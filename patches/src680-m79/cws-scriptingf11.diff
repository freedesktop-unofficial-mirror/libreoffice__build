Index: scripting/examples/java/build.xml
===================================================================
RCS file: /cvs/framework/scripting/examples/java/build.xml,v
retrieving revision 1.11
retrieving revision 1.11.2.1
diff -u -p -r1.11 -r1.11.2.1
--- scripting/examples/java/build.xml	27 Jan 2005 15:26:29 -0000	1.11
+++ scripting/examples/java/build.xml	7 Feb 2005 15:22:10 -0000	1.11.2.1
@@ -171,6 +171,6 @@
   </target>
 
   <!-- ========================= All In One Build ======================= -->
-  <target name="all" depends="HelloWorld,Highlight,MemoryUsage,selector"/>
+  <target name="all" depends="HelloWorld,Highlight,MemoryUsage"/>
  
 </project>
Index: scripting/java/com/sun/star/script/framework/provider/beanshell/ScriptProviderForBeanShell.java
===================================================================
RCS file: /cvs/framework/scripting/java/com/sun/star/script/framework/provider/beanshell/ScriptProviderForBeanShell.java,v
retrieving revision 1.7
retrieving revision 1.7.22.1
diff -u -p -r1.7 -r1.7.22.1
--- scripting/java/com/sun/star/script/framework/provider/beanshell/ScriptProviderForBeanShell.java	22 Oct 2004 14:49:31 -0000	1.7
+++ scripting/java/com/sun/star/script/framework/provider/beanshell/ScriptProviderForBeanShell.java	18 Feb 2005 17:13:53 -0000	1.7.22.1
@@ -335,20 +335,20 @@ class ScriptImpl implements XScript
                 ScriptEditorForBeanShell editor =
                     ScriptEditorForBeanShell.getEditor(
                        sourceUrl );
+
                 if ( editor != null )
                 {
-                    editor.execute();
-                }
+                    result = editor.execute();
 
-                if (editor != null && editor.isModified())
-                {
-                    source = editor.getText();
-                }
-                else
-                {
-                    metaData.loadSource();  
-                    source = metaData.getSource();
+                    if (result == null)
+                    {
+                        return new Any(new Type(), null);
+                    }
+                    return result;
                 }
+
+                metaData.loadSource();  
+                source = metaData.getSource();
 
                 if ( source == null || source.length() == 0 )
                 {
Index: scripting/source/provider/MasterScriptProviderFactory.cxx
===================================================================
RCS file: /cvs/framework/scripting/source/provider/MasterScriptProviderFactory.cxx,v
retrieving revision 1.5
retrieving revision 1.5.2.1
diff -u -p -r1.5 -r1.5.2.1
--- scripting/source/provider/MasterScriptProviderFactory.cxx	27 Jan 2005 15:32:17 -0000	1.5
+++ scripting/source/provider/MasterScriptProviderFactory.cxx	10 Feb 2005 13:57:23 -0000	1.5.2.1
@@ -89,7 +89,13 @@ MasterScriptProviderFactory::MasterScrip
 
 MasterScriptProviderFactory::~MasterScriptProviderFactory()
 {
-    if (m_MSPList) delete m_MSPList;
+    // by setting m_MSPListHolder to an empty reference the existing
+    // Reference to the ActiveMSPList object will get released causing
+    // the ActiveMSPList to get destructed
+    if (m_MSPListHolder.is())
+    {
+        m_MSPListHolder = Reference< lang::XEventListener >();
+    }
 }
 
 
Index: rhino/Codegen.java
===================================================================
RCS file: rhino/Codegen.java
diff -N rhino/Codegen.java
--- rhino/Codegen.java	22 Oct 2004 14:12:53 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,3765 +0,0 @@
-/*
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-2000 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Norris Boyd
- * Roger Lawrence
- * Andi Vajda
- * Kemal Bayram
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-
-package org.mozilla.javascript.optimizer;
-
-import org.mozilla.javascript.*;
-import org.mozilla.classfile.*;
-import java.util.*;
-import java.io.IOException;
-import java.lang.reflect.Constructor;
-
-/**
- * This class generates code for a given IR tree.
- *
- * @author Norris Boyd
- * @author Roger Lawrence
- */
-
-public class Codegen extends Interpreter {
-
-    public Codegen() {
-    }
-
-    public IRFactory createIRFactory(TokenStream ts,
-                                     ClassNameHelper nameHelper, Scriptable scope)
-    {
-        return new OptIRFactory(ts, nameHelper, scope);
-    }
-
-    public Node transform(Node tree, TokenStream ts, Scriptable scope) {
-        OptTransformer opt = new OptTransformer(new Hashtable(11));
-        return opt.transform(tree, null, ts, scope);
-    }
-
-    public Object compile(Context cx, Scriptable scope, Node tree,
-                          Object securityDomain,
-                          SecurityController securityController,
-                          ClassNameHelper cnh)
-    {
-        ObjArray classFiles = new ObjArray();
-        ObjArray names = new ObjArray();
-        String generatedName = null;
-
-        OptClassNameHelper nameHelper = (OptClassNameHelper) cnh;
-
-        Exception e = null;
-        Class result = null;
-        ClassLoader parentLoader = cx.getApplicationClassLoader();
-        GeneratedClassLoader loader;
-        if (securityController == null) {
-            loader = cx.createClassLoader(parentLoader);
-        } else {
-            loader = securityController.createClassLoader(parentLoader,
-                                                          securityDomain);
-        }
-        nameHelper.reset();
-
-        try {
-            if (cx.getOptimizationLevel() > 0) {
-                (new Optimizer()).optimize(tree, cx.getOptimizationLevel());
-            }
-            generatedName = generateCode(tree, names, classFiles, nameHelper);
-
-            ClassRepository repository = nameHelper.getClassRepository();
-
-            for (int i=0; i < names.size(); i++) {
-                String name = (String) names.get(i);
-                byte[] classFile = (byte[]) classFiles.get(i);
-                boolean isTopLevel = name.equals(generatedName);
-                try {
-                    if (repository.storeClass(name, classFile, isTopLevel)) {
-                        Class cl = loader.defineClass(name, classFile);
-                        if (isTopLevel) {
-                            result = cl;
-                        }
-                    }
-                } catch (ClassFormatError ex) {
-                    throw new RuntimeException(ex.toString());
-                } catch (IOException iox) {
-                    throw WrappedException.wrapException(iox);
-                }
-            }
-            if (result != null) {
-                loader.linkClass(result);
-            }
-        } catch (SecurityException x) {
-            e = x;
-        } catch (IllegalArgumentException x) {
-            e = x;
-        }
-        if (e != null)
-            throw new RuntimeException("Malformed optimizer package " + e);
-
-        Class[] interfaces = nameHelper.getTargetImplements();
-        Class superClass = nameHelper.getTargetExtends();
-        if (interfaces != null || superClass != null) {
-            String name = nameHelper.getJavaScriptClassName(null, true);
-            ScriptableObject obj = new NativeObject();
-            for (Node cursor = tree.getFirstChild(); cursor != null;
-                 cursor = cursor.getNext())
-            {
-                if (cursor.getType() == TokenStream.FUNCTION) {
-                    OptFunctionNode fnNode
-                        = (OptFunctionNode)cursor.getProp(Node.FUNCTION_PROP);
-                    obj.put(fnNode.getFunctionName(), obj, fnNode);
-                }
-            }
-            if (superClass == null)
-                superClass = Object.class;
-            try {
-                JavaAdapter.createAdapterClass(cx, obj, name,
-                                               superClass,
-                                               interfaces,
-                                               generatedName,
-                                               nameHelper);
-            } catch (ClassNotFoundException exn) {
-                // should never happen
-                throw new Error(exn.toString());
-            }
-        }
-        if (result == null)
-            return null;
-        if (tree instanceof OptFunctionNode) {
-            NativeFunction f;
-            try {
-                Constructor ctor = result.getConstructors()[0];
-                Object[] initArgs = { scope, cx };
-                f = (NativeFunction)ctor.newInstance(initArgs);
-            } catch (Exception ex) {
-                throw new RuntimeException
-                    ("Unable to instantiate compiled class:"+ex.toString());
-            }
-            OptFunctionNode fnNode = (OptFunctionNode)tree;
-            OptRuntime.initFunction(f, fnNode.getFunctionType(), scope, cx);
-            return f;
-        } else {
-            NativeScript script;
-            try {
-                script = (NativeScript) result.newInstance();
-            } catch (Exception ex) {
-                throw new RuntimeException
-                    ("Unable to instantiate compiled class:"+ex.toString());
-            }
-            if (scope != null) {
-                script.setPrototype(script.getClassPrototype(scope, "Script"));
-                script.setParentScope(scope);
-            }
-            return script;
-        }
-    }
-
-    void addByteCode(byte theOpcode)
-    {
-        classFile.add(theOpcode);
-    }
-
-    void addByteCode(byte theOpcode, int theOperand)
-    {
-        classFile.add(theOpcode, theOperand);
-    }
-
-    void addByteCode(byte theOpcode, String className)
-    {
-        classFile.add(theOpcode, className);
-    }
-
-    void addVirtualInvoke(String className, String methodName, String parameterSignature, String resultSignature)
-    {
-        classFile.add(ByteCode.INVOKEVIRTUAL,
-                        className,
-                        methodName,
-                        parameterSignature,
-                        resultSignature);
-    }
-
-    void addStaticInvoke(String className, String methodName, String parameterSignature, String resultSignature)
-    {
-        classFile.add(ByteCode.INVOKESTATIC,
-                        className,
-                        methodName,
-                        parameterSignature,
-                        resultSignature);
-    }
-
-    void addScriptRuntimeInvoke(String methodName, String parameterSignature, String resultSignature)
-    {
-        classFile.add(ByteCode.INVOKESTATIC,
-                        "org/mozilla/javascript/ScriptRuntime",
-                        methodName,
-                        parameterSignature,
-                        resultSignature);
-    }
-
-    void addOptRuntimeInvoke(String methodName, String parameterSignature, String resultSignature)
-    {
-        classFile.add(ByteCode.INVOKESTATIC,
-                        "org/mozilla/javascript/optimizer/OptRuntime",
-                        methodName,
-                        parameterSignature,
-                        resultSignature);
-    }
-
-    void addSpecialInvoke(String className, String methodName, String parameterSignature, String resultSignature)
-    {
-        classFile.add(ByteCode.INVOKESPECIAL,
-                        className,
-                        methodName,
-                        parameterSignature,
-                        resultSignature);
-    }
-
-    void addDoubleConstructor()
-    {
-        classFile.add(ByteCode.INVOKESPECIAL,
-                                "java/lang/Double",
-                                "<init>", "(D)", "V");
-    }
-
-    private void markLabel(int label)
-    {
-        classFile.markLabel(label);
-    }
-
-    private void markLabel(int label, short stackheight)
-    {
-        classFile.markLabel(label, stackheight);
-    }
-
-    private int acquireLabel()
-    {
-        return classFile.acquireLabel();
-    }
-
-    public void emitDirectConstructor(OptFunctionNode fnNode)
-    {
-/*
-    we generate ..
-        Scriptable directConstruct(<directCallArgs>) {
-            Scriptable newInstance = new NativeObject();
-            newInstance.setPrototype(getClassPrototype());
-            newInstance.setParentScope(getParentScope());
-
-            Object val = callDirect(<directCallArgs>);
-            // except that the incoming thisArg is discarded
-            // and replaced by newInstance
-            //
-
-            if (val != null && val != Undefined.instance &&
-                val instanceof Scriptable)
-            {
-                return (Scriptable) val;
-            }
-            return newInstance;
-        }
-*/
-        short flags = (short)(ClassFileWriter.ACC_PUBLIC
-                            | ClassFileWriter.ACC_FINAL);
-        classFile.startMethod("constructDirect",
-                        fnNode.getDirectCallParameterSignature()
-                            + "Ljava/lang/Object;",
-                        flags);
-
-        int argCount = fnNode.getVariableTable().getParameterCount();
-        short firstLocal = (short)((4 + argCount * 3) + 1);
-
-        addByteCode(ByteCode.NEW, "org/mozilla/javascript/NativeObject");
-        addByteCode(ByteCode.DUP);
-        classFile.add(ByteCode.INVOKESPECIAL,
-                                "org/mozilla/javascript/NativeObject",
-                                "<init>", "()", "V");
-        astore(firstLocal);
-
-        aload(firstLocal);
-        aload((short)0);
-        addVirtualInvoke("org/mozilla/javascript/NativeFunction",
-                            "getClassPrototype",
-                            "()", "Lorg/mozilla/javascript/Scriptable;");
-        classFile.add(ByteCode.INVOKEINTERFACE,
-                        "org/mozilla/javascript/Scriptable",
-                        "setPrototype",
-                        "(Lorg/mozilla/javascript/Scriptable;)",
-                        "V");
-
-
-        aload(firstLocal);
-        aload((short)0);
-        addVirtualInvoke("org/mozilla/javascript/NativeFunction",
-                            "getParentScope",
-                            "()", "Lorg/mozilla/javascript/Scriptable;");
-        classFile.add(ByteCode.INVOKEINTERFACE,
-                        "org/mozilla/javascript/Scriptable",
-                        "setPrototype",
-                        "(Lorg/mozilla/javascript/Scriptable;)",
-                        "V");
-
-
-        aload((short)0);
-        aload((short)1);
-        aload((short)2);
-        aload(firstLocal);
-        for (int i = 0; i < argCount; i++) {
-            aload((short)(4 + (i * 3)));
-            dload((short)(5 + (i * 3)));
-        }
-        aload((short)(4 + argCount * 3));
-        addVirtualInvoke(this.name,
-                            "callDirect",
-                            fnNode.getDirectCallParameterSignature(),
-                            "Ljava/lang/Object;");
-        astore((short)(firstLocal + 1));
-
-        int exitLabel = acquireLabel();
-        aload((short)(firstLocal + 1));
-        addByteCode(ByteCode.IFNULL, exitLabel);
-        aload((short)(firstLocal + 1));
-        pushUndefined();
-        addByteCode(ByteCode.IF_ACMPEQ, exitLabel);
-        aload((short)(firstLocal + 1));
-        addByteCode(ByteCode.INSTANCEOF, "org/mozilla/javascript/Scriptable");
-        addByteCode(ByteCode.IFEQ, exitLabel);
-        aload((short)(firstLocal + 1));
-        addByteCode(ByteCode.CHECKCAST, "org/mozilla/javascript/Scriptable");
-        addByteCode(ByteCode.ARETURN);
-        markLabel(exitLabel);
-
-        aload(firstLocal);
-        addByteCode(ByteCode.ARETURN);
-
-        classFile.stopMethod((short)(firstLocal + 2), null);
-
-    }
-
-    public String generateCode(Node tree, ObjArray names, ObjArray classFiles,
-                               OptClassNameHelper nameHelper)
-    {
-        ObjArray fns = (ObjArray) tree.getProp(Node.FUNCTION_PROP);
-        if (fns != null) {
-            for (int i = 0; i != fns.size(); ++i) {
-                OptFunctionNode fn = (OptFunctionNode) fns.get(i);
-                Codegen codegen = new Codegen();
-                codegen.generateCode(fn, names, classFiles, nameHelper);
-            }
-        }
-
-        Context cx = Context.getCurrentContext();
-        itsUseDynamicScope = cx.hasCompileFunctionsWithDynamicScope();
-
-        itsSourceFile = null;
-        // default is to generate debug info
-        if (!cx.isGeneratingDebugChanged() || cx.isGeneratingDebug())
-            itsSourceFile = (String) tree.getProp(Node.SOURCENAME_PROP);
-        version = cx.getLanguageVersion();
-        optLevel = cx.getOptimizationLevel();
-        inFunction = tree.getType() == TokenStream.FUNCTION;
-        superClassName = inFunction
-                         ? functionSuperClassName
-                         : scriptSuperClassName;
-        superClassSlashName = superClassName.replace('.', '/');
-
-        Node codegenBase;
-        if (inFunction) {
-            OptFunctionNode fnNode = (OptFunctionNode) tree;
-            inDirectCallFunction = fnNode.isTargetOfDirectCall();
-            vars = fnNode.getVariableTable();
-            this.name = fnNode.getClassName();
-            classFile = new ClassFileWriter(name, superClassName, itsSourceFile);
-            Node args = tree.getFirstChild();
-            String name = fnNode.getFunctionName();
-            generateInit(cx, "<init>", tree, name, args);
-            if (fnNode.isTargetOfDirectCall()) {
-                classFile.startMethod("call",
-                                      "(Lorg/mozilla/javascript/Context;" +
-                                      "Lorg/mozilla/javascript/Scriptable;" +
-                                      "Lorg/mozilla/javascript/Scriptable;" +
-                                      "[Ljava/lang/Object;)Ljava/lang/Object;",
-                                      (short)(ClassFileWriter.ACC_PUBLIC
-                                              | ClassFileWriter.ACC_FINAL));
-                addByteCode(ByteCode.ALOAD_0);
-                addByteCode(ByteCode.ALOAD_1);
-                addByteCode(ByteCode.ALOAD_2);
-                addByteCode(ByteCode.ALOAD_3);
-                for (int i = 0; i < vars.getParameterCount(); i++) {
-                    push(i);
-                    addByteCode(ByteCode.ALOAD, 4);
-                    addByteCode(ByteCode.ARRAYLENGTH);
-                    int undefArg = acquireLabel();
-                    int beyond = acquireLabel();
-                    addByteCode(ByteCode.IF_ICMPGE, undefArg);
-                    addByteCode(ByteCode.ALOAD, 4);
-                    push(i);
-                    addByteCode(ByteCode.AALOAD);
-                    push(0.0);
-                    addByteCode(ByteCode.GOTO, beyond);
-                    markLabel(undefArg);
-                    pushUndefined();
-                    push(0.0);
-                    markLabel(beyond);
-                }
-                addByteCode(ByteCode.ALOAD, 4);
-                addVirtualInvoke(this.name,
-                                "callDirect",
-                                fnNode.getDirectCallParameterSignature(),
-                                "Ljava/lang/Object;");
-                addByteCode(ByteCode.ARETURN);
-                classFile.stopMethod((short)5, null);
-                // 1 for this, 1 for js this, 1 for args[]
-
-                emitDirectConstructor(fnNode);
-
-                startNewMethod("callDirect",
-                               fnNode.getDirectCallParameterSignature() +
-                                "Ljava/lang/Object;",
-                               1, false, true);
-                assignParameterJRegs(vars);
-                if (!fnNode.getParameterNumberContext()) {
-                    // make sure that all parameters are objects
-                    itsForcedObjectParameters = true;
-                    for (int i = 0; i < vars.getParameterCount(); i++) {
-                        OptLocalVariable lVar = OptLocalVariable.get(vars, i);
-                        aload(lVar.getJRegister());
-                        classFile.add(ByteCode.GETSTATIC,
-                                      "java/lang/Void",
-                                      "TYPE",
-                                      "Ljava/lang/Class;");
-                        int isObjectLabel = acquireLabel();
-                        addByteCode(ByteCode.IF_ACMPNE, isObjectLabel);
-                        addByteCode(ByteCode.NEW,"java/lang/Double");
-                        addByteCode(ByteCode.DUP);
-                        dload((short)(lVar.getJRegister() + 1));
-                        addDoubleConstructor();
-                        astore(lVar.getJRegister());
-                        markLabel(isObjectLabel);
-                    }
-                }
-                generatePrologue(cx, tree, true, vars.getParameterCount());
-            } else {
-                startNewMethod("call",
-                               "(Lorg/mozilla/javascript/Context;" +
-                                "Lorg/mozilla/javascript/Scriptable;" +
-                                "Lorg/mozilla/javascript/Scriptable;" +
-                               "[Ljava/lang/Object;)Ljava/lang/Object;",
-                               1, false, true);
-                generatePrologue(cx, tree, true, -1);
-            }
-            codegenBase = tree.getLastChild();
-        } else {
-            // better be a script
-            if (tree.getType() != TokenStream.SCRIPT)
-                badTree();
-            vars = (VariableTable) tree.getProp(Node.VARS_PROP);
-            boolean isPrimary = nameHelper.getTargetExtends() == null &&
-                                nameHelper.getTargetImplements() == null;
-            this.name = nameHelper.getJavaScriptClassName(null, isPrimary);
-            classFile = new ClassFileWriter(name, superClassName, itsSourceFile);
-            classFile.addInterface("org/mozilla/javascript/Script");
-            generateScriptCtor(cx, tree);
-            generateMain(cx);
-            generateInit(cx, "initScript", tree, "", null);
-            generateExecute(cx);
-            startNewMethod("call",
-                           "(Lorg/mozilla/javascript/Context;" +
-                            "Lorg/mozilla/javascript/Scriptable;" +
-                            "Lorg/mozilla/javascript/Scriptable;" +
-                            "[Ljava/lang/Object;)Ljava/lang/Object;",
-                           1, false, true);
-            generatePrologue(cx, tree, false, -1);
-            int linenum = tree.getIntProp(Node.END_LINENO_PROP, -1);
-            if (linenum != -1)
-              classFile.addLineNumberEntry((short)linenum);
-            tree.addChildToBack(new Node(TokenStream.RETURN));
-            codegenBase = tree;
-        }
-
-        generateCodeFromNode(codegenBase, null, -1, -1);
-
-        generateEpilogue();
-
-        finishMethod(cx, debugVars);
-
-        emitConstantDudeInitializers();
-
-        byte[] bytes = classFile.toByteArray();
-
-        names.add(name);
-        classFiles.add(bytes);
-
-        classFile = null;
-
-        return name;
-    }
-
-    private static void assignParameterJRegs(VariableTable vars) {
-        // 0 is reserved for function Object 'this'
-        // 1 is reserved for context
-        // 2 is reserved for parentScope
-        // 3 is reserved for script 'this'
-        short jReg = 4;
-        int parameterCount = vars.getParameterCount();
-        for (int i = 0; i < parameterCount; i++) {
-            OptLocalVariable lVar = OptLocalVariable.get(vars, i);
-            lVar.assignJRegister(jReg);
-            jReg += 3;  // 3 is 1 for Object parm and 2 for double parm
-        }
-    }
-
-    private void generateCodeFromNode(Node node, Node parent, int trueLabel,
-                                      int falseLabel)
-    {
-        // System.out.println("gen code for " + node.toString());
-
-        int type = node.getType();
-        Node child = node.getFirstChild();
-        switch (type) {
-              case TokenStream.LOOP:
-              case TokenStream.WITH:
-              case TokenStream.LABEL:
-                visitStatement(node);
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                break;
-
-              case TokenStream.CASE:
-              case TokenStream.DEFAULT:
-                // XXX shouldn't these be StatementNodes?
-
-              case TokenStream.SCRIPT:
-              case TokenStream.BLOCK:
-              case TokenStream.VOID:
-              case TokenStream.NOP:
-                // no-ops.
-                visitStatement(node);
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                break;
-
-              case TokenStream.FUNCTION:
-                if (inFunction || parent.getType() != TokenStream.SCRIPT) {
-                    OptFunctionNode fn
-                        = (OptFunctionNode) node.getProp(Node.FUNCTION_PROP);
-                    int t = fn.getFunctionType();
-                    if (t != FunctionNode.FUNCTION_STATEMENT) {
-                        visitFunction(fn, t);
-                    }
-                }
-                break;
-
-              case TokenStream.NAME:
-                visitName(node);
-                break;
-
-              case TokenStream.NEW:
-              case TokenStream.CALL:
-                visitCall(node, type, child);
-                break;
-
-              case TokenStream.NUMBER:
-              case TokenStream.STRING:
-                visitLiteral(node);
-                break;
-
-              case TokenStream.PRIMARY:
-                visitPrimary(node);
-                break;
-
-              case TokenStream.REGEXP:
-                visitObject(node);
-                break;
-
-              case TokenStream.TRY:
-                visitTryCatchFinally(node, child);
-                break;
-
-              case TokenStream.THROW:
-                visitThrow(node, child);
-                break;
-
-              case TokenStream.RETURN:
-                visitReturn(node, child);
-                break;
-
-              case TokenStream.SWITCH:
-                visitSwitch(node, child);
-                break;
-
-              case TokenStream.COMMA: {
-                Node next = child.getNext();
-                while (next != null) {
-                    generateCodeFromNode(child, node, -1, -1);
-                    addByteCode(ByteCode.POP);
-                    child = next;
-                    next = next.getNext();
-                }
-                generateCodeFromNode(child, node, trueLabel, falseLabel);
-                break;
-              }
-
-              case TokenStream.NEWSCOPE:
-                addScriptRuntimeInvoke("newScope", "()",
-                                       "Lorg/mozilla/javascript/Scriptable;");
-                break;
-
-              case TokenStream.ENTERWITH:
-                visitEnterWith(node, child);
-                break;
-
-              case TokenStream.LEAVEWITH:
-                visitLeaveWith(node, child);
-                break;
-
-              case TokenStream.ENUMINIT:
-                visitEnumInit(node, child);
-                break;
-
-              case TokenStream.ENUMNEXT:
-                visitEnumNext(node, child);
-                break;
-
-              case TokenStream.ENUMDONE:
-                visitEnumDone(node, child);
-                break;
-
-              case TokenStream.POP:
-                visitStatement(node);
-                if (child.getType() == TokenStream.SETVAR) {
-                    /* special case this so as to avoid unnecessary
-                    load's & pop's */
-                    visitSetVar(child, child.getFirstChild(), false);
-                }
-                else {
-                    while (child != null) {
-                        generateCodeFromNode(child, node, trueLabel, falseLabel);
-                        child = child.getNext();
-                    }
-                    if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1)
-                        addByteCode(ByteCode.POP2);
-                    else
-                        addByteCode(ByteCode.POP);
-                }
-                break;
-
-              case TokenStream.POPV:
-                visitStatement(node);
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                astore(scriptResultLocal);
-                break;
-
-              case TokenStream.TARGET:
-                visitTarget(node);
-                break;
-
-              case TokenStream.JSR:
-              case TokenStream.GOTO:
-              case TokenStream.IFEQ:
-              case TokenStream.IFNE:
-                visitGOTO(node, type, child);
-                break;
-
-              case TokenStream.UNARYOP:
-                visitUnary(node, child, trueLabel, falseLabel);
-                break;
-
-              case TokenStream.TYPEOF:
-                visitTypeof(node, child);
-                break;
-
-              case TokenStream.INC:
-                visitIncDec(node, true);
-                break;
-
-              case TokenStream.DEC:
-                visitIncDec(node, false);
-                break;
-
-              case TokenStream.OR:
-              case TokenStream.AND: {
-                    if (trueLabel == -1) {
-                        generateCodeFromNode(child, node, trueLabel, falseLabel);
-                        addByteCode(ByteCode.DUP);
-                        addScriptRuntimeInvoke("toBoolean", "(Ljava/lang/Object;)", "Z");
-                        int falseTarget = acquireLabel();
-                        if (type == TokenStream.AND)
-                            addByteCode(ByteCode.IFEQ, falseTarget);
-                        else
-                            addByteCode(ByteCode.IFNE, falseTarget);
-                        addByteCode(ByteCode.POP);
-                        generateCodeFromNode(child.getNext(), node, trueLabel, falseLabel);
-                        markLabel(falseTarget);
-                    }
-                    else {
-                        int interLabel = acquireLabel();
-                        if (type == TokenStream.AND) {
-                            generateCodeFromNode(child, node, interLabel,
-                                                 falseLabel);
-                            if (!childIsBoolean(child)) {
-                                addScriptRuntimeInvoke("toBoolean",
-                                                "(Ljava/lang/Object;)", "Z");
-                                addByteCode(ByteCode.IFNE, interLabel);
-                                addByteCode(ByteCode.GOTO, falseLabel);
-                            }
-                        }
-                        else {
-                            generateCodeFromNode(child, node, trueLabel, interLabel);
-                            if (!childIsBoolean(child)) {
-                                addScriptRuntimeInvoke("toBoolean",
-                                                "(Ljava/lang/Object;)", "Z");
-                                addByteCode(ByteCode.IFNE, trueLabel);
-                                addByteCode(ByteCode.GOTO, interLabel);
-                            }
-                        }
-                        markLabel(interLabel);
-                        child = child.getNext();
-                        generateCodeFromNode(child, node, trueLabel, falseLabel);
-                        if (!childIsBoolean(child)) {
-                            addScriptRuntimeInvoke("toBoolean",
-                                            "(Ljava/lang/Object;)", "Z");
-                            addByteCode(ByteCode.IFNE, trueLabel);
-                            addByteCode(ByteCode.GOTO, falseLabel);
-                        }
-                    }
-                }
-                break;
-
-              case TokenStream.ADD: {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    generateCodeFromNode(child.getNext(),
-                                                 node, trueLabel, falseLabel);
-                    switch (node.getIntProp(Node.ISNUMBER_PROP, -1)) {
-                        case Node.BOTH:
-                            addByteCode(ByteCode.DADD);
-                            break;
-                        case Node.LEFT:
-                                addOptRuntimeInvoke("add",
-                                "(DLjava/lang/Object;)", "Ljava/lang/Object;");
-                            break;
-                        case Node.RIGHT:
-                                addOptRuntimeInvoke("add",
-                                "(Ljava/lang/Object;D)", "Ljava/lang/Object;");
-                            break;
-                        default:
-                        addScriptRuntimeInvoke("add",
-                                    "(Ljava/lang/Object;Ljava/lang/Object;)",
-                                    "Ljava/lang/Object;");
-                    }
-                }
-                break;
-
-              case TokenStream.MUL:
-                visitArithmetic(node, ByteCode.DMUL, child, parent);
-                break;
-
-              case TokenStream.SUB:
-                visitArithmetic(node, ByteCode.DSUB, child, parent);
-                break;
-
-              case TokenStream.DIV:
-              case TokenStream.MOD:
-                visitArithmetic(node, type == TokenStream.DIV
-                                      ? ByteCode.DDIV
-                                      : ByteCode.DREM, child, parent);
-                break;
-
-              case TokenStream.BITOR:
-              case TokenStream.BITXOR:
-              case TokenStream.BITAND:
-              case TokenStream.LSH:
-              case TokenStream.RSH:
-              case TokenStream.URSH:
-                visitBitOp(node, type, child);
-                break;
-
-              case TokenStream.CONVERT: {
-                    Object toType = node.getProp(Node.TYPE_PROP);
-                    if (toType == ScriptRuntime.NumberClass) {
-                        addByteCode(ByteCode.NEW, "java/lang/Double");
-                        addByteCode(ByteCode.DUP);
-                        generateCodeFromNode(child, node, trueLabel, falseLabel);
-                        addScriptRuntimeInvoke("toNumber",
-                                              "(Ljava/lang/Object;)", "D");
-                        addDoubleConstructor();
-                    }
-                    else {
-                        if (toType == ScriptRuntime.DoubleClass) {
-                                                               // cnvt to double
-                                                               // (not Double)
-                            generateCodeFromNode(child, node, trueLabel, falseLabel);
-                            addScriptRuntimeInvoke("toNumber",
-                                             "(Ljava/lang/Object;)", "D");
-                        }
-                        else {
-                            if (toType == ScriptRuntime.ObjectClass) {
-                                // convert from double
-                                int prop = -1;
-                                if (child.getType() == TokenStream.NUMBER) {
-                                    prop = child.getIntProp(Node.ISNUMBER_PROP,
-                                                            -1);
-                                }
-                                if (prop != -1) {
-                                    child.removeProp(Node.ISNUMBER_PROP);
-                                    generateCodeFromNode(child, node, trueLabel,
-                                                         falseLabel);
-                                    child.putIntProp(Node.ISNUMBER_PROP, prop);
-                                }
-                                else {
-                                    addByteCode(ByteCode.NEW, "java/lang/Double");
-                                    addByteCode(ByteCode.DUP);
-                                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                                    addDoubleConstructor();
-                                }
-                            }
-                            else
-                                badTree();
-                        }
-                    }
-                }
-                break;
-
-              case TokenStream.RELOP:
-                if (trueLabel == -1)    // need a result Object
-                    visitRelOp(node, child, parent);
-                else
-                    visitGOTOingRelOp(node, child, parent, trueLabel, falseLabel);
-                break;
-
-              case TokenStream.EQOP:
-                visitEqOp(node, child, parent, trueLabel, falseLabel);
-                break;
-
-              case TokenStream.GETPROP:
-                visitGetProp(node, child);
-                break;
-
-              case TokenStream.GETELEM:
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                aload(variableObjectLocal);
-                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-                    addOptRuntimeInvoke("getElem",
-                                      "(Ljava/lang/Object;D" +
-                                      "Lorg/mozilla/javascript/Scriptable;)",
-                                      "Ljava/lang/Object;");
-                }
-                else {
-                    addScriptRuntimeInvoke("getElem",
-                                      "(Ljava/lang/Object;Ljava/lang/Object;" +
-                                      "Lorg/mozilla/javascript/Scriptable;)",
-                                      "Ljava/lang/Object;");
-                }
-                break;
-
-              case TokenStream.GETVAR: {
-                OptLocalVariable lVar
-                        = (OptLocalVariable)(node.getProp(Node.VARIABLE_PROP));
-                visitGetVar(lVar,
-                            node.getIntProp(Node.ISNUMBER_PROP, -1) != -1,
-                            node.getString());
-              }
-              break;
-
-              case TokenStream.SETVAR:
-                visitSetVar(node, child, true);
-                break;
-
-              case TokenStream.SETNAME:
-                visitSetName(node, child);
-                break;
-
-              case TokenStream.SETPROP:
-                visitSetProp(node, child);
-                break;
-
-              case TokenStream.SETELEM:
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                aload(variableObjectLocal);
-                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-                    addOptRuntimeInvoke("setElem",
-                              "(Ljava/lang/Object;D" +
-                              "Ljava/lang/Object;Lorg/mozilla/javascript/Scriptable;)",
-                              "Ljava/lang/Object;");
-                }
-                else {
-                    addScriptRuntimeInvoke("setElem",
-                              "(Ljava/lang/Object;Ljava/lang/Object;" +
-                              "Ljava/lang/Object;Lorg/mozilla/javascript/Scriptable;)",
-                              "Ljava/lang/Object;");
-                }
-                break;
-
-              case TokenStream.DELPROP:
-                while (child != null) {
-                    generateCodeFromNode(child, node, trueLabel, falseLabel);
-                    child = child.getNext();
-                }
-                addScriptRuntimeInvoke("delete",
-                          "(Ljava/lang/Object;Ljava/lang/Object;)",
-                          "Ljava/lang/Object;");
-                break;
-
-              case TokenStream.BINDNAME:
-              case TokenStream.GETBASE:
-                visitBind(node, type, child);
-                break;
-
-              case TokenStream.GETTHIS:
-                generateCodeFromNode(child, node, trueLabel, falseLabel);
-                addScriptRuntimeInvoke("getThis",
-                          "(Lorg/mozilla/javascript/Scriptable;)",
-                          "Lorg/mozilla/javascript/Scriptable;");
-                break;
-
-              case TokenStream.PARENT:
-                generateCodeFromNode(child, node, trueLabel, falseLabel);
-                addScriptRuntimeInvoke("getParent",
-                              "(Ljava/lang/Object;)",
-                              "Lorg/mozilla/javascript/Scriptable;");
-                break;
-
-              case TokenStream.NEWTEMP:
-                visitNewTemp(node, child);
-                break;
-
-              case TokenStream.USETEMP:
-                visitUseTemp(node, child);
-                break;
-
-              case TokenStream.NEWLOCAL:
-                visitNewLocal(node, child);
-                break;
-
-              case TokenStream.USELOCAL:
-                visitUseLocal(node, child);
-                break;
-
-              default:
-                throw new RuntimeException("Unexpected node type " +
-                          TokenStream.tokenToName(type));
-        }
-
-    }
-
-    private void startNewMethod(String methodName, String methodDesc,
-                                int parmCount, boolean isStatic,
-                                boolean isFinal)
-    {
-        locals = new boolean[MAX_LOCALS];
-        localsMax = (short) (parmCount+1);  // number of parms + "this"
-        firstFreeLocal = 0;
-        contextLocal = -1;
-        variableObjectLocal = -1;
-        scriptResultLocal = -1;
-        argsLocal = -1;
-        thisObjLocal = -1;
-        funObjLocal = -1;
-        debug_pcLocal = -1;
-        debugStopSubRetLocal = -1;
-        itsZeroArgArray = -1;
-        itsOneArgArray = -1;
-        short flags = ClassFileWriter.ACC_PUBLIC;
-        if (isStatic)
-            flags |= ClassFileWriter.ACC_STATIC;
-        if (isFinal)
-            flags |= ClassFileWriter.ACC_FINAL;
-        epilogueLabel = -1;
-        classFile.startMethod(methodName, methodDesc, (short) flags);
-    }
-
-    private void finishMethod(Context cx, VariableTable vars) {
-        OptLocalVariable[] array = OptLocalVariable.toArray(vars);
-        classFile.stopMethod((short)(localsMax + 1), array);
-        contextLocal = -1;
-    }
-
-    private void generateMain(Context cx) {
-        startNewMethod("main", "([Ljava/lang/String;)V", 1, true, true);
-
-        push(this.name);        // load the name of this class
-        classFile.add(ByteCode.INVOKESTATIC,
-                      "java/lang/Class",
-                      "forName",
-                      "(Ljava/lang/String;)",
-                      "Ljava/lang/Class;");
-        addByteCode(ByteCode.ALOAD_0); // load 'args'
-        addScriptRuntimeInvoke("main",
-                              "(Ljava/lang/Class;[Ljava/lang/String;)",
-                              "V");
-        addByteCode(ByteCode.RETURN);
-        finishMethod(cx, null);
-    }
-
-    private void generateExecute(Context cx) {
-        String signature = "(Lorg/mozilla/javascript/Context;" +
-                            "Lorg/mozilla/javascript/Scriptable;)" +
-                           "Ljava/lang/Object;";
-        startNewMethod("exec", signature, 2, false, true);
-        String slashName = this.name.replace('.', '/');
-
-        if (!trivialInit) {
-            // to begin a script, call the initScript method
-            addByteCode(ByteCode.ALOAD_0); // load 'this'
-            addByteCode(ByteCode.ALOAD_2); // load 'scope'
-            addByteCode(ByteCode.ALOAD_1); // load 'cx'
-            addVirtualInvoke(slashName,
-                          "initScript",
-                          "(Lorg/mozilla/javascript/Scriptable;" +
-                          "Lorg/mozilla/javascript/Context;)",
-                          "V");
-        }
-
-        addByteCode(ByteCode.ALOAD_0); // load 'this'
-        addByteCode(ByteCode.ALOAD_1); // load 'cx'
-        addByteCode(ByteCode.ALOAD_2); // load 'scope'
-        addByteCode(ByteCode.DUP);
-        addByteCode(ByteCode.ACONST_NULL);
-        addVirtualInvoke(slashName,
-                      "call",
-                      "(Lorg/mozilla/javascript/Context;" +
-                       "Lorg/mozilla/javascript/Scriptable;" +
-                       "Lorg/mozilla/javascript/Scriptable;" +
-                       "[Ljava/lang/Object;)",
-                      "Ljava/lang/Object;");
-
-        addByteCode(ByteCode.ARETURN);
-        finishMethod(cx, null);
-    }
-
-    private void generateScriptCtor(Context cx, Node tree) {
-        startNewMethod("<init>", "()V", 1, false, false);
-        addByteCode(ByteCode.ALOAD_0);
-        addSpecialInvoke(superClassSlashName,
-                      "<init>", "()", "V");
-        addByteCode(ByteCode.RETURN);
-        finishMethod(cx, null);
-    }
-
-    /**
-     * Indicate that the init is non-trivial.
-     *
-     * For trivial inits we can omit creating the init method
-     * altogether. (Only applies to scripts, since function
-     * inits are constructors, which are required.) For trivial
-     * inits we also omit the call to initScript from exec().
-     */
-    private void setNonTrivialInit(String methodName) {
-        if (!trivialInit)
-            return;     // already set
-        trivialInit = false;
-        startNewMethod(methodName, "(Lorg/mozilla/javascript/Scriptable;"
-                                    + "Lorg/mozilla/javascript/Context;)V",
-                       1, false, false);
-        reserveWordLocal(0);  // reserve 0 for 'this'
-        variableObjectLocal = reserveWordLocal(1);  // reserve 1 for 'scope'
-        contextLocal = reserveWordLocal(2);  // reserve 2 for 'context'
-    }
-
-    private void generateInit(Context cx, String methodName,
-                              Node tree, String name, Node args)
-    {
-        trivialInit = true;
-        boolean inCtor = false;
-        VariableTable vars;
-        if (tree instanceof OptFunctionNode)
-            vars = ((OptFunctionNode)tree).getVariableTable();
-        else
-            vars = (VariableTable) tree.getProp(Node.VARS_PROP);
-
-        if (methodName.equals("<init>")) {
-            inCtor = true;
-            setNonTrivialInit(methodName);
-            addByteCode(ByteCode.ALOAD_0);
-            addSpecialInvoke(superClassSlashName, "<init>", "()", "V");
-
-            addByteCode(ByteCode.ALOAD_0);
-            addByteCode(ByteCode.ALOAD_1);
-            classFile.add(ByteCode.PUTFIELD,
-                          "org/mozilla/javascript/ScriptableObject",
-                          "parent", "Lorg/mozilla/javascript/Scriptable;");
-        }
-
-        /*
-         * Generate code to initialize functionName field with the name
-         * of the function and argNames string array with the names
-         * of the parameters and the vars. Initialize argCount
-         * to the number of formal parameters.
-         */
-
-        if (name.length() != 0) {
-            setNonTrivialInit(methodName);
-               addByteCode(ByteCode.ALOAD_0);
-            classFile.addLoadConstant(name);
-            classFile.add(ByteCode.PUTFIELD,
-                          "org/mozilla/javascript/NativeFunction",
-                          "functionName", "Ljava/lang/String;");
-        }
-
-        if (vars != null) {
-            int N = vars.size();
-            if (N != 0) {
-                setNonTrivialInit(methodName);
-                push(N);
-                addByteCode(ByteCode.ANEWARRAY, "java/lang/String");
-                for (int i = 0; i != N; i++) {
-                    addByteCode(ByteCode.DUP);
-                    push(i);
-                    push(OptLocalVariable.get(vars, i).getName());
-                    addByteCode(ByteCode.AASTORE);
-                }
-                addByteCode(ByteCode.ALOAD_0);
-                addByteCode(ByteCode.SWAP);
-                classFile.add(ByteCode.PUTFIELD,
-                              "org/mozilla/javascript/NativeFunction",
-                              "argNames", "[Ljava/lang/String;");
-            }
-        }
-
-        int parmCount = vars == null ? 0 : vars.getParameterCount();
-        if (parmCount != 0) {
-            setNonTrivialInit(methodName);
-            addByteCode(ByteCode.ALOAD_0);
-            push(parmCount);
-            classFile.add(ByteCode.PUTFIELD,
-                    "org/mozilla/javascript/NativeFunction",
-                    "argCount", "S");
-        }
-
-        // Initialize NativeFunction.version with Context's version.
-        if (cx.getLanguageVersion() != 0) {
-            setNonTrivialInit(methodName);
-            addByteCode(ByteCode.ALOAD_0);
-            push(cx.getLanguageVersion());
-            classFile.add(ByteCode.PUTFIELD,
-                    "org/mozilla/javascript/NativeFunction",
-                    "version", "S");
-        }
-
-        // precompile all regexp literals
-        ObjArray regexps = (ObjArray) tree.getProp(Node.REGEXP_PROP);
-        if (regexps != null) {
-            setNonTrivialInit(methodName);
-            generateRegExpLiterals(regexps, inCtor);
-        }
-
-        if (tree instanceof OptFunctionNode) {
-
-            OptFunctionNode fnNode = (OptFunctionNode)tree;
-            if (fnNode.isTargetOfDirectCall()) {
-                setNonTrivialInit(methodName);
-                String className = fnNode.getClassName();
-                String fieldName = className.replace('.', '_');
-                String fieldType = 'L'+classFile.fullyQualifiedForm(className)
-                                   +';';
-                classFile.addField(fieldName, fieldType,
-                                   (short)(ClassFileWriter.ACC_PUBLIC
-                                           | ClassFileWriter.ACC_STATIC));
-                addByteCode(ByteCode.ALOAD_0);
-                classFile.add(ByteCode.PUTSTATIC, className,
-                              fieldName, fieldType);
-            }
-        }
-
-        if (!trivialInit) {
-            addByteCode(ByteCode.RETURN);
-            finishMethod(cx, null);
-        }
-
-        // Add static method to return encoded source tree for decompilation
-        // which will be called from OptFunction/OptScrript.getSourcesTree
-        // via reflection. See NativeFunction.getSourcesTree for documentation.
-        // Note that nested function decompilation currently depends on the
-        // elements of the fns array being defined in source order.
-        // (per function/script, starting from 0.)
-        // Change Parser if changing ordering.
-
-        if (cx.isGeneratingSource()) {
-            String source = (String) tree.getProp(Node.SOURCE_PROP);
-            if (source != null && source.length() < 65536) {
-                short flags = ClassFileWriter.ACC_PUBLIC
-                            | ClassFileWriter.ACC_STATIC;
-                String getSourceMethodStr = "getSourcesTreeImpl";
-                classFile.startMethod(getSourceMethodStr,
-                                      "()Ljava/lang/Object;",
-                                      (short)flags);
-                ObjArray fns = (ObjArray) tree.getProp(Node.FUNCTION_PROP);
-                if (fns == null) {
-                    // generate return <source-literal-string>;
-                    push(source);
-                } else {
-                    // generate with N = fns.size():
-                    // Object[] result = new Object[1 + N];
-                    // result[0] = <source-literal-string>
-                    // result[1] = Class1.getSourcesTreeImpl();
-                    // ...
-                    // result[N] = ClassN.getSourcesTreeImpl();
-                    // return result;
-                    push(1 + fns.size());
-                    addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-                       addByteCode(ByteCode.DUP); // dup array reference
-                    push(0);
-                    push(source);
-                    addByteCode(ByteCode.AASTORE);
-                    for (int i = 0; i != fns.size(); ++i) {
-                        addByteCode(ByteCode.DUP); // dup array reference
-                        push(1 + i);
-
-                        OptFunctionNode fn = (OptFunctionNode) fns.get(i);
-                        classFile.add(ByteCode.INVOKESTATIC,
-                                      fn.getClassName(),
-                                      getSourceMethodStr,
-                                      "()",
-                                      "Ljava/lang/Object;");
-                        addByteCode(ByteCode.AASTORE);
-                    }
-                }
-                addByteCode(ByteCode.ARETURN);
-                classFile.stopMethod((short)0, null);
-            }
-        }
-    }
-
-    private void generateRegExpLiterals(ObjArray regexps, boolean inCtor) {
-        for (int i=0; i < regexps.size(); i++) {
-            Node regexp = (Node) regexps.get(i);
-            StringBuffer sb = new StringBuffer("_re");
-            sb.append(i);
-            String fieldName = sb.toString();
-            short flags = ClassFileWriter.ACC_PRIVATE;
-            if (inCtor)
-                flags |= ClassFileWriter.ACC_FINAL;
-            classFile.addField(fieldName,
-                               "Lorg/mozilla/javascript/regexp/NativeRegExp;",
-                               flags);
-            addByteCode(ByteCode.ALOAD_0);    // load 'this'
-
-            addByteCode(ByteCode.NEW, "org/mozilla/javascript/regexp/NativeRegExp");
-            addByteCode(ByteCode.DUP);
-
-            aload(contextLocal);    // load 'context'
-            aload(variableObjectLocal);    // load 'scope'
-            Node left = regexp.getFirstChild();
-            push(left.getString());
-            Node right = regexp.getLastChild();
-            if (left == right) {
-                addByteCode(ByteCode.ACONST_NULL);
-            } else {
-                push(right.getString());
-            }
-            push(0);
-
-            addSpecialInvoke("org/mozilla/javascript/regexp/NativeRegExp",
-                                "<init>",
-                                "(Lorg/mozilla/javascript/Context;" +
-                                  "Lorg/mozilla/javascript/Scriptable;" +
-                                  "Ljava/lang/String;Ljava/lang/String;Z)",
-                                  "V");
-
-            regexp.putProp(Node.REGEXP_PROP, fieldName);
-            classFile.add(ByteCode.PUTFIELD,
-                            classFile.fullyQualifiedForm(this.name),
-                            fieldName, "Lorg/mozilla/javascript/regexp/NativeRegExp;");
-        }
-    }
-
-    /**
-     * Generate the prologue for a function or script.
-     *
-     * @param cx the context
-     * @param tree the tree to generate code for
-     * @param inFunction true if generating the prologue for a function
-     *        (as opposed to a script)
-     * @param directParameterCount number of parameters for direct call,
-     *        or -1 if not direct call
-     */
-    private void generatePrologue(Context cx, Node tree, boolean inFunction,
-                                  int directParameterCount)
-    {
-        funObjLocal = reserveWordLocal(0);
-        contextLocal = reserveWordLocal(1);
-        variableObjectLocal = reserveWordLocal(2);
-        thisObjLocal = reserveWordLocal(3);
-
-        if (inFunction && !itsUseDynamicScope &&
-            directParameterCount == -1)
-        {
-            // Unless we're either using dynamic scope or we're in a
-            // direct call, use the enclosing scope of the function as our
-            // variable object.
-            aload(funObjLocal);
-            classFile.add(ByteCode.INVOKEINTERFACE,
-                          "org/mozilla/javascript/Scriptable",
-                          "getParentScope",
-                          "()",
-                          "Lorg/mozilla/javascript/Scriptable;");
-            astore(variableObjectLocal);
-        }
-
-        if (directParameterCount > 0) {
-            for (int i = 0; i < (3 * directParameterCount); i++)
-                reserveWordLocal(i + 4);               // reserve 'args'
-        }
-        // reserve 'args[]'
-        argsLocal = reserveWordLocal(directParameterCount <= 0
-                                     ? 4 : (3 * directParameterCount) + 4);
-
-        // These locals are to be pre-allocated since they need function scope.
-        // They are primarily used by the exception handling mechanism
-        int localCount = tree.getIntProp(Node.LOCALCOUNT_PROP, 0);
-        if (localCount != 0) {
-            itsLocalAllocationBase = (short)(argsLocal + 1);
-            for (int i = 0; i < localCount; i++) {
-                reserveWordLocal(itsLocalAllocationBase + i);
-            }
-        }
-
-        if (inFunction && ((OptFunctionNode)tree).getCheckThis()) {
-            // Nested functions must check their 'this' value to
-            //  insure it is not an activation object:
-            //  see 10.1.6 Activation Object
-            aload(thisObjLocal);
-            addScriptRuntimeInvoke("getThis",
-                      "(Lorg/mozilla/javascript/Scriptable;)",
-                      "Lorg/mozilla/javascript/Scriptable;");
-            astore(thisObjLocal);
-        }
-
-        hasVarsInRegs = inFunction &&
-                        !((OptFunctionNode)tree).requiresActivation();
-        if (hasVarsInRegs) {
-            // No need to create activation. Pad arguments if need be.
-            int parmCount = vars.getParameterCount();
-            if (inFunction && parmCount > 0 && directParameterCount < 0) {
-                // Set up args array
-                // check length of arguments, pad if need be
-                aload(argsLocal);
-                addByteCode(ByteCode.ARRAYLENGTH);
-                push(parmCount);
-                int label = acquireLabel();
-                addByteCode(ByteCode.IF_ICMPGE, label);
-                aload(argsLocal);
-                push(parmCount);
-                addScriptRuntimeInvoke("padArguments",
-                              "([Ljava/lang/Object;I)",
-                              "[Ljava/lang/Object;");
-                astore(argsLocal);
-                markLabel(label);
-            }
-
-            // REMIND - only need to initialize the vars that don't get a value
-            // before the next call and are used in the function
-            short firstUndefVar = -1;
-            for (int i = 0; i < vars.size(); i++) {
-                OptLocalVariable lVar = OptLocalVariable.get(vars, i);
-                if (lVar.isNumber()) {
-                    lVar.assignJRegister(getNewWordPairLocal());
-                    push(0.0);
-                    dstore(lVar.getJRegister());
-                } else if (lVar.isParameter()) {
-                    if (directParameterCount < 0) {
-                        lVar.assignJRegister(getNewWordLocal());
-                        aload(argsLocal);
-                        push(i);
-                        addByteCode(ByteCode.AALOAD);
-                        astore(lVar.getJRegister());
-                    }
-                } else {
-                    lVar.assignJRegister(getNewWordLocal());
-                    if (firstUndefVar == -1) {
-                        pushUndefined();
-                        firstUndefVar = lVar.getJRegister();
-                    } else {
-                        aload(firstUndefVar);
-                    }
-                    astore(lVar.getJRegister());
-                }
-                lVar.setStartPC(classFile.getCurrentCodeOffset());
-            }
-
-            // Indicate that we should generate debug information for
-            // the variable table. (If we're generating debug info at
-            // all.)
-            debugVars = vars;
-
-            // Skip creating activation object.
-            return;
-        }
-
-        if (directParameterCount > 0) {
-            // We're going to create an activation object, so we
-            // need to get an args array with all the arguments in it.
-
-            aload(argsLocal);
-            push(directParameterCount);
-            addOptRuntimeInvoke("padStart",
-                                   "([Ljava/lang/Object;I)",
-                                   "[Ljava/lang/Object;");
-            astore(argsLocal);
-            for (int i=0; i < directParameterCount; i++) {
-                aload(argsLocal);
-                push(i);
-                // "3" is 1 for Object parm and 2 for double parm, and
-                // "4" is to account for the context, etc. parms
-                aload((short) (3*i+4));
-                addByteCode(ByteCode.AASTORE);
-            }
-        }
-
-        String debugVariableName;
-        if (inFunction) {
-            aload(contextLocal);
-            aload(variableObjectLocal);
-            aload(funObjLocal);
-            aload(thisObjLocal);
-            aload(argsLocal);
-            addScriptRuntimeInvoke("initVarObj",
-                          "(Lorg/mozilla/javascript/Context;" +
-                           "Lorg/mozilla/javascript/Scriptable;" +
-                           "Lorg/mozilla/javascript/NativeFunction;" +
-                           "Lorg/mozilla/javascript/Scriptable;" +
-                           "[Ljava/lang/Object;)",
-                          "Lorg/mozilla/javascript/Scriptable;");
-            debugVariableName = "activation";
-        } else {
-            aload(contextLocal);
-            aload(variableObjectLocal);
-            aload(funObjLocal);
-            aload(thisObjLocal);
-            push(0);
-            addScriptRuntimeInvoke("initScript",
-                          "(Lorg/mozilla/javascript/Context;" +
-                           "Lorg/mozilla/javascript/Scriptable;" +
-                           "Lorg/mozilla/javascript/NativeFunction;" +
-                           "Lorg/mozilla/javascript/Scriptable;Z)",
-                          "Lorg/mozilla/javascript/Scriptable;");
-            debugVariableName = "global";
-        }
-        astore(variableObjectLocal);
-
-        ObjArray fns = (ObjArray) tree.getProp(Node.FUNCTION_PROP);
-        if (fns != null) {
-            for (int i=0; i < fns.size(); i++) {
-                OptFunctionNode fn = (OptFunctionNode) fns.get(i);
-                if (fn.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {
-                    visitFunction(fn, FunctionNode.FUNCTION_STATEMENT);
-                    addByteCode(ByteCode.POP);
-                }
-            }
-        }
-
-
-        // default is to generate debug info
-        if (!cx.isGeneratingDebugChanged() || cx.isGeneratingDebug()) {
-            OptLocalVariable lv = new OptLocalVariable(debugVariableName,
-                                                       false);
-            lv.assignJRegister(variableObjectLocal);
-            lv.setStartPC(classFile.getCurrentCodeOffset());
-
-            debugVars = new VariableTable();
-            debugVars.addLocal(debugVariableName, lv);
-        }
-
-        if (!inFunction) {
-            // OPT: use dataflow to prove that this assignment is dead
-            scriptResultLocal = getNewWordLocal();
-            pushUndefined();
-            astore(scriptResultLocal);
-        }
-
-        if (inFunction && ((OptFunctionNode)tree).containsCalls(-1)) {
-            if (((OptFunctionNode)tree).containsCalls(0)) {
-                itsZeroArgArray = getNewWordLocal();
-                classFile.add(ByteCode.GETSTATIC,
-                        "org/mozilla/javascript/ScriptRuntime",
-                        "emptyArgs", "[Ljava/lang/Object;");
-                astore(itsZeroArgArray);
-            }
-            if (((OptFunctionNode)tree).containsCalls(1)) {
-                itsOneArgArray = getNewWordLocal();
-                push(1);
-                addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-                astore(itsOneArgArray);
-            }
-        }
-    }
-
-    private void generateEpilogue() {
-        if (epilogueLabel != -1) {
-            classFile.markLabel(epilogueLabel);
-        }
-        if (!hasVarsInRegs || !inFunction) {
-            // restore caller's activation
-            aload(contextLocal);
-            addScriptRuntimeInvoke("popActivation",
-                                   "(Lorg/mozilla/javascript/Context;)",
-                                   "V");
-        }
-        addByteCode(ByteCode.ARETURN);
-    }
-
-    private void visitFunction(OptFunctionNode fn, int functionType) {
-        String fnClassName = fn.getClassName();
-        addByteCode(ByteCode.NEW, fnClassName);
-        // Call function constructor
-        addByteCode(ByteCode.DUP);
-        aload(variableObjectLocal);
-        aload(contextLocal);           // load 'cx'
-        addSpecialInvoke(fnClassName, "<init>",
-                         "(Lorg/mozilla/javascript/Scriptable;"
-                         +"Lorg/mozilla/javascript/Context;)",
-                         "V");
-        addByteCode(ByteCode.DUP); // copy of function
-        push(functionType);
-        aload(variableObjectLocal);
-        aload(contextLocal);           // load 'cx'
-        addOptRuntimeInvoke("initFunction",
-                            "(Lorg/mozilla/javascript/NativeFunction;"
-                            +"I"
-                            +"Lorg/mozilla/javascript/Scriptable;"
-                            +"Lorg/mozilla/javascript/Context;)",
-                            "V");
-        // leave on stack new function instance
-    }
-
-    private void visitTarget(Node node) {
-        int label = node.getIntProp(Node.LABEL_PROP, -1);
-        if (label == -1) {
-            label = acquireLabel();
-            node.putIntProp(Node.LABEL_PROP, label);
-        }
-        markLabel(label);
-    }
-
-    private void visitGOTO(Node node, int type, Node child) {
-        Node target = (Node)(node.getProp(Node.TARGET_PROP));
-        int targetLabel = target.getIntProp(Node.LABEL_PROP, -1);
-        if (targetLabel == -1) {
-            targetLabel = acquireLabel();
-            target.putIntProp(Node.LABEL_PROP, targetLabel);
-        }
-        int fallThruLabel = acquireLabel();
-
-        if ((type == TokenStream.IFEQ) || (type == TokenStream.IFNE)) {
-            if (child == null) {
-                // can have a null child from visitSwitch which
-                // has already generated the code for the child
-                // and just needs the GOTO code emitted
-                addScriptRuntimeInvoke("toBoolean", "(Ljava/lang/Object;)", "Z");
-                if (type == TokenStream.IFEQ)
-                    addByteCode(ByteCode.IFNE, targetLabel);
-                else
-                    addByteCode(ByteCode.IFEQ, targetLabel);
-            }
-            else {
-                if (type == TokenStream.IFEQ)
-                    generateCodeFromNode(child, node, targetLabel, fallThruLabel);
-                else
-                    generateCodeFromNode(child, node, fallThruLabel, targetLabel);
-                if (!childIsBoolean(child)) {
-                    addScriptRuntimeInvoke("toBoolean",
-                                    "(Ljava/lang/Object;)", "Z");
-                    if (type == TokenStream.IFEQ)
-                        addByteCode(ByteCode.IFNE, targetLabel);
-                    else
-                        addByteCode(ByteCode.IFEQ, targetLabel);
-                }
-            }
-        }
-        else {
-            while (child != null) {
-                generateCodeFromNode(child, node, -1, -1);
-                child = child.getNext();
-            }
-            if (type == TokenStream.JSR)
-                addByteCode(ByteCode.JSR, targetLabel);
-            else
-                addByteCode(ByteCode.GOTO, targetLabel);
-        }
-        markLabel(fallThruLabel);
-    }
-
-    private void visitEnumInit(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        aload(variableObjectLocal);
-        addScriptRuntimeInvoke("initEnum",
-            "(Ljava/lang/Object;Lorg/mozilla/javascript/Scriptable;)",
-             "Ljava/lang/Object;");
-        short x = getNewWordLocal();
-        astore(x);
-        node.putIntProp(Node.LOCAL_PROP, x);
-    }
-
-    private void visitEnumNext(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        Node init = (Node) node.getProp(Node.ENUM_PROP);
-        int local = init.getExistingIntProp(Node.LOCAL_PROP);
-        aload((short)local);
-        addScriptRuntimeInvoke("nextEnum", "(Ljava/lang/Object;)", "Ljava/lang/Object;");
-    }
-
-    private void visitEnumDone(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        Node init = (Node) node.getProp(Node.ENUM_PROP);
-        int local = init.getExistingIntProp(Node.LOCAL_PROP);
-        releaseWordLocal((short)local);
-    }
-
-    private void visitEnterWith(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        aload(variableObjectLocal);
-        addScriptRuntimeInvoke("enterWith",
-            "(Ljava/lang/Object;" +
-             "Lorg/mozilla/javascript/Scriptable;)",
-            "Lorg/mozilla/javascript/Scriptable;");
-        astore(variableObjectLocal);
-    }
-
-    private void visitLeaveWith(Node node, Node child) {
-        aload(variableObjectLocal);
-        addScriptRuntimeInvoke("leaveWith",
-            "(Lorg/mozilla/javascript/Scriptable;)",
-            "Lorg/mozilla/javascript/Scriptable;");
-        astore(variableObjectLocal);
-    }
-
-    private void resetTargets(Node node)
-    {
-        if (node.getType() == TokenStream.TARGET) {
-            node.removeProp(Node.LABEL_PROP);
-        }
-        Node child = node.getFirstChild();
-        while (child != null) {
-            resetTargets(child);
-            child = child.getNext();
-        }
-    }
-
-    private void visitCall(Node node, int type, Node child) {
-        /*
-         * Generate code for call.
-         */
-
-        Node chelsea = child;      // remember the first child for later
-        OptFunctionNode target = (OptFunctionNode)node.getProp(Node.DIRECTCALL_PROP);
-        if (target != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            int regularCall = acquireLabel();
-
-            String className = classFile.fullyQualifiedForm(target.getClassName());
-            String fieldName = className.replace('/', '_');
-
-            classFile.add(ByteCode.GETSTATIC,
-                                classFile.fullyQualifiedForm(className),
-                                fieldName,
-                                "L" + className + ";");
-            short stackHeight = classFile.getStackTop();
-
-            addByteCode(ByteCode.DUP2);
-            addByteCode(ByteCode.IF_ACMPNE, regularCall);
-            addByteCode(ByteCode.SWAP);
-            addByteCode(ByteCode.POP);
-
-            if (!itsUseDynamicScope) {
-                addByteCode(ByteCode.DUP);
-                classFile.add(ByteCode.INVOKEINTERFACE,
-                                "org/mozilla/javascript/Scriptable",
-                                "getParentScope",
-                                "()", "Lorg/mozilla/javascript/Scriptable;");
-            } else {
-                aload(variableObjectLocal);
-            }
-            aload(contextLocal);
-            addByteCode(ByteCode.SWAP);
-
-            if (type == TokenStream.NEW)
-                addByteCode(ByteCode.ACONST_NULL);
-            else {
-                child = child.getNext();
-                generateCodeFromNode(child, node, -1, -1);
-            }
-/*
-    Remember that directCall parameters are paired in 1 aReg and 1 dReg
-    If the argument is an incoming arg, just pass the orginal pair thru.
-    Else, if the argument is known to be typed 'Number', pass Void.TYPE
-    in the aReg and the number is the dReg
-    Else pass the JS object in the aReg and 0.0 in the dReg.
-*/
-            child = child.getNext();
-            while (child != null) {
-                boolean handled = false;
-                if ((child.getType() == TokenStream.GETVAR)
-                        && inDirectCallFunction) {
-                    OptLocalVariable lVar
-                        = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-                    if (lVar != null && lVar.isParameter()) {
-                        handled = true;
-                        aload(lVar.getJRegister());
-                        dload((short)(lVar.getJRegister() + 1));
-                    }
-                }
-                if (!handled) {
-                    int childNumberFlag
-                                = child.getIntProp(Node.ISNUMBER_PROP, -1);
-                    if (childNumberFlag == Node.BOTH) {
-                        classFile.add(ByteCode.GETSTATIC,
-                                "java/lang/Void",
-                                "TYPE",
-                                "Ljava/lang/Class;");
-                        generateCodeFromNode(child, node, -1, -1);
-                    }
-                    else {
-                        generateCodeFromNode(child, node, -1, -1);
-                        push(0.0);
-                    }
-                }
-                resetTargets(child);
-                child = child.getNext();
-            }
-
-            classFile.add(ByteCode.GETSTATIC,
-                    "org/mozilla/javascript/ScriptRuntime",
-                    "emptyArgs", "[Ljava/lang/Object;");
-
-            if (type == TokenStream.NEW)
-                addVirtualInvoke(target.getClassName(),
-                                "constructDirect",
-                                target.getDirectCallParameterSignature(),
-                                "Ljava/lang/Object;");
-            else
-                addVirtualInvoke(target.getClassName(),
-                                "callDirect",
-                                target.getDirectCallParameterSignature(),
-                                "Ljava/lang/Object;");
-
-            int beyond = acquireLabel();
-            addByteCode(ByteCode.GOTO, beyond);
-            markLabel(regularCall, stackHeight);
-            addByteCode(ByteCode.POP);
-
-            visitRegularCall(node, type, chelsea, true);
-            markLabel(beyond);
-        }
-        else {
-            visitRegularCall(node, type, chelsea, false);
-        }
-   }
-
-
-    private String getSimpleCallName(Node callNode)
-    /*
-        Find call trees that look like this :
-        (they arise from simple function invocations)
-
-            CALL                     <-- this is the callNode node
-                GETPROP
-                    NEWTEMP [USES: 1]
-                        GETBASE 'name'
-                    STRING 'name'
-                GETTHIS
-                    USETEMP [TEMP: NEWTEMP [USES: 1]]
-                <-- arguments would be here
-
-        and return the name found.
-
-    */
-    {
-        Node callBase = callNode.getFirstChild();
-        if (callBase.getType() == TokenStream.GETPROP) {
-            Node callBaseChild = callBase.getFirstChild();
-            if (callBaseChild.getType() == TokenStream.NEWTEMP) {
-                Node callBaseID = callBaseChild.getNext();
-                Node tempChild = callBaseChild.getFirstChild();
-                if (tempChild.getType() == TokenStream.GETBASE) {
-                    String functionName = tempChild.getString();
-                    if ((callBaseID != null) &&
-                            (callBaseID.getType() == TokenStream.STRING)) {
-                        if (functionName.equals(callBaseID.getString())) {
-                            Node thisChild = callBase.getNext();
-                            if (thisChild.getType() == TokenStream.GETTHIS) {
-                                Node useChild = thisChild.getFirstChild();
-                                if (useChild.getType() == TokenStream.USETEMP) {
-                                    Node temp = (Node)useChild.getProp(Node.TEMP_PROP);
-                                    if (temp == callBaseChild) {
-                                        return functionName;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        return null;
-    }
-
-    private void constructArgArray(int argCount)
-    {
-        if (argCount == 0) {
-            if (itsZeroArgArray >= 0)
-                aload(itsZeroArgArray);
-            else {
-                push(0);
-                addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-            }
-        }
-        else {
-            if (argCount == 1) {
-                if (itsOneArgArray >= 0)
-                    aload(itsOneArgArray);
-                else {
-                    push(1);
-                    addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-                }
-            }
-            else {
-                push(argCount);
-                addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-            }
-        }
-    }
-
-    private void visitRegularCall(Node node, int type,
-                                  Node child, boolean firstArgDone)
-    {
-        /*
-         * Generate code for call.
-         *
-         * push <arity>
-         * anewarray Ljava/lang/Object;
-         * // "initCount" instances of code from here...
-         * dup
-         * push <i>
-         * <gen code for child>
-         * aastore
-         * //...to here
-         * invokestatic call
-         */
-
-        OptFunctionNode target = (OptFunctionNode)node.getProp(Node.DIRECTCALL_PROP);
-        Node chelsea = child;
-        int childCount = 0;
-        int argSkipCount = (type == TokenStream.NEW) ? 1 : 2;
-        while (child != null) {
-            childCount++;
-            child = child.getNext();
-        }
-
-        child = chelsea;    // re-start the iterator from the first child,
-                    // REMIND - too bad we couldn't just back-patch the count ?
-
-        int argIndex = -argSkipCount;
-        if (firstArgDone && (child != null)) {
-            child = child.getNext();
-            argIndex++;
-            aload(contextLocal);
-            addByteCode(ByteCode.SWAP);
-        }
-        else
-            aload(contextLocal);
-
-        if (firstArgDone && (type == TokenStream.NEW))
-            constructArgArray(childCount - argSkipCount);
-
-        boolean isSpecialCall = node.getProp(Node.SPECIALCALL_PROP) != null;
-        boolean isSimpleCall = false;
-        String simpleCallName = null;
-        if (type != TokenStream.NEW) {
-            simpleCallName = getSimpleCallName(node);
-            if (simpleCallName != null && !isSpecialCall) {
-                isSimpleCall = true;
-                push(simpleCallName);
-                aload(variableObjectLocal);
-                child = child.getNext().getNext();
-                argIndex = 0;
-                push(childCount - argSkipCount);
-                addByteCode(ByteCode.ANEWARRAY, "java/lang/Object");
-            }
-        }
-
-        while (child != null) {
-            if (argIndex < 0)       // not moving these arguments to the array
-                generateCodeFromNode(child, node, -1, -1);
-            else {
-                addByteCode(ByteCode.DUP);
-                push(argIndex);
-                if (target != null) {
-/*
-    If this has also been a directCall sequence, the Number flag will
-    have remained set for any parameter so that the values could be
-    copied directly into the outgoing args. Here we want to force it
-    to be treated as not in a Number context, so we set the flag off.
-*/
-                    boolean handled = false;
-                    if ((child.getType() == TokenStream.GETVAR)
-                            && inDirectCallFunction) {
-                        OptLocalVariable lVar
-                          = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-                        if (lVar != null && lVar.isParameter()) {
-                            child.removeProp(Node.ISNUMBER_PROP);
-                            generateCodeFromNode(child, node, -1, -1);
-                            handled = true;
-                        }
-                    }
-                    if (!handled) {
-                        int childNumberFlag
-                                = child.getIntProp(Node.ISNUMBER_PROP, -1);
-                        if (childNumberFlag == Node.BOTH) {
-                            addByteCode(ByteCode.NEW,"java/lang/Double");
-                            addByteCode(ByteCode.DUP);
-                            generateCodeFromNode(child, node, -1, -1);
-                            addDoubleConstructor();
-                        }
-                        else
-                            generateCodeFromNode(child, node, -1, -1);
-                    }
-                }
-                else
-                    generateCodeFromNode(child, node, -1, -1);
-                addByteCode(ByteCode.AASTORE);
-            }
-            argIndex++;
-            if (argIndex == 0) {
-                                        // now we need to construct the array
-                                        // (even if there are no args to load
-                                        // into it) - REMIND could pass null
-                                        // instead ?
-                constructArgArray(childCount - argSkipCount);
-            }
-            child = child.getNext();
-        }
-
-        String className;
-        String methodNameNewObj;
-        String methodNameCall;
-        String callSignature;
-
-        if (isSpecialCall) {
-            className        = "org/mozilla/javascript/ScriptRuntime";
-            methodNameNewObj = "newObjectSpecial";
-            methodNameCall   = "callSpecial";
-            if (type != TokenStream.NEW) {
-                callSignature    = "(Lorg/mozilla/javascript/Context;" +
-                                     "Ljava/lang/Object;" +
-                                     "Ljava/lang/Object;" +
-                                     "[Ljava/lang/Object;" +
-                                     "Lorg/mozilla/javascript/Scriptable;" +
-                                     "Lorg/mozilla/javascript/Scriptable;" +
-                                     "Ljava/lang/String;I)";   // filename & linenumber
-                aload(thisObjLocal);
-                aload(variableObjectLocal);
-                push(itsSourceFile == null ? "" : itsSourceFile);
-                push(itsLineNumber);
-            } else {
-                callSignature    = "(Lorg/mozilla/javascript/Context;" +
-                                    "Ljava/lang/Object;" +
-                                    "[Ljava/lang/Object;" +
-                                    "Lorg/mozilla/javascript/Scriptable;)";
-                aload(variableObjectLocal);
-            }
-        } else {
-            methodNameNewObj = "newObject";
-            if (isSimpleCall) {
-                callSignature  = "(Lorg/mozilla/javascript/Context;" +
-                                  "Ljava/lang/String;" +
-                                  "Lorg/mozilla/javascript/Scriptable;" +
-                                  "[Ljava/lang/Object;)";
-                methodNameCall = "callSimple";
-                className      = "org/mozilla/javascript/optimizer/OptRuntime";
-            } else {
-                aload(variableObjectLocal);
-                if (type == TokenStream.NEW) {
-                    callSignature    = "(Lorg/mozilla/javascript/Context;" +
-                                        "Ljava/lang/Object;" +
-                                        "[Ljava/lang/Object;" +
-                                        "Lorg/mozilla/javascript/Scriptable;)";
-                } else {
-                    callSignature    = "(Lorg/mozilla/javascript/Context;" +
-                                        "Ljava/lang/Object;" +
-                                        "Ljava/lang/Object;" +
-                                        "[Ljava/lang/Object;" +
-                                        "Lorg/mozilla/javascript/Scriptable;)";
-                }
-                methodNameCall   = "call";
-                className        = "org/mozilla/javascript/ScriptRuntime";
-            }
-        }
-
-        if (type == TokenStream.NEW) {
-            addStaticInvoke(className,
-                methodNameNewObj,
-                callSignature,
-                "Lorg/mozilla/javascript/Scriptable;");
-        } else {
-            addStaticInvoke(className,
-                methodNameCall,
-                callSignature,
-                "Ljava/lang/Object;");
-        }
-    }
-
-    private void visitStatement(Node node) {
-        itsLineNumber = node.getLineno();
-        if (itsLineNumber == -1)
-            return;
-        classFile.addLineNumberEntry((short)itsLineNumber);
-    }
-
-
-    private void visitTryCatchFinally(Node node, Node child) {
-        /* Save the variable object, in case there are with statements
-         * enclosed by the try block and we catch some exception.
-         * We'll restore it for the catch block so that catch block
-         * statements get the right scope.
-         */
-
-        // OPT we only need to do this if there are enclosed WITH
-        // statements; could statically check and omit this if there aren't any.
-
-        // XXX OPT Maybe instead do syntactic transforms to associate
-        // each 'with' with a try/finally block that does the exitwith.
-
-        // For that matter:  Why do we have leavewith?
-
-        // XXX does Java have any kind of MOV(reg, reg)?
-        short savedVariableObject = getNewWordLocal();
-        aload(variableObjectLocal);
-        astore(savedVariableObject);
-
-        /*
-         * Generate the code for the tree; most of the work is done in IRFactory
-         * and NodeTransformer;  Codegen just adds the java handlers for the
-         * javascript catch and finally clauses.  */
-        // need to set the stack top to 1 to account for the incoming exception
-        int startLabel = acquireLabel();
-        markLabel(startLabel, (short)1);
-
-        visitStatement(node);
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-
-        Node catchTarget = (Node)node.getProp(Node.TARGET_PROP);
-        Node finallyTarget = (Node)node.getProp(Node.FINALLY_PROP);
-
-        // control flow skips the handlers
-        int realEnd = acquireLabel();
-        addByteCode(ByteCode.GOTO, realEnd);
-
-
-        // javascript handler; unwrap exception and GOTO to javascript
-        // catch area.
-        if (catchTarget != null) {
-            // get the label to goto
-            int catchLabel = catchTarget.getExistingIntProp(Node.LABEL_PROP);
-
-            generateCatchBlock(JAVASCRIPTEXCEPTION, savedVariableObject,
-                               catchLabel, startLabel);
-            /*
-             * catch WrappedExceptions, see if they are wrapped
-             * JavaScriptExceptions. Otherwise, rethrow.
-             */
-            generateCatchBlock(WRAPPEDEXCEPTION, savedVariableObject,
-                               catchLabel, startLabel);
-
-            /*
-                we also need to catch EcmaErrors and feed the
-                associated error object to the handler
-            */
-            int jsHandler = acquireLabel();
-            classFile.markHandler(jsHandler);
-            short exceptionObject = getNewWordLocal();
-            astore(exceptionObject);
-            aload(savedVariableObject);
-            astore(variableObjectLocal);
-            aload(exceptionObject);
-            addVirtualInvoke("org/mozilla/javascript/EcmaError",
-                             "getErrorObject",
-                             "()",
-                             "Lorg/mozilla/javascript/Scriptable;");
-            releaseWordLocal(exceptionObject);
-            addByteCode(ByteCode.GOTO, catchLabel);
-            classFile.addExceptionHandler
-                (startLabel, catchLabel, jsHandler,
-                 "org/mozilla/javascript/EcmaError");
-
-
-        }
-
-        // finally handler; catch all exceptions, store to a local; JSR to
-        // the finally, then re-throw.
-        if (finallyTarget != null) {
-            int finallyHandler = acquireLabel();
-            classFile.markHandler(finallyHandler);
-
-            // reset the variable object local
-            aload(savedVariableObject);
-            astore(variableObjectLocal);
-
-            short exnLocal = itsLocalAllocationBase++;
-            astore(exnLocal);
-
-            // get the label to JSR to
-            int finallyLabel =
-                finallyTarget.getExistingIntProp(Node.LABEL_PROP);
-            addByteCode(ByteCode.JSR, finallyLabel);
-
-            // rethrow
-            aload(exnLocal);
-            addByteCode(ByteCode.ATHROW);
-
-            // mark the handler
-            classFile.addExceptionHandler(startLabel, finallyLabel,
-                                          finallyHandler, null); // catch any
-        }
-        releaseWordLocal(savedVariableObject);
-        markLabel(realEnd);
-    }
-
-    private final int JAVASCRIPTEXCEPTION = 0;
-    private final int WRAPPEDEXCEPTION    = 1;
-
-    private void generateCatchBlock(int exceptionType,
-                                    short savedVariableObject,
-                                    int catchLabel,
-                                    int startLabel)
-    {
-        int handler = acquireLabel();
-        classFile.markHandler(handler);
-
-        // MS JVM gets cranky if the exception object is left on the stack
-        short exceptionObject = getNewWordLocal();
-        astore(exceptionObject);
-
-        // reset the variable object local
-        aload(savedVariableObject);
-        astore(variableObjectLocal);
-
-        aload(exceptionObject);
-        releaseWordLocal(exceptionObject);
-
-        if (exceptionType == JAVASCRIPTEXCEPTION) {
-            // unwrap the exception...
-            addScriptRuntimeInvoke("unwrapJavaScriptException",
-                          "(Lorg/mozilla/javascript/JavaScriptException;)",
-                          "Ljava/lang/Object;");
-        } else {
-            // unwrap the exception...
-            addScriptRuntimeInvoke("unwrapWrappedException",
-                          "(Lorg/mozilla/javascript/WrappedException;)",
-                          "Ljava/lang/Object;");
-        }
-
-
-        String exceptionName = exceptionType == JAVASCRIPTEXCEPTION
-                               ? "org/mozilla/javascript/JavaScriptException"
-                               : "org/mozilla/javascript/WrappedException";
-
-        // mark the handler
-        classFile.addExceptionHandler(startLabel, catchLabel, handler,
-                                      exceptionName);
-
-        addByteCode(ByteCode.GOTO, catchLabel);
-    }
-
-    private void visitThrow(Node node, Node child) {
-        visitStatement(node);
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-
-        addByteCode(ByteCode.NEW,
-                      "org/mozilla/javascript/JavaScriptException");
-        addByteCode(ByteCode.DUP_X1);
-        addByteCode(ByteCode.SWAP);
-        addSpecialInvoke("org/mozilla/javascript/JavaScriptException",
-                      "<init>", "(Ljava/lang/Object;)", "V");
-
-        addByteCode(ByteCode.ATHROW);
-    }
-
-    private void visitReturn(Node node, Node child) {
-        visitStatement(node);
-        if (child != null) {
-            do {
-                generateCodeFromNode(child, node, -1, -1);
-                child = child.getNext();
-            } while (child != null);
-        } else if (inFunction) {
-            pushUndefined();
-        } else {
-            aload(scriptResultLocal);
-        }
-
-        if (epilogueLabel == -1)
-            epilogueLabel = classFile.acquireLabel();
-        addByteCode(ByteCode.GOTO, epilogueLabel);
-    }
-
-    private void visitSwitch(Node node, Node child) {
-        visitStatement(node);
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-
-        // save selector value
-        short selector = getNewWordLocal();
-        astore(selector);
-
-        ObjArray cases = (ObjArray) node.getProp(Node.CASES_PROP);
-        for (int i=0; i < cases.size(); i++) {
-            Node thisCase = (Node) cases.get(i);
-            Node first = thisCase.getFirstChild();
-            generateCodeFromNode(first, thisCase, -1, -1);
-            aload(selector);
-            addScriptRuntimeInvoke("seqB",
-                                   "(Ljava/lang/Object;Ljava/lang/Object;)",
-                                   "Ljava/lang/Boolean;");
-            Node target = new Node(TokenStream.TARGET);
-            thisCase.replaceChild(first, target);
-            generateGOTO(TokenStream.IFEQ, target);
-        }
-
-        Node defaultNode = (Node) node.getProp(Node.DEFAULT_PROP);
-        if (defaultNode != null) {
-            Node defaultTarget = new Node(TokenStream.TARGET);
-            defaultNode.getFirstChild().addChildToFront(defaultTarget);
-            generateGOTO(TokenStream.GOTO, defaultTarget);
-        }
-
-        Node breakTarget = (Node) node.getProp(Node.BREAK_PROP);
-        generateGOTO(TokenStream.GOTO, breakTarget);
-    }
-
-    private void generateGOTO(int type, Node target) {
-        Node GOTO = new Node(type);
-        GOTO.putProp(Node.TARGET_PROP, target);
-        visitGOTO(GOTO, type, null);
-    }
-
-    private void visitUnary(Node node, Node child, int trueGOTO, int falseGOTO) {
-        int op = node.getOperation();
-        switch (op) {
-          case TokenStream.NOT:
-          {
-            if (trueGOTO != -1) {
-                generateCodeFromNode(child, node, falseGOTO, trueGOTO);
-                if (!childIsBoolean(child)) {
-                    addScriptRuntimeInvoke("toBoolean",
-                                    "(Ljava/lang/Object;)", "Z");
-                    addByteCode(ByteCode.IFNE, falseGOTO);
-                    addByteCode(ByteCode.GOTO, trueGOTO);
-                }
-            }
-            else {
-                int trueTarget = acquireLabel();
-                int falseTarget = acquireLabel();
-                int beyond = acquireLabel();
-                generateCodeFromNode(child, node, trueTarget, falseTarget);
-
-                if (!childIsBoolean(child)) {
-                    addScriptRuntimeInvoke("toBoolean",
-                                    "(Ljava/lang/Object;)", "Z");
-                    addByteCode(ByteCode.IFEQ, falseTarget);
-                    addByteCode(ByteCode.GOTO, trueTarget);
-                }
-
-                markLabel(trueTarget);
-                classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                        "FALSE", "Ljava/lang/Boolean;");
-                addByteCode(ByteCode.GOTO, beyond);
-                markLabel(falseTarget);
-                classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                        "TRUE", "Ljava/lang/Boolean;");
-                markLabel(beyond);
-                classFile.adjustStackTop(-1);
-            }
-            break;
-          }
-
-          case TokenStream.TYPEOF:
-            visitTypeof(node, child);
-            break;
-
-          case TokenStream.VOID:
-            generateCodeFromNode(child, node, -1, -1);
-            addByteCode(ByteCode.POP);
-            pushUndefined();
-            break;
-
-          case TokenStream.BITNOT:
-            addByteCode(ByteCode.NEW, "java/lang/Double");
-            addByteCode(ByteCode.DUP);
-            generateCodeFromNode(child, node, -1, -1);
-            addScriptRuntimeInvoke("toInt32",
-                        "(Ljava/lang/Object;)", "I");
-            push(-1);         // implement ~a as (a ^ -1)
-            addByteCode(ByteCode.IXOR);
-            addByteCode(ByteCode.I2D);
-            addDoubleConstructor();
-            break;
-
-          case TokenStream.ADD:
-          case TokenStream.SUB:
-            addByteCode(ByteCode.NEW, "java/lang/Double");
-            addByteCode(ByteCode.DUP);
-            generateCodeFromNode(child, node, -1, -1);
-            addScriptRuntimeInvoke("toNumber", "(Ljava/lang/Object;)", "D");
-            if (op == TokenStream.SUB) {
-                addByteCode(ByteCode.DNEG);
-            }
-            addDoubleConstructor();
-            break;
-
-          default:
-            badTree();
-        }
-    }
-
-    private static boolean childIsBoolean(Node child) {
-        switch (child.getType()) {
-            case TokenStream.UNARYOP:
-                return child.getOperation() == TokenStream.NOT;
-            case TokenStream.AND:
-            case TokenStream.OR:
-            case TokenStream.RELOP:
-            case TokenStream.EQOP:
-                return true;
-        }
-        return false;
-    }
-
-    private void visitTypeof(Node node, Node child) {
-        if (node.getType() == TokenStream.UNARYOP) {
-            generateCodeFromNode(child, node, -1, -1);
-            addScriptRuntimeInvoke("typeof",
-                    "(Ljava/lang/Object;)", "Ljava/lang/String;");
-            return;
-        }
-        String name = node.getString();
-        if (hasVarsInRegs) {
-            OptLocalVariable lVar = OptLocalVariable.get(vars, name);
-            if (lVar != null) {
-                if (lVar.isNumber()) {
-                    push("number");
-                    return;
-                }
-                visitGetVar(lVar, false, name);
-                addScriptRuntimeInvoke("typeof",
-                        "(Ljava/lang/Object;)", "Ljava/lang/String;");
-                return;
-            }
-        }
-        aload(variableObjectLocal);
-        push(name);
-        addScriptRuntimeInvoke("typeofName",
-            "(Lorg/mozilla/javascript/Scriptable;Ljava/lang/String;)",
-            "Ljava/lang/String;");
-    }
-
-    private void visitIncDec(Node node, boolean isInc)
-    {
-        Node child = node.getFirstChild();
-        if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-            OptLocalVariable lVar
-                    = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-            if (lVar.getJRegister() == -1)
-                lVar.assignJRegister(getNewWordPairLocal());
-            dload(lVar.getJRegister());
-            addByteCode(ByteCode.DUP2);
-            push(1.0);
-            addByteCode((isInc) ? ByteCode.DADD : ByteCode.DSUB);
-            dstore(lVar.getJRegister());
-        } else {
-            OptLocalVariable lVar
-                    = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-            String routine = (isInc) ? "postIncrement" : "postDecrement";
-            if (hasVarsInRegs && child.getType() == TokenStream.GETVAR) {
-                if (lVar == null)
-                    lVar = OptLocalVariable.get(vars, child.getString());
-                if (lVar.getJRegister() == -1)
-                    lVar.assignJRegister(getNewWordLocal());
-                aload(lVar.getJRegister());
-                addByteCode(ByteCode.DUP);
-                addScriptRuntimeInvoke(routine,
-                            "(Ljava/lang/Object;)", "Ljava/lang/Object;");
-                astore(lVar.getJRegister());
-            } else {
-                if (child.getType() == TokenStream.GETPROP) {
-                    Node getPropChild = child.getFirstChild();
-                    generateCodeFromNode(getPropChild, node, -1, -1);
-                    generateCodeFromNode(getPropChild.getNext(), node, -1, -1);
-                    aload(variableObjectLocal);
-                    addScriptRuntimeInvoke(routine,
-                            "(Ljava/lang/Object;Ljava/lang/String;" +
-                            "Lorg/mozilla/javascript/Scriptable;)",
-                            "Ljava/lang/Object;");
-                }
-                else {
-                    if (child.getType() == TokenStream.GETELEM) {
-                        routine += "Elem";
-                        Node getPropChild = child.getFirstChild();
-                        generateCodeFromNode(getPropChild, node, -1, -1);
-                        generateCodeFromNode(getPropChild.getNext(), node, -1, -1);
-                        aload(variableObjectLocal);
-                        addScriptRuntimeInvoke(routine,
-                                "(Ljava/lang/Object;Ljava/lang/Object;" +
-                                "Lorg/mozilla/javascript/Scriptable;)",
-                                "Ljava/lang/Object;");
-                    }
-                    else {
-                        aload(variableObjectLocal);
-                        push(child.getString());          // push name
-                        addScriptRuntimeInvoke(routine,
-                                "(Lorg/mozilla/javascript/Scriptable;Ljava/lang/String;)",
-                                "Ljava/lang/Object;");
-                    }
-                }
-            }
-        }
-    }
-
-    private boolean isArithmeticNode(Node node) {
-        int type = node.getType();
-        return (type == TokenStream.SUB)
-                  || (type == TokenStream.MOD)
-                        || (type == TokenStream.DIV)
-                              || (type == TokenStream.MUL);
-    }
-
-    private void visitArithmetic(Node node, byte opCode, Node child,
-                                 Node parent)
-    {
-        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
-        if (childNumberFlag != -1) {
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            addByteCode(opCode);
-        }
-        else {
-            boolean childOfArithmetic = isArithmeticNode(parent);
-            if (!childOfArithmetic) {
-                addByteCode(ByteCode.NEW, "java/lang/Double");
-                addByteCode(ByteCode.DUP);
-            }
-            generateCodeFromNode(child, node, -1, -1);
-            if (!isArithmeticNode(child))
-                addScriptRuntimeInvoke("toNumber", "(Ljava/lang/Object;)", "D");
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            if (!isArithmeticNode(child.getNext()))
-                  addScriptRuntimeInvoke("toNumber", "(Ljava/lang/Object;)", "D");
-            addByteCode(opCode);
-            if (!childOfArithmetic) {
-                addDoubleConstructor();
-            }
-        }
-    }
-
-    private void visitBitOp(Node node, int type, Node child) {
-        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
-        if (childNumberFlag == -1) {
-            addByteCode(ByteCode.NEW, "java/lang/Double");
-            addByteCode(ByteCode.DUP);
-        }
-        generateCodeFromNode(child, node, -1, -1);
-
-        // special-case URSH; work with the target arg as a long, so
-        // that we can return a 32-bit unsigned value, and call
-        // toUint32 instead of toInt32.
-        if (type == TokenStream.URSH) {
-            addScriptRuntimeInvoke("toUint32", "(Ljava/lang/Object;)", "J");
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            addScriptRuntimeInvoke("toInt32", "(Ljava/lang/Object;)", "I");
-            // Looks like we need to explicitly mask the shift to 5 bits -
-            // LUSHR takes 6 bits.
-            push(31);
-            addByteCode(ByteCode.IAND);
-            addByteCode(ByteCode.LUSHR);
-            addByteCode(ByteCode.L2D);
-            addDoubleConstructor();
-            return;
-        }
-        if (childNumberFlag == -1) {
-            addScriptRuntimeInvoke("toInt32", "(Ljava/lang/Object;)", "I");
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            addScriptRuntimeInvoke("toInt32", "(Ljava/lang/Object;)", "I");
-        }
-        else {
-            addScriptRuntimeInvoke("toInt32", "(D)", "I");
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            addScriptRuntimeInvoke("toInt32", "(D)", "I");
-        }
-        switch (type) {
-          case TokenStream.BITOR:
-            addByteCode(ByteCode.IOR);
-            break;
-          case TokenStream.BITXOR:
-            addByteCode(ByteCode.IXOR);
-            break;
-          case TokenStream.BITAND:
-            addByteCode(ByteCode.IAND);
-            break;
-          case TokenStream.RSH:
-            addByteCode(ByteCode.ISHR);
-            break;
-          case TokenStream.LSH:
-            addByteCode(ByteCode.ISHL);
-            break;
-          default:
-            badTree();
-        }
-        addByteCode(ByteCode.I2D);
-        if (childNumberFlag == -1) {
-            addDoubleConstructor();
-        }
-    }
-
-    private boolean nodeIsDirectCallParameter(Node node) {
-        if (node.getType() == TokenStream.GETVAR) {
-            OptLocalVariable lVar
-                    = (OptLocalVariable)(node.getProp(Node.VARIABLE_PROP));
-            if (lVar != null && lVar.isParameter() && inDirectCallFunction &&
-                !itsForcedObjectParameters)
-            {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void genSimpleCompare(int op, int trueGOTO, int falseGOTO) {
-        switch (op) {
-            case TokenStream.LE :
-                addByteCode(ByteCode.DCMPG);
-                addByteCode(ByteCode.IFLE, trueGOTO);
-                break;
-            case TokenStream.GE :
-                addByteCode(ByteCode.DCMPL);
-                addByteCode(ByteCode.IFGE, trueGOTO);
-                break;
-            case TokenStream.LT :
-                addByteCode(ByteCode.DCMPG);
-                addByteCode(ByteCode.IFLT, trueGOTO);
-                break;
-            case TokenStream.GT :
-                addByteCode(ByteCode.DCMPL);
-                addByteCode(ByteCode.IFGT, trueGOTO);
-                break;
-        }
-        if (falseGOTO != -1)
-            addByteCode(ByteCode.GOTO, falseGOTO);
-    }
-
-    private void visitGOTOingRelOp(Node node, Node child, Node parent,
-                                   int trueGOTO, int falseGOTO)
-    {
-        int op = node.getOperation();
-        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
-        if (childNumberFlag == Node.BOTH) {
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            genSimpleCompare(op, trueGOTO, falseGOTO);
-        }
-        else {
-            if (op == TokenStream.INSTANCEOF) {
-                aload(variableObjectLocal);
-                generateCodeFromNode(child, node, -1, -1);
-                generateCodeFromNode(child.getNext(), node, -1, -1);
-                addScriptRuntimeInvoke("instanceOf",
-                              "(Lorg/mozilla/javascript/Scriptable;"+
-                               "Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                addByteCode(ByteCode.IFNE, trueGOTO);
-                addByteCode(ByteCode.GOTO, falseGOTO);
-            } else if (op == TokenStream.IN) {
-                generateCodeFromNode(child, node, -1, -1);
-                generateCodeFromNode(child.getNext(), node, -1, -1);
-                aload(variableObjectLocal);
-                addScriptRuntimeInvoke("in",
-                              "(Ljava/lang/Object;Ljava/lang/Object;"+
-                               "Lorg/mozilla/javascript/Scriptable;)","Z");
-                addByteCode(ByteCode.IFNE, trueGOTO);
-                addByteCode(ByteCode.GOTO, falseGOTO);
-            } else {
-                Node rChild = child.getNext();
-                boolean leftIsDCP = nodeIsDirectCallParameter(child);
-                boolean rightIsDCP = nodeIsDirectCallParameter(rChild);
-                if (leftIsDCP || rightIsDCP) {
-                    if (leftIsDCP) {
-                        if (rightIsDCP) {
-                            OptLocalVariable lVar1
-                                = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-                            aload(lVar1.getJRegister());
-                            classFile.add(ByteCode.GETSTATIC,
-                                    "java/lang/Void",
-                                    "TYPE",
-                                    "Ljava/lang/Class;");
-                            int notNumbersLabel = acquireLabel();
-                            addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
-                            OptLocalVariable lVar2
-                                = (OptLocalVariable)(rChild.getProp(Node.VARIABLE_PROP));
-                            aload(lVar2.getJRegister());
-                            classFile.add(ByteCode.GETSTATIC,
-                                    "java/lang/Void",
-                                    "TYPE",
-                                    "Ljava/lang/Class;");
-                            addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
-                            dload((short)(lVar1.getJRegister() + 1));
-                            dload((short)(lVar2.getJRegister() + 1));
-                            genSimpleCompare(op, trueGOTO, falseGOTO);
-                            markLabel(notNumbersLabel);
-                            // fall thru to generic handling
-                        }
-                        else {  // just the left child is a DCP, if the right child
-                                // is a number it's worth testing the left
-                            if (childNumberFlag == Node.RIGHT) {
-                                OptLocalVariable lVar1
-                                    = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-                                aload(lVar1.getJRegister());
-                                classFile.add(ByteCode.GETSTATIC,
-                                        "java/lang/Void",
-                                        "TYPE",
-                                        "Ljava/lang/Class;");
-                                int notNumbersLabel = acquireLabel();
-                                addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
-                                dload((short)(lVar1.getJRegister() + 1));
-                                generateCodeFromNode(rChild, node, -1, -1);
-                                genSimpleCompare(op, trueGOTO, falseGOTO);
-                                markLabel(notNumbersLabel);
-                                // fall thru to generic handling
-                            }
-                        }
-                    }
-                    else {  //  just the right child is a DCP, if the left child
-                            //  is a number it's worth testing the right
-                        if (childNumberFlag == Node.LEFT) {
-                            OptLocalVariable lVar2
-                                = (OptLocalVariable)(rChild.getProp(Node.VARIABLE_PROP));
-                            aload(lVar2.getJRegister());
-                            classFile.add(ByteCode.GETSTATIC,
-                                    "java/lang/Void",
-                                    "TYPE",
-                                    "Ljava/lang/Class;");
-                            int notNumbersLabel = acquireLabel();
-                            addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
-                            generateCodeFromNode(child, node, -1, -1);
-                            dload((short)(lVar2.getJRegister() + 1));
-                            genSimpleCompare(op, trueGOTO, falseGOTO);
-                            markLabel(notNumbersLabel);
-                            // fall thru to generic handling
-                        }
-                    }
-                }
-                generateCodeFromNode(child, node, -1, -1);
-                generateCodeFromNode(rChild, node, -1, -1);
-                if (childNumberFlag == -1) {
-                    if (op == TokenStream.GE || op == TokenStream.GT) {
-                        addByteCode(ByteCode.SWAP);
-                    }
-                    String routine = ((op == TokenStream.LT)
-                              || (op == TokenStream.GT)) ? "cmp_LT" : "cmp_LE";
-                    addScriptRuntimeInvoke(routine,
-                               "(Ljava/lang/Object;Ljava/lang/Object;)", "I");
-                }
-                else {
-                    boolean doubleThenObject = (childNumberFlag == Node.LEFT);
-                    if (op == TokenStream.GE || op == TokenStream.GT) {
-                        if (doubleThenObject) {
-                            addByteCode(ByteCode.DUP_X2);
-                            addByteCode(ByteCode.POP);
-                            doubleThenObject = false;
-                        }
-                        else {
-                            addByteCode(ByteCode.DUP2_X1);
-                            addByteCode(ByteCode.POP2);
-                            doubleThenObject = true;
-                        }
-                    }
-                    String routine = ((op == TokenStream.LT)
-                             || (op == TokenStream.GT)) ? "cmp_LT" : "cmp_LE";
-                    if (doubleThenObject)
-                        addOptRuntimeInvoke(routine,
-                                 "(DLjava/lang/Object;)", "I");
-                    else
-                        addOptRuntimeInvoke(routine,
-                              "(Ljava/lang/Object;D)", "I");
-                }
-                addByteCode(ByteCode.IFNE, trueGOTO);
-                addByteCode(ByteCode.GOTO, falseGOTO);
-            }
-        }
-    }
-
-    private void visitRelOp(Node node, Node child, Node parent) {
-        /*
-            this is the version that returns an Object result
-        */
-        int op = node.getOperation();
-        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
-        if (childNumberFlag == Node.BOTH
-                || op == TokenStream.INSTANCEOF
-                || op == TokenStream.IN)
-        {
-            if (op == TokenStream.INSTANCEOF)
-                aload(variableObjectLocal);
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            int trueGOTO = acquireLabel();
-            int skip = acquireLabel();
-            if (op == TokenStream.INSTANCEOF) {
-                addScriptRuntimeInvoke("instanceOf",
-                              "(Lorg/mozilla/javascript/Scriptable;"+
-                               "Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                addByteCode(ByteCode.IFNE, trueGOTO);
-            }
-            else {
-                if (op == TokenStream.IN) {
-                    aload(variableObjectLocal);
-                    addScriptRuntimeInvoke("in",
-                                  "(Ljava/lang/Object;Ljava/lang/Object;" +
-                                   "Lorg/mozilla/javascript/Scriptable;)","Z");
-                    addByteCode(ByteCode.IFNE, trueGOTO);
-                }
-                else {
-                    genSimpleCompare(op, trueGOTO, -1);
-                }
-            }
-            classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                    "FALSE", "Ljava/lang/Boolean;");
-            addByteCode(ByteCode.GOTO, skip);
-            markLabel(trueGOTO);
-            classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                    "TRUE", "Ljava/lang/Boolean;");
-            markLabel(skip);
-            classFile.adjustStackTop(-1);   // only have 1 of true/false
-        }
-        else {
-            String routine = ((op == TokenStream.LT)
-                     || (op == TokenStream.GT)) ? "cmp_LTB" : "cmp_LEB";
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            if (childNumberFlag == -1) {
-                if (op == TokenStream.GE || op == TokenStream.GT) {
-                    addByteCode(ByteCode.SWAP);
-                }
-                addScriptRuntimeInvoke(routine,
-                           "(Ljava/lang/Object;Ljava/lang/Object;)",
-                           "Ljava/lang/Boolean;");
-            }
-            else {
-                boolean doubleThenObject = (childNumberFlag == Node.LEFT);
-                if (op == TokenStream.GE || op == TokenStream.GT) {
-                    if (doubleThenObject) {
-                        addByteCode(ByteCode.DUP_X2);
-                        addByteCode(ByteCode.POP);
-                        doubleThenObject = false;
-                    }
-                    else {
-                        addByteCode(ByteCode.DUP2_X1);
-                        addByteCode(ByteCode.POP2);
-                        doubleThenObject = true;
-                    }
-                }
-                if (doubleThenObject)
-                    addOptRuntimeInvoke(routine,
-                             "(DLjava/lang/Object;)",
-                             "Ljava/lang/Boolean;");
-                else
-                    addOptRuntimeInvoke(routine,
-                          "(Ljava/lang/Object;D)",
-                          "Ljava/lang/Boolean;");
-            }
-        }
-    }
-
-    private Node getConvertToObjectOfNumberNode(Node node) {
-        if (node.getType() == TokenStream.CONVERT) {
-            Object toType = node.getProp(Node.TYPE_PROP);
-            if (toType == ScriptRuntime.ObjectClass) {
-                Node convertChild = node.getFirstChild();
-                if (convertChild.getType() == TokenStream.NUMBER)
-                    return convertChild;
-            }
-        }
-        return null;
-    }
-
-    private void visitEqOp(Node node, Node child, Node parent, int trueGOTO,
-                           int falseGOTO)
-    {
-        int op = node.getOperation();
-        Node rightChild = child.getNext();
-        boolean isStrict = op == TokenStream.SHEQ ||
-                           op == TokenStream.SHNE;
-        if (trueGOTO == -1) {
-            if (rightChild.getType() == TokenStream.PRIMARY &&
-                rightChild.getOperation() == TokenStream.NULL)
-            {
-                generateCodeFromNode(child, node, -1, -1);
-                if (isStrict) {
-                    addByteCode(ByteCode.IFNULL, 9);
-                } else {
-                    addByteCode(ByteCode.DUP);
-                    addByteCode(ByteCode.IFNULL, 15);
-                    pushUndefined();
-                    addByteCode(ByteCode.IF_ACMPEQ, 10);
-                }
-                if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
-                    classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                            "FALSE", "Ljava/lang/Boolean;");
-                else
-                    classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                            "TRUE", "Ljava/lang/Boolean;");
-                if (isStrict) {
-                    addByteCode(ByteCode.GOTO, 6);
-                } else {
-                    addByteCode(ByteCode.GOTO, 7);
-                    addByteCode(ByteCode.POP);
-                }
-                if ((op == TokenStream.EQ) || (op == TokenStream.SHEQ))
-                    classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                            "TRUE", "Ljava/lang/Boolean;");
-                else
-                    classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                            "FALSE", "Ljava/lang/Boolean;");
-                return;
-            }
-
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-
-            // JavaScript 1.2 uses shallow equality for == and !=
-            String name;
-            switch (op) {
-              case TokenStream.EQ:
-                name = version == Context.VERSION_1_2 ? "seqB" : "eqB";
-                break;
-
-              case TokenStream.NE:
-                name = version == Context.VERSION_1_2 ? "sneB" : "neB";
-                break;
-
-              case TokenStream.SHEQ:
-                name = "seqB";
-                break;
-
-              case TokenStream.SHNE:
-                name = "sneB";
-                break;
-
-              default:
-                name = null;
-                badTree();
-            }
-            addScriptRuntimeInvoke(name,
-                             "(Ljava/lang/Object;Ljava/lang/Object;)",
-                             "Ljava/lang/Boolean;");
-        }
-        else {
-            if (rightChild.getType() == TokenStream.PRIMARY &&
-                rightChild.getOperation() == TokenStream.NULL)
-            {
-                if (op != TokenStream.EQ && op != TokenStream.SHEQ) {
-                    // invert true and false.
-                    int temp = trueGOTO;
-                    trueGOTO = falseGOTO;
-                    falseGOTO = temp;
-                }
-
-                generateCodeFromNode(child, node, -1, -1);
-                if (isStrict) {
-                    addByteCode(ByteCode.IFNULL, trueGOTO);
-                    addByteCode(ByteCode.GOTO, falseGOTO);
-                    return;
-                }
-                /*
-                    since we have to test for null && undefined we end up
-                    having to push the operand twice and so have to GOTO to
-                    a pop site if the first test passes.
-                    We can avoid that for operands that are 'simple', i.e.
-                    don't generate a lot of code and don't have side-effects.
-                    For now, 'simple' means GETVAR
-                */
-                boolean simpleChild = (child.getType() == TokenStream.GETVAR);
-                if (!simpleChild) addByteCode(ByteCode.DUP);
-                int popGOTO = acquireLabel();
-                addByteCode(ByteCode.IFNULL,
-                                (simpleChild) ? trueGOTO : popGOTO);
-                short popStack = classFile.getStackTop();
-                if (simpleChild) generateCodeFromNode(child, node, -1, -1);
-                pushUndefined();
-                addByteCode(ByteCode.IF_ACMPEQ, trueGOTO);
-                addByteCode(ByteCode.GOTO, falseGOTO);
-                if (!simpleChild) {
-                    markLabel(popGOTO, popStack);
-                    addByteCode(ByteCode.POP);
-                    addByteCode(ByteCode.GOTO, trueGOTO);
-                }
-                return;
-            }
-
-            Node rChild = child.getNext();
-
-            if (nodeIsDirectCallParameter(child)) {
-                Node convertChild = getConvertToObjectOfNumberNode(rChild);
-                if (convertChild != null) {
-                    OptLocalVariable lVar1
-                        = (OptLocalVariable)(child.getProp(Node.VARIABLE_PROP));
-                    aload(lVar1.getJRegister());
-                    classFile.add(ByteCode.GETSTATIC,
-                            "java/lang/Void",
-                            "TYPE",
-                            "Ljava/lang/Class;");
-                    int notNumbersLabel = acquireLabel();
-                    addByteCode(ByteCode.IF_ACMPNE, notNumbersLabel);
-                    dload((short)(lVar1.getJRegister() + 1));
-                    push(convertChild.getDouble());
-                    addByteCode(ByteCode.DCMPL);
-                    if (op == TokenStream.EQ)
-                        addByteCode(ByteCode.IFEQ, trueGOTO);
-                    else
-                        addByteCode(ByteCode.IFNE, trueGOTO);
-                    addByteCode(ByteCode.GOTO, falseGOTO);
-                    markLabel(notNumbersLabel);
-                    // fall thru into generic handling
-                }
-            }
-
-            generateCodeFromNode(child, node, -1, -1);
-            generateCodeFromNode(rChild, node, -1, -1);
-
-            String name;
-            switch (op) {
-              case TokenStream.EQ:
-                name = version == Context.VERSION_1_2 ? "shallowEq" : "eq";
-                addScriptRuntimeInvoke(name,
-                                "(Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                break;
-
-              case TokenStream.NE:
-                name = version == Context.VERSION_1_2 ? "shallowNeq" : "neq";
-                addOptRuntimeInvoke(name,
-                                "(Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                break;
-
-              case TokenStream.SHEQ:
-                name = "shallowEq";
-                addScriptRuntimeInvoke(name,
-                                "(Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                break;
-
-              case TokenStream.SHNE:
-                name = "shallowNeq";
-                addOptRuntimeInvoke(name,
-                                "(Ljava/lang/Object;Ljava/lang/Object;)", "Z");
-                break;
-
-              default:
-                name = null;
-                badTree();
-            }
-            addByteCode(ByteCode.IFNE, trueGOTO);
-            addByteCode(ByteCode.GOTO, falseGOTO);
-        }
-    }
-
-    private void visitLiteral(Node node) {
-        if (node.getType() == TokenStream.STRING) {
-            // just load the string constant
-            push(node.getString());
-        } else {
-            double num = node.getDouble();
-            if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-                push(num);
-            }
-            else if (itsConstantListSize >= 2000) {
-                // There appears to be a limit in the JVM on either the number
-                // of static fields in a class or the size of the class
-                // initializer. Either way, we can't have any more than 2000
-                // statically init'd constants.
-                pushAsWrapperObject(num);
-            }
-            else {
-                String constantName = "jsK_" + addNumberConstant(num);
-                String constantType = getStaticConstantWrapperType(num);
-                classFile.add(ByteCode.GETSTATIC,
-                              classFile.fullyQualifiedForm(this.name),
-                              constantName, constantType);
-            }
-        }
-    }
-
-    private String getStaticConstantWrapperType(double num) {
-        String constantType;
-        int inum = (int)num;
-        if (inum == num) {
-            if ((byte)inum == inum) {
-                constantType = "Ljava/lang/Byte;";
-            }
-            else if ((short)inum == inum) {
-                constantType = "Ljava/lang/Short;";
-            }
-            else {
-                constantType = "Ljava/lang/Integer;";
-            }
-        }
-        else {
-            // See comments in push(double)
-            //if ((float)num == num) {
-            //      constantType = "Ljava/lang/Float;";
-            //}
-            //else {
-                constantType = "Ljava/lang/Double;";
-            //}
-        }
-        return constantType;
-    }
-
-    private int addNumberConstant(double num) {
-        int N = itsConstantListSize;
-        if (N == 0) {
-            itsConstantList = new double[128];
-        }
-        else {
-            double[] array = itsConstantList;
-            for (int i = 0; i != N; ++i) {
-                if (array[i] == num) { return i; }
-            }
-            if (N == array.length) {
-                array = new double[N * 2];
-                System.arraycopy(itsConstantList, 0, array, 0, N);
-                itsConstantList = array;
-            }
-        }
-        itsConstantList[N] = num;
-        itsConstantListSize = N + 1;
-        return N;
-    }
-
-    private void emitConstantDudeInitializers() {
-        int N = itsConstantListSize;
-        if (N == 0)
-            return;
-
-        classFile.startMethod("<clinit>", "()V",
-            (short)(ClassFileWriter.ACC_STATIC + ClassFileWriter.ACC_FINAL));
-
-        double[] array = itsConstantList;
-        for (int i = 0; i != N; ++i) {
-            double num = array[i];
-            String constantName = "jsK_" + addNumberConstant(num);
-            String constantType = getStaticConstantWrapperType(num);
-            classFile.addField(constantName, constantType,
-                               ClassFileWriter.ACC_STATIC);
-            pushAsWrapperObject(num);
-            classFile.add(ByteCode.PUTSTATIC,
-                          classFile.fullyQualifiedForm(this.name),
-                          constantName, constantType);
-        }
-
-        addByteCode(ByteCode.RETURN);
-        classFile.stopMethod((short)0, null);
-    }
-
-   private void visitPrimary(Node node) {
-        int op = node.getOperation();
-        switch (op) {
-
-          case TokenStream.THIS:
-            aload(thisObjLocal);
-            break;
-
-          case TokenStream.THISFN:
-            classFile.add(ByteCode.ALOAD_0);
-            break;
-
-          case TokenStream.NULL:
-            addByteCode(ByteCode.ACONST_NULL);
-            break;
-
-          case TokenStream.TRUE:
-            classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                    "TRUE", "Ljava/lang/Boolean;");
-            break;
-
-          case TokenStream.FALSE:
-            classFile.add(ByteCode.GETSTATIC, "java/lang/Boolean",
-                                    "FALSE", "Ljava/lang/Boolean;");
-            break;
-
-          case TokenStream.UNDEFINED:
-            pushUndefined();
-            break;
-
-          default:
-            badTree();
-        }
-    }
-
-    private void visitObject(Node node) {
-        Node regexp = (Node) node.getProp(Node.REGEXP_PROP);
-        String fieldName = (String)(regexp.getProp(Node.REGEXP_PROP));
-        aload(funObjLocal);
-        classFile.add(ByteCode.GETFIELD,
-                        classFile.fullyQualifiedForm(this.name),
-                        fieldName, "Lorg/mozilla/javascript/regexp/NativeRegExp;");
-    }
-
-    private void visitName(Node node) {
-        aload(variableObjectLocal);             // get variable object
-        push(node.getString());                 // push name
-        addScriptRuntimeInvoke("name",
-            "(Lorg/mozilla/javascript/Scriptable;Ljava/lang/String;)",
-            "Ljava/lang/Object;");
-    }
-
-    private void visitSetName(Node node, Node child) {
-        String name = node.getFirstChild().getString();
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        aload(variableObjectLocal);
-        push(name);
-        addScriptRuntimeInvoke("setName",
-                "(Lorg/mozilla/javascript/Scriptable;Ljava/lang/Object;" +
-                 "Lorg/mozilla/javascript/Scriptable;Ljava/lang/String;)",
-                "Ljava/lang/Object;");
-    }
-
-    private void visitGetVar(OptLocalVariable lVar, boolean isNumber,
-                             String name)
-    {
-        // TODO: Clean up use of lVar here and in set.
-        if (hasVarsInRegs && lVar == null)
-            lVar = OptLocalVariable.get(vars, name);
-        if (lVar != null) {
-            if (lVar.getJRegister() == -1)
-                if (lVar.isNumber())
-                    lVar.assignJRegister(getNewWordPairLocal());
-                else
-                    lVar.assignJRegister(getNewWordLocal());
-            if (lVar.isParameter() && inDirectCallFunction &&
-                !itsForcedObjectParameters)
-            {
-/*
-    Remember that here the isNumber flag means that we want to
-    use the incoming parameter in a Number context, so test the
-    object type and convert the value as necessary.
-
-*/
-                if (isNumber) {
-                    aload(lVar.getJRegister());
-                    classFile.add(ByteCode.GETSTATIC,
-                            "java/lang/Void",
-                            "TYPE",
-                            "Ljava/lang/Class;");
-                    int isNumberLabel = acquireLabel();
-                    int beyond = acquireLabel();
-                    addByteCode(ByteCode.IF_ACMPEQ, isNumberLabel);
-                    aload(lVar.getJRegister());
-                    addScriptRuntimeInvoke("toNumber", "(Ljava/lang/Object;)", "D");
-                    addByteCode(ByteCode.GOTO, beyond);
-                    markLabel(isNumberLabel);
-                    dload((short)(lVar.getJRegister() + 1));
-                    markLabel(beyond);
-                } else {
-                    aload(lVar.getJRegister());
-                    classFile.add(ByteCode.GETSTATIC,
-                            "java/lang/Void",
-                            "TYPE",
-                            "Ljava/lang/Class;");
-                    int isNumberLabel = acquireLabel();
-                    int beyond = acquireLabel();
-                    addByteCode(ByteCode.IF_ACMPEQ, isNumberLabel);
-                    aload(lVar.getJRegister());
-                    addByteCode(ByteCode.GOTO, beyond);
-                    markLabel(isNumberLabel);
-                    addByteCode(ByteCode.NEW,"java/lang/Double");
-                    addByteCode(ByteCode.DUP);
-                    dload((short)(lVar.getJRegister() + 1));
-                    addDoubleConstructor();
-                    markLabel(beyond);
-                }
-            } else {
-                if (lVar.isNumber())
-                    dload(lVar.getJRegister());
-                else
-                    aload(lVar.getJRegister());
-            }
-            return;
-        }
-
-        aload(variableObjectLocal);
-        push(name);
-        aload(variableObjectLocal);
-        addScriptRuntimeInvoke("getProp",
-                        "(Ljava/lang/Object;Ljava/lang/String;" +
-                        "Lorg/mozilla/javascript/Scriptable;)",
-                        "Ljava/lang/Object;");
-    }
-
-    private void visitSetVar(Node node, Node child, boolean needValue) {
-        OptLocalVariable lVar = (OptLocalVariable)(node.getProp(Node.VARIABLE_PROP));
-        // XXX is this right? If so, clean up.
-        if (hasVarsInRegs && lVar == null)
-            lVar = OptLocalVariable.get(vars, child.getString());
-        if (lVar != null) {
-            generateCodeFromNode(child.getNext(), node, -1, -1);
-            if (lVar.getJRegister() == -1) {
-                if (lVar.isNumber())
-                    lVar.assignJRegister(getNewWordPairLocal());
-                else
-                    lVar.assignJRegister(getNewWordLocal());
-            }
-            if (lVar.isParameter()
-                        && inDirectCallFunction
-                        && !itsForcedObjectParameters) {
-                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-                    if (needValue) addByteCode(ByteCode.DUP2);
-                    aload(lVar.getJRegister());
-                    classFile.add(ByteCode.GETSTATIC,
-                            "java/lang/Void",
-                            "TYPE",
-                            "Ljava/lang/Class;");
-                    int isNumberLabel = acquireLabel();
-                    int beyond = acquireLabel();
-                    addByteCode(ByteCode.IF_ACMPEQ, isNumberLabel);
-                    addByteCode(ByteCode.NEW,"java/lang/Double");
-                    addByteCode(ByteCode.DUP);
-                    addByteCode(ByteCode.DUP2_X2);
-                    addByteCode(ByteCode.POP2);
-                    addDoubleConstructor();
-                    astore(lVar.getJRegister());
-                    addByteCode(ByteCode.GOTO, beyond);
-                    markLabel(isNumberLabel);
-                    dstore((short)(lVar.getJRegister() + 1));
-                    markLabel(beyond);
-                }
-                else {
-                    if (needValue) addByteCode(ByteCode.DUP);
-                    astore(lVar.getJRegister());
-                }
-            }
-            else {
-                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
-                      dstore(lVar.getJRegister());
-                      if (needValue) dload(lVar.getJRegister());
-                }
-                else {
-                    astore(lVar.getJRegister());
-                    if (needValue) aload(lVar.getJRegister());
-                }
-            }
-            return;
-        }
-
-        // default: just treat like any other name lookup
-        child.setType(TokenStream.BINDNAME);
-        node.setType(TokenStream.SETNAME);
-        visitSetName(node, child);
-        if (!needValue)
-            addByteCode(ByteCode.POP);
-    }
-
-
-    private void visitGetProp(Node node, Node child) {
-        String s = (String) node.getProp(Node.SPECIAL_PROP_PROP);
-        if (s != null) {
-            while (child != null) {
-                generateCodeFromNode(child, node, -1, -1);
-                child = child.getNext();
-            }
-            aload(variableObjectLocal);
-            String runtimeMethod = null;
-            if (s.equals("__proto__")) {
-                runtimeMethod = "getProto";
-            } else if (s.equals("__parent__")) {
-                runtimeMethod = "getParent";
-            } else {
-                badTree();
-            }
-            addScriptRuntimeInvoke(runtimeMethod,
-                            "(Ljava/lang/Object;Lorg/mozilla/javascript/Scriptable;)",
-                            "Lorg/mozilla/javascript/Scriptable;");
-            return;
-        }
-        Node nameChild = child.getNext();
-        /*
-            for 'this.foo' we call thisGet which can skip some
-            casting overhead.
-
-        */
-        generateCodeFromNode(child, node, -1, -1);      // the object
-        generateCodeFromNode(nameChild, node, -1, -1);  // the name
-        if (nameChild.getType() == TokenStream.STRING) {
-            if ((child.getType() == TokenStream.PRIMARY &&
-                        child.getOperation() == TokenStream.THIS)
-                  || ((child.getType() == TokenStream.NEWTEMP)
-                        && (child.getFirstChild().getType() == TokenStream.PRIMARY)
-                            && (child.getFirstChild().getOperation() == TokenStream.THIS))
-                        ) {
-                aload(variableObjectLocal);
-                addOptRuntimeInvoke("thisGet",
-                                "(Lorg/mozilla/javascript/Scriptable;" +
-                                "Ljava/lang/String;" +
-                                "Lorg/mozilla/javascript/Scriptable;)",
-                                "Ljava/lang/Object;");
-            }
-            else {
-                aload(variableObjectLocal);
-                addScriptRuntimeInvoke("getProp",
-                                "(Ljava/lang/Object;Ljava/lang/String;" +
-                                "Lorg/mozilla/javascript/Scriptable;)",
-                                "Ljava/lang/Object;");
-            }
-        }
-        else {
-            aload(variableObjectLocal);
-            addScriptRuntimeInvoke("getProp",
-                            "(Ljava/lang/Object;Ljava/lang/String;" +
-                            "Lorg/mozilla/javascript/Scriptable;)",
-                            "Ljava/lang/Object;");
-        }
-    }
-
-    private void visitSetProp(Node node, Node child) {
-        String s = (String) node.getProp(Node.SPECIAL_PROP_PROP);
-        if (s != null) {
-            while (child != null) {
-                generateCodeFromNode(child, node, -1, -1);
-                child = child.getNext();
-            }
-            aload(variableObjectLocal);
-            String runtimeMethod = null;
-            if (s.equals("__proto__")) {
-                runtimeMethod = "setProto";
-            } else if (s.equals("__parent__")) {
-                runtimeMethod = "setParent";
-            } else {
-                badTree();
-            }
-            addScriptRuntimeInvoke(runtimeMethod,
-                            "(Ljava/lang/Object;Ljava/lang/Object;" +
-                            "Lorg/mozilla/javascript/Scriptable;)",
-                            "Ljava/lang/Object;");
-            return;
-        }
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        aload(variableObjectLocal);
-        addScriptRuntimeInvoke("setProp",
-                        "(Ljava/lang/Object;Ljava/lang/String;" +
-                        "Ljava/lang/Object;Lorg/mozilla/javascript/Scriptable;)",
-                        "Ljava/lang/Object;");
-    }
-
-    private void visitBind(Node node, int type, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        // Generate code for "ScriptRuntime.bind(varObj, "s")"
-        aload(variableObjectLocal);             // get variable object
-        push(node.getString());                 // push name
-        addScriptRuntimeInvoke(type == TokenStream.BINDNAME ? "bind" : "getBase",
-                            "(Lorg/mozilla/javascript/Scriptable;Ljava/lang/String;)",
-                            "Lorg/mozilla/javascript/Scriptable;");
-    }
-
-    private short getLocalFromNode(Node node) {
-        int local = node.getIntProp(Node.LOCAL_PROP, -1);
-        if (local == -1) {
-            // for NEWLOCAL & USELOCAL, use the next pre-allocated
-            // register, otherwise for NEWTEMP & USETEMP, get the
-            // next available from the pool
-            local = ((node.getType() == TokenStream.NEWLOCAL)
-                                || (node.getType() == TokenStream.USELOCAL)) ?
-                            itsLocalAllocationBase++ : getNewWordLocal();
-
-            node.putIntProp(Node.LOCAL_PROP, local);
-        }
-        return (short)local;
-    }
-
-    private void visitNewTemp(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        short local = getLocalFromNode(node);
-        addByteCode(ByteCode.DUP);
-        astore(local);
-        if (node.getIntProp(Node.USES_PROP, 0) == 0)
-            releaseWordLocal(local);
-    }
-
-    private void visitUseTemp(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        Node temp = (Node) node.getProp(Node.TEMP_PROP);
-        short local = getLocalFromNode(temp);
-
-        // if the temp node has a magic TARGET property,
-        // treat it as a RET to that temp.
-        if (node.getProp(Node.TARGET_PROP) != null)
-            addByteCode(ByteCode.RET, local);
-        else
-            aload(local);
-        int n = temp.getIntProp(Node.USES_PROP, 0);
-        if (n <= 1) {
-                    releaseWordLocal(local);
-            }
-        if (n != 0 && n != Integer.MAX_VALUE) {
-            temp.putIntProp(Node.USES_PROP, n - 1);
-        }
-    }
-
-    private void visitNewLocal(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        short local = getLocalFromNode(node);
-        addByteCode(ByteCode.DUP);
-        astore(local);
-    }
-
-    private void visitUseLocal(Node node, Node child) {
-        while (child != null) {
-            generateCodeFromNode(child, node, -1, -1);
-            child = child.getNext();
-        }
-        Node temp = (Node) node.getProp(Node.LOCAL_PROP);
-        short local = getLocalFromNode(temp);
-
-        // if the temp node has a magic TARGET property,
-        // treat it as a RET to that temp.
-        if (node.getProp(Node.TARGET_PROP) != null)
-            addByteCode(ByteCode.RET, local);
-        else
-            aload(local);
-    }
-
-    private void dstore(short local) {
-        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);
-    }
-
-    private void istore(short local) {
-        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);
-    }
-
-    private void astore(short local) {
-        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);
-    }
-
-    private void xop(byte shortOp, byte op, short local) {
-        switch (local) {
-          case 0:
-            addByteCode(shortOp);
-            break;
-          case 1:
-            addByteCode((byte)(shortOp + 1));
-            break;
-          case 2:
-            addByteCode((byte)(shortOp + 2));
-            break;
-          case 3:
-            addByteCode((byte)(shortOp + 3));
-            break;
-          default:
-            if (local < 0 || local >= Short.MAX_VALUE)
-                throw new RuntimeException("bad local");
-            if (local < Byte.MAX_VALUE) {
-                addByteCode(op, (byte)local);
-            } else {
-                // Add wide opcode.
-                addByteCode(ByteCode.WIDE);
-                addByteCode(op);
-                addByteCode((byte)(local >> 8));
-                addByteCode((byte)(local & 0xff));
-            }
-            break;
-        }
-    }
-
-    private void dload(short local) {
-        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);
-    }
-
-    private void iload(short local) {
-        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);
-    }
-
-    private void aload(short local) {
-        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);
-    }
-
-    private short getNewWordPairLocal() {
-        short result = firstFreeLocal;
-        while (true) {
-            if (result >= (MAX_LOCALS - 1))
-                break;
-            if (!locals[result]
-                    && !locals[result + 1])
-                break;
-            result++;
-        }
-        if (result < (MAX_LOCALS - 1)) {
-            locals[result] = true;
-            locals[result + 1] = true;
-            if (result == firstFreeLocal) {
-                for (int i = firstFreeLocal + 2; i < MAX_LOCALS; i++) {
-                    if (!locals[i]) {
-                        firstFreeLocal = (short) i;
-                        if (localsMax < firstFreeLocal)
-                            localsMax = firstFreeLocal;
-                        return result;
-                    }
-                }
-            }
-            else {
-                return result;
-            }
-        }
-        throw Context.reportRuntimeError("Program too complex " +
-                                         "(out of locals)");
-    }
-
-    private short reserveWordLocal(int local) {
-        if (getNewWordLocal() != local)
-            throw new RuntimeException("Local allocation error");
-        return (short) local;
-    }
-
-    private short getNewWordLocal() {
-        short result = firstFreeLocal;
-        locals[result] = true;
-        for (int i = firstFreeLocal + 1; i < MAX_LOCALS; i++) {
-            if (!locals[i]) {
-                firstFreeLocal = (short) i;
-                if (localsMax < firstFreeLocal)
-                    localsMax = firstFreeLocal;
-                return result;
-            }
-        }
-        throw Context.reportRuntimeError("Program too complex " +
-                                         "(out of locals)");
-    }
-
-    private void releaseWordpairLocal(short local) {
-        if (local < firstFreeLocal)
-            firstFreeLocal = local;
-        locals[local] = false;
-        locals[local + 1] = false;
-    }
-
-    private void releaseWordLocal(short local) {
-        if (local < firstFreeLocal)
-            firstFreeLocal = local;
-        locals[local] = false;
-    }
-
-    private void push(int i) {
-        if ((byte)i == i) {
-            if (i == -1) {
-                addByteCode(ByteCode.ICONST_M1);
-            } else if (0 <= i && i <= 5) {
-                addByteCode((byte) (ByteCode.ICONST_0 + i));
-            } else {
-                addByteCode(ByteCode.BIPUSH, (byte) i);
-            }
-        } else if ((short)i == i) {
-            addByteCode(ByteCode.SIPUSH, (short) i);
-        } else {
-            classFile.addLoadConstant(i);
-        }
-    }
-
-    private void push(double d) {
-        if (d == 0.0) {
-            addByteCode(ByteCode.DCONST_0);
-        } else if (d == 1.0) {
-            addByteCode(ByteCode.DCONST_1);
-        /* XXX this breaks all sorts of simple math.
-        } else if (Float.MIN_VALUE <= d && d <= Float.MAX_VALUE) {
-        loadWordConstant(classFile.addFloatConstant((float) d));
-        */
-        } else {
-            classFile.addLoadConstant((double)d);
-        }
-    }
-
-    private void pushAsWrapperObject(double num) {
-        // Generate code to create the new numeric constant
-        //
-        // new java/lang/<WrapperType>
-        // dup
-        // push <number>
-        // invokestatic java/lang/<WrapperType>/<init>(X)V
-
-        String wrapperType;
-        String signature;
-        boolean isInteger;
-        int inum = (int)num;
-        if (inum == num) {
-            isInteger = true;
-            if ((byte)inum == inum) {
-                wrapperType = "java/lang/Byte";
-                signature = "(B)";
-            }
-            else if ((short)inum == inum) {
-                wrapperType = "java/lang/Short";
-                signature = "(S)";
-            }
-            else {
-                wrapperType = "java/lang/Integer";
-                signature = "(I)";
-            }
-        }
-        else {
-            isInteger = false;
-            // See comments in push(double)
-            //if ((float)num == num) {
-            //    wrapperType = "java/lang/Float";
-            //    signature = "(F)";
-            //}
-            //else {
-                wrapperType = "java/lang/Double";
-                signature = "(D)";
-            //}
-        }
-
-        addByteCode(ByteCode.NEW, wrapperType);
-        addByteCode(ByteCode.DUP);
-        if (isInteger) { push(inum); }
-        else { push(num); }
-        addSpecialInvoke(wrapperType, "<init>", signature, "V");
-    }
-
-    private void push(String s) {
-        classFile.addLoadConstant(s);
-    }
-
-    private void pushUndefined() {
-        classFile.add(ByteCode.GETSTATIC, "org/mozilla/javascript/Undefined",
-                "instance", "Lorg/mozilla/javascript/Scriptable;");
-    }
-
-
-    private void badTree() {
-        throw new RuntimeException("Bad tree in codegen");
-    }
-
-    private static final String functionSuperClassName =
-                          "org.mozilla.javascript.NativeFunction";
-    private static final String scriptSuperClassName =
-                          "org.mozilla.javascript.NativeScript";
-    private String superClassName;
-    private String superClassSlashName;
-    private String name;
-    private int ordinal;
-    boolean inFunction;
-    boolean inDirectCallFunction;
-    private ClassFileWriter classFile;
-    private short scriptRuntimeIndex;
-    private int version;
-
-    private String itsSourceFile;
-    private int itsLineNumber;
-
-    private int stackDepth;
-    private int stackDepthMax;
-
-    private static final int MAX_LOCALS = 256;
-    private boolean[] locals;
-    private short firstFreeLocal;
-    private short localsMax;
-
-    private double[] itsConstantList;
-    private int itsConstantListSize;
-
-    // special known locals. If you add a new local here, be sure
-    // to initialize it to -1 in startNewMethod
-    private short variableObjectLocal;
-    private short scriptResultLocal;
-    private short contextLocal;
-    private short argsLocal;
-    private short thisObjLocal;
-    private short funObjLocal;
-    private short debug_pcLocal;
-    private short debugStopSubRetLocal;
-    private short itsZeroArgArray;
-    private short itsOneArgArray;
-
-    private boolean itsUseDynamicScope;
-    private boolean hasVarsInRegs;
-    private boolean itsForcedObjectParameters;
-    private boolean trivialInit;
-    private short itsLocalAllocationBase;
-    private VariableTable vars;
-    private VariableTable debugVars;
-    private int epilogueLabel;
-    private int optLevel;
-}
-
Index: rhino/Context.java
===================================================================
RCS file: rhino/Context.java
diff -N rhino/Context.java
--- rhino/Context.java	22 Oct 2004 14:13:04 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,2297 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-2000 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- *
- * Patrick Beard
- * Norris Boyd
- * Igor Bukanov
- * Brendan Eich
- * Roger Lawrence
- * Mike McCabe
- * Ian D. Stewart
- * Andi Vajda
- * Andrew Wason
- * Kemal Bayram
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-// API class
-
-package org.mozilla.javascript;
-
-import java.beans.*;
-import java.io.*;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Locale;
-import java.util.ResourceBundle;
-import java.text.MessageFormat;
-import java.lang.reflect.*;
-import org.mozilla.javascript.debug.*;
-
-/**
- * This class represents the runtime context of an executing script.
- *
- * Before executing a script, an instance of Context must be created
- * and associated with the thread that will be executing the script.
- * The Context will be used to store information about the executing
- * of the script such as the call stack. Contexts are associated with
- * the current thread  using the <a href="#enter()">enter()</a> method.<p>
- *
- * The behavior of the execution engine may be altered through methods
- * such as <a href="#setLanguageVersion>setLanguageVersion</a> and
- * <a href="#setErrorReporter>setErrorReporter</a>.<p>
- *
- * Different forms of script execution are supported. Scripts may be
- * evaluated from the source directly, or first compiled and then later
- * executed. Interactive execution is also supported.<p>
- *
- * Some aspects of script execution, such as type conversions and
- * object creation, may be accessed directly through methods of
- * Context.
- *
- * @see Scriptable
- * @author Norris Boyd
- * @author Brendan Eich
- */
-
-public class Context {
-    public static final String languageVersionProperty = "language version";
-    public static final String errorReporterProperty   = "error reporter";
-
-    /**
-     * Create a new Context.
-     *
-     * Note that the Context must be associated with a thread before
-     * it can be used to execute a script.
-     *
-     * @see org.mozilla.javascript.Context#enter
-     */
-    public Context() {
-        setLanguageVersion(VERSION_DEFAULT);
-        optimizationLevel = codegenClass != null ? 0 : -1;
-        Object[] array = contextListeners;
-        if (array != null) {
-            for (int i = array.length; i-- != 0;) {
-                ((ContextListener)array[i]).contextCreated(this);
-            }
-        }
-    }
-
-/**
-@deprecated The {@link SecuritySupport} class is deprecated. See its documentation for the upgrade path.
-*/
-    public Context(SecuritySupport x) {
-        this();
-        setClassShutter(x);
-    }
-
-    /**
-     * Get a context associated with the current thread, creating
-     * one if need be.
-     *
-     * The Context stores the execution state of the JavaScript
-     * engine, so it is required that the context be entered
-     * before execution may begin. Once a thread has entered
-     * a Context, then getCurrentContext() may be called to find
-     * the context that is associated with the current thread.
-     * <p>
-     * Calling <code>enter()</code> will
-     * return either the Context currently associated with the
-     * thread, or will create a new context and associate it
-     * with the current thread. Each call to <code>enter()</code>
-     * must have a matching call to <code>exit()</code>. For example,
-     * <pre>
-     *      Context cx = Context.enter();
-     *      try {
-     *          ...
-     *          cx.evaluateString(...);
-     *      }
-     *      finally { Context.exit(); }
-     * </pre>
-     * @return a Context associated with the current thread
-     * @see org.mozilla.javascript.Context#getCurrentContext
-     * @see org.mozilla.javascript.Context#exit
-     */
-    public static Context enter() {
-        return enter(null);
-    }
-
-    /**
-     * Get a Context associated with the current thread, using
-     * the given Context if need be.
-     * <p>
-     * The same as <code>enter()</code> except that <code>cx</code>
-     * is associated with the current thread and returned if
-     * the current thread has no associated context and <code>cx</code>
-     * is not associated with any other thread.
-     * @param cx a Context to associate with the thread if possible
-     * @return a Context associated with the current thread
-     */
-    public static Context enter(Context cx) {
-
-        Context old = getCurrentContext();
-
-        if (cx == null) {
-            if (old != null) {
-                cx = old;
-            } else {
-                cx = new Context();
-                setThreadContext(cx);
-            }
-        } else {
-            if (cx.enterCount != 0) {
-                // The suplied context must be the context for
-                // the current thread if it is already entered
-                if (cx != old) {
-                    throw new RuntimeException
-                        ("Cannot enter Context active on another thread");
-                }
-            } else {
-                if (old != null) {
-                    cx = old;
-                } else {
-                    setThreadContext(cx);
-                }
-            }
-        }
-
-        ++cx.enterCount;
-
-        Object[] listeners = contextListeners;
-        if (listeners != null) {
-            for (int i = listeners.length; i-- != 0;) {
-                ((ContextListener)listeners[i]).contextEntered(cx);
-            }
-        }
-        return cx;
-     }
-
-    /**
-     * Exit a block of code requiring a Context.
-     *
-     * Calling <code>exit()</code> will remove the association between
-     * the current thread and a Context if the prior call to
-     * <code>enter()</code> on this thread newly associated a Context
-     * with this thread.
-     * Once the current thread no longer has an associated Context,
-     * it cannot be used to execute JavaScript until it is again associated
-     * with a Context.
-     *
-     * @see org.mozilla.javascript.Context#enter
-     */
-    public static void exit() {
-        boolean released = false;
-        Context cx = getCurrentContext();
-        if (cx == null) {
-            throw new RuntimeException
-                ("Calling Context.exit without previous Context.enter");
-        }
-        if (Context.check && cx.enterCount < 1) Context.codeBug();
-        --cx.enterCount;
-        if (cx.enterCount == 0) {
-            released = true;
-            setThreadContext(null);
-        }
-
-        Object[] listeners = contextListeners;
-        if (listeners != null) {
-            for (int i = listeners.length; i-- != 0;) {
-                ((ContextListener)listeners[i]).contextExited(cx);
-            }
-            if (released) {
-                for (int i = listeners.length; i-- != 0;) {
-                    ((ContextListener)listeners[i]).contextReleased(cx);
-                }
-            }
-        }
-    }
-
-    /**
-     * Add a Context listener.
-     */
-    public static void addContextListener(ContextListener listener) {
-        synchronized (contextListenersLock) {
-            contextListeners = ListenerArray.add(contextListeners, listener);
-        }
-    }
-
-    /**
-     * Remove a Context listener.
-     * @param listener the listener to remove.
-     */
-    public static void removeContextListener(ContextListener listener) {
-        synchronized (contextListenersLock) {
-            contextListeners = ListenerArray.remove(contextListeners, listener);
-        }
-    }
-
-    /**
-     * Get the current Context.
-     *
-     * The current Context is per-thread; this method looks up
-     * the Context associated with the current thread. <p>
-     *
-     * @return the Context associated with the current thread, or
-     *         null if no context is associated with the current
-     *         thread.
-     * @see org.mozilla.javascript.Context#enter
-     * @see org.mozilla.javascript.Context#exit
-     */
-    public static Context getCurrentContext() {
-        if (threadLocalCx != null) {
-            try {
-                return (Context)threadLocalGet.invoke(threadLocalCx, null);
-            } catch (Exception ex) { }
-        }
-        Thread t = Thread.currentThread();
-        return (Context) threadContexts.get(t);
-    }
-
-    private static void setThreadContext(Context cx) {
-        if (threadLocalCx != null) {
-            try {
-                threadLocalSet.invoke(threadLocalCx, new Object[] { cx });
-                return;
-            } catch (Exception ex) { }
-        }
-        Thread t = Thread.currentThread();
-        if (cx != null) {
-            threadContexts.put(t, cx);
-        } else {
-            threadContexts.remove(t);
-        }
-    }
-
-    /**
-     * Language versions
-     *
-     * All integral values are reserved for future version numbers.
-     */
-
-    /**
-     * The unknown version.
-     */
-    public static final int VERSION_UNKNOWN =   -1;
-
-    /**
-     * The default version.
-     */
-    public static final int VERSION_DEFAULT =    0;
-
-    /**
-     * JavaScript 1.0
-     */
-    public static final int VERSION_1_0 =      100;
-
-    /**
-     * JavaScript 1.1
-     */
-    public static final int VERSION_1_1 =      110;
-
-    /**
-     * JavaScript 1.2
-     */
-    public static final int VERSION_1_2 =      120;
-
-    /**
-     * JavaScript 1.3
-     */
-    public static final int VERSION_1_3 =      130;
-
-    /**
-     * JavaScript 1.4
-     */
-    public static final int VERSION_1_4 =      140;
-
-    /**
-     * JavaScript 1.5
-     */
-    public static final int VERSION_1_5 =      150;
-
-    /**
-     * Get the current language version.
-     * <p>
-     * The language version number affects JavaScript semantics as detailed
-     * in the overview documentation.
-     *
-     * @return an integer that is one of VERSION_1_0, VERSION_1_1, etc.
-     */
-    public int getLanguageVersion() {
-       return version;
-    }
-
-    /**
-     * Set the language version.
-     *
-     * <p>
-     * Setting the language version will affect functions and scripts compiled
-     * subsequently. See the overview documentation for version-specific
-     * behavior.
-     *
-     * @param version the version as specified by VERSION_1_0, VERSION_1_1, etc.
-     */
-    public void setLanguageVersion(int version) {
-        Object[] array = listeners;
-        if (array != null && version != this.version) {
-            firePropertyChangeImpl(array, languageVersionProperty,
-                               new Integer(this.version),
-                               new Integer(version));
-        }
-        this.version = version;
-    }
-
-    /**
-     * Get the implementation version.
-     *
-     * <p>
-     * The implementation version is of the form
-     * <pre>
-     *    "<i>name langVer</i> <code>release</code> <i>relNum date</i>"
-     * </pre>
-     * where <i>name</i> is the name of the product, <i>langVer</i> is
-     * the language version, <i>relNum</i> is the release number, and
-     * <i>date</i> is the release date for that specific
-     * release in the form "yyyy mm dd".
-     *
-     * @return a string that encodes the product, language version, release
-     *         number, and date.
-     */
-     public String getImplementationVersion() {
-        return "Rhino 1.5 release 4.1 2003 04 21";
-     }
-
-    /**
-     * Get the current error reporter.
-     *
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public ErrorReporter getErrorReporter() {
-        if (errorReporter == null) {
-            errorReporter = new DefaultErrorReporter();
-        }
-        return errorReporter;
-    }
-
-    /**
-     * Change the current error reporter.
-     *
-     * @return the previous error reporter
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public ErrorReporter setErrorReporter(ErrorReporter reporter) {
-        ErrorReporter result = errorReporter;
-        Object[] array = listeners;
-        if (array != null && errorReporter != reporter) {
-            firePropertyChangeImpl(array, errorReporterProperty,
-                                   errorReporter, reporter);
-        }
-        errorReporter = reporter;
-        return result;
-    }
-
-    /**
-     * Get the current locale.  Returns the default locale if none has
-     * been set.
-     *
-     * @see java.util.Locale
-     */
-
-    public Locale getLocale() {
-        if (locale == null)
-            locale = Locale.getDefault();
-        return locale;
-    }
-
-    /**
-     * Set the current locale.
-     *
-     * @see java.util.Locale
-     */
-    public Locale setLocale(Locale loc) {
-        Locale result = locale;
-        locale = loc;
-        return result;
-    }
-
-    /**
-     * Register an object to receive notifications when a bound property
-     * has changed
-     * @see java.beans.PropertyChangeEvent
-     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)
-     * @param  listener  the listener
-     */
-    public void addPropertyChangeListener(PropertyChangeListener listener) {
-        synchronized (this) {
-            listeners = ListenerArray.add(listeners, listener);
-        }
-    }
-
-    /**
-     * Remove an object from the list of objects registered to receive
-     * notification of changes to a bounded property
-     * @see java.beans.PropertyChangeEvent
-     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
-     * @param listener  the listener
-     */
-    public void removePropertyChangeListener(PropertyChangeListener listener) {
-        synchronized (this) {
-            listeners = ListenerArray.remove(listeners, listener);
-        }
-    }
-
-    /**
-     * Notify any registered listeners that a bounded property has changed
-     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
-     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)
-     * @see java.beans.PropertyChangeListener
-     * @see java.beans.PropertyChangeEvent
-     * @param  property  the bound property
-     * @param  oldValue  the old value
-     * @param  newVale   the new value
-     */
-    void firePropertyChange(String property, Object oldValue,
-                            Object newValue)
-    {
-        Object[] array = listeners;
-        if (array != null) {
-            firePropertyChangeImpl(array, property, oldValue, newValue);
-        }
-    }
-
-    private void firePropertyChangeImpl(Object[] array, String property,
-                                        Object oldValue, Object newValue)
-    {
-        for (int i = array.length; i-- != 0;) {
-            Object obj = array[i];
-            if (obj instanceof PropertyChangeListener) {
-                PropertyChangeListener l = (PropertyChangeListener)obj;
-                l.propertyChange(new PropertyChangeEvent(
-                    this, property, oldValue, newValue));
-            }
-    }
-    }
-
-    /**
-     * Report a warning using the error reporter for the current thread.
-     *
-     * @param message the warning message to report
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param lineSource the text of the line (may be null)
-     * @param lineOffset the offset into lineSource where problem was detected
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static void reportWarning(String message, String sourceName,
-                                     int lineno, String lineSource,
-                                     int lineOffset)
-    {
-        Context cx = Context.getContext();
-        cx.getErrorReporter().warning(message, sourceName, lineno,
-                                      lineSource, lineOffset);
-    }
-
-    /**
-     * Report a warning using the error reporter for the current thread.
-     *
-     * @param message the warning message to report
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static void reportWarning(String message) {
-        int[] linep = { 0 };
-        String filename = getSourcePositionFromStack(linep);
-        Context.reportWarning(message, filename, linep[0], null, 0);
-    }
-
-    /**
-     * Report an error using the error reporter for the current thread.
-     *
-     * @param message the error message to report
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param lineSource the text of the line (may be null)
-     * @param lineOffset the offset into lineSource where problem was detected
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static void reportError(String message, String sourceName,
-                                   int lineno, String lineSource,
-                                   int lineOffset)
-    {
-        Context cx = getCurrentContext();
-        if (cx != null) {
-            cx.errorCount++;
-            cx.getErrorReporter().error(message, sourceName, lineno,
-                                        lineSource, lineOffset);
-        } else {
-            throw new EvaluatorException(message);
-        }
-    }
-
-    /**
-     * Report an error using the error reporter for the current thread.
-     *
-     * @param message the error message to report
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static void reportError(String message) {
-        int[] linep = { 0 };
-        String filename = getSourcePositionFromStack(linep);
-        Context.reportError(message, filename, linep[0], null, 0);
-    }
-
-    /**
-     * Report a runtime error using the error reporter for the current thread.
-     *
-     * @param message the error message to report
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param lineSource the text of the line (may be null)
-     * @param lineOffset the offset into lineSource where problem was detected
-     * @return a runtime exception that will be thrown to terminate the
-     *         execution of the script
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static EvaluatorException reportRuntimeError(String message,
-                                                      String sourceName,
-                                                      int lineno,
-                                                      String lineSource,
-                                                      int lineOffset)
-    {
-        Context cx = getCurrentContext();
-        if (cx != null) {
-            cx.errorCount++;
-            return cx.getErrorReporter().
-                            runtimeError(message, sourceName, lineno,
-                                         lineSource, lineOffset);
-        } else {
-            throw new EvaluatorException(message);
-        }
-    }
-
-    static EvaluatorException reportRuntimeError0(String messageId) {
-        return reportRuntimeError(getMessage0(messageId));
-    }
-
-    static EvaluatorException reportRuntimeError1
-        (String messageId, Object arg1)
-    {
-        return reportRuntimeError(getMessage1(messageId, arg1));
-    }
-
-    static EvaluatorException reportRuntimeError2
-        (String messageId, Object arg1, Object arg2)
-    {
-        return reportRuntimeError(getMessage2(messageId, arg1, arg2));
-    }
-
-    static EvaluatorException reportRuntimeError3
-        (String messageId, Object arg1, Object arg2, Object arg3)
-    {
-        return reportRuntimeError(getMessage3(messageId, arg1, arg2, arg3));
-    }
-
-    /**
-     * Report a runtime error using the error reporter for the current thread.
-     *
-     * @param message the error message to report
-     * @see org.mozilla.javascript.ErrorReporter
-     */
-    public static EvaluatorException reportRuntimeError(String message) {
-        int[] linep = { 0 };
-        String filename = getSourcePositionFromStack(linep);
-        return Context.reportRuntimeError(message, filename, linep[0], null, 0);
-    }
-
-    /**
-     * Initialize the standard objects.
-     *
-     * Creates instances of the standard objects and their constructors
-     * (Object, String, Number, Date, etc.), setting up 'scope' to act
-     * as a global object as in ECMA 15.1.<p>
-     *
-     * This method must be called to initialize a scope before scripts
-     * can be evaluated in that scope.<p>
-     *
-     * This method does not affect the Context it is called upon.
-     *
-     * @param scope the scope to initialize, or null, in which case a new
-     *        object will be created to serve as the scope
-     * @return the initialized scope
-     */
-    public Scriptable initStandardObjects(ScriptableObject scope) {
-        return initStandardObjects(scope, false);
-    }
-
-    /**
-     * Initialize the standard objects.
-     *
-     * Creates instances of the standard objects and their constructors
-     * (Object, String, Number, Date, etc.), setting up 'scope' to act
-     * as a global object as in ECMA 15.1.<p>
-     *
-     * This method must be called to initialize a scope before scripts
-     * can be evaluated in that scope.<p>
-     *
-     * This method does not affect the Context it is called upon.<p>
-     *
-     * This form of the method also allows for creating "sealed" standard
-     * objects. An object that is sealed cannot have properties added or
-     * removed. This is useful to create a "superglobal" that can be shared
-     * among several top-level objects. Note that sealing is not allowed in
-     * the current ECMA/ISO language specification, but is likely for
-     * the next version.
-     *
-     * @param scope the scope to initialize, or null, in which case a new
-     *        object will be created to serve as the scope
-     * @param sealed whether or not to create sealed standard objects that
-     *        cannot be modified.
-     * @return the initialized scope
-     * @since 1.4R3
-     */
-    public ScriptableObject initStandardObjects(ScriptableObject scope,
-                                                boolean sealed)
-    {
-        if (scope == null)
-            scope = new NativeObject();
-
-        BaseFunction.init(this, scope, sealed);
-        NativeObject.init(this, scope, sealed);
-
-        Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
-
-        // Function.prototype.__proto__ should be Object.prototype
-        Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
-        functionProto.setPrototype(objectProto);
-
-        // Set the prototype of the object passed in if need be
-        if (scope.getPrototype() == null)
-            scope.setPrototype(objectProto);
-
-        // must precede NativeGlobal since it's needed therein
-        NativeError.init(this, scope, sealed);
-        NativeGlobal.init(this, scope, sealed);
-
-        NativeArray.init(this, scope, sealed);
-        NativeString.init(this, scope, sealed);
-        NativeBoolean.init(this, scope, sealed);
-        NativeNumber.init(this, scope, sealed);
-        NativeDate.init(this, scope, sealed);
-        NativeMath.init(this, scope, sealed);
-
-        NativeWith.init(this, scope, sealed);
-        NativeCall.init(this, scope, sealed);
-        NativeScript.init(this, scope, sealed);
-
-        new LazilyLoadedCtor(scope,
-                             "RegExp",
-                             "org.mozilla.javascript.regexp.NativeRegExp",
-                             sealed);
-
-        // This creates the Packages and java package roots.
-        new LazilyLoadedCtor(scope,
-                             "Packages",
-                             "org.mozilla.javascript.NativeJavaPackage",
-                             sealed);
-        new LazilyLoadedCtor(scope,
-                             "java",
-                             "org.mozilla.javascript.NativeJavaPackage",
-                             sealed);
-        new LazilyLoadedCtor(scope,
-                             "getClass",
-                             "org.mozilla.javascript.NativeJavaPackage",
-                             sealed);
-
-        // Define the JavaAdapter class, allowing it to be overridden.
-        String adapterClass = "org.mozilla.javascript.JavaAdapter";
-        String adapterProperty = "JavaAdapter";
-        try {
-            adapterClass = System.getProperty(adapterClass, adapterClass);
-            adapterProperty = System.getProperty
-                ("org.mozilla.javascript.JavaAdapterClassName",
-                 adapterProperty);
-        }
-        catch (SecurityException e) {
-            // We may not be allowed to get system properties. Just
-            // use the default adapter in that case.
-        }
-
-        new LazilyLoadedCtor(scope, adapterProperty, adapterClass, sealed);
-
-        return scope;
-    }
-
-    /**
-     * Get the singleton object that represents the JavaScript Undefined value.
-     */
-    public static Object getUndefinedValue() {
-        return Undefined.instance;
-    }
-
-    /**
-     * Evaluate a JavaScript source string.
-     *
-     * The provided source name and line number are used for error messages
-     * and for producing debug information.
-     *
-     * @param scope the scope to execute in
-     * @param source the JavaScript source
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param securityDomain an arbitrary object that specifies security
-     *        information about the origin or owner of the script. For
-     *        implementations that don't care about security, this value
-     *        may be null.
-     * @return the result of evaluating the string
-     * @exception JavaScriptException if an uncaught JavaScript exception
-     *            occurred while evaluating the source string
-     * @see org.mozilla.javascript.SecuritySupport
-     */
-    public Object evaluateString(Scriptable scope, String source,
-                                 String sourceName, int lineno,
-                                 Object securityDomain)
-        throws JavaScriptException
-    {
-        try {
-            Reader in = new StringReader(source);
-            return evaluateReader(scope, in, sourceName, lineno,
-                                  securityDomain);
-        }
-        catch (IOException ioe) {
-            // Should never occur because we just made the reader from a String
-            throw new RuntimeException();
-        }
-    }
-
-    /**
-     * Evaluate a reader as JavaScript source.
-     *
-     * All characters of the reader are consumed.
-     *
-     * @param scope the scope to execute in
-     * @param in the Reader to get JavaScript source from
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param securityDomain an arbitrary object that specifies security
-     *        information about the origin or owner of the script. For
-     *        implementations that don't care about security, this value
-     *        may be null.
-     * @return the result of evaluating the source
-     *
-     * @exception IOException if an IOException was generated by the Reader
-     * @exception JavaScriptException if an uncaught JavaScript exception
-     *            occurred while evaluating the Reader
-     */
-    public Object evaluateReader(Scriptable scope, Reader in,
-                                 String sourceName, int lineno,
-                                 Object securityDomain)
-        throws IOException, JavaScriptException
-    {
-        Script script = compileReader(scope, in, sourceName, lineno,
-                                      securityDomain);
-        if (script != null)
-            return script.exec(this, scope);
-        else
-            return null;
-    }
-
-    /**
-     * Check whether a string is ready to be compiled.
-     * <p>
-     * stringIsCompilableUnit is intended to support interactive compilation of
-     * javascript.  If compiling the string would result in an error
-     * that might be fixed by appending more source, this method
-     * returns false.  In every other case, it returns true.
-     * <p>
-     * Interactive shells may accumulate source lines, using this
-     * method after each new line is appended to check whether the
-     * statement being entered is complete.
-     *
-     * @param source the source buffer to check
-     * @return whether the source is ready for compilation
-     * @since 1.4 Release 2
-     */
-    synchronized public boolean stringIsCompilableUnit(String source)
-    {
-        Reader in = new StringReader(source);
-        // no source name or source text manager, because we're just
-        // going to throw away the result.
-        TokenStream ts = new TokenStream(in, null, null, 1);
-
-        // Temporarily set error reporter to always be the exception-throwing
-        // DefaultErrorReporter.  (This is why the method is synchronized...)
-        ErrorReporter currentReporter =
-            setErrorReporter(new DefaultErrorReporter());
-
-        boolean errorseen = false;
-        try {
-            IRFactory irf = new IRFactory(ts, null);
-            Parser p = new Parser(irf);
-            p.parse(ts);
-        } catch (IOException ioe) {
-            errorseen = true;
-        } catch (EvaluatorException ee) {
-            errorseen = true;
-        } finally {
-            // Restore the old error reporter.
-            setErrorReporter(currentReporter);
-        }
-        // Return false only if an error occurred as a result of reading past
-        // the end of the file, i.e. if the source could be fixed by
-        // appending more source.
-        if (errorseen && ts.eof())
-            return false;
-        else
-            return true;
-    }
-
-    /**
-     * Compiles the source in the given reader.
-     * <p>
-     * Returns a script that may later be executed.
-     * Will consume all the source in the reader.
-     *
-     * @param scope if nonnull, will be the scope in which the script object
-     *        is created. The script object will be a valid JavaScript object
-     *        as if it were created using the JavaScript1.3 Script constructor
-     * @param in the input reader
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number for reporting errors
-     * @param securityDomain an arbitrary object that specifies security
-     *        information about the origin or owner of the script. For
-     *        implementations that don't care about security, this value
-     *        may be null.
-     * @return a script that may later be executed
-     * @see org.mozilla.javascript.Script#exec
-     * @exception IOException if an IOException was generated by the Reader
-     */
-    public Script compileReader(Scriptable scope, Reader in, String sourceName,
-                                int lineno, Object securityDomain)
-        throws IOException
-    {
-        return (Script) compile(scope, in, sourceName, lineno, securityDomain,
-                                false);
-    }
-
-
-    /**
-     * Compile a JavaScript function.
-     * <p>
-     * The function source must be a function definition as defined by
-     * ECMA (e.g., "function f(a) { return a; }").
-     *
-     * @param scope the scope to compile relative to
-     * @param source the function definition source
-     * @param sourceName a string describing the source, such as a filename
-     * @param lineno the starting line number
-     * @param securityDomain an arbitrary object that specifies security
-     *        information about the origin or owner of the script. For
-     *        implementations that don't care about security, this value
-     *        may be null.
-     * @return a Function that may later be called
-     * @see org.mozilla.javascript.Function
-     */
-    public Function compileFunction(Scriptable scope, String source,
-                                    String sourceName, int lineno,
-                                    Object securityDomain)
-    {
-        Reader in = new StringReader(source);
-        try {
-            return (Function) compile(scope, in, sourceName, lineno,
-                                      securityDomain, true);
-        }
-        catch (IOException ioe) {
-            // Should never happen because we just made the reader
-            // from a String
-            throw new RuntimeException();
-        }
-    }
-
-    /**
-     * Decompile the script.
-     * <p>
-     * The canonical source of the script is returned.
-     *
-     * @param script the script to decompile
-     * @param scope the scope under which to decompile
-     * @param indent the number of spaces to indent the result
-     * @return a string representing the script source
-     */
-     public String decompileScript(Script script, Scriptable scope,
-                                   int indent)
-    {
-        NativeScript ns = (NativeScript) script;
-        ns.initScript(scope);
-        return ns.decompile(this, indent, false);
-    }
-
-    /**
-     * Decompile a JavaScript Function.
-     * <p>
-     * Decompiles a previously compiled JavaScript function object to
-     * canonical source.
-     * <p>
-     * Returns function body of '[native code]' if no decompilation
-     * information is available.
-     *
-     * @param fun the JavaScript function to decompile
-     * @param indent the number of spaces to indent the result
-     * @return a string representing the function source
-     */
-    public String decompileFunction(Function fun, int indent) {
-        if (fun instanceof BaseFunction)
-            return ((BaseFunction)fun).decompile(this, indent, false);
-        else
-            return "function " + fun.getClassName() +
-                   "() {\n\t[native code]\n}\n";
-    }
-
-    /**
-     * Decompile the body of a JavaScript Function.
-     * <p>
-     * Decompiles the body a previously compiled JavaScript Function
-     * object to canonical source, omitting the function header and
-     * trailing brace.
-     *
-     * Returns '[native code]' if no decompilation information is available.
-     *
-     * @param fun the JavaScript function to decompile
-     * @param indent the number of spaces to indent the result
-     * @return a string representing the function body source.
-     */
-    public String decompileFunctionBody(Function fun, int indent) {
-        if (fun instanceof BaseFunction)
-            return ((BaseFunction)fun).decompile(this, indent, true);
-        else
-            // not sure what the right response here is.  JSRef currently
-            // dumps core.
-            return "[native code]\n";
-    }
-
-    /**
-     * Create a new JavaScript object.
-     *
-     * Equivalent to evaluating "new Object()".
-     * @param scope the scope to search for the constructor and to evaluate
-     *              against
-     * @return the new object
-     * @exception PropertyException if "Object" cannot be found in
-     *            the scope
-     * @exception NotAFunctionException if the "Object" found in the scope
-     *            is not a function
-     * @exception JavaScriptException if an uncaught JavaScript exception
-     *            occurred while creating the object
-     */
-    public Scriptable newObject(Scriptable scope)
-        throws PropertyException,
-               NotAFunctionException,
-               JavaScriptException
-    {
-        return newObject(scope, "Object", null);
-    }
-
-    /**
-     * Create a new JavaScript object by executing the named constructor.
-     *
-     * The call <code>newObject(scope, "Foo")</code> is equivalent to
-     * evaluating "new Foo()".
-     *
-     * @param scope the scope to search for the constructor and to evaluate against
-     * @param constructorName the name of the constructor to call
-     * @return the new object
-     * @exception PropertyException if a property with the constructor
-     *            name cannot be found in the scope
-     * @exception NotAFunctionException if the property found in the scope
-     *            is not a function
-     * @exception JavaScriptException if an uncaught JavaScript exception
-     *            occurred while creating the object
-     */
-    public Scriptable newObject(Scriptable scope, String constructorName)
-        throws PropertyException,
-               NotAFunctionException,
-               JavaScriptException
-    {
-        return newObject(scope, constructorName, null);
-    }
-
-    /**
-     * Creates a new JavaScript object by executing the named constructor.
-     *
-     * Searches <code>scope</code> for the named constructor, calls it with
-     * the given arguments, and returns the result.<p>
-     *
-     * The code
-     * <pre>
-     * Object[] args = { "a", "b" };
-     * newObject(scope, "Foo", args)</pre>
-     * is equivalent to evaluating "new Foo('a', 'b')", assuming that the Foo
-     * constructor has been defined in <code>scope</code>.
-     *
-     * @param scope The scope to search for the constructor and to evaluate
-     *              against
-     * @param constructorName the name of the constructor to call
-     * @param args the array of arguments for the constructor
-     * @return the new object
-     * @exception PropertyException if a property with the constructor
-     *            name cannot be found in the scope
-     * @exception NotAFunctionException if the property found in the scope
-     *            is not a function
-     * @exception JavaScriptException if an uncaught JavaScript exception
-     *            occurs while creating the object
-     */
-    public Scriptable newObject(Scriptable scope, String constructorName,
-                                Object[] args)
-        throws PropertyException,
-               NotAFunctionException,
-               JavaScriptException
-    {
-        scope = ScriptableObject.getTopLevelScope(scope);
-        Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
-        if (ctorVal instanceof Function) {
-            Function ctor = (Function) ctorVal;
-            if (args == null) { args = ScriptRuntime.emptyArgs; }
-            return ctor.construct(this, scope, args);
-        }
-        if (ctorVal == Scriptable.NOT_FOUND) {
-            String message = getMessage1("msg.ctor.not.found", constructorName);
-            throw new PropertyException(message);
-        } else {
-            String message = getMessage1("msg.not.ctor", constructorName);
-            throw new NotAFunctionException(message);
-        }
-    }
-
-    /**
-     * Create an array with a specified initial length.
-     * <p>
-     * @param scope the scope to create the object in
-     * @param length the initial length (JavaScript arrays may have
-     *               additional properties added dynamically).
-     * @return the new array object
-     */
-    public Scriptable newArray(Scriptable scope, int length) {
-        Scriptable result = new NativeArray(length);
-        newArrayHelper(scope, result);
-        return result;
-    }
-
-    /**
-     * Create an array with a set of initial elements.
-     * <p>
-     * @param scope the scope to create the object in
-     * @param elements the initial elements. Each object in this array
-     *                 must be an acceptable JavaScript type.
-     * @return the new array object
-     */
-    public Scriptable newArray(Scriptable scope, Object[] elements) {
-        Scriptable result = new NativeArray(elements);
-        newArrayHelper(scope, result);
-        return result;
-    }
-
-    /**
-     * Get the elements of a JavaScript array.
-     * <p>
-     * If the object defines a length property which can be converted to
-     * a number a Java array with length given by
-     * {@link ScriptRuntime#toUint32(double)} is created and initialized with
-     * the values obtained by
-     * calling get() on object for each value of i in [0,length-1]. If
-     * there is not a defined value for a property the Undefined value
-     * is used to initialize the corresponding element in the array. The
-     * Java array is then returned.
-     * If the object doesn't define a length property or it is not a number,
-     * empty array is returned.
-     * @param object the JavaScript array or array-like object
-     * @return a Java array of objects
-     * @since 1.4 release 2
-     */
-    public Object[] getElements(Scriptable object) {
-        long longLen = NativeArray.getLengthProperty(object);
-        if (longLen > Integer.MAX_VALUE) {
-            // arrays beyond  MAX_INT is not in Java in any case
-            throw new IllegalArgumentException();
-        }
-        int len = (int) longLen;
-        if (len == 0) {
-            return ScriptRuntime.emptyArgs;
-        } else {
-            Object[] result = new Object[len];
-            for (int i=0; i < len; i++) {
-                Object elem = ScriptableObject.getProperty(object, i);
-                result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance
-                                                           : elem;
-            }
-            return result;
-        }
-    }
-
-    /**
-     * Convert the value to a JavaScript boolean value.
-     * <p>
-     * See ECMA 9.2.
-     *
-     * @param value a JavaScript value
-     * @return the corresponding boolean value converted using
-     *         the ECMA rules
-     */
-    public static boolean toBoolean(Object value) {
-        return ScriptRuntime.toBoolean(value);
-    }
-
-    /**
-     * Convert the value to a JavaScript Number value.
-     * <p>
-     * Returns a Java double for the JavaScript Number.
-     * <p>
-     * See ECMA 9.3.
-     *
-     * @param value a JavaScript value
-     * @return the corresponding double value converted using
-     *         the ECMA rules
-     */
-    public static double toNumber(Object value) {
-        return ScriptRuntime.toNumber(value);
-    }
-
-    /**
-     * Convert the value to a JavaScript String value.
-     * <p>
-     * See ECMA 9.8.
-     * <p>
-     * @param value a JavaScript value
-     * @return the corresponding String value converted using
-     *         the ECMA rules
-     */
-    public static String toString(Object value) {
-        return ScriptRuntime.toString(value);
-    }
-
-    /**
-     * Convert the value to an JavaScript object value.
-     * <p>
-     * Note that a scope must be provided to look up the constructors
-     * for Number, Boolean, and String.
-     * <p>
-     * See ECMA 9.9.
-     * <p>
-     * Additionally, arbitrary Java objects and classes will be
-     * wrapped in a Scriptable object with its Java fields and methods
-     * reflected as JavaScript properties of the object.
-     *
-     * @param value any Java object
-     * @param scope global scope containing constructors for Number,
-     *              Boolean, and String
-     * @return new JavaScript object
-     */
-    public static Scriptable toObject(Object value, Scriptable scope) {
-        return ScriptRuntime.toObject(scope, value, null);
-    }
-
-    /**
-     * Convert the value to an JavaScript object value.
-     * <p>
-     * Note that a scope must be provided to look up the constructors
-     * for Number, Boolean, and String.
-     * <p>
-     * See ECMA 9.9.
-     * <p>
-     * Additionally, arbitrary Java objects and classes will be
-     * wrapped in a Scriptable object with its Java fields and methods
-     * reflected as JavaScript properties of the object. If the
-     * "staticType" parameter is provided, it will be used as the static
-     * type of the Java value to create.
-     *
-     * @param value any Java object
-     * @param scope global scope containing constructors for Number,
-     *              Boolean, and String
-     * @param staticType the static type of the Java value to create
-     * @return new JavaScript object
-     */
-    public static Scriptable toObject(Object value, Scriptable scope,
-                                      Class staticType) {
-        if (value == null && staticType != null)
-            return null;
-        return ScriptRuntime.toObject(scope, value, staticType);
-    }
-
-    /**
-     * Convert a JavaScript value into the desired type.
-     * Uses the semantics defined with LiveConnect3 and throws an
-     * Illegal argument exception if the conversion cannot be performed.
-     * @param value the JavaScript value to convert
-     * @param desired type the Java type to convert to. Primitive Java
-     *        types are represented using the TYPE fields in the corresponding
-     *        wrapper class in java.lang.
-     * @return the converted value
-     * @throws IllegalArgumentException if the conversion cannot be performed
-     */
-    public static Object toType(Object value, Class desiredType)
-        throws IllegalArgumentException
-    {
-        return NativeJavaObject.coerceType(desiredType, value, false);
-    }
-
-    /**
-     * Tell whether debug information is being generated.
-     * @since 1.3
-     */
-    public boolean isGeneratingDebug() {
-        return generatingDebug;
-    }
-
-    /**
-     * Specify whether or not debug information should be generated.
-     * <p>
-     * Setting the generation of debug information on will set the
-     * optimization level to zero.
-     * @since 1.3
-     */
-    public void setGeneratingDebug(boolean generatingDebug) {
-        generatingDebugChanged = true;
-        if (generatingDebug && getOptimizationLevel() > 0)
-            setOptimizationLevel(0);
-        this.generatingDebug = generatingDebug;
-    }
-
-    /**
-     * Tell whether source information is being generated.
-     * @since 1.3
-     */
-    public boolean isGeneratingSource() {
-        return generatingSource;
-    }
-
-    /**
-     * Specify whether or not source information should be generated.
-     * <p>
-     * Without source information, evaluating the "toString" method
-     * on JavaScript functions produces only "[native code]" for
-     * the body of the function.
-     * Note that code generated without source is not fully ECMA
-     * conformant.
-     * @since 1.3
-     */
-    public void setGeneratingSource(boolean generatingSource) {
-        this.generatingSource = generatingSource;
-    }
-
-    /**
-     * Get the current optimization level.
-     * <p>
-     * The optimization level is expressed as an integer between -1 and
-     * 9.
-     * @since 1.3
-     *
-     */
-    public int getOptimizationLevel() {
-        return optimizationLevel;
-    }
-
-    /**
-     * Set the current optimization level.
-     * <p>
-     * The optimization level is expected to be an integer between -1 and
-     * 9. Any negative values will be interpreted as -1, and any values
-     * greater than 9 will be interpreted as 9.
-     * An optimization level of -1 indicates that interpretive mode will
-     * always be used. Levels 0 through 9 indicate that class files may
-     * be generated. Higher optimization levels trade off compile time
-     * performance for runtime performance.
-     * The optimizer level can't be set greater than -1 if the optimizer
-     * package doesn't exist at run time.
-     * @param optimizationLevel an integer indicating the level of
-     *        optimization to perform
-     * @since 1.3
-     *
-     */
-    public void setOptimizationLevel(int optimizationLevel) {
-        if (optimizationLevel < 0) {
-            optimizationLevel = -1;
-        } else if (optimizationLevel > 9) {
-                optimizationLevel = 9;
-        }
-        if (codegenClass == null)
-            optimizationLevel = -1;
-        this.optimizationLevel = optimizationLevel;
-    }
-
-    /**
-     * @deprecated Use <tt>ClassNameHelper.get(cx).getClassName()</tt> instead.
-     * @see ClassNameHelper#getClassName
-     */
-    public String getClassName() {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        return nameHelper != null ? nameHelper.getClassName() : null;
-    }
-
-    /**
-     * @deprecated Use <tt>ClassNameHelper.get(cx).setClassName(className)</tt> instead.
-     * @see ClassNameHelper#setClassName
-     */
-    public void setClassName(String className) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null)
-              nameHelper.setClassName(className);
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).getTargetClassFileName()</tt> instead.
-     * @see ClassNameHelper#getTargetClassFileName
-     */
-    public String getTargetClassFileName() {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            return nameHelper.getTargetClassFileName();
-        }
-        return null;
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).setTargetClassFileName(classFileName)</tt> instead.
-     * @see ClassNameHelper#setTargetClassFileName
-     */
-    public void setTargetClassFileName(String classFileName) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            nameHelper.setTargetClassFileName(classFileName);
-        }
-    }
-
-    /**
-     * @deprecated Use <tt>ClassNameHelper.get(cx).getTargetPackage()</tt> instead.
-     * @see ClassNameHelper#getTargetPackage
-     */
-    public String getTargetPackage() {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        return nameHelper != null ? nameHelper.getTargetPackage() : null;
-    }
-
-    /**
-     * @deprecated Use <tt>ClassNameHelper.get(cx).setTargetPackage(targetPackage)</tt>
-     * instead.
-     * @see ClassNameHelper#setTargetPackage
-     */
-    public void setTargetPackage(String targetPackage) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null)
-            nameHelper.setTargetPackage(targetPackage);
-    }
-
-    /**
-     * @deprecated Use <tt>ClassNameHelper.get(cx).getClassRepository()</tt> instead.
-     * @see ClassNameHelper#getClassRepository
-     */
-    public ClassRepository getClassRepository() {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        return nameHelper != null ? nameHelper.getClassRepository() : null;
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).setClassRepository(classRepository)</tt> instead.
-     * @see ClassNameHelper#setClassRepository
-     */
-    public void setClassRepository(ClassRepository classRepository) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null)
-            nameHelper.setClassRepository(classRepository);
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).getClassOutput()</tt> instead.
-     * @see ClassNameHelper#getClassOutput
-     */
-    public ClassOutput getClassOutput() {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            return nameHelper.getClassOutput();
-        }
-        return null;
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).setClassOutput(classOutput)</tt> instead.
-     * @see ClassNameHelper#setClassOutput
-     */
-    public void setClassOutput(ClassOutput classOutput) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            nameHelper.setClassOutput(classOutput);
-        }
-    }
-
-    /**
-     * Set the security controller for this context.
-     * <p> SecurityController may only be set if it is currently null.
-     * Otherwise a SecurityException is thrown.
-     * @param controller a SecurityController object
-     * @throws SecurityException if there is already a SecurityController
-     *         object for this Context
-     */
-    public void setSecurityController(SecurityController controller) {
-        if (controller == null) throw new IllegalArgumentException();
-        if (securityController != null) {
-            throw new SecurityException("Cannot overwrite existing " +
-                                        "SecurityController object");
-        }
-        securityController = controller;
-    }
-
-/**
-@deprecated The {@link SecuritySupport} class is deprecated. See its documentation for the upgrade path.
-*/
-    public void setSecuritySupport(SecuritySupport x) {
-        setClassShutter(x);
-    }
-
-    /**
-     * Set the LiveConnect access filter for this context.
-     * <p> {@link ClassShutter} may only be set if it is currently null.
-     * Otherwise a SecurityException is thrown.
-     * @param shutter a ClassShutter object
-     * @throws SecurityException if there is already a ClassShutter
-     *         object for this Context
-     */
-    public void setClassShutter(ClassShutter shutter) {
-        if (shutter == null) throw new IllegalArgumentException();
-        if (classShutter != null) {
-            throw new SecurityException("Cannot overwrite existing " +
-                                        "ClassShutter object");
-        }
-        classShutter = shutter;
-    }
-
-    final ClassShutter getClassShutter() {
-        return classShutter;
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).setTargetExtends(extendsClass)</tt> instead.
-     * @see ClassNameHelper#setTargetExtends
-     */
-    public void setTargetExtends(Class extendsClass) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            nameHelper.setTargetExtends(extendsClass);
-        }
-    }
-
-    /**
-     * @deprecated Use
-     * <tt>ClassNameHelper.get(cx).setTargetImplements(implementsClasses)</tt>
-     * instead.
-     * @see ClassNameHelper#setTargetImplements
-     */
-    public void setTargetImplements(Class[] implementsClasses) {
-        ClassNameHelper nameHelper = ClassNameHelper.get(this);
-        if (nameHelper != null) {
-            nameHelper.setTargetImplements(implementsClasses);
-        }
-    }
-
-    /**
-     * Get a value corresponding to a key.
-     * <p>
-     * Since the Context is associated with a thread it can be
-     * used to maintain values that can be later retrieved using
-     * the current thread.
-     * <p>
-     * Note that the values are maintained with the Context, so
-     * if the Context is disassociated from the thread the values
-     * cannot be retreived. Also, if private data is to be maintained
-     * in this manner the key should be a java.lang.Object
-     * whose reference is not divulged to untrusted code.
-     * @param key the key used to lookup the value
-     * @return a value previously stored using putThreadLocal.
-     */
-    public final Object getThreadLocal(Object key) {
-        if (hashtable == null)
-            return null;
-        return hashtable.get(key);
-    }
-
-    /**
-     * Put a value that can later be retrieved using a given key.
-     * <p>
-     * @param key the key used to index the value
-     * @param value the value to save
-     */
-    public void putThreadLocal(Object key, Object value) {
-        if (hashtable == null)
-            hashtable = new Hashtable();
-        hashtable.put(key, value);
-    }
-
-    /**
-     * Remove values from thread-local storage.
-     * @param key the key for the entry to remove.
-     * @since 1.5 release 2
-     */
-    public void removeThreadLocal(Object key) {
-        if (hashtable == null)
-            return;
-        hashtable.remove(key);
-    }
-
-    /**
-     * Return whether functions are compiled by this context using
-     * dynamic scope.
-     * <p>
-     * If functions are compiled with dynamic scope, then they execute
-     * in the scope of their caller, rather than in their parent scope.
-     * This is useful for sharing functions across multiple scopes.
-     * @since 1.5 Release 1
-     */
-    public final boolean hasCompileFunctionsWithDynamicScope() {
-        return compileFunctionsWithDynamicScopeFlag;
-    }
-
-    /**
-     * Set whether functions compiled by this context should use
-     * dynamic scope.
-     * <p>
-     * @param flag if true, compile functions with dynamic scope
-     * @since 1.5 Release 1
-     */
-    public void setCompileFunctionsWithDynamicScope(boolean flag) {
-        compileFunctionsWithDynamicScopeFlag = flag;
-    }
-
-    /**
-     * Set whether to cache some values statically.
-     * <p>
-     * By default, the engine will cache some values statically
-     * (reflected Java classes, for instance). This can speed
-     * execution dramatically, but increases the memory footprint.
-     * Also, with caching enabled, references may be held to
-     * objects past the lifetime of any real usage.
-     * <p>
-     * If caching is enabled and this method is called with a
-     * <code>false</code> argument, the caches will be emptied.
-     * So one strategy could be to clear the caches at times
-     * appropriate to the application.
-     * <p>
-     * Caching is enabled by default.
-     *
-     * @param cachingEnabled if true, caching is enabled
-     * @since 1.5 Release 1
-     */
-    public static void setCachingEnabled(boolean cachingEnabled) {
-        if (isCachingEnabled && !cachingEnabled) {
-            // Caching is being turned off. Empty caches.
-            JavaMembers.classTable = new Hashtable();
-            ClassNameHelper.clearCache();
-        }
-        isCachingEnabled = cachingEnabled;
-        FunctionObject.setCachingEnabled(cachingEnabled);
-    }
-
-    // Proxy to allow to use deprecated WrapHandler in place of WrapFactory
-    private static class WrapHandlerProxy extends WrapFactory {
-        WrapHandler _handler;
-
-        WrapHandlerProxy(WrapHandler handler) {
-            _handler = handler;
-        }
-
-        public Object wrap(Context cx, Scriptable scope,
-                           Object obj, Class staticType)
-        {
-            if (obj == null) { return obj; }
-            Object result = _handler.wrap(scope, obj, staticType);
-            if (result == null) {
-                result = super.wrap(cx, scope, obj, staticType);
-            }
-            return result;
-        }
-
-        public Scriptable wrapNewObject(Context cx, Scriptable scope,
-                                        Object obj)
-        {
-            Object wrap = _handler.wrap(scope, obj, obj.getClass());
-            if (wrap instanceof Scriptable) {
-                return (Scriptable)wrap;
-            }
-            if (wrap == null) {
-                return super.wrapNewObject(cx, scope, obj);
-            }
-            throw new RuntimeException
-                ("Please upgrade from WrapHandler to WrapFactory");
-        }
-    }
-
-    /**
-     * @deprecated  As of Rhino 1.5 Release 4, use
-     * {@link WrapFactory} and {@link #setWrapFactory(WrapFactory)}
-     */
-    public void setWrapHandler(WrapHandler wrapHandler) {
-        if (wrapHandler == null) {
-            setWrapFactory(new WrapFactory());
-        } else {
-            setWrapFactory(new WrapHandlerProxy(wrapHandler));
-        }
-    }
-
-    /**
-     * @deprecated  As of Rhino 1.5 Release 4, use
-     * {@link WrapFactory} and {@link #getWrapFactory()}
-     */
-    public WrapHandler getWrapHandler() {
-        WrapFactory f = getWrapFactory();
-        if (f instanceof WrapHandlerProxy) {
-            return ((WrapHandlerProxy)f)._handler;
-        }
-        return null;
-    }
-
-    /**
-     * Set a WrapFactory for this Context.
-     * <p>
-     * The WrapFactory allows custom object wrapping behavior for
-     * Java object manipulated with JavaScript.
-     * @see org.mozilla.javascript.WrapFactory
-     * @since 1.5 Release 4
-     */
-    public void setWrapFactory(WrapFactory wrapFactory) {
-        if (wrapFactory == null) throw new IllegalArgumentException();
-        this.wrapFactory = wrapFactory;
-    }
-
-    /**
-     * Return the current WrapHandler, or null if none is defined.
-     * @see org.mozilla.javascript.WrapHandler
-     * @since 1.5 Release 4
-     */
-    public final WrapFactory getWrapFactory() {
-        if (wrapFactory == null) {
-            wrapFactory = new WrapFactory();
-        }
-        return wrapFactory;
-    }
-
-    /**
-     * Return the current debugger.
-     * @return the debugger, or null if none is attached.
-     */
-    public final Debugger getDebugger() {
-        return debugger;
-    }
-
-    /**
-     * Return the debugger context data associated with current context.
-     * @return the debugger data, or null if debugger is not attached
-     */
-    public final Object getDebuggerContextData() {
-        return debuggerData;
-    }
-
-    /**
-     * Set the associated debugger.
-     * @param debugger the debugger to be used on callbacks from
-     * the engine.
-     * @param contextData arbitrary object that debugger can use to store
-     *        per Context data.
-     */
-    public void setDebugger(Debugger debugger, Object contextData) {
-        this.debugger = debugger;
-        debuggerData = contextData;
-    }
-
-    /**
-     * if hasFeature(FEATURE_NON_ECMA_GET_YEAR) returns true,
-     * Date.prototype.getYear subtructs 1900 only if 1900 <= date < 2000
-     * in deviation with Ecma B.2.4
-     */
-    public static final int FEATURE_NON_ECMA_GET_YEAR = 1;
-
-    /**
-     * if hasFeature(FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME) returns true,
-     * allow 'function <MemberExpression>(...) { ... }' to be syntax sugar for
-     * '<MemberExpression> = function(...) { ... }', when <MemberExpression>
-     * is not simply identifier.
-     * See Ecma-262, section 11.2 for definition of <MemberExpression>
-     */
-    public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;
-
-    /**
-     * if hasFeature(RESERVED_KEYWORD_AS_IDENTIFIER) returns true,
-     * treat future reserved keyword (see  Ecma-262, section 7.5.3) as ordinary
-     * identifiers but warn about this usage
-     */
-    public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;
-
-    /**
-     * if hasFeature(FEATURE_TO_STRING_AS_SOURCE) returns true,
-     * calling toString on JS objects gives JS source with code to create an
-     * object with all enumeratable fields of the original object instead of
-     * printing "[object <object-type>]".
-     * By default {@link #hasFeature(int)} returns true only if
-     * the current JS version is set to {@link #VERSION_1_2}.
-     */
-    public static final int FEATURE_TO_STRING_AS_SOURCE = 4;
-
-    /**
-     * Controls certain aspects of script semantics.
-     * Should be overwritten to alter default behavior.
-     * @param featureIndex feature index to check
-     * @return true if the <code>featureIndex</code> feature is turned on
-     * @see #FEATURE_NON_ECMA_GET_YEAR
-     * @see #FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME
-     * @see #FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER
-     * @see #FEATURE_TO_STRING_AS_SOURCE
-     */
-    public boolean hasFeature(int featureIndex) {
-        switch (featureIndex) {
-            case FEATURE_NON_ECMA_GET_YEAR:
-               /*
-                * During the great date rewrite of 1.3, we tried to track the
-                * evolving ECMA standard, which then had a definition of
-                * getYear which always subtracted 1900.  Which we
-                * implemented, not realizing that it was incompatible with
-                * the old behavior...  now, rather than thrash the behavior
-                * yet again, we've decided to leave it with the - 1900
-                * behavior and point people to the getFullYear method.  But
-                * we try to protect existing scripts that have specified a
-                * version...
-                */
-                return (version == Context.VERSION_1_0
-                        || version == Context.VERSION_1_1
-                        || version == Context.VERSION_1_2);
-
-            case FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME:
-                return false;
-
-            case FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER:
-                return false;
-
-            case FEATURE_TO_STRING_AS_SOURCE:
-                return version == VERSION_1_2;
-        }
-        // It is a bug to call the method with unknown featureIndex
-        throw new IllegalArgumentException();
-    }
-
-    /**
-     * Get/Set threshold of executed instructions counter that triggers call to
-     * <code>observeInstructionCount()</code>.
-     * When the threshold is zero, instruction counting is disabled,
-     * otherwise each time the run-time executes at least the threshold value
-     * of script instructions, <code>observeInstructionCount()</code> will
-     * be called.
-     */
-    public int getInstructionObserverThreshold() {
-        return instructionThreshold;
-    }
-
-    public void setInstructionObserverThreshold(int threshold) {
-        instructionThreshold = threshold;
-    }
-
-    /**
-     * Allow application to monitor counter of executed script instructions
-     * in Context subclasses.
-     * Run-time calls this when instruction counting is enabled and the counter
-     * reaches limit set by <code>setInstructionObserverThreshold()</code>.
-     * The method is useful to observe long running scripts and if necessary
-     * to terminate them.
-     * @param instructionCount amount of script instruction executed since
-     * last call to <code>observeInstructionCount</code>
-     * @throws Error to terminate the script
-     */
-    protected void observeInstructionCount(int instructionCount) {}
-
-    public GeneratedClassLoader createClassLoader(ClassLoader parent) {
-        return new DefiningClassLoader(parent);
-    }
-
-    public final ClassLoader getApplicationClassLoader()
-    {
-        if (applicationClassLoader != null) {
-            return applicationClassLoader;
-        }
-        ClassLoader loader = null;
-        if (method_getContextClassLoader != null) {
-            Thread thread = Thread.currentThread();
-            try {
-                loader = (ClassLoader)method_getContextClassLoader.invoke(
-                             thread, ScriptRuntime.emptyArgs);
-            } catch (Exception ex) { }
-        }
-        if (loader != null && !testIfCanUseLoader(loader)) {
-            loader = null;
-        }
-        if (loader == null) {
-            // If Context was subclassed, the following gets the loader
-            // for the subclass which can be different from Rhino loader,
-            // but then proper Rhino classes should be accessible through it
-            // in any case or JVM class loading is severely broken
-            loader = this.getClass().getClassLoader();
-        }
-        // The result is not cached since caching
-        // Thread.getContextClassLoader prevents it from GC which
-        // may lead to a memory leak.
-        return loader;
-    }
-
-    public void setApplicationClassLoader(ClassLoader loader)
-    {
-        if (loader == null) {
-            // restore default behaviour
-            applicationClassLoader = null;
-            return;
-        }
-        if (!testIfCanUseLoader(loader)) {
-            throw new IllegalArgumentException(
-                "Loader can not resolve Rhino classes");
-        }
-        applicationClassLoader = loader;
-    }
-
-    private boolean testIfCanUseLoader(ClassLoader loader)
-    {
-        // If Context was subclussed, cxClass != Context.class
-        Class cxClass = this.getClass();
-        // Check that Context or its suclass is accesible from this loader
-        Class x = ScriptRuntime.getClassOrNull(loader, cxClass.getName());
-        if (x != cxClass) {
-            // The check covers the case when x == null =>
-            // threadLoader does not know about Rhino or the case
-            // when x != null && x != cxClass =>
-            // threadLoader loads unrelated Rhino instance
-            return false;
-        }
-        return true;
-    }
-
-    /********** end of API **********/
-
-    static String getMessage0(String messageId) {
-        return getMessage(messageId, null);
-    }
-
-    static String getMessage1(String messageId, Object arg1) {
-        Object[] arguments = {arg1};
-        return getMessage(messageId, arguments);
-    }
-
-    static String getMessage2(String messageId, Object arg1, Object arg2) {
-        Object[] arguments = {arg1, arg2};
-        return getMessage(messageId, arguments);
-    }
-
-    static String getMessage3
-        (String messageId, Object arg1, Object arg2, Object arg3) {
-        Object[] arguments = {arg1, arg2, arg3};
-        return getMessage(messageId, arguments);
-    }
-    /**
-     * Internal method that reports an error for missing calls to
-     * enter().
-     */
-    static Context getContext() {
-        Context cx = getCurrentContext();
-        if (cx == null) {
-            throw new RuntimeException(
-                "No Context associated with current Thread");
-        }
-        return cx;
-    }
-
-    /* OPT there's a noticable delay for the first error!  Maybe it'd
-     * make sense to use a ListResourceBundle instead of a properties
-     * file to avoid (synchronized) text parsing.
-     */
-    static final String defaultResource =
-        "org.mozilla.javascript.resources.Messages";
-
-    static String getMessage(String messageId, Object[] arguments) {
-        Context cx = getCurrentContext();
-        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
-
-        // ResourceBundle does cacheing.
-        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
-
-        String formatString;
-        try {
-            formatString = rb.getString(messageId);
-        } catch (java.util.MissingResourceException mre) {
-            throw new RuntimeException
-                ("no message resource found for message property "+ messageId);
-        }
-
-        /*
-         * It's OK to format the string, even if 'arguments' is null;
-         * we need to format it anyway, to make double ''s collapse to
-         * single 's.
-         */
-        // TODO: MessageFormat is not available on pJava
-        MessageFormat formatter = new MessageFormat(formatString);
-        return formatter.format(arguments);
-    }
-
-    // debug flags
-    static final boolean printTrees = false;
-    static final boolean printICode = false;
-
-    /**
-     * Compile a script.
-     *
-     * Reads script source from the reader and compiles it, returning
-     * a class for either the script or the function depending on the
-     * value of <code>returnFunction</code>.
-     *
-     * @param scope the scope to compile relative to
-     * @param in the Reader to read source from
-     * @param sourceName the name of the origin of the source (usually
-     *                   a file or URL)
-     * @param lineno the line number of the start of the source
-     * @param securityDomain an arbitrary object that specifies security
-     *        information about the origin or owner of the script. For
-     *        implementations that don't care about security, this value
-     *        may be null.
-     * @param returnFunction if true, will expect the source to contain
-     *                        a function; return value is assumed to
-     *                        then be a org.mozilla.javascript.Function
-     * @return a class for the script or function
-     * @see org.mozilla.javascript.Context#compileReader
-     */
-    private Object compile(Scriptable scope, Reader in, String sourceName,
-                           int lineno, Object securityDomain,
-                           boolean returnFunction)
-        throws IOException
-    {
-        Object dynamicDoamin = null;
-        if (securityController != null) {
-            dynamicDoamin = securityController.
-                getDynamicSecurityDomain(securityDomain);
-        }
-
-        if (debugger != null && in != null) {
-            in = new DebugReader(in);
-        }
-        TokenStream ts = new TokenStream(in, scope, sourceName, lineno);
-        return compile(scope, ts, dynamicDoamin, in, returnFunction);
-    }
-
-    private static Class codegenClass;
-    static {
-        try {
-            codegenClass = Class.forName(
-                "org.mozilla.javascript.optimizer.Codegen");
-        } catch (ClassNotFoundException x) {
-            // ...must be running lite, that's ok
-            codegenClass = null;
-        }
-    }
-
-    private Interpreter getCompiler() {
-        if (codegenClass != null) {
-            try {
-                return (Interpreter) codegenClass.newInstance();
-            }
-            catch (SecurityException x) {
-            }
-            catch (IllegalArgumentException x) {
-            }
-            catch (InstantiationException x) {
-            }
-            catch (IllegalAccessException x) {
-            }
-            // fall through
-        }
-        return new Interpreter();
-    }
-
-    private Object compile(Scriptable scope, TokenStream ts,
-                           Object dynamicSecurityDomain, Reader in,
-                           boolean returnFunction)
-        throws IOException
-    {
-        Interpreter compiler = optimizationLevel == -1
-                               ? new Interpreter()
-                               : getCompiler();
-        ClassNameHelper nameHelper = optimizationLevel == -1
-                                     ? null
-                                     : ClassNameHelper.get(this);
-
-        errorCount = 0;
-        IRFactory irf = compiler.createIRFactory(ts, nameHelper, scope);
-        Parser p = new Parser(irf);
-        Node tree = (Node) p.parse(ts);
-        if (tree == null)
-            return null;
-
-        tree = compiler.transform(tree, ts, scope);
-
-        if (printTrees)
-            System.out.println(tree.toStringTree());
-
-        if (returnFunction) {
-            Node first = tree.getFirstChild();
-            if (first == null)
-                return null;
-            tree = (Node) first.getProp(Node.FUNCTION_PROP);
-            if (tree == null)
-                return null;
-        }
-
-        if (in instanceof DebugReader) {
-            DebugReader dr = (DebugReader) in;
-            tree.putProp(Node.DEBUGSOURCE_PROP, dr.getSaved());
-        }
-
-        Object result = compiler.compile(this, scope, tree,
-                                         dynamicSecurityDomain,
-                                         securityController,
-                                         nameHelper);
-
-        return errorCount == 0 ? result : null;
-    }
-
-    static String getSourcePositionFromStack(int[] linep) {
-        Context cx = getCurrentContext();
-        if (cx == null)
-            return null;
-        if (cx.interpreterLine > 0 && cx.interpreterSourceFile != null) {
-            linep[0] = cx.interpreterLine;
-            return cx.interpreterSourceFile;
-        }
-        /**
-         * A bit of a hack, but the only way to get filename and line
-         * number from an enclosing frame.
-         */
-        CharArrayWriter writer = new CharArrayWriter();
-        RuntimeException re = new RuntimeException();
-        re.printStackTrace(new PrintWriter(writer));
-        String s = writer.toString();
-        int open = -1;
-        int close = -1;
-        int colon = -1;
-        for (int i=0; i < s.length(); i++) {
-            char c = s.charAt(i);
-            if (c == ':')
-                colon = i;
-            else if (c == '(')
-                open = i;
-            else if (c == ')')
-                close = i;
-            else if (c == '\n' && open != -1 && close != -1 && colon != -1 &&
-                     open < colon && colon < close)
-            {
-                String fileStr = s.substring(open + 1, colon);
-                if (!fileStr.endsWith(".java")) {
-                    String lineStr = s.substring(colon + 1, close);
-                    try {
-                        linep[0] = Integer.parseInt(lineStr);
-                        return fileStr;
-                    }
-                    catch (NumberFormatException e) {
-                        // fall through
-                    }
-                }
-                open = close = colon = -1;
-            }
-        }
-
-        return null;
-    }
-
-    RegExpProxy getRegExpProxy() {
-        if (regExpProxy == null) {
-            try {
-                Class c = Class.forName(
-                            "org.mozilla.javascript.regexp.RegExpImpl");
-                regExpProxy = (RegExpProxy) c.newInstance();
-                return regExpProxy;
-            } catch (ClassNotFoundException e) {
-            } catch (InstantiationException e) {
-            } catch (IllegalAccessException e) {
-            }
-        }
-        return regExpProxy;
-    }
-
-    private void newArrayHelper(Scriptable scope, Scriptable array) {
-        array.setParentScope(scope);
-        Object ctor = ScriptRuntime.getTopLevelProp(scope, "Array");
-        if (ctor != null && ctor instanceof Scriptable) {
-            Scriptable s = (Scriptable) ctor;
-            array.setPrototype((Scriptable) s.get("prototype", s));
-        }
-    }
-
-    final boolean isVersionECMA1() {
-        return version == VERSION_DEFAULT || version >= VERSION_1_3;
-    }
-
-// Should not be public
-    SecurityController getSecurityController() {
-        return securityController;
-    }
-
-    public boolean isGeneratingDebugChanged() {
-        return generatingDebugChanged;
-    }
-
-    /**
-     * Add a name to the list of names forcing the creation of real
-     * activation objects for functions.
-     *
-     * @param name the name of the object to add to the list
-     */
-    public void addActivationName(String name) {
-        if (activationNames == null)
-            activationNames = new Hashtable(5);
-        activationNames.put(name, name);
-    }
-
-    /**
-     * Check whether the name is in the list of names of objects
-     * forcing the creation of activation objects.
-     *
-     * @param name the name of the object to test
-     *
-     * @return true if an function activation object is needed.
-     */
-    public boolean isActivationNeeded(String name) {
-        if ("arguments".equals(name))
-            return true;
-        return activationNames != null && activationNames.containsKey(name);
-    }
-
-    /**
-     * Remove a name from the list of names forcing the creation of real
-     * activation objects for functions.
-     *
-     * @param name the name of the object to remove from the list
-     */
-    public void removeActivationName(String name) {
-        if (activationNames != null)
-            activationNames.remove(name);
-    }
-
-// Rudimentary support for Design-by-Contract
-    static void codeBug() {
-        throw new RuntimeException("FAILED ASSERTION");
-    }
-
-    static final boolean check = true;
-
-    static boolean isCachingEnabled = true;
-
-    private static Hashtable threadContexts = new Hashtable(11);
-    private static Object threadLocalCx;
-    private static Method threadLocalGet;
-    private static Method threadLocalSet;
-
-    static {
-        try {
-            Class cl = Class.forName("java.lang.ThreadLocal");
-            threadLocalGet = cl.getMethod("get", null);
-            threadLocalSet = cl.getMethod("set",
-                new Class[] { ScriptRuntime.ObjectClass });
-            threadLocalCx = cl.newInstance();
-        } catch (Exception ex) { }
-    }
-
-    // We'd like to use "Thread.getContextClassLoader", but
-    // that's only available on Java2.
-    private static Method method_getContextClassLoader;
-
-    static {
-        // Don't use "Thread.class": that performs the lookup
-        // in the class initializer, which doesn't allow us to
-        // catch possible security exceptions.
-        Class threadClass = ScriptRuntime.getClassOrNull("java.lang.Thread");
-        if (threadClass != null) {
-            try {
-                method_getContextClassLoader =
-                    threadClass.getDeclaredMethod("getContextClassLoader",
-                                                   new Class[0]);
-            } catch (Exception ex) { }
-        }
-    }
-
-    private static final Object contextListenersLock = new Object();
-    private static Object[] contextListeners;
-
-    /**
-     * The activation of the currently executing function or script.
-     */
-    NativeCall currentActivation;
-
-    // for Objects, Arrays to tag themselves as being printed out,
-    // so they don't print themselves out recursively.
-    // Use ObjToIntMap instead of java.util.HashSet for JDK 1.1 compatibility
-    ObjToIntMap iterating;
-
-    Object interpreterSecurityDomain;
-
-    int version;
-    int errorCount;
-
-    private SecurityController securityController;
-    private ClassShutter classShutter;
-    private ErrorReporter errorReporter;
-    private RegExpProxy regExpProxy;
-    private Locale locale;
-    private boolean generatingDebug;
-    private boolean generatingDebugChanged;
-    private boolean generatingSource=true;
-    private boolean compileFunctionsWithDynamicScopeFlag;
-    private int optimizationLevel;
-    private WrapFactory wrapFactory;
-    Debugger debugger;
-    private Object debuggerData;
-    private int enterCount;
-    private Object[] listeners;
-    private Hashtable hashtable;
-    private ClassLoader applicationClassLoader;
-
-    /**
-     * This is the list of names of objects forcing the creation of
-     * function activation records.
-     */
-    private Hashtable activationNames;
-
-    // For the interpreter to indicate line/source for error reports.
-    int interpreterLine;
-    String interpreterSourceFile;
-
-    // For instruction counting (interpreter only)
-    int instructionCount;
-    int instructionThreshold;
-}
Index: rhino/DefiningClassLoader.java
===================================================================
RCS file: rhino/DefiningClassLoader.java
diff -N rhino/DefiningClassLoader.java
--- rhino/DefiningClassLoader.java	22 Oct 2004 14:13:19 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,155 +0,0 @@
-/*
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-1999 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Norris Boyd
- * Roger Lawrence
- * Patrick Beard
- * Igor Bukanov
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-
-/**
- * Load generated classes.
- *
- * @author Norris Boyd
- */
-public class DefiningClassLoader extends ClassLoader
-    implements GeneratedClassLoader
-{
-    public DefiningClassLoader() {
-        init(getClass().getClassLoader());
-    }
-
-    public DefiningClassLoader(ClassLoader parentLoader) {
-
-        init(parentLoader);
-    }
-
-    private void init(ClassLoader parentLoader) {
-
-        this.parentLoader = parentLoader;
-
-        this.contextLoader = null;
-        if (method_getContextClassLoader != null) {
-            try {
-                this.contextLoader = (ClassLoader)
-                    method_getContextClassLoader.invoke(
-                        Thread.currentThread(),
-                        ScriptRuntime.emptyArgs);
-            } catch (IllegalAccessException ex) {
-            } catch (InvocationTargetException ex) {
-            } catch (SecurityException ex) {
-            }
-            if (this.contextLoader == this.parentLoader) {
-                this.contextLoader = null;
-            }
-        }
-
-    }
-
-    public Class defineClass(String name, byte[] data) {
-        return super.defineClass(name, data, 0, data.length);
-    }
-
-    public void linkClass(Class cl) {
-        resolveClass(cl);
-    }
-
-    public Class loadClass(String name, boolean resolve)
-        throws ClassNotFoundException
-    {
-
-        Class cl = findLoadedClass(name);
-        if (cl == null) {
-            // First try parent class loader and if that does not work, try
-            // contextLoader, but that will be null if
-            // Thread.getContextClassLoader() == parentLoader
-            // or on JDK 1.1 due to lack Thread.getContextClassLoader().
-            // To avoid catching and rethrowing ClassNotFoundException
-            // in this cases, use try/catch check only if contextLoader != null.
-            if (contextLoader == null) {
-                cl = loadFromParent(name);
-
-            } else {
-
-                try {
-                    cl = loadFromParent(name);
-                } catch (ClassNotFoundException ex) {
-                    cl = contextLoader.loadClass(name);
-                }
-
-            }
-        }
-
-        if (resolve) {
-            resolveClass(cl);
-        }
-        return cl;
-    }
-
-    private Class loadFromParent(String name)
-        throws ClassNotFoundException
-    {
-        if (parentLoader != null) {
-            return parentLoader.loadClass(name);
-        } else {
-            return findSystemClass(name);
-        }
-
-    }
-
-    private ClassLoader parentLoader;
-
-    private ClassLoader contextLoader;
-
-    // We'd like to use "Thread.getContextClassLoader", but
-    // that's only available on Java2.
-    private static Method method_getContextClassLoader;
-
-    static {
-        try {
-            // Don't use "Thread.class": that performs the lookup
-            // in the class initializer, which doesn't allow us to
-            // catch possible security exceptions.
-            Class threadClass = Class.forName("java.lang.Thread");
-            method_getContextClassLoader =
-                threadClass.getDeclaredMethod("getContextClassLoader",
-                                               new Class[0]);
-        } catch (ClassNotFoundException e) {
-        } catch (NoSuchMethodException e) {
-        } catch (SecurityException e) {
-        }
-    }
-}
Index: rhino/ImporterTopLevel.java
===================================================================
RCS file: rhino/ImporterTopLevel.java
diff -N rhino/ImporterTopLevel.java
--- rhino/ImporterTopLevel.java	22 Oct 2004 14:13:32 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,188 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1999 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Norris Boyd
- * Matthias Radestock
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-// API class
-
-package org.mozilla.javascript;
-
-/**
- * Class ImporterTopLevel
- *
- * This class defines a ScriptableObject that can be instantiated
- * as a top-level ("global") object to provide functionality similar
- * to Java's "import" statement.
- * <p>
- * This class can be used to create a top-level scope using the following code:
- * <pre>
- *  Scriptable scope = new ImporterTopLevel(cx);
- * </pre>
- * Then JavaScript code will have access to the following methods:
- * <ul>
- * <li>importClass - will "import" a class by making its unqualified name
- *                   available as a property of the top-level scope
- * <li>importPackage - will "import" all the classes of the package by
- *                     searching for unqualified names as classes qualified
- *                     by the given package.
- * </ul>
- * The following code from the shell illustrates this use:
- * <pre>
- * js> importClass(java.io.File)
- * js> f = new File('help.txt')
- * help.txt
- * js> importPackage(java.util)
- * js> v = new Vector()
- * []
- *
- * @author Norris Boyd
- */
-public class ImporterTopLevel extends ScriptableObject {
-
-    /**
-     * @deprecated
-     */
-    public ImporterTopLevel() {
-        init();
-    }
-
-    public ImporterTopLevel(Context cx) {
-        cx.initStandardObjects(this);
-        init();
-    }
-
-    private void init() {
-        String[] names = { "importClass", "importPackage" };
-
-        try {
-            this.defineFunctionProperties(names, ImporterTopLevel.class,
-                                          ScriptableObject.DONTENUM);
-        } catch (PropertyException e) {
-            throw new Error();  // should never happen
-        }
-    }
-
-    public String getClassName() {
-        return "global";
-    }
-
-    public boolean has(String name, Scriptable start) {
-        return super.has(name, start)
-               || getPackageProperty(name, start) != NOT_FOUND;
-    }
-
-    public Object get(String name, Scriptable start) {
-        Object result = super.get(name, start);
-        if (result != NOT_FOUND)
-            return result;
-        result = getPackageProperty(name, start);
-        return result;
-    }
-
-    private Object getPackageProperty(String name, Scriptable start) {
-        Object result= NOT_FOUND;
-        if (name.equals("_packages_"))
-            return result;
-        Object plist = ScriptableObject.getProperty(start,"_packages_");
-        if (plist == NOT_FOUND)
-            return result;
-        Object[] elements;
-        Context cx = Context.enter();
-        try {
-            elements = cx.getElements((Scriptable)plist);
-        }
-        finally { Context.exit(); }
-        for (int i=0; i < elements.length; i++) {
-            NativeJavaPackage p = (NativeJavaPackage) elements[i];
-            Object v = p.getPkgProperty(name, start, false);
-            if (v != null && !(v instanceof NativeJavaPackage)) {
-                if (result == NOT_FOUND) {
-                    result = v;
-                } else {
-                    throw Context.reportRuntimeError2(
-                        "msg.ambig.import", result.toString(), v.toString());
-                }
-            }
-        }
-        return result;
-    }
-
-    public static void importClass(Context cx, Scriptable thisObj,
-                                   Object[] args, Function funObj) {
-        for (int i=0; i<args.length; i++) {
-            Object cl = args[i];
-            if (!(cl instanceof NativeJavaClass)) {
-                throw Context.reportRuntimeError1(
-                    "msg.not.class", Context.toString(cl));
-            }
-            String s = ((NativeJavaClass) cl).getClassObject().getName();
-            String n = s.substring(s.lastIndexOf('.')+1);
-            Object val = thisObj.get(n, thisObj);
-            if (val != NOT_FOUND && val != cl) {
-                throw Context.reportRuntimeError1("msg.prop.defined", n);
-            }
-            //thisObj.defineProperty(n, cl, DONTENUM);
-            thisObj.put(n,thisObj,cl);
-        }
-    }
-
-    public static void importPackage(Context cx, Scriptable thisObj,
-                                   Object[] args, Function funObj) {
-        Scriptable importedPackages;
-        Object plist = thisObj.get("_packages_", thisObj);
-        if (plist == NOT_FOUND) {
-            importedPackages = cx.newArray(thisObj,0);
-            thisObj.put("_packages_", thisObj, importedPackages);
-        }
-        else {
-            importedPackages = (Scriptable)plist;
-        }
-        for (int i=0; i<args.length; i++) {
-            Object pkg = args[i];
-            if (!(pkg instanceof NativeJavaPackage)) {
-                throw Context.reportRuntimeError1(
-                    "msg.not.pkg", Context.toString(pkg));
-            }
-            Object[] elements = cx.getElements(importedPackages);
-            for (int j=0; j < elements.length; j++) {
-                if (pkg == elements[j]) {
-                    pkg = null;
-                    break;
-                }
-            }
-            if (pkg != null)
-                importedPackages.put(elements.length,importedPackages,pkg);
-        }
-    }
-}
Index: rhino/InvokerImpl.java
===================================================================
RCS file: rhino/InvokerImpl.java
diff -N rhino/InvokerImpl.java
--- rhino/InvokerImpl.java	22 Oct 2004 14:13:42 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,303 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-2000 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Norris Boyd
- * David C. Navas
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript.optimizer;
-
-import java.util.Hashtable;
-import java.lang.reflect.Method;
-
-import org.mozilla.javascript.Invoker;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.GeneratedClassLoader;
-import org.mozilla.classfile.ByteCode;
-import org.mozilla.classfile.ClassFileWriter;
-
-/**
- * Avoid cost of java.lang.reflect.Method.invoke() by compiling a class to
- * perform the method call directly.
- */
-public class InvokerImpl extends Invoker {
-
-    public Invoker createInvoker(Context cx, Method method, Class[] types) {
-
-        Invoker result;
-        int classNum;
-        synchronized (this) {
-            if (invokersCache == null) {
-                invokersCache = new Hashtable();
-                ClassLoader parentLoader = cx.getApplicationClassLoader();
-                classLoader = cx.createClassLoader(parentLoader);
-            } else {
-                result = (Invoker)invokersCache.get(method);
-                if (result != null) { return result; }
-            }
-            classNum = ++classNumber;
-        }
-
-        String className = "inv" + classNum;
-
-        ClassFileWriter cfw = new ClassFileWriter(className,
-                                "org.mozilla.javascript.Invoker", "");
-        cfw.setFlags((short)(ClassFileWriter.ACC_PUBLIC |
-                             ClassFileWriter.ACC_FINAL));
-
-        // Add our instantiator!
-        cfw.startMethod("<init>", "()V", ClassFileWriter.ACC_PUBLIC);
-        cfw.add(ByteCode.ALOAD_0);
-        cfw.add(ByteCode.INVOKESPECIAL,
-                "org.mozilla.javascript.Invoker",
-                "<init>", "()", "V");
-        cfw.add(ByteCode.RETURN);
-        cfw.stopMethod((short)1, null); // one argument -- this???
-
-        // Add the invoke() method call
-        cfw.startMethod("invoke",
-                        "(Ljava/lang/Object;[Ljava/lang/Object;)"+
-                         "Ljava/lang/Object;",
-                        (short)(ClassFileWriter.ACC_PUBLIC |
-                                ClassFileWriter.ACC_FINAL));
-
-        // If we return a primitive type, then do something special!
-        String declaringClassName = method.getDeclaringClass().getName
-            ().replace('.', '/');
-        Class returnType = method.getReturnType();
-        String invokeSpecial = null;
-        String invokeSpecialType = null;
-        boolean returnsVoid = false;
-        boolean returnsBoolean = false;
-
-        if (returnType.isPrimitive()) {
-            if (returnType == Boolean.TYPE) {
-                returnsBoolean = true;
-                invokeSpecialType = "(Z)";
-            } else if (returnType == Void.TYPE) {
-                returnsVoid = true;
-                invokeSpecialType = "(V)";
-            } else if (returnType == Integer.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Integer");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(I)";
-            } else if (returnType == Long.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Long");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(J)";
-            } else if (returnType == Short.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Short");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(S)";
-            } else if (returnType == Float.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Float");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(F)";
-            } else if (returnType == Double.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Double");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(D)";
-            } else if (returnType == Byte.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial = "java/lang/Byte");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(B)";
-            } else if (returnType == Character.TYPE) {
-                cfw.add(ByteCode.NEW, invokeSpecial
-                            = "java/lang/Character");
-                cfw.add(ByteCode.DUP);
-                invokeSpecialType = "(C)";
-            }
-        }
-
-        // handle setup of call to virtual function (if calling non-static)
-        if (!java.lang.reflect.Modifier.isStatic(method.getModifiers())) {
-            cfw.add(ByteCode.ALOAD_1);
-            cfw.add(ByteCode.CHECKCAST, declaringClassName);
-        }
-
-        // Handle parameters!
-        StringBuffer params = new StringBuffer(2 + ((types!=null)?(20 *
-                                types.length):0));
-
-        params.append('(');
-        if (types != null) {
-            for(int i = 0; i < types.length; i++) {
-                Class type = types[i];
-
-                cfw.add(ByteCode.ALOAD_2);
-
-                if (i <= 5) {
-                    cfw.add((byte) (ByteCode.ICONST_0 + i));
-                } else if (i <= Byte.MAX_VALUE) {
-                    cfw.add(ByteCode.BIPUSH, i);
-                } else if (i <= Short.MAX_VALUE) {
-                    cfw.add(ByteCode.SIPUSH, i);
-                } else {
-                    cfw.addLoadConstant((int)i);
-                }
-
-                cfw.add(ByteCode.AALOAD);
-
-                if (type.isPrimitive()) {
-                    // Convert enclosed type back to primitive.
-
-                    if (type == Boolean.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Boolean");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Boolean",
-                                "booleanValue", "()", "Z");
-                        params.append('Z');
-                    } else if (type == Integer.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Number");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Number",
-                                "intValue", "()", "I");
-                        params.append('I');
-                    } else if (type == Short.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Number");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Number",
-                                "shortValue", "()", "S");
-                        params.append('S');
-                    } else if (type == Character.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Character");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Character",
-                                "charValue", "()", "C");
-                        params.append('C');
-                    } else if (type == Double.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Number");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Number",
-                                "doubleValue", "()", "D");
-                        params.append('D');
-                    } else if (type == Float.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Number");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Number",
-                                "floatValue", "()", "F");
-                        params.append('F');
-                    } else if (type == Byte.TYPE) {
-                        cfw.add(ByteCode.CHECKCAST, "java/lang/Byte");
-                        cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/Byte",
-                                "byteValue", "()", "B");
-                        params.append('B');
-                    }
-                } else {
-                    String typeName = type.getName().replace('.', '/');
-                    cfw.add(ByteCode.CHECKCAST, typeName);
-
-                    if (!type.isArray()) {
-                        params.append('L');
-                    }
-                    params.append(typeName);
-
-                    if (!type.isArray()) {
-                        params.append(';');
-                    }
-                }
-            }
-        }
-        params.append(')');
-
-        // Call actual function!
-        if (!java.lang.reflect.Modifier.isStatic(method.getModifiers())) {
-            cfw.add(ByteCode.INVOKEVIRTUAL, declaringClassName,
-                    method.getName(), params.toString(),
-                    (invokeSpecialType!=null?invokeSpecialType.substring(1,2)
-                                             :returnType.isArray()?
-                                              returnType.getName().replace('.','/')
-                                              :"L".concat
-                (returnType.getName().replace('.', '/').concat(";"))));
-        } else {
-            cfw.add(ByteCode.INVOKESTATIC, declaringClassName,
-                    method.getName(), params.toString(),
-                    (invokeSpecialType!=null?invokeSpecialType.substring(1,2)
-                                             :returnType.isArray()?
-                                              returnType.getName().replace('.','/')
-                                              :"L".concat
-                (returnType.getName().replace('.', '/').concat(";"))));
-        }
-
-        // Handle return value
-        if (returnsVoid) {
-            cfw.add(ByteCode.ACONST_NULL);
-            cfw.add(ByteCode.ARETURN);
-        } else if (returnsBoolean) {
-            // HACK
-            //check to see if true;
-            // '7' is the number of bytes of the ifeq<branch> plus getstatic<TRUE> plus areturn instructions
-            cfw.add(ByteCode.IFEQ, 7);
-            cfw.add(ByteCode.GETSTATIC,
-                    "java/lang/Boolean",
-                    "TRUE",
-                    "Ljava/lang/Boolean;");
-            cfw.add(ByteCode.ARETURN);
-            cfw.add(ByteCode.GETSTATIC,
-                    "java/lang/Boolean",
-                    "FALSE",
-                    "Ljava/lang/Boolean;");
-            cfw.add(ByteCode.ARETURN);
-        } else if (invokeSpecial != null) {
-            cfw.add(ByteCode.INVOKESPECIAL,
-                    invokeSpecial,
-                    "<init>", invokeSpecialType, "V");
-            cfw.add(ByteCode.ARETURN);
-        } else {
-            cfw.add(ByteCode.ARETURN);
-        }
-        cfw.stopMethod((short)3, null); // three arguments, including the this pointer???
-
-        byte[] bytes = cfw.toByteArray();
-
-        // Add class to our classloader.
-        Class c = classLoader.defineClass(className, bytes);
-        classLoader.linkClass(c);
-        try {
-            result = (Invoker)c.newInstance();
-        } catch (InstantiationException e) {
-            throw new RuntimeException("unexpected " + e.toString());
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException("unexpected " + e.toString());
-        }
-        if (false) {
-            System.out.println
-                ("Generated method delegate for: "+method.getName()
-                 +" on "+method.getDeclaringClass().getName()+" :: "
-                 +params.toString()+" :: "+types);
-        }
-        invokersCache.put(method, result);
-        return result;
-    }
-
-    public Object invoke(Object that, Object [] args) {
-        return null;
-    }
-
-    int classNumber;
-    Hashtable invokersCache;
-    GeneratedClassLoader classLoader;
-}
Index: rhino/JavaAdapter.java
===================================================================
RCS file: rhino/JavaAdapter.java
diff -N rhino/JavaAdapter.java
--- rhino/JavaAdapter.java	22 Oct 2004 14:13:53 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,937 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-1999 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Patrick Beard
- * Norris Boyd
- * Mike McCabe
- * Matthias Radestock
- * Andi Vajda
- * Andrew Wason
- * Kemal Bayram
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript;
-
-import org.mozilla.classfile.*;
-import java.lang.reflect.*;
-import java.io.IOException;
-import java.util.*;
-
-public class JavaAdapter extends ScriptableObject {
-    public boolean equals(Object obj) {
-        return super.equals(obj);
-    }
-
-    public String getClassName() {
-        return "JavaAdapter";
-    }
-
-    public static Object convertResult(Object result, Class c) {
-        if (result == Undefined.instance &&
-            (c != ScriptRuntime.ObjectClass &&
-             c != ScriptRuntime.StringClass))
-        {
-            // Avoid an error for an undefined value; return null instead.
-            return null;
-        }
-        return NativeJavaObject.coerceType(c, result, true);
-    }
-
-    public static Scriptable setAdapterProto(Scriptable obj, Object adapter) {
-        // We could be called from a thread not associated with a Context
-        Context cx = Context.enter();
-        try {
-            Scriptable topLevel = ScriptableObject.getTopLevelScope(obj);
-            Scriptable res = ScriptRuntime.toObject(topLevel, adapter);
-            res.setPrototype(obj);
-            return res;
-        } finally {
-            cx.exit();
-        }
-    }
-
-    public static Object getAdapterSelf(Class adapterClass, Object adapter)
-        throws NoSuchFieldException, IllegalAccessException
-    {
-        Field self = adapterClass.getDeclaredField("self");
-        return self.get(adapter);
-    }
-
-    public static Object jsConstructor(Context cx, Object[] args,
-                                       Function ctorObj, boolean inNewExpr)
-        throws InstantiationException, NoSuchMethodException,
-               IllegalAccessException, InvocationTargetException,
-               ClassNotFoundException, NoSuchFieldException
-    {
-        Class superClass = null;
-        Class[] intfs = new Class[args.length-1];
-        int interfaceCount = 0;
-        for (int i=0; i < args.length-1; i++) {
-            if (!(args[i] instanceof NativeJavaClass)) {
-                throw NativeGlobal.constructError(cx, "TypeError",
-                        "expected java class object", ctorObj);
-            }
-            Class c = ((NativeJavaClass) args[i]).getClassObject();
-            if (!c.isInterface()) {
-                if (superClass != null) {
-                    String msg = "Only one class may be extended by a " +
-                                 "JavaAdapter. Had " + superClass.getName() +
-                                 " and " + c.getName();
-                    throw NativeGlobal.constructError(cx, "TypeError", msg,
-                                                      ctorObj);
-                }
-                superClass = c;
-            } else {
-                intfs[interfaceCount++] = c;
-            }
-        }
-
-        if (superClass == null)
-            superClass = Object.class;
-
-        Class[] interfaces = new Class[interfaceCount];
-        System.arraycopy(intfs, 0, interfaces, 0, interfaceCount);
-        Scriptable obj = (Scriptable) args[args.length - 1];
-
-        ClassSignature sig = new ClassSignature(superClass, interfaces, obj);
-        Class adapterClass = (Class) generatedClasses.get(sig);
-        if (adapterClass == null) {
-            String adapterName;
-            synchronized (generatedClasses) {
-                adapterName = "adapter" + serial++;
-            }
-            adapterClass = createAdapterClass(cx, obj, adapterName,
-                                              superClass, interfaces,
-                                              null, null);
-            generatedClasses.put(sig, adapterClass);
-        }
-
-        Class[] ctorParms = { Scriptable.class };
-        Object[] ctorArgs = { obj };
-        Object adapter = adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);
-        return getAdapterSelf(adapterClass, adapter);
-    }
-
-    // Needed by NativeJavaObject de-serializer
-
-    public static Object createAdapterClass(Class superClass,
-                                            Class[] interfaces,
-                                            Scriptable obj, Scriptable self)
-          throws ClassNotFoundException
-    {
-        ClassSignature sig = new ClassSignature(superClass, interfaces, obj);
-        Class adapterClass = (Class) generatedClasses.get(sig);
-        if (adapterClass == null) {
-            String adapterName;
-            synchronized (generatedClasses) {
-                adapterName = "adapter" + serial++;
-            }
-            Context cx = Context.enter();
-            try {
-                adapterClass = createAdapterClass(cx, obj,
-                                                  adapterName, superClass,
-                                                  interfaces, null, null);
-                generatedClasses.put(sig, adapterClass);
-            } finally {
-                Context.exit();
-            }
-        }
-
-        try {
-            Class[] ctorParms = { Scriptable.class, Scriptable.class };
-            Object[] ctorArgs = { obj, self };
-
-            return adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);
-        } catch(InstantiationException e) {
-        } catch(IllegalAccessException e) {
-        } catch(InvocationTargetException e) {
-        } catch(NoSuchMethodException e) {
-        }
-
-        throw new ClassNotFoundException("adapter");
-    }
-
-    public static Class createAdapterClass(Context cx, Scriptable jsObj,
-                                           String adapterName, Class superClass,
-                                           Class[] interfaces,
-                                           String scriptClassName,
-                                           ClassNameHelper nameHelper)
-        throws ClassNotFoundException
-    {
-        ClassFileWriter cfw = new ClassFileWriter(adapterName,
-                                                  superClass.getName(),
-                                                  "<adapter>");
-        cfw.addField("delegee", "Lorg/mozilla/javascript/Scriptable;",
-                     (short) (ClassFileWriter.ACC_PUBLIC |
-                              ClassFileWriter.ACC_FINAL));
-        cfw.addField("self", "Lorg/mozilla/javascript/Scriptable;",
-                     (short) (ClassFileWriter.ACC_PUBLIC |
-                              ClassFileWriter.ACC_FINAL));
-        int interfacesCount = interfaces == null ? 0 : interfaces.length;
-        for (int i=0; i < interfacesCount; i++) {
-            if (interfaces[i] != null)
-                cfw.addInterface(interfaces[i].getName());
-        }
-
-        String superName = superClass.getName().replace('.', '/');
-        generateCtor(cfw, adapterName, superName);
-        generateSerialCtor(cfw, adapterName, superName);
-        if (scriptClassName != null)
-            generateEmptyCtor(cfw, adapterName, superName, scriptClassName);
-
-        ObjToIntMap generatedOverrides = new ObjToIntMap();
-        ObjToIntMap generatedMethods = new ObjToIntMap();
-
-        // generate methods to satisfy all specified interfaces.
-        for (int i = 0; i < interfacesCount; i++) {
-            Method[] methods = interfaces[i].getMethods();
-            for (int j = 0; j < methods.length; j++) {
-                Method method = methods[j];
-                int mods = method.getModifiers();
-                if (Modifier.isStatic(mods) || Modifier.isFinal(mods) ||
-                    jsObj == null)
-                {
-                    continue;
-                }
-                if (!ScriptableObject.hasProperty(jsObj, method.getName())) {
-                    try {
-                        superClass.getMethod(method.getName(),
-                                             method.getParameterTypes());
-                        // The class we're extending implements this method and
-                        // the JavaScript object doesn't have an override. See
-                        // bug 61226.
-                        continue;
-                    } catch (NoSuchMethodException e) {
-                        // Not implemented by superclass; fall through
-                    }
-                }
-                // make sure to generate only one instance of a particular
-                // method/signature.
-                String methodName = method.getName();
-                String methodKey = methodName + getMethodSignature(method);
-                if (! generatedOverrides.has(methodKey)) {
-                    generateMethod(cfw, adapterName, methodName,
-                                   method.getParameterTypes(),
-                                   method.getReturnType());
-                    generatedOverrides.put(methodKey, 0);
-                    generatedMethods.put(methodName, 0);
-                }
-            }
-        }
-
-        // Now, go through the superclasses methods, checking for abstract
-        // methods or additional methods to override.
-
-        // generate any additional overrides that the object might contain.
-        Method[] methods = superClass.getMethods();
-        for (int j = 0; j < methods.length; j++) {
-            Method method = methods[j];
-            int mods = method.getModifiers();
-            if (Modifier.isStatic(mods) || Modifier.isFinal(mods))
-                continue;
-            // if a method is marked abstract, must implement it or the
-            // resulting class won't be instantiable. otherwise, if the object
-            // has a property of the same name, then an override is intended.
-            boolean isAbstractMethod = Modifier.isAbstract(mods);
-            if (isAbstractMethod ||
-                (jsObj != null && ScriptableObject.hasProperty(jsObj,method.getName())))
-            {
-                // make sure to generate only one instance of a particular
-                // method/signature.
-                String methodName = method.getName();
-                String methodSignature = getMethodSignature(method);
-                String methodKey = methodName + methodSignature;
-                if (! generatedOverrides.has(methodKey)) {
-                    generateMethod(cfw, adapterName, methodName,
-                                   method.getParameterTypes(),
-                                   method.getReturnType());
-                    generatedOverrides.put(methodKey, 0);
-                    generatedMethods.put(methodName, 0);
-                }
-                // if a method was overridden, generate a "super$method"
-                // which lets the delegate call the superclass' version.
-                if (!isAbstractMethod) {
-                    generateSuper(cfw, adapterName, superName,
-                                  methodName, methodSignature,
-                                  method.getParameterTypes(),
-                                  method.getReturnType());
-                }
-            }
-        }
-
-        // Generate Java methods, fields for remaining properties that
-        // are not overrides.
-        for (Scriptable o=jsObj; o != null; o = (Scriptable)o.getPrototype()) {
-            Object[] ids = jsObj.getIds();
-            for (int j=0; j < ids.length; j++) {
-                if (!(ids[j] instanceof String))
-                    continue;
-                String id = (String) ids[j];
-                if (generatedMethods.has(id))
-                    continue;
-                Object f = o.get(id, o);
-                int length;
-                if (f instanceof Function) {
-                    Function p = (Function) f;
-                    length = (int) Context.toNumber(
-                                ScriptableObject.getProperty(p, "length"));
-                } else if (f instanceof FunctionNode) {
-                    // This is used only by optimizer/Codegen
-                    length = ((FunctionNode) f).getVariableTable()
-                                .getParameterCount();
-                } else {
-                    continue;
-                }
-                Class[] parms = new Class[length];
-                for (int k=0; k < length; k++)
-                    parms[k] = Object.class;
-                generateMethod(cfw, adapterName, id, parms, Object.class);
-            }
-        }
-        byte[] bytes = cfw.toByteArray();
-
-        if (nameHelper != null) {
-            try {
-                if (!nameHelper.getClassRepository().storeClass(adapterName,
-                                                                bytes, true))
-                {
-                    return null;
-                }
-            } catch(IOException iox) {
-                throw WrappedException.wrapException(iox);
-            }
-        }
-
-        ClassLoader parentLoader = cx.getApplicationClassLoader();
-        GeneratedClassLoader loader;
-        SecurityController sc = cx.getSecurityController();
-        if (sc == null) {
-            loader = cx.createClassLoader(parentLoader);
-        } else {
-            Object securityDomain = sc.getDynamicSecurityDomain(null);
-            loader = sc.createClassLoader(parentLoader, securityDomain);
-        }
-        Class result = loader.defineClass(adapterName, bytes);
-        loader.linkClass(result);
-        return result;
-    }
-
-    /**
-     * Utility method which dynamically binds a Context to the current thread,
-     * if none already exists.
-     */
-    public static Object callMethod(Scriptable object, Object thisObj,
-                                    String methodId, Object[] args)
-    {
-        Context cx = Context.enter();
-        try {
-            Object fun = ScriptableObject.getProperty(object,methodId);
-            if (fun == Scriptable.NOT_FOUND) {
-                // This method used to swallow the exception from calling
-                // an undefined method. People have come to depend on this
-                // somewhat dubious behavior. It allows people to avoid
-                // implementing listener methods that they don't care about,
-                // for instance.
-                return Undefined.instance;
-            }
-            return ScriptRuntime.call(cx, fun, thisObj, args, object);
-        } catch (JavaScriptException ex) {
-            throw WrappedException.wrapException(ex);
-        } finally {
-            Context.exit();
-        }
-    }
-
-    public static Scriptable toObject(Object value, Scriptable scope,
-                                      Class staticType)
-    {
-        Context cx = Context.enter();
-        try {
-            return ScriptRuntime.toObject(cx, scope, value, staticType);
-        } finally {
-            Context.exit();
-        }
-    }
-
-    private static void generateCtor(ClassFileWriter cfw, String adapterName,
-                                     String superName)
-    {
-        cfw.startMethod("<init>",
-                        "(Lorg/mozilla/javascript/Scriptable;)V",
-                        ClassFileWriter.ACC_PUBLIC);
-
-        // Invoke base class constructor
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.INVOKESPECIAL, superName, "<init>", "()", "V");
-
-        // Save parameter in instance variable "delegee"
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_1);  // first arg
-        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        // create a wrapper object to be used as "this" in method calls
-        cfw.add(ByteCode.ALOAD_1);  // the Scriptable
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.INVOKESTATIC,
-                "org/mozilla/javascript/JavaAdapter",
-                "setAdapterProto",
-                "(Lorg/mozilla/javascript/Scriptable;" +
-                 "Ljava/lang/Object;)",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        // save the wrapper
-        cfw.add(ByteCode.ASTORE_1);
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_1);  // first arg
-        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        cfw.add(ByteCode.RETURN);
-        cfw.stopMethod((short)20, null); // TODO: magic number "20"
-    }
-
-    private static void generateSerialCtor(ClassFileWriter cfw, String adapterName,
-                                     String superName)
-    {
-        cfw.startMethod("<init>",
-                        "(Lorg/mozilla/javascript/Scriptable;Lorg/mozilla/javascript/Scriptable;)V",
-                        ClassFileWriter.ACC_PUBLIC);
-
-        // Invoke base class constructor
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.INVOKESPECIAL, superName, "<init>", "()", "V");
-
-        // Save parameter in instance variable "delegee"
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_1);  // first arg
-        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        // save self
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_2);  // second arg
-        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        cfw.add(ByteCode.RETURN);
-        cfw.stopMethod((short)20, null); // TODO: magic number "20"
-    }
-
-    private static void generateEmptyCtor(ClassFileWriter cfw, String adapterName,
-                                          String superName, String scriptClassName)
-    {
-        cfw.startMethod("<init>", "()V", ClassFileWriter.ACC_PUBLIC);
-
-        // Invoke base class constructor
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.INVOKESPECIAL, superName, "<init>", "()", "V");
-
-        // Load script class
-        cfw.add(ByteCode.NEW, scriptClassName);
-        cfw.add(ByteCode.DUP);
-        cfw.add(ByteCode.INVOKESPECIAL, scriptClassName, "<init>", "()", "V");
-
-        // Run script and save resulting scope
-        cfw.add(ByteCode.INVOKESTATIC,
-                "org/mozilla/javascript/ScriptRuntime",
-                "runScript",
-                "(Lorg/mozilla/javascript/Script;)",
-                "Lorg/mozilla/javascript/Scriptable;");
-        cfw.add(ByteCode.ASTORE_1);
-
-        // Save the Scriptable in instance variable "delegee"
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_1);  // the Scriptable
-        cfw.add(ByteCode.PUTFIELD, adapterName, "delegee",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        // create a wrapper object to be used as "this" in method calls
-        cfw.add(ByteCode.ALOAD_1);  // the Scriptable
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.INVOKESTATIC,
-                "org/mozilla/javascript/JavaAdapter",
-                "setAdapterProto",
-                "(Lorg/mozilla/javascript/Scriptable;" +
-                 "Ljava/lang/Object;)",
-                "Lorg/mozilla/javascript/Scriptable;");
-        //save the wrapper
-        cfw.add(ByteCode.ASTORE_1);
-        cfw.add(ByteCode.ALOAD_0);  // this
-        cfw.add(ByteCode.ALOAD_1);  // first arg
-        cfw.add(ByteCode.PUTFIELD, adapterName, "self",
-                "Lorg/mozilla/javascript/Scriptable;");
-
-        cfw.add(ByteCode.RETURN);
-        cfw.stopMethod((short)20, null); // TODO: magic number "20"
-    }
-
-    /**
-     * Generates code to create a java.lang.Boolean, java.lang.Character or a
-     * java.lang.Double to wrap the specified primitive parameter. Leaves the
-     * wrapper object on the top of the stack.
-     */
-    private static int generateWrapParam(ClassFileWriter cfw, int paramOffset,
-                                         Class paramType)
-    {
-        if (paramType.equals(Boolean.TYPE)) {
-            // wrap boolean values with java.lang.Boolean.
-            cfw.add(ByteCode.NEW, "java/lang/Boolean");
-            cfw.add(ByteCode.DUP);
-            cfw.add(ByteCode.ILOAD, paramOffset++);
-            cfw.add(ByteCode.INVOKESPECIAL, "java/lang/Boolean",
-                    "<init>", "(Z)", "V");
-        } else
-            if (paramType.equals(Character.TYPE)) {
-                // Create a string of length 1 using the character parameter.
-                cfw.add(ByteCode.NEW, "java/lang/String");
-                cfw.add(ByteCode.DUP);
-                cfw.add(ByteCode.ICONST_1);
-                cfw.add(ByteCode.NEWARRAY, ByteCode.T_CHAR);
-                cfw.add(ByteCode.DUP);
-                cfw.add(ByteCode.ICONST_0);
-                cfw.add(ByteCode.ILOAD, paramOffset++);
-                cfw.add(ByteCode.CASTORE);
-                cfw.add(ByteCode.INVOKESPECIAL, "java/lang/String",
-                        "<init>", "([C)", "V");
-            } else {
-                // convert all numeric values to java.lang.Double.
-                cfw.add(ByteCode.NEW, "java/lang/Double");
-                cfw.add(ByteCode.DUP);
-                String typeName = paramType.getName();
-                switch (typeName.charAt(0)) {
-                case 'b':
-                case 's':
-                case 'i':
-                    // load an int value, convert to double.
-                    cfw.add(ByteCode.ILOAD, paramOffset++);
-                    cfw.add(ByteCode.I2D);
-                    break;
-                case 'l':
-                    // load a long, convert to double.
-                    cfw.add(ByteCode.LLOAD, paramOffset);
-                    cfw.add(ByteCode.L2D);
-                    paramOffset += 2;
-                    break;
-                case 'f':
-                    // load a float, convert to double.
-                    cfw.add(ByteCode.FLOAD, paramOffset++);
-                    cfw.add(ByteCode.F2D);
-                    break;
-                case 'd':
-                    cfw.add(ByteCode.DLOAD, paramOffset);
-                    paramOffset += 2;
-                    break;
-                }
-                cfw.add(ByteCode.INVOKESPECIAL, "java/lang/Double",
-                        "<init>", "(D)", "V");
-            }
-        return paramOffset;
-    }
-
-    /**
-     * Generates code to convert a wrapped value type to a primitive type.
-     * Handles unwrapping java.lang.Boolean, and java.lang.Number types.
-     * May need to map between char and java.lang.String as well.
-     * Generates the appropriate RETURN bytecode.
-     */
-    private static void generateReturnResult(ClassFileWriter cfw,
-                                             Class retType)
-    {
-        // wrap boolean values with java.lang.Boolean, convert all other
-        // primitive values to java.lang.Double.
-        if (retType.equals(Boolean.TYPE)) {
-            cfw.add(ByteCode.INVOKESTATIC,
-                    "org/mozilla/javascript/Context",
-                    "toBoolean", "(Ljava/lang/Object;)",
-                    "Z");
-            cfw.add(ByteCode.IRETURN);
-        } else if (retType.equals(Character.TYPE)) {
-                // characters are represented as strings in JavaScript.
-                // return the first character.
-                // first convert the value to a string if possible.
-                cfw.add(ByteCode.INVOKESTATIC,
-                        "org/mozilla/javascript/Context",
-                        "toString", "(Ljava/lang/Object;)",
-                        "Ljava/lang/String;");
-                cfw.add(ByteCode.ICONST_0);
-                cfw.add(ByteCode.INVOKEVIRTUAL, "java/lang/String", "charAt",
-                        "(I)", "C");
-                cfw.add(ByteCode.IRETURN);
-        } else if (retType.isPrimitive()) {
-            cfw.add(ByteCode.INVOKESTATIC,
-                    "org/mozilla/javascript/Context",
-                    "toNumber", "(Ljava/lang/Object;)",
-                    "D");
-            String typeName = retType.getName();
-            switch (typeName.charAt(0)) {
-            case 'b':
-            case 's':
-            case 'i':
-                cfw.add(ByteCode.D2I);
-                cfw.add(ByteCode.IRETURN);
-                break;
-            case 'l':
-                cfw.add(ByteCode.D2L);
-                cfw.add(ByteCode.LRETURN);
-                break;
-            case 'f':
-                cfw.add(ByteCode.D2F);
-                cfw.add(ByteCode.FRETURN);
-                break;
-            case 'd':
-                cfw.add(ByteCode.DRETURN);
-                break;
-            default:
-                throw new RuntimeException("Unexpected return type " +
-                                           retType.toString());
-            }
-        } else {
-            String retTypeStr = retType.getName();
-            cfw.addLoadConstant(retTypeStr);
-            cfw.add(ByteCode.INVOKESTATIC,
-                    "java/lang/Class",
-                    "forName",
-                    "(Ljava/lang/String;)",
-                    "Ljava/lang/Class;");
-
-            cfw.add(ByteCode.INVOKESTATIC,
-                    "org/mozilla/javascript/JavaAdapter",
-                    "convertResult",
-                    "(Ljava/lang/Object;" +
-                    "Ljava/lang/Class;)",
-                    "Ljava/lang/Object;");
-            // Now cast to return type
-            cfw.add(ByteCode.CHECKCAST, retTypeStr.replace('.', '/'));
-            cfw.add(ByteCode.ARETURN);
-        }
-    }
-
-    private static void generateMethod(ClassFileWriter cfw, String genName,
-                                       String methodName, Class[] parms,
-                                       Class returnType)
-    {
-        StringBuffer sb = new StringBuffer();
-        sb.append('(');
-        short arrayLocal = 1;    // includes this.
-        for (int i = 0; i < parms.length; i++) {
-            Class type = parms[i];
-            appendTypeString(sb, type);
-            if (type.equals(Long.TYPE) || type.equals(Double.TYPE))
-                arrayLocal += 2;
-            else
-                arrayLocal += 1;
-        }
-        sb.append(')');
-        appendTypeString(sb, returnType);
-        String methodSignature = sb.toString();
-        // System.out.println("generating " + m.getName() + methodSignature);
-        // System.out.flush();
-        cfw.startMethod(methodName, methodSignature,
-                        ClassFileWriter.ACC_PUBLIC);
-        cfw.add(ByteCode.BIPUSH, (byte) parms.length);  // > 255 parms?
-        cfw.add(ByteCode.ANEWARRAY, "java/lang/Object");
-        cfw.add(ByteCode.ASTORE, arrayLocal);
-
-        // allocate a local variable to store the scope used to wrap native objects.
-        short scopeLocal = (short) (arrayLocal + 1);
-        boolean loadedScope = false;
-
-        int paramOffset = 1;
-        for (int i = 0; i < parms.length; i++) {
-            cfw.add(ByteCode.ALOAD, arrayLocal);
-            cfw.add(ByteCode.BIPUSH, i);
-            if (parms[i].isPrimitive()) {
-                paramOffset = generateWrapParam(cfw, paramOffset, parms[i]);
-            } else {
-                // An arbitary Java object; call Context.toObject to wrap in
-                // a Scriptable object
-                cfw.add(ByteCode.ALOAD, paramOffset++);
-                if (! loadedScope) {
-                    // load this.self into a local the first time it's needed.
-                    // it will provide the scope needed by Context.toObject().
-                    cfw.add(ByteCode.ALOAD_0);
-                    cfw.add(ByteCode.GETFIELD, genName, "delegee",
-                            "Lorg/mozilla/javascript/Scriptable;");
-                    cfw.add(ByteCode.ASTORE, scopeLocal);
-                    loadedScope = true;
-                }
-                cfw.add(ByteCode.ALOAD, scopeLocal);
-
-                // Get argument Class
-                cfw.addLoadConstant(parms[i].getName());
-                cfw.add(ByteCode.INVOKESTATIC,
-                        "java/lang/Class",
-                        "forName",
-                        "(Ljava/lang/String;)",
-                        "Ljava/lang/Class;");
-
-                cfw.add(ByteCode.INVOKESTATIC,
-                        "org/mozilla/javascript/JavaAdapter",
-                        "toObject",
-                        "(Ljava/lang/Object;" +
-                         "Lorg/mozilla/javascript/Scriptable;" +
-                         "Ljava/lang/Class;)",
-                        "Lorg/mozilla/javascript/Scriptable;");
-            }
-            cfw.add(ByteCode.AASTORE);
-        }
-
-        cfw.add(ByteCode.ALOAD_0);
-        cfw.add(ByteCode.GETFIELD, genName, "delegee",
-                "Lorg/mozilla/javascript/Scriptable;");
-        cfw.add(ByteCode.ALOAD_0);
-        cfw.add(ByteCode.GETFIELD, genName, "self",
-                "Lorg/mozilla/javascript/Scriptable;");
-        cfw.addLoadConstant(methodName);
-        cfw.add(ByteCode.ALOAD, arrayLocal);
-
-        // go through utility method, which creates a Context to run the
-        // method in.
-        cfw.add(ByteCode.INVOKESTATIC,
-                "org/mozilla/javascript/JavaAdapter",
-                "callMethod",
-                "(Lorg/mozilla/javascript/Scriptable;" +
-                 "Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)",
-                "Ljava/lang/Object;");
-
-        if (returnType.equals(Void.TYPE)) {
-            cfw.add(ByteCode.POP);
-            cfw.add(ByteCode.RETURN);
-        } else {
-            generateReturnResult(cfw, returnType);
-        }
-        cfw.stopMethod((short)(scopeLocal + 3), null);
-    }
-
-    /**
-     * Generates code to push typed parameters onto the operand stack
-     * prior to a direct Java method call.
-     */
-    private static int generatePushParam(ClassFileWriter cfw, int paramOffset,
-                                         Class paramType)
-    {
-        String typeName = paramType.getName();
-        switch (typeName.charAt(0)) {
-        case 'z':
-        case 'b':
-        case 'c':
-        case 's':
-        case 'i':
-            // load an int value, convert to double.
-            cfw.add(ByteCode.ILOAD, paramOffset++);
-            break;
-        case 'l':
-            // load a long, convert to double.
-            cfw.add(ByteCode.LLOAD, paramOffset);
-            paramOffset += 2;
-            break;
-        case 'f':
-            // load a float, convert to double.
-            cfw.add(ByteCode.FLOAD, paramOffset++);
-            break;
-        case 'd':
-            cfw.add(ByteCode.DLOAD, paramOffset);
-            paramOffset += 2;
-            break;
-        }
-        return paramOffset;
-    }
-
-    /**
-     * Generates code to return a Java type, after calling a Java method
-     * that returns the same type.
-     * Generates the appropriate RETURN bytecode.
-     */
-    private static void generatePopResult(ClassFileWriter cfw,
-                                          Class retType)
-    {
-        if (retType.isPrimitive()) {
-            String typeName = retType.getName();
-            switch (typeName.charAt(0)) {
-            case 'b':
-            case 'c':
-            case 's':
-            case 'i':
-            case 'z':
-                cfw.add(ByteCode.IRETURN);
-                break;
-            case 'l':
-                cfw.add(ByteCode.LRETURN);
-                break;
-            case 'f':
-                cfw.add(ByteCode.FRETURN);
-                break;
-            case 'd':
-                cfw.add(ByteCode.DRETURN);
-                break;
-            }
-        } else {
-            cfw.add(ByteCode.ARETURN);
-        }
-    }
-
-    /**
-     * Generates a method called "super$methodName()" which can be called
-     * from JavaScript that is equivalent to calling "super.methodName()"
-     * from Java. Eventually, this may be supported directly in JavaScript.
-     */
-    private static void generateSuper(ClassFileWriter cfw,
-                                      String genName, String superName,
-                                      String methodName, String methodSignature,
-                                      Class[] parms, Class returnType)
-    {
-        cfw.startMethod("super$" + methodName, methodSignature,
-                        ClassFileWriter.ACC_PUBLIC);
-
-        // push "this"
-        cfw.add(ByteCode.ALOAD, 0);
-
-        // push the rest of the parameters.
-        int paramOffset = 1;
-        for (int i = 0; i < parms.length; i++) {
-            if (parms[i].isPrimitive()) {
-                paramOffset = generatePushParam(cfw, paramOffset, parms[i]);
-            } else {
-                cfw.add(ByteCode.ALOAD, paramOffset++);
-            }
-        }
-
-        // split the method signature at the right parentheses.
-        int rightParen = methodSignature.indexOf(')');
-
-        // call the superclass implementation of the method.
-        cfw.add(ByteCode.INVOKESPECIAL,
-                superName,
-                methodName,
-                methodSignature.substring(0, rightParen + 1),
-                methodSignature.substring(rightParen + 1));
-
-        // now, handle the return type appropriately.
-        Class retType = returnType;
-        if (!retType.equals(Void.TYPE)) {
-            generatePopResult(cfw, retType);
-        } else {
-            cfw.add(ByteCode.RETURN);
-        }
-        cfw.stopMethod((short)(paramOffset + 1), null);
-    }
-
-    /**
-     * Returns a fully qualified method name concatenated with its signature.
-     */
-    private static String getMethodSignature(Method method) {
-        Class[] parms = method.getParameterTypes();
-        StringBuffer sb = new StringBuffer();
-        sb.append('(');
-        for (int i = 0; i < parms.length; i++) {
-            Class type = parms[i];
-            appendTypeString(sb, type);
-        }
-        sb.append(')');
-        appendTypeString(sb, method.getReturnType());
-        return sb.toString();
-    }
-
-    private static StringBuffer appendTypeString(StringBuffer sb, Class type)
-    {
-        while (type.isArray()) {
-            sb.append('[');
-            type = type.getComponentType();
-        }
-        if (type.isPrimitive()) {
-            if (type.equals(Boolean.TYPE)) {
-                sb.append('Z');
-            } else
-                if (type.equals(Long.TYPE)) {
-                    sb.append('J');
-                } else {
-                    String typeName = type.getName();
-                    sb.append(Character.toUpperCase(typeName.charAt(0)));
-                }
-        } else {
-            sb.append('L');
-            sb.append(type.getName().replace('.', '/'));
-            sb.append(';');
-        }
-        return sb;
-    }
-
-    /**
-     * Provides a key with which to distinguish previously generated
-     * adapter classes stored in a hash table.
-     */
-    static class ClassSignature {
-        Class mSuperClass;
-        Class[] mInterfaces;
-        Object[] mProperties;    // JDK1.2: Use HashSet
-
-        ClassSignature(Class superClass, Class[] interfaces, Scriptable jsObj) {
-            mSuperClass = superClass;
-            mInterfaces = interfaces;
-            mProperties = ScriptableObject.getPropertyIds(jsObj);
-        }
-
-        public boolean equals(Object obj) {
-            if (obj instanceof ClassSignature) {
-                ClassSignature sig = (ClassSignature) obj;
-                if (mSuperClass == sig.mSuperClass) {
-                    Class[] interfaces = sig.mInterfaces;
-                    if (mInterfaces != interfaces) {
-                        if (mInterfaces == null || interfaces == null)
-                            return false;
-                        if (mInterfaces.length != interfaces.length)
-                            return false;
-                        for (int i=0; i < interfaces.length; i++)
-                            if (mInterfaces[i] != interfaces[i])
-                                return false;
-                    }
-                    if (mProperties.length != sig.mProperties.length)
-                        return false;
-                    for (int i=0; i < mProperties.length; i++) {
-                        if (!mProperties[i].equals(sig.mProperties[i]))
-                            return false;
-                    }
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        public int hashCode() {
-            return mSuperClass.hashCode();
-        }
-    }
-
-    private static int serial;
-    private static Hashtable generatedClasses = new Hashtable(7);
-}
Index: rhino/Main.java
===================================================================
RCS file: rhino/Main.java
diff -N rhino/Main.java
--- rhino/Main.java	22 Oct 2004 14:14:08 -0000	1.5
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,4099 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino JavaScript Debugger code, released
- * November 21, 2000.
- *
- * The Initial Developer of the Original Code is SeeBeyond Corporation.
-
- * Portions created by SeeBeyond are
- * Copyright (C) 2000 SeeBeyond Technology Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Christopher Oliver
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript.tools.debugger;
-
-import javax.swing.*;
-import javax.swing.text.*;
-import javax.swing.event.*;
-import javax.swing.table.*;
-import java.awt.*;
-import java.awt.event.*;
-import java.util.StringTokenizer;
-
-import org.mozilla.javascript.*;
-import org.mozilla.javascript.debug.*;
-import org.mozilla.javascript.tools.shell.ConsoleTextArea;
-import java.util.*;
-import java.io.*;
-import javax.swing.tree.DefaultMutableTreeNode;
-import javax.swing.tree.DefaultTreeCellRenderer;
-import java.lang.reflect.Method;
-import java.net.URL;
-
-class MessageDialogWrapper {
-
-    static void showMessageDialog(Component parent, String msg,
-                                  String title, int flags) {
-        if (msg.length() > 60) {
-            StringBuffer buf = new StringBuffer();
-            int len = msg.length();
-            int j = 0;
-            int i;
-            for (i = 0; i < len; i++, j++) {
-                char c = msg.charAt(i);
-                buf.append(c);
-                if (Character.isWhitespace(c)) {
-                    int remainder = len - i;
-                    int k;
-                    for (k = i + 1; k < len; k++) {
-                        if (Character.isWhitespace(msg.charAt(k))) {
-                            break;
-                        }
-                    }
-                    if (k < len) {
-                        int nextWordLen = k - i;
-                        if (j + nextWordLen > 60) {
-                            buf.append('\n');
-                            j = 0;
-                        }
-                    }
-                }
-            }
-            msg = buf.toString();
-        }
-        JOptionPane.showMessageDialog(parent, msg, title, flags);
-    }
-};
-
-class EvalTextArea extends JTextArea implements KeyListener,
-DocumentListener {
-    Main db;
-    private java.util.Vector history;
-    private int historyIndex = -1;
-    private int outputMark = 0;
-
-    public void select(int start, int end) {
-        //requestFocus();
-        super.select(start, end);
-    }
-
-    public EvalTextArea(Main db) {
-        super();
-        this.db = db;
-        history = new java.util.Vector();
-        Document doc = getDocument();
-        doc.addDocumentListener(this);
-        addKeyListener(this);
-        setLineWrap(true);
-        setFont(new Font("Monospaced", 0, 12));
-        append("% ");
-        outputMark = doc.getLength();
-    }
-
-    synchronized void returnPressed() {
-        Document doc = getDocument();
-        int len = doc.getLength();
-        Segment segment = new Segment();
-        try {
-            doc.getText(outputMark, len - outputMark, segment);
-        } catch (javax.swing.text.BadLocationException ignored) {
-            ignored.printStackTrace();
-        }
-        String text = segment.toString();
-        if (db.stringIsCompilableUnit(text)) {
-            if (text.trim().length() > 0) {
-               history.addElement(text);
-               historyIndex = history.size();
-            }
-            append("\n");
-            String result = db.eval(text);
-            if (result.length() > 0) {
-                append(result);
-                append("\n");
-            }
-            append("% ");
-            outputMark = doc.getLength();
-        } else {
-            append("\n");
-        }
-    }
-
-    public void keyPressed(KeyEvent e) {
-        int code = e.getKeyCode();
-        if (code == KeyEvent.VK_BACK_SPACE || code == KeyEvent.VK_LEFT) {
-            if (outputMark == getCaretPosition()) {
-                e.consume();
-            }
-        } else if (code == KeyEvent.VK_HOME) {
-           int caretPos = getCaretPosition();
-           if (caretPos == outputMark) {
-               e.consume();
-           } else if (caretPos > outputMark) {
-               if (!e.isControlDown()) {
-                   if (e.isShiftDown()) {
-                       moveCaretPosition(outputMark);
-                   } else {
-                       setCaretPosition(outputMark);
-                   }
-                   e.consume();
-               }
-           }
-        } else if (code == KeyEvent.VK_ENTER) {
-            returnPressed();
-            e.consume();
-        } else if (code == KeyEvent.VK_UP) {
-            historyIndex--;
-            if (historyIndex >= 0) {
-                if (historyIndex >= history.size()) {
-                    historyIndex = history.size() -1;
-                }
-                if (historyIndex >= 0) {
-                    String str = (String)history.elementAt(historyIndex);
-                    int len = getDocument().getLength();
-                    replaceRange(str, outputMark, len);
-                    int caretPos = outputMark + str.length();
-                    select(caretPos, caretPos);
-                } else {
-                    historyIndex++;
-                }
-            } else {
-                historyIndex++;
-            }
-            e.consume();
-        } else if (code == KeyEvent.VK_DOWN) {
-            int caretPos = outputMark;
-            if (history.size() > 0) {
-                historyIndex++;
-                if (historyIndex < 0) {historyIndex = 0;}
-                int len = getDocument().getLength();
-                if (historyIndex < history.size()) {
-                    String str = (String)history.elementAt(historyIndex);
-                    replaceRange(str, outputMark, len);
-                    caretPos = outputMark + str.length();
-                } else {
-                    historyIndex = history.size();
-                    replaceRange("", outputMark, len);
-                }
-            }
-            select(caretPos, caretPos);
-            e.consume();
-        }
-    }
-
-    public void keyTyped(KeyEvent e) {
-        int keyChar = e.getKeyChar();
-        if (keyChar == 0x8 /* KeyEvent.VK_BACK_SPACE */) {
-            if (outputMark == getCaretPosition()) {
-                e.consume();
-            }
-        } else if (getCaretPosition() < outputMark) {
-            setCaretPosition(outputMark);
-        }
-    }
-
-    public synchronized void keyReleased(KeyEvent e) {
-    }
-
-    public synchronized void write(String str) {
-        insert(str, outputMark);
-        int len = str.length();
-        outputMark += len;
-        select(outputMark, outputMark);
-    }
-
-    public synchronized void insertUpdate(DocumentEvent e) {
-        int len = e.getLength();
-        int off = e.getOffset();
-        if (outputMark > off) {
-            outputMark += len;
-        }
-    }
-
-    public synchronized void removeUpdate(DocumentEvent e) {
-        int len = e.getLength();
-        int off = e.getOffset();
-        if (outputMark > off) {
-            if (outputMark >= off + len) {
-                outputMark -= len;
-            } else {
-                outputMark = off;
-            }
-        }
-    }
-
-    public synchronized void postUpdateUI() {
-        // this attempts to cleanup the damage done by updateComponentTreeUI
-        //requestFocus();
-        setCaret(getCaret());
-        select(outputMark, outputMark);
-    }
-
-    public synchronized void changedUpdate(DocumentEvent e) {
-    }
-};
-
-class EvalWindow extends JInternalFrame
-implements ActionListener {
-
-    EvalTextArea evalTextArea;
-
-    public void setEnabled(boolean b) {
-        super.setEnabled(b);
-        evalTextArea.setEnabled(b);
-    }
-
-    public EvalWindow(String name, Main db) {
-        super(name, true, false, true, true);
-        evalTextArea = new EvalTextArea(db);
-        evalTextArea.setRows(24);
-        evalTextArea.setColumns(80);
-        JScrollPane scroller = new JScrollPane(evalTextArea);
-        setContentPane(scroller);
-        //scroller.setPreferredSize(new Dimension(600, 400));
-        pack();
-        setVisible(true);
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        if (cmd.equals("Cut")) {
-            evalTextArea.cut();
-        } else if (cmd.equals("Copy")) {
-            evalTextArea.copy();
-        } else if (cmd.equals("Paste")) {
-            evalTextArea.paste();
-        }
-    }
-};
-
-class JSInternalConsole extends JInternalFrame
-    implements ActionListener {
-
-    ConsoleTextArea consoleTextArea;
-
-    public InputStream getIn() {
-        return consoleTextArea.getIn();
-    }
-
-    public PrintStream getOut() {
-        return consoleTextArea.getOut();
-    }
-
-    public PrintStream getErr() {
-        return consoleTextArea.getErr();
-    }
-
-    public JSInternalConsole(String name) {
-        super(name, true, false, true, true);
-        consoleTextArea = new ConsoleTextArea(null);
-        consoleTextArea.setRows(24);
-        consoleTextArea.setColumns(80);
-        JScrollPane scroller = new JScrollPane(consoleTextArea);
-        setContentPane(scroller);
-        pack();
-        addInternalFrameListener(new InternalFrameAdapter() {
-                public void internalFrameActivated(InternalFrameEvent e) {
-                    // hack
-                    if (consoleTextArea.hasFocus()) {
-                        consoleTextArea.getCaret().setVisible(false);
-                        consoleTextArea.getCaret().setVisible(true);
-                    }
-                }
-            });
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        if (cmd.equals("Cut")) {
-            consoleTextArea.cut();
-        } else if (cmd.equals("Copy")) {
-            consoleTextArea.copy();
-        } else if (cmd.equals("Paste")) {
-            consoleTextArea.paste();
-        }
-    }
-
-
-};
-
-class FilePopupMenu extends JPopupMenu {
-    FileTextArea w;
-    int x, y;
-
-    FilePopupMenu(FileTextArea w) {
-        super();
-        this.w = w;
-        JMenuItem item;
-        add(item = new JMenuItem("Set Breakpoint"));
-        item.addActionListener(w);
-        add(item = new JMenuItem("Clear Breakpoint"));
-        item.addActionListener(w);
-        //add(item = new JMenuItem("Run to Cursor"));
-        //item.addActionListener(w);
-        add(item = new JMenuItem("Run"));
-        item.addActionListener(w);
-    }
-
-    void show(JComponent comp, int x, int y) {
-        this.x = x;
-        this.y = y;
-        super.show(comp, x, y);
-    }
-};
-
-class FileTextArea extends JTextArea implements ActionListener,
-                                                PopupMenuListener,
-                                                KeyListener,
-                                                MouseListener {
-    FileWindow w;
-    FilePopupMenu popup;
-
-    FileTextArea(FileWindow w) {
-        this.w = w;
-        popup = new FilePopupMenu(this);
-        popup.addPopupMenuListener(this);
-        addMouseListener(this);
-        addKeyListener(this);
-        setFont(new Font("Monospaced", 0, 12));
-    }
-
-    void select(int pos) {
-        if (pos >= 0) {
-            try {
-                int line = getLineOfOffset(pos);
-                Rectangle rect = modelToView(pos);
-                if (rect == null) {
-                    select(pos, pos);
-                } else {
-                    try {
-                        Rectangle nrect =
-                            modelToView(getLineStartOffset(line + 1));
-                        if (nrect != null) {
-                            rect = nrect;
-                        }
-                    } catch (Exception exc) {
-                    }
-                    JViewport vp = (JViewport)getParent();
-                    Rectangle viewRect = vp.getViewRect();
-                    if (viewRect.y + viewRect.height > rect.y) {
-                        // need to scroll up
-                        select(pos, pos);
-                    } else {
-                        // need to scroll down
-                        rect.y += (viewRect.height - rect.height)/2;
-                        scrollRectToVisible(rect);
-                        select(pos, pos);
-                    }
-                }
-            } catch (BadLocationException exc) {
-                select(pos, pos);
-                //exc.printStackTrace();
-            }
-        }
-    }
-
-
-    public void mousePressed(MouseEvent e) {
-        checkPopup(e);
-    }
-    public void mouseClicked(MouseEvent e) {
-        checkPopup(e);
-        requestFocus();
-        getCaret().setVisible(true);
-    }
-    public void mouseEntered(MouseEvent e) {
-    }
-    public void mouseExited(MouseEvent e) {
-    }
-    public void mouseReleased(MouseEvent e) {
-        checkPopup(e);
-    }
-
-    private void checkPopup(MouseEvent e) {
-        if (e.isPopupTrigger()) {
-            popup.show(this, e.getX(), e.getY());
-        }
-    }
-
-    public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
-    }
-    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
-    }
-    public void popupMenuCanceled(PopupMenuEvent e) {
-    }
-    public void actionPerformed(ActionEvent e) {
-        int pos = viewToModel(new Point(popup.x, popup.y));
-        popup.setVisible(false);
-        String cmd = e.getActionCommand();
-        int line = -1;
-        try {
-            line = getLineOfOffset(pos);
-        } catch (Exception exc) {
-        }
-        if (cmd.equals("Set Breakpoint")) {
-            w.setBreakPoint(line + 1);
-        } else if (cmd.equals("Clear Breakpoint")) {
-            w.clearBreakPoint(line + 1);
-        } else if (cmd.equals("Run to Cursor")) {
-            w.runToCursor(e);
-        } else if (cmd.equals("Run")) {
-            w.load();
-        }
-    }
-    public void keyPressed(KeyEvent e) {
-        switch (e.getKeyCode()) {
-        case KeyEvent.VK_BACK_SPACE:
-        case KeyEvent.VK_ENTER:
-        case KeyEvent.VK_DELETE:
-            if (w.isEditable() == false) {
-                e.consume();
-            }
-            break;
-        }
-    }
-    public void keyTyped(KeyEvent e) {
-        if (w.isEditable() == false) {
-            e.consume();
-        }
-    }
-    public void keyReleased(KeyEvent e) {
-        if (w.isEditable() == false) {
-            e.consume();
-        }
-    }
-}
-
-class MoreWindows extends JDialog implements ActionListener {
-
-    private String value = null;
-    private JList list;
-    Hashtable fileWindows;
-    JButton setButton;
-    JButton refreshButton;
-    JButton cancelButton;
-
-
-    public String showDialog(Component comp) {
-        value = null;
-        setLocationRelativeTo(comp);
-        setVisible(true);
-        return value;
-    }
-
-    private void setValue(String newValue) {
-        value = newValue;
-        list.setSelectedValue(value, true);
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        if (cmd.equals("Cancel")) {
-            setVisible(false);
-            value = null;
-        } else if (cmd.equals("Select")) {
-            value = (String)list.getSelectedValue();
-            setVisible(false);
-            JInternalFrame w = (JInternalFrame)fileWindows.get(value);
-            if (w != null) {
-                try {
-                    w.show();
-                    w.setSelected(true);
-                } catch (Exception exc) {
-                }
-            }
-        }
-    }
-
-    class MouseHandler extends MouseAdapter {
-        public void mouseClicked(MouseEvent e) {
-            if (e.getClickCount() == 2) {
-                setButton.doClick();
-            }
-        }
-    };
-
-    MoreWindows(JFrame frame, Hashtable fileWindows,
-                String title,
-                String labelText) {
-        super(frame, title, true);
-        this.fileWindows = fileWindows;
-        //buttons
-        cancelButton = new JButton("Cancel");
-        setButton = new JButton("Select");
-        cancelButton.addActionListener(this);
-        setButton.addActionListener(this);
-        getRootPane().setDefaultButton(setButton);
-
-        //main part of the dialog
-        list = new JList(new DefaultListModel());
-        DefaultListModel model = (DefaultListModel)list.getModel();
-        model.clear();
-        //model.fireIntervalRemoved(model, 0, size);
-        Enumeration e = fileWindows.keys();
-        while (e.hasMoreElements()) {
-            String data = e.nextElement().toString();
-            model.addElement(data);
-        }
-        list.setSelectedIndex(0);
-        //model.fireIntervalAdded(model, 0, data.length);
-        setButton.setEnabled(true);
-        list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
-        list.addMouseListener(new MouseHandler());
-        JScrollPane listScroller = new JScrollPane(list);
-        listScroller.setPreferredSize(new Dimension(320, 240));
-        //XXX: Must do the following, too, or else the scroller thinks
-        //XXX: it's taller than it is:
-        listScroller.setMinimumSize(new Dimension(250, 80));
-        listScroller.setAlignmentX(LEFT_ALIGNMENT);
-
-        //Create a container so that we can add a title around
-        //the scroll pane.  Can't add a title directly to the
-        //scroll pane because its background would be white.
-        //Lay out the label and scroll pane from top to button.
-        JPanel listPane = new JPanel();
-        listPane.setLayout(new BoxLayout(listPane, BoxLayout.Y_AXIS));
-        JLabel label = new JLabel(labelText);
-        label.setLabelFor (list);
-        listPane.add(label);
-        listPane.add(Box.createRigidArea(new Dimension(0,5)));
-        listPane.add(listScroller);
-        listPane.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
-
-        //Lay out the buttons from left to right.
-        JPanel buttonPane = new JPanel();
-        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.X_AXIS));
-        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
-        buttonPane.add(Box.createHorizontalGlue());
-        buttonPane.add(cancelButton);
-        buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));
-        buttonPane.add(setButton);
-
-        //Put everything together, using the content pane's BorderLayout.
-        Container contentPane = getContentPane();
-        contentPane.add(listPane, BorderLayout.CENTER);
-        contentPane.add(buttonPane, BorderLayout.SOUTH);
-        pack();
-        addKeyListener(new KeyAdapter() {
-                public void keyPressed(KeyEvent ke) {
-                    int code = ke.getKeyCode();
-                    if (code == KeyEvent.VK_ESCAPE) {
-                        ke.consume();
-                        value = null;
-                        setVisible(false);
-                    }
-                }
-            });
-    }
-};
-
-class FindFunction extends JDialog implements ActionListener {
-    private String value = null;
-    private JList list;
-    Hashtable functionNames;
-    Main db;
-    JButton setButton;
-    JButton refreshButton;
-    JButton cancelButton;
-
-    public String showDialog(Component comp) {
-        value = null;
-        setLocationRelativeTo(comp);
-        setVisible(true);
-        return value;
-    }
-
-    private void setValue(String newValue) {
-        value = newValue;
-        list.setSelectedValue(value, true);
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        if (cmd.equals("Cancel")) {
-            setVisible(false);
-            value = null;
-        } else if (cmd.equals("Select")) {
-            if (list.getSelectedIndex() < 0) {
-                return;
-            }
-            try {
-                value = (String)list.getSelectedValue();
-            } catch (ArrayIndexOutOfBoundsException exc) {
-                return;
-            }
-            setVisible(false);
-            ScriptItem item = (ScriptItem)functionNames.get(value);
-            if (item != null) {
-                SourceInfo si = item.getSourceInfo();
-                String url = si.getUrl();
-                int lineNumber = item.getFirstLine();
-                FileWindow w = db.getFileWindow(url);
-                if (w == null) {
-                    CreateFileWindow.action(db, si, lineNumber).run();
-                    w = db.getFileWindow(url);
-                    w.setPosition(-1);
-                }
-                int start = w.getPosition(lineNumber-1);
-                int end = w.getPosition(lineNumber)-1;
-                w.textArea.select(start);
-                w.textArea.setCaretPosition(start);
-                w.textArea.moveCaretPosition(end);
-                try {
-                    w.show();
-                    db.requestFocus();
-                    w.requestFocus();
-                    w.textArea.requestFocus();
-                } catch (Exception exc) {
-                }
-            }
-        }
-    }
-
-    class MouseHandler extends MouseAdapter {
-        public void mouseClicked(MouseEvent e) {
-            if (e.getClickCount() == 2) {
-                setButton.doClick();
-            }
-        }
-    };
-
-    FindFunction(Main db, Hashtable functionNames,
-                 String title,
-                 String labelText) {
-        super(db, title, true);
-        this.functionNames = functionNames;
-        this.db = db;
-
-        cancelButton = new JButton("Cancel");
-        setButton = new JButton("Select");
-        cancelButton.addActionListener(this);
-        setButton.addActionListener(this);
-        getRootPane().setDefaultButton(setButton);
-
-        list = new JList(new DefaultListModel());
-        DefaultListModel model = (DefaultListModel)list.getModel();
-        model.clear();
-
-        Enumeration e = functionNames.keys();
-        String[] a = new String[functionNames.size()];
-        int i = 0;
-        while (e.hasMoreElements()) {
-            a[i++] = e.nextElement().toString();
-        }
-        java.util.Arrays.sort(a);
-        for (i = 0; i < a.length; i++) {
-            model.addElement(a[i]);
-        }
-        list.setSelectedIndex(0);
-
-        setButton.setEnabled(a.length > 0);
-        list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
-        list.addMouseListener(new MouseHandler());
-        JScrollPane listScroller = new JScrollPane(list);
-        listScroller.setPreferredSize(new Dimension(320, 240));
-        listScroller.setMinimumSize(new Dimension(250, 80));
-        listScroller.setAlignmentX(LEFT_ALIGNMENT);
-
-        //Create a container so that we can add a title around
-        //the scroll pane.  Can't add a title directly to the
-        //scroll pane because its background would be white.
-        //Lay out the label and scroll pane from top to button.
-        JPanel listPane = new JPanel();
-        listPane.setLayout(new BoxLayout(listPane, BoxLayout.Y_AXIS));
-        JLabel label = new JLabel(labelText);
-        label.setLabelFor (list);
-        listPane.add(label);
-        listPane.add(Box.createRigidArea(new Dimension(0,5)));
-        listPane.add(listScroller);
-        listPane.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
-
-        //Lay out the buttons from left to right.
-        JPanel buttonPane = new JPanel();
-        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.X_AXIS));
-        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
-        buttonPane.add(Box.createHorizontalGlue());
-        buttonPane.add(cancelButton);
-        buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));
-        buttonPane.add(setButton);
-
-        //Put everything together, using the content pane's BorderLayout.
-        Container contentPane = getContentPane();
-        contentPane.add(listPane, BorderLayout.CENTER);
-        contentPane.add(buttonPane, BorderLayout.SOUTH);
-        pack();
-        addKeyListener(new KeyAdapter() {
-                public void keyPressed(KeyEvent ke) {
-                    int code = ke.getKeyCode();
-                    if (code == KeyEvent.VK_ESCAPE) {
-                        ke.consume();
-                        value = null;
-                        setVisible(false);
-                    }
-                }
-            });
-    }
-};
-
-class FileHeader extends JPanel implements MouseListener {
-
-    FileWindow fileWindow;
-
-    public void mouseEntered(MouseEvent e) {
-    }
-    public void mousePressed(MouseEvent e) {
-    }
-    public void mouseClicked(MouseEvent e) {
-        if (e.getComponent() == this &&
-          (e.getModifiers() & MouseEvent.BUTTON1_MASK) != 0) {
-            int x = e.getX();
-            int y = e.getY();
-            Font font = fileWindow.textArea.getFont();
-            FontMetrics metrics = getFontMetrics(font);
-            int h = metrics.getHeight();
-            int line = y/h;
-            fileWindow.toggleBreakPoint(line + 1);
-        }
-    }
-    public void mouseExited(MouseEvent e) {
-    }
-    public void mouseReleased(MouseEvent e) {
-    }
-
-    FileHeader(FileWindow fileWindow) {
-        this.fileWindow = fileWindow;
-        addMouseListener(this);
-        update();
-    }
-
-    void update() {
-        FileTextArea textArea = fileWindow.textArea;
-        Font font = textArea.getFont();
-        setFont(font);
-        FontMetrics metrics = getFontMetrics(font);
-        int h = metrics.getHeight();
-        int lineCount = textArea.getLineCount() + 1;
-        String dummy = Integer.toString(lineCount);
-        if (dummy.length() < 2) {
-            dummy = "99";
-        }
-        Dimension d = new Dimension();
-        d.width = metrics.stringWidth(dummy) + 16;
-        d.height = lineCount * h + 100;
-        setPreferredSize(d);
-        setSize(d);
-    }
-
-    public void paint(Graphics g) {
-        super.paint(g);
-        FileTextArea textArea = fileWindow.textArea;
-        Font font = textArea.getFont();
-        g.setFont(font);
-        FontMetrics metrics = getFontMetrics(font);
-        Rectangle clip = g.getClipBounds();
-        g.setColor(getBackground());
-        g.fillRect(clip.x, clip.y, clip.width, clip.height);
-        int left = getX();
-        int ascent = metrics.getMaxAscent();
-        int h = metrics.getHeight();
-        int lineCount = textArea.getLineCount() + 1;
-        String dummy = Integer.toString(lineCount);
-        if (dummy.length() < 2) {
-            dummy = "99";
-        }
-
-        int maxWidth = metrics.stringWidth(dummy);
-        int startLine = clip.y / h;
-        int endLine = (clip.y + clip.height) / h + 1;
-        int width = getWidth();
-        if (endLine > lineCount) endLine = lineCount;
-        for (int i = startLine; i < endLine; i++) {
-            String text;
-            int pos = -2;
-            try {
-                pos = textArea.getLineStartOffset(i);
-            } catch (BadLocationException ignored) {
-            }
-            boolean isBreakPoint = fileWindow.isBreakPoint(i + 1);
-            text = Integer.toString(i + 1) + " ";
-            int w = metrics.stringWidth(text);
-            int y = i * h;
-            g.setColor(Color.blue);
-            g.drawString(text, 0, y + ascent);
-            int x = width - ascent;
-            if (isBreakPoint) {
-                g.setColor(new Color(0x80, 0x00, 0x00));
-                int dy = y + ascent - 9;
-                g.fillOval(x, dy, 9, 9);
-                g.drawOval(x, dy, 8, 8);
-                g.drawOval(x, dy, 9, 9);
-            }
-            if (pos == fileWindow.currentPos) {
-                Polygon arrow = new Polygon();
-                int dx = x;
-                y += ascent - 10;
-                int dy = y;
-                arrow.addPoint(dx, dy + 3);
-                arrow.addPoint(dx + 5, dy + 3);
-                for (x = dx + 5; x <= dx + 10; x++, y++) {
-                    arrow.addPoint(x, y);
-                }
-                for (x = dx + 9; x >= dx + 5; x--, y++) {
-                    arrow.addPoint(x, y);
-                }
-                arrow.addPoint(dx + 5, dy + 7);
-                arrow.addPoint(dx, dy + 7);
-                g.setColor(Color.yellow);
-                g.fillPolygon(arrow);
-                g.setColor(Color.black);
-                g.drawPolygon(arrow);
-            }
-        }
-    }
-};
-
-class FileWindow extends JInternalFrame
-    implements ActionListener, DocumentListener {
-
-    Main db;
-    SourceInfo sourceInfo;
-    FileTextArea textArea;
-    FileHeader fileHeader;
-    JScrollPane p;
-    int currentPos;
-    JLabel statusBar;
-    boolean isModified = false;
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        if (cmd.equals("Cut")) {
-            textArea.cut();
-        } else if (cmd.equals("Copy")) {
-            textArea.copy();
-        } else if (cmd.equals("Paste")) {
-            textArea.paste();
-        }
-    }
-
-    void runToCursor(ActionEvent e) {
-        try {
-            db.runToCursor(getUrl(),
-                           textArea.getLineOfOffset(textArea.getCaretPosition()) + 1,
-                           e);
-        } catch (BadLocationException exc) {
-        }
-    }
-
-    void load() {
-        //Scriptable scope = db.getScope();
-        Scriptable scope = db.officeScripts.getScriptScope( getUrl() );
-        if ( scope == null )
-        {
-            scope = db.getScope();
-        }
-        
-        if (scope == null) {
-            MessageDialogWrapper.showMessageDialog(db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
-        } else {
-            String url = getUrl();
-            if (url != null) {
-                new Thread(new LoadFile(db,scope, url, new StringReader(textArea.getText()))).start(); 
-            }
-        }
-    }
-
-    void save() {
-        if (getUrl() != null) {
-            OutputStream os = null;
-            try {
-                if ( getUrl().startsWith("vnd.sun.star")  )
-                {
-                    URL scriptUrl = db.officeScripts.getScriptUrl( getUrl() );
-                    if ( scriptUrl == null )
-                    {
-                        throw new IOException("Can't optain stream for " + getUrl() );
-                    }
-                    os = scriptUrl.openConnection().getOutputStream();
-                }
-                else
-                {
-                   os = new FileOutputStream( getUrl() );
-                }
-                String s = textArea.getText();
-                os.write(s.getBytes(), 0, s.length());
-
-                this.isModified = false;
-            }
-            catch (IOException ioe) {
-                JOptionPane.showMessageDialog(this,
-                    "Error saving file: " + ioe.getMessage(),
-                    "Error", JOptionPane.ERROR_MESSAGE);
-            }
-            finally
-            {
-                if ( os != null )
-                {
-                    try
-                    {
-                        os.close();
-                        os = null;
-                    }
-                    catch( IOException ioe )
-                    {
-                        System.err.println("Error closing stream: " + ioe.getMessage() );
-                        ioe.printStackTrace();
-                    }
-                }
-            }
-        }
-    }
-
-    public boolean isEditable() {
-        return db.isSourceEditingEnabled();
-    }
-
-   public int getPosition(int line) {
-        int result = -1;
-        try {
-            result = textArea.getLineStartOffset(line);
-        } catch (javax.swing.text.BadLocationException exc) {
-        }
-        return result;
-    }
-
-    boolean isBreakPoint(int line) {
-        return sourceInfo.hasBreakpoint(line);
-    }
-
-    void toggleBreakPoint(int line) {
-        if (!isBreakPoint(line)) {
-            setBreakPoint(line);
-        } else {
-            clearBreakPoint(line);
-        }
-    }
-
-    void setBreakPoint(int line) {
-        if (sourceInfo.placeBreakpoint(line)) {
-            fileHeader.repaint();
-        }
-    }
-
-    void clearBreakPoint(int line) {
-        if (sourceInfo.removeBreakpoint(line)) {
-            fileHeader.repaint();
-        }
-    }
-    public Main getDB() { return db; }
-    FileWindow(Main db, SourceInfo sourceInfo) {
-        super(SourceInfo.getShortName(sourceInfo.getUrl()),
-              true, true, true, true);
-        this.db = db;
-        this.sourceInfo = sourceInfo;
-        updateToolTip();
-        currentPos = -1;
-        textArea = new FileTextArea(this);
-        textArea.setRows(24);
-        textArea.setColumns(80);
-        p = new JScrollPane();
-        fileHeader = new FileHeader(this);
-        p.setViewportView(textArea);
-        p.setRowHeaderView(fileHeader);
-        setContentPane(p);
-        pack();
-        updateText();
-        textArea.select(0);
-        addInternalFrameListener( new InternalFrameAdapter() {
-            public void internalFrameClosed(InternalFrameEvent e) {
-                    // clean up scriptItems and sourceNames hashes
-                    getDB().removeScript( getUrl() );
-                    // remove scripts for officeScripts
-                    getDB().officeScripts.deleteScript( getUrl() );
-                }
-            } );
-                
-
-    }
-
-    private void updateToolTip() {
-        // in case fileName is very long, try to set tool tip on frame
-        Component c = getComponent(1);
-        // this will work at least for Metal L&F
-        if (c != null && c instanceof JComponent) {
-            ((JComponent)c).setToolTipText(getUrl());
-        }
-    }
-
-    public String getUrl() {
-        return sourceInfo.getUrl();
-    }
-
-    void updateText() {
-        String newText = sourceInfo.getSource();
-        if (!textArea.getText().equals(newText)) {
-            textArea.getDocument().removeDocumentListener(this);
-            textArea.setText(newText);
-            this.isModified = false;
-            textArea.getDocument().addDocumentListener(this);
-            int pos = 0;
-            if (currentPos != -1) {
-                pos = currentPos;
-            }
-            textArea.select(pos);
-        }
-        fileHeader.update();
-        fileHeader.repaint();
-    }
-
-    /* Implementation of DocumentListener interface */
-    public void insertUpdate(DocumentEvent e) {
-        doChanged(e);
-    }
-
-    public void removeUpdate(DocumentEvent e) {
-        doChanged(e);
-    }
-
-    public void changedUpdate(DocumentEvent e) {
-        doChanged(e);
-    }
-
-    public void doChanged(DocumentEvent e) {
-        this.isModified = true;
-    }
-
-    public boolean isModified() {
-        return this.isModified;
-    }
-
-    public String getText() {
-        return textArea.getText();
-    }
-
-    void setPosition(int pos) {
-        textArea.select(pos);
-        currentPos = pos;
-        fileHeader.repaint();
-    }
-
-    void select(int start, int end) {
-        int docEnd = textArea.getDocument().getLength();
-        textArea.select(docEnd, docEnd);
-        textArea.select(start, end);
-    }
-};
-
-class MyTableModel extends AbstractTableModel {
-    Main db;
-    Vector expressions;
-    Vector values;
-    MyTableModel(Main db) {
-        this.db = db;
-        expressions = new Vector();
-        values = new Vector();
-        expressions.addElement("");
-        values.addElement("");
-    }
-
-    public int getColumnCount() {
-        return 2;
-    }
-
-    public int getRowCount() {
-        return expressions.size();
-    }
-
-    public String getColumnName(int column) {
-        switch (column) {
-        case 0:
-            return "Expression";
-        case 1:
-            return "Value";
-        }
-        return null;
-    }
-
-    public boolean isCellEditable(int row, int column) {
-        return true;
-    }
-
-    public Object getValueAt(int row, int column) {
-        switch (column) {
-        case 0:
-            return expressions.elementAt(row);
-        case 1:
-            return values.elementAt(row);
-        }
-        return "";
-    }
-
-    public void setValueAt(Object value, int row, int column) {
-        switch (column) {
-        case 0:
-            String expr = value.toString();
-            expressions.setElementAt(expr, row);
-            String result = "";
-            if (expr.length() > 0) {
-                result = db.eval(expr);
-                if (result == null) result = "";
-            }
-            values.setElementAt(result, row);
-            updateModel();
-            if (row + 1 == expressions.size()) {
-                expressions.addElement("");
-                values.addElement("");
-                fireTableRowsInserted(row + 1, row + 1);
-            }
-            break;
-        case 1:
-            // just reset column 2; ignore edits
-            fireTableDataChanged();
-        }
-    }
-
-    void updateModel() {
-        for (int i = 0; i < expressions.size(); ++i) {
-            Object value = expressions.elementAt(i);
-            String expr = value.toString();
-            String result = "";
-            if (expr.length() > 0) {
-                result = db.eval(expr);
-                if (result == null) result = "";
-            } else {
-                result = "";
-            }
-            result = result.replace('\n', ' ');
-            values.setElementAt(result, i);
-        }
-        fireTableDataChanged();
-    }
-};
-
-class Evaluator extends JTable {
-    MyTableModel tableModel;
-    Evaluator(Main db) {
-        super(new MyTableModel(db));
-        tableModel = (MyTableModel)getModel();
-    }
-}
-
-class MyTreeTable extends JTreeTable {
-
-    public MyTreeTable(TreeTableModel model) {
-        super(model);
-    }
-
-    public JTree resetTree(TreeTableModel treeTableModel) {
-        tree = new TreeTableCellRenderer(treeTableModel);
-
-        // Install a tableModel representing the visible rows in the tree.
-        super.setModel(new TreeTableModelAdapter(treeTableModel, tree));
-
-        // Force the JTable and JTree to share their row selection models.
-        ListToTreeSelectionModelWrapper selectionWrapper = new
-            ListToTreeSelectionModelWrapper();
-        tree.setSelectionModel(selectionWrapper);
-        setSelectionModel(selectionWrapper.getListSelectionModel());
-
-        // Make the tree and table row heights the same.
-        if (tree.getRowHeight() < 1) {
-            // Metal looks better like this.
-            setRowHeight(18);
-        }
-
-        // Install the tree editor renderer and editor.
-        setDefaultRenderer(TreeTableModel.class, tree);
-        setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
-        setShowGrid(true);
-        setIntercellSpacing(new Dimension(1,1));
-        tree.setRootVisible(false);
-        tree.setShowsRootHandles(true);
-        DefaultTreeCellRenderer r = (DefaultTreeCellRenderer)tree.getCellRenderer();
-        r.setOpenIcon(null);
-        r.setClosedIcon(null);
-        r.setLeafIcon(null);
-        return tree;
-    }
-
-    public boolean isCellEditable(EventObject e) {
-        if (e instanceof MouseEvent) {
-            MouseEvent me = (MouseEvent)e;
-            // If the modifiers are not 0 (or the left mouse button),
-            // tree may try and toggle the selection, and table
-            // will then try and toggle, resulting in the
-            // selection remaining the same. To avoid this, we
-            // only dispatch when the modifiers are 0 (or the left mouse
-            // button).
-            if (me.getModifiers() == 0 ||
-                ((me.getModifiers() & (InputEvent.BUTTON1_MASK|1024)) != 0 &&
-                 (me.getModifiers() &
-                  (InputEvent.SHIFT_MASK |
-                   InputEvent.CTRL_MASK |
-                   InputEvent.ALT_MASK |
-                   InputEvent.BUTTON2_MASK |
-                   InputEvent.BUTTON3_MASK |
-                   64   | //SHIFT_DOWN_MASK
-                   128  | //CTRL_DOWN_MASK
-                   512  | // ALT_DOWN_MASK
-                   2048 | //BUTTON2_DOWN_MASK
-                   4096   //BUTTON3_DOWN_MASK
-                   )) == 0)) {
-                int row = rowAtPoint(me.getPoint());
-                for (int counter = getColumnCount() - 1; counter >= 0;
-                     counter--) {
-                    if (TreeTableModel.class == getColumnClass(counter)) {
-                        MouseEvent newME = new MouseEvent
-                            (MyTreeTable.this.tree, me.getID(),
-                             me.getWhen(), me.getModifiers(),
-                             me.getX() - getCellRect(row, counter, true).x,
-                             me.getY(), me.getClickCount(),
-                             me.isPopupTrigger());
-                        MyTreeTable.this.tree.dispatchEvent(newME);
-                        break;
-                    }
-                }
-            }
-            if (me.getClickCount() >= 3) {
-                return true;
-            }
-            return false;
-        }
-        if (e == null) {
-            return true;
-        }
-        return false;
-    }
-};
-
-class ContextWindow extends JPanel implements ActionListener {
-    JComboBox context;
-    Vector toolTips;
-    JTabbedPane tabs;
-    JTabbedPane tabs2;
-    MyTreeTable thisTable;
-    MyTreeTable localsTable;
-    VariableModel model;
-    MyTableModel tableModel;
-    Evaluator evaluator;
-    EvalTextArea cmdLine;
-    JSplitPane split;
-    Main db;
-    boolean enabled;
-    ContextWindow(Main db) {
-        super();
-        this.db = db;
-        enabled = false;
-        JPanel left = new JPanel();
-        JToolBar t1 = new JToolBar();
-        t1.setName("Variables");
-        t1.setLayout(new GridLayout());
-        t1.add(left);
-        JPanel p1 = new JPanel();
-        p1.setLayout(new GridLayout());
-        JPanel p2 = new JPanel();
-        p2.setLayout(new GridLayout());
-        p1.add(t1);
-        JLabel label = new JLabel("Context:");
-        context = new JComboBox();
-        context.setLightWeightPopupEnabled(false);
-        toolTips = new java.util.Vector();
-        label.setBorder(context.getBorder());
-        context.addActionListener(this);
-        context.setActionCommand("ContextSwitch");
-        GridBagLayout layout = new GridBagLayout();
-        left.setLayout(layout);
-        GridBagConstraints lc = new GridBagConstraints();
-        lc.insets.left = 5;
-        lc.anchor = GridBagConstraints.WEST;
-        lc.ipadx = 5;
-        layout.setConstraints(label, lc);
-        left.add(label);
-        GridBagConstraints c = new GridBagConstraints();
-        c.gridwidth = GridBagConstraints.REMAINDER;
-        c.fill = GridBagConstraints.HORIZONTAL;
-        c.anchor = GridBagConstraints.WEST;
-        layout.setConstraints(context, c);
-        left.add(context);
-        tabs = new JTabbedPane(SwingConstants.BOTTOM);
-        tabs.setPreferredSize(new Dimension(500,300));
-        thisTable = new MyTreeTable(new AbstractTreeTableModel(new DefaultMutableTreeNode()) {
-                public Object getChild(Object parent, int index) {
-                    return null;
-                }
-                public int getChildCount(Object parent) {
-                    return 0;
-                }
-                public int getColumnCount() {
-                    //return 3;
-                    return 2;
-                }
-                public String getColumnName(int column) {
-                    switch (column) {
-                    case 0:
-                        return " Name";
-                    case 1:
-                        //return "Type";
-                        //case 2:
-                        return " Value";
-                    }
-                    return null;
-                }
-                public Object getValueAt(Object node, int column) {
-                    return null;
-                }
-            });
-        JScrollPane jsp = new JScrollPane(thisTable);
-        jsp.getViewport().setViewSize(new Dimension(5,2));
-        tabs.add("this", jsp);
-        localsTable = new MyTreeTable(new AbstractTreeTableModel(new DefaultMutableTreeNode()) {
-                public Object getChild(Object parent, int index) {
-                    return null;
-                }
-                public int getChildCount(Object parent) {
-                    return 0;
-                }
-                public int getColumnCount() {
-                    return 2;
-                }
-                public String getColumnName(int column) {
-                    switch (column) {
-                    case 0:
-                        return " Name";
-                    case 1:
-                        return " Value";
-                    }
-                    return null;
-                }
-                public Object getValueAt(Object node, int column) {
-                    return null;
-                }
-            });
-        localsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
-        localsTable.setPreferredSize(null);
-        jsp = new JScrollPane(localsTable);
-        tabs.add("Locals", jsp);
-        c.weightx  = c.weighty = 1;
-        c.gridheight = GridBagConstraints.REMAINDER;
-        c.fill = GridBagConstraints.BOTH;
-        c.anchor = GridBagConstraints.WEST;
-        layout.setConstraints(tabs, c);
-        left.add(tabs);
-        evaluator = new Evaluator(db);
-        cmdLine = new EvalTextArea(db);
-        //cmdLine.requestFocus();
-        tableModel = evaluator.tableModel;
-        jsp = new JScrollPane(evaluator);
-        JToolBar t2 = new JToolBar();
-        t2.setName("Evaluate");
-        tabs2 = new JTabbedPane(SwingConstants.BOTTOM);
-        tabs2.add("Watch", jsp);
-        tabs2.add("Evaluate", new JScrollPane(cmdLine));
-        tabs2.setPreferredSize(new Dimension(500,300));
-        t2.setLayout(new GridLayout());
-        t2.add(tabs2);
-        p2.add(t2);
-        evaluator.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
-        split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
-                               p1, p2);
-        split.setOneTouchExpandable(true);
-        Main.setResizeWeight(split, 0.5);
-        setLayout(new BorderLayout());
-        add(split, BorderLayout.CENTER);
-
-        final JToolBar finalT1 = t1;
-        final JToolBar finalT2 = t2;
-        final JPanel finalP1 = p1;
-        final JPanel finalP2 = p2;
-        final JSplitPane finalSplit = split;
-        final JPanel finalThis = this;
-        final Main finalDb = db;
-
-        ComponentListener clistener = new ComponentListener() {
-                boolean t1Docked = true;
-                boolean t2Docked = true;
-                void check(Component comp) {
-                    Component thisParent = finalThis.getParent();
-                    if (thisParent == null) {
-                        return;
-                    }
-                    Component parent = finalT1.getParent();
-                    boolean leftDocked = true;
-                    boolean rightDocked = true;
-                    boolean adjustVerticalSplit = false;
-                    if (parent != null) {
-                        if (parent != finalP1) {
-                            while (!(parent instanceof JFrame)) {
-                                parent = parent.getParent();
-                            }
-                            JFrame frame = (JFrame)parent;
-                            finalDb.addTopLevel("Variables", frame);
-
-                            // We need the following hacks because:
-                            // - We want an undocked toolbar to be
-                            //   resizable.
-                            // - We are using JToolbar as a container of a
-                            //   JComboBox. Without this JComboBox's popup
-                            //   can get left floating when the toolbar is
-                            //   re-docked.
-                            //
-                            // We make the frame resizable and then
-                            // remove JToolbar's window listener
-                            // and insert one of our own that first ensures
-                            // the JComboBox's popup window is closed
-                            // and then calls JToolbar's window listener.
-                            if (!frame.isResizable()) {
-                                frame.setResizable(true);
-                                frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
-                                final EventListener[] l =
-                                    frame.getListeners(WindowListener.class);
-                                frame.removeWindowListener((WindowListener)l[0]);
-                                frame.addWindowListener(new WindowAdapter() {
-                                        public void windowClosing(WindowEvent e) {
-                                            context.hidePopup();
-                                            ((WindowListener)l[0]).windowClosing(e);
-                                        }
-                                    });
-                                //adjustVerticalSplit = true;
-                            }
-                            leftDocked = false;
-                        } else {
-                            leftDocked = true;
-                        }
-                    }
-                    parent = finalT2.getParent();
-                    if (parent != null) {
-                        if (parent != finalP2) {
-                            while (!(parent instanceof JFrame)) {
-                                parent = parent.getParent();
-                            }
-                            JFrame frame = (JFrame)parent;
-                            finalDb.addTopLevel("Evaluate", frame);
-                            frame.setResizable(true);
-                            rightDocked = false;
-                        } else {
-                            rightDocked = true;
-                        }
-                    }
-                    if (leftDocked && t2Docked && rightDocked && t2Docked) {
-                        // no change
-                        return;
-                    }
-                    t1Docked = leftDocked;
-                    t2Docked = rightDocked;
-                    JSplitPane split = (JSplitPane)thisParent;
-                    if (leftDocked) {
-                        if (rightDocked) {
-                            finalSplit.setDividerLocation(0.5);
-                        } else {
-                            finalSplit.setDividerLocation(1.0);
-                        }
-                        if (adjustVerticalSplit) {
-                            split.setDividerLocation(0.66);
-                        }
-
-                    } else if (rightDocked) {
-                            finalSplit.setDividerLocation(0.0);
-                            split.setDividerLocation(0.66);
-                    } else {
-                        // both undocked
-                        split.setDividerLocation(1.0);
-                    }
-                }
-                public void componentHidden(ComponentEvent e) {
-                    check(e.getComponent());
-                }
-                public void componentMoved(ComponentEvent e) {
-                    check(e.getComponent());
-                }
-                public void componentResized(ComponentEvent e) {
-                    check(e.getComponent());
-                }
-                public void componentShown(ComponentEvent e) {
-                    check(e.getComponent());
-                }
-            };
-        p1.addContainerListener(new ContainerListener() {
-            public void componentAdded(ContainerEvent e) {
-                Component thisParent = finalThis.getParent();
-                JSplitPane split = (JSplitPane)thisParent;
-                if (e.getChild() == finalT1) {
-                    if (finalT2.getParent() == finalP2) {
-                        // both docked
-                        finalSplit.setDividerLocation(0.5);
-                    } else {
-                        // left docked only
-                        finalSplit.setDividerLocation(1.0);
-                    }
-                    split.setDividerLocation(0.66);
-                }
-            }
-            public void componentRemoved(ContainerEvent e) {
-                Component thisParent = finalThis.getParent();
-                JSplitPane split = (JSplitPane)thisParent;
-                if (e.getChild() == finalT1) {
-                    if (finalT2.getParent() == finalP2) {
-                        // right docked only
-                        finalSplit.setDividerLocation(0.0);
-                        split.setDividerLocation(0.66);
-                    } else {
-                        // both undocked
-                        split.setDividerLocation(1.0);
-                    }
-                }
-            }
-            });
-        t1.addComponentListener(clistener);
-        t2.addComponentListener(clistener);
-        disable();
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        if (!enabled) return;
-        if (e.getActionCommand().equals("ContextSwitch")) {
-            ContextHelper helper = new ContextHelper();
-            Context cx = db.getCurrentContext();
-            ContextData contextData = ContextData.get(cx);
-            helper.attach(cx);
-            int frameIndex = context.getSelectedIndex();
-            context.setToolTipText(toolTips.elementAt(frameIndex).toString());
-            Scriptable obj;
-            int frameCount = contextData.getFrameCount();
-            if (frameIndex < frameCount) {
-                FrameHelper frame = contextData.getFrame(frameIndex);
-                obj = frame.getVariableObject();
-            } else {
-                helper.reset();
-                return;
-            }
-            NativeCall call = null;
-            if (obj instanceof NativeCall) {
-                call = (NativeCall)obj;
-                obj = call.getThisObj();
-            }
-            JTree tree = thisTable.resetTree(model = new VariableModel(obj));
-
-            if (call == null) {
-                tree = localsTable.resetTree(new AbstractTreeTableModel(new DefaultMutableTreeNode()) {
-                        public Object getChild(Object parent, int index) {
-                            return null;
-                        }
-                        public int getChildCount(Object parent) {
-                            return 0;
-                        }
-                        public int getColumnCount() {
-                            return 2;
-                        }
-                        public String getColumnName(int column) {
-                            switch (column) {
-                            case 0:
-                                return " Name";
-                            case 1:
-                                return " Value";
-                            }
-                            return null;
-                        }
-                        public Object getValueAt(Object node, int column) {
-                            return null;
-                        }
-                    });
-            } else {
-                tree = localsTable.resetTree(model = new VariableModel(call));
-            }
-            helper.reset();
-            db.contextSwitch (frameIndex);
-            tableModel.updateModel();
-        }
-    }
-
-    public void disable() {
-        context.setEnabled(false);
-        thisTable.setEnabled(false);
-        localsTable.setEnabled(false);
-        evaluator.setEnabled(false);
-        cmdLine.setEnabled(false);
-    }
-
-    public void enable() {
-        context.setEnabled(true);
-        thisTable.setEnabled(true);
-        localsTable.setEnabled(true);
-        evaluator.setEnabled(true);
-        cmdLine.setEnabled(true);
-    }
-
-    public void disableUpdate() {
-        enabled = false;
-    }
-
-    public void enableUpdate() {
-        enabled = true;
-    }
-};
-
-class CreateFileWindow implements Runnable {
-
-    Main db;
-    SourceInfo sourceInfo;
-    int line;
-    boolean activate;
-
-    private CreateFileWindow() { }
-
-    static Runnable action(Main db, SourceInfo sourceInfo, int line) {
-        CreateFileWindow obj = new CreateFileWindow();
-        obj.db = db;
-        obj.sourceInfo = sourceInfo;
-        obj.line = line;
-        obj.activate = true;
-        return obj;
-    }
-
-    static Runnable action(Main db,
-                           SourceInfo sourceInfo, int line, boolean activate)
-    {
-        CreateFileWindow obj = new CreateFileWindow();
-        obj.db = db;
-        obj.sourceInfo = sourceInfo;
-        obj.line = line;
-        obj.activate = activate;
-        return obj;
-    }
-
-    public void run() {
-        String url = sourceInfo.getUrl();
-        FileWindow w = new FileWindow(db, sourceInfo);
-        db.fileWindows.put(url, w);
-        if (line != -1) {
-            if (db.currentWindow != null) {
-                db.currentWindow.setPosition(-1);
-            }
-            try {
-                w.setPosition(w.textArea.getLineStartOffset(line-1));
-            } catch (BadLocationException exc) {
-                try {
-                    w.setPosition(w.textArea.getLineStartOffset(0));
-                } catch (BadLocationException ee) {
-                    w.setPosition(-1);
-                }
-            }
-        }
-        db.desk.add(w);
-        if (line != -1) {
-            db.currentWindow = w;
-        }
-        // db.menubar.addFile(url);
-        w.setVisible(true);
-        if (activate) {
-            try {
-                w.setMaximum(true);
-                w.setSelected(true);
-                w.moveToFront();
-            } catch (Exception exc) {
-            }
-        }
-    }
-}
-
-class SetFilePosition implements Runnable {
-
-    Main db;
-    FileWindow w;
-    int line;
-    boolean activate;
-
-    SetFilePosition(Main db, FileWindow w, int line) {
-        this.db = db;
-        this.w = w;
-        this.line = line;
-        activate = true;
-    }
-
-    SetFilePosition(Main db, FileWindow w, int line, boolean activate) {
-        this.db = db;
-        this.w = w;
-        this.line = line;
-        this.activate = activate;
-    }
-
-    public void run() {
-        JTextArea ta = w.textArea;
-        try {
-            if (line == -1) {
-                w.setPosition(-1);
-                if (db.currentWindow == w) {
-                    db.currentWindow = null;
-                }
-            } else {
-                int loc = ta.getLineStartOffset(line-1);
-                if (db.currentWindow != null && db.currentWindow != w) {
-                    db.currentWindow.setPosition(-1);
-                }
-                w.setPosition(loc);
-                db.currentWindow = w;
-            }
-        } catch (BadLocationException exc) {
-            // fix me
-        }
-        if (activate) {
-            if (w.isIcon()) {
-                db.desk.getDesktopManager().deiconifyFrame(w);
-            }
-            db.desk.getDesktopManager().activateFrame(w);
-            try {
-                w.show();
-                w.toFront();  // required for correct frame layering (JDK 1.4.1)
-                w.setSelected(true);
-            } catch (Exception exc) {
-            }
-        }
-    }
-}
-
-class UpdateFileText implements Runnable {
-
-    private FileWindow w;
-
-    private UpdateFileText() {}
-
-    static Runnable action(FileWindow w) {
-        UpdateFileText obj = new UpdateFileText();
-        obj.w = w;
-        return obj;
-    }
-
-    public void run() {
-        w.updateText();
-    }
-}
-
-class UpdateContext implements Runnable {
-    Main db;
-    ContextData contextData;
-    UpdateContext(Main db, Context cx) {
-        this.db = db;
-        this.contextData = ContextData.get(cx);
-    }
-
-    public void run() {
-        db.context.enable();
-        JComboBox ctx = db.context.context;
-        Vector toolTips = db.context.toolTips;
-        db.context.disableUpdate();
-        int frameCount = contextData.getFrameCount();
-        ctx.removeAllItems();
-        // workaround for JDK 1.4 bug that caches selected value even after
-        // removeAllItems() is called
-        ctx.setSelectedItem(null);
-        toolTips.removeAllElements();
-        for (int i = 0; i < frameCount; i++) {
-            FrameHelper frame = contextData.getFrame(i);
-            String url = frame.getUrl();
-            int lineNumber = frame.getLineNumber();
-            String shortName = url;
-            if (url.length() > 20) {
-                shortName = "..." + url.substring(url.length() - 17);
-            }
-            String location = "\"" + shortName + "\", line " + lineNumber;
-            ctx.insertItemAt(location, i);
-            location = "\"" + url + "\", line " + lineNumber;
-            toolTips.addElement(location);
-        }
-        db.context.enableUpdate();
-        if (frameCount != 0) {
-            ctx.setSelectedIndex(0);
-        }
-        ctx.setMinimumSize(new Dimension(50, ctx.getMinimumSize().height));
-    }
-};
-
-class Menubar extends JMenuBar implements ActionListener {
-
-    JMenu getDebugMenu() {
-        return getMenu(2);
-    }
-
-    Menubar(Main db) {
-        super();
-        this.db = db;
-        // String[] fileItems  = {"Open...", "Run...", "", "Exit"};
-        // String[] fileCmds  = {"Open", "Load", "", "Exit"};
-        String[] fileItems  = {"Run", "Save", "", "Exit"};
-        String[] fileCmds  = {"Run", "Save", "", "Exit"};
-        char[] fileShortCuts = {'0', 'N', '\0', 'X'};
-        int[] fileAccelerators = {KeyEvent.VK_O,
-                                  KeyEvent.VK_N,
-                                  0,
-                                  KeyEvent.VK_Q};
-        String[] editItems = {"Cut", "Copy", "Paste", "Go to function..."};
-        char[] editShortCuts = {'T', 'C', 'P', 'F'};
-        String[] debugItems = {"Break", "Go", "Step Into", "Step Over", "Step Out"};
-        char[] debugShortCuts = {'B', 'G', 'I', 'O', 'T'};
-        String[] plafItems = {"Metal", "Windows", "Motif"};
-        char [] plafShortCuts = {'M', 'W', 'F'};
-        int[] debugAccelerators = {KeyEvent.VK_PAUSE,
-                                   KeyEvent.VK_F5,
-                                   KeyEvent.VK_F11,
-                                   KeyEvent.VK_F7,
-                                   KeyEvent.VK_F8,
-                                   0, 0};
-
-        JMenu fileMenu = new JMenu("File");
-        fileMenu.setMnemonic('F');
-        JMenu editMenu = new JMenu("Edit");
-        editMenu.setMnemonic('E');
-        JMenu plafMenu = new JMenu("Platform");
-        plafMenu.setMnemonic('P');
-        JMenu debugMenu = new JMenu("Debug");
-        debugMenu.setMnemonic('D');
-        windowMenu = new JMenu("Window");
-        windowMenu.setMnemonic('W');
-        for (int i = 0; i < fileItems.length; ++i) {
-            if (fileItems[i].length() == 0) {
-                fileMenu.addSeparator();
-            } else {
-                JMenuItem item = new JMenuItem(fileItems[i],
-                                               fileShortCuts[i]);
-                item.setActionCommand(fileCmds[i]);
-                item.addActionListener(this);
-                fileMenu.add(item);
-                if (fileAccelerators[i] != 0) {
-                    KeyStroke k = KeyStroke.getKeyStroke(fileAccelerators[i], Event.CTRL_MASK);
-                    item.setAccelerator(k);
-                }
-                if (fileItems[i].equals("Save")) {
-                    saveItem = item;
-                }
-            }
-        }
-        for (int i = 0; i < editItems.length; ++i) {
-            JMenuItem item = new JMenuItem(editItems[i],
-                                           editShortCuts[i]);
-            item.addActionListener(this);
-            editMenu.add(item);
-        }
-        for (int i = 0; i < plafItems.length; ++i) {
-            JMenuItem item = new JMenuItem(plafItems[i],
-                                           plafShortCuts[i]);
-            item.addActionListener(this);
-            plafMenu.add(item);
-        }
-        for (int i = 0; i < debugItems.length; ++i) {
-            JMenuItem item = new JMenuItem(debugItems[i],
-                                           debugShortCuts[i]);
-            item.addActionListener(this);
-            if (debugAccelerators[i] != 0) {
-                KeyStroke k = KeyStroke.getKeyStroke(debugAccelerators[i], 0);
-                item.setAccelerator(k);
-            }
-            if (i != 0) {
-                item.setEnabled(false);
-            }
-            debugMenu.add(item);
-        }
-        breakOnExceptions = new JCheckBoxMenuItem("Break on Exceptions");
-        breakOnExceptions.setMnemonic('X');
-        breakOnExceptions.addActionListener(this);
-        breakOnExceptions.setSelected(false);
-        debugMenu.add(breakOnExceptions);
-
-        breakOnEnter = new JCheckBoxMenuItem("Break on Function Enter");
-        breakOnEnter.setMnemonic('E');
-        breakOnEnter.addActionListener(this);
-        breakOnEnter.setSelected(false);
-        debugMenu.add(breakOnEnter);
-
-        breakOnReturn = new JCheckBoxMenuItem("Break on Function Return");
-        breakOnReturn.setMnemonic('R');
-        breakOnReturn.addActionListener(this);
-        breakOnReturn.setSelected(false);
-        debugMenu.add(breakOnReturn);
-
-        add(fileMenu);
-        add(editMenu);
-        //add(plafMenu);
-        add(debugMenu);
-        JMenuItem item;
-        windowMenu.add(item = new JMenuItem("Cascade", 'A'));
-        item.addActionListener(this);
-        windowMenu.add(item = new JMenuItem("Tile", 'T'));
-        item.addActionListener(this);
-        // windowMenu.addSeparator();
-        // windowMenu.add(item = new JMenuItem("Console", 'C'));
-        // item.addActionListener(this);
-        add(windowMenu);
-
-    }
-
-    public void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        String plaf_name = null;
-        if (cmd.equals("Metal")) {
-            plaf_name = "javax.swing.plaf.metal.MetalLookAndFeel";
-        } else if (cmd.equals("Windows")) {
-            plaf_name = "com.sun.java.swing.plaf.windows.WindowsLookAndFeel";
-        } else if (cmd.equals("Motif")) {
-            plaf_name = "com.sun.java.swing.plaf.motif.MotifLookAndFeel";
-        } else {
-            Object source = e.getSource();
-            if (source == breakOnExceptions) {
-                db.setBreakOnExceptions(breakOnExceptions.isSelected());
-            }else if (source == breakOnEnter) {
-                db.setBreakOnEnter(breakOnEnter.isSelected());
-            }else if (source == breakOnReturn) {
-                db.setBreakOnReturn(breakOnReturn.isSelected());
-            }else {
-                db.actionPerformed(e);
-            }
-               return;
-        }
-        try {
-            UIManager.setLookAndFeel(plaf_name);
-            SwingUtilities.updateComponentTreeUI(db);
-            SwingUtilities.updateComponentTreeUI(db.dlg);
-        } catch (Exception ignored) {
-            //ignored.printStackTrace();
-        }
-    }
-
-    void addFile(String url) {
-        int count = windowMenu.getItemCount();
-        JMenuItem item;
-        if (count == 4) {
-            windowMenu.addSeparator();
-            count++;
-        }
-        JMenuItem lastItem = windowMenu.getItem(count -1);
-        boolean hasMoreWin = false;
-        int maxWin = 5;
-        if (lastItem != null &&
-           lastItem.getText().equals("More Windows...")) {
-            hasMoreWin = true;
-            maxWin++;
-        }
-        if (!hasMoreWin && count - 4 == 5) {
-            windowMenu.add(item = new JMenuItem("More Windows...", 'M'));
-            item.setActionCommand("More Windows...");
-            item.addActionListener(this);
-            return;
-        } else if (count - 4 <= maxWin) {
-            if (hasMoreWin) {
-                count--;
-                windowMenu.remove(lastItem);
-            }
-            String shortName = SourceInfo.getShortName(url);
-
-            windowMenu.add(item = new JMenuItem((char)('0' + (count-4)) + " " + shortName, '0' + (count - 4)));
-            if (hasMoreWin) {
-                windowMenu.add(lastItem);
-            }
-        } else {
-            return;
-        }
-        item.setActionCommand(url);
-        item.addActionListener(this);
-    }
-
-    public void setSaveEnabled(boolean state) {
-        saveItem.setEnabled(state);
-    }
-
-    Main db;
-    JMenu windowMenu;
-    JCheckBoxMenuItem breakOnExceptions;
-    JCheckBoxMenuItem breakOnEnter;
-    JCheckBoxMenuItem breakOnReturn;
-    JMenuItem saveItem;
-};
-
-class EnterInterrupt implements Runnable {
-    Main db;
-    Context cx;
-    EnterInterrupt(Main db, Context cx) {
-        this.db = db;
-        this.cx = cx;
-    }
-    public void run() {
-        JMenu menu = db.getJMenuBar().getMenu(0);
-        //menu.getItem(0).setEnabled(false); // File->Load
-
-        // disable Edit menu Cut, Copy, Paste items
-        menu = db.getJMenuBar().getMenu(1);
-        for (int i = 0; i < 3; i++) {
-            menu.getItem(i).setEnabled(false);
-        }
-
-        menu = db.getJMenuBar().getMenu(2);
-        menu.getItem(0).setEnabled(false); // Debug->Break
-        int count = menu.getItemCount();
-        for (int i = 1; i < count; ++i) {
-            menu.getItem(i).setEnabled(true);
-        }
-        boolean b = false;
-        for (int ci = 0, cc = db.toolBar.getComponentCount(); ci < cc; ci++) {
-            db.toolBar.getComponent(ci).setEnabled(b);
-            b = true;
-        }
-        db.toolBar.setEnabled(true);
-
-        // set flag to disable source editing
-        db.setSourceEditingEnabled(false);
-
-        // raise the debugger window
-        db.toFront();
-    }
-};
-
-class ExitInterrupt implements Runnable {
-    Main db;
-    ExitInterrupt(Main db) {
-        this.db = db;
-    }
-    public void run() {
-        JMenu menu = db.getJMenuBar().getMenu(0);
-        menu.getItem(0).setEnabled(true); // File->Load
-
-        // enable Edit menu items
-        menu = db.getJMenuBar().getMenu(1);
-        for (int i = 0; i < 3; i++) {
-            menu.getItem(i).setEnabled(true);
-        }
-
-        menu = db.getJMenuBar().getMenu(2);
-        menu.getItem(0).setEnabled(true); // Debug->Break
-        int count = menu.getItemCount() - 1;
-        int i = 1;
-        for (; i < count; ++i) {
-            menu.getItem(i).setEnabled(false);
-        }
-        db.context.disable();
-        boolean b = true;
-        for (int ci = 0, cc = db.toolBar.getComponentCount(); ci < cc; ci++) {
-            db.toolBar.getComponent(ci).setEnabled(b);
-            b = false;
-        }
-        // set flag to enable source editing
-        db.setSourceEditingEnabled(true);
-
-        //db.console.consoleTextArea.requestFocus();
-    }
-};
-
-class OpenFile implements Runnable {
-    Scriptable scope;
-    String fileName;
-    Main db;
-    Reader reader = null;
-
-    OpenFile(Main db, Scriptable scope, String fileName) {
-        this.scope = scope;
-        this.fileName = fileName;
-        this.db = db;
-    }
-    OpenFile(Main db, Scriptable scope, String fileName, Reader reader) {
-        this(db, scope, fileName);
-        this.reader = reader;
-    }
-    public void run() {
-        Context cx = Context.enter();
-        ContextData contextData = ContextData.get(cx);
-        contextData.breakNextLine = true;
-        try {
-            cx.compileReader(scope,
-                reader == null ? new FileReader(fileName) : reader,
-                fileName, 1, null);
-        } catch (Exception exc) {
-            String msg = exc.getMessage();
-            if (exc instanceof EcmaError) {
-                EcmaError err = (EcmaError)exc;
-                msg = err.getSourceName() + ", line " + err.getLineNumber() + ": " + msg;
-            }
-            MessageDialogWrapper.showMessageDialog(db,
-                                                   msg,
-                                                   "Error Compiling File",
-                                                   JOptionPane.ERROR_MESSAGE);
-        } finally {
-            cx.exit();
-        }
-    }
-}
-
-class LoadFile implements Runnable {
-    Scriptable scope;
-    String fileName;
-    Main db;
-    Reader reader = null;
-    Object result = null;
-    Exception exception = null;
-    int lineNum = -1;
-    boolean sfExecute = false;
-    
-    LoadFile(Main db, Scriptable scope, String fileName) {
-        this.scope = scope;
-        this.fileName = fileName;
-        this.db = db;
-    }
-
-    LoadFile(Main db, Scriptable scope, String fileName, Reader reader) {
-        this(db, scope, fileName);
-        this.reader = reader;
-    }
-    LoadFile(Main db, Scriptable scope, String fileName, Reader reader, boolean sfExecute ) {
-        this(db, scope, fileName);
-        this.reader = reader;
-        this.sfExecute = sfExecute;
-    }
-
-    public void run() {
-        if ( db.officeScripts.isScriptRunning( fileName ) )
-        { 
-            exception = new Exception("The script is already executing");
-            if ( !sfExecute ) {
-                MessageDialogWrapper.showMessageDialog(db,
-                                                   "Script already executing",
-                                                   "Run",
-                                                   JOptionPane.ERROR_MESSAGE);
-            }
-            return;
-        } 
-        db.officeScripts.setScriptRunning( fileName, true );
-        Context cx = Context.enter();
-        ContextData contextData = ContextData.get(cx);
-        if ( sfExecute )
-        {
-            contextData.breakNextLine = false;
-        }
-        else
-        {
-            contextData.breakNextLine = true;
-        }
-        /*
-        FileWindow w = (FileWindow)db.getSelectedFrame();
-        if ( sfExecute )        
-        {
-            db.swingInvoke(new SetFilePosition(db, w, -1 ) );                
-        }*/
-        try {
-            result = cx.evaluateReader(scope,
-                reader == null ? new FileReader(fileName) : reader,
-                    fileName, 1, null);
-        } catch (Exception exc) {
-            exception = exc;
-            String msg = exc.getMessage();
-            if (exc instanceof EcmaError) {
-                EcmaError err = (EcmaError)exc;
-                msg = err.getSourceName() + ", line " + err.getLineNumber() + ": " + msg;
-    
-                int lineNum =  err.getLineNumber() ;
-                //db.swingInvoke(new SetFilePosition(db, w, lineNum ) );
-                if ( !sfExecute ) {
-                    MessageDialogWrapper.showMessageDialog(db,
-                                                   msg,
-                                                   "Run",
-                                                   JOptionPane.ERROR_MESSAGE);
-                }
-            }
-         
-        } finally {
-            db.officeScripts.setScriptRunning( fileName, false );
-            cx.exit();
-            }
-    }
-}
-
-
-class ContextHelper {
-    Context old;
-    int enterCount;
-    Context New;
-    public void attach(Context cx) {
-        old = Context.getCurrentContext();
-        enterCount = 0;
-        if (old != null) {
-            old.exit();
-            while (Context.getCurrentContext() != null) {
-                enterCount++;
-                old.exit();
-            }
-        }
-        Context.enter(cx);
-        New = cx;
-    }
-    void reset() {
-        New.exit();
-        if (old != null) {
-            if (Context.enter(old) != old) {
-                throw new RuntimeException("debugger error: failed to reset context");
-            }
-            while (enterCount > 0) {
-                Context.enter();
-                enterCount--;
-            }
-        }
-    }
-}
-
-class ContextData {
-    static ContextData get(Context cx) {
-        return (ContextData)cx.getDebuggerContextData();
-    }
-
-    int getFrameCount() {
-        return frameStack.size();
-    }
-
-    FrameHelper getFrame(int frameNumber) {
-        return (FrameHelper) frameStack.get(frameStack.size() - frameNumber - 1);
-    }
-
-    void pushFrame(FrameHelper frame) {
-        frameStack.push(frame);
-    }
-
-    void popFrame() {
-        frameStack.pop();
-    }
-
-    ObjArray frameStack = new ObjArray();
-    boolean breakNextLine;
-}
-
-class FrameHelper implements DebugFrame {
-
-    FrameHelper(Context cx, Main db, DebuggableScript fnOrScript)
-    {
-        this.db = db;
-        this.contextData = ContextData.get(cx);
-        this.fnOrScript = fnOrScript;
-        ScriptItem item = db.getScriptItem(fnOrScript);
-        if (item != null) {
-            this.sourceInfo = item.getSourceInfo();
-            this.lineNumber = item.getFirstLine();
-        }
-        contextData.pushFrame(this);
-    }
-
-    public void onEnter(Context cx, Scriptable activation,
-                        Scriptable thisObj, Object[] args)
-    {
-        this.activation = activation;
-        if (db.breakOnEnter) {
-            db.handleBreakpointHit(cx);
-        }
-    }
-
-    public void onLineChange(Context cx, int lineno) {
-        this.lineNumber = lineno;
-        if (contextData.breakNextLine
-            || (sourceInfo != null && sourceInfo.hasBreakpoint(lineno)))
-        {
-            db.handleBreakpointHit(cx);
-        }
-    }
-
-    public void onExceptionThrown(Context cx, Throwable exception) {
-        db.handleExceptionThrown(cx, exception, this);
-    }
-
-    public void onExit(Context cx, boolean byThrow, Object resultOrException) {
-        if (db.breakOnReturn && !byThrow) {
-            db.handleBreakpointHit(cx);
-        }
-        contextData.popFrame();
-    }
-
-    SourceInfo getSourceInfo() {
-        return sourceInfo;
-    }
-
-    Scriptable getVariableObject() {
-        return activation;
-    }
-
-    String getUrl() {
-        if (sourceInfo != null) {
-            return sourceInfo.getUrl();
-        }
-        return db.getNormilizedUrl(fnOrScript);
-    }
-
-    int getLineNumber() {
-        return lineNumber;
-    }
-
-    DebuggableScript getScript() {
-        return fnOrScript;
-    }
-
-    private Main db;
-    private ContextData contextData;
-    private Scriptable activation;
-    private DebuggableScript fnOrScript;
-    private SourceInfo sourceInfo;
-    private int lineNumber;
-}
-
-class ScriptItem {
-
-    ScriptItem(DebuggableScript fnOrScript, SourceInfo sourceInfo) {
-        this.fnOrScript = fnOrScript;
-        this.sourceInfo = sourceInfo;
-    }
-
-    DebuggableScript getScript() { return fnOrScript; }
-
-    SourceInfo getSourceInfo() { return sourceInfo; }
-
-    int getFirstLine() {
-        return (firstLine == 0) ? 1 : firstLine;
-    }
-
-    void setFirstLine(int firstLine) {
-        if (firstLine <= 0) { throw new IllegalArgumentException(); }
-        if (this.firstLine != 0) { throw new IllegalStateException(); }
-        this.firstLine = firstLine;
-    }
-
-    private DebuggableScript fnOrScript;
-    private SourceInfo sourceInfo;
-    private int firstLine;
-}
-
-class SourceInfo {
-
-    static String getShortName(String url) {
-        int lastSlash = url.lastIndexOf('/');
-        if (lastSlash < 0) {
-            lastSlash = url.lastIndexOf('\\');
-        }
-        String shortName = url;
-        if (lastSlash >= 0 && lastSlash + 1 < url.length()) {
-            shortName = url.substring(lastSlash + 1);
-        }
-        return shortName;
-    }
-
-    SourceInfo(String sourceUrl, String source) {
-        this.sourceUrl = sourceUrl;
-        this.source = source;
-    }
-
-    String getUrl() {
-        return sourceUrl;
-    }
-
-    String getSource() {
-        return source;
-    }
-
-    synchronized void setSource(String source) {
-        if (!this.source.equals(source)) {
-            this.source = source;
-            endLine = 0;
-            breakableLines = null;
-
-            if (breakpoints != null) {
-                for (int i = breakpoints.length - 1; i >= 0; --i) {
-                    if (breakpoints[i] == BREAK_FLAG) {
-                        breakpoints[i] = OLD_BREAK_FLAG;
-                    }
-                }
-            }
-        }
-    }
-
-    synchronized void updateLineInfo(ScriptItem item) {
-
-        int[] lines = item.getScript().getLineNumbers();
-        if (lines.length == 0) {
-            return;
-        }
-
-        int fnFirstLine = lines[0];
-        int fnEndLine = fnFirstLine + 1;
-        for (int i = 1; i != lines.length; ++i) {
-            int line = lines[i];
-            if (line < fnFirstLine) {
-                fnFirstLine = line;
-            }else if (line >= fnEndLine) {
-                fnEndLine = line + 1;
-            }
-        }
-        item.setFirstLine(fnFirstLine);
-
-        if (endLine < fnEndLine) {
-            endLine = fnEndLine;
-        }
-        if (breakableLines == null) {
-            int newLength = 20;
-            if (newLength < endLine) { newLength = endLine; }
-            breakableLines = new boolean[newLength];
-        }else if (breakableLines.length < endLine) {
-            int newLength = breakableLines.length * 2;
-            if (newLength < endLine) { newLength = endLine; }
-            boolean[] tmp = new boolean[newLength];
-            System.arraycopy(breakableLines, 0, tmp, 0, breakableLines.length);
-            breakableLines = tmp;
-        }
-        int breakpointsEnd = (breakpoints == null) ? 0 : breakpoints.length;
-        for (int i = 0; i != lines.length; ++i) {
-            int line = lines[i];
-            breakableLines[line] = true;
-            if (line < breakpointsEnd) {
-                if (breakpoints[line] == OLD_BREAK_FLAG) {
-                    breakpoints[line] = BREAK_FLAG;
-                }
-            }
-        }
-    }
-
-    boolean breakableLine(int line) {
-        boolean[] breakableLines = this.breakableLines;
-        if (breakableLines != null && line < breakableLines.length) {
-            return breakableLines[line];
-        }
-        return false;
-    }
-
-    boolean hasBreakpoint(int line) {
-        byte[] breakpoints = this.breakpoints;
-        if (breakpoints != null && line < breakpoints.length) {
-            return breakpoints[line] == BREAK_FLAG;
-        }
-        return false;
-    }
-
-    synchronized boolean placeBreakpoint(int line) {
-        if (breakableLine(line)) {
-            if (breakpoints == null) {
-                breakpoints = new byte[endLine];
-            }else if (line >= breakpoints.length) {
-                byte[] tmp = new byte[endLine];
-                System.arraycopy(breakpoints, 0, tmp, 0, breakpoints.length);
-                breakpoints = tmp;
-            }
-            breakpoints[line] = BREAK_FLAG;
-            return true;
-        }
-        return false;
-    }
-
-    synchronized boolean removeBreakpoint(int line) {
-        boolean wasBreakpoint = false;
-        if (breakpoints != null && line < breakpoints.length) {
-            wasBreakpoint = (breakpoints[line] != BREAK_FLAG);
-            breakpoints[line] = 0;
-        }
-        return wasBreakpoint;
-    }
-
-    synchronized void removeAllBreakpoints() {
-        breakpoints = null;
-    }
-
-    private String sourceUrl;
-    private String source;
-
-    private int endLine;
-    private boolean[] breakableLines;
-
-    private static final byte BREAK_FLAG = 1;
-    private static final byte OLD_BREAK_FLAG = 2;
-    private byte[] breakpoints;
-
-}
-
-public class Main extends JFrame implements Debugger, ContextListener {
-
-    /* ContextListener interface */
-
-    ObjToIntMap contexts = new ObjToIntMap();
-
-    static Thread mainThread; // thread used to run the shell
-
-    public void contextCreated(Context cx) {
-        
-        synchronized (contexts) {
-            ContextData contextData = new ContextData();
-            cx.setDebugger(this, contextData);
-            cx.setGeneratingDebug(true);
-            cx.setOptimizationLevel(-1);
-            // if the user pressed "Break" or if this thread is the shell's
-            // Main then set the break flag so that when the debugger is run
-            // with a file argument on the command line it will
-            // break at the start of the file
-            if (breakFlag || Thread.currentThread() == mainThread) {
-                contextData.breakNextLine = true;
-            }
-        }
-    }
-
-    public void contextEntered(Context cx) {
-        // If the debugger is attached to cx
-        // keep a reference to it even if it was detached
-        // from its thread (we cause that to happen below
-        // in interrupted)
-        synchronized (contexts) {
-            if (!contexts.has(cx)) {
-                if (cx.getDebugger() == this) {
-                    contexts.put(cx, 1);
-                }
-            }
-        }
-    }
-
-    public void contextExited(Context cx) {
-    }
-
-    public void contextReleased(Context cx) {
-        synchronized (contexts) {
-            contexts.remove(cx);
-        }
-    }
-
-    /* end ContextListener interface */
-
-    boolean breakFlag = false;
-
-    public void doBreak() {
-        breakFlag = true;
-        synchronized (contexts) {
-            ObjToIntMap.Iterator iter = contexts.newIterator();
-            for (iter.start(); !iter.done(); iter.next()) {
-                Context cx = (Context)iter.getKey();
-                ContextData.get(cx).breakNextLine = true;
-            }
-        }
-    }
-
-    public void setVisible(boolean b) {
-        super.setVisible(b);
-        if (b) {
-            // this needs to be done after the window is visible
-            // console.consoleTextArea.requestFocus();
-            context.split.setDividerLocation(0.5);
-            try {
-                // console.setMaximum(true);
-                // console.setSelected(true);
-                // console.show();
-                // console.consoleTextArea.requestFocus();
-            } catch (Exception exc) {
-            }
-        }
-    }
-
-    static final int STEP_OVER = 0;
-    static final int STEP_INTO = 1;
-    static final int STEP_OUT = 2;
-    static final int GO = 3;
-    static final int BREAK = 4;
-    static final int RUN_TO_CURSOR = 5;
-    static final int EXIT = 6;
-
-    class ThreadState {
-        private int stopAtFrameDepth = -1;
-    };
-
-    private Hashtable threadState = new Hashtable();
-    private Thread runToCursorThread;
-    private int runToCursorLine;
-    private String runToCursorFile;
-    private Hashtable scriptItems = new Hashtable();
-    private Hashtable sourceNames = new Hashtable();
-
-  
-    Hashtable functionNames = new Hashtable();
-
-
-    /* Debugger Interface */
-
-    public void handleCompilationDone(Context cx, DebuggableScript fnOrScript,
-                                      String source)
-    {
-         String sourceUrl = getNormilizedUrl(fnOrScript);
-         SourceInfo si = registerSource(sourceUrl, source);
-         registerScript(si, fnOrScript);
-    }
-
-    String getNormilizedUrl(DebuggableScript fnOrScript) {
-        String url = fnOrScript.getSourceName();
-        if (url == null) { url = "document"; }
-        else {
-            // Not to produce window for eval from different lines,
-            // strip line numbers, i.e. replace all #[0-9]+\(eval\) by (eval)
-            // Option: similar teatment for Function?
-            char evalSeparator = '#';
-            StringBuffer sb = null;
-            int urlLength = url.length();
-            int cursor = 0;
-            for (;;) {
-                int searchStart = url.indexOf(evalSeparator, cursor);
-                if (searchStart < 0) {
-                    break;
-                }
-                String replace = null;
-                int i = searchStart + 1;
-                boolean hasDigits = false;
-                while (i != urlLength) {
-                    int c = url.charAt(i);
-                    if (!('0' <= c && c <= '9')) {
-                        break;
-                    }
-                    ++i;
-                }
-                if (i != searchStart + 1) {
-                    // i points after #[0-9]+
-                    if ("(eval)".regionMatches(0, url, i, 6)) {
-                        cursor = i + 6;
-                        replace = "(eval)";
-                    }
-                }
-                if (replace == null) {
-                    break;
-                }
-                if (sb == null) {
-                    sb = new StringBuffer();
-                    sb.append(url.substring(0, searchStart));
-                }
-                sb.append(replace);
-            }
-            if (sb != null) {
-                if (cursor != urlLength) {
-                    sb.append(url.substring(cursor));
-                }
-                url = sb.toString();
-            }
-        }
-        return url;
-    }
-
-    private static InputStream openSource(String sourceUrl)
-        throws IOException
-    {
-        int hash = sourceUrl.indexOf('#');
-        if (hash >= 0) {
-            sourceUrl = sourceUrl.substring(0, hash);
-        }
-        if (sourceUrl.indexOf(':') < 0) {
-            // Can be a file name
-            try {
-                if (sourceUrl.startsWith("~/")) {
-                    String home = System.getProperty("user.home");
-                    if (home != null) {
-                        String pathFromHome = sourceUrl.substring(2);
-                        File f = new File(new File(home), pathFromHome);
-                        if (f.exists()) {
-                            return new FileInputStream(f);
-                        }
-                    }
-                }
-                File f = new File(sourceUrl);
-                if (f.exists()) {
-                    return new FileInputStream(f);
-                }
-            } catch (SecurityException ex) { }
-            // No existing file, assume missed http://
-            if (sourceUrl.startsWith("//")) {
-                sourceUrl = "http:" + sourceUrl;
-            } else if (sourceUrl.startsWith("/")) {
-                sourceUrl = "http://127.0.0.1" + sourceUrl;
-            } else {
-                sourceUrl = "http://" + sourceUrl;
-            }
-        }
-
-        return (new java.net.URL(sourceUrl)).openStream();
-    }
-
-    private static String readSource(InputStream is) throws IOException {
-        byte[] buffer = new byte[4096];
-        int offset = 0;
-        for (;;) {
-            int n = is.read(buffer, 0, buffer.length - offset);
-            if (n < 0) { break; }
-            offset += n;
-            if (offset == buffer.length) {
-                byte[] tmp = new byte[buffer.length * 2];
-                System.arraycopy(buffer, 0, tmp, 0, offset);
-                buffer = tmp;
-            }
-        }
-        return new String(buffer, 0, offset);
-    }
-
-    private SourceInfo registerSource(String sourceUrl, String source) {
-        SourceInfo si;
-        synchronized (sourceNames) {
-            si = (SourceInfo)sourceNames.get(sourceUrl);
-            if (si == null) {
-                si = new SourceInfo(sourceUrl, source);
-                sourceNames.put(sourceUrl, si);
-            }
-            else if (!source.equals(si.getSource()))
-                si.setSource(source);
-        }
-        return si;
-    }
-
-    private ScriptItem registerScript(SourceInfo si,
-                                      DebuggableScript fnOrScript)
-    {
-        ScriptItem item;
-        synchronized (scriptItems) {
-            item = (ScriptItem)scriptItems.get(fnOrScript);
-            if (item == null) {
-                item = new ScriptItem(fnOrScript, si);
-                si.updateLineInfo(item);
-                scriptItems.put(fnOrScript, item);
-            }
-        }
-
-        String name = fnOrScript.getFunctionName();
-        if (name != null && name.length() > 0 && !name.equals("anonymous")) {
-            functionNames.put(name, item);
-        }
-
-        loadedFile(si);
-        return item;
-    }
-
-
-    void handleBreakpointHit(Context cx) {
-        breakFlag = false;
-        interrupted(cx);
-    }
-
-    private static Object unwrapException(Object ex) {
-        for (;;) {
-            if (ex instanceof JavaScriptException) {
-                ex = ScriptRuntime.unwrapJavaScriptException
-                            ((JavaScriptException)ex);
-            }else if (ex instanceof EcmaError) {
-                ex = ((EcmaError)ex).getErrorObject();
-            }else if (ex instanceof NativeJavaObject) {
-                ex = ((NativeJavaObject)ex).unwrap();
-                break;
-            }else if (ex instanceof WrappedException) {
-                Object w = ((WrappedException)ex).unwrap();
-                if (w instanceof Throwable) {
-                    ex = w;
-                    continue;
-                }
-                break;
-            }else {
-                break;
-            }
-        }
-        return ex;
-    }
-
-    void handleExceptionThrown(Context cx, Throwable ex, FrameHelper frame) {
-        if (breakOnExceptions) {
-            String url = frame.getUrl();
-            int lineNumber = frame.getLineNumber();
-            FileWindow w = getFileWindow(url);
-            Object e = unwrapException(ex);
-            String msg = e.toString();
-            if (msg == null || msg.length() == 0) {
-                msg = e.getClass().toString();
-            }
-            msg += " (" + url + ", line " + lineNumber + ")";
-            if (w != null) {
-                swingInvoke(new SetFilePosition(this, w, lineNumber));
-            }
-            MessageDialogWrapper.showMessageDialog(this,
-                                                   msg,
-                                                   "Exception in Script",
-                                                   JOptionPane.ERROR_MESSAGE);
-            //if (w != null) {
-            //swingInvoke(new SetFilePosition(this, w, -1));
-            //}
-            interrupted(cx);
-        }
-    }
-
-    public DebugFrame getFrame(Context cx, DebuggableScript fnOrScript) {
-        return new FrameHelper(cx, this, fnOrScript);
-    }
-
-    /* end Debugger interface */
-
-    JDesktopPane desk;
-    ContextWindow context;
-    Menubar menubar;
-    JToolBar toolBar;
-    JSInternalConsole console;
-    EvalWindow evalWindow;
-    JSplitPane split1;
-    JLabel statusBar;
-    void init() {
-        setJMenuBar(menubar = new Menubar(this));
-        toolBar = new JToolBar();
-        JButton button;
-        JButton breakButton, goButton, stepIntoButton,
-            stepOverButton, stepOutButton;
-        String [] toolTips = {"Break (Pause)",
-                              "Go (F5)",
-                              "Step Into (F11)",
-                              "Step Over (F7)",
-                              "Step Out (F8)"};
-        int count = 0;
-        button = breakButton = new JButton("Break");
-        JButton focusButton = button;
-        button.setToolTipText("Break");
-        button.setActionCommand("Break");
-        button.addActionListener(menubar);
-        button.setEnabled(true);
-        button.setToolTipText(toolTips[count++]);
-
-        button = goButton = new JButton("Go");
-        button.setToolTipText("Go");
-        button.setActionCommand("Go");
-        button.addActionListener(menubar);
-        button.setEnabled(false);
-        button.setToolTipText(toolTips[count++]);
-
-        button = stepIntoButton = new JButton("Step Into");
-        button.setToolTipText("Step Into");
-        button.setActionCommand("Step Into");
-        button.addActionListener(menubar);
-        button.setEnabled(false);
-        button.setToolTipText(toolTips[count++]);
-
-        button = stepOverButton = new JButton("Step Over");
-        button.setToolTipText("Step Over");
-        button.setActionCommand("Step Over");
-        button.setEnabled(false);
-        button.addActionListener(menubar);
-        button.setToolTipText(toolTips[count++]);
-
-        button = stepOutButton = new JButton("Step Out");
-        button.setToolTipText("Step Out");
-        button.setActionCommand("Step Out");
-        button.setEnabled(false);
-        button.addActionListener(menubar);
-        button.setToolTipText(toolTips[count++]);
-
-        Dimension dim = stepOverButton.getPreferredSize();
-        breakButton.setPreferredSize(dim);
-        breakButton.setMinimumSize(dim);
-        breakButton.setMaximumSize(dim);
-        breakButton.setSize(dim);
-        goButton.setPreferredSize(dim);
-        goButton.setMinimumSize(dim);
-        goButton.setMaximumSize(dim);
-        stepIntoButton.setPreferredSize(dim);
-        stepIntoButton.setMinimumSize(dim);
-        stepIntoButton.setMaximumSize(dim);
-        stepOverButton.setPreferredSize(dim);
-        stepOverButton.setMinimumSize(dim);
-        stepOverButton.setMaximumSize(dim);
-        stepOutButton.setPreferredSize(dim);
-        stepOutButton.setMinimumSize(dim);
-        stepOutButton.setMaximumSize(dim);
-        toolBar.add(breakButton);
-        toolBar.add(goButton);
-        toolBar.add(stepIntoButton);
-        toolBar.add(stepOverButton);
-        toolBar.add(stepOutButton);
-
-        JPanel contentPane = new JPanel();
-        contentPane.setLayout(new BorderLayout());
-        getContentPane().add(toolBar, BorderLayout.NORTH);
-        getContentPane().add(contentPane, BorderLayout.CENTER);
-        desk = new JDesktopPane();
-        desk.setPreferredSize(new Dimension(600, 300));
-        desk.setMinimumSize(new Dimension(150, 50));
-        // desk.add(console = new JSInternalConsole("JavaScript Console"));
-        context = new ContextWindow(this);
-        context.setPreferredSize(new Dimension(600, 120));
-        context.setMinimumSize(new Dimension(50, 50));
-
-        split1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, desk,
-                                          context);
-        split1.setOneTouchExpandable(true);
-        Main.setResizeWeight(split1, 0.66);
-        contentPane.add(split1, BorderLayout.CENTER);
-        statusBar = new JLabel();
-        statusBar.setText("Thread: ");
-        contentPane.add(statusBar, BorderLayout.SOUTH);
-        dlg = new JFileChooser();
-
-        javax.swing.filechooser.FileFilter filter =
-            new javax.swing.filechooser.FileFilter() {
-                    public boolean accept(File f) {
-                        if (f.isDirectory()) {
-                            return true;
-                        }
-                        String n = f.getName();
-                        int i = n.lastIndexOf('.');
-                        if (i > 0 && i < n.length() -1) {
-                            String ext = n.substring(i + 1).toLowerCase();
-                            if (ext.equals("js")) {
-                                return true;
-                            }
-                        }
-                        return false;
-                    }
-
-                    public String getDescription() {
-                        return "JavaScript Files (*.js)";
-                    }
-                };
-        dlg.addChoosableFileFilter(filter);
-        final Main self = this;
-        addWindowListener(new WindowAdapter() {
-                public void windowClosing(WindowEvent e) {
-                    self.Exit();
-                }
-            });
-    }
-
-
-    ScopeProvider scopeProvider;
-    Runnable exitAction;
-
-
-    Scriptable getScope() {
-        return (scopeProvider != null) ? scopeProvider.getScope() : null;
-    }
-
-    FileWindow getFileWindow(String url) {
-        if (url == null || url.equals("<stdin>")) {
-            return null;
-        }
-        return (FileWindow)fileWindows.get(url);
-    }
-
-    void loadedFile(SourceInfo si) {
-        String fileName = si.getUrl();
-        FileWindow w = getFileWindow(fileName);
-        if (w != null) {
-            swingInvoke(UpdateFileText.action(w));
-            w.show();
-        } else if (!fileName.equals("<stdin>")) {
-            
-            swingInvoke(CreateFileWindow.action(this, si, -1));
-        }
-    }
-
-    static void swingInvoke(Runnable f) {
-        if (SwingUtilities.isEventDispatchThread()) {
-            f.run();
-            return;
-        }
-        try {
-            SwingUtilities.invokeAndWait(f);
-        } catch (Exception exc) {
-            exc.printStackTrace();
-        }
-    }
-
-    static void swingInvokeLater(Runnable f) {
-        try {
-            SwingUtilities.invokeLater(f);
-        } catch (RuntimeException exc) {
-            exc.printStackTrace();
-        }
-    }
-
-    int frameIndex = -1;
-
-    void contextSwitch (int frameIndex) {
-        Context cx = getCurrentContext();
-        ContextData contextData = ContextData.get(cx);
-        ContextHelper helper = new ContextHelper();
-        helper.attach(cx);
-        if (cx != null) {
-            int frameCount = contextData.getFrameCount();
-            if (frameIndex < 0 || frameIndex >= frameCount) {
-                helper.reset();
-                return;
-            }
-            this.frameIndex = frameIndex;
-            FrameHelper frame = contextData.getFrame(frameIndex);
-            String sourceName = frame.getUrl();
-            if (sourceName == null || sourceName.equals("<stdin>")) {
-                // console.show();
-                helper.reset();
-                return;
-            }
-            int lineNumber = frame.getLineNumber();
-            this.frameIndex = frameIndex;
-            FileWindow w = getFileWindow(sourceName);
-            if (w != null) {
-                SetFilePosition action =
-                    new SetFilePosition(this, w, lineNumber);
-                action.run();
-            } else {
-                SourceInfo si = frame.getSourceInfo();
-                CreateFileWindow.action(this, si, lineNumber).run();
-            }
-            helper.reset();
-        }
-    }
-
-    boolean isInterrupted = false;
-    boolean nonDispatcherWaiting = false;
-    int dispatcherIsWaiting = 0;
-    Context currentContext = null;
-
-    // Flag used to establish whether source code editing is allowed in
-    // the debugger, switched on and off depending on whether a debug session
-    // is active
-    boolean sourceEditingEnabled = true;
-
-    public boolean isSourceEditingEnabled() {
-        return sourceEditingEnabled;
-    }
-
-    void setSourceEditingEnabled(boolean b) {
-        sourceEditingEnabled = b;
-    }
-
-    Context getCurrentContext() {
-        return currentContext;
-    }
-
-    void interrupted(Context cx) {
-        synchronized (swingMonitor) {
-            if (SwingUtilities.isEventDispatchThread()) {
-                dispatcherIsWaiting++;
-                if (nonDispatcherWaiting) {
-                    // Another thread is stopped in the debugger
-                    // process events until it resumes and we
-                    // can enter
-                    java.awt.EventQueue eventQ  =
-                        java.awt.Toolkit.getDefaultToolkit().getSystemEventQueue();
-                    while (nonDispatcherWaiting) {
-                        try {
-                            AWTEvent event = eventQ.getNextEvent();
-                            if (event instanceof ActiveEvent) {
-                                ((ActiveEvent)event).dispatch();
-                            } else {
-                                Object source = event.getSource();
-                                if (source instanceof Component) {
-                                    Component comp = (Component)source;
-                                // Suppress Window/InputEvent's that aren't
-                                // directed to the Debugger
-                                    // if (!(event instanceof InputEvent ||
-                                    //event instanceof WindowEvent)||
-                                    //shouldDispatchTo(comp)) {
-                                    comp.dispatchEvent(event);
-                                //}
-                                } else if (source instanceof MenuComponent) {
-                                    ((MenuComponent)source).dispatchEvent(event);
-                                }
-                            }
-                            if (this.returnValue == EXIT) {
-                                return;
-                            }
-                            swingMonitor.wait(1);
-                        } catch (InterruptedException exc) {
-                            return;
-                        }
-                    }
-                }
-            } else {
-                while (isInterrupted || dispatcherIsWaiting > 0) {
-                    try {
-                        swingMonitor.wait();
-                    } catch (InterruptedException exc) {
-                        return;
-                    }
-                }
-                nonDispatcherWaiting = true;
-            }
-            isInterrupted = true;
-        }
-        do {
-            currentContext = cx;
-            ContextData contextData = ContextData.get(cx);
-            Thread thread = Thread.currentThread();
-            statusBar.setText("Thread: " + thread.toString());
-            ThreadState state = (ThreadState)threadState.get(thread);
-            int stopAtFrameDepth = -1;
-            if (state != null) {
-                stopAtFrameDepth = state.stopAtFrameDepth;
-            }
-            if (runToCursorFile != null && thread == runToCursorThread) {
-                int frameCount = contextData.getFrameCount();
-                if (frameCount > 0) {
-                    FrameHelper frame = contextData.getFrame(0);
-                    String url = frame.getUrl();
-                    if (url != null) {
-                        if (url.equals(runToCursorFile)) {
-                            int lineNumber = frame.getLineNumber();
-                            if (lineNumber == runToCursorLine) {
-                                stopAtFrameDepth = -1;
-                                runToCursorFile = null;
-                            } else {
-                                FileWindow w = getFileWindow(url);
-                                if (w == null ||
-                                   !w.isBreakPoint(lineNumber)) {
-                                    return;
-                                } else {
-                                    runToCursorFile = null;
-                                }
-                            }
-                        }
-                    }
-                } else {
-                }
-            }
-            if (stopAtFrameDepth > 0) {
-                if (contextData.getFrameCount() > stopAtFrameDepth) {
-                    break;
-                }
-            }
-            if (state != null) {
-                state.stopAtFrameDepth = -1;
-            }
-            threadState.remove(thread);
-            int frameCount = contextData.getFrameCount();
-            this.frameIndex = frameCount -1;
-            int line = 0;
-            if (frameCount == 0) {
-                break;
-            }
-            FrameHelper frame = contextData.getFrame(0);
-            String url = frame.getUrl();
-            contextData.breakNextLine = false;
-            line = frame.getLineNumber();
-            int enterCount = 0;
-            boolean isDispatchThread =
-                SwingUtilities.isEventDispatchThread();
-
-            if (!isDispatchThread) {
-                // detach cx from its thread so the debugger (in the awt
-                // dispatcher thread) can enter it if necessary
-                cx.exit();
-                while (Context.getCurrentContext() != null) {
-                    Context.exit();
-                    enterCount++;
-                }
-            }
-            if (url != null && !url.equals("<stdin>")) {
-                FileWindow w = (FileWindow)getFileWindow(url);
-                if (w != null) {
-                    SetFilePosition action =
-                        new SetFilePosition(this, w, line);
-                    swingInvoke(action);
-                } else {
-                    SourceInfo si = frame.getSourceInfo();
-                    swingInvoke(CreateFileWindow.action(this, si, line));
-                }
-            } else {
-                /* if (console.isVisible()) {
-                    final JSInternalConsole finalConsole = console;
-                    swingInvoke(new Runnable() {
-                            public void run() {
-                                finalConsole.show();
-                            }
-                        });
-                } */
-            }
-            swingInvoke(new EnterInterrupt(this, cx));
-            swingInvoke(new UpdateContext(this, cx));
-            int returnValue;
-            if (!isDispatchThread) {
-                synchronized (monitor) {
-                    this.returnValue = -1;
-                    try {
-                        while (this.returnValue == -1) {
-                            monitor.wait();
-                        }
-                        returnValue = this.returnValue;
-                    } catch (InterruptedException exc) {
-                        break;
-                    }
-                }
-            } else {
-                java.awt.EventQueue eventQ  =
-                    java.awt.Toolkit.getDefaultToolkit().getSystemEventQueue();
-                this.returnValue = -1;
-                while (this.returnValue == -1) {
-                    try {
-                        AWTEvent event = eventQ.getNextEvent();
-                        if (event instanceof ActiveEvent) {
-                            ((ActiveEvent)event).dispatch();
-                        } else {
-                            Object source = event.getSource();
-                            if (source instanceof Component) {
-                                Component comp = (Component)source;
-                                // Suppress Window/InputEvent's that aren't
-                                // directed to the Debugger
-                                // if (!(event instanceof InputEvent ||
-                                //event instanceof WindowEvent)||
-                                //       shouldDispatchTo(comp)) {
-                                //comp.dispatchEvent(event);
-                                //}
-                                comp.dispatchEvent(event);
-                            } else if (source instanceof MenuComponent) {
-                                ((MenuComponent)source).dispatchEvent(event);
-                            }
-                        }
-                    } catch (InterruptedException exc) {
-                    }
-                }
-                returnValue = this.returnValue;
-            }
-            swingInvoke(new ExitInterrupt(this));
-            if (!isDispatchThread) {
-                // reattach cx to its thread
-                Context current;
-                if ((current = Context.enter(cx)) != cx) {
-                    System.out.println("debugger error: cx = " + cx + " current = " + current);
-
-                }
-                while (enterCount > 0) {
-                    Context.enter();
-                    enterCount--;
-                }
-            }
-            switch (returnValue) {
-            case STEP_OVER:
-                contextData.breakNextLine = true;
-                stopAtFrameDepth = contextData.getFrameCount();
-                if (state == null) {
-                    state = new ThreadState();
-                }
-                state.stopAtFrameDepth = stopAtFrameDepth;
-                threadState.put(thread, state);
-                break;
-            case STEP_INTO:
-                contextData.breakNextLine = true;
-                if (state != null) {
-                    state.stopAtFrameDepth = -1;
-                }
-                break;
-            case STEP_OUT:
-                stopAtFrameDepth = contextData.getFrameCount() -1;
-                if (stopAtFrameDepth > 0) {
-                    contextData.breakNextLine = true;
-                    if (state == null) {
-                        state = new ThreadState();
-                    }
-                    state.stopAtFrameDepth = stopAtFrameDepth;
-                    threadState.put(thread, state);
-                }
-                break;
-            case RUN_TO_CURSOR:
-                contextData.breakNextLine = true;
-                if (state != null) {
-                    state.stopAtFrameDepth = -1;
-                }
-                break;
-            }
-        } while (false);
-        synchronized (swingMonitor) {
-            isInterrupted = false;
-            if (SwingUtilities.isEventDispatchThread()) {
-                dispatcherIsWaiting--;
-            } else {
-                nonDispatcherWaiting = false;
-            }
-            swingMonitor.notifyAll();
-        }
-    }
-
-    JFileChooser dlg;
-
-    String chooseFile(String title) {
-        dlg.setDialogTitle(title);
-        File CWD = null;
-        String dir = System.getProperty("user.dir");
-        if (dir != null) {
-            CWD = new File(dir);
-        }
-        if (CWD != null) {
-            dlg.setCurrentDirectory(CWD);
-        }
-        int returnVal = dlg.showOpenDialog(this);
-        if (returnVal == JFileChooser.APPROVE_OPTION) {
-            try {
-                String result = dlg.getSelectedFile().getCanonicalPath();
-                CWD = dlg.getSelectedFile().getParentFile();
-                Properties props = System.getProperties();
-                props.put("user.dir", CWD.getPath());
-                System.setProperties(props);
-                return result;
-            }catch (IOException ignored) {
-            }catch (SecurityException ignored) {
-            }
-        }
-        return null;
-    }
-
-    JInternalFrame getSelectedFrame() {
-       JInternalFrame[] frames = desk.getAllFrames();
-       for (int i = 0; i < frames.length; i++) {
-           if (frames[i].isShowing()) {
-               return frames[i];
-           }
-       }
-       return frames[frames.length - 1];
-    }
-
-    void actionPerformed(ActionEvent e) {
-        String cmd = e.getActionCommand();
-        int returnValue = -1;
-        if (cmd.equals("Cut") || cmd.equals("Copy") || cmd.equals("Paste")) {
-            JInternalFrame f = getSelectedFrame();
-            if (f != null && f instanceof ActionListener) {
-                ((ActionListener)f).actionPerformed(e);
-            }
-        } else if (cmd.equals("Step Over")) {
-            returnValue = STEP_OVER;
-        } else if (cmd.equals("Step Into")) {
-            returnValue = STEP_INTO;
-        } else if (cmd.equals("Step Out")) {
-            returnValue = STEP_OUT;
-        } else if (cmd.equals("Go")) {
-            returnValue = GO;
-        } else if (cmd.equals("Break")) {
-            doBreak();
-        } else if (cmd.equals("Run to Cursor")) {
-            returnValue = RUN_TO_CURSOR;
-        } else if (cmd.equals("Exit")) {
-            Exit();
-        } else if (cmd.equals("Open")) {
-            Scriptable scope = getScope();
-            if (scope == null) {
-                MessageDialogWrapper.showMessageDialog(this, "Can't compile scripts: no scope available", "Open", JOptionPane.ERROR_MESSAGE);
-            } else {
-                String fileName = chooseFile("Select a file to compile");
-                if (fileName != null) {
-                    new Thread(new OpenFile(this, scope,
-                                            fileName)).start();
-                }
-            }
-        } else if (cmd.equals("Load")) {
-            Scriptable scope = getScope();
-            if (scope == null) {
-                MessageDialogWrapper.showMessageDialog(this, "Can't run scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
-            } else {
-                String fileName = chooseFile("Select a file to execute");
-                if (fileName != null) {
-                    new Thread(new LoadFile(this, scope,
-                                            fileName)).start();
-                }
-            }
-        } else if (cmd.equals("Run")) {
-            FileWindow w = (FileWindow)getSelectedFrame();
-            if (w != null)
-                w.load();
-        } else if (cmd.equals("Save")) {
-            FileWindow w = (FileWindow)getSelectedFrame();
-            if (w != null)
-                w.save();
-        } else if (cmd.equals("More Windows...")) {
-            MoreWindows dlg = new MoreWindows(this, fileWindows,
-                                              "Window", "Files");
-            dlg.showDialog(this);
-        } else if (cmd.equals("Console")) {
-            if (console.isIcon()) {
-                desk.getDesktopManager().deiconifyFrame(console);
-            }
-            console.show();
-            desk.getDesktopManager().activateFrame(console);
-            console.consoleTextArea.requestFocus();
-        } else if (cmd.equals("Cut")) {
-        } else if (cmd.equals("Copy")) {
-        } else if (cmd.equals("Paste")) {
-        } else if (cmd.equals("Go to function...")) {
-            FindFunction dlg = new FindFunction(this, functionNames,
-                                                "Go to function",
-                                                "Function");
-            dlg.showDialog(this);
-        } else if (cmd.equals("Tile")) {
-            JInternalFrame[] frames = desk.getAllFrames();
-            int count = frames.length;
-            int rows, cols;
-            rows = cols = (int)Math.sqrt(count);
-            if (rows*cols < count) {
-                cols++;
-                if (rows * cols < count) {
-                    rows++;
-                }
-            }
-            Dimension size = desk.getSize();
-            int w = size.width/cols;
-            int h = size.height/rows;
-            int x = 0;
-            int y = 0;
-            for (int i = 0; i < rows; i++) {
-                for (int j = 0; j < cols; j++) {
-                    int index = (i*cols) + j;
-                    if (index >= frames.length) {
-                        break;
-                    }
-                    JInternalFrame f = frames[index];
-                    try {
-                        f.setIcon(false);
-                        f.setMaximum(false);
-                    } catch (Exception exc) {
-                    }
-                    desk.getDesktopManager().setBoundsForFrame(f, x, y,
-                                                               w, h);
-                    x += w;
-                }
-                y += h;
-                x = 0;
-            }
-        } else if (cmd.equals("Cascade")) {
-            JInternalFrame[] frames = desk.getAllFrames();
-            int count = frames.length;
-            int x, y, w, h;
-            x = y = 0;
-            h = desk.getHeight();
-            int d = h / count;
-            if (d > 30) d = 30;
-            for (int i = count -1; i >= 0; i--, x += d, y += d) {
-                JInternalFrame f = frames[i];
-                try {
-                    f.setIcon(false);
-                    f.setMaximum(false);
-                } catch (Exception exc) {
-                }
-                Dimension dimen = f.getPreferredSize();
-                w = dimen.width;
-                h = dimen.height;
-                desk.getDesktopManager().setBoundsForFrame(f, x, y, w, h);
-            }
-        } else {
-            Object obj = getFileWindow(cmd);
-            if (obj != null) {
-                FileWindow w = (FileWindow)obj;
-                try {
-                    if (w.isIcon()) {
-                        w.setIcon(false);
-                    }
-                    w.setVisible(true);
-                    w.moveToFront();
-                    w.setSelected(true);
-                } catch (Exception exc) {
-                }
-            }
-        }
-        if (returnValue != -1) {
-            if (currentWindow != null) currentWindow.setPosition(-1);
-            synchronized (monitor) {
-                this.returnValue = returnValue;
-                monitor.notify();
-            }
-        }
-    }
-
-    void runToCursor(String fileName,
-                     int lineNumber,
-                     ActionEvent evt) {
-        SourceInfo si = (SourceInfo)sourceNames.get(fileName);
-        if (si == null) {
-            System.out.println("debugger error: Couldn't find source: " + fileName);
-        }
-        if (si.breakableLine(lineNumber)) {
-            runToCursorFile = fileName;
-            runToCursorLine = lineNumber;
-            actionPerformed(evt);
-        }
-    }
-
-    JMenu getWindowMenu() {
-        return menubar.getMenu(3);
-    }
-
-    void removeWindow(FileWindow w) {
-        fileWindows.remove(w.getUrl());
-        JMenu windowMenu = getWindowMenu();
-        int count = windowMenu.getItemCount();
-        JMenuItem lastItem = windowMenu.getItem(count -1);
-        String name = SourceInfo.getShortName(w.getUrl());
-        for (int i = 5; i < count; i++) {
-            JMenuItem item = windowMenu.getItem(i);
-            if (item == null) continue; // separator
-            String text = item.getText();
-            //1 D:\foo.js
-            //2 D:\bar.js
-            int pos = text.indexOf(' ');
-            if (text.substring(pos + 1).equals(name)) {
-                windowMenu.remove(item);
-                // Cascade    [0]
-                // Tile       [1]
-                // -------    [2]
-                // Console    [3]
-                // -------    [4]
-                if (count == 6) {
-                    // remove the final separator
-                    windowMenu.remove(4);
-                } else {
-                    int j = i - 4;
-                    for (;i < count -1; i++) {
-                        JMenuItem thisItem = windowMenu.getItem(i);
-                        if (thisItem != null) {
-                            //1 D:\foo.js
-                            //2 D:\bar.js
-                            text = thisItem.getText();
-                            if (text.equals("More Windows...")) {
-                                break;
-                            } else {
-                                pos = text.indexOf(' ');
-                                thisItem.setText((char)('0' + j) + " " +
-                                                 text.substring(pos + 1));
-                                thisItem.setMnemonic('0' + j);
-                                j++;
-                            }
-                        }
-                    }
-                    if (count - 6 == 0 && lastItem != item) {
-                        if (lastItem.getText().equals("More Windows...")) {
-                            windowMenu.remove(lastItem);
-                        }
-                    }
-                }
-                break;
-            }
-        }
-        windowMenu.revalidate();
-    }
-
-    boolean stringIsCompilableUnit(String expr) {
-        Context cx = Context.enter();
-        boolean result = cx.stringIsCompilableUnit(expr);
-        cx.exit();
-        return result;
-    }
-
-    String eval(String expr) {
-        Context cx = getCurrentContext();
-        if (cx == null) return "undefined";
-        ContextData contextData = ContextData.get(cx);
-        ContextHelper helper = new ContextHelper();
-        helper.attach(cx);
-        if (frameIndex >= contextData.getFrameCount()) {
-            helper.reset();
-            return "undefined";
-        }
-        String resultString;
-        cx.setDebugger(null, null);
-        cx.setGeneratingDebug(false);
-        cx.setOptimizationLevel(-1);
-        boolean savedBreakNextLine = contextData.breakNextLine;
-        contextData.breakNextLine = false;
-        try {
-            Scriptable scope;
-            FrameHelper frame = contextData.getFrame(frameIndex);
-            scope = frame.getVariableObject();
-            Object result;
-            if (scope instanceof NativeCall) {
-                NativeCall call = (NativeCall)scope;
-                result = NativeGlobal.evalSpecial(cx, call,
-                                                  call.getThisObj(),
-                                                  new Object[]{expr},
-                                                  "", 1);
-            } else {
-                result = cx.evaluateString(scope, expr, "", 0, null);
-            }
-            if (result == Undefined.instance) {
-                result = "";
-            }
-            try {
-                resultString = ScriptRuntime.toString(result);
-            } catch (RuntimeException exc) {
-                resultString = result.toString();
-            }
-        } catch (Exception exc) {
-            resultString = exc.getMessage();
-        }
-        if (resultString == null) {
-            resultString = "null";
-        }
-        cx.setDebugger(this, contextData);
-        cx.setGeneratingDebug(true);
-        cx.setOptimizationLevel(-1);
-        contextData.breakNextLine = savedBreakNextLine;
-        helper.reset();
-        return resultString;
-    }
-
-    void Exit() {
-        // stop handling events
-        this.returnValue = EXIT;
-        // call the exit handler if any
-        if (exitAction != null) {
-            swingInvokeLater(exitAction);
-        }
-    }
-
-    java.util.Hashtable fileWindows = new java.util.Hashtable();
-    FileWindow currentWindow;
-    Object monitor = new Object();
-    Object swingMonitor = new Object();
-    int returnValue = -1;
-    boolean breakOnExceptions;
-    boolean breakOnEnter;
-    boolean breakOnReturn;
-
-    static void setResizeWeight(JSplitPane pane, double weight) {
-        // call through reflection for portability
-        // pre-1.3 JDK JSplitPane doesn't have this method
-        try {
-            Method m = JSplitPane.class.getMethod("setResizeWeight",
-                                                  new Class[]{double.class});
-            m.invoke(pane, new Object[]{new Double(weight)});
-        } catch (NoSuchMethodException exc) {
-        } catch (IllegalAccessException exc) {
-        } catch (java.lang.reflect.InvocationTargetException exc) {
-        }
-    }
-
-    java.util.Hashtable toplevels = new java.util.Hashtable();
-
-    boolean shouldDispatchTo(Component source) {
-        Component root = SwingUtilities.getRoot(source);
-        if (root == this) {
-            return true;
-        }
-        Enumeration e = toplevels.keys();
-        while (e.hasMoreElements()) {
-            Object key = e.nextElement();
-            JFrame frame = (JFrame)toplevels.get(key);
-            if (root == frame) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    void addTopLevel(String key, JFrame frame) {
-        if (frame != this) {
-            toplevels.put(key, frame);
-        }
-    }
-
-    JInternalFrame getFrameForUrl( URL url )
-    { 
-        JInternalFrame[] frames = desk.getAllFrames();
-        for (int i = 0; i < frames.length; i++) {
-           FileWindow w = (FileWindow)frames[i];
-           if ( url.toString().equals( w.getUrl() ) ) {
-               return w;
-               }
-           }
-        return null; 
-    } 
-    public void highlighLineInSelectedWindow(URL url, int lineNum ){
-        //FileWindow w = (FileWindow)getFrameForUrl( url );
-        FileWindow w = (FileWindow)getSelectedFrame();
-        if (w != null)
-        {
-            if ( lineNum > -1 )
-                swingInvoke(new SetFilePosition(this, w, lineNum ) );
-        }
-    }
-    public Object  runSelectedWindow( URL scriptUrl ) throws Exception
-    {
-        Object result = null;
-        FileWindow w = (FileWindow)getSelectedFrame();
-        //FileWindow w = (FileWindow)getFrameForUrl( scriptUrl );
-        w.toFront();
-        if (w != null)
-        {
-            Scriptable scope = w.db.getScope();
-            if (scope == null) 
-            {
-                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
-                result =  null;
-            } 
-            else 
-            {
-                String url = w.getUrl();
-                Thread executorThread = null;
-                if (url != null) 
-                {
-                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
-                    executor.run(); 
-                    result = executor.result;  
-                    if ( executor.exception != null )
-                    {
-                        throw executor.exception;
-                    }
-                }
-            }
-        }
-        return result;
-
-    }
-
-    //
-    // public interface
-    //
-
-    public Main(String title) {
-        super(title);
-        init();
-    }
-
-   /**
-    *  Toggle Break-on-Exception behavior
-    */
-    public void setBreakOnExceptions(boolean value) {
-        this.breakOnExceptions = value;
-    }
-
-   /**
-    *  Toggle Break-on-Enter behavior
-    */
-    public void setBreakOnEnter(boolean value) {
-        this.breakOnEnter = value;
-    }
-
-   /**
-    *  Toggle Break-on-Return behavior
-    */
-    public void setBreakOnReturn(boolean value) {
-        this.breakOnReturn = value;
-    }
-
-    /**
-     *
-     * Remove all breakpoints
-     */
-    public void clearAllBreakpoints() {
-        Enumeration e = sourceNames.elements();
-        while (e.hasMoreElements()) {
-            SourceInfo si = (SourceInfo)e.nextElement();
-            si.removeAllBreakpoints();
-        }
-    }
-
-   /**
-    *  Resume Execution
-    */
-    public void go()
-    {
-        returnValue = GO;
-        synchronized (monitor) {
-            this.returnValue = returnValue;
-            monitor.notifyAll();
-        }
-    }
-
-    /**
-     * Assign an object that can provide a Scriptable that will
-     * be used as the scope for loading scripts from files
-     * when the user selects "Open..." or "Run..."
-     */
-    public void setScopeProvider(ScopeProvider p) {
-        scopeProvider = p;
-    }
-
-    /**
-     * Assign a Runnable object that will be invoked when the user
-     * selects "Exit..." or closes the Debugger main window
-     */
-    public void setExitAction(Runnable r) {
-        exitAction = r;
-    }
-
-    /**
-     * Get an input stream to the Debugger's internal Console window
-     */
-
-    public InputStream getIn() {
-        return console.getIn();
-    }
-
-    /**
-     * Get an output stream to the Debugger's internal Console window
-     */
-
-    public PrintStream getOut() {
-        return console.getOut();
-    }
-
-    /**
-     * Get an error stream to the Debugger's internal Console window
-     */
-
-    public PrintStream getErr() {
-        return console.getErr();
-    }
-
-    public void openFile(URL scriptUrl, Scriptable scope, Runnable closeCallback ) {
-        if (scope == null) {
-            MessageDialogWrapper.showMessageDialog(this,
-                "Can't compile scripts: no scope available",
-                "Open", JOptionPane.ERROR_MESSAGE);
-        } else {
-            if (scriptUrl != null) {
-                try
-                {
-                    InputStreamReader reader = new InputStreamReader(scriptUrl.openStream()); 
-                    String fileName = null;
-                    if ( scriptUrl.getProtocol().startsWith("vnd.sun.star.") )
-                    {
-                        fileName = scriptUrl.toString();
-                    }
-                    else
-                    {
-                        fileName = scriptUrl.getPath();
-                    }
-                    officeScripts.addScript( fileName, scriptUrl, scope, closeCallback  );
-                    //new Thread(new OpenFile(this, scope, fileName, reader )).start();
-                    swingInvoke( new OpenFile(this, scope, fileName, reader ));
-                }
-                catch ( IOException e )
-                {
-                    MessageDialogWrapper.showMessageDialog(this,
-                        "Can't open stream for script: " + e.toString(),
-                        "Open", JOptionPane.ERROR_MESSAGE);
-                }
-            }
-        }
-        split1.setDividerLocation(1.0);
-    }
-
-
-    public void openFile(String fileName) {
-        Scriptable scope = getScope();
-        if (scope == null) {
-            MessageDialogWrapper.showMessageDialog(this,
-                "Can't compile scripts: no scope available",
-                "Open", JOptionPane.ERROR_MESSAGE);
-        } else {
-            if (fileName != null) {
-                new Thread(new OpenFile(this, scope, fileName)).start();
-            }
-        }
-        split1.setDividerLocation(1.0);
-    }
-
-    public void openStream(InputStream in) {
-        Scriptable scope = getScope();
-        if (scope == null) {
-            MessageDialogWrapper.showMessageDialog(this,
-                "Can't compile scripts: no scope available",
-                "Open", JOptionPane.ERROR_MESSAGE);
-        } else {
-            if (in != null) {
-                new Thread(new OpenFile(this, scope, null, new InputStreamReader(in))).start();
-            }
-        }
-        split1.setDividerLocation(1.0);
-        menubar.setSaveEnabled(false);
-    }
-
-    public static void main(String[] args) {
-        try {
-            mainThread = Thread.currentThread();
-            final Main sdb = new Main("Rhino JavaScript Debugger");
-            swingInvoke(new Runnable() {
-                    public void run() {
-                        sdb.pack();
-                        sdb.setSize(600, 460);
-                        sdb.setVisible(true);
-                    }
-                });
-            sdb.setExitAction(new Runnable() {
-                    public void run() {
-                        System.exit(0);
-                    }
-                });
-            System.setIn(sdb.getIn());
-            System.setOut(sdb.getOut());
-            System.setErr(sdb.getErr());
-            Context.addContextListener(sdb);
-            sdb.setScopeProvider(new ScopeProvider() {
-                    public Scriptable getScope() {
-                        return org.mozilla.javascript.tools.shell.Main.getScope();
-                    }
-                });
-            org.mozilla.javascript.tools.shell.Main.exec(args);
-        } catch (Exception exc) {
-            exc.printStackTrace();
-        }
-    }
-
-// patched Office specific interface
-
-    OfficeScriptInfo officeScripts = new OfficeScriptInfo();
-
-    void removeScript( String url )
-    {
-        // Remove the FileWindow from list of open sources
-        fileWindows.remove( url );
-
-        // Remove sourceInfo from sourceNames, ensures that
-        // breakpoints etc are deleted
-        synchronized (sourceNames) {
-            sourceNames.remove( url );
-        }
-        // Removes scriptItems for the script, ensures that a new open ( from openFile )
-        // will succeed, openFile should open file but fails due to fact that 
-        synchronized ( scriptItems ) 
-        {   
-            Iterator iter = scriptItems.entrySet().iterator();
-            while ( iter.hasNext() )
-            {
-                Map.Entry me = ( Map.Entry )iter.next();
-                ScriptItem item = (ScriptItem)me.getValue();
-                SourceInfo si =   item.getSourceInfo();
-                if ( si.getUrl().equals( url ) )
-                {
-                    //match
-                    scriptItems.remove( me.getKey() );
-                    break;
-                }
-            }
-        }
-        officeScripts.deleteScript( url );
-    }
-
-
-    ScriptItem getScriptItem(DebuggableScript fnOrScript) {
-        ScriptItem item = (ScriptItem)scriptItems.get(fnOrScript);
-        if (item == null) {
-            String url = getNormilizedUrl(fnOrScript);
-            SourceInfo si = (SourceInfo)sourceNames.get(url);
-            if (si == null) {
-                if (!fnOrScript.isGeneratedScript()) {
-                    // Not eval or Function, try to load it from URL
-                    String source = null;
-                    try {
-                        InputStream is = openSource(url);
-                        try { source = readSource(is); }
-                        finally { is.close(); }
-                    } catch (IOException ex) {
-                        System.err.println
-                            ("Failed to load source from "+url+": "+ ex);
-                    }
-                    if (source != null) {
-                        si = registerSource(url, source);
-                    }
-                }
-            }
-            if (si != null) {
-                item = registerScript(si, fnOrScript);
-            }
-        }
-        
-        return item;
-    }
-
-    public void showScriptWindow(URL url ){
-        String key = url.getPath();
-        if ( url.getProtocol().startsWith("vnd.sun.star") )
-        {
-            key = url.toString();
-        }
-        FileWindow w = (FileWindow)getFileWindow( key );
-        if ( w != null )
-        {
-            //w.maximize();
-            desk.getDesktopManager().deiconifyFrame(w);
-            desk.getDesktopManager().activateFrame(w);
-            w.show();
-            w.toFront();
-        }
-    }
-
-    public void highlighLineInScriptWindow(URL url, int lineNum ){
-        String key = url.getPath();
-        if ( url.getProtocol().startsWith("vnd.sun.star") )
-        {
-            key = url.getPath();
-        }
-        FileWindow w = (FileWindow)getFileWindow( key );
-        if (w != null)
-        {
-            if ( lineNum > -1 )
-                swingInvoke(new SetFilePosition(this, w, lineNum ) );
-        }
-    }
-    public Object runScriptWindow( URL scriptUrl ) throws Exception
-    {
-        String key = scriptUrl.getPath();
-        if ( scriptUrl.getProtocol().startsWith("vnd.sun.star") )
-        {
-            key = scriptUrl.toString();
-        }
-        FileWindow w = (FileWindow)getFileWindow( key );
-        Object result = null;
-        w.toFront();
-        if (w != null)
-        {
-            //Scriptable scope = w.db.getScope();
-            Scriptable scope = w.db.officeScripts.getScriptScope( key );
-            if (scope == null) 
-            {
-                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
-                result =  null;
-            } 
-            else 
-            {
-                String url = w.getUrl();
-                Thread executorThread = null;
-                if (url != null) 
-                {
-                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
-                    executor.run(); 
-                    result = executor.result;  
-                    if ( executor.exception != null )
-                    {
-                        throw executor.exception;
-                    }
-                }
-            }
-        }
-        return result;
-
-    }
-
-    public boolean isModified( URL url ) 
-    {
-        String key = url.getPath();
-        if ( url.getProtocol().startsWith("vnd.sun.star") )
-        {
-            key = url.toString();
-        }
-        FileWindow w = (FileWindow)getFileWindow( key );
-        return w.isModified();
-    }
-
-    public String getText( URL url )
-    {
-        String key = url.toString();
-        if ( url.getProtocol().startsWith("vnd.sun.star") )
-        {
-            key = url.toString();
-        }
-        FileWindow w = (FileWindow)getFileWindow( key );
-        return w.getText();
-    }
-
-
-}
-
Index: rhino/NativeJavaPackage.java
===================================================================
RCS file: rhino/NativeJavaPackage.java
diff -N rhino/NativeJavaPackage.java
--- rhino/NativeJavaPackage.java	22 Oct 2004 14:14:20 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,299 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-1999 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Norris Boyd
- * Frank Mitchell
- * Mike Shaver
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript;
-
-import java.lang.reflect.*;
-
-/**
- * This class reflects Java packages into the JavaScript environment.  We
- * lazily reflect classes and subpackages, and use a caching/sharing
- * system to ensure that members reflected into one JavaPackage appear
- * in all other references to the same package (as with Packages.java.lang
- * and java.lang).
- *
- * @author Mike Shaver
- * @see NativeJavaArray
- * @see NativeJavaObject
- * @see NativeJavaClass
- */
-
-public class NativeJavaPackage extends ScriptableObject {
-
-    // we know these are packages so we can skip the class check
-    // note that this is ok even if the package isn't present.
-    static final String[] commonPackages = {
-        "java.lang",
-        "java.lang.reflect",
-        "java.io",
-        "java.math",
-        "java.util",
-        "java.util.zip",
-        "java.text",
-        "java.text.resources",
-        "java.applet",
-    };
-
-    public static class TopLevelPackage extends NativeJavaPackage
-                                        implements Function
-    {
-        public TopLevelPackage() {
-            super("");
-        }
-
-        public Object call(Context cx, Scriptable scope, Scriptable thisObj,
-                           Object[] args)
-            throws JavaScriptException
-        {
-            return construct(cx, scope, args);
-        }
-
-        public Scriptable construct(Context cx, Scriptable scope, Object[] args)
-            throws JavaScriptException
-        {
-            ClassLoader loader = getClassLoaderFromArgs(args);
-            if (loader == null) {
-                Context.reportRuntimeError0("msg.not.classloader");
-                return null;
-            }
-            return new NativeJavaPackage("", loader);
-        }
-
-        private ClassLoader getClassLoaderFromArgs(Object[] args) {
-            if (args.length < 1) {
-                return null;
-            }
-            Object arg = args[0];
-            if (arg instanceof Wrapper) {
-                arg = ((Wrapper)arg).unwrap();
-            }
-            if (!(arg instanceof ClassLoader)) {
-                return null;
-            }
-            return (ClassLoader) arg;
-        }
-
-    }
-    public static Scriptable init(Scriptable scope)
-        throws PropertyException
-    {
-        NativeJavaPackage packages = new NativeJavaPackage.TopLevelPackage();
-        packages.setPrototype(getObjectPrototype(scope));
-        packages.setParentScope(scope);
-
-        // We want to get a real alias, and not a distinct JavaPackage
-        // with the same packageName, so that we share classes and packages
-        // that are underneath.
-        NativeJavaPackage javaAlias = (NativeJavaPackage)packages.get("java",
-                                                                      packages);
-
-        // It's safe to downcast here since initStandardObjects takes
-        // a ScriptableObject.
-        ScriptableObject global = (ScriptableObject) scope;
-
-        global.defineProperty("Packages", packages, ScriptableObject.DONTENUM);
-        global.defineProperty("java", javaAlias, ScriptableObject.DONTENUM);
-
-        for (int i = 0; i < commonPackages.length; i++)
-            packages.forcePackage(commonPackages[i]);
-
-        Method[] m = FunctionObject.findMethods(NativeJavaPackage.class,
-                                                "jsFunction_getClass");
-        FunctionObject f = new FunctionObject("getClass", m[0], global);
-        global.defineProperty("getClass", f, ScriptableObject.DONTENUM);
-
-        // I think I'm supposed to return the prototype, but I don't have one.
-        return packages;
-    }
-
-    // set up a name which is known to be a package so we don't
-    // need to look for a class by that name
-    void forcePackage(String name) {
-        NativeJavaPackage pkg;
-        int end = name.indexOf('.');
-        if (end == -1)
-            end = name.length();
-
-        String id = name.substring(0, end);
-        Object cached = super.get(id, this);
-        if (cached != null && cached instanceof NativeJavaPackage) {
-            pkg = (NativeJavaPackage) cached;
-        } else {
-            String newPackage = packageName.length() == 0
-                                ? id
-                                : packageName + "." + id;
-            pkg = new NativeJavaPackage(newPackage, classLoader);
-            pkg.setParentScope(this);
-            pkg.setPrototype(this.prototype);
-            super.put(id, this, pkg);
-        }
-        if (end < name.length())
-            pkg.forcePackage(name.substring(end+1));
-    }
-
-    public NativeJavaPackage(String packageName) {
-        this(packageName, null);
-    }
-
-    public NativeJavaPackage(String packageName, ClassLoader classLoader) {
-        this.packageName = packageName;
-        if (classLoader != null) {
-            this.classLoader = classLoader;
-        } else {
-            this.classLoader = Context.getContext().getApplicationClassLoader();
-        }
-    }
-
-    public String getClassName() {
-        return "JavaPackage";
-    }
-
-    public boolean has(String id, Scriptable start) {
-        return true;
-    }
-
-    public boolean has(int index, Scriptable start) {
-        return false;
-    }
-
-    public void put(String id, Scriptable start, Object value) {
-        // Can't add properties to Java packages.  Sorry.
-    }
-
-    public void put(int index, Scriptable start, Object value) {
-        throw Context.reportRuntimeError0("msg.pkg.int");
-    }
-
-    public Object get(String id, Scriptable start) {
-        return getPkgProperty(id, start, true);
-    }
-
-    public Object get(int index, Scriptable start) {
-        return NOT_FOUND;
-    }
-
-    synchronized Object getPkgProperty(String name, Scriptable start,
-                                       boolean createPkg)
-    {
-        Object cached = super.get(name, start);
-        if (cached != NOT_FOUND)
-            return cached;
-
-        String newPackage = packageName.length() == 0
-                            ? name
-                            : packageName + '.' + name;
-        Context cx = Context.getContext();
-        ClassShutter shutter = cx.getClassShutter();
-        Scriptable newValue = null;
-        if (shutter == null || shutter.visibleToScripts(newPackage)) {
-            Class cl = findClass(classLoader, newPackage);
-            if (cl != null) {
-                newValue = new NativeJavaClass(getTopLevelScope(this), cl);
-                newValue.setParentScope(this);
-                newValue.setPrototype(this.prototype);
-            }
-        }
-        if (newValue == null && createPkg) {
-            NativeJavaPackage pkg = new NativeJavaPackage(newPackage,
-                                                          classLoader);
-            pkg.setParentScope(this);
-            pkg.setPrototype(this.prototype);
-            newValue = pkg;
-        }
-        if (newValue != null) {
-            // Make it available for fast lookup and sharing of
-            // lazily-reflected constructors and static members.
-            super.put(name, start, newValue);
-        }
-        return newValue;
-    }
-
-    public Object getDefaultValue(Class ignored) {
-        return toString();
-    }
-
-    public String toString() {
-        return "[JavaPackage " + packageName + "]";
-    }
-
-    public static Scriptable jsFunction_getClass(Context cx,
-                                                 Scriptable thisObj,
-                                                 Object[] args,
-                                                 Function funObj)
-    {
-        if (args.length > 0  && args[0] instanceof Wrapper) {
-            Scriptable result = getTopLevelScope(thisObj);
-            Class cl = ((Wrapper) args[0]).unwrap().getClass();
-            // Evaluate the class name by getting successive properties of
-            // the string to find the appropriate NativeJavaClass object
-            String name = "Packages." + cl.getName();
-            int offset = 0;
-            for (;;) {
-                int index = name.indexOf('.', offset);
-                String propName = index == -1
-                                  ? name.substring(offset)
-                                  : name.substring(offset, index);
-                Object prop = result.get(propName, result);
-                if (!(prop instanceof Scriptable))
-                    break;  // fall through to error
-                result = (Scriptable) prop;
-                if (index == -1)
-                    return result;
-                offset = index+1;
-            }
-        }
-        throw Context.reportRuntimeError(
-            Context.getMessage0("msg.not.java.obj"));
-    }
-
-    private static Class findClass(ClassLoader loader, String className) {
-        Class cl = null;
-        if (loader != null) {
-            try { cl = loader.loadClass(className); }
-            catch (ClassNotFoundException ex) { }
-            catch (SecurityException ex) { }
-        } else {
-            try { cl = Class.forName(className); }
-            catch (ClassNotFoundException ex) { }
-            catch (SecurityException ex) { }
-        }
-        return cl;
-    }
-
-    private String packageName;
-    private ClassLoader classLoader;
-}
Index: rhino/OfficeScriptInfo.java
===================================================================
RCS file: rhino/OfficeScriptInfo.java
diff -N rhino/OfficeScriptInfo.java
--- rhino/OfficeScriptInfo.java	22 Oct 2004 14:14:31 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,164 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-
-package org.mozilla.javascript.tools.debugger;
-import java.net.URL;
-import java.util.Hashtable;
-import org.mozilla.javascript.Scriptable;
-
-public class OfficeScriptInfo
-{
-    private Hashtable loadedSFScripts = new Hashtable();
-   
-    public void addScript( URL url, Scriptable scope, Runnable closeCallback )
-    {
-        addScript( url.toString(), url, scope, closeCallback );
-    }
-
-    public void addScript( String key, URL url, Scriptable scope, Runnable closeCallback )
-    {
-        SFScriptInfo si = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( si == null )
-        {
-            si = new SFScriptInfo();
-            si.url = url;
-            si.scope = scope; 
-            si.closeCallback = closeCallback; 
-            loadedSFScripts.put( key, si );
-        }  
-    }   
-
-    public void deleteScript( String key )
-    {
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.remove( key );
-        if ( info != null )
-        {
-            if ( info.closeCallback != null )
-            {
-                System.out.println("** In removeSFScriptInfo  have callback for " + key );
-                info.closeCallback.run(); // really need to do this in seperate thread????
-            }
-        }
-    }
-
-    public Scriptable getScriptScope( String key )
-    {
-        Scriptable result = null;
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( info != null )
-        {
-            result = info.scope;
-        }
-        return result;
-    } 
-  
-    public URL getScriptUrl( String key )
-    {
-        URL result = null;
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( info != null )
-        {
-            result = info.url;
-        }
-        return result;
-    } 
-    public boolean hasScript( String key )
-    {
-        boolean result = true;
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( info == null )
-        {
-            result = false;
-        }      
-        return result;
-    } 
-
-    public void setScriptRunning( String key, boolean running )
-    {
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( info != null )
-        {
-            info.isExecuting = running;
-        }
-    }
-
-    public boolean isScriptRunning( String key )
-    {
-        boolean result = false;
-        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
-        if ( info != null )
-        {
-            result = info.isExecuting;
-        }
-        return result;
-    }
-
-    
-  
-    class SFScriptInfo
-    {
-        Scriptable scope;
-        boolean isExecuting;
-        URL url;
-        Runnable closeCallback;
-    }
-}
Index: rhino/README
===================================================================
RCS file: /cvs/external/rhino/README,v
retrieving revision 1.2
retrieving revision 1.2.8.1
diff -u -p -r1.2 -r1.2.8.1
--- rhino/README	22 Oct 2004 14:14:43 -0000	1.2
+++ rhino/README	7 Feb 2005 13:53:26 -0000	1.2.8.1
@@ -5,11 +5,7 @@ JavaScript interpreter, available under 
 In addition, to support the debugging of scripts contained in OpenOffice.org
 documents, we have modified the Java source file Main.java.
 
-The modified source code is rebuilt and repackaged in the Rhino js.jar file
-before being deliver to the OpenOffice.org solver. The modified source is
-also available from the OpenOffice.org website at:
-
-http://framework.openoffice.org/source/browse/framework/scripting/examples/java/debugger/rhino/Main.java
-
-In order to allow Java classloading to work properly (issue 30929)
-we have included versions of a number of files from Rhino 1.5R4.1
+The Rhino source tarball is patched with the modified code. The Rhino
+Jar file (js.jar) is then built and delivered to the solver. The file
+rhino15R4.patch contains the changes made in order to build Rhino. The
+patch was generated using the command: diff -wurN
Index: rhino/ScriptRuntime.java
===================================================================
RCS file: rhino/ScriptRuntime.java
diff -N rhino/ScriptRuntime.java
--- rhino/ScriptRuntime.java	22 Oct 2004 14:14:54 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,2139 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * The contents of this file are subject to the Netscape Public
- * License Version 1.1 (the "License"); you may not use this file
- * except in compliance with the License. You may obtain a copy of
- * the License at http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS
- * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
- * implied. See the License for the specific language governing
- * rights and limitations under the License.
- *
- * The Original Code is Rhino code, released
- * May 6, 1999.
- *
- * The Initial Developer of the Original Code is Netscape
- * Communications Corporation.  Portions created by Netscape are
- * Copyright (C) 1997-2000 Netscape Communications Corporation. All
- * Rights Reserved.
- *
- * Contributor(s):
- * Patrick Beard
- * Norris Boyd
- * Igor Bukanov
- * Roger Lawrence
- * Frank Mitchell
- * Andrew Wason
- *
- * Alternatively, the contents of this file may be used under the
- * terms of the GNU Public License (the "GPL"), in which case the
- * provisions of the GPL are applicable instead of those above.
- * If you wish to allow use of your version of this file only
- * under the terms of the GPL and not to allow others to use your
- * version of this file under the NPL, indicate your decision by
- * deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL.  If you do not delete
- * the provisions above, a recipient may use your version of this
- * file under either the NPL or the GPL.
- */
-
-package org.mozilla.javascript;
-
-import java.lang.reflect.*;
-
-/**
- * This is the class that implements the runtime.
- *
- * @author Norris Boyd
- */
-
-public class ScriptRuntime {
-
-    /**
-     * No instances should be created.
-     */
-    protected ScriptRuntime() {
-    }
-
-    /*
-     * There's such a huge space (and some time) waste for the Foo.class
-     * syntax: the compiler sticks in a test of a static field in the
-     * enclosing class for null and the code for creating the class value.
-     * It has to do this since the reference has to get pushed off til
-     * executiontime (i.e. can't force an early load), but for the
-     * 'standard' classes - especially those in java.lang, we can trust
-     * that they won't cause problems by being loaded early.
-     */
-
-    public final static Class UndefinedClass = Undefined.class;
-    public final static Class ScriptableClass = Scriptable.class;
-    public final static Class StringClass = String.class;
-    public final static Class NumberClass = Number.class;
-    public final static Class BooleanClass = Boolean.class;
-    public final static Class ByteClass = Byte.class;
-    public final static Class ShortClass = Short.class;
-    public final static Class IntegerClass = Integer.class;
-    public final static Class LongClass = Long.class;
-    public final static Class FloatClass = Float.class;
-    public final static Class DoubleClass = Double.class;
-    public final static Class CharacterClass = Character.class;
-    public final static Class ObjectClass = Object.class;
-    public final static Class FunctionClass = Function.class;
-    public final static Class ClassClass = Class.class;
-    public final static Class SerializableClass = java.io.Serializable.class;
-
-    // Can not use .class as Comparable is only since JDK 1.2
-    public final static Class
-        ComparableClass = getClassOrNull("java.lang.Comparable");
-
-    /**
-     * Convert the value to a boolean.
-     *
-     * See ECMA 9.2.
-     */
-    public static boolean toBoolean(Object val) {
-        if (val == null)
-            return false;
-        if (val instanceof Boolean)
-            return ((Boolean) val).booleanValue();
-        if (val instanceof Scriptable) {
-            if (Context.getContext().isVersionECMA1()) {
-                // pure ECMA
-                return val != Undefined.instance;
-            }
-            // ECMA extension
-            val = ((Scriptable) val).getDefaultValue(BooleanClass);
-            if (val instanceof Scriptable)
-                throw errorWithClassName("msg.primitive.expected", val);
-            if (val instanceof Boolean)
-                return ((Boolean) val).booleanValue();
-            // fall through
-        }
-        if (val instanceof String)
-            return ((String) val).length() != 0;
-        if (val instanceof Number) {
-            double d = ((Number) val).doubleValue();
-            return (d == d && d != 0.0);
-        }
-        throw errorWithClassName("msg.invalid.type", val);
-    }
-
-    public static boolean toBoolean(Object[] args, int index) {
-        return (index < args.length) ? toBoolean(args[index]) : false;
-    }
-    /**
-     * Convert the value to a number.
-     *
-     * See ECMA 9.3.
-     */
-    public static double toNumber(Object val) {
-        if (val == null)
-            return +0.0;
-        if (val instanceof Number)
-            return ((Number) val).doubleValue();
-        if (val instanceof Scriptable) {
-            val = ((Scriptable) val).getDefaultValue(NumberClass);
-            if (val != null && val instanceof Scriptable)
-                throw errorWithClassName("msg.primitive.expected", val);
-            if (val instanceof Number)
-                return ((Number) val).doubleValue();
-            // fall through
-        }
-        if (val instanceof String)
-            return toNumber((String) val);
-        if (val instanceof Boolean)
-            return ((Boolean) val).booleanValue() ? 1 : +0.0;
-        throw errorWithClassName("msg.invalid.type", val);
-    }
-
-    public static double toNumber(Object[] args, int index) {
-        return (index < args.length) ? toNumber(args[index]) : NaN;
-    }
-
-    // This definition of NaN is identical to that in java.lang.Double
-    // except that it is not final. This is a workaround for a bug in
-    // the Microsoft VM, versions 2.01 and 3.0P1, that causes some uses
-    // (returns at least) of Double.NaN to be converted to 1.0.
-    // So we use ScriptRuntime.NaN instead of Double.NaN.
-    public static double NaN = 0.0d / 0.0;
-    public static Double NaNobj = new Double(0.0d / 0.0);
-
-    // A similar problem exists for negative zero.
-    public static double negativeZero = -0.0;
-
-    /*
-     * Helper function for toNumber, parseInt, and TokenStream.getToken.
-     */
-    static double stringToNumber(String s, int start, int radix) {
-        char digitMax = '9';
-        char lowerCaseBound = 'a';
-        char upperCaseBound = 'A';
-        int len = s.length();
-        if (radix < 10) {
-            digitMax = (char) ('0' + radix - 1);
-        }
-        if (radix > 10) {
-            lowerCaseBound = (char) ('a' + radix - 10);
-            upperCaseBound = (char) ('A' + radix - 10);
-        }
-        int end;
-        double sum = 0.0;
-        for (end=start; end < len; end++) {
-            char c = s.charAt(end);
-            int newDigit;
-            if ('0' <= c && c <= digitMax)
-                newDigit = c - '0';
-            else if ('a' <= c && c < lowerCaseBound)
-                newDigit = c - 'a' + 10;
-            else if ('A' <= c && c < upperCaseBound)
-                newDigit = c - 'A' + 10;
-            else
-                break;
-            sum = sum*radix + newDigit;
-        }
-        if (start == end) {
-            return NaN;
-        }
-        if (sum >= 9007199254740992.0) {
-            if (radix == 10) {
-                /* If we're accumulating a decimal number and the number
-                 * is >= 2^53, then the result from the repeated multiply-add
-                 * above may be inaccurate.  Call Java to get the correct
-                 * answer.
-                 */
-                try {
-                    return Double.valueOf(s.substring(start, end)).doubleValue();
-                } catch (NumberFormatException nfe) {
-                    return NaN;
-                }
-            } else if (radix == 2 || radix == 4 || radix == 8 ||
-                       radix == 16 || radix == 32)
-            {
-                /* The number may also be inaccurate for one of these bases.
-                 * This happens if the addition in value*radix + digit causes
-                 * a round-down to an even least significant mantissa bit
-                 * when the first dropped bit is a one.  If any of the
-                 * following digits in the number (which haven't been added
-                 * in yet) are nonzero then the correct action would have
-                 * been to round up instead of down.  An example of this
-                 * occurs when reading the number 0x1000000000000081, which
-                 * rounds to 0x1000000000000000 instead of 0x1000000000000100.
-                 */
-                BinaryDigitReader bdr = new BinaryDigitReader(radix, s, start, end);
-                int bit;
-                sum = 0.0;
-
-                /* Skip leading zeros. */
-                do {
-                    bit = bdr.getNextBinaryDigit();
-                } while (bit == 0);
-
-                if (bit == 1) {
-                    /* Gather the 53 significant bits (including the leading 1) */
-                    sum = 1.0;
-                    for (int j = 52; j != 0; j--) {
-                        bit = bdr.getNextBinaryDigit();
-                        if (bit < 0)
-                            return sum;
-                        sum = sum*2 + bit;
-                    }
-                    /* bit54 is the 54th bit (the first dropped from the mantissa) */
-                    int bit54 = bdr.getNextBinaryDigit();
-                    if (bit54 >= 0) {
-                        double factor = 2.0;
-                        int sticky = 0;  /* sticky is 1 if any bit beyond the 54th is 1 */
-                        int bit3;
-
-                        while ((bit3 = bdr.getNextBinaryDigit()) >= 0) {
-                            sticky |= bit3;
-                            factor *= 2;
-                        }
-                        sum += bit54 & (bit | sticky);
-                        sum *= factor;
-                    }
-                }
-            }
-            /* We don't worry about inaccurate numbers for any other base. */
-        }
-        return sum;
-    }
-
-
-    /**
-     * ToNumber applied to the String type
-     *
-     * See ECMA 9.3.1
-     */
-    public static double toNumber(String s) {
-        int len = s.length();
-        int start = 0;
-        char startChar;
-        for (;;) {
-            if (start == len) {
-                // Empty or contains only whitespace
-                return +0.0;
-            }
-            startChar = s.charAt(start);
-            if (!Character.isWhitespace(startChar))
-                break;
-            start++;
-        }
-
-        if (startChar == '0' && start+2 < len &&
-            Character.toLowerCase(s.charAt(start+1)) == 'x')
-            // A hexadecimal number
-            return stringToNumber(s, start + 2, 16);
-
-        if ((startChar == '+' || startChar == '-') && start+3 < len &&
-            s.charAt(start+1) == '0' &&
-            Character.toLowerCase(s.charAt(start+2)) == 'x') {
-            // A hexadecimal number
-            double val = stringToNumber(s, start + 3, 16);
-            return startChar == '-' ? -val : val;
-        }
-
-        int end = len - 1;
-        char endChar;
-        while (Character.isWhitespace(endChar = s.charAt(end)))
-            end--;
-        if (endChar == 'y') {
-            // check for "Infinity"
-            if (startChar == '+' || startChar == '-')
-                start++;
-            if (start + 7 == end && s.regionMatches(start, "Infinity", 0, 8))
-                return startChar == '-'
-                    ? Double.NEGATIVE_INFINITY
-                    : Double.POSITIVE_INFINITY;
-            return NaN;
-        }
-        // A non-hexadecimal, non-infinity number:
-        // just try a normal floating point conversion
-        String sub = s.substring(start, end+1);
-        if (MSJVM_BUG_WORKAROUNDS) {
-            // The MS JVM will accept non-conformant strings
-            // rather than throwing a NumberFormatException
-            // as it should.
-            for (int i=sub.length()-1; i >= 0; i--) {
-                char c = sub.charAt(i);
-                if (('0' <= c && c <= '9') || c == '.' ||
-                    c == 'e' || c == 'E'  ||
-                    c == '+' || c == '-')
-                    continue;
-                return NaN;
-            }
-        }
-        try {
-            return Double.valueOf(sub).doubleValue();
-        } catch (NumberFormatException ex) {
-            return NaN;
-        }
-    }
-
-    /**
-     * Helper function for builtin objects that use the varargs form.
-     * ECMA function formal arguments are undefined if not supplied;
-     * this function pads the argument array out to the expected
-     * length, if necessary.
-     */
-    public static Object[] padArguments(Object[] args, int count) {
-        if (count < args.length)
-            return args;
-
-        int i;
-        Object[] result = new Object[count];
-        for (i = 0; i < args.length; i++) {
-            result[i] = args[i];
-        }
-
-        for (; i < count; i++) {
-            result[i] = Undefined.instance;
-        }
-
-        return result;
-    }
-
-    /* Work around Microsoft Java VM bugs. */
-    private final static boolean MSJVM_BUG_WORKAROUNDS = true;
-
-    /**
-     * For escaping strings printed by object and array literals; not quite
-     * the same as 'escape.'
-     */
-    public static String escapeString(String s) {
-
-        StringBuffer sb = null;
-
-        for(int i = 0, L = s.length(); i != L; ++i) {
-            int c = s.charAt(i);
-
-            if (' ' <= c && c <= '~' && c != '"' && c != '\\') {
-                // an ordinary print character (like C isprint()) and not "
-                // or \ . Note single quote ' is not escaped
-                if (sb != null) {
-                    sb.append((char)c);
-                }
-                continue;
-            }
-            if (sb == null) {
-                sb = new StringBuffer(L + 3);
-                sb.append(s);
-                sb.setLength(i);
-            }
-
-            int escape = -1;
-            switch (c) {
-                case '\b':  escape = 'b';  break;
-                case '\f':  escape = 'f';  break;
-                case '\n':  escape = 'n';  break;
-                case '\r':  escape = 'r';  break;
-                case '\t':  escape = 't';  break;
-                case 0xb:   escape = 'v';  break; // Java lacks \v.
-                case '"':   escape = '"';  break;
-                case ' ':   escape = ' ';  break;
-                case '\\':  escape = '\\'; break;
-            }
-            if (escape >= 0) {
-                // an \escaped sort of character
-                sb.append('\\');
-                sb.append((char)escape);
-            } else {
-                int hexSize;
-                if (c < 256) {
-                    // 2-digit hex
-                    sb.append("\\x");
-                    hexSize = 2;
-                } else {
-                    // Unicode.
-                    sb.append("\\u");
-                    hexSize = 4;
-                }
-                // append hexadecimal form of c left-padded with 0
-                for (int shift = (hexSize - 1) * 4; shift >= 0; shift -= 4) {
-                    int digit = 0xf & (c >> shift);
-                    int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
-                    sb.append((char)hc);
-                }
-            }
-        }
-
-        return (sb == null) ? s : sb.toString();
-    }
-
-    /**
-     * Convert the value to a string.
-     *
-     * See ECMA 9.8.
-     */
-    public static String toString(Object val) {
-        for (;;) {
-            if (val == null)
-                return "null";
-            if (val instanceof Scriptable) {
-                val = ((Scriptable) val).getDefaultValue(StringClass);
-                if (val != Undefined.instance && val instanceof Scriptable) {
-                    throw errorWithClassName("msg.primitive.expected", val);
-                }
-                continue;
-            }
-            if (val instanceof Number) {
-                // XXX should we just teach NativeNumber.stringValue()
-                // about Numbers?
-                return numberToString(((Number) val).doubleValue(), 10);
-            }
-            return val.toString();
-        }
-    }
-
-    public static String toString(Object[] args, int index) {
-        return (index < args.length) ? toString(args[index]) : "undefined";
-    }
-
-    /**
-     * Optimized version of toString(Object) for numbers.
-     */
-    public static String toString(double val) {
-        return numberToString(val, 10);
-    }
-
-    public static String numberToString(double d, int base) {
-        if (d != d)
-            return "NaN";
-        if (d == Double.POSITIVE_INFINITY)
-            return "Infinity";
-        if (d == Double.NEGATIVE_INFINITY)
-            return "-Infinity";
-        if (d == 0.0)
-            return "0";
-
-        if ((base < 2) || (base > 36)) {
-            throw Context.reportRuntimeError1(
-                "msg.bad.radix", Integer.toString(base));
-        }
-
-        if (base != 10) {
-            return DToA.JS_dtobasestr(base, d);
-        } else {
-            StringBuffer result = new StringBuffer();
-            DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
-            return result.toString();
-        }
-
-    }
-
-    // ALERT: should it be deprecated ?
-    public static Scriptable toObject(Scriptable scope, Object val) {
-        return toObject(Context.getContext(), scope, val, null);
-    }
-
-    // ALERT: should it be deprecated ?
-    public static Scriptable toObject(Scriptable scope, Object val,
-                                      Class staticClass)
-    {
-        return toObject(Context.getContext(), scope, val, staticClass);
-    }
-
-    /**
-     * Convert the value to an object.
-     *
-     * See ECMA 9.9.
-     */
-    public static Scriptable toObject(Context cx, Scriptable scope, Object val)
-    {
-        return toObject(cx, scope, val, null);
-    }
-
-    public static Scriptable toObject(Context cx, Scriptable scope, Object val,
-                                      Class staticClass)
-    {
-        if (val == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        if (val instanceof Scriptable) {
-            if (val == Undefined.instance) {
-                throw NativeGlobal.typeError0("msg.undef.to.object", scope);
-            }
-            return (Scriptable) val;
-        }
-        String className = val instanceof String ? "String" :
-                           val instanceof Number ? "Number" :
-                           val instanceof Boolean ? "Boolean" :
-                           null;
-
-        if (className == null) {
-            // Extension: Wrap as a LiveConnect object.
-            Object wrapped = cx.getWrapFactory().
-                                wrap(cx, scope, val, staticClass);
-            if (wrapped instanceof Scriptable)
-                return (Scriptable) wrapped;
-            throw errorWithClassName("msg.invalid.type", val);
-        }
-
-        Object[] args = { val };
-        scope = ScriptableObject.getTopLevelScope(scope);
-        Scriptable result = newObject(cx, scope, className, args);
-        return result;
-    }
-
-    public static Scriptable newObject(Context cx, Scriptable scope,
-                                       String constructorName, Object[] args)
-    {
-        scope = ScriptableObject.getTopLevelScope(scope);
-        Function ctor = getExistingCtor(cx, scope, constructorName);
-        try {
-            if (args == null) { args = ScriptRuntime.emptyArgs; }
-            return ctor.construct(cx, scope, args);
-        } catch (JavaScriptException e) {
-            throw cx.reportRuntimeError(e.getMessage());
-        }
-    }
-
-    /**
-     *
-     * See ECMA 9.4.
-     */
-    public static double toInteger(Object val) {
-        return toInteger(toNumber(val));
-    }
-
-    // convenience method
-    public static double toInteger(double d) {
-        // if it's NaN
-        if (d != d)
-            return +0.0;
-
-        if (d == 0.0 ||
-            d == Double.POSITIVE_INFINITY ||
-            d == Double.NEGATIVE_INFINITY)
-            return d;
-
-        if (d > 0.0)
-            return Math.floor(d);
-        else
-            return Math.ceil(d);
-    }
-
-    public static double toInteger(Object[] args, int index) {
-        return (index < args.length) ? toInteger(args[index]) : +0.0;
-    }
-
-    /**
-     *
-     * See ECMA 9.5.
-     */
-    public static int toInt32(Object val) {
-        // short circuit for common small values; TokenStream
-        // returns them as Bytes.
-        if (val instanceof Byte)
-            return ((Number)val).intValue();
-
-        return toInt32(toNumber(val));
-    }
-
-    public static int toInt32(Object[] args, int index) {
-        return (index < args.length) ? toInt32(args[index]) : 0;
-    }
-
-    public static int toInt32(double d) {
-        int id = (int)d;
-        if (id == d) {
-            // This covers -0.0 as well
-            return id;
-        }
-
-        if (d != d
-            || d == Double.POSITIVE_INFINITY
-            || d == Double.NEGATIVE_INFINITY)
-        {
-            return 0;
-        }
-
-        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
-
-        double two32 = 4294967296.0;
-        d = Math.IEEEremainder(d, two32);
-        // (double)(long)d == d should hold here
-
-        long l = (long)d;
-        // returning (int)d does not work as d can be outside int range
-        // but the result must always be 32 lower bits of l
-        return (int)l;
-    }
-
-    /**
-     *
-     * See ECMA 9.6.
-     */
-
-    // must return long to hold an _unsigned_ int
-    public static long toUint32(double d) {
-        long l = (long)d;
-        if (l == d) {
-            // This covers -0.0 as well
-            return l & 0xffffffffL;
-        }
-
-        if (d != d
-            || d == Double.POSITIVE_INFINITY
-            || d == Double.NEGATIVE_INFINITY)
-        {
-            return 0;
-        }
-
-        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
-
-        // 0x100000000 gives me a numeric overflow...
-        double two32 = 4294967296.0;
-        l = (long)Math.IEEEremainder(d, two32);
-
-        return l & 0xffffffffL;
-    }
-
-    public static long toUint32(Object val) {
-        return toUint32(toNumber(val));
-    }
-
-    /**
-     *
-     * See ECMA 9.7.
-     */
-    public static char toUint16(Object val) {
-        double d = toNumber(val);
-
-        int i = (int)d;
-        if (i == d) {
-            return (char)i;
-        }
-
-        if (d != d
-            || d == Double.POSITIVE_INFINITY
-            || d == Double.NEGATIVE_INFINITY)
-        {
-            return 0;
-        }
-
-        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
-
-        int int16 = 0x10000;
-        i = (int)Math.IEEEremainder(d, int16);
-
-        return (char)i;
-    }
-
-    /**
-     * Unwrap a JavaScriptException.  Sleight of hand so that we don't
-     * javadoc JavaScriptException.getRuntimeValue().
-     */
-    public static Object unwrapJavaScriptException(JavaScriptException jse) {
-        return jse.value;
-    }
-
-    /**
-     * Check a WrappedException. Unwrap a JavaScriptException and return
-     * the value, otherwise rethrow.
-     */
-    public static Object unwrapWrappedException(WrappedException we) {
-        Throwable t = we.getWrappedException();
-        if (t instanceof JavaScriptException)
-            return ((JavaScriptException) t).value;
-        throw we;
-    }
-
-    public static Object getProp(Object obj, String id, Scriptable scope) {
-        Scriptable start;
-        if (obj instanceof Scriptable) {
-            start = (Scriptable) obj;
-        } else {
-            start = toObject(scope, obj);
-        }
-        if (start == null || start == Undefined.instance) {
-            String msg = start == null ? "msg.null.to.object"
-                                       : "msg.undefined";
-            throw NativeGlobal.constructError(
-                        Context.getContext(), "ConversionError",
-                        ScriptRuntime.getMessage0(msg),
-                        scope);
-        }
-        Object result = ScriptableObject.getProperty(start, id);
-        if (result != Scriptable.NOT_FOUND)
-            return result;
-        return Undefined.instance;
-    }
-
-    public static Object getTopLevelProp(Scriptable scope, String id) {
-        scope = ScriptableObject.getTopLevelScope(scope);
-        return ScriptableObject.getProperty(scope, id);
-    }
-
-    static Function getExistingCtor(Context cx, Scriptable scope,
-                                    String constructorName)
-    {
-        Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
-        if (ctorVal instanceof Function) {
-            return (Function)ctorVal;
-        }
-        if (ctorVal == Scriptable.NOT_FOUND) {
-            throw cx.reportRuntimeError1("msg.ctor.not.found", constructorName);
-        } else {
-            throw cx.reportRuntimeError1("msg.not.ctor", constructorName);
-        }
-    }
-
-/***********************************************************************/
-
-    public static Scriptable getProto(Object obj, Scriptable scope) {
-        Scriptable s;
-        if (obj instanceof Scriptable) {
-            s = (Scriptable) obj;
-        } else {
-            s = toObject(scope, obj);
-        }
-        if (s == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        return s.getPrototype();
-    }
-
-    public static Scriptable getParent(Object obj) {
-        Scriptable s;
-        try {
-            s = (Scriptable) obj;
-        }
-        catch (ClassCastException e) {
-            return null;
-        }
-        if (s == null) {
-            return null;
-        }
-        return getThis(s.getParentScope());
-    }
-
-   public static Scriptable getParent(Object obj, Scriptable scope) {
-        Scriptable s;
-        if (obj instanceof Scriptable) {
-            s = (Scriptable) obj;
-        } else {
-            s = toObject(scope, obj);
-        }
-        if (s == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        return s.getParentScope();
-    }
-
-    public static Object setProto(Object obj, Object value, Scriptable scope) {
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch(ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        Scriptable result = value == null ? null : toObject(scope, value);
-        Scriptable s = result;
-        while (s != null) {
-            if (s == start) {
-                throw Context.reportRuntimeError1(
-                    "msg.cyclic.value", "__proto__");
-            }
-            s = s.getPrototype();
-        }
-        if (start == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        start.setPrototype(result);
-        return result;
-    }
-
-    public static Object setParent(Object obj, Object value, Scriptable scope) {
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch(ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        Scriptable result = value == null ? null : toObject(scope, value);
-        Scriptable s = result;
-        while (s != null) {
-            if (s == start) {
-                throw Context.reportRuntimeError1(
-                    "msg.cyclic.value", "__parent__");
-            }
-            s = s.getParentScope();
-        }
-        if (start == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        start.setParentScope(result);
-        return result;
-    }
-
-    public static Object setProp(Object obj, String id, Object value,
-                                 Scriptable scope)
-    {
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch(ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        if (start == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        ScriptableObject.putProperty(start, id, value);
-        return value;
-    }
-
-    // Return -1L if str is not an index or the index value as lower 32
-    // bits of the result
-    private static long indexFromString(String str) {
-        // It must be a string.
-
-        // The length of the decimal string representation of
-        //  Integer.MAX_VALUE, 2147483647
-        final int MAX_VALUE_LENGTH = 10;
-
-        int len = str.length();
-        if (len > 0) {
-            int i = 0;
-            boolean negate = false;
-            int c = str.charAt(0);
-            if (c == '-') {
-                if (len > 1) {
-                    c = str.charAt(1);
-                    i = 1;
-                    negate = true;
-                }
-            }
-            c -= '0';
-            if (0 <= c && c <= 9
-                && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH))
-            {
-                // Use negative numbers to accumulate index to handle
-                // Integer.MIN_VALUE that is greater by 1 in absolute value
-                // then Integer.MAX_VALUE
-                int index = -c;
-                int oldIndex = 0;
-                i++;
-                if (index != 0) {
-                    // Note that 00, 01, 000 etc. are not indexes
-                    while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9)
-                    {
-                        oldIndex = index;
-                        index = 10 * index - c;
-                        i++;
-                    }
-                }
-                // Make sure all characters were consumed and that it couldn't
-                // have overflowed.
-                if (i == len &&
-                    (oldIndex > (Integer.MIN_VALUE / 10) ||
-                     (oldIndex == (Integer.MIN_VALUE / 10) &&
-                      c <= (negate ? -(Integer.MIN_VALUE % 10)
-                                   : (Integer.MAX_VALUE % 10)))))
-                {
-                    return 0xFFFFFFFFL & (negate ? index : -index);
-                }
-            }
-        }
-        return -1L;
-    }
-
-    static String getStringId(Object id) {
-        if (id instanceof Number) {
-            double d = ((Number) id).doubleValue();
-            int index = (int) d;
-            if (((double) index) == d)
-                return null;
-            return toString(id);
-        }
-        String s = toString(id);
-        long indexTest = indexFromString(s);
-        if (indexTest >= 0)
-            return null;
-        return s;
-    }
-
-    static int getIntId(Object id) {
-        if (id instanceof Number) {
-            double d = ((Number) id).doubleValue();
-            int index = (int) d;
-            if (((double) index) == d)
-                return index;
-            return 0;
-        }
-        String s = toString(id);
-        long indexTest = indexFromString(s);
-        if (indexTest >= 0)
-            return (int)indexTest;
-        return 0;
-    }
-
-
-    public static Object getElem(Object obj, Object id, Scriptable scope) {
-        int index;
-        String s;
-        if (id instanceof Number) {
-            double d = ((Number) id).doubleValue();
-            index = (int) d;
-            s = ((double) index) == d ? null : toString(id);
-        } else {
-            s = (id instanceof String) ? (String)id : toString(id);
-            long indexTest = indexFromString(s);
-            if (indexTest >= 0) {
-                index = (int)indexTest;
-                s = null;
-            } else {
-                index = 0;
-            }
-        }
-        Scriptable start;
-        try {
-            start = (Scriptable)obj;
-        } catch (ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        if (s != null) {
-            return getStrIdElem(start, s);
-        }
-        else {
-            return getElem(start, index);
-        }
-    }
-
-
-    /*
-     * A cheaper and less general version of the above for well-known argument
-     * types.
-     */
-    public static Object getElem(Scriptable obj, int index) {
-        Object result = ScriptableObject.getProperty(obj, index);
-        if (result != Scriptable.NOT_FOUND)
-            return result;
-        return Undefined.instance;
-    }
-
-    static Object getStrIdElem(Scriptable obj, String id) {
-        int l = id.length();
-        if (l == 9) {
-            if (id.equals("__proto__")) { return obj.getPrototype(); }
-        }
-        else if (l == 10) {
-            if (id.equals("__parent__")) { return obj.getParentScope(); }
-        }
-        Object result = ScriptableObject.getProperty(obj, id);
-        if (result != Scriptable.NOT_FOUND)
-            return result;
-        return Undefined.instance;
-    }
-
-    public static Object setElem(Object obj, Object id, Object value,
-                                 Scriptable scope)
-    {
-        int index;
-        String s;
-        if (id instanceof Number) {
-            double d = ((Number) id).doubleValue();
-            index = (int) d;
-            s = ((double) index) == d ? null : toString(id);
-        } else {
-            s = (id instanceof String) ? (String)id : toString(id);
-            long indexTest = indexFromString(s);
-            if (indexTest >= 0) {
-                index = (int)indexTest;
-                s = null;
-            } else {
-                index = 0;
-            }
-        }
-
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch (ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        if (s != null) {
-            return setStrIdElem(start, s, value, scope);
-        }
-        else {
-            return setElem(start, index, value);
-        }
-    }
-
-    /*
-     * A cheaper and less general version of the above for well-known argument
-     * types.
-     */
-    public static Object setElem(Scriptable obj, int index, Object value) {
-        ScriptableObject.putProperty(obj, index, value);
-        return value;
-    }
-
-    static Object setStrIdElem(Scriptable obj, String id, Object value,
-                               Scriptable scope)
-    {
-        int l = id.length();
-        if (l == 9) {
-            if (id.equals("__proto__")) return setProto(obj, value, scope);
-        }
-        else if (l == 10) {
-            if (id.equals("__parent__")) return setParent(obj, value, scope);
-        }
-        ScriptableObject.putProperty(obj, id, value);
-        return value;
-    }
-
-    /**
-     * The delete operator
-     *
-     * See ECMA 11.4.1
-     *
-     * In ECMA 0.19, the description of the delete operator (11.4.1)
-     * assumes that the [[Delete]] method returns a value. However,
-     * the definition of the [[Delete]] operator (8.6.2.5) does not
-     * define a return value. Here we assume that the [[Delete]]
-     * method doesn't return a value.
-     */
-    public static Object delete(Object obj, Object id) {
-        String s = getStringId(id);
-        boolean result = s != null
-            ? ScriptableObject.deleteProperty((Scriptable) obj, s)
-            : ScriptableObject.deleteProperty((Scriptable) obj, getIntId(id));
-        return result ? Boolean.TRUE : Boolean.FALSE;
-    }
-
-    /**
-     * Looks up a name in the scope chain and returns its value.
-     */
-    public static Object name(Scriptable scopeChain, String id) {
-        Scriptable obj = scopeChain;
-        while (obj != null) {
-            Object result = ScriptableObject.getProperty(obj, id);
-            if (result != Scriptable.NOT_FOUND)
-                return result;
-            obj = obj.getParentScope();
-        }
-        throw NativeGlobal.constructError
-            (Context.getContext(), "ReferenceError",
-             ScriptRuntime.getMessage1("msg.is.not.defined", id.toString()),
-                        scopeChain);
-    }
-
-    /**
-     * Returns the object in the scope chain that has a given property.
-     *
-     * The order of evaluation of an assignment expression involves
-     * evaluating the lhs to a reference, evaluating the rhs, and then
-     * modifying the reference with the rhs value. This method is used
-     * to 'bind' the given name to an object containing that property
-     * so that the side effects of evaluating the rhs do not affect
-     * which property is modified.
-     * Typically used in conjunction with setName.
-     *
-     * See ECMA 10.1.4
-     */
-    public static Scriptable bind(Scriptable scope, String id) {
-        while (!ScriptableObject.hasProperty(scope, id)) {
-            scope = scope.getParentScope();
-            if (scope == null) {
-                break;
-            }
-        }
-        return scope;
-    }
-
-    public static Scriptable getBase(Scriptable scope, String id) {
-        Scriptable base = bind(scope, id);
-        if (base != null) {
-            return base;
-        }
-        throw NativeGlobal.constructError(
-                    Context.getContext(), "ReferenceError",
-                    ScriptRuntime.getMessage1("msg.is.not.defined", id),
-                    scope);
-    }
-
-    public static Scriptable getThis(Scriptable base) {
-        while (base instanceof NativeWith)
-            base = base.getPrototype();
-        if (base instanceof NativeCall)
-            base = ScriptableObject.getTopLevelScope(base);
-        return base;
-    }
-
-    public static Object setName(Scriptable bound, Object value,
-                                 Scriptable scope, String id)
-    {
-        if (bound != null) {
-            ScriptableObject.putProperty(bound, id, value);
-        }else {
-            // "newname = 7;", where 'newname' has not yet
-            // been defined, creates a new property in the
-            // global object. Find the global object by
-            // walking up the scope chain.
-            bound = ScriptableObject.getTopLevelScope(scope);
-            bound.put(id, bound, value);
-            /*
-            This code is causing immense performance problems in
-            scripts that assign to the variables as a way of creating them.
-            XXX need strict mode
-            String message = getMessage1("msg.assn.create", id);
-            Context.reportWarning(message);
-            */
-        }
-        return value;
-    }
-
-    public static Object initEnum(Object value, Scriptable scope) {
-        if (value == null || value == Undefined.instance) {
-            // Empty enumeration
-            return new IdEnumeration(null);
-        }
-        Scriptable m = toObject(scope, value);
-        return new IdEnumeration(m);
-    }
-
-    public static Object nextEnum(Object enumObj) {
-        // OPT this could be more efficient
-        IdEnumeration enum = (IdEnumeration)enumObj;
-        return enum.nextId();
-    }
-
-    // Form used by class files generated by 1.4R3 and earlier.
-    public static Object call(Context cx, Object fun, Object thisArg,
-                              Object[] args)
-        throws JavaScriptException
-    {
-        Scriptable scope = null;
-        if (fun instanceof Scriptable)
-            scope = ((Scriptable) fun).getParentScope();
-        return call(cx, fun, thisArg, args, scope);
-    }
-
-    public static Object call(Context cx, Object fun, Object thisArg,
-                              Object[] args, Scriptable scope)
-        throws JavaScriptException
-    {
-        Function function;
-        try {
-            function = (Function) fun;
-        }
-        catch (ClassCastException e) {
-            throw NativeGlobal.typeError1
-                ("msg.isnt.function", toString(fun), scope);
-        }
-        Scriptable thisObj;
-        if (thisArg instanceof Scriptable || thisArg == null) {
-            thisObj = (Scriptable) thisArg;
-        } else {
-            thisObj = ScriptRuntime.toObject(cx, scope, thisArg);
-        }
-        return function.call(cx, scope, thisObj, args);
-    }
-
-    private static Object callOrNewSpecial(Context cx, Scriptable scope,
-                                           Object fun, Object jsThis,
-                                           Object thisArg,
-                                           Object[] args, boolean isCall,
-                                           String filename, int lineNumber)
-        throws JavaScriptException
-    {
-        if (fun instanceof IdFunction) {
-            IdFunction f = (IdFunction)fun;
-            String name = f.getFunctionName();
-            if (name.length() == 4) {
-                if (name.equals("eval")) {
-                    if (f.master.getClass() == NativeGlobal.class) {
-                        return NativeGlobal.evalSpecial(cx, scope,
-                                                        thisArg, args,
-                                                        filename, lineNumber);
-                    }
-                }
-                else if (name.equals("With")) {
-                    if (f.master.getClass() == NativeWith.class) {
-                        return NativeWith.newWithSpecial(cx, args, f, !isCall);
-                    }
-                }
-                else if (name.equals("exec")) {
-                    if (f.master.getClass() == NativeScript.class) {
-                        return ((NativeScript)jsThis).
-                            exec(cx, ScriptableObject.getTopLevelScope(scope));
-                    }
-                    else {
-                        RegExpProxy proxy = cx.getRegExpProxy();
-                        if (proxy != null && proxy.isRegExp(jsThis)) {
-                            return call(cx, fun, jsThis, args, scope);
-                        }
-                    }
-                }
-            }
-        }
-        else    // could've been <java>.XXX.exec() that was re-directed here
-            if (fun instanceof NativeJavaMethod)
-                return call(cx, fun, jsThis, args, scope);
-
-        if (isCall)
-            return call(cx, fun, jsThis, args, scope);
-        return newObject(cx, fun, args, scope);
-    }
-
-    public static Object callSpecial(Context cx, Object fun,
-                                     Object thisArg, Object[] args,
-                                     Scriptable enclosingThisArg,
-                                     Scriptable scope, String filename,
-                                     int lineNumber)
-        throws JavaScriptException
-    {
-        return callOrNewSpecial(cx, scope, fun, thisArg,
-                                enclosingThisArg, args, true,
-                                filename, lineNumber);
-    }
-
-    /**
-     * Operator new.
-     *
-     * See ECMA 11.2.2
-     */
-    public static Scriptable newObject(Context cx, Object fun,
-                                       Object[] args, Scriptable scope)
-        throws JavaScriptException
-    {
-        Function f;
-        try {
-            f = (Function) fun;
-            if (f != null) {
-                return f.construct(cx, scope, args);
-           }
-            // else fall through to error
-        } catch (ClassCastException e) {
-            // fall through to error
-        }
-        throw NativeGlobal.typeError1
-            ("msg.isnt.function", toString(fun), scope);
-    }
-
-    public static Scriptable newObjectSpecial(Context cx, Object fun,
-                                              Object[] args, Scriptable scope)
-        throws JavaScriptException
-    {
-        return (Scriptable) callOrNewSpecial(cx, scope, fun, null, null, args,
-                                             false, null, -1);
-    }
-
-    /**
-     * The typeof operator
-     */
-    public static String typeof(Object value) {
-        if (value == Undefined.instance)
-            return "undefined";
-        if (value == null)
-            return "object";
-        if (value instanceof Scriptable)
-            return (value instanceof Function) ? "function" : "object";
-        if (value instanceof String)
-            return "string";
-        if (value instanceof Number)
-            return "number";
-        if (value instanceof Boolean)
-            return "boolean";
-        throw errorWithClassName("msg.invalid.type", value);
-    }
-
-    /**
-     * The typeof operator that correctly handles the undefined case
-     */
-    public static String typeofName(Scriptable scope, String id) {
-        Object val = bind(scope, id);
-        if (val == null)
-            return "undefined";
-        return typeof(getProp(val, id, scope));
-    }
-
-    // neg:
-    // implement the '-' operator inline in the caller
-    // as "-toNumber(val)"
-
-    // not:
-    // implement the '!' operator inline in the caller
-    // as "!toBoolean(val)"
-
-    // bitnot:
-    // implement the '~' operator inline in the caller
-    // as "~toInt32(val)"
-
-    public static Object add(Object val1, Object val2) {
-        if(val1 instanceof Number && val2 instanceof Number) {
-            return new Double(((Number)val1).doubleValue() +
-                              ((Number)val2).doubleValue());
-        }
-        if (val1 instanceof Scriptable)
-            val1 = ((Scriptable) val1).getDefaultValue(null);
-        if (val2 instanceof Scriptable)
-            val2 = ((Scriptable) val2).getDefaultValue(null);
-        if (!(val1 instanceof String) && !(val2 instanceof String))
-            if ((val1 instanceof Number) && (val2 instanceof Number))
-                return new Double(((Number)val1).doubleValue() +
-                                  ((Number)val2).doubleValue());
-            else
-                return new Double(toNumber(val1) + toNumber(val2));
-        return toString(val1) + toString(val2);
-    }
-
-    public static Object postIncrement(Object value) {
-        if (value instanceof Number)
-            value = new Double(((Number)value).doubleValue() + 1.0);
-        else
-            value = new Double(toNumber(value) + 1.0);
-        return value;
-    }
-
-    public static Object postIncrement(Scriptable scopeChain, String id) {
-        Scriptable obj = scopeChain;
-        Object prop;
-        while (obj != null) {
-            Scriptable m = obj;
-            do {
-                Object result = m.get(id, obj);
-                if (result != Scriptable.NOT_FOUND) {
-                    Object newValue = result;
-                    if (newValue instanceof Number) {
-                        newValue = new Double(
-                                    ((Number)newValue).doubleValue() + 1.0);
-                        m.put(id, obj, newValue);
-                        return result;
-                    }
-                    else {
-                        newValue = new Double(toNumber(newValue) + 1.0);
-                        m.put(id, obj, newValue);
-                        return new Double(toNumber(result));
-                    }
-                }
-                m = m.getPrototype();
-            } while (m != null);
-            obj = obj.getParentScope();
-        }
-        throw NativeGlobal.constructError
-            (Context.getContext(), "ReferenceError",
-             ScriptRuntime.getMessage1("msg.is.not.defined", id),
-                    scopeChain);
-    }
-
-    public static Object postIncrement(Object obj, String id, Scriptable scope) {
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch (ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        if (start == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        Scriptable m = start;
-        do {
-            Object result = m.get(id, start);
-            if (result != Scriptable.NOT_FOUND) {
-                Object newValue = result;
-                if (newValue instanceof Number) {
-                    newValue = new Double(
-                                ((Number)newValue).doubleValue() + 1.0);
-                    m.put(id, start, newValue);
-                    return result;
-                }
-                else {
-                    newValue = new Double(toNumber(newValue) + 1.0);
-                    m.put(id, start, newValue);
-                    return new Double(toNumber(result));
-                }
-            }
-            m = m.getPrototype();
-        } while (m != null);
-        return Undefined.instance;
-    }
-
-    public static Object postIncrementElem(Object obj,
-                                            Object index, Scriptable scope) {
-        Object oldValue = getElem(obj, index, scope);
-        if (oldValue == Undefined.instance)
-            return Undefined.instance;
-        double resultValue = toNumber(oldValue);
-        Double newValue = new Double(resultValue + 1.0);
-        setElem(obj, index, newValue, scope);
-        return new Double(resultValue);
-    }
-
-    public static Object postDecrementElem(Object obj,
-                                            Object index, Scriptable scope) {
-        Object oldValue = getElem(obj, index, scope);
-        if (oldValue == Undefined.instance)
-            return Undefined.instance;
-        double resultValue = toNumber(oldValue);
-        Double newValue = new Double(resultValue - 1.0);
-        setElem(obj, index, newValue, scope);
-        return new Double(resultValue);
-    }
-
-    public static Object postDecrement(Object value) {
-        if (value instanceof Number)
-            value = new Double(((Number)value).doubleValue() - 1.0);
-        else
-            value = new Double(toNumber(value) - 1.0);
-        return value;
-    }
-
-    public static Object postDecrement(Scriptable scopeChain, String id) {
-        Scriptable obj = scopeChain;
-        Object prop;
-        while (obj != null) {
-            Scriptable m = obj;
-            do {
-                Object result = m.get(id, obj);
-                if (result != Scriptable.NOT_FOUND) {
-                    Object newValue = result;
-                    if (newValue instanceof Number) {
-                        newValue = new Double(
-                                    ((Number)newValue).doubleValue() - 1.0);
-                        m.put(id, obj, newValue);
-                        return result;
-                    }
-                    else {
-                        newValue = new Double(toNumber(newValue) - 1.0);
-                        m.put(id, obj, newValue);
-                        return new Double(toNumber(result));
-                    }
-                }
-                m = m.getPrototype();
-            } while (m != null);
-            obj = obj.getParentScope();
-        }
-        throw NativeGlobal.constructError
-            (Context.getContext(), "ReferenceError",
-             ScriptRuntime.getMessage1("msg.is.not.defined", id),
-                    scopeChain);
-    }
-
-    public static Object postDecrement(Object obj, String id, Scriptable scope) {
-        Scriptable start;
-        try {
-            start = (Scriptable) obj;
-        } catch (ClassCastException e) {
-            start = toObject(scope, obj);
-        }
-        if (start == null) {
-            throw NativeGlobal.typeError0("msg.null.to.object", scope);
-        }
-        Scriptable m = start;
-        do {
-            Object result = m.get(id, start);
-            if (result != Scriptable.NOT_FOUND) {
-                Object newValue = result;
-                if (newValue instanceof Number) {
-                    newValue = new Double(
-                                ((Number)newValue).doubleValue() - 1.0);
-                    m.put(id, start, newValue);
-                    return result;
-                }
-                else {
-                    newValue = new Double(toNumber(newValue) - 1.0);
-                    m.put(id, start, newValue);
-                    return new Double(toNumber(result));
-                }
-            }
-            m = m.getPrototype();
-        } while (m != null);
-        return Undefined.instance;
-    }
-
-    public static Object toPrimitive(Object val) {
-        if (val == null || !(val instanceof Scriptable)) {
-            return val;
-        }
-        Object result = ((Scriptable) val).getDefaultValue(null);
-        if (result != null && result instanceof Scriptable)
-            throw NativeGlobal.typeError0("msg.bad.default.value", val);
-        return result;
-    }
-
-    private static Class getTypeOfValue(Object obj) {
-        if (obj == null)
-            return ScriptableClass;
-        if (obj == Undefined.instance)
-            return UndefinedClass;
-        if (obj instanceof Number)
-            return NumberClass;
-        if (obj instanceof Scriptable)
-            return ScriptableClass;
-        return obj.getClass();
-    }
-
-    /**
-     * Equality
-     *
-     * See ECMA 11.9
-     */
-    public static boolean eq(Object x, Object y) {
-        Object xCopy = x;                                       // !!! JIT bug in Cafe 2.1
-        Object yCopy = y;                                       // need local copies, otherwise their values get blown below
-        for (;;) {
-            Class typeX = getTypeOfValue(x);
-            Class typeY = getTypeOfValue(y);
-            if (typeX == typeY) {
-                if (typeX == UndefinedClass)
-                    return true;
-                if (typeX == NumberClass)
-                    return ((Number) x).doubleValue() ==
-                           ((Number) y).doubleValue();
-                if (typeX == StringClass || typeX == BooleanClass)
-                    return xCopy.equals(yCopy);                                 // !!! JIT bug in Cafe 2.1
-                if (typeX == ScriptableClass) {
-                    if (x == y)
-                        return true;
-                    if (x instanceof Wrapper &&
-                        y instanceof Wrapper)
-                    {
-                        return ((Wrapper) x).unwrap() ==
-                               ((Wrapper) y).unwrap();
-                    }
-                    return false;
-                }
-                throw new RuntimeException(); // shouldn't get here
-            }
-            if (x == null && y == Undefined.instance)
-                return true;
-            if (x == Undefined.instance && y == null)
-                return true;
-            if (typeX == NumberClass &&
-                typeY == StringClass)
-            {
-                return ((Number) x).doubleValue() == toNumber(y);
-            }
-            if (typeX == StringClass &&
-                typeY == NumberClass)
-            {
-                return toNumber(x) == ((Number) y).doubleValue();
-            }
-            if (typeX == BooleanClass) {
-                x = new Double(toNumber(x));
-                xCopy = x;                                 // !!! JIT bug in Cafe 2.1
-                continue;
-            }
-            if (typeY == BooleanClass) {
-                y = new Double(toNumber(y));
-                yCopy = y;                                 // !!! JIT bug in Cafe 2.1
-                continue;
-            }
-            if ((typeX == StringClass ||
-                 typeX == NumberClass) &&
-                typeY == ScriptableClass && y != null)
-            {
-                y = toPrimitive(y);
-                yCopy = y;                                 // !!! JIT bug in Cafe 2.1
-                continue;
-            }
-            if (typeX == ScriptableClass && x != null &&
-                (typeY == StringClass ||
-                 typeY == NumberClass))
-            {
-                x = toPrimitive(x);
-                xCopy = x;                                 // !!! JIT bug in Cafe 2.1
-                continue;
-            }
-            return false;
-        }
-    }
-
-    public static Boolean eqB(Object x, Object y) {
-        if (eq(x,y))
-            return Boolean.TRUE;
-        else
-            return Boolean.FALSE;
-    }
-
-    public static Boolean neB(Object x, Object y) {
-        if (eq(x,y))
-            return Boolean.FALSE;
-        else
-            return Boolean.TRUE;
-    }
-
-    public static boolean shallowEq(Object x, Object y) {
-        Class type = getTypeOfValue(x);
-        if (type != getTypeOfValue(y))
-            return false;
-        if (type == StringClass || type == BooleanClass)
-            return x.equals(y);
-        if (type == NumberClass)
-            return ((Number) x).doubleValue() ==
-                   ((Number) y).doubleValue();
-        if (type == ScriptableClass) {
-            if (x == y)
-                return true;
-            if (x instanceof Wrapper && y instanceof Wrapper)
-                return ((Wrapper) x).unwrap() ==
-                       ((Wrapper) y).unwrap();
-            return false;
-        }
-        if (type == UndefinedClass)
-            return true;
-        return false;
-    }
-
-    public static Boolean seqB(Object x, Object y) {
-        if (shallowEq(x,y))
-            return Boolean.TRUE;
-        else
-            return Boolean.FALSE;
-    }
-
-    public static Boolean sneB(Object x, Object y) {
-        if (shallowEq(x,y))
-            return Boolean.FALSE;
-        else
-            return Boolean.TRUE;
-    }
-
-    /**
-     * The instanceof operator.
-     *
-     * @return a instanceof b
-     */
-    public static boolean instanceOf(Scriptable scope, Object a, Object b) {
-        // Check RHS is an object
-        if (! (b instanceof Scriptable)) {
-            throw NativeGlobal.typeError0("msg.instanceof.not.object", scope);
-        }
-
-        // for primitive values on LHS, return false
-        // XXX we may want to change this so that
-        // 5 instanceof Number == true
-        if (! (a instanceof Scriptable))
-            return false;
-
-        return ((Scriptable)b).hasInstance((Scriptable)a);
-    }
-
-    /**
-     * Delegates to
-     *
-     * @return true iff rhs appears in lhs' proto chain
-     */
-    protected static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
-        Scriptable proto = lhs.getPrototype();
-
-        while (proto != null) {
-            if (proto.equals(rhs)) return true;
-            proto = proto.getPrototype();
-        }
-
-        return false;
-    }
-
-    /**
-     * The in operator.
-     *
-     * This is a new JS 1.3 language feature.  The in operator mirrors
-     * the operation of the for .. in construct, and tests whether the
-     * rhs has the property given by the lhs.  It is different from the
-     * for .. in construct in that:
-     * <BR> - it doesn't perform ToObject on the right hand side
-     * <BR> - it returns true for DontEnum properties.
-     * @param a the left hand operand
-     * @param b the right hand operand
-     *
-     * @return true if property name or element number a is a property of b
-     */
-    public static boolean in(Object a, Object b, Scriptable scope) {
-        if (!(b instanceof Scriptable)) {
-            throw NativeGlobal.typeError0("msg.instanceof.not.object", scope);
-        }
-        String s = getStringId(a);
-        return s != null
-            ? ScriptableObject.hasProperty((Scriptable) b, s)
-            : ScriptableObject.hasProperty((Scriptable) b, getIntId(a));
-    }
-
-    public static Boolean cmp_LTB(Object val1, Object val2) {
-        if (cmp_LT(val1, val2) == 1)
-            return Boolean.TRUE;
-        else
-            return Boolean.FALSE;
-    }
-
-    public static int cmp_LT(Object val1, Object val2) {
-        if(val1 instanceof Number && val2 instanceof Number) {
-            double d1 = ((Number)val1).doubleValue();
-            double d2 = ((Number)val2).doubleValue();
-            if(d1 != d1) return 0;
-            if(d2 != d2) return 0;
-            return d1 < d2 ? 1 : 0;
-        }
-        if (val1 instanceof Scriptable)
-            val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
-        if (val2 instanceof Scriptable)
-            val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
-        if (!(val1 instanceof String) || !(val2 instanceof String)) {
-            double d1 = toNumber(val1);
-            if (d1 != d1)
-                return 0;
-            double d2 = toNumber(val2);
-            if (d2 != d2)
-                return 0;
-            return d1 < d2 ? 1 : 0;
-        }
-        return toString(val1).compareTo(toString(val2)) < 0 ? 1 : 0;
-    }
-
-    public static Boolean cmp_LEB(Object val1, Object val2) {
-        if (cmp_LE(val1, val2) == 1)
-            return Boolean.TRUE;
-        else
-            return Boolean.FALSE;
-    }
-
-    public static int cmp_LE(Object val1, Object val2) {
-        if(val1 instanceof Number && val2 instanceof Number) {
-            double d1 = ((Number)val1).doubleValue();
-            double d2 = ((Number)val2).doubleValue();
-            if(d1 != d1) return 0;
-            if(d2 != d2) return 0;
-            return d1 <= d2 ? 1 : 0;
-        }
-        if (val1 instanceof Scriptable)
-            val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
-        if (val2 instanceof Scriptable)
-            val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
-        if (!(val1 instanceof String) || !(val2 instanceof String)) {
-            double d1 = toNumber(val1);
-            if (d1 != d1)
-                return 0;
-            double d2 = toNumber(val2);
-            if (d2 != d2)
-                return 0;
-            return d1 <= d2 ? 1 : 0;
-        }
-        return toString(val1).compareTo(toString(val2)) <= 0 ? 1 : 0;
-    }
-
-    // lt:
-    // implement the '<' operator inline in the caller
-    // as "compare(val1, val2) == 1"
-
-    // le:
-    // implement the '<=' operator inline in the caller
-    // as "compare(val2, val1) == 0"
-
-    // gt:
-    // implement the '>' operator inline in the caller
-    // as "compare(val2, val1) == 1"
-
-    // ge:
-    // implement the '>=' operator inline in the caller
-    // as "compare(val1, val2) == 0"
-
-    // ------------------
-    // Statements
-    // ------------------
-
-    private static final String GLOBAL_CLASS =
-        "org.mozilla.javascript.tools.shell.Global";
-
-    private static ScriptableObject getGlobal(Context cx) {
-        try {
-            Class globalClass = Class.forName(GLOBAL_CLASS);
-            Class[] parm = { Context.class };
-            Constructor globalClassCtor = globalClass.getConstructor(parm);
-            Object[] arg = { cx };
-            return (ScriptableObject) globalClassCtor.newInstance(arg);
-        } catch (ClassNotFoundException e) {
-            // fall through...
-        } catch (NoSuchMethodException e) {
-            // fall through...
-        } catch (InvocationTargetException e) {
-            // fall through...
-        } catch (IllegalAccessException e) {
-            // fall through...
-        } catch (InstantiationException e) {
-            // fall through...
-        }
-        return new ImporterTopLevel(cx);
-    }
-
-    public static void main(Class scriptClass, String[] args)
-        throws JavaScriptException
-    {
-        Context cx = Context.enter();
-        try {
-            Script script = null;
-            try {
-                script = (Script)scriptClass.newInstance();
-            } catch (InstantiationException e) {
-            } catch (IllegalAccessException e) {
-            }
-            if (script == null) {
-                throw new RuntimeException("Error creating script object");
-            }
-            ScriptableObject global = getGlobal(cx);
-
-            // get the command line arguments and define "arguments"
-            // array in the top-level object
-            Scriptable argsObj = cx.newArray(global, args);
-            global.defineProperty("arguments", argsObj,
-                                  ScriptableObject.DONTENUM);
-            script.exec(cx, global);
-        } finally {
-            Context.exit();
-        }
-    }
-
-    public static Scriptable initScript(Context cx, Scriptable scope,
-                                        NativeFunction funObj,
-                                        Scriptable thisObj,
-                                        boolean fromEvalCode)
-    {
-        String[] argNames = funObj.argNames;
-        if (argNames != null) {
-            Scriptable varScope = scope;
-            if (fromEvalCode) {
-                // When executing an eval() inside a with statement,
-                // define any variables resulting from var statements
-                // in the first non-with scope. See bug 38590.
-                varScope = scope;
-                while (varScope instanceof NativeWith)
-                    varScope = varScope.getParentScope();
-            }
-            for (int i = argNames.length; i-- != 0;) {
-                String name = argNames[i];
-                // Don't overwrite existing def if already defined in object
-                // or prototypes of object.
-                if (!hasProp(scope, name)) {
-                    if (!fromEvalCode) {
-                        // Global var definitions are supposed to be DONTDELETE
-                        ScriptableObject.defineProperty
-                            (scope, name, Undefined.instance,
-                             ScriptableObject.PERMANENT);
-                    } else {
-                        varScope.put(name, varScope, Undefined.instance);
-                    }
-                }
-            }
-        }
-
-        return scope;
-    }
-
-    public static Scriptable runScript(Script script) {
-        Context cx = Context.enter();
-        ScriptableObject global = getGlobal(cx);
-        try {
-            script.exec(cx, global);
-        } catch (JavaScriptException e) {
-            throw new Error(e.toString());
-        } finally {
-            Context.exit();
-        }
-        return global;
-    }
-
-    public static Scriptable initVarObj(Context cx, Scriptable scope,
-                                        NativeFunction funObj,
-                                        Scriptable thisObj, Object[] args)
-    {
-        return new NativeCall(cx, scope, funObj, thisObj, args);
-    }
-
-    public static void popActivation(Context cx) {
-        NativeCall current = cx.currentActivation;
-        if (current != null) {
-            cx.currentActivation = current.caller;
-            current.caller = null;
-        }
-    }
-
-    public static Scriptable newScope() {
-        return new NativeObject();
-    }
-
-    public static Scriptable enterWith(Object value, Scriptable scope) {
-        return new NativeWith(scope, toObject(scope, value));
-    }
-
-    public static Scriptable leaveWith(Scriptable scope) {
-        return scope.getParentScope();
-    }
-
-    public static void setFunctionProtoAndParent(Scriptable scope,
-                                                 Function fn)
-    {
-        fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
-        fn.setParentScope(scope);
-    }
-
-    public static void initFunction(Context cx, Scriptable scope,
-                                    NativeFunction function, int type,
-                                    boolean fromEvalCode)
-    {
-        setFunctionProtoAndParent(scope, function);
-        if (type == FunctionNode.FUNCTION_STATEMENT) {
-            String name = function.functionName;
-            if (name != null && name.length() != 0) {
-                if (!fromEvalCode) {
-                    // ECMA specifies that functions defined in global and
-                    // function scope outside eval should have DONTDELETE set.
-                    ScriptableObject.defineProperty
-                        (scope, name, function, ScriptableObject.PERMANENT);
-                } else {
-                    scope.put(name, scope, function);
-                }
-            }
-        } else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
-            String name = function.functionName;
-            if (name != null && name.length() != 0) {
-                // Always put function expression statements into initial
-                // activation object ignoring the with statement to follow
-                // SpiderMonkey
-                while (scope instanceof NativeWith) {
-                    scope = scope.getParentScope();
-                }
-                scope.put(name, scope, function);
-            }
-        }
-    }
-
-    static void checkDeprecated(Context cx, String name) {
-        int version = cx.getLanguageVersion();
-        if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
-            String msg = getMessage1("msg.deprec.ctor", name);
-            if (version == Context.VERSION_DEFAULT)
-                Context.reportWarning(msg);
-            else
-                throw Context.reportRuntimeError(msg);
-        }
-    }
-
-    public static String getMessage0(String messageId) {
-        return Context.getMessage0(messageId);
-    }
-
-    public static String getMessage1(String messageId, Object arg1) {
-        return Context.getMessage1(messageId, arg1);
-    }
-
-    public static String getMessage2
-        (String messageId, Object arg1, Object arg2)
-    {
-        return Context.getMessage2(messageId, arg1, arg2);
-    }
-
-    public static String getMessage(String messageId, Object[] arguments) {
-        return Context.getMessage(messageId, arguments);
-    }
-
-    public static RegExpProxy getRegExpProxy(Context cx) {
-        return cx.getRegExpProxy();
-    }
-
-    public static NativeCall getCurrentActivation(Context cx) {
-        return cx.currentActivation;
-    }
-
-    public static void setCurrentActivation(Context cx,
-                                            NativeCall activation)
-    {
-        cx.currentActivation = activation;
-    }
-
-    static Class getClassOrNull(String className) {
-        try {
-            return Class.forName(className);
-        } catch  (ClassNotFoundException ex) {
-        } catch  (SecurityException ex) {
-        } catch (IllegalArgumentException e) {
-            // Can be thrown if name has characters that a class name
-            // can not contain
-        }
-        return null;
-    }
-
-    static Class getClassOrNull(ClassLoader loader, String className)
-    {
-        try {
-            return loader.loadClass(className);
-        } catch (ClassNotFoundException ex) {
-        } catch (SecurityException ex) {
-        } catch (IllegalArgumentException e) {
-            // Can be thrown if name has characters that a class name
-            // can not contain
-        }
-        return null;
-    }
-
-    static boolean hasProp(Scriptable start, String name) {
-        Scriptable m = start;
-        do {
-            if (m.has(name, start))
-                return true;
-            m = m.getPrototype();
-        } while (m != null);
-        return false;
-    }
-
-    static String makeUrlForGeneratedScript
-        (boolean isEval, String masterScriptUrl, int masterScriptLine)
-    {
-        if (isEval) {
-            return masterScriptUrl+'#'+masterScriptLine+"(eval)";
-        } else {
-            return masterScriptUrl+'#'+masterScriptLine+"(Function)";
-        }
-    }
-
-    static boolean isGeneratedScript(String sourceUrl) {
-        // ALERT: this may clash with a valid URL containing (eval) or
-        // (Function)
-        return sourceUrl.indexOf("(eval)") >= 0
-               || sourceUrl.indexOf("(Function)") >= 0;
-    }
-
-    private static RuntimeException errorWithClassName(String msg, Object val)
-    {
-        return Context.reportRuntimeError1(msg, val.getClass().getName());
-    }
-
-    public static final Object[] emptyArgs = new Object[0];
-
-}
-
-
-/**
- * This is the enumeration needed by the for..in statement.
- *
- * See ECMA 12.6.3.
- *
- * IdEnumeration maintains a ObjToIntMap to make sure a given
- * id is enumerated only once across multiple objects in a
- * prototype chain.
- *
- * XXX - ECMA delete doesn't hide properties in the prototype,
- * but js/ref does. This means that the js/ref for..in can
- * avoid maintaining a hash table and instead perform lookups
- * to see if a given property has already been enumerated.
- *
- */
-class IdEnumeration {
-    IdEnumeration(Scriptable m) {
-        used = new ObjToIntMap(27);
-        changeObject(m);
-        next = getNext();
-    }
-
-    Object nextId() {
-        Object result = next;
-        if (result != null) {
-            // only key used; 0 as value for convenience
-            used.put(next, 0);
-
-            next = getNext();
-        }
-        return result;
-    }
-
-    private void changeObject(Scriptable m) {
-        obj = m;
-        if (obj != null) {
-            array = m.getIds();
-            if (array.length == 0)
-                changeObject(obj.getPrototype());
-        }
-        index = 0;
-    }
-
-    private Object getNext() {
-        if (obj == null)
-            return null;
-        Object result;
-        for (;;) {
-            if (index == array.length) {
-                changeObject(obj.getPrototype());
-                if (obj == null)
-                    return null;
-            }
-            result = array[index++];
-            if (result instanceof String) {
-                if (!obj.has((String) result, obj))
-                    continue;   // must have been deleted
-            } else {
-                if (!obj.has(((Number) result).intValue(), obj))
-                    continue;   // must have been deleted
-            }
-            if (!used.has(result)) {
-                break;
-            }
-        }
-        return ScriptRuntime.toString(result);
-    }
-
-    private Object next;
-    private Scriptable obj;
-    private int index;
-    private Object[] array;
-    private ObjToIntMap used;
-}
Index: rhino/build.xml
===================================================================
RCS file: rhino/build.xml
diff -N rhino/build.xml
--- rhino/build.xml	22 Oct 2004 14:15:06 -0000	1.4
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,116 +0,0 @@
-<!--
-#*************************************************************************
-#
-#   $RCSfile$
-#
-#   $Revision$
-#
-#   last change: $Author$ $Date$
-#
-#   The Contents of this file are made available subject to the terms of
-#   either of the following licenses
-#
-#          - GNU Lesser General Public License Version 2.1
-#          - Sun Industry Standards Source License Version 1.1
-#
-#   Sun Microsystems Inc., October, 2000
-#
-#   GNU Lesser General Public License Version 2.1
-#   =============================================
-#   Copyright 2000 by Sun Microsystems, Inc.
-#   901 San Antonio Road, Palo Alto, CA 94303, USA
-#
-#   This library is free software; you can redistribute it and/or
-#   modify it under the terms of the GNU Lesser General Public
-#   License version 2.1, as published by the Free Software Foundation.
-#
-#   This library is distributed in the hope that it will be useful,
-#   but WITHOUT ANY WARRANTY; without even the implied warranty of
-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#   Lesser General Public License for more details.
-#
-#   You should have received a copy of the GNU Lesser General Public
-#   License along with this library; if not, write to the Free Software
-#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-#   MA  02111-1307  USA
-#
-#
-#   Sun Industry Standards Source License Version 1.1
-#   =================================================
-#   The contents of this file are subject to the Sun Industry Standards
-#   Source License Version 1.1 (the "License"); You may not use this file
-#   except in compliance with the License. You may obtain a copy of the
-#   License at http://www.openoffice.org/license.html.
-#
-#   Software provided under this License is provided on an "AS IS" basis,
-#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
-#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
-#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
-#   See the License for the specific provisions governing your rights and
-#   obligations concerning the Software.
-#
-#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
-#
-#   Copyright: 2000 by Sun Microsystems, Inc.
-#
-#   All Rights Reserved.
-#
-#   Contributor(s): _______________________________________
-#
-#
-#
-#*************************************************************************
--->
-<project name="Scipting Framework Installer" default="all" basedir=".">
-
-  <!-- =================== Environmental Properties ======================= -->
-
-  <property name="prj" value="."/>
-  <property name="build.compiler"   value="modern"/>
-  <property name="optimize"   value="on"/>
-  <property name="debug"   value="on"/>
-  <property name="jardir" value="${out}/class"/>
-  <property name="bindir" value="${out}/bin"/>
-  <property name="rhinojar" value="js-1.5R4.jar"/>
-
-  <!-- ===================== Patch the rhino jar ========================= -->
-  
-  <!-- unzip jar and compile patched java sources -->
-  <target name="compile" depends="depend" unless="compile.notRequired">
-    <delete dir="${out}/class/org"/>
-    <delete dir="${out}/class/META-INF"/>
-    <unzip src="js-1.5R4.jar"
-        dest="${out}/class"/>
-    <javac srcdir="${prj}"
-           destdir="${out}/class"
-       	   includes="Main.java, OfficeScriptInfo.java, Context.java, ImporterTopLevel.java, Codegen.java, InvokerImpl.java, NativeJavaPackage.java, JavaAdapter.java, ScriptRuntime.java" 
-	   debug="${debug}" optimize="${optimize}" deprecation="on"/>
-  </target>
-
-  <!-- check dependencies -->
-  <target name="depend">
-     <uptodate property="compile.notRequired" value="true"
-               targetfile="${out}/class/org/mozilla/javascript/tools/debugger/Main.class">
-               <srcfiles dir="${prj}" includes="Main.java, OfficeScriptInfo.java, ScriptRuntime.java, ImporterTopLevel.java, Codegen.java, InvokerImpl.java, NativeJavaPackage.java, JavaAdapter.java, Context.java, ${rhinojar},build.xml"/>
-     </uptodate>
-  </target>
-	
-  <target name="test">
-  </target>
-
-  <!-- create jar file -->
-  <target name="jar" depends="compile">
-    <jar jarfile="${out}/class/${rhinojar}"
-        basedir="${out}/class" includes="org/**"
-        manifest="${out}/class/META-INF/MANIFEST.MF"/>
-  </target>
-
-  <!-- ====================== Clean Generated Files ===================== -->
-  <target name="clean">
-    <delete dir="${out}/class"/>
-  </target>
-
-  <!-- ========================= All In One Build ======================= -->
-  <target name="all" depends="jar"/>
- 
-</project>
Index: rhino/js-1.5R4.jar
===================================================================
RCS file: rhino/js-1.5R4.jar
diff -N rhino/js-1.5R4.jar
Binary files /tmp/cvsXmaiBb and /dev/null differ
Index: rhino/makefile.mk
===================================================================
RCS file: /cvs/external/rhino/makefile.mk,v
retrieving revision 1.3
retrieving revision 1.3.2.2
diff -u -p -r1.3 -r1.3.2.2
--- rhino/makefile.mk	25 Jan 2005 15:16:22 -0000	1.3
+++ rhino/makefile.mk	7 Feb 2005 14:06:52 -0000	1.3.2.2
@@ -61,17 +61,34 @@
 #*************************************************************************
 
 PRJ=.
-PRJNAME=so_rhino
-TARGET=so_rhino
+
+PRJNAME=ooo_rhino
+TARGET=ooo_rhino
 
 .IF "$(SOLAR_JAVA)"!=""
 .IF "$(JDK)" == "gcj"
 all:
         @echo This dir cannot be build with gcj because of javax.swing.JTextArea.replaceRange
 .ELSE
-.INCLUDE : ant.mk
 
-ALLTAR : ANTBUILD
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :	settings.mk
+
+# --- Files --------------------------------------------------------
+
+TARFILE_NAME=rhino15R4
+TARFILE_ROOTDIR=rhino1_5R4
+PATCH_FILE_NAME=rhino1_5R4.patch
+
+BUILD_ACTION=dmake $(MFLAGS) $(CALLMACROS)
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : set_ext.mk
+.INCLUDE : target.mk
+.INCLUDE : tg_ext.mk
+
 .ENDIF
 .ELSE
 all:
Index: rhino/rhino15R4.patch
===================================================================
RCS file: rhino/rhino15R4.patch
diff -N rhino/rhino15R4.patch
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ rhino/rhino15R4.patch	7 Feb 2005 14:06:53 -0000	1.1.2.3
@@ -0,0 +1,2302 @@
+--- misc/build/rhino1_5R4/build.xml	2005-02-01 18:05:48.983062000 +0000
++++ misc/build/rhino1_5R4/build.xml	2005-02-01 18:06:04.693016000 +0000
+@@ -4,7 +4,7 @@
+ Build file for Rhino using Ant (see http://jakarta.apache.org/ant/index.html)
+ Requires Ant version 1.2 or later
+ -->
+-<project name="Rhino" default="default" basedir=".">
++<project name="Rhino" default="jar" basedir=".">
+ 
+   <target name="properties">
+     <property name="name" value="rhino"/>
+--- misc/build/rhino1_5R4/makefile.mk	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/makefile.mk	2005-02-01 18:43:30.832676000 +0000
+@@ -0,0 +1,70 @@
++#*************************************************************************
++#
++#   $RCSfile$
++#
++#   $Revision$
++#
++#   last change: $Author$ $Date$
++#
++#   The Contents of this file are made available subject to the terms of
++#   either of the following licenses
++#
++#          - GNU Lesser General Public License Version 2.1
++#          - Sun Industry Standards Source License Version 1.1
++#
++#   Sun Microsystems Inc., October, 2000
++#
++#   GNU Lesser General Public License Version 2.1
++#   =============================================
++#   Copyright 2000 by Sun Microsystems, Inc.
++#   901 San Antonio Road, Palo Alto, CA 94303, USA
++#
++#   This library is free software; you can redistribute it and/or
++#   modify it under the terms of the GNU Lesser General Public
++#   License version 2.1, as published by the Free Software Foundation.
++#
++#   This library is distributed in the hope that it will be useful,
++#   but WITHOUT ANY WARRANTY; without even the implied warranty of
++#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++#   Lesser General Public License for more details.
++#
++#   You should have received a copy of the GNU Lesser General Public
++#   License along with this library; if not, write to the Free Software
++#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++#   MA  02111-1307  USA
++#
++#
++#   Sun Industry Standards Source License Version 1.1
++#   =================================================
++#   The contents of this file are subject to the Sun Industry Standards
++#   Source License Version 1.1 (the "License"); You may not use this file
++#   except in compliance with the License. You may obtain a copy of the
++#   License at http://www.openoffice.org/license.html.
++#
++#   Software provided under this License is provided on an "AS IS" basis,
++#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
++#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
++#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
++#   See the License for the specific provisions governing your rights and
++#   obligations concerning the Software.
++#
++#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
++#
++#   Copyright: 2000 by Sun Microsystems, Inc.
++#
++#   All Rights Reserved.
++#
++#   Contributor(s): _______________________________________
++#
++#
++#
++#*************************************************************************
++
++PRJ=..$/..$/..$/..
++PRJNAME=ooo_rhino
++TARGET=jar
++
++.INCLUDE : ant.mk
++
++ALLTAR : ANTBUILD
++
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/Context.java	2005-02-01 18:05:47.293067000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/Context.java	2005-02-01 18:06:02.843024000 +0000
+@@ -386,7 +386,7 @@
+      *         number, and date.
+      */
+      public String getImplementationVersion() {
+-        return "Rhino 1.5 release 4 2003 02 10";
++        return "Rhino 1.5 release 4.1 2003 04 21";
+      }
+ 
+     /**
+@@ -1835,7 +1835,65 @@
+ 
+     public GeneratedClassLoader createClassLoader(ClassLoader parent) {
+         return new DefiningClassLoader(parent);
++    }
+ 
++    public final ClassLoader getApplicationClassLoader()
++    {
++        if (applicationClassLoader != null) {
++            return applicationClassLoader;
++        }
++        ClassLoader loader = null;
++        if (method_getContextClassLoader != null) {
++            Thread thread = Thread.currentThread();
++            try {
++                loader = (ClassLoader)method_getContextClassLoader.invoke(
++                             thread, ScriptRuntime.emptyArgs);
++            } catch (Exception ex) { }
++        }
++        if (loader != null && !testIfCanUseLoader(loader)) {
++            loader = null;
++        }
++        if (loader == null) {
++            // If Context was subclassed, the following gets the loader
++            // for the subclass which can be different from Rhino loader,
++            // but then proper Rhino classes should be accessible through it
++            // in any case or JVM class loading is severely broken
++            loader = this.getClass().getClassLoader();
++        }
++        // The result is not cached since caching
++        // Thread.getContextClassLoader prevents it from GC which
++        // may lead to a memory leak.
++        return loader;
++    }
++
++    public void setApplicationClassLoader(ClassLoader loader)
++    {
++        if (loader == null) {
++            // restore default behaviour
++            applicationClassLoader = null;
++            return;
++        }
++        if (!testIfCanUseLoader(loader)) {
++            throw new IllegalArgumentException(
++                "Loader can not resolve Rhino classes");
++        }
++        applicationClassLoader = loader;
++    }
++
++    private boolean testIfCanUseLoader(ClassLoader loader)
++    {
++        // If Context was subclussed, cxClass != Context.class
++        Class cxClass = this.getClass();
++        // Check that Context or its suclass is accesible from this loader
++        Class x = ScriptRuntime.getClassOrNull(loader, cxClass.getName());
++        if (x != cxClass) {
++            // The check covers the case when x == null =>
++            // threadLoader does not know about Rhino or the case
++            // when x != null && x != cxClass =>
++            // threadLoader loads unrelated Rhino instance
++            return false;
++        }
++        return true;
+     }
+ 
+     /********** end of API **********/
+@@ -2169,6 +2227,24 @@
+         } catch (Exception ex) { }
+     }
+ 
++    // We'd like to use "Thread.getContextClassLoader", but
++    // that's only available on Java2.
++    private static Method method_getContextClassLoader;
++
++    static {
++        // Don't use "Thread.class": that performs the lookup
++        // in the class initializer, which doesn't allow us to
++        // catch possible security exceptions.
++        Class threadClass = ScriptRuntime.getClassOrNull("java.lang.Thread");
++        if (threadClass != null) {
++            try {
++                method_getContextClassLoader =
++                    threadClass.getDeclaredMethod("getContextClassLoader",
++                                                   new Class[0]);
++            } catch (Exception ex) { }
++        }
++    }
++
+     private static final Object contextListenersLock = new Object();
+     private static Object[] contextListeners;
+ 
+@@ -2203,6 +2279,7 @@
+     private int enterCount;
+     private Object[] listeners;
+     private Hashtable hashtable;
++    private ClassLoader applicationClassLoader;
+ 
+     /**
+      * This is the list of names of objects forcing the creation of
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/DefiningClassLoader.java	2005-02-01 18:05:46.693066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/DefiningClassLoader.java	2005-02-01 18:06:02.263025000 +0000
+@@ -49,11 +49,34 @@
+     implements GeneratedClassLoader
+ {
+     public DefiningClassLoader() {
+-        this.parentLoader = getClass().getClassLoader();
++        init(getClass().getClassLoader());
+     }
+ 
+     public DefiningClassLoader(ClassLoader parentLoader) {
++
++        init(parentLoader);
++    }
++
++    private void init(ClassLoader parentLoader) {
++
+         this.parentLoader = parentLoader;
++
++        this.contextLoader = null;
++        if (method_getContextClassLoader != null) {
++            try {
++                this.contextLoader = (ClassLoader)
++                    method_getContextClassLoader.invoke(
++                        Thread.currentThread(),
++                        ScriptRuntime.emptyArgs);
++            } catch (IllegalAccessException ex) {
++            } catch (InvocationTargetException ex) {
++            } catch (SecurityException ex) {
++            }
++            if (this.contextLoader == this.parentLoader) {
++                this.contextLoader = null;
++            }
++        }
++
+     }
+ 
+     public Class defineClass(String name, byte[] data) {
+@@ -67,18 +90,66 @@
+     public Class loadClass(String name, boolean resolve)
+         throws ClassNotFoundException
+     {
+-        Class clazz = findLoadedClass(name);
+-        if (clazz == null) {
+-            if (parentLoader != null) {
+-                clazz = parentLoader.loadClass(name);
++
++        Class cl = findLoadedClass(name);
++        if (cl == null) {
++            // First try parent class loader and if that does not work, try
++            // contextLoader, but that will be null if
++            // Thread.getContextClassLoader() == parentLoader
++            // or on JDK 1.1 due to lack Thread.getContextClassLoader().
++            // To avoid catching and rethrowing ClassNotFoundException
++            // in this cases, use try/catch check only if contextLoader != null.
++            if (contextLoader == null) {
++                cl = loadFromParent(name);
++
+             } else {
+-                clazz = findSystemClass(name);
++
++                try {
++                    cl = loadFromParent(name);
++                } catch (ClassNotFoundException ex) {
++                    cl = contextLoader.loadClass(name);
++                }
++
+             }
+         }
+-        if (resolve)
+-            resolveClass(clazz);
+-        return clazz;
++
++        if (resolve) {
++            resolveClass(cl);
++        }
++        return cl;
++    }
++
++    private Class loadFromParent(String name)
++        throws ClassNotFoundException
++    {
++        if (parentLoader != null) {
++            return parentLoader.loadClass(name);
++        } else {
++            return findSystemClass(name);
++        }
++
+     }
+ 
+     private ClassLoader parentLoader;
++
++    private ClassLoader contextLoader;
++
++    // We'd like to use "Thread.getContextClassLoader", but
++    // that's only available on Java2.
++    private static Method method_getContextClassLoader;
++
++    static {
++        try {
++            // Don't use "Thread.class": that performs the lookup
++            // in the class initializer, which doesn't allow us to
++            // catch possible security exceptions.
++            Class threadClass = Class.forName("java.lang.Thread");
++            method_getContextClassLoader =
++                threadClass.getDeclaredMethod("getContextClassLoader",
++                                               new Class[0]);
++        } catch (ClassNotFoundException e) {
++        } catch (NoSuchMethodException e) {
++        } catch (SecurityException e) {
++        }
++    }
+ }
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/ImporterTopLevel.java	2005-02-01 18:05:47.143066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/ImporterTopLevel.java	2005-02-01 18:06:02.693023000 +0000
+@@ -97,10 +97,21 @@
+         return "global";
+     }
+ 
++    public boolean has(String name, Scriptable start) {
++        return super.has(name, start)
++               || getPackageProperty(name, start) != NOT_FOUND;
++    }
++
+     public Object get(String name, Scriptable start) {
+         Object result = super.get(name, start);
+         if (result != NOT_FOUND)
+             return result;
++        result = getPackageProperty(name, start);
++        return result;
++    }
++
++    private Object getPackageProperty(String name, Scriptable start) {
++        Object result= NOT_FOUND;
+         if (name.equals("_packages_"))
+             return result;
+         Object plist = ScriptableObject.getProperty(start,"_packages_");
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/JavaAdapter.java	2005-02-01 18:05:46.293068000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/JavaAdapter.java	2005-02-01 18:06:01.993024000 +0000
+@@ -331,7 +331,7 @@
+             }
+         }
+ 
+-        ClassLoader parentLoader = cx.getClass().getClassLoader();
++        ClassLoader parentLoader = cx.getApplicationClassLoader();
+         GeneratedClassLoader loader;
+         SecurityController sc = cx.getSecurityController();
+         if (sc == null) {
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/NativeJavaPackage.java	2005-02-01 18:05:47.173068000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/NativeJavaPackage.java	2005-02-01 18:06:02.733022000 +0000
+@@ -166,22 +166,30 @@
+     }
+ 
+     public NativeJavaPackage(String packageName) {
+-        this.packageName = packageName;
++        this(packageName, null);
+     }
+ 
+     public NativeJavaPackage(String packageName, ClassLoader classLoader) {
+         this.packageName = packageName;
++        if (classLoader != null) {
+         this.classLoader = classLoader;
++        } else {
++            this.classLoader = Context.getContext().getApplicationClassLoader();
++        }
+     }
+ 
+     public String getClassName() {
+         return "JavaPackage";
+     }
+ 
+-    public boolean has(String id, int index, Scriptable start) {
++    public boolean has(String id, Scriptable start) {
+         return true;
+     }
+ 
++    public boolean has(int index, Scriptable start) {
++        return false;
++    }
++
+     public void put(String id, Scriptable start, Object value) {
+         // Can't add properties to Java packages.  Sorry.
+     }
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/Codegen.java	2005-02-01 18:05:46.933066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/Codegen.java	2005-02-01 18:06:02.493021000 +0000
+@@ -80,7 +80,7 @@
+ 
+         Exception e = null;
+         Class result = null;
+-        ClassLoader parentLoader = cx.getClass().getClassLoader();
++        ClassLoader parentLoader = cx.getApplicationClassLoader();
+         GeneratedClassLoader loader;
+         if (securityController == null) {
+             loader = cx.createClassLoader(parentLoader);
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/InvokerImpl.java	2005-02-01 18:05:47.033066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/InvokerImpl.java	2005-02-01 18:06:02.583023000 +0000
+@@ -58,7 +58,7 @@
+         synchronized (this) {
+             if (invokersCache == null) {
+                 invokersCache = new Hashtable();
+-                ClassLoader parentLoader = cx.getClass().getClassLoader();
++                ClassLoader parentLoader = cx.getApplicationClassLoader();
+                 classLoader = cx.createClassLoader(parentLoader);
+             } else {
+                 result = (Invoker)invokersCache.get(method);
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/ScriptRuntime.java	2005-02-01 18:05:46.483070000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/ScriptRuntime.java	2005-02-01 18:06:02.053022000 +0000
+@@ -2001,11 +2001,27 @@
+         cx.currentActivation = activation;
+     }
+ 
+-    private static Class getClassOrNull(String className) {
++    static Class getClassOrNull(String className) {
+         try {
+             return Class.forName(className);
+         } catch  (ClassNotFoundException ex) {
+         } catch  (SecurityException ex) {
++        } catch (IllegalArgumentException e) {
++            // Can be thrown if name has characters that a class name
++            // can not contain
++        }
++        return null;
++    }
++
++    static Class getClassOrNull(ClassLoader loader, String className)
++    {
++        try {
++            return loader.loadClass(className);
++        } catch (ClassNotFoundException ex) {
++        } catch (SecurityException ex) {
++        } catch (IllegalArgumentException e) {
++            // Can be thrown if name has characters that a class name
++            // can not contain
+         }
+         return null;
+     }
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractCellEditor.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractCellEditor.java	2005-02-01 18:06:04.443018000 +0000
+@@ -0,0 +1,62 @@
++package org.mozilla.javascript.tools.debugger;
++
++import java.awt.Component;
++import java.awt.event.*;
++import java.awt.AWTEvent;
++import javax.swing.*;
++import javax.swing.event.*;
++import java.util.EventObject;
++import java.io.Serializable;
++
++public class AbstractCellEditor implements CellEditor {
++
++    protected EventListenerList listenerList = new EventListenerList();
++
++    public Object getCellEditorValue() { return null; }
++    public boolean isCellEditable(EventObject e) { return true; }
++    public boolean shouldSelectCell(EventObject anEvent) { return false; }
++    public boolean stopCellEditing() { return true; }
++    public void cancelCellEditing() {}
++
++    public void addCellEditorListener(CellEditorListener l) {
++	listenerList.add(CellEditorListener.class, l);
++    }
++
++    public void removeCellEditorListener(CellEditorListener l) {
++	listenerList.remove(CellEditorListener.class, l);
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  
++     * @see EventListenerList
++     */
++    protected void fireEditingStopped() {
++	// Guaranteed to return a non-null array
++	Object[] listeners = listenerList.getListenerList();
++	// Process the listeners last to first, notifying
++	// those that are interested in this event
++	for (int i = listeners.length-2; i>=0; i-=2) {
++	    if (listeners[i]==CellEditorListener.class) {
++		((CellEditorListener)listeners[i+1]).editingStopped(new ChangeEvent(this));
++	    }	       
++	}
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  
++     * @see EventListenerList
++     */
++    protected void fireEditingCanceled() {
++	// Guaranteed to return a non-null array
++	Object[] listeners = listenerList.getListenerList();
++	// Process the listeners last to first, notifying
++	// those that are interested in this event
++	for (int i = listeners.length-2; i>=0; i-=2) {
++	    if (listeners[i]==CellEditorListener.class) {
++		((CellEditorListener)listeners[i+1]).editingCanceled(new ChangeEvent(this));
++	    }	       
++	}
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractTreeTableModel.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractTreeTableModel.java	2005-02-01 18:06:04.453017000 +0000
+@@ -0,0 +1,196 @@
++/*
++ * @(#)AbstractTreeTableModel.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.tree.*;
++import javax.swing.event.*;
++ 
++/**
++ * @version 1.2 10/27/98
++ * An abstract implementation of the TreeTableModel interface, handling the list 
++ * of listeners. 
++ * @author Philip Milne
++ */
++
++public abstract class AbstractTreeTableModel implements TreeTableModel {
++    protected Object root;     
++    protected EventListenerList listenerList = new EventListenerList();
++  
++    public AbstractTreeTableModel(Object root) {
++        this.root = root; 
++    }
++
++    //
++    // Default implmentations for methods in the TreeModel interface. 
++    //
++
++    public Object getRoot() {
++        return root;
++    }
++
++    public boolean isLeaf(Object node) {
++        return getChildCount(node) == 0; 
++    }
++
++    public void valueForPathChanged(TreePath path, Object newValue) {}
++
++    // This is not called in the JTree's default mode: use a naive implementation. 
++    public int getIndexOfChild(Object parent, Object child) {
++        for (int i = 0; i < getChildCount(parent); i++) {
++	    if (getChild(parent, i).equals(child)) { 
++	        return i; 
++	    }
++        }
++	return -1; 
++    }
++
++    public void addTreeModelListener(TreeModelListener l) {
++        listenerList.add(TreeModelListener.class, l);
++    }
++
++    public void removeTreeModelListener(TreeModelListener l) {
++        listenerList.remove(TreeModelListener.class, l);
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesChanged(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesInserted(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesRemoved(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeStructureChanged(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
++            }          
++        }
++    }
++
++    //
++    // Default impelmentations for methods in the TreeTableModel interface. 
++    //
++
++    public Class getColumnClass(int column) { return Object.class; }
++
++   /** By default, make the column with the Tree in it the only editable one. 
++    *  Making this column editable causes the JTable to forward mouse 
++    *  and keyboard events in the Tree column to the underlying JTree. 
++    */ 
++    public boolean isCellEditable(Object node, int column) { 
++         return getColumnClass(column) == TreeTableModel.class; 
++    }
++
++    public void setValueAt(Object aValue, Object node, int column) {}
++
++
++    // Left to be implemented in the subclass:
++
++    /* 
++     *   public Object getChild(Object parent, int index)
++     *   public int getChildCount(Object parent) 
++     *   public int getColumnCount() 
++     *   public String getColumnName(Object node, int column)  
++     *   public Object getValueAt(Object node, int column) 
++     */
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/JTreeTable.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/JTreeTable.java	2005-02-01 18:06:04.463017000 +0000
+@@ -0,0 +1,354 @@
++/*
++ * @(#)JTreeTable.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.*;
++import javax.swing.event.*;
++import javax.swing.tree.*;
++import javax.swing.table.*;
++
++import java.awt.Dimension;
++import java.awt.Component;
++import java.awt.Graphics;
++import java.awt.Rectangle;
++
++import java.awt.event.MouseEvent;
++
++import java.util.EventObject;
++
++/**
++ * This example shows how to create a simple JTreeTable component, 
++ * by using a JTree as a renderer (and editor) for the cells in a 
++ * particular column in the JTable.  
++ *
++ * @version 1.2 10/27/98
++ *
++ * @author Philip Milne
++ * @author Scott Violet
++ */
++public class JTreeTable extends JTable {
++    /** A subclass of JTree. */
++    protected TreeTableCellRenderer tree;
++
++    public JTreeTable(TreeTableModel treeTableModel) {
++	super();
++
++	// Create the tree. It will be used as a renderer and editor. 
++	tree = new TreeTableCellRenderer(treeTableModel);
++
++	// Install a tableModel representing the visible rows in the tree. 
++	super.setModel(new TreeTableModelAdapter(treeTableModel, tree));
++
++	// Force the JTable and JTree to share their row selection models. 
++	ListToTreeSelectionModelWrapper selectionWrapper = new 
++	                        ListToTreeSelectionModelWrapper();
++	tree.setSelectionModel(selectionWrapper);
++	setSelectionModel(selectionWrapper.getListSelectionModel()); 
++
++	// Install the tree editor renderer and editor. 
++	setDefaultRenderer(TreeTableModel.class, tree); 
++	setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
++
++	// No grid.
++	setShowGrid(false);
++
++	// No intercell spacing
++	setIntercellSpacing(new Dimension(0, 0));	
++
++	// And update the height of the trees row to match that of
++	// the table.
++	if (tree.getRowHeight() < 1) {
++	    // Metal looks better like this.
++	    setRowHeight(18);
++	}
++    }
++
++    /**
++     * Overridden to message super and forward the method to the tree.
++     * Since the tree is not actually in the component hieachy it will
++     * never receive this unless we forward it in this manner.
++     */
++    public void updateUI() {
++	super.updateUI();
++	if(tree != null) {
++	    tree.updateUI();
++	}
++	// Use the tree's default foreground and background colors in the
++	// table. 
++        LookAndFeel.installColorsAndFont(this, "Tree.background",
++                                         "Tree.foreground", "Tree.font");
++    }
++
++    /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to 
++     * paint the editor. The UI currently uses different techniques to 
++     * paint the renderers and editors and overriding setBounds() below 
++     * is not the right thing to do for an editor. Returning -1 for the 
++     * editing row in this case, ensures the editor is never painted. 
++     */
++    public int getEditingRow() {
++        return (getColumnClass(editingColumn) == TreeTableModel.class) ? -1 :
++	        editingRow;  
++    }
++
++    /**
++     * Overridden to pass the new rowHeight to the tree.
++     */
++    public void setRowHeight(int rowHeight) { 
++        super.setRowHeight(rowHeight); 
++	if (tree != null && tree.getRowHeight() != rowHeight) {
++            tree.setRowHeight(getRowHeight()); 
++	}
++    }
++
++    /**
++     * Returns the tree that is being shared between the model.
++     */
++    public JTree getTree() {
++	return tree;
++    }
++
++    /**
++     * A TreeCellRenderer that displays a JTree.
++     */
++    public class TreeTableCellRenderer extends JTree implements
++	         TableCellRenderer {
++	/** Last table/tree row asked to renderer. */
++	protected int visibleRow;
++
++	public TreeTableCellRenderer(TreeModel model) {
++	    super(model); 
++	}
++
++	/**
++	 * updateUI is overridden to set the colors of the Tree's renderer
++	 * to match that of the table.
++	 */
++	public void updateUI() {
++	    super.updateUI();
++	    // Make the tree's cell renderer use the table's cell selection
++	    // colors. 
++	    TreeCellRenderer tcr = getCellRenderer();
++	    if (tcr instanceof DefaultTreeCellRenderer) {
++		DefaultTreeCellRenderer dtcr = ((DefaultTreeCellRenderer)tcr); 
++		// For 1.1 uncomment this, 1.2 has a bug that will cause an
++		// exception to be thrown if the border selection color is
++		// null.
++		// dtcr.setBorderSelectionColor(null);
++		dtcr.setTextSelectionColor(UIManager.getColor
++					   ("Table.selectionForeground"));
++		dtcr.setBackgroundSelectionColor(UIManager.getColor
++						("Table.selectionBackground"));
++	    }
++	}
++
++	/**
++	 * Sets the row height of the tree, and forwards the row height to
++	 * the table.
++	 */
++	public void setRowHeight(int rowHeight) { 
++	    if (rowHeight > 0) {
++		super.setRowHeight(rowHeight); 
++		if (JTreeTable.this != null &&
++		    JTreeTable.this.getRowHeight() != rowHeight) {
++		    JTreeTable.this.setRowHeight(getRowHeight()); 
++		}
++	    }
++	}
++
++	/**
++	 * This is overridden to set the height to match that of the JTable.
++	 */
++	public void setBounds(int x, int y, int w, int h) {
++	    super.setBounds(x, 0, w, JTreeTable.this.getHeight());
++	}
++
++	/**
++	 * Sublcassed to translate the graphics such that the last visible
++	 * row will be drawn at 0,0.
++	 */
++	public void paint(Graphics g) {
++	    g.translate(0, -visibleRow * getRowHeight());
++	    super.paint(g);
++	}
++
++	/**
++	 * TreeCellRenderer method. Overridden to update the visible row.
++	 */
++	public Component getTableCellRendererComponent(JTable table,
++						       Object value,
++						       boolean isSelected,
++						       boolean hasFocus,
++						       int row, int column) {
++	    if(isSelected)
++		setBackground(table.getSelectionBackground());
++	    else
++		setBackground(table.getBackground());
++
++	    visibleRow = row;
++	    return this;
++	}
++    }
++
++
++    /**
++     * TreeTableCellEditor implementation. Component returned is the
++     * JTree.
++     */
++    public class TreeTableCellEditor extends AbstractCellEditor implements
++	         TableCellEditor {
++	public Component getTableCellEditorComponent(JTable table,
++						     Object value,
++						     boolean isSelected,
++						     int r, int c) {
++	    return tree;
++	}
++
++	/**
++	 * Overridden to return false, and if the event is a mouse event
++	 * it is forwarded to the tree.<p>
++	 * The behavior for this is debatable, and should really be offered
++	 * as a property. By returning false, all keyboard actions are
++	 * implemented in terms of the table. By returning true, the
++	 * tree would get a chance to do something with the keyboard
++	 * events. For the most part this is ok. But for certain keys,
++	 * such as left/right, the tree will expand/collapse where as
++	 * the table focus should really move to a different column. Page
++	 * up/down should also be implemented in terms of the table.
++	 * By returning false this also has the added benefit that clicking
++	 * outside of the bounds of the tree node, but still in the tree
++	 * column will select the row, whereas if this returned true
++	 * that wouldn't be the case.
++	 * <p>By returning false we are also enforcing the policy that
++	 * the tree will never be editable (at least by a key sequence).
++	 */
++	public boolean isCellEditable(EventObject e) {
++	    if (e instanceof MouseEvent) {
++		for (int counter = getColumnCount() - 1; counter >= 0;
++		     counter--) {
++		    if (getColumnClass(counter) == TreeTableModel.class) {
++			MouseEvent me = (MouseEvent)e;
++			MouseEvent newME = new MouseEvent(tree, me.getID(),
++				   me.getWhen(), me.getModifiers(),
++				   me.getX() - getCellRect(0, counter, true).x,
++				   me.getY(), me.getClickCount(),
++                                   me.isPopupTrigger());
++			tree.dispatchEvent(newME);
++			break;
++		    }
++		}
++	    }
++	    return false;
++	}
++    }
++
++
++    /**
++     * ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel
++     * to listen for changes in the ListSelectionModel it maintains. Once
++     * a change in the ListSelectionModel happens, the paths are updated
++     * in the DefaultTreeSelectionModel.
++     */
++    class ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel { 
++	/** Set to true when we are updating the ListSelectionModel. */
++	protected boolean         updatingListSelectionModel;
++
++	public ListToTreeSelectionModelWrapper() {
++	    super();
++	    getListSelectionModel().addListSelectionListener
++	                            (createListSelectionListener());
++	}
++
++	/**
++	 * Returns the list selection model. ListToTreeSelectionModelWrapper
++	 * listens for changes to this model and updates the selected paths
++	 * accordingly.
++	 */
++	ListSelectionModel getListSelectionModel() {
++	    return listSelectionModel; 
++	}
++
++	/**
++	 * This is overridden to set <code>updatingListSelectionModel</code>
++	 * and message super. This is the only place DefaultTreeSelectionModel
++	 * alters the ListSelectionModel.
++	 */
++	public void resetRowSelection() {
++	    if(!updatingListSelectionModel) {
++		updatingListSelectionModel = true;
++		try {
++		    super.resetRowSelection();
++		}
++		finally {
++		    updatingListSelectionModel = false;
++		}
++	    }
++	    // Notice how we don't message super if
++	    // updatingListSelectionModel is true. If
++	    // updatingListSelectionModel is true, it implies the
++	    // ListSelectionModel has already been updated and the
++	    // paths are the only thing that needs to be updated.
++	}
++
++	/**
++	 * Creates and returns an instance of ListSelectionHandler.
++	 */
++	protected ListSelectionListener createListSelectionListener() {
++	    return new ListSelectionHandler();
++	}
++
++	/**
++	 * If <code>updatingListSelectionModel</code> is false, this will
++	 * reset the selected paths from the selected rows in the list
++	 * selection model.
++	 */
++	protected void updateSelectedPathsFromSelectedRows() {
++	    if(!updatingListSelectionModel) {
++		updatingListSelectionModel = true;
++		try {
++		    // This is way expensive, ListSelectionModel needs an
++		    // enumerator for iterating.
++		    int        min = listSelectionModel.getMinSelectionIndex();
++		    int        max = listSelectionModel.getMaxSelectionIndex();
++
++		    clearSelection();
++		    if(min != -1 && max != -1) {
++			for(int counter = min; counter <= max; counter++) {
++			    if(listSelectionModel.isSelectedIndex(counter)) {
++				TreePath     selPath = tree.getPathForRow
++				                            (counter);
++
++				if(selPath != null) {
++				    addSelectionPath(selPath);
++				}
++			    }
++			}
++		    }
++		}
++		finally {
++		    updatingListSelectionModel = false;
++		}
++	    }
++	}
++
++	/**
++	 * Class responsible for calling updateSelectedPathsFromSelectedRows
++	 * when the selection of the list changse.
++	 */
++	class ListSelectionHandler implements ListSelectionListener {
++	    public void valueChanged(ListSelectionEvent e) {
++		updateSelectedPathsFromSelectedRows();
++	    }
++	}
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/Main.java	2005-02-01 18:05:48.773063000 +0000
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/Main.java	2005-02-01 18:06:04.413018000 +0000
+@@ -469,17 +469,23 @@
+         case KeyEvent.VK_BACK_SPACE:
+         case KeyEvent.VK_ENTER:
+         case KeyEvent.VK_DELETE:
++            if (w.isEditable() == false) {
+             e.consume();
++            }
+             break;
+         }
+     }
+     public void keyTyped(KeyEvent e) {
++        if (w.isEditable() == false) {
+         e.consume();
+     }
++    }
+     public void keyReleased(KeyEvent e) {
++        if (w.isEditable() == false) {
+         e.consume();
+     }
+ }
++}
+ 
+ class MoreWindows extends JDialog implements ActionListener {
+ 
+@@ -818,6 +824,7 @@
+         if (dummy.length() < 2) {
+             dummy = "99";
+         }
++
+         int maxWidth = metrics.stringWidth(dummy);
+         int startLine = clip.y / h;
+         int endLine = (clip.y + clip.height) / h + 1;
+@@ -868,7 +875,8 @@
+     }
+ };
+ 
+-class FileWindow extends JInternalFrame implements ActionListener {
++class FileWindow extends JInternalFrame
++    implements ActionListener, DocumentListener {
+ 
+     Main db;
+     SourceInfo sourceInfo;
+@@ -877,15 +885,16 @@
+     JScrollPane p;
+     int currentPos;
+     JLabel statusBar;
++    boolean isModified = false;
+ 
+     public void actionPerformed(ActionEvent e) {
+         String cmd = e.getActionCommand();
+         if (cmd.equals("Cut")) {
+-            // textArea.cut();
++            textArea.cut();
+         } else if (cmd.equals("Copy")) {
+             textArea.copy();
+         } else if (cmd.equals("Paste")) {
+-            // textArea.paste();
++            textArea.paste();
+         }
+     }
+ 
+@@ -899,15 +908,71 @@
+     }
+ 
+     void load() {
+-        Scriptable scope = db.getScope();
++        //Scriptable scope = db.getScope();
++        Scriptable scope = db.officeScripts.getScriptScope( getUrl() );
++        if ( scope == null )
++        {
++            scope = db.getScope();
++        }
++        
+         if (scope == null) {
+             MessageDialogWrapper.showMessageDialog(db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
+         } else {
+             String url = getUrl();
+             if (url != null) {
+-                new Thread(new LoadFile(db,scope,url)).start();
++                new Thread(new LoadFile(db,scope, url, new StringReader(textArea.getText()))).start(); 
++            }
++        }
+             }
++
++    void save() {
++        if (getUrl() != null) {
++            OutputStream os = null;
++            try {
++                if ( getUrl().startsWith("vnd.sun.star")  )
++                {
++                    URL scriptUrl = db.officeScripts.getScriptUrl( getUrl() );
++                    if ( scriptUrl == null )
++                    {
++                        throw new IOException("Can't optain stream for " + getUrl() );
+         }
++                    os = scriptUrl.openConnection().getOutputStream();
++                }
++                else
++                {
++                   os = new FileOutputStream( getUrl() );
++                }
++                String s = textArea.getText();
++                os.write(s.getBytes(), 0, s.length());
++
++                this.isModified = false;
++            }
++            catch (IOException ioe) {
++                JOptionPane.showMessageDialog(this,
++                    "Error saving file: " + ioe.getMessage(),
++                    "Error", JOptionPane.ERROR_MESSAGE);
++            }
++            finally
++            {
++                if ( os != null )
++                {
++                    try
++                    {
++                        os.close();
++                        os = null;
++                    }
++                    catch( IOException ioe )
++                    {
++                        System.err.println("Error closing stream: " + ioe.getMessage() );
++                        ioe.printStackTrace();
++                    }
++                }
++            }
++        }
++    }
++
++    public boolean isEditable() {
++        return db.isSourceEditingEnabled();
+     }
+ 
+    public int getPosition(int line) {
+@@ -942,7 +1007,7 @@
+             fileHeader.repaint();
+         }
+     }
+-
++    public Main getDB() { return db; }
+     FileWindow(Main db, SourceInfo sourceInfo) {
+         super(SourceInfo.getShortName(sourceInfo.getUrl()),
+               true, true, true, true);
+@@ -961,6 +1026,16 @@
+         pack();
+         updateText();
+         textArea.select(0);
++        addInternalFrameListener( new InternalFrameAdapter() {
++            public void internalFrameClosed(InternalFrameEvent e) {
++                    // clean up scriptItems and sourceNames hashes
++                    getDB().removeScript( getUrl() );
++                    // remove scripts for officeScripts
++                    getDB().officeScripts.deleteScript( getUrl() );
++                }
++            } );
++                
++
+     }
+ 
+     private void updateToolTip() {
+@@ -979,7 +1054,10 @@
+     void updateText() {
+         String newText = sourceInfo.getSource();
+         if (!textArea.getText().equals(newText)) {
++            textArea.getDocument().removeDocumentListener(this);
+             textArea.setText(newText);
++            this.isModified = false;
++            textArea.getDocument().addDocumentListener(this);
+             int pos = 0;
+             if (currentPos != -1) {
+                 pos = currentPos;
+@@ -990,6 +1068,31 @@
+         fileHeader.repaint();
+     }
+ 
++    /* Implementation of DocumentListener interface */
++    public void insertUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void removeUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void changedUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void doChanged(DocumentEvent e) {
++        this.isModified = true;
++    }
++
++    public boolean isModified() {
++        return this.isModified;
++    }
++
++    public String getText() {
++        return textArea.getText();
++    }
++
+     void setPosition(int pos) {
+         textArea.select(pos);
+         currentPos = pos;
+@@ -1601,7 +1704,7 @@
+         if (line != -1) {
+             db.currentWindow = w;
+         }
+-        db.menubar.addFile(url);
++        // db.menubar.addFile(url);
+         w.setVisible(true);
+         if (activate) {
+             try {
+@@ -1735,8 +1838,10 @@
+     Menubar(Main db) {
+         super();
+         this.db = db;
+-        String[] fileItems  = {"Open...", "Run...", "", "Exit"};
+-        String[] fileCmds  = {"Open", "Load", "", "Exit"};
++        // String[] fileItems  = {"Open...", "Run...", "", "Exit"};
++        // String[] fileCmds  = {"Open", "Load", "", "Exit"};
++        String[] fileItems  = {"Run", "Save", "", "Exit"};
++        String[] fileCmds  = {"Run", "Save", "", "Exit"};
+         char[] fileShortCuts = {'0', 'N', '\0', 'X'};
+         int[] fileAccelerators = {KeyEvent.VK_O,
+                                   KeyEvent.VK_N,
+@@ -1778,6 +1883,9 @@
+                     KeyStroke k = KeyStroke.getKeyStroke(fileAccelerators[i], Event.CTRL_MASK);
+                     item.setAccelerator(k);
+                 }
++                if (fileItems[i].equals("Save")) {
++                    saveItem = item;
++                }
+             }
+         }
+         for (int i = 0; i < editItems.length; ++i) {
+@@ -1832,9 +1940,9 @@
+         item.addActionListener(this);
+         windowMenu.add(item = new JMenuItem("Tile", 'T'));
+         item.addActionListener(this);
+-        windowMenu.addSeparator();
+-        windowMenu.add(item = new JMenuItem("Console", 'C'));
+-        item.addActionListener(this);
++        // windowMenu.addSeparator();
++        // windowMenu.add(item = new JMenuItem("Console", 'C'));
++        // item.addActionListener(this);
+         add(windowMenu);
+ 
+     }
+@@ -1908,11 +2016,16 @@
+         item.addActionListener(this);
+     }
+ 
++    public void setSaveEnabled(boolean state) {
++        saveItem.setEnabled(state);
++    }
++
+     Main db;
+     JMenu windowMenu;
+     JCheckBoxMenuItem breakOnExceptions;
+     JCheckBoxMenuItem breakOnEnter;
+     JCheckBoxMenuItem breakOnReturn;
++    JMenuItem saveItem;
+ };
+ 
+ class EnterInterrupt implements Runnable {
+@@ -1925,6 +2038,13 @@
+     public void run() {
+         JMenu menu = db.getJMenuBar().getMenu(0);
+         //menu.getItem(0).setEnabled(false); // File->Load
++
++        // disable Edit menu Cut, Copy, Paste items
++        menu = db.getJMenuBar().getMenu(1);
++        for (int i = 0; i < 3; i++) {
++            menu.getItem(i).setEnabled(false);
++        }
++
+         menu = db.getJMenuBar().getMenu(2);
+         menu.getItem(0).setEnabled(false); // Debug->Break
+         int count = menu.getItemCount();
+@@ -1937,6 +2057,10 @@
+             b = true;
+         }
+         db.toolBar.setEnabled(true);
++
++        // set flag to disable source editing
++        db.setSourceEditingEnabled(false);
++
+         // raise the debugger window
+         db.toFront();
+     }
+@@ -1950,6 +2074,13 @@
+     public void run() {
+         JMenu menu = db.getJMenuBar().getMenu(0);
+         menu.getItem(0).setEnabled(true); // File->Load
++
++        // enable Edit menu items
++        menu = db.getJMenuBar().getMenu(1);
++        for (int i = 0; i < 3; i++) {
++            menu.getItem(i).setEnabled(true);
++        }
++
+         menu = db.getJMenuBar().getMenu(2);
+         menu.getItem(0).setEnabled(true); // Debug->Break
+         int count = menu.getItemCount() - 1;
+@@ -1963,6 +2094,9 @@
+             db.toolBar.getComponent(ci).setEnabled(b);
+             b = false;
+         }
++        // set flag to enable source editing
++        db.setSourceEditingEnabled(true);
++
+         //db.console.consoleTextArea.requestFocus();
+     }
+ };
+@@ -1971,17 +2105,24 @@
+     Scriptable scope;
+     String fileName;
+     Main db;
++    Reader reader = null;
++
+     OpenFile(Main db, Scriptable scope, String fileName) {
+         this.scope = scope;
+         this.fileName = fileName;
+         this.db = db;
+     }
++    OpenFile(Main db, Scriptable scope, String fileName, Reader reader) {
++        this(db, scope, fileName);
++        this.reader = reader;
++    }
+     public void run() {
+         Context cx = Context.enter();
+         ContextData contextData = ContextData.get(cx);
+         contextData.breakNextLine = true;
+         try {
+-            cx.compileReader(scope, new FileReader(fileName),
++            cx.compileReader(scope,
++                reader == null ? new FileReader(fileName) : reader,
+                              fileName, 1, null);
+         } catch (Exception exc) {
+             String msg = exc.getMessage();
+@@ -2003,29 +2144,80 @@
+     Scriptable scope;
+     String fileName;
+     Main db;
++    Reader reader = null;
++    Object result = null;
++    Exception exception = null;
++    int lineNum = -1;
++    boolean sfExecute = false;
++    
+     LoadFile(Main db, Scriptable scope, String fileName) {
+         this.scope = scope;
+         this.fileName = fileName;
+         this.db = db;
+     }
++
++    LoadFile(Main db, Scriptable scope, String fileName, Reader reader) {
++        this(db, scope, fileName);
++        this.reader = reader;
++    }
++    LoadFile(Main db, Scriptable scope, String fileName, Reader reader, boolean sfExecute ) {
++        this(db, scope, fileName);
++        this.reader = reader;
++        this.sfExecute = sfExecute;
++    }
++
+     public void run() {
++        if ( db.officeScripts.isScriptRunning( fileName ) )
++        { 
++            exception = new Exception("The script is already executing");
++            if ( !sfExecute ) {
++                MessageDialogWrapper.showMessageDialog(db,
++                                                   "Script already executing",
++                                                   "Run",
++                                                   JOptionPane.ERROR_MESSAGE);
++            }
++            return;
++        } 
++        db.officeScripts.setScriptRunning( fileName, true );
+         Context cx = Context.enter();
+         ContextData contextData = ContextData.get(cx);
++        if ( sfExecute )
++        {
++            contextData.breakNextLine = false;
++        }
++        else
++        {
+         contextData.breakNextLine = true;
++        }
++        /*
++        FileWindow w = (FileWindow)db.getSelectedFrame();
++        if ( sfExecute )        
++        {
++            db.swingInvoke(new SetFilePosition(db, w, -1 ) );                
++        }*/
+         try {
+-            cx.evaluateReader(scope, new FileReader(fileName),
++            result = cx.evaluateReader(scope,
++                reader == null ? new FileReader(fileName) : reader,
+                               fileName, 1, null);
+         } catch (Exception exc) {
++            exception = exc;
+             String msg = exc.getMessage();
+             if (exc instanceof EcmaError) {
+                 EcmaError err = (EcmaError)exc;
+                 msg = err.getSourceName() + ", line " + err.getLineNumber() + ": " + msg;
+-            }
++    
++                int lineNum =  err.getLineNumber() ;
++                //db.swingInvoke(new SetFilePosition(db, w, lineNum ) );
++                if ( !sfExecute ) {
+             MessageDialogWrapper.showMessageDialog(db,
+                                                    msg,
+                                                    "Run",
+                                                    JOptionPane.ERROR_MESSAGE);
++                }
++            }
++         
+         } finally {
++            db.officeScripts.setScriptRunning( fileName, false );
+             cx.exit();
+         }
+     }
+@@ -2400,13 +2592,13 @@
+         super.setVisible(b);
+         if (b) {
+             // this needs to be done after the window is visible
+-            console.consoleTextArea.requestFocus();
++            // console.consoleTextArea.requestFocus();
+             context.split.setDividerLocation(0.5);
+             try {
+-                console.setMaximum(true);
+-                console.setSelected(true);
+-                console.show();
+-                console.consoleTextArea.requestFocus();
++                // console.setMaximum(true);
++                // console.setSelected(true);
++                // console.show();
++                // console.consoleTextArea.requestFocus();
+             } catch (Exception exc) {
+             }
+         }
+@@ -2431,36 +2623,9 @@
+     private Hashtable scriptItems = new Hashtable();
+     private Hashtable sourceNames = new Hashtable();
+ 
++  
+     Hashtable functionNames = new Hashtable();
+ 
+-    ScriptItem getScriptItem(DebuggableScript fnOrScript) {
+-        ScriptItem item = (ScriptItem)scriptItems.get(fnOrScript);
+-        if (item == null) {
+-            String url = getNormilizedUrl(fnOrScript);
+-            SourceInfo si = (SourceInfo)sourceNames.get(url);
+-            if (si == null) {
+-                if (!fnOrScript.isGeneratedScript()) {
+-                    // Not eval or Function, try to load it from URL
+-                    String source = null;
+-                    try {
+-                        InputStream is = openSource(url);
+-                        try { source = readSource(is); }
+-                        finally { is.close(); }
+-                    } catch (IOException ex) {
+-                        System.err.println
+-                            ("Failed to load source from "+url+": "+ ex);
+-                    }
+-                    if (source != null) {
+-                        si = registerSource(url, source);
+-                    }
+-                }
+-            }
+-            if (si != null) {
+-                item = registerScript(si, fnOrScript);
+-            }
+-        }
+-        return item;
+-    }
+ 
+     /* Debugger Interface */
+ 
+@@ -2474,7 +2639,7 @@
+ 
+     String getNormilizedUrl(DebuggableScript fnOrScript) {
+         String url = fnOrScript.getSourceName();
+-        if (url == null) { url = "<stdin>"; }
++        if (url == null) { url = "document"; }
+         else {
+             // Not to produce window for eval from different lines,
+             // strip line numbers, i.e. replace all #[0-9]+\(eval\) by (eval)
+@@ -2586,6 +2751,8 @@
+                 si = new SourceInfo(sourceUrl, source);
+                 sourceNames.put(sourceUrl, si);
+             }
++            else if (!source.equals(si.getSource()))
++                si.setSource(source);
+         }
+         return si;
+     }
+@@ -2681,7 +2848,6 @@
+     EvalWindow evalWindow;
+     JSplitPane split1;
+     JLabel statusBar;
+-
+     void init() {
+         setJMenuBar(menubar = new Menubar(this));
+         toolBar = new JToolBar();
+@@ -2760,7 +2926,7 @@
+         desk = new JDesktopPane();
+         desk.setPreferredSize(new Dimension(600, 300));
+         desk.setMinimumSize(new Dimension(150, 50));
+-        desk.add(console = new JSInternalConsole("JavaScript Console"));
++        // desk.add(console = new JSInternalConsole("JavaScript Console"));
+         context = new ContextWindow(this);
+         context.setPreferredSize(new Dimension(600, 120));
+         context.setMinimumSize(new Dimension(50, 50));
+@@ -2828,6 +2994,7 @@
+             swingInvoke(UpdateFileText.action(w));
+             w.show();
+         } else if (!fileName.equals("<stdin>")) {
++            
+             swingInvoke(CreateFileWindow.action(this, si, -1));
+         }
+     }
+@@ -2869,7 +3036,7 @@
+             FrameHelper frame = contextData.getFrame(frameIndex);
+             String sourceName = frame.getUrl();
+             if (sourceName == null || sourceName.equals("<stdin>")) {
+-                console.show();
++                // console.show();
+                 helper.reset();
+                 return;
+             }
+@@ -2893,6 +3060,19 @@
+     int dispatcherIsWaiting = 0;
+     Context currentContext = null;
+ 
++    // Flag used to establish whether source code editing is allowed in
++    // the debugger, switched on and off depending on whether a debug session
++    // is active
++    boolean sourceEditingEnabled = true;
++
++    public boolean isSourceEditingEnabled() {
++        return sourceEditingEnabled;
++    }
++
++    void setSourceEditingEnabled(boolean b) {
++        sourceEditingEnabled = b;
++    }
++
+     Context getCurrentContext() {
+         return currentContext;
+     }
+@@ -3026,14 +3206,14 @@
+                     swingInvoke(CreateFileWindow.action(this, si, line));
+                 }
+             } else {
+-                if (console.isVisible()) {
++                /* if (console.isVisible()) {
+                     final JSInternalConsole finalConsole = console;
+                     swingInvoke(new Runnable() {
+                             public void run() {
+                                 finalConsole.show();
+                             }
+                         });
+-                }
++                } */
+             }
+             swingInvoke(new EnterInterrupt(this, cx));
+             swingInvoke(new UpdateContext(this, cx));
+@@ -3221,6 +3401,14 @@
+                                             fileName)).start();
+                 }
+             }
++        } else if (cmd.equals("Run")) {
++            FileWindow w = (FileWindow)getSelectedFrame();
++            if (w != null)
++                w.load();
++        } else if (cmd.equals("Save")) {
++            FileWindow w = (FileWindow)getSelectedFrame();
++            if (w != null)
++                w.save();
+         } else if (cmd.equals("More Windows...")) {
+             MoreWindows dlg = new MoreWindows(this, fileWindows,
+                                               "Window", "Files");
+@@ -3505,6 +3693,60 @@
+         }
+     }
+ 
++    JInternalFrame getFrameForUrl( URL url )
++    { 
++        JInternalFrame[] frames = desk.getAllFrames();
++        for (int i = 0; i < frames.length; i++) {
++           FileWindow w = (FileWindow)frames[i];
++           if ( url.toString().equals( w.getUrl() ) ) {
++               return w;
++               }
++           }
++        return null; 
++    } 
++    public void highlighLineInSelectedWindow(URL url, int lineNum ){
++        //FileWindow w = (FileWindow)getFrameForUrl( url );
++        FileWindow w = (FileWindow)getSelectedFrame();
++        if (w != null)
++        {
++            if ( lineNum > -1 )
++                swingInvoke(new SetFilePosition(this, w, lineNum ) );
++        }
++    }
++    public Object  runSelectedWindow( URL scriptUrl ) throws Exception
++    {
++        Object result = null;
++        FileWindow w = (FileWindow)getSelectedFrame();
++        //FileWindow w = (FileWindow)getFrameForUrl( scriptUrl );
++        w.toFront();
++        if (w != null)
++        {
++            Scriptable scope = w.db.getScope();
++            if (scope == null) 
++            {
++                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
++                result =  null;
++            } 
++            else 
++            {
++                String url = w.getUrl();
++                Thread executorThread = null;
++                if (url != null) 
++                {
++                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
++                    executor.run(); 
++                    result = executor.result;  
++                    if ( executor.exception != null )
++                    {
++                        throw executor.exception;
++                    }
++                }
++            }
++        }
++        return result;
++
++    }
++
+     //
+     // public interface
+     //
+@@ -3600,6 +3842,70 @@
+         return console.getErr();
+     }
+ 
++    public void openFile(URL scriptUrl, Scriptable scope, Runnable closeCallback ) {
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (scriptUrl != null) {
++                try
++                {
++                    InputStreamReader reader = new InputStreamReader(scriptUrl.openStream()); 
++                    String fileName = null;
++                    if ( scriptUrl.getProtocol().startsWith("vnd.sun.star.") )
++                    {
++                        fileName = scriptUrl.toString();
++                    }
++                    else
++                    {
++                        fileName = scriptUrl.getPath();
++                    }
++                    officeScripts.addScript( fileName, scriptUrl, scope, closeCallback  );
++                    //new Thread(new OpenFile(this, scope, fileName, reader )).start();
++                    swingInvoke( new OpenFile(this, scope, fileName, reader ));
++                }
++                catch ( IOException e )
++                {
++                    MessageDialogWrapper.showMessageDialog(this,
++                        "Can't open stream for script: " + e.toString(),
++                        "Open", JOptionPane.ERROR_MESSAGE);
++                }
++            }
++        }
++        split1.setDividerLocation(1.0);
++    }
++
++
++    public void openFile(String fileName) {
++        Scriptable scope = getScope();
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (fileName != null) {
++                new Thread(new OpenFile(this, scope, fileName)).start();
++            }
++        }
++        split1.setDividerLocation(1.0);
++    }
++
++    public void openStream(InputStream in) {
++        Scriptable scope = getScope();
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (in != null) {
++                new Thread(new OpenFile(this, scope, null, new InputStreamReader(in))).start();
++            }
++        }
++        split1.setDividerLocation(1.0);
++        menubar.setSaveEnabled(false);
++    }
++
+     public static void main(String[] args) {
+         try {
+             mainThread = Thread.currentThread();
+@@ -3631,5 +3937,163 @@
+         }
+     }
+ 
++// patched Office specific interface
++
++    OfficeScriptInfo officeScripts = new OfficeScriptInfo();
++
++    void removeScript( String url )
++    {
++        // Remove the FileWindow from list of open sources
++        fileWindows.remove( url );
++
++        // Remove sourceInfo from sourceNames, ensures that
++        // breakpoints etc are deleted
++        synchronized (sourceNames) {
++            sourceNames.remove( url );
++        }
++        // Removes scriptItems for the script, ensures that a new open ( from openFile )
++        // will succeed, openFile should open file but fails due to fact that 
++        synchronized ( scriptItems ) 
++        {   
++            Iterator iter = scriptItems.entrySet().iterator();
++            while ( iter.hasNext() )
++            {
++                Map.Entry me = ( Map.Entry )iter.next();
++                ScriptItem item = (ScriptItem)me.getValue();
++                SourceInfo si =   item.getSourceInfo();
++                if ( si.getUrl().equals( url ) )
++                {
++                    //match
++                    scriptItems.remove( me.getKey() );
++                    break;
++                }
++            }
++        }
++        officeScripts.deleteScript( url );
++    }
++
++
++    ScriptItem getScriptItem(DebuggableScript fnOrScript) {
++        ScriptItem item = (ScriptItem)scriptItems.get(fnOrScript);
++        if (item == null) {
++            String url = getNormilizedUrl(fnOrScript);
++            SourceInfo si = (SourceInfo)sourceNames.get(url);
++            if (si == null) {
++                if (!fnOrScript.isGeneratedScript()) {
++                    // Not eval or Function, try to load it from URL
++                    String source = null;
++                    try {
++                        InputStream is = openSource(url);
++                        try { source = readSource(is); }
++                        finally { is.close(); }
++                    } catch (IOException ex) {
++                        System.err.println
++                            ("Failed to load source from "+url+": "+ ex);
++                    }
++                    if (source != null) {
++                        si = registerSource(url, source);
++                    }
++                }
++            }
++            if (si != null) {
++                item = registerScript(si, fnOrScript);
++            }
++        }
++        
++        return item;
++    }
++
++    public void showScriptWindow(URL url ){
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        if ( w != null )
++        {
++            //w.maximize();
++            desk.getDesktopManager().deiconifyFrame(w);
++            desk.getDesktopManager().activateFrame(w);
++            w.show();
++            w.toFront();
++        }
++    }
++
++    public void highlighLineInScriptWindow(URL url, int lineNum ){
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.getPath();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        if (w != null)
++        {
++            if ( lineNum > -1 )
++                swingInvoke(new SetFilePosition(this, w, lineNum ) );
++        }
++    }
++    public Object runScriptWindow( URL scriptUrl ) throws Exception
++    {
++        String key = scriptUrl.getPath();
++        if ( scriptUrl.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = scriptUrl.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        Object result = null;
++        w.toFront();
++        if (w != null)
++        {
++            //Scriptable scope = w.db.getScope();
++            Scriptable scope = w.db.officeScripts.getScriptScope( key );
++            if (scope == null) 
++            {
++                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
++                result =  null;
++            } 
++            else 
++            {
++                String url = w.getUrl();
++                Thread executorThread = null;
++                if (url != null) 
++                {
++                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
++                    executor.run(); 
++                    result = executor.result;  
++                    if ( executor.exception != null )
++                    {
++                        throw executor.exception;
++                    }
++                }
++            }
++        }
++        return result;
++
++    }
++
++    public boolean isModified( URL url ) 
++    {
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        return w.isModified();
++    }
++
++    public String getText( URL url )
++    {
++        String key = url.toString();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        return w.getText();
++    }
++
++
+ }
+ 
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/OfficeScriptInfo.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/OfficeScriptInfo.java	2005-02-01 18:06:04.433017000 +0000
+@@ -0,0 +1,164 @@
++/*************************************************************************
++ *
++ *  $RCSfile$
++ *
++ *  $Revision$
++ *
++ *  last change: $Author$ $Date$
++ *
++ *  The Contents of this file are made available subject to the terms of
++ *  either of the following licenses
++ *
++ *         - GNU Lesser General Public License Version 2.1
++ *         - Sun Industry Standards Source License Version 1.1
++ *
++ *  Sun Microsystems Inc., October, 2000
++ *
++ *  GNU Lesser General Public License Version 2.1
++ *  =============================================
++ *  Copyright 2000 by Sun Microsystems, Inc.
++ *  901 San Antonio Road, Palo Alto, CA 94303, USA
++ *
++ *  This library is free software; you can redistribute it and/or
++ *  modify it under the terms of the GNU Lesser General Public
++ *  License version 2.1, as published by the Free Software Foundation.
++ *
++ *  This library is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ *  Lesser General Public License for more details.
++ *
++ *  You should have received a copy of the GNU Lesser General Public
++ *  License along with this library; if not, write to the Free Software
++ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ *  MA  02111-1307  USA
++ *
++ *
++ *  Sun Industry Standards Source License Version 1.1
++ *  =================================================
++ *  The contents of this file are subject to the Sun Industry Standards
++ *  Source License Version 1.1 (the "License"); You may not use this file
++ *  except in compliance with the License. You may obtain a copy of the
++ *  License at http://www.openoffice.org/license.html.
++ *
++ *  Software provided under this License is provided on an "AS IS" basis,
++ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
++ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
++ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
++ *  See the License for the specific provisions governing your rights and
++ *  obligations concerning the Software.
++ *
++ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
++ *
++ *  Copyright: 2000 by Sun Microsystems, Inc.
++ *
++ *  All Rights Reserved.
++ *
++ *  Contributor(s): _______________________________________
++ *
++ *
++ ************************************************************************/
++
++
++package org.mozilla.javascript.tools.debugger;
++import java.net.URL;
++import java.util.Hashtable;
++import org.mozilla.javascript.Scriptable;
++
++public class OfficeScriptInfo
++{
++    private Hashtable loadedSFScripts = new Hashtable();
++   
++    public void addScript( URL url, Scriptable scope, Runnable closeCallback )
++    {
++        addScript( url.toString(), url, scope, closeCallback );
++    }
++
++    public void addScript( String key, URL url, Scriptable scope, Runnable closeCallback )
++    {
++        SFScriptInfo si = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( si == null )
++        {
++            si = new SFScriptInfo();
++            si.url = url;
++            si.scope = scope; 
++            si.closeCallback = closeCallback; 
++            loadedSFScripts.put( key, si );
++        }  
++    }   
++
++    public void deleteScript( String key )
++    {
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.remove( key );
++        if ( info != null )
++        {
++            if ( info.closeCallback != null )
++            {
++                System.out.println("** In removeSFScriptInfo  have callback for " + key );
++                info.closeCallback.run(); // really need to do this in seperate thread????
++            }
++        }
++    }
++
++    public Scriptable getScriptScope( String key )
++    {
++        Scriptable result = null;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.scope;
++        }
++        return result;
++    } 
++  
++    public URL getScriptUrl( String key )
++    {
++        URL result = null;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.url;
++        }
++        return result;
++    } 
++    public boolean hasScript( String key )
++    {
++        boolean result = true;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info == null )
++        {
++            result = false;
++        }      
++        return result;
++    } 
++
++    public void setScriptRunning( String key, boolean running )
++    {
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            info.isExecuting = running;
++        }
++    }
++
++    public boolean isScriptRunning( String key )
++    {
++        boolean result = false;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.isExecuting;
++        }
++        return result;
++    }
++
++    
++  
++    class SFScriptInfo
++    {
++        Scriptable scope;
++        boolean isExecuting;
++        URL url;
++        Runnable closeCallback;
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModelAdapter.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModelAdapter.java	2005-02-01 18:06:04.473017000 +0000
+@@ -0,0 +1,126 @@
++/*
++ * @(#)TreeTableModelAdapter.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.JTree;
++import javax.swing.SwingUtilities;
++import javax.swing.table.AbstractTableModel;
++import javax.swing.tree.TreePath;
++import javax.swing.event.TreeExpansionEvent;
++import javax.swing.event.TreeExpansionListener;
++import javax.swing.event.TreeModelEvent;
++import javax.swing.event.TreeModelListener;
++
++/**
++ * This is a wrapper class takes a TreeTableModel and implements 
++ * the table model interface. The implementation is trivial, with 
++ * all of the event dispatching support provided by the superclass: 
++ * the AbstractTableModel. 
++ *
++ * @version 1.2 10/27/98
++ *
++ * @author Philip Milne
++ * @author Scott Violet
++ */
++public class TreeTableModelAdapter extends AbstractTableModel
++{
++    JTree tree;
++    TreeTableModel treeTableModel;
++
++    public TreeTableModelAdapter(TreeTableModel treeTableModel, JTree tree) {
++        this.tree = tree;
++        this.treeTableModel = treeTableModel;
++
++	tree.addTreeExpansionListener(new TreeExpansionListener() {
++	    // Don't use fireTableRowsInserted() here; the selection model
++	    // would get updated twice. 
++	    public void treeExpanded(TreeExpansionEvent event) {  
++	      fireTableDataChanged(); 
++	    }
++            public void treeCollapsed(TreeExpansionEvent event) {  
++	      fireTableDataChanged(); 
++	    }
++	});
++
++	// Install a TreeModelListener that can update the table when
++	// tree changes. We use delayedFireTableDataChanged as we can
++	// not be guaranteed the tree will have finished processing
++	// the event before us.
++	treeTableModel.addTreeModelListener(new TreeModelListener() {
++	    public void treeNodesChanged(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeNodesInserted(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeNodesRemoved(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeStructureChanged(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++	});
++    }
++
++    // Wrappers, implementing TableModel interface. 
++
++    public int getColumnCount() {
++	return treeTableModel.getColumnCount();
++    }
++
++    public String getColumnName(int column) {
++	return treeTableModel.getColumnName(column);
++    }
++
++    public Class getColumnClass(int column) {
++	return treeTableModel.getColumnClass(column);
++    }
++
++    public int getRowCount() {
++	return tree.getRowCount();
++    }
++
++    protected Object nodeForRow(int row) {
++	TreePath treePath = tree.getPathForRow(row);
++	return treePath.getLastPathComponent();         
++    }
++
++    public Object getValueAt(int row, int column) {
++	return treeTableModel.getValueAt(nodeForRow(row), column);
++    }
++
++    public boolean isCellEditable(int row, int column) {
++         return treeTableModel.isCellEditable(nodeForRow(row), column); 
++    }
++
++    public void setValueAt(Object value, int row, int column) {
++	treeTableModel.setValueAt(value, nodeForRow(row), column);
++    }
++
++    /**
++     * Invokes fireTableDataChanged after all the pending events have been
++     * processed. SwingUtilities.invokeLater is used to handle this.
++     */
++    protected void delayedFireTableDataChanged() {
++	SwingUtilities.invokeLater(new Runnable() {
++	    public void run() {
++		fireTableDataChanged();
++	    }
++	});
++    }
++}
++
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModel.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModel.java	2005-02-01 18:06:04.493018000 +0000
+@@ -0,0 +1,69 @@
++/*
++ * TreeTableModel.java
++ *
++ * Copyright (c) 1998 Sun Microsystems, Inc. All Rights Reserved.
++ *
++ * This software is the confidential and proprietary information of Sun
++ * Microsystems, Inc. ("Confidential Information").  You shall not
++ * disclose such Confidential Information and shall use it only in
++ * accordance with the terms of the license agreement you entered into
++ * with Sun.
++ *
++ * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
++ * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
++ * PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR ANY DAMAGES
++ * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
++ * THIS SOFTWARE OR ITS DERIVATIVES.
++ *
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.tree.TreeModel;
++
++/**
++ * TreeTableModel is the model used by a JTreeTable. It extends TreeModel
++ * to add methods for getting inforamtion about the set of columns each 
++ * node in the TreeTableModel may have. Each column, like a column in 
++ * a TableModel, has a name and a type associated with it. Each node in 
++ * the TreeTableModel can return a value for each of the columns and 
++ * set that value if isCellEditable() returns true. 
++ *
++ * @author Philip Milne 
++ * @author Scott Violet
++ */
++public interface TreeTableModel extends TreeModel
++{
++    /**
++     * Returns the number ofs availible column.
++     */
++    public int getColumnCount();
++
++    /**
++     * Returns the name for column number <code>column</code>.
++     */
++    public String getColumnName(int column);
++
++    /**
++     * Returns the type for column number <code>column</code>.
++     */
++    public Class getColumnClass(int column);
++
++    /**
++     * Returns the value to be displayed for node <code>node</code>, 
++     * at column number <code>column</code>.
++     */
++    public Object getValueAt(Object node, int column);
++
++    /**
++     * Indicates whether the the value for node <code>node</code>, 
++     * at column number <code>column</code> is editable.
++     */
++    public boolean isCellEditable(Object node, int column);
++
++    /**
++     * Sets the value for node <code>node</code>, 
++     * at column number <code>column</code>.
++     */
++    public void setValueAt(Object aValue, Object node, int column);
++}
Index: rhino/rhino1_5R4.patch
===================================================================
RCS file: rhino/rhino1_5R4.patch
diff -N rhino/rhino1_5R4.patch
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ rhino/rhino1_5R4.patch	7 Feb 2005 14:06:53 -0000	1.1.2.1
@@ -0,0 +1,2302 @@
+--- misc/build/rhino1_5R4/build.xml	2005-02-01 18:05:48.983062000 +0000
++++ misc/build/rhino1_5R4/build.xml	2005-02-01 18:06:04.693016000 +0000
+@@ -4,7 +4,7 @@
+ Build file for Rhino using Ant (see http://jakarta.apache.org/ant/index.html)
+ Requires Ant version 1.2 or later
+ -->
+-<project name="Rhino" default="default" basedir=".">
++<project name="Rhino" default="jar" basedir=".">
+ 
+   <target name="properties">
+     <property name="name" value="rhino"/>
+--- misc/build/rhino1_5R4/makefile.mk	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/makefile.mk	2005-02-01 18:43:30.832676000 +0000
+@@ -0,0 +1,70 @@
++#*************************************************************************
++#
++#   $RCSfile$
++#
++#   $Revision$
++#
++#   last change: $Author$ $Date$
++#
++#   The Contents of this file are made available subject to the terms of
++#   either of the following licenses
++#
++#          - GNU Lesser General Public License Version 2.1
++#          - Sun Industry Standards Source License Version 1.1
++#
++#   Sun Microsystems Inc., October, 2000
++#
++#   GNU Lesser General Public License Version 2.1
++#   =============================================
++#   Copyright 2000 by Sun Microsystems, Inc.
++#   901 San Antonio Road, Palo Alto, CA 94303, USA
++#
++#   This library is free software; you can redistribute it and/or
++#   modify it under the terms of the GNU Lesser General Public
++#   License version 2.1, as published by the Free Software Foundation.
++#
++#   This library is distributed in the hope that it will be useful,
++#   but WITHOUT ANY WARRANTY; without even the implied warranty of
++#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++#   Lesser General Public License for more details.
++#
++#   You should have received a copy of the GNU Lesser General Public
++#   License along with this library; if not, write to the Free Software
++#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++#   MA  02111-1307  USA
++#
++#
++#   Sun Industry Standards Source License Version 1.1
++#   =================================================
++#   The contents of this file are subject to the Sun Industry Standards
++#   Source License Version 1.1 (the "License"); You may not use this file
++#   except in compliance with the License. You may obtain a copy of the
++#   License at http://www.openoffice.org/license.html.
++#
++#   Software provided under this License is provided on an "AS IS" basis,
++#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
++#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
++#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
++#   See the License for the specific provisions governing your rights and
++#   obligations concerning the Software.
++#
++#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
++#
++#   Copyright: 2000 by Sun Microsystems, Inc.
++#
++#   All Rights Reserved.
++#
++#   Contributor(s): _______________________________________
++#
++#
++#
++#*************************************************************************
++
++PRJ=..$/..$/..$/..
++PRJNAME=ooo_rhino
++TARGET=jar
++
++.INCLUDE : ant.mk
++
++ALLTAR : ANTBUILD
++
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/Context.java	2005-02-01 18:05:47.293067000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/Context.java	2005-02-01 18:06:02.843024000 +0000
+@@ -386,7 +386,7 @@
+      *         number, and date.
+      */
+      public String getImplementationVersion() {
+-        return "Rhino 1.5 release 4 2003 02 10";
++        return "Rhino 1.5 release 4.1 2003 04 21";
+      }
+ 
+     /**
+@@ -1835,7 +1835,65 @@
+ 
+     public GeneratedClassLoader createClassLoader(ClassLoader parent) {
+         return new DefiningClassLoader(parent);
++    }
+ 
++    public final ClassLoader getApplicationClassLoader()
++    {
++        if (applicationClassLoader != null) {
++            return applicationClassLoader;
++        }
++        ClassLoader loader = null;
++        if (method_getContextClassLoader != null) {
++            Thread thread = Thread.currentThread();
++            try {
++                loader = (ClassLoader)method_getContextClassLoader.invoke(
++                             thread, ScriptRuntime.emptyArgs);
++            } catch (Exception ex) { }
++        }
++        if (loader != null && !testIfCanUseLoader(loader)) {
++            loader = null;
++        }
++        if (loader == null) {
++            // If Context was subclassed, the following gets the loader
++            // for the subclass which can be different from Rhino loader,
++            // but then proper Rhino classes should be accessible through it
++            // in any case or JVM class loading is severely broken
++            loader = this.getClass().getClassLoader();
++        }
++        // The result is not cached since caching
++        // Thread.getContextClassLoader prevents it from GC which
++        // may lead to a memory leak.
++        return loader;
++    }
++
++    public void setApplicationClassLoader(ClassLoader loader)
++    {
++        if (loader == null) {
++            // restore default behaviour
++            applicationClassLoader = null;
++            return;
++        }
++        if (!testIfCanUseLoader(loader)) {
++            throw new IllegalArgumentException(
++                "Loader can not resolve Rhino classes");
++        }
++        applicationClassLoader = loader;
++    }
++
++    private boolean testIfCanUseLoader(ClassLoader loader)
++    {
++        // If Context was subclussed, cxClass != Context.class
++        Class cxClass = this.getClass();
++        // Check that Context or its suclass is accesible from this loader
++        Class x = ScriptRuntime.getClassOrNull(loader, cxClass.getName());
++        if (x != cxClass) {
++            // The check covers the case when x == null =>
++            // threadLoader does not know about Rhino or the case
++            // when x != null && x != cxClass =>
++            // threadLoader loads unrelated Rhino instance
++            return false;
++        }
++        return true;
+     }
+ 
+     /********** end of API **********/
+@@ -2169,6 +2227,24 @@
+         } catch (Exception ex) { }
+     }
+ 
++    // We'd like to use "Thread.getContextClassLoader", but
++    // that's only available on Java2.
++    private static Method method_getContextClassLoader;
++
++    static {
++        // Don't use "Thread.class": that performs the lookup
++        // in the class initializer, which doesn't allow us to
++        // catch possible security exceptions.
++        Class threadClass = ScriptRuntime.getClassOrNull("java.lang.Thread");
++        if (threadClass != null) {
++            try {
++                method_getContextClassLoader =
++                    threadClass.getDeclaredMethod("getContextClassLoader",
++                                                   new Class[0]);
++            } catch (Exception ex) { }
++        }
++    }
++
+     private static final Object contextListenersLock = new Object();
+     private static Object[] contextListeners;
+ 
+@@ -2203,6 +2279,7 @@
+     private int enterCount;
+     private Object[] listeners;
+     private Hashtable hashtable;
++    private ClassLoader applicationClassLoader;
+ 
+     /**
+      * This is the list of names of objects forcing the creation of
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/DefiningClassLoader.java	2005-02-01 18:05:46.693066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/DefiningClassLoader.java	2005-02-01 18:06:02.263025000 +0000
+@@ -49,11 +49,34 @@
+     implements GeneratedClassLoader
+ {
+     public DefiningClassLoader() {
+-        this.parentLoader = getClass().getClassLoader();
++        init(getClass().getClassLoader());
+     }
+ 
+     public DefiningClassLoader(ClassLoader parentLoader) {
++
++        init(parentLoader);
++    }
++
++    private void init(ClassLoader parentLoader) {
++
+         this.parentLoader = parentLoader;
++
++        this.contextLoader = null;
++        if (method_getContextClassLoader != null) {
++            try {
++                this.contextLoader = (ClassLoader)
++                    method_getContextClassLoader.invoke(
++                        Thread.currentThread(),
++                        ScriptRuntime.emptyArgs);
++            } catch (IllegalAccessException ex) {
++            } catch (InvocationTargetException ex) {
++            } catch (SecurityException ex) {
++            }
++            if (this.contextLoader == this.parentLoader) {
++                this.contextLoader = null;
++            }
++        }
++
+     }
+ 
+     public Class defineClass(String name, byte[] data) {
+@@ -67,18 +90,66 @@
+     public Class loadClass(String name, boolean resolve)
+         throws ClassNotFoundException
+     {
+-        Class clazz = findLoadedClass(name);
+-        if (clazz == null) {
+-            if (parentLoader != null) {
+-                clazz = parentLoader.loadClass(name);
++
++        Class cl = findLoadedClass(name);
++        if (cl == null) {
++            // First try parent class loader and if that does not work, try
++            // contextLoader, but that will be null if
++            // Thread.getContextClassLoader() == parentLoader
++            // or on JDK 1.1 due to lack Thread.getContextClassLoader().
++            // To avoid catching and rethrowing ClassNotFoundException
++            // in this cases, use try/catch check only if contextLoader != null.
++            if (contextLoader == null) {
++                cl = loadFromParent(name);
++
+             } else {
+-                clazz = findSystemClass(name);
++
++                try {
++                    cl = loadFromParent(name);
++                } catch (ClassNotFoundException ex) {
++                    cl = contextLoader.loadClass(name);
++                }
++
+             }
+         }
+-        if (resolve)
+-            resolveClass(clazz);
+-        return clazz;
++
++        if (resolve) {
++            resolveClass(cl);
++        }
++        return cl;
++    }
++
++    private Class loadFromParent(String name)
++        throws ClassNotFoundException
++    {
++        if (parentLoader != null) {
++            return parentLoader.loadClass(name);
++        } else {
++            return findSystemClass(name);
++        }
++
+     }
+ 
+     private ClassLoader parentLoader;
++
++    private ClassLoader contextLoader;
++
++    // We'd like to use "Thread.getContextClassLoader", but
++    // that's only available on Java2.
++    private static Method method_getContextClassLoader;
++
++    static {
++        try {
++            // Don't use "Thread.class": that performs the lookup
++            // in the class initializer, which doesn't allow us to
++            // catch possible security exceptions.
++            Class threadClass = Class.forName("java.lang.Thread");
++            method_getContextClassLoader =
++                threadClass.getDeclaredMethod("getContextClassLoader",
++                                               new Class[0]);
++        } catch (ClassNotFoundException e) {
++        } catch (NoSuchMethodException e) {
++        } catch (SecurityException e) {
++        }
++    }
+ }
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/ImporterTopLevel.java	2005-02-01 18:05:47.143066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/ImporterTopLevel.java	2005-02-01 18:06:02.693023000 +0000
+@@ -97,10 +97,21 @@
+         return "global";
+     }
+ 
++    public boolean has(String name, Scriptable start) {
++        return super.has(name, start)
++               || getPackageProperty(name, start) != NOT_FOUND;
++    }
++
+     public Object get(String name, Scriptable start) {
+         Object result = super.get(name, start);
+         if (result != NOT_FOUND)
+             return result;
++        result = getPackageProperty(name, start);
++        return result;
++    }
++
++    private Object getPackageProperty(String name, Scriptable start) {
++        Object result= NOT_FOUND;
+         if (name.equals("_packages_"))
+             return result;
+         Object plist = ScriptableObject.getProperty(start,"_packages_");
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/JavaAdapter.java	2005-02-01 18:05:46.293068000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/JavaAdapter.java	2005-02-01 18:06:01.993024000 +0000
+@@ -331,7 +331,7 @@
+             }
+         }
+ 
+-        ClassLoader parentLoader = cx.getClass().getClassLoader();
++        ClassLoader parentLoader = cx.getApplicationClassLoader();
+         GeneratedClassLoader loader;
+         SecurityController sc = cx.getSecurityController();
+         if (sc == null) {
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/NativeJavaPackage.java	2005-02-01 18:05:47.173068000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/NativeJavaPackage.java	2005-02-01 18:06:02.733022000 +0000
+@@ -166,22 +166,30 @@
+     }
+ 
+     public NativeJavaPackage(String packageName) {
+-        this.packageName = packageName;
++        this(packageName, null);
+     }
+ 
+     public NativeJavaPackage(String packageName, ClassLoader classLoader) {
+         this.packageName = packageName;
++        if (classLoader != null) {
+         this.classLoader = classLoader;
++        } else {
++            this.classLoader = Context.getContext().getApplicationClassLoader();
++        }
+     }
+ 
+     public String getClassName() {
+         return "JavaPackage";
+     }
+ 
+-    public boolean has(String id, int index, Scriptable start) {
++    public boolean has(String id, Scriptable start) {
+         return true;
+     }
+ 
++    public boolean has(int index, Scriptable start) {
++        return false;
++    }
++
+     public void put(String id, Scriptable start, Object value) {
+         // Can't add properties to Java packages.  Sorry.
+     }
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/Codegen.java	2005-02-01 18:05:46.933066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/Codegen.java	2005-02-01 18:06:02.493021000 +0000
+@@ -80,7 +80,7 @@
+ 
+         Exception e = null;
+         Class result = null;
+-        ClassLoader parentLoader = cx.getClass().getClassLoader();
++        ClassLoader parentLoader = cx.getApplicationClassLoader();
+         GeneratedClassLoader loader;
+         if (securityController == null) {
+             loader = cx.createClassLoader(parentLoader);
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/InvokerImpl.java	2005-02-01 18:05:47.033066000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/optimizer/InvokerImpl.java	2005-02-01 18:06:02.583023000 +0000
+@@ -58,7 +58,7 @@
+         synchronized (this) {
+             if (invokersCache == null) {
+                 invokersCache = new Hashtable();
+-                ClassLoader parentLoader = cx.getClass().getClassLoader();
++                ClassLoader parentLoader = cx.getApplicationClassLoader();
+                 classLoader = cx.createClassLoader(parentLoader);
+             } else {
+                 result = (Invoker)invokersCache.get(method);
+--- misc/build/rhino1_5R4/src/org/mozilla/javascript/ScriptRuntime.java	2005-02-01 18:05:46.483070000 +0000
++++ misc/build/rhino1_5R4/src/org/mozilla/javascript/ScriptRuntime.java	2005-02-01 18:06:02.053022000 +0000
+@@ -2001,11 +2001,27 @@
+         cx.currentActivation = activation;
+     }
+ 
+-    private static Class getClassOrNull(String className) {
++    static Class getClassOrNull(String className) {
+         try {
+             return Class.forName(className);
+         } catch  (ClassNotFoundException ex) {
+         } catch  (SecurityException ex) {
++        } catch (IllegalArgumentException e) {
++            // Can be thrown if name has characters that a class name
++            // can not contain
++        }
++        return null;
++    }
++
++    static Class getClassOrNull(ClassLoader loader, String className)
++    {
++        try {
++            return loader.loadClass(className);
++        } catch (ClassNotFoundException ex) {
++        } catch (SecurityException ex) {
++        } catch (IllegalArgumentException e) {
++            // Can be thrown if name has characters that a class name
++            // can not contain
+         }
+         return null;
+     }
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractCellEditor.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractCellEditor.java	2005-02-01 18:06:04.443018000 +0000
+@@ -0,0 +1,62 @@
++package org.mozilla.javascript.tools.debugger;
++
++import java.awt.Component;
++import java.awt.event.*;
++import java.awt.AWTEvent;
++import javax.swing.*;
++import javax.swing.event.*;
++import java.util.EventObject;
++import java.io.Serializable;
++
++public class AbstractCellEditor implements CellEditor {
++
++    protected EventListenerList listenerList = new EventListenerList();
++
++    public Object getCellEditorValue() { return null; }
++    public boolean isCellEditable(EventObject e) { return true; }
++    public boolean shouldSelectCell(EventObject anEvent) { return false; }
++    public boolean stopCellEditing() { return true; }
++    public void cancelCellEditing() {}
++
++    public void addCellEditorListener(CellEditorListener l) {
++	listenerList.add(CellEditorListener.class, l);
++    }
++
++    public void removeCellEditorListener(CellEditorListener l) {
++	listenerList.remove(CellEditorListener.class, l);
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  
++     * @see EventListenerList
++     */
++    protected void fireEditingStopped() {
++	// Guaranteed to return a non-null array
++	Object[] listeners = listenerList.getListenerList();
++	// Process the listeners last to first, notifying
++	// those that are interested in this event
++	for (int i = listeners.length-2; i>=0; i-=2) {
++	    if (listeners[i]==CellEditorListener.class) {
++		((CellEditorListener)listeners[i+1]).editingStopped(new ChangeEvent(this));
++	    }	       
++	}
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  
++     * @see EventListenerList
++     */
++    protected void fireEditingCanceled() {
++	// Guaranteed to return a non-null array
++	Object[] listeners = listenerList.getListenerList();
++	// Process the listeners last to first, notifying
++	// those that are interested in this event
++	for (int i = listeners.length-2; i>=0; i-=2) {
++	    if (listeners[i]==CellEditorListener.class) {
++		((CellEditorListener)listeners[i+1]).editingCanceled(new ChangeEvent(this));
++	    }	       
++	}
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractTreeTableModel.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/AbstractTreeTableModel.java	2005-02-01 18:06:04.453017000 +0000
+@@ -0,0 +1,196 @@
++/*
++ * @(#)AbstractTreeTableModel.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.tree.*;
++import javax.swing.event.*;
++ 
++/**
++ * @version 1.2 10/27/98
++ * An abstract implementation of the TreeTableModel interface, handling the list 
++ * of listeners. 
++ * @author Philip Milne
++ */
++
++public abstract class AbstractTreeTableModel implements TreeTableModel {
++    protected Object root;     
++    protected EventListenerList listenerList = new EventListenerList();
++  
++    public AbstractTreeTableModel(Object root) {
++        this.root = root; 
++    }
++
++    //
++    // Default implmentations for methods in the TreeModel interface. 
++    //
++
++    public Object getRoot() {
++        return root;
++    }
++
++    public boolean isLeaf(Object node) {
++        return getChildCount(node) == 0; 
++    }
++
++    public void valueForPathChanged(TreePath path, Object newValue) {}
++
++    // This is not called in the JTree's default mode: use a naive implementation. 
++    public int getIndexOfChild(Object parent, Object child) {
++        for (int i = 0; i < getChildCount(parent); i++) {
++	    if (getChild(parent, i).equals(child)) { 
++	        return i; 
++	    }
++        }
++	return -1; 
++    }
++
++    public void addTreeModelListener(TreeModelListener l) {
++        listenerList.add(TreeModelListener.class, l);
++    }
++
++    public void removeTreeModelListener(TreeModelListener l) {
++        listenerList.remove(TreeModelListener.class, l);
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesChanged(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesInserted(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeNodesRemoved(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
++            }          
++        }
++    }
++
++    /*
++     * Notify all listeners that have registered interest for
++     * notification on this event type.  The event instance 
++     * is lazily created using the parameters passed into 
++     * the fire method.
++     * @see EventListenerList
++     */
++    protected void fireTreeStructureChanged(Object source, Object[] path, 
++                                        int[] childIndices, 
++                                        Object[] children) {
++        // Guaranteed to return a non-null array
++        Object[] listeners = listenerList.getListenerList();
++        TreeModelEvent e = null;
++        // Process the listeners last to first, notifying
++        // those that are interested in this event
++        for (int i = listeners.length-2; i>=0; i-=2) {
++            if (listeners[i]==TreeModelListener.class) {
++                // Lazily create the event:
++                if (e == null)
++                    e = new TreeModelEvent(source, path, 
++                                           childIndices, children);
++                ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
++            }          
++        }
++    }
++
++    //
++    // Default impelmentations for methods in the TreeTableModel interface. 
++    //
++
++    public Class getColumnClass(int column) { return Object.class; }
++
++   /** By default, make the column with the Tree in it the only editable one. 
++    *  Making this column editable causes the JTable to forward mouse 
++    *  and keyboard events in the Tree column to the underlying JTree. 
++    */ 
++    public boolean isCellEditable(Object node, int column) { 
++         return getColumnClass(column) == TreeTableModel.class; 
++    }
++
++    public void setValueAt(Object aValue, Object node, int column) {}
++
++
++    // Left to be implemented in the subclass:
++
++    /* 
++     *   public Object getChild(Object parent, int index)
++     *   public int getChildCount(Object parent) 
++     *   public int getColumnCount() 
++     *   public String getColumnName(Object node, int column)  
++     *   public Object getValueAt(Object node, int column) 
++     */
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/JTreeTable.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/JTreeTable.java	2005-02-01 18:06:04.463017000 +0000
+@@ -0,0 +1,354 @@
++/*
++ * @(#)JTreeTable.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.*;
++import javax.swing.event.*;
++import javax.swing.tree.*;
++import javax.swing.table.*;
++
++import java.awt.Dimension;
++import java.awt.Component;
++import java.awt.Graphics;
++import java.awt.Rectangle;
++
++import java.awt.event.MouseEvent;
++
++import java.util.EventObject;
++
++/**
++ * This example shows how to create a simple JTreeTable component, 
++ * by using a JTree as a renderer (and editor) for the cells in a 
++ * particular column in the JTable.  
++ *
++ * @version 1.2 10/27/98
++ *
++ * @author Philip Milne
++ * @author Scott Violet
++ */
++public class JTreeTable extends JTable {
++    /** A subclass of JTree. */
++    protected TreeTableCellRenderer tree;
++
++    public JTreeTable(TreeTableModel treeTableModel) {
++	super();
++
++	// Create the tree. It will be used as a renderer and editor. 
++	tree = new TreeTableCellRenderer(treeTableModel);
++
++	// Install a tableModel representing the visible rows in the tree. 
++	super.setModel(new TreeTableModelAdapter(treeTableModel, tree));
++
++	// Force the JTable and JTree to share their row selection models. 
++	ListToTreeSelectionModelWrapper selectionWrapper = new 
++	                        ListToTreeSelectionModelWrapper();
++	tree.setSelectionModel(selectionWrapper);
++	setSelectionModel(selectionWrapper.getListSelectionModel()); 
++
++	// Install the tree editor renderer and editor. 
++	setDefaultRenderer(TreeTableModel.class, tree); 
++	setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
++
++	// No grid.
++	setShowGrid(false);
++
++	// No intercell spacing
++	setIntercellSpacing(new Dimension(0, 0));	
++
++	// And update the height of the trees row to match that of
++	// the table.
++	if (tree.getRowHeight() < 1) {
++	    // Metal looks better like this.
++	    setRowHeight(18);
++	}
++    }
++
++    /**
++     * Overridden to message super and forward the method to the tree.
++     * Since the tree is not actually in the component hieachy it will
++     * never receive this unless we forward it in this manner.
++     */
++    public void updateUI() {
++	super.updateUI();
++	if(tree != null) {
++	    tree.updateUI();
++	}
++	// Use the tree's default foreground and background colors in the
++	// table. 
++        LookAndFeel.installColorsAndFont(this, "Tree.background",
++                                         "Tree.foreground", "Tree.font");
++    }
++
++    /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to 
++     * paint the editor. The UI currently uses different techniques to 
++     * paint the renderers and editors and overriding setBounds() below 
++     * is not the right thing to do for an editor. Returning -1 for the 
++     * editing row in this case, ensures the editor is never painted. 
++     */
++    public int getEditingRow() {
++        return (getColumnClass(editingColumn) == TreeTableModel.class) ? -1 :
++	        editingRow;  
++    }
++
++    /**
++     * Overridden to pass the new rowHeight to the tree.
++     */
++    public void setRowHeight(int rowHeight) { 
++        super.setRowHeight(rowHeight); 
++	if (tree != null && tree.getRowHeight() != rowHeight) {
++            tree.setRowHeight(getRowHeight()); 
++	}
++    }
++
++    /**
++     * Returns the tree that is being shared between the model.
++     */
++    public JTree getTree() {
++	return tree;
++    }
++
++    /**
++     * A TreeCellRenderer that displays a JTree.
++     */
++    public class TreeTableCellRenderer extends JTree implements
++	         TableCellRenderer {
++	/** Last table/tree row asked to renderer. */
++	protected int visibleRow;
++
++	public TreeTableCellRenderer(TreeModel model) {
++	    super(model); 
++	}
++
++	/**
++	 * updateUI is overridden to set the colors of the Tree's renderer
++	 * to match that of the table.
++	 */
++	public void updateUI() {
++	    super.updateUI();
++	    // Make the tree's cell renderer use the table's cell selection
++	    // colors. 
++	    TreeCellRenderer tcr = getCellRenderer();
++	    if (tcr instanceof DefaultTreeCellRenderer) {
++		DefaultTreeCellRenderer dtcr = ((DefaultTreeCellRenderer)tcr); 
++		// For 1.1 uncomment this, 1.2 has a bug that will cause an
++		// exception to be thrown if the border selection color is
++		// null.
++		// dtcr.setBorderSelectionColor(null);
++		dtcr.setTextSelectionColor(UIManager.getColor
++					   ("Table.selectionForeground"));
++		dtcr.setBackgroundSelectionColor(UIManager.getColor
++						("Table.selectionBackground"));
++	    }
++	}
++
++	/**
++	 * Sets the row height of the tree, and forwards the row height to
++	 * the table.
++	 */
++	public void setRowHeight(int rowHeight) { 
++	    if (rowHeight > 0) {
++		super.setRowHeight(rowHeight); 
++		if (JTreeTable.this != null &&
++		    JTreeTable.this.getRowHeight() != rowHeight) {
++		    JTreeTable.this.setRowHeight(getRowHeight()); 
++		}
++	    }
++	}
++
++	/**
++	 * This is overridden to set the height to match that of the JTable.
++	 */
++	public void setBounds(int x, int y, int w, int h) {
++	    super.setBounds(x, 0, w, JTreeTable.this.getHeight());
++	}
++
++	/**
++	 * Sublcassed to translate the graphics such that the last visible
++	 * row will be drawn at 0,0.
++	 */
++	public void paint(Graphics g) {
++	    g.translate(0, -visibleRow * getRowHeight());
++	    super.paint(g);
++	}
++
++	/**
++	 * TreeCellRenderer method. Overridden to update the visible row.
++	 */
++	public Component getTableCellRendererComponent(JTable table,
++						       Object value,
++						       boolean isSelected,
++						       boolean hasFocus,
++						       int row, int column) {
++	    if(isSelected)
++		setBackground(table.getSelectionBackground());
++	    else
++		setBackground(table.getBackground());
++
++	    visibleRow = row;
++	    return this;
++	}
++    }
++
++
++    /**
++     * TreeTableCellEditor implementation. Component returned is the
++     * JTree.
++     */
++    public class TreeTableCellEditor extends AbstractCellEditor implements
++	         TableCellEditor {
++	public Component getTableCellEditorComponent(JTable table,
++						     Object value,
++						     boolean isSelected,
++						     int r, int c) {
++	    return tree;
++	}
++
++	/**
++	 * Overridden to return false, and if the event is a mouse event
++	 * it is forwarded to the tree.<p>
++	 * The behavior for this is debatable, and should really be offered
++	 * as a property. By returning false, all keyboard actions are
++	 * implemented in terms of the table. By returning true, the
++	 * tree would get a chance to do something with the keyboard
++	 * events. For the most part this is ok. But for certain keys,
++	 * such as left/right, the tree will expand/collapse where as
++	 * the table focus should really move to a different column. Page
++	 * up/down should also be implemented in terms of the table.
++	 * By returning false this also has the added benefit that clicking
++	 * outside of the bounds of the tree node, but still in the tree
++	 * column will select the row, whereas if this returned true
++	 * that wouldn't be the case.
++	 * <p>By returning false we are also enforcing the policy that
++	 * the tree will never be editable (at least by a key sequence).
++	 */
++	public boolean isCellEditable(EventObject e) {
++	    if (e instanceof MouseEvent) {
++		for (int counter = getColumnCount() - 1; counter >= 0;
++		     counter--) {
++		    if (getColumnClass(counter) == TreeTableModel.class) {
++			MouseEvent me = (MouseEvent)e;
++			MouseEvent newME = new MouseEvent(tree, me.getID(),
++				   me.getWhen(), me.getModifiers(),
++				   me.getX() - getCellRect(0, counter, true).x,
++				   me.getY(), me.getClickCount(),
++                                   me.isPopupTrigger());
++			tree.dispatchEvent(newME);
++			break;
++		    }
++		}
++	    }
++	    return false;
++	}
++    }
++
++
++    /**
++     * ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel
++     * to listen for changes in the ListSelectionModel it maintains. Once
++     * a change in the ListSelectionModel happens, the paths are updated
++     * in the DefaultTreeSelectionModel.
++     */
++    class ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel { 
++	/** Set to true when we are updating the ListSelectionModel. */
++	protected boolean         updatingListSelectionModel;
++
++	public ListToTreeSelectionModelWrapper() {
++	    super();
++	    getListSelectionModel().addListSelectionListener
++	                            (createListSelectionListener());
++	}
++
++	/**
++	 * Returns the list selection model. ListToTreeSelectionModelWrapper
++	 * listens for changes to this model and updates the selected paths
++	 * accordingly.
++	 */
++	ListSelectionModel getListSelectionModel() {
++	    return listSelectionModel; 
++	}
++
++	/**
++	 * This is overridden to set <code>updatingListSelectionModel</code>
++	 * and message super. This is the only place DefaultTreeSelectionModel
++	 * alters the ListSelectionModel.
++	 */
++	public void resetRowSelection() {
++	    if(!updatingListSelectionModel) {
++		updatingListSelectionModel = true;
++		try {
++		    super.resetRowSelection();
++		}
++		finally {
++		    updatingListSelectionModel = false;
++		}
++	    }
++	    // Notice how we don't message super if
++	    // updatingListSelectionModel is true. If
++	    // updatingListSelectionModel is true, it implies the
++	    // ListSelectionModel has already been updated and the
++	    // paths are the only thing that needs to be updated.
++	}
++
++	/**
++	 * Creates and returns an instance of ListSelectionHandler.
++	 */
++	protected ListSelectionListener createListSelectionListener() {
++	    return new ListSelectionHandler();
++	}
++
++	/**
++	 * If <code>updatingListSelectionModel</code> is false, this will
++	 * reset the selected paths from the selected rows in the list
++	 * selection model.
++	 */
++	protected void updateSelectedPathsFromSelectedRows() {
++	    if(!updatingListSelectionModel) {
++		updatingListSelectionModel = true;
++		try {
++		    // This is way expensive, ListSelectionModel needs an
++		    // enumerator for iterating.
++		    int        min = listSelectionModel.getMinSelectionIndex();
++		    int        max = listSelectionModel.getMaxSelectionIndex();
++
++		    clearSelection();
++		    if(min != -1 && max != -1) {
++			for(int counter = min; counter <= max; counter++) {
++			    if(listSelectionModel.isSelectedIndex(counter)) {
++				TreePath     selPath = tree.getPathForRow
++				                            (counter);
++
++				if(selPath != null) {
++				    addSelectionPath(selPath);
++				}
++			    }
++			}
++		    }
++		}
++		finally {
++		    updatingListSelectionModel = false;
++		}
++	    }
++	}
++
++	/**
++	 * Class responsible for calling updateSelectedPathsFromSelectedRows
++	 * when the selection of the list changse.
++	 */
++	class ListSelectionHandler implements ListSelectionListener {
++	    public void valueChanged(ListSelectionEvent e) {
++		updateSelectedPathsFromSelectedRows();
++	    }
++	}
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/Main.java	2005-02-01 18:05:48.773063000 +0000
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/Main.java	2005-02-01 18:06:04.413018000 +0000
+@@ -469,17 +469,23 @@
+         case KeyEvent.VK_BACK_SPACE:
+         case KeyEvent.VK_ENTER:
+         case KeyEvent.VK_DELETE:
++            if (w.isEditable() == false) {
+             e.consume();
++            }
+             break;
+         }
+     }
+     public void keyTyped(KeyEvent e) {
++        if (w.isEditable() == false) {
+         e.consume();
+     }
++    }
+     public void keyReleased(KeyEvent e) {
++        if (w.isEditable() == false) {
+         e.consume();
+     }
+ }
++}
+ 
+ class MoreWindows extends JDialog implements ActionListener {
+ 
+@@ -818,6 +824,7 @@
+         if (dummy.length() < 2) {
+             dummy = "99";
+         }
++
+         int maxWidth = metrics.stringWidth(dummy);
+         int startLine = clip.y / h;
+         int endLine = (clip.y + clip.height) / h + 1;
+@@ -868,7 +875,8 @@
+     }
+ };
+ 
+-class FileWindow extends JInternalFrame implements ActionListener {
++class FileWindow extends JInternalFrame
++    implements ActionListener, DocumentListener {
+ 
+     Main db;
+     SourceInfo sourceInfo;
+@@ -877,15 +885,16 @@
+     JScrollPane p;
+     int currentPos;
+     JLabel statusBar;
++    boolean isModified = false;
+ 
+     public void actionPerformed(ActionEvent e) {
+         String cmd = e.getActionCommand();
+         if (cmd.equals("Cut")) {
+-            // textArea.cut();
++            textArea.cut();
+         } else if (cmd.equals("Copy")) {
+             textArea.copy();
+         } else if (cmd.equals("Paste")) {
+-            // textArea.paste();
++            textArea.paste();
+         }
+     }
+ 
+@@ -899,15 +908,71 @@
+     }
+ 
+     void load() {
+-        Scriptable scope = db.getScope();
++        //Scriptable scope = db.getScope();
++        Scriptable scope = db.officeScripts.getScriptScope( getUrl() );
++        if ( scope == null )
++        {
++            scope = db.getScope();
++        }
++        
+         if (scope == null) {
+             MessageDialogWrapper.showMessageDialog(db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
+         } else {
+             String url = getUrl();
+             if (url != null) {
+-                new Thread(new LoadFile(db,scope,url)).start();
++                new Thread(new LoadFile(db,scope, url, new StringReader(textArea.getText()))).start(); 
++            }
++        }
+             }
++
++    void save() {
++        if (getUrl() != null) {
++            OutputStream os = null;
++            try {
++                if ( getUrl().startsWith("vnd.sun.star")  )
++                {
++                    URL scriptUrl = db.officeScripts.getScriptUrl( getUrl() );
++                    if ( scriptUrl == null )
++                    {
++                        throw new IOException("Can't optain stream for " + getUrl() );
+         }
++                    os = scriptUrl.openConnection().getOutputStream();
++                }
++                else
++                {
++                   os = new FileOutputStream( getUrl() );
++                }
++                String s = textArea.getText();
++                os.write(s.getBytes(), 0, s.length());
++
++                this.isModified = false;
++            }
++            catch (IOException ioe) {
++                JOptionPane.showMessageDialog(this,
++                    "Error saving file: " + ioe.getMessage(),
++                    "Error", JOptionPane.ERROR_MESSAGE);
++            }
++            finally
++            {
++                if ( os != null )
++                {
++                    try
++                    {
++                        os.close();
++                        os = null;
++                    }
++                    catch( IOException ioe )
++                    {
++                        System.err.println("Error closing stream: " + ioe.getMessage() );
++                        ioe.printStackTrace();
++                    }
++                }
++            }
++        }
++    }
++
++    public boolean isEditable() {
++        return db.isSourceEditingEnabled();
+     }
+ 
+    public int getPosition(int line) {
+@@ -942,7 +1007,7 @@
+             fileHeader.repaint();
+         }
+     }
+-
++    public Main getDB() { return db; }
+     FileWindow(Main db, SourceInfo sourceInfo) {
+         super(SourceInfo.getShortName(sourceInfo.getUrl()),
+               true, true, true, true);
+@@ -961,6 +1026,16 @@
+         pack();
+         updateText();
+         textArea.select(0);
++        addInternalFrameListener( new InternalFrameAdapter() {
++            public void internalFrameClosed(InternalFrameEvent e) {
++                    // clean up scriptItems and sourceNames hashes
++                    getDB().removeScript( getUrl() );
++                    // remove scripts for officeScripts
++                    getDB().officeScripts.deleteScript( getUrl() );
++                }
++            } );
++                
++
+     }
+ 
+     private void updateToolTip() {
+@@ -979,7 +1054,10 @@
+     void updateText() {
+         String newText = sourceInfo.getSource();
+         if (!textArea.getText().equals(newText)) {
++            textArea.getDocument().removeDocumentListener(this);
+             textArea.setText(newText);
++            this.isModified = false;
++            textArea.getDocument().addDocumentListener(this);
+             int pos = 0;
+             if (currentPos != -1) {
+                 pos = currentPos;
+@@ -990,6 +1068,31 @@
+         fileHeader.repaint();
+     }
+ 
++    /* Implementation of DocumentListener interface */
++    public void insertUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void removeUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void changedUpdate(DocumentEvent e) {
++        doChanged(e);
++    }
++
++    public void doChanged(DocumentEvent e) {
++        this.isModified = true;
++    }
++
++    public boolean isModified() {
++        return this.isModified;
++    }
++
++    public String getText() {
++        return textArea.getText();
++    }
++
+     void setPosition(int pos) {
+         textArea.select(pos);
+         currentPos = pos;
+@@ -1601,7 +1704,7 @@
+         if (line != -1) {
+             db.currentWindow = w;
+         }
+-        db.menubar.addFile(url);
++        // db.menubar.addFile(url);
+         w.setVisible(true);
+         if (activate) {
+             try {
+@@ -1735,8 +1838,10 @@
+     Menubar(Main db) {
+         super();
+         this.db = db;
+-        String[] fileItems  = {"Open...", "Run...", "", "Exit"};
+-        String[] fileCmds  = {"Open", "Load", "", "Exit"};
++        // String[] fileItems  = {"Open...", "Run...", "", "Exit"};
++        // String[] fileCmds  = {"Open", "Load", "", "Exit"};
++        String[] fileItems  = {"Run", "Save", "", "Exit"};
++        String[] fileCmds  = {"Run", "Save", "", "Exit"};
+         char[] fileShortCuts = {'0', 'N', '\0', 'X'};
+         int[] fileAccelerators = {KeyEvent.VK_O,
+                                   KeyEvent.VK_N,
+@@ -1778,6 +1883,9 @@
+                     KeyStroke k = KeyStroke.getKeyStroke(fileAccelerators[i], Event.CTRL_MASK);
+                     item.setAccelerator(k);
+                 }
++                if (fileItems[i].equals("Save")) {
++                    saveItem = item;
++                }
+             }
+         }
+         for (int i = 0; i < editItems.length; ++i) {
+@@ -1832,9 +1940,9 @@
+         item.addActionListener(this);
+         windowMenu.add(item = new JMenuItem("Tile", 'T'));
+         item.addActionListener(this);
+-        windowMenu.addSeparator();
+-        windowMenu.add(item = new JMenuItem("Console", 'C'));
+-        item.addActionListener(this);
++        // windowMenu.addSeparator();
++        // windowMenu.add(item = new JMenuItem("Console", 'C'));
++        // item.addActionListener(this);
+         add(windowMenu);
+ 
+     }
+@@ -1908,11 +2016,16 @@
+         item.addActionListener(this);
+     }
+ 
++    public void setSaveEnabled(boolean state) {
++        saveItem.setEnabled(state);
++    }
++
+     Main db;
+     JMenu windowMenu;
+     JCheckBoxMenuItem breakOnExceptions;
+     JCheckBoxMenuItem breakOnEnter;
+     JCheckBoxMenuItem breakOnReturn;
++    JMenuItem saveItem;
+ };
+ 
+ class EnterInterrupt implements Runnable {
+@@ -1925,6 +2038,13 @@
+     public void run() {
+         JMenu menu = db.getJMenuBar().getMenu(0);
+         //menu.getItem(0).setEnabled(false); // File->Load
++
++        // disable Edit menu Cut, Copy, Paste items
++        menu = db.getJMenuBar().getMenu(1);
++        for (int i = 0; i < 3; i++) {
++            menu.getItem(i).setEnabled(false);
++        }
++
+         menu = db.getJMenuBar().getMenu(2);
+         menu.getItem(0).setEnabled(false); // Debug->Break
+         int count = menu.getItemCount();
+@@ -1937,6 +2057,10 @@
+             b = true;
+         }
+         db.toolBar.setEnabled(true);
++
++        // set flag to disable source editing
++        db.setSourceEditingEnabled(false);
++
+         // raise the debugger window
+         db.toFront();
+     }
+@@ -1950,6 +2074,13 @@
+     public void run() {
+         JMenu menu = db.getJMenuBar().getMenu(0);
+         menu.getItem(0).setEnabled(true); // File->Load
++
++        // enable Edit menu items
++        menu = db.getJMenuBar().getMenu(1);
++        for (int i = 0; i < 3; i++) {
++            menu.getItem(i).setEnabled(true);
++        }
++
+         menu = db.getJMenuBar().getMenu(2);
+         menu.getItem(0).setEnabled(true); // Debug->Break
+         int count = menu.getItemCount() - 1;
+@@ -1963,6 +2094,9 @@
+             db.toolBar.getComponent(ci).setEnabled(b);
+             b = false;
+         }
++        // set flag to enable source editing
++        db.setSourceEditingEnabled(true);
++
+         //db.console.consoleTextArea.requestFocus();
+     }
+ };
+@@ -1971,17 +2105,24 @@
+     Scriptable scope;
+     String fileName;
+     Main db;
++    Reader reader = null;
++
+     OpenFile(Main db, Scriptable scope, String fileName) {
+         this.scope = scope;
+         this.fileName = fileName;
+         this.db = db;
+     }
++    OpenFile(Main db, Scriptable scope, String fileName, Reader reader) {
++        this(db, scope, fileName);
++        this.reader = reader;
++    }
+     public void run() {
+         Context cx = Context.enter();
+         ContextData contextData = ContextData.get(cx);
+         contextData.breakNextLine = true;
+         try {
+-            cx.compileReader(scope, new FileReader(fileName),
++            cx.compileReader(scope,
++                reader == null ? new FileReader(fileName) : reader,
+                              fileName, 1, null);
+         } catch (Exception exc) {
+             String msg = exc.getMessage();
+@@ -2003,29 +2144,80 @@
+     Scriptable scope;
+     String fileName;
+     Main db;
++    Reader reader = null;
++    Object result = null;
++    Exception exception = null;
++    int lineNum = -1;
++    boolean sfExecute = false;
++    
+     LoadFile(Main db, Scriptable scope, String fileName) {
+         this.scope = scope;
+         this.fileName = fileName;
+         this.db = db;
+     }
++
++    LoadFile(Main db, Scriptable scope, String fileName, Reader reader) {
++        this(db, scope, fileName);
++        this.reader = reader;
++    }
++    LoadFile(Main db, Scriptable scope, String fileName, Reader reader, boolean sfExecute ) {
++        this(db, scope, fileName);
++        this.reader = reader;
++        this.sfExecute = sfExecute;
++    }
++
+     public void run() {
++        if ( db.officeScripts.isScriptRunning( fileName ) )
++        { 
++            exception = new Exception("The script is already executing");
++            if ( !sfExecute ) {
++                MessageDialogWrapper.showMessageDialog(db,
++                                                   "Script already executing",
++                                                   "Run",
++                                                   JOptionPane.ERROR_MESSAGE);
++            }
++            return;
++        } 
++        db.officeScripts.setScriptRunning( fileName, true );
+         Context cx = Context.enter();
+         ContextData contextData = ContextData.get(cx);
++        if ( sfExecute )
++        {
++            contextData.breakNextLine = false;
++        }
++        else
++        {
+         contextData.breakNextLine = true;
++        }
++        /*
++        FileWindow w = (FileWindow)db.getSelectedFrame();
++        if ( sfExecute )        
++        {
++            db.swingInvoke(new SetFilePosition(db, w, -1 ) );                
++        }*/
+         try {
+-            cx.evaluateReader(scope, new FileReader(fileName),
++            result = cx.evaluateReader(scope,
++                reader == null ? new FileReader(fileName) : reader,
+                               fileName, 1, null);
+         } catch (Exception exc) {
++            exception = exc;
+             String msg = exc.getMessage();
+             if (exc instanceof EcmaError) {
+                 EcmaError err = (EcmaError)exc;
+                 msg = err.getSourceName() + ", line " + err.getLineNumber() + ": " + msg;
+-            }
++    
++                int lineNum =  err.getLineNumber() ;
++                //db.swingInvoke(new SetFilePosition(db, w, lineNum ) );
++                if ( !sfExecute ) {
+             MessageDialogWrapper.showMessageDialog(db,
+                                                    msg,
+                                                    "Run",
+                                                    JOptionPane.ERROR_MESSAGE);
++                }
++            }
++         
+         } finally {
++            db.officeScripts.setScriptRunning( fileName, false );
+             cx.exit();
+         }
+     }
+@@ -2400,13 +2592,13 @@
+         super.setVisible(b);
+         if (b) {
+             // this needs to be done after the window is visible
+-            console.consoleTextArea.requestFocus();
++            // console.consoleTextArea.requestFocus();
+             context.split.setDividerLocation(0.5);
+             try {
+-                console.setMaximum(true);
+-                console.setSelected(true);
+-                console.show();
+-                console.consoleTextArea.requestFocus();
++                // console.setMaximum(true);
++                // console.setSelected(true);
++                // console.show();
++                // console.consoleTextArea.requestFocus();
+             } catch (Exception exc) {
+             }
+         }
+@@ -2431,36 +2623,9 @@
+     private Hashtable scriptItems = new Hashtable();
+     private Hashtable sourceNames = new Hashtable();
+ 
++  
+     Hashtable functionNames = new Hashtable();
+ 
+-    ScriptItem getScriptItem(DebuggableScript fnOrScript) {
+-        ScriptItem item = (ScriptItem)scriptItems.get(fnOrScript);
+-        if (item == null) {
+-            String url = getNormilizedUrl(fnOrScript);
+-            SourceInfo si = (SourceInfo)sourceNames.get(url);
+-            if (si == null) {
+-                if (!fnOrScript.isGeneratedScript()) {
+-                    // Not eval or Function, try to load it from URL
+-                    String source = null;
+-                    try {
+-                        InputStream is = openSource(url);
+-                        try { source = readSource(is); }
+-                        finally { is.close(); }
+-                    } catch (IOException ex) {
+-                        System.err.println
+-                            ("Failed to load source from "+url+": "+ ex);
+-                    }
+-                    if (source != null) {
+-                        si = registerSource(url, source);
+-                    }
+-                }
+-            }
+-            if (si != null) {
+-                item = registerScript(si, fnOrScript);
+-            }
+-        }
+-        return item;
+-    }
+ 
+     /* Debugger Interface */
+ 
+@@ -2474,7 +2639,7 @@
+ 
+     String getNormilizedUrl(DebuggableScript fnOrScript) {
+         String url = fnOrScript.getSourceName();
+-        if (url == null) { url = "<stdin>"; }
++        if (url == null) { url = "document"; }
+         else {
+             // Not to produce window for eval from different lines,
+             // strip line numbers, i.e. replace all #[0-9]+\(eval\) by (eval)
+@@ -2586,6 +2751,8 @@
+                 si = new SourceInfo(sourceUrl, source);
+                 sourceNames.put(sourceUrl, si);
+             }
++            else if (!source.equals(si.getSource()))
++                si.setSource(source);
+         }
+         return si;
+     }
+@@ -2681,7 +2848,6 @@
+     EvalWindow evalWindow;
+     JSplitPane split1;
+     JLabel statusBar;
+-
+     void init() {
+         setJMenuBar(menubar = new Menubar(this));
+         toolBar = new JToolBar();
+@@ -2760,7 +2926,7 @@
+         desk = new JDesktopPane();
+         desk.setPreferredSize(new Dimension(600, 300));
+         desk.setMinimumSize(new Dimension(150, 50));
+-        desk.add(console = new JSInternalConsole("JavaScript Console"));
++        // desk.add(console = new JSInternalConsole("JavaScript Console"));
+         context = new ContextWindow(this);
+         context.setPreferredSize(new Dimension(600, 120));
+         context.setMinimumSize(new Dimension(50, 50));
+@@ -2828,6 +2994,7 @@
+             swingInvoke(UpdateFileText.action(w));
+             w.show();
+         } else if (!fileName.equals("<stdin>")) {
++            
+             swingInvoke(CreateFileWindow.action(this, si, -1));
+         }
+     }
+@@ -2869,7 +3036,7 @@
+             FrameHelper frame = contextData.getFrame(frameIndex);
+             String sourceName = frame.getUrl();
+             if (sourceName == null || sourceName.equals("<stdin>")) {
+-                console.show();
++                // console.show();
+                 helper.reset();
+                 return;
+             }
+@@ -2893,6 +3060,19 @@
+     int dispatcherIsWaiting = 0;
+     Context currentContext = null;
+ 
++    // Flag used to establish whether source code editing is allowed in
++    // the debugger, switched on and off depending on whether a debug session
++    // is active
++    boolean sourceEditingEnabled = true;
++
++    public boolean isSourceEditingEnabled() {
++        return sourceEditingEnabled;
++    }
++
++    void setSourceEditingEnabled(boolean b) {
++        sourceEditingEnabled = b;
++    }
++
+     Context getCurrentContext() {
+         return currentContext;
+     }
+@@ -3026,14 +3206,14 @@
+                     swingInvoke(CreateFileWindow.action(this, si, line));
+                 }
+             } else {
+-                if (console.isVisible()) {
++                /* if (console.isVisible()) {
+                     final JSInternalConsole finalConsole = console;
+                     swingInvoke(new Runnable() {
+                             public void run() {
+                                 finalConsole.show();
+                             }
+                         });
+-                }
++                } */
+             }
+             swingInvoke(new EnterInterrupt(this, cx));
+             swingInvoke(new UpdateContext(this, cx));
+@@ -3221,6 +3401,14 @@
+                                             fileName)).start();
+                 }
+             }
++        } else if (cmd.equals("Run")) {
++            FileWindow w = (FileWindow)getSelectedFrame();
++            if (w != null)
++                w.load();
++        } else if (cmd.equals("Save")) {
++            FileWindow w = (FileWindow)getSelectedFrame();
++            if (w != null)
++                w.save();
+         } else if (cmd.equals("More Windows...")) {
+             MoreWindows dlg = new MoreWindows(this, fileWindows,
+                                               "Window", "Files");
+@@ -3505,6 +3693,60 @@
+         }
+     }
+ 
++    JInternalFrame getFrameForUrl( URL url )
++    { 
++        JInternalFrame[] frames = desk.getAllFrames();
++        for (int i = 0; i < frames.length; i++) {
++           FileWindow w = (FileWindow)frames[i];
++           if ( url.toString().equals( w.getUrl() ) ) {
++               return w;
++               }
++           }
++        return null; 
++    } 
++    public void highlighLineInSelectedWindow(URL url, int lineNum ){
++        //FileWindow w = (FileWindow)getFrameForUrl( url );
++        FileWindow w = (FileWindow)getSelectedFrame();
++        if (w != null)
++        {
++            if ( lineNum > -1 )
++                swingInvoke(new SetFilePosition(this, w, lineNum ) );
++        }
++    }
++    public Object  runSelectedWindow( URL scriptUrl ) throws Exception
++    {
++        Object result = null;
++        FileWindow w = (FileWindow)getSelectedFrame();
++        //FileWindow w = (FileWindow)getFrameForUrl( scriptUrl );
++        w.toFront();
++        if (w != null)
++        {
++            Scriptable scope = w.db.getScope();
++            if (scope == null) 
++            {
++                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
++                result =  null;
++            } 
++            else 
++            {
++                String url = w.getUrl();
++                Thread executorThread = null;
++                if (url != null) 
++                {
++                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
++                    executor.run(); 
++                    result = executor.result;  
++                    if ( executor.exception != null )
++                    {
++                        throw executor.exception;
++                    }
++                }
++            }
++        }
++        return result;
++
++    }
++
+     //
+     // public interface
+     //
+@@ -3600,6 +3842,70 @@
+         return console.getErr();
+     }
+ 
++    public void openFile(URL scriptUrl, Scriptable scope, Runnable closeCallback ) {
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (scriptUrl != null) {
++                try
++                {
++                    InputStreamReader reader = new InputStreamReader(scriptUrl.openStream()); 
++                    String fileName = null;
++                    if ( scriptUrl.getProtocol().startsWith("vnd.sun.star.") )
++                    {
++                        fileName = scriptUrl.toString();
++                    }
++                    else
++                    {
++                        fileName = scriptUrl.getPath();
++                    }
++                    officeScripts.addScript( fileName, scriptUrl, scope, closeCallback  );
++                    //new Thread(new OpenFile(this, scope, fileName, reader )).start();
++                    swingInvoke( new OpenFile(this, scope, fileName, reader ));
++                }
++                catch ( IOException e )
++                {
++                    MessageDialogWrapper.showMessageDialog(this,
++                        "Can't open stream for script: " + e.toString(),
++                        "Open", JOptionPane.ERROR_MESSAGE);
++                }
++            }
++        }
++        split1.setDividerLocation(1.0);
++    }
++
++
++    public void openFile(String fileName) {
++        Scriptable scope = getScope();
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (fileName != null) {
++                new Thread(new OpenFile(this, scope, fileName)).start();
++            }
++        }
++        split1.setDividerLocation(1.0);
++    }
++
++    public void openStream(InputStream in) {
++        Scriptable scope = getScope();
++        if (scope == null) {
++            MessageDialogWrapper.showMessageDialog(this,
++                "Can't compile scripts: no scope available",
++                "Open", JOptionPane.ERROR_MESSAGE);
++        } else {
++            if (in != null) {
++                new Thread(new OpenFile(this, scope, null, new InputStreamReader(in))).start();
++            }
++        }
++        split1.setDividerLocation(1.0);
++        menubar.setSaveEnabled(false);
++    }
++
+     public static void main(String[] args) {
+         try {
+             mainThread = Thread.currentThread();
+@@ -3631,5 +3937,163 @@
+         }
+     }
+ 
++// patched Office specific interface
++
++    OfficeScriptInfo officeScripts = new OfficeScriptInfo();
++
++    void removeScript( String url )
++    {
++        // Remove the FileWindow from list of open sources
++        fileWindows.remove( url );
++
++        // Remove sourceInfo from sourceNames, ensures that
++        // breakpoints etc are deleted
++        synchronized (sourceNames) {
++            sourceNames.remove( url );
++        }
++        // Removes scriptItems for the script, ensures that a new open ( from openFile )
++        // will succeed, openFile should open file but fails due to fact that 
++        synchronized ( scriptItems ) 
++        {   
++            Iterator iter = scriptItems.entrySet().iterator();
++            while ( iter.hasNext() )
++            {
++                Map.Entry me = ( Map.Entry )iter.next();
++                ScriptItem item = (ScriptItem)me.getValue();
++                SourceInfo si =   item.getSourceInfo();
++                if ( si.getUrl().equals( url ) )
++                {
++                    //match
++                    scriptItems.remove( me.getKey() );
++                    break;
++                }
++            }
++        }
++        officeScripts.deleteScript( url );
++    }
++
++
++    ScriptItem getScriptItem(DebuggableScript fnOrScript) {
++        ScriptItem item = (ScriptItem)scriptItems.get(fnOrScript);
++        if (item == null) {
++            String url = getNormilizedUrl(fnOrScript);
++            SourceInfo si = (SourceInfo)sourceNames.get(url);
++            if (si == null) {
++                if (!fnOrScript.isGeneratedScript()) {
++                    // Not eval or Function, try to load it from URL
++                    String source = null;
++                    try {
++                        InputStream is = openSource(url);
++                        try { source = readSource(is); }
++                        finally { is.close(); }
++                    } catch (IOException ex) {
++                        System.err.println
++                            ("Failed to load source from "+url+": "+ ex);
++                    }
++                    if (source != null) {
++                        si = registerSource(url, source);
++                    }
++                }
++            }
++            if (si != null) {
++                item = registerScript(si, fnOrScript);
++            }
++        }
++        
++        return item;
++    }
++
++    public void showScriptWindow(URL url ){
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        if ( w != null )
++        {
++            //w.maximize();
++            desk.getDesktopManager().deiconifyFrame(w);
++            desk.getDesktopManager().activateFrame(w);
++            w.show();
++            w.toFront();
++        }
++    }
++
++    public void highlighLineInScriptWindow(URL url, int lineNum ){
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.getPath();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        if (w != null)
++        {
++            if ( lineNum > -1 )
++                swingInvoke(new SetFilePosition(this, w, lineNum ) );
++        }
++    }
++    public Object runScriptWindow( URL scriptUrl ) throws Exception
++    {
++        String key = scriptUrl.getPath();
++        if ( scriptUrl.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = scriptUrl.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        Object result = null;
++        w.toFront();
++        if (w != null)
++        {
++            //Scriptable scope = w.db.getScope();
++            Scriptable scope = w.db.officeScripts.getScriptScope( key );
++            if (scope == null) 
++            {
++                MessageDialogWrapper.showMessageDialog(w.db, "Can't load scripts: no scope available", "Run", JOptionPane.ERROR_MESSAGE);
++                result =  null;
++            } 
++            else 
++            {
++                String url = w.getUrl();
++                Thread executorThread = null;
++                if (url != null) 
++                {
++                    LoadFile executor = new  LoadFile(w.db,scope, url, new StringReader(w.textArea.getText()), true );
++                    executor.run(); 
++                    result = executor.result;  
++                    if ( executor.exception != null )
++                    {
++                        throw executor.exception;
++                    }
++                }
++            }
++        }
++        return result;
++
++    }
++
++    public boolean isModified( URL url ) 
++    {
++        String key = url.getPath();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        return w.isModified();
++    }
++
++    public String getText( URL url )
++    {
++        String key = url.toString();
++        if ( url.getProtocol().startsWith("vnd.sun.star") )
++        {
++            key = url.toString();
++        }
++        FileWindow w = (FileWindow)getFileWindow( key );
++        return w.getText();
++    }
++
++
+ }
+ 
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/OfficeScriptInfo.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/OfficeScriptInfo.java	2005-02-01 18:06:04.433017000 +0000
+@@ -0,0 +1,164 @@
++/*************************************************************************
++ *
++ *  $RCSfile$
++ *
++ *  $Revision$
++ *
++ *  last change: $Author$ $Date$
++ *
++ *  The Contents of this file are made available subject to the terms of
++ *  either of the following licenses
++ *
++ *         - GNU Lesser General Public License Version 2.1
++ *         - Sun Industry Standards Source License Version 1.1
++ *
++ *  Sun Microsystems Inc., October, 2000
++ *
++ *  GNU Lesser General Public License Version 2.1
++ *  =============================================
++ *  Copyright 2000 by Sun Microsystems, Inc.
++ *  901 San Antonio Road, Palo Alto, CA 94303, USA
++ *
++ *  This library is free software; you can redistribute it and/or
++ *  modify it under the terms of the GNU Lesser General Public
++ *  License version 2.1, as published by the Free Software Foundation.
++ *
++ *  This library is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ *  Lesser General Public License for more details.
++ *
++ *  You should have received a copy of the GNU Lesser General Public
++ *  License along with this library; if not, write to the Free Software
++ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ *  MA  02111-1307  USA
++ *
++ *
++ *  Sun Industry Standards Source License Version 1.1
++ *  =================================================
++ *  The contents of this file are subject to the Sun Industry Standards
++ *  Source License Version 1.1 (the "License"); You may not use this file
++ *  except in compliance with the License. You may obtain a copy of the
++ *  License at http://www.openoffice.org/license.html.
++ *
++ *  Software provided under this License is provided on an "AS IS" basis,
++ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
++ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
++ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
++ *  See the License for the specific provisions governing your rights and
++ *  obligations concerning the Software.
++ *
++ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
++ *
++ *  Copyright: 2000 by Sun Microsystems, Inc.
++ *
++ *  All Rights Reserved.
++ *
++ *  Contributor(s): _______________________________________
++ *
++ *
++ ************************************************************************/
++
++
++package org.mozilla.javascript.tools.debugger;
++import java.net.URL;
++import java.util.Hashtable;
++import org.mozilla.javascript.Scriptable;
++
++public class OfficeScriptInfo
++{
++    private Hashtable loadedSFScripts = new Hashtable();
++   
++    public void addScript( URL url, Scriptable scope, Runnable closeCallback )
++    {
++        addScript( url.toString(), url, scope, closeCallback );
++    }
++
++    public void addScript( String key, URL url, Scriptable scope, Runnable closeCallback )
++    {
++        SFScriptInfo si = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( si == null )
++        {
++            si = new SFScriptInfo();
++            si.url = url;
++            si.scope = scope; 
++            si.closeCallback = closeCallback; 
++            loadedSFScripts.put( key, si );
++        }  
++    }   
++
++    public void deleteScript( String key )
++    {
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.remove( key );
++        if ( info != null )
++        {
++            if ( info.closeCallback != null )
++            {
++                System.out.println("** In removeSFScriptInfo  have callback for " + key );
++                info.closeCallback.run(); // really need to do this in seperate thread????
++            }
++        }
++    }
++
++    public Scriptable getScriptScope( String key )
++    {
++        Scriptable result = null;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.scope;
++        }
++        return result;
++    } 
++  
++    public URL getScriptUrl( String key )
++    {
++        URL result = null;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.url;
++        }
++        return result;
++    } 
++    public boolean hasScript( String key )
++    {
++        boolean result = true;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info == null )
++        {
++            result = false;
++        }      
++        return result;
++    } 
++
++    public void setScriptRunning( String key, boolean running )
++    {
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            info.isExecuting = running;
++        }
++    }
++
++    public boolean isScriptRunning( String key )
++    {
++        boolean result = false;
++        SFScriptInfo info = (SFScriptInfo)loadedSFScripts.get( key );
++        if ( info != null )
++        {
++            result = info.isExecuting;
++        }
++        return result;
++    }
++
++    
++  
++    class SFScriptInfo
++    {
++        Scriptable scope;
++        boolean isExecuting;
++        URL url;
++        Runnable closeCallback;
++    }
++}
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModelAdapter.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModelAdapter.java	2005-02-01 18:06:04.473017000 +0000
+@@ -0,0 +1,126 @@
++/*
++ * @(#)TreeTableModelAdapter.java	1.2 98/10/27
++ *
++ * Copyright 1997, 1998 by Sun Microsystems, Inc.,
++ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
++ * All rights reserved.
++ *
++ * This software is the confidential and proprietary information
++ * of Sun Microsystems, Inc. ("Confidential Information").  You
++ * shall not disclose such Confidential Information and shall use
++ * it only in accordance with the terms of the license agreement
++ * you entered into with Sun.
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.JTree;
++import javax.swing.SwingUtilities;
++import javax.swing.table.AbstractTableModel;
++import javax.swing.tree.TreePath;
++import javax.swing.event.TreeExpansionEvent;
++import javax.swing.event.TreeExpansionListener;
++import javax.swing.event.TreeModelEvent;
++import javax.swing.event.TreeModelListener;
++
++/**
++ * This is a wrapper class takes a TreeTableModel and implements 
++ * the table model interface. The implementation is trivial, with 
++ * all of the event dispatching support provided by the superclass: 
++ * the AbstractTableModel. 
++ *
++ * @version 1.2 10/27/98
++ *
++ * @author Philip Milne
++ * @author Scott Violet
++ */
++public class TreeTableModelAdapter extends AbstractTableModel
++{
++    JTree tree;
++    TreeTableModel treeTableModel;
++
++    public TreeTableModelAdapter(TreeTableModel treeTableModel, JTree tree) {
++        this.tree = tree;
++        this.treeTableModel = treeTableModel;
++
++	tree.addTreeExpansionListener(new TreeExpansionListener() {
++	    // Don't use fireTableRowsInserted() here; the selection model
++	    // would get updated twice. 
++	    public void treeExpanded(TreeExpansionEvent event) {  
++	      fireTableDataChanged(); 
++	    }
++            public void treeCollapsed(TreeExpansionEvent event) {  
++	      fireTableDataChanged(); 
++	    }
++	});
++
++	// Install a TreeModelListener that can update the table when
++	// tree changes. We use delayedFireTableDataChanged as we can
++	// not be guaranteed the tree will have finished processing
++	// the event before us.
++	treeTableModel.addTreeModelListener(new TreeModelListener() {
++	    public void treeNodesChanged(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeNodesInserted(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeNodesRemoved(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++
++	    public void treeStructureChanged(TreeModelEvent e) {
++		delayedFireTableDataChanged();
++	    }
++	});
++    }
++
++    // Wrappers, implementing TableModel interface. 
++
++    public int getColumnCount() {
++	return treeTableModel.getColumnCount();
++    }
++
++    public String getColumnName(int column) {
++	return treeTableModel.getColumnName(column);
++    }
++
++    public Class getColumnClass(int column) {
++	return treeTableModel.getColumnClass(column);
++    }
++
++    public int getRowCount() {
++	return tree.getRowCount();
++    }
++
++    protected Object nodeForRow(int row) {
++	TreePath treePath = tree.getPathForRow(row);
++	return treePath.getLastPathComponent();         
++    }
++
++    public Object getValueAt(int row, int column) {
++	return treeTableModel.getValueAt(nodeForRow(row), column);
++    }
++
++    public boolean isCellEditable(int row, int column) {
++         return treeTableModel.isCellEditable(nodeForRow(row), column); 
++    }
++
++    public void setValueAt(Object value, int row, int column) {
++	treeTableModel.setValueAt(value, nodeForRow(row), column);
++    }
++
++    /**
++     * Invokes fireTableDataChanged after all the pending events have been
++     * processed. SwingUtilities.invokeLater is used to handle this.
++     */
++    protected void delayedFireTableDataChanged() {
++	SwingUtilities.invokeLater(new Runnable() {
++	    public void run() {
++		fireTableDataChanged();
++	    }
++	});
++    }
++}
++
+--- misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModel.java	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/rhino1_5R4/toolsrc/org/mozilla/javascript/tools/debugger/TreeTableModel.java	2005-02-01 18:06:04.493018000 +0000
+@@ -0,0 +1,69 @@
++/*
++ * TreeTableModel.java
++ *
++ * Copyright (c) 1998 Sun Microsystems, Inc. All Rights Reserved.
++ *
++ * This software is the confidential and proprietary information of Sun
++ * Microsystems, Inc. ("Confidential Information").  You shall not
++ * disclose such Confidential Information and shall use it only in
++ * accordance with the terms of the license agreement you entered into
++ * with Sun.
++ *
++ * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
++ * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
++ * PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR ANY DAMAGES
++ * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
++ * THIS SOFTWARE OR ITS DERIVATIVES.
++ *
++ */
++package org.mozilla.javascript.tools.debugger;
++
++import javax.swing.tree.TreeModel;
++
++/**
++ * TreeTableModel is the model used by a JTreeTable. It extends TreeModel
++ * to add methods for getting inforamtion about the set of columns each 
++ * node in the TreeTableModel may have. Each column, like a column in 
++ * a TableModel, has a name and a type associated with it. Each node in 
++ * the TreeTableModel can return a value for each of the columns and 
++ * set that value if isCellEditable() returns true. 
++ *
++ * @author Philip Milne 
++ * @author Scott Violet
++ */
++public interface TreeTableModel extends TreeModel
++{
++    /**
++     * Returns the number ofs availible column.
++     */
++    public int getColumnCount();
++
++    /**
++     * Returns the name for column number <code>column</code>.
++     */
++    public String getColumnName(int column);
++
++    /**
++     * Returns the type for column number <code>column</code>.
++     */
++    public Class getColumnClass(int column);
++
++    /**
++     * Returns the value to be displayed for node <code>node</code>, 
++     * at column number <code>column</code>.
++     */
++    public Object getValueAt(Object node, int column);
++
++    /**
++     * Indicates whether the the value for node <code>node</code>, 
++     * at column number <code>column</code> is editable.
++     */
++    public boolean isCellEditable(Object node, int column);
++
++    /**
++     * Sets the value for node <code>node</code>, 
++     * at column number <code>column</code>.
++     */
++    public void setValueAt(Object aValue, Object node, int column);
++}
cvs server: Diffing rhino/prj
Index: rhino/prj/d.lst
===================================================================
RCS file: /cvs/external/rhino/prj/d.lst,v
retrieving revision 1.2
retrieving revision 1.2.42.1
diff -u -p -r1.2 -r1.2.42.1
--- rhino/prj/d.lst	3 Dec 2003 15:49:38 -0000	1.2
+++ rhino/prj/d.lst	7 Feb 2005 13:53:28 -0000	1.2.42.1
@@ -1 +1 @@
-..\%__SRC%\class\js-1.5R4.jar %_DEST%\bin%_EXT%\js.jar
+..\%__SRC%\misc\build\rhino1_5R4\build\rhino1_5R4\js.jar %_DEST%\bin%_EXT%\js.jar
cvs server: Diffing svx
cvs server: Diffing svx/doc
cvs server: Diffing svx/doc/UML
cvs server: Diffing svx/inc
cvs server: Diffing svx/inc/svx
cvs server: Diffing svx/inc/svx/sdr
cvs server: Diffing svx/inc/svx/sdr/animation
cvs server: Diffing svx/inc/svx/sdr/contact
cvs server: Diffing svx/inc/svx/sdr/event
cvs server: Diffing svx/inc/svx/sdr/mixer
cvs server: Diffing svx/inc/svx/sdr/properties
cvs server: Diffing svx/prj
cvs server: Diffing svx/qa
cvs server: Diffing svx/qa/unoapi
cvs server: Diffing svx/qa/unoapi/testdocuments
cvs server: Diffing svx/res
cvs server: Diffing svx/sdi
cvs server: Diffing svx/source
cvs server: Diffing svx/source/accessibility
cvs server: Diffing svx/source/customshapes
cvs server: Diffing svx/source/dialog
cvs server: Diffing svx/source/editeng
cvs server: Diffing svx/source/engine3d
cvs server: Diffing svx/source/fmcomp
cvs server: Diffing svx/source/form
cvs server: Diffing svx/source/gallery2
cvs server: Diffing svx/source/inc
cvs server: Diffing svx/source/init
cvs server: Diffing svx/source/intro
cvs server: Diffing svx/source/items
cvs server: Diffing svx/source/mnuctrls
cvs server: Diffing svx/source/msfilter
cvs server: Diffing svx/source/options
cvs server: Diffing svx/source/outliner
cvs server: Diffing svx/source/sdr
cvs server: Diffing svx/source/sdr/animation
cvs server: Diffing svx/source/sdr/contact
cvs server: Diffing svx/source/sdr/event
cvs server: Diffing svx/source/sdr/mixer
cvs server: Diffing svx/source/sdr/properties
cvs server: Diffing svx/source/src
cvs server: Diffing svx/source/stbctrls
cvs server: Diffing svx/source/svdraw
cvs server: Diffing svx/source/svrtf
cvs server: Diffing svx/source/svxlink
cvs server: Diffing svx/source/tbxctrls
cvs server: Diffing svx/source/toolbars
cvs server: Diffing svx/source/unodialogs
cvs server: Diffing svx/source/unodialogs/inc
cvs server: Diffing svx/source/unodialogs/textconversiondlgs
cvs server: Diffing svx/source/unodraw
cvs server: Diffing svx/source/unoedit
cvs server: Diffing svx/source/unogallery
cvs server: Diffing svx/source/xml
cvs server: Diffing svx/source/xoutdev
cvs server: Diffing svx/uiconfig
cvs server: Diffing svx/uiconfig/accelerator
cvs server: Diffing svx/uiconfig/accelerator/en-US
cvs server: Diffing svx/util
cvs server: Diffing svx/util/defs
cvs server: Diffing svx/win
cvs server: Diffing svx/win/res
cvs server: Diffing svx/workben
cvs server: Diffing svx/xml
cvs server: Diffing beanshell
Index: beanshell/bsh-2.0b1-src.patch
===================================================================
RCS file: beanshell/bsh-2.0b1-src.patch
diff -N beanshell/bsh-2.0b1-src.patch
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ beanshell/bsh-2.0b1-src.patch	7 Feb 2005 13:46:25 -0000	1.1.2.1
@@ -0,0 +1,104 @@
+--- misc/build/BeanShell/build.xml	2003-12-19 17:04:47.000000000 +0000
++++ misc/build/BeanShell/build.xml	2003-12-19 17:53:18.000000000 +0000
+@@ -17,7 +17,7 @@
+ 		up the build dir!  It has to be done manually the first time (or put
+ 		in the jar file). There must be a way to fix this...
+ -->
+-<project name="beanshell" default="compile" basedir=".">
++<project name="beanshell" default="jarall" basedir=".">
+ 
+ <!-- Project Configuration -->
+ 
+@@ -71,6 +71,9 @@
+ 		value="bsh/util/BeanShellBSFEngine.java,TestBshBSF.java"/>
+ 	-->
+ 
++	<property name="exclude-bsf" 
++		value="bsh/util/BeanShellBSFEngine.java,TestBshBSF.java"/>
++
+ 	<!-- Uncomment to build without the ASM class generator code.
+ 	<property name="exclude-classgen" 
+ 		value="bsh/org/objectweb/asm/**,bsh/ClassGeneratorImpl.java,bsh/ClassGeneratorUtil.java,bsh/DelayedEvalBshMethod.java"/>
+@@ -81,6 +84,9 @@
+ 		value="bsh/servlet/*"/>
+ 	-->
+ 
++	<property name="exclude-servlet" 
++		value="bsh/servlet/*"/>
++
+ 	<!-- Legacy excludes.  Comment this *out* to build these legacy items -->
+ 	<property name="legacy-excludes" 
+ 		value="bsh/JThis.java"/>
+--- misc/build/BeanShell/makefile.mk	1970-01-01 01:00:00.000000000 +0100
++++ misc/build/BeanShell/makefile.mk	2003-12-19 17:04:47.000000000 +0000
+@@ -0,0 +1,70 @@
++#*************************************************************************
++#
++#   $RCSfile$
++#
++#   $Revision$
++#
++#   last change: $Author$ $Date$
++#
++#   The Contents of this file are made available subject to the terms of
++#   either of the following licenses
++#
++#          - GNU Lesser General Public License Version 2.1
++#          - Sun Industry Standards Source License Version 1.1
++#
++#   Sun Microsystems Inc., October, 2000
++#
++#   GNU Lesser General Public License Version 2.1
++#   =============================================
++#   Copyright 2000 by Sun Microsystems, Inc.
++#   901 San Antonio Road, Palo Alto, CA 94303, USA
++#
++#   This library is free software; you can redistribute it and/or
++#   modify it under the terms of the GNU Lesser General Public
++#   License version 2.1, as published by the Free Software Foundation.
++#
++#   This library is distributed in the hope that it will be useful,
++#   but WITHOUT ANY WARRANTY; without even the implied warranty of
++#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++#   Lesser General Public License for more details.
++#
++#   You should have received a copy of the GNU Lesser General Public
++#   License along with this library; if not, write to the Free Software
++#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++#   MA  02111-1307  USA
++#
++#
++#   Sun Industry Standards Source License Version 1.1
++#   =================================================
++#   The contents of this file are subject to the Sun Industry Standards
++#   Source License Version 1.1 (the "License"); You may not use this file
++#   except in compliance with the License. You may obtain a copy of the
++#   License at http://www.openoffice.org/license.html.
++#
++#   Software provided under this License is provided on an "AS IS" basis,
++#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
++#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
++#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
++#   See the License for the specific provisions governing your rights and
++#   obligations concerning the Software.
++#
++#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
++#
++#   Copyright: 2000 by Sun Microsystems, Inc.
++#
++#   All Rights Reserved.
++#
++#   Contributor(s): _______________________________________
++#
++#
++#
++#*************************************************************************
++
++PRJ=..$/..$/..$/..
++PRJNAME=ooo_beanshell
++TARGET=jarall
++
++.INCLUDE : ant.mk
++
++ALLTAR : ANTBUILD
++
Index: beanshell/bsh-2.0b1.jar
===================================================================
RCS file: beanshell/bsh-2.0b1.jar
diff -N beanshell/bsh-2.0b1.jar
Binary files /tmp/cvsTaay4f and /dev/null differ
Index: beanshell/makefile.mk
===================================================================
RCS file: beanshell/makefile.mk
diff -N beanshell/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ beanshell/makefile.mk	8 Feb 2005 11:11:59 -0000	1.1.2.2
@@ -0,0 +1,95 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=.
+
+PRJNAME=ooo_beanshell
+TARGET=ooo_beanshell
+
+.IF "$(SOLAR_JAVA)"!=""
+.IF "$(JDK)" == "gcj"
+all:
+        @echo This dir cannot be build with gcj because of javax.swing.text.DefaultStyledDocument
+.ELSE
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :	settings.mk
+
+# --- Files --------------------------------------------------------
+
+TARFILE_NAME=bsh-2.0b1-src
+TARFILE_ROOTDIR=BeanShell
+PATCH_FILE_NAME=bsh-2.0b1-src.patch
+
+BUILD_ACTION=dmake $(MFLAGS) $(CALLMACROS)
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : set_ext.mk
+.INCLUDE : target.mk
+.INCLUDE : tg_ext.mk
+
+.ENDIF
+.ELSE
+all:
+        @echo java disabled
+.ENDIF
cvs server: Diffing beanshell/prj
Index: beanshell/prj/build.lst
===================================================================
RCS file: /cvs/external/beanshell/prj/build.lst,v
retrieving revision 1.1
retrieving revision 1.1.24.1
diff -u -p -r1.1 -r1.1.24.1
--- beanshell/prj/build.lst	8 Dec 2003 14:13:57 -0000	1.1
+++ beanshell/prj/build.lst	7 Feb 2005 13:46:27 -0000	1.1.24.1
@@ -1,3 +1,3 @@
 be	beanshell	:	solenv NULL
-be	beanshell							usr1	-	all	be_mkout NULL
-be	beanshell\prj						get		-	all	be_prj NULL
+be	beanshell							usr1		-	all	be_mkout				NULL
+be	beanshell							nmake		-	all	be_beanshell		NULL
Index: beanshell/prj/d.lst
===================================================================
RCS file: /cvs/external/beanshell/prj/d.lst,v
retrieving revision 1.2
retrieving revision 1.2.24.1
diff -u -p -r1.2 -r1.2.24.1
--- beanshell/prj/d.lst	3 Dec 2003 15:48:07 -0000	1.2
+++ beanshell/prj/d.lst	7 Feb 2005 13:46:27 -0000	1.2.24.1
@@ -1 +1 @@
-..\bsh-2.0b1.jar %_DEST%\bin%_EXT%\bsh.jar
+..\%__SRC%\misc\build\BeanShell\dist\bsh-2.0b1.jar %_DEST%\bin%_EXT%\bsh.jar
