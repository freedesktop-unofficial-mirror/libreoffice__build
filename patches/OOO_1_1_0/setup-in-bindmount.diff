IZ#20459

In 1.1.1a
diff 1.49.14.2 to 1.49.14.2.2.3

--- setup2/mow/source/loader/loader.c.orig	2003-10-21 18:59:25.000000000 +0200
+++ setup2/mow/source/loader/loader.c	2003-10-24 17:22:42.000000000 +0200
@@ -60,6 +60,8 @@
  ************************************************************************/
 #include <stdio.h>
 #include <stdlib.h>
+#include <ctype.h>
+#include <wchar.h>
 
 #include <sys/types.h>
 #include <limits.h>
@@ -647,7 +649,6 @@
 unsigned long       nSetupSize = 0;
 
 void SendEvent(long);
-BOOL __getFullPath(const char* pszFilename, char* pszPath, unsigned long MaxLen);
 void __EnumFilesCallBack( char *pFile, ULONG nSize, void *pObject );
 void __UnzipCallback( long lBytesWritten );
 
@@ -980,7 +981,7 @@
 }
 
 /* ----------------------------------------------------------------------------- */
-int CheckForSlash( char* _pStr )
+int CheckForSlash( const char* _pStr )
 {
 	int i = 0;
 	char c;
@@ -1788,6 +1789,8 @@
     XGCValues       aValues;
     BOOL            bLD_LIBRARY_PATH_Set = FALSE;
     char*           pLibPath;
+    char            pRealPath[PATH_MAX];
+    char*           pResult = 0L;
     XSetWindowAttributes aAttr;
     XColor aColor;
     Colormap aColorMap;
@@ -1833,12 +1836,12 @@
         }
     }
 
-    if( !__getFullPath(progname, strAbsBinaryName, __MAX_PATH) )
+    if( !realpath( progname, strAbsBinaryName ) )
     {
         fprintf( stderr, "%s: absolute programpath cannot be found.\n", progname );
-        exit(0);
+        exit(-1);
     }
-
+    
     // we need a LD_LIBRARY_PATH with a current directory in it so we can
     // dynamicly load a library ( needed for patching! )
 #ifdef MACOSX
@@ -2116,183 +2119,6 @@
                 break;
         }
     }
-
-    return 1;
-}
-
-/*****************************************************************************/
-/* getFullPath */
-/*****************************************************************************/
-
-BOOL __getFullPath(const char* pszFilename, char* pszPath, unsigned long MaxLen)
-{
-    int   n, nBufSize;
-    char* pBuffer;
-    char* pDir;
-    struct stat status;
-    struct stat root;
-    struct stat parent;
-    char  Path[PATH_MAX + 1];
-
-    pDir = strdup(pszFilename);
-
-    /* check if path has a trailing '/', so it should specify a directory, */
-        /* or if last component doesn't exist or is not a directory. So in any case */
-    /* of this the last component should be remove before checking the path */
-    if ((pDir[strlen(pDir) - 1] == '/') ||
-        (stat(pDir, &status) < 0) || (! S_ISDIR(status.st_mode)))
-    {
-        char* pFile;
-
-        if ((pFile = strrchr(pDir, '/')) != NULL)
-        {
-            *pFile++ = '\0';
-            STRNCPY( Path, pFile, sizeof(Path) );
-            STRNCAT( Path, "/", sizeof(Path) );
-        }
-        else
-        {
-            STRNCPY( Path, pDir, sizeof(Path) );
-            STRNCAT( Path, "/", sizeof(Path) );
-            free(pDir);
-            pDir = strdup(".");
-        }
-
-        if ((strlen(pDir) > 0) &&
-            ((stat(pDir, &status) < 0) || (! S_ISDIR(status.st_mode))))
-        {
-            free(pDir);
-            return (FALSE);
-        }
-    }
-    else
-        Path[0] = '\0';
-
-    if ((n = pathconf(pDir, _PC_PATH_MAX)) < 0)
-        n = PATH_MAX + 1;
-
-    nBufSize = n+1;
-    pBuffer = (char *)malloc((n + 1) * sizeof(char));
-    STRNCPY( pBuffer, pDir, nBufSize );
-
-    stat("/", &root);
-
-    STRNCAT( pBuffer, "/.", nBufSize );
-    stat(pBuffer, &status);
-    STRNCAT( pBuffer, ".", nBufSize );
-
-    while ((status.st_dev != root.st_dev) || (status.st_ino != root.st_ino))
-    {
-        DIR*           dir;
-        struct dirent* entry;
-
-        if (((dir = opendir(pBuffer)) == NULL) ||
-            (stat(pBuffer, &parent) < 0))
-        {
-            if ( dir ) closedir( dir );
-            free(pDir);
-            free(pBuffer);
-
-            return (FALSE);
-        }
-
-        if (status.st_dev == parent.st_dev)
-        {
-            do
-            {
-                if ((entry = readdir(dir)) == NULL)
-                {
-                    closedir( dir );
-                    free(pDir);
-                    free(pBuffer);
-
-                    return (FALSE);
-                }
-            }
-            while (entry->d_ino != status.st_ino);
-        }
-        else
-        {
-            /*
-             * if this point is a mount point we have to check
-             * each entry, because the inode number in the directory
-             * is for the parent directory, not for the mounted file
-             */
-            size_t nFullLen = (strlen(pBuffer) + PATH_MAX + 1) * sizeof(char);
-            size_t nNameLen;
-            char* full = (char *)malloc( nFullLen );
-            char* name;
-
-            STRNCPY( full, pBuffer, nFullLen );
-            STRNCAT( full, "/", nFullLen );
-            name = full + strlen(full);
-            nNameLen = nFullLen - strlen(full);
-
-            do
-            {
-                if ((entry = readdir(dir)) == NULL)
-                {
-                    free(full);
-
-                    closedir( dir );
-                    free(pDir);
-                    free(pBuffer);
-
-                    return (FALSE);
-                }
-
-                if ((entry->d_name[0] == '.') && ((entry->d_name[1] == '\0') ||
-                    ((entry->d_name[1] == '.') && (entry->d_name[2] == '\0'))))
-                    continue;
-
-                STRNCPY( name, entry->d_name, nNameLen );
-
-                if (stat(full, &parent) < 0)
-                    continue;
-            }
-            while ((parent.st_ino != status.st_ino) || (parent.st_dev != status.st_dev));
-
-            free(full);
-        }
-
-        STRNCAT( Path, entry->d_name, sizeof(Path) );
-        STRNCAT( Path, "/", sizeof(Path) );
-
-        closedir(dir);
-
-        stat(pBuffer, &status);
-        STRNCAT( pBuffer, "/..", nBufSize );
-    }
-
-    free(pDir);
-    free(pBuffer);
-
-    if (strlen(Path) < MaxLen)
-    {
-        int  n;
-        char *p, *l;
-
-        for (p = Path + strlen(Path), l = p; p >= Path; p--)
-        {
-            if (*p == '/')
-            {
-                n = l - (p + 1);
-                memcpy(pszPath, p + 1, n);
-                pszPath += n;
-                *pszPath++ = '/';
-                l = p;
-            }
-        }
-
-        n = l - (p + 1);
-        memcpy(pszPath, p + 1, n);
-        pszPath += n;
-        *pszPath = '\0';
-
-        return (TRUE);
-    }
-
-    return (FALSE);
 }
 
 /*****************************************************************************/
