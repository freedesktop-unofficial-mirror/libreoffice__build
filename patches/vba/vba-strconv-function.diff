--- basic/source/runtime/stdobj.cxx.old	2007-11-20 17:32:54.000000000 -1000
+++ basic/source/runtime/stdobj.cxx	2007-11-20 22:51:43.000000000 -1000
@@ -504,9 +504,10 @@
   { "String1",      SbxSTRING, 0,NULL,0 },
   { "String2",      SbxSTRING, 0,NULL,0 },
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
-{ "StrConv",        SbxSTRING,   2 | _FUNCTION, RTLNAME(StrConv),0          },
-  { "String",       SbxSTRING, 0,NULL,0 },
+{ "StrConv",        SbxOBJECT,   3 | _FUNCTION, RTLNAME(StrConv),0          },
+  { "String",       SbxOBJECT, 0,NULL,0 },
   { "Conversion",   SbxSTRING, 0,NULL,0 },
+  { "LCID",			SbxINTEGER, 0,NULL,0 },
 { "String",         SbxSTRING,    2 | _FUNCTION, RTLNAME(String),0          },
   { "Count",        SbxLONG, 0,NULL,0 },
   { "Filler",       SbxVARIANT, 0,NULL,0 },
--- basic/source/runtime/methods.cxx.old	2007-11-20 17:32:39.000000000 -1000
+++ basic/source/runtime/methods.cxx	2007-11-20 22:44:45.000000000 -1000
@@ -3934,21 +3934,159 @@
 	rPar.Get(0)->PutLong( nRGB );
 }
 
+bool IsIndexOne()
+{
+	bool result = false;
+	if ( pINST && pINST->pRun )
+	{
+		USHORT res = pINST->pRun->GetBase();
+		if ( res )
+			result = true;
+	}	
+	return result;
+}
 
+// StrConv(string, conversion, LCID)
 RTLFUNC(StrConv)
 {
     (void)pBasic;
     (void)bWrite;
-    (void)rPar;
     
-	DBG_ASSERT(0,"StrConv:Not implemented");
-//	if ( rPar.Count() != 3 )
-//	{
+	ULONG nArgCount = rPar.Count()-1;
+	if( nArgCount < 2 || nArgCount > 3 )
+	{
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
-//		return;
-//	}
+		return;	
+	}
+
+	String aOldStr; 
+	INT32 nConversion = rPar.Get(2)->GetLong();
+	if( nConversion != 64 )
+	{
+		// The first parameter is String object, not byte array
+ 		aOldStr = rPar.Get(1)->GetString();
+	}
+	
+	USHORT nLanguage = LANGUAGE_SYSTEM;
+	if( nArgCount == 3 )
+	{
+		// LCID not supported now	
+		//nLanguage = rPar.Get(3)->GetInteger();
+	}
+
+	USHORT nOldLen = aOldStr.Len();
+	if( nOldLen == 0 )
+	{
+		// null string, need check the behavior in Excel	
+	}
+
+	INT32 nType = 0;
+	if ( (nConversion & 0x03) == 3 ) //  vbProperCase
+	{
+		CharClass& rCharClass = GetCharClass();
+		aOldStr = rCharClass.toTitle( aOldStr, 0, nOldLen );
+	}
+	else if ( (nConversion & 0x01) == 1 ) // vbUpperCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_LOWERCASE_UPPERCASE;
+	else if ( (nConversion & 0x02) == 2 ) // vbLowerCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_UPPERCASE_LOWERCASE;
+	
+	if ( (nConversion & 0x04) == 4 ) // vbWide
+		nType |= ::com::sun::star::i18n::TransliterationModules_HALFWIDTH_FULLWIDTH;
+	else if ( (nConversion & 0x08) == 8 ) // vbNarrow
+		nType |= ::com::sun::star::i18n::TransliterationModules_FULLWIDTH_HALFWIDTH;
+
+	if ( (nConversion & 0x10) == 16) // vbKatakana
+		nType |= ::com::sun::star::i18n::TransliterationModules_HIRAGANA_KATAKANA;
+	else if ( (nConversion & 0x20) == 32 ) // vbHiragana
+		nType |= ::com::sun::star::i18n::TransliterationModules_KATAKANA_HIRAGANA;
+
+	String aNewStr( aOldStr );
+	if( nType != 0 )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+    	::utl::TransliterationWrapper aTransliterationWrapper( xSMgr,nType );
+		com::sun::star::uno::Sequence<sal_Int32> aOffsets;
+		aTransliterationWrapper.loadModuleIfNeeded( nLanguage );
+		aNewStr = aTransliterationWrapper.transliterate( aOldStr, nLanguage, 0, nOldLen, &aOffsets );
+	}
+
+	if ( (nConversion & 0x40) == 64 ) // vbUnicode
+	{
+		SbxBase* pParObj = rPar.Get(1)->GetObject();
+		SbxDimArray* pArr = PTR_CAST(SbxDimArray,pParObj);
+		if( pArr )
+		{
+			INT32 nLower, nUpper;
+			if( !pArr->GetDim32( 1, nLower, nUpper ) )
+				StarBASIC::Error( SbERR_OUT_OF_RANGE );
+			else
+			{
+				UINT32 nCount = nUpper - nLower + 1;
+				sal_Char* pChar = new sal_Char[nCount+1];
+				for( INT32 i = nLower; i <= nUpper; i++)
+				{
+					INT32 index = i;
+					pChar[ i-nLower ] = pArr->Get32(&index)->GetByte();
+				}
+				pChar[nCount] = '\0';
+				OString aOStr( pChar );
+
+				// default text coding is incorrect in unix
+				OUString aOUStr = OStringToOUString(aOStr, osl_getThreadTextEncoding());
+				aNewStr = String(aOUStr);
+				rPar.Get(0)->PutString( aNewStr );
+			}
+		}
+		else
+			StarBASIC::Error( SbERR_MUST_HAVE_DIMS );
+	}
+	else if ( (nConversion & 0x80) == 128 ) // vbFromUnicode
+	{
+		OUString aOUStr1(aNewStr);
+		// default text coding is incorrect in unix
+		OString aOStr1 = OUStringToOString(aNewStr,osl_getThreadTextEncoding());
+		const sal_Char* pChar = aOStr1.getStr();
+		USHORT nArraySize = aOStr1.getLength();
+		SbxDimArray* pArray = new SbxDimArray(SbxBYTE);
+		bool bIncIndex = (IsIndexOne() && SbiRuntime::isVBAEnabled() );
+		if(nArraySize)
+		{
+			if( bIncIndex )
+				pArray->AddDim( 1, nArraySize );
+			else
+				pArray->AddDim( 0, nArraySize-1 );	
+		}
+		else
+		{
+			pArray->unoAddDim( 0, -1 );	
+		}
+
+		for( USHORT	i=0; i< nArraySize; i++)
+		{
+			SbxVariable* pNew = new SbxVariable( SbxBYTE );
+			pNew->PutByte(*pChar);
+			pChar++;
+			pNew->SetFlag( SBX_WRITE );
+			short index = i;
+			if( bIncIndex )
+				++index;
+			pArray->Put( pNew, &index );	
+		}
+
+		SbxVariableRef refVar = rPar.Get(0);
+		USHORT nFlags = refVar->GetFlags();
+		refVar->ResetFlag( SBX_FIXED );
+		refVar->PutObject( pArray );
+		refVar->SetFlags( nFlags );
+	    refVar->SetParameters( NULL );
+   		return;	   
+	}
+
+	rPar.Get(0)->PutString(aNewStr);
 }
 
+
 RTLFUNC(Beep)
 {
     (void)pBasic;
