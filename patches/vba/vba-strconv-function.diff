--- basic/source/runtime/stdobj.cxx.orig	2007-12-05 05:29:28.000000000 +0800
+++ basic/source/runtime/stdobj.cxx	2007-12-06 15:02:07.000000000 +0800
@@ -504,9 +504,10 @@ static Methods aMethods[] = {
   { "String1",      SbxSTRING, 0,NULL,0 },
   { "String2",      SbxSTRING, 0,NULL,0 },
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
-{ "StrConv",        SbxSTRING,   2 | _FUNCTION, RTLNAME(StrConv),0          },
+{ "StrConv",        SbxOBJECT,   3 | _FUNCTION, RTLNAME(StrConv),0          },
   { "String",       SbxSTRING, 0,NULL,0 },
   { "Conversion",   SbxSTRING, 0,NULL,0 },
+  { "LCID",			SbxINTEGER, _OPT,NULL,0 },
 { "String",         SbxSTRING,    2 | _FUNCTION, RTLNAME(String),0          },
   { "Count",        SbxLONG, 0,NULL,0 },
   { "Filler",       SbxVARIANT, 0,NULL,0 },
--- basic/source/runtime/rtlproto.hxx.orig	2007-12-04 15:19:05.000000000 +0800
+++ basic/source/runtime/rtlproto.hxx	2007-12-05 05:31:09.000000000 +0800
@@ -351,3 +351,4 @@ extern RTLFUNC(CDec);
 
 extern double Now_Impl();
 extern void Wait_Impl( bool bDurationBased, SbxArray& rPar );
+bool IsBaseIndexOne();
--- basic/source/runtime/methods.cxx.orig	2007-12-05 05:29:28.000000000 +0800
+++ basic/source/runtime/methods.cxx	2007-12-06 14:57:31.000000000 +0800
@@ -3946,21 +3946,135 @@ RTLFUNC(QBColor)
 	rPar.Get(0)->PutLong( nRGB );
 }
 
-
+// StrConv(string, conversion, LCID)
 RTLFUNC(StrConv)
 {
     (void)pBasic;
     (void)bWrite;
-    (void)rPar;
     
-	DBG_ASSERT(0,"StrConv:Not implemented");
-//	if ( rPar.Count() != 3 )
-//	{
+	ULONG nArgCount = rPar.Count()-1;
+	if( nArgCount < 2 || nArgCount > 3 )
+	{
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
-//		return;
-//	}
+		return;	
+	}
+
+	String aOldStr = rPar.Get(1)->GetString(); 
+	INT32 nConversion = rPar.Get(2)->GetLong();
+	
+	USHORT nLanguage = LANGUAGE_SYSTEM;
+	if( nArgCount == 3 )
+	{
+		// LCID not supported now	
+		//nLanguage = rPar.Get(3)->GetInteger();
+	}
+
+	USHORT nOldLen = aOldStr.Len();
+	if( nOldLen == 0 )
+	{
+		// null string,return 
+		rPar.Get(0)->PutString(aOldStr);
+		return;
+	}
+
+	INT32 nType = 0;
+	if ( (nConversion & 0x03) == 3 ) //  vbProperCase
+	{
+		CharClass& rCharClass = GetCharClass();
+		aOldStr = rCharClass.toTitle( aOldStr.ToLowerAscii(), 0, nOldLen );
+	}
+	else if ( (nConversion & 0x01) == 1 ) // vbUpperCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_LOWERCASE_UPPERCASE;
+	else if ( (nConversion & 0x02) == 2 ) // vbLowerCase
+		nType |= ::com::sun::star::i18n::TransliterationModules_UPPERCASE_LOWERCASE;
+	
+	if ( (nConversion & 0x04) == 4 ) // vbWide
+		nType |= ::com::sun::star::i18n::TransliterationModules_HALFWIDTH_FULLWIDTH;
+	else if ( (nConversion & 0x08) == 8 ) // vbNarrow
+		nType |= ::com::sun::star::i18n::TransliterationModules_FULLWIDTH_HALFWIDTH;
+
+	if ( (nConversion & 0x10) == 16) // vbKatakana
+		nType |= ::com::sun::star::i18n::TransliterationModules_HIRAGANA_KATAKANA;
+	else if ( (nConversion & 0x20) == 32 ) // vbHiragana
+		nType |= ::com::sun::star::i18n::TransliterationModules_KATAKANA_HIRAGANA;
+
+	String aNewStr( aOldStr );
+	if( nType != 0 )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+    	::utl::TransliterationWrapper aTransliterationWrapper( xSMgr,nType );
+		com::sun::star::uno::Sequence<sal_Int32> aOffsets;
+		aTransliterationWrapper.loadModuleIfNeeded( nLanguage );
+		aNewStr = aTransliterationWrapper.transliterate( aOldStr, nLanguage, 0, nOldLen, &aOffsets );
+	}
+
+	if ( (nConversion & 0x40) == 64 ) // vbUnicode
+	{
+		// convert the string to byte string, preserving unicode (2 bytes per character)
+		USHORT nSize = aNewStr.Len()*2;
+		const sal_Unicode* pSrc = aNewStr.GetBuffer();
+		sal_Char* pChar = new sal_Char[nSize+1];
+		for( USHORT i=0; i < nSize; i++ )
+		{
+			pChar[i] = i%2 ? ((*pSrc) >> 8) & 0xff : (*pSrc) & 0xff;
+			if( i%2 )
+				pSrc++;	
+		}
+		pChar[nSize] = '\0';
+		OString aOStr(pChar);	
+		
+		// there is no concept about default codepage in unix. so it is incorrectly in unix 
+		OUString aOUStr = OStringToOUString(aOStr, osl_getThreadTextEncoding());
+		aNewStr = String(aOUStr);
+		rPar.Get(0)->PutString( aNewStr );
+		return;
+	}
+	else if ( (nConversion & 0x80) == 128 ) // vbFromUnicode
+	{
+		OUString aOUStr(aNewStr);
+		// there is no concept about default codepage in unix. so it is incorrectly in unix 
+		OString aOStr = OUStringToOString(aNewStr,osl_getThreadTextEncoding());
+		const sal_Char* pChar = aOStr.getStr();
+		USHORT nArraySize = aOStr.getLength();
+		SbxDimArray* pArray = new SbxDimArray(SbxBYTE);
+		bool bIncIndex = (IsBaseIndexOne() && SbiRuntime::isVBAEnabled() );
+		if(nArraySize)
+		{
+			if( bIncIndex )
+				pArray->AddDim( 1, nArraySize );
+			else
+				pArray->AddDim( 0, nArraySize-1 );	
+		}
+		else
+		{
+			pArray->unoAddDim( 0, -1 );	
+		}
+
+		for( USHORT	i=0; i< nArraySize; i++)
+		{
+			SbxVariable* pNew = new SbxVariable( SbxBYTE );
+			pNew->PutByte(*pChar);
+			pChar++;
+			pNew->SetFlag( SBX_WRITE );
+			short index = i;
+			if( bIncIndex )
+				++index;
+			pArray->Put( pNew, &index );	
+		}
+
+		SbxVariableRef refVar = rPar.Get(0);
+		USHORT nFlags = refVar->GetFlags();
+		refVar->ResetFlag( SBX_FIXED );
+		refVar->PutObject( pArray );
+		refVar->SetFlags( nFlags );
+	    refVar->SetParameters( NULL );
+   		return;	   
+	}
+
+	rPar.Get(0)->PutString(aNewStr);
 }
 
+
 RTLFUNC(Beep)
 {
     (void)pBasic;
