diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
index 2aae16d..6b510ff 100644
--- sc/source/ui/vba/vbarange.cxx
+++ sc/source/ui/vba/vbarange.cxx
@@ -791,9 +791,10 @@ protected:
 		double aDblValue;
 		if ( aValue >>= sFormula )
 		{
-            // convert to CONV_OOO style formula string because XCell::setFormula
-            // always compile it in CONV_OOO style.  Perhaps css.sheet.FormulaParser
-            // should be used in future to directly pass formula tokens.
+            // convert to GRAM_PODF_A1 style grammar because XCell::setFormula
+            // always compile it in that grammar. Perhaps
+            // css.sheet.FormulaParser should be used in future to directly
+            // pass formula tokens when that API stabilizes.
             if ( m_eGrammar != ScGrammar::GRAM_PODF_A1 && ( sFormula.trim().indexOf('=') == 0 ) )	
 			{
 				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
@@ -1459,25 +1460,25 @@ void
 ScVbaRange::setFormula(const uno::Any &rFormula ) throw (uno::RuntimeException)
 {
 	// #FIXME converting "=$a$1" e.g. CONV_XL_A1 -> CONV_OOO                        	// results in "=$a$1:a1", temporalily disable conversion
-	setFormulaValue( rFormula, ScGrammar::GRAM_NATIVE_XL_A1 );;
+	setFormulaValue( rFormula, ScGrammar::GRAM_ENGLISH_XL_A1 );;
 }
 
 uno::Any
 ScVbaRange::getFormulaR1C1() throw (::com::sun::star::uno::RuntimeException)
 {
-	return getFormulaValue( ScGrammar::GRAM_NATIVE_XL_R1C1 );
+	return getFormulaValue( ScGrammar::GRAM_ENGLISH_XL_R1C1 );
 }
 
 void
 ScVbaRange::setFormulaR1C1(const uno::Any& rFormula ) throw (uno::RuntimeException)
 {
-	setFormulaValue( rFormula, ScGrammar::GRAM_NATIVE_XL_R1C1 );
+	setFormulaValue( rFormula, ScGrammar::GRAM_ENGLISH_XL_R1C1 );
 }
 
 uno::Any
 ScVbaRange::getFormula() throw (::com::sun::star::uno::RuntimeException)
 {
-	return getFormulaValue( ScGrammar::GRAM_NATIVE_XL_A1 );
+	return getFormulaValue( ScGrammar::GRAM_ENGLISH_XL_A1 );
 }
 
 sal_Int32 
