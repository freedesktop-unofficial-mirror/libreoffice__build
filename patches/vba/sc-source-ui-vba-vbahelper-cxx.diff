--- sc/source/ui/vba//vbahelper.cxx	
+++ sc/source/ui/vba//vbahelper.cxx
@@ -52,7 +52,9 @@
 
 #include <basic/sbx.hxx>
 #include <basic/sbstar.hxx>
+#include <rtl/math.hxx>
 
+#include <math.h>
 #include "vbahelper.hxx"
 #include "tabvwsh.hxx"
 #include "transobj.hxx"
@@ -71,6 +73,8 @@ namespace org
 namespace openoffice
 {
 
+const double Millimeter::factor =  35.27778;
+
 // helper method to determine if the view ( calc ) is in print-preview mode
 bool isInPrintPreview( SfxViewFrame* pView )
 {
@@ -512,16 +516,196 @@ void PrintOutHelper( const uno::Any& Fro
 	}
 	
 	// #FIXME #TODO
-	// 1 Preview ( does such a thing exist in OO.org? )
-	// 2 ActivePrinter ( how/can we switch a printer via API? )
-	// 3 PrintToFile ( ms behaviour if this option is specified but no 
+	// 1 ActivePrinter ( how/can we switch a printer via API? )
+	// 2 PrintToFile ( ms behaviour if this option is specified but no 
 	//   filename supplied 'PrToFileName' then the user will be prompted )
-	// 4 Need to check behaviour of Selected sheets with range ( e.g. From & To
+	// 3 Need to check behaviour of Selected sheets with range ( e.g. From & To
 	//    values ) in oOO these options are mutually exclusive
-	// 5 There is a pop up to do with transparent objects in the print source
+	// 4 There is a pop up to do with transparent objects in the print source
 	//   should be able to disable that via configuration for the duration
 	//   of this method
 }
 
+rtl::OUString getAnyAsString( const uno::Any& pvargItem ) throw ( uno::RuntimeException )
+{
+	uno::Type aType = pvargItem.getValueType();
+	uno::TypeClass eTypeClass = aType.getTypeClass();
+	rtl::OUString sString;
+	switch ( eTypeClass )
+	{
+		case uno::TypeClass_BOOLEAN:
+		{
+			sal_Bool bBool = sal_False;
+			pvargItem >>= bBool;
+			sString = rtl::OUString::valueOf( bBool );
+			break;
+		}
+		case uno::TypeClass_STRING:
+			pvargItem >>= sString;
+			break;
+		case uno::TypeClass_FLOAT:
+			float aFloat;
+			pvargItem >>= aFloat;
+			sString = rtl::OUString::valueOf( aFloat );
+			break;
+		case uno::TypeClass_DOUBLE:
+			double aDouble;
+			pvargItem >>= aDouble;
+			sString = rtl::OUString::valueOf( aDouble );
+			break;
+		case uno::TypeClass_SHORT:
+		case uno::TypeClass_LONG:
+		case uno::TypeClass_BYTE:
+			sal_Int32 aNum;
+			pvargItem >>= aNum;
+			sString = rtl::OUString::valueOf( aNum );
+			break;
+
+		case uno::TypeClass_HYPER:
+			sal_Int64 aHyper;
+			pvargItem >>= aHyper;
+			sString = rtl::OUString::valueOf( aHyper );
+			break;
+		default:
+       			throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid type, can't convert" ), uno::Reference< uno::XInterface >() );
+	}
+	return sString;
 }
+
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator)
+{
+	return getUniqueName(_slist, _sElementName, _sSuffixSeparator, sal_Int32(2));
+}
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix)
+{
+	sal_Int32 a = _nStartSuffix;
+	rtl::OUString scompname = _sElementName;
+	bool bElementexists = true;
+	sal_Int32 nLen = _slist.getLength();
+	if ( nLen == 0 )
+		return _sElementName;
+
+	while (bElementexists == true) 
+	{
+		for (sal_Int32 i = 0; i < nLen; i++)
+		{
+			if (FieldInList(_slist, scompname) == -1)
+			{
+				return scompname;
+			}
+		}
+		scompname = _sElementName + _sSuffixSeparator + rtl::OUString::valueOf( a++ );
+	}
+	return rtl::OUString();
 }
+
+sal_Int32 
+ContainerUtilities::FieldInList( const uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString )
+{
+	sal_Int32 FieldLen = SearchList.getLength();
+	sal_Int32 retvalue = -1;
+	for (sal_Int32 i = 0; i < FieldLen; i++) 
+	{
+		// I wonder why comparing lexicographically is done
+		// when its a match is whats interesting?
+		//if (SearchList[i].compareTo(SearchString) == 0) 
+		if ( SearchList[i].equals( SearchString ) ) 
+		{
+			retvalue = i;
+			break;
+		}
+	}
+	return retvalue;
+
+}
+
+bool NeedEsc(sal_Unicode cCode)
+{
+	String sEsc(RTL_CONSTASCII_USTRINGPARAM(".^$+\\|{}()"));
+	return (STRING_NOTFOUND != sEsc.Search(cCode));
+}
+
+rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike )
+{
+	rtl::OUStringBuffer sResult;
+	const sal_Unicode *start = rIn.getStr();
+	const sal_Unicode *end = start + rIn.getLength();
+
+	int seenright = 0;
+	if ( bForLike )
+		sResult.append(static_cast<sal_Unicode>('^'));
+
+	while (start < end) 
+	{
+		switch (*start)
+		{
+			case '?':
+				sResult.append(static_cast<sal_Unicode>('.'));
+				start++;
+				break;
+			case '*':
+				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(".*")));
+				start++;
+				break;
+			case '#':
+				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[0-9]")));
+				start++;
+				break;
+			case '~':
+				sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*(++start));
+				start++;
+				break;
+				// dump the ~ and escape the next characture
+			case ']':
+				sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*start++);
+				break;
+			case '[':
+				sResult.append(*start++);
+				seenright = 0;
+				while (start < end && !seenright)
+				{
+					switch (*start)
+					{
+						case '[':
+						case '?':
+						case '*':
+						sResult.append(static_cast<sal_Unicode>('\\'));
+						sResult.append(*start);
+							break;
+						case ']':
+						sResult.append(*start);
+							seenright = 1;
+							break;
+						case '!':
+							sResult.append(static_cast<sal_Unicode>('^'));
+							break;
+						default:
+						if (NeedEsc(*start))
+							sResult.append(static_cast<sal_Unicode>('\\'));
+						sResult.append(*start);
+							break;
+					}
+					start++;
+				}
+				break;
+			default:
+				if (NeedEsc(*start))
+					sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*start++);
+		}
+	}
+
+	if ( bForLike )
+		sResult.append(static_cast<sal_Unicode>('$'));
+
+	return sResult.makeStringAndClear( );
+}
+
+} // openoffice
+} //org
