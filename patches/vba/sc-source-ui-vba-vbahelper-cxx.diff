--- sc/source/ui/vba//vbahelper.cxx	
+++ sc/source/ui/vba//vbahelper.cxx
@@ -52,7 +52,9 @@
 
 #include <basic/sbx.hxx>
 #include <basic/sbstar.hxx>
+#include <rtl/math.hxx>
 
+#include <math.h>
 #include "vbahelper.hxx"
 #include "tabvwsh.hxx"
 #include "transobj.hxx"
@@ -71,6 +73,8 @@ namespace org
 namespace openoffice
 {
 
+const double Millimeter::factor =  35.27778;
+
 // helper method to determine if the view ( calc ) is in print-preview mode
 bool isInPrintPreview( SfxViewFrame* pView )
 {
@@ -512,16 +516,112 @@ void PrintOutHelper( const uno::Any& Fro
 	}
 	
 	// #FIXME #TODO
-	// 1 Preview ( does such a thing exist in OO.org? )
-	// 2 ActivePrinter ( how/can we switch a printer via API? )
-	// 3 PrintToFile ( ms behaviour if this option is specified but no 
+	// 1 ActivePrinter ( how/can we switch a printer via API? )
+	// 2 PrintToFile ( ms behaviour if this option is specified but no 
 	//   filename supplied 'PrToFileName' then the user will be prompted )
-	// 4 Need to check behaviour of Selected sheets with range ( e.g. From & To
+	// 3 Need to check behaviour of Selected sheets with range ( e.g. From & To
 	//    values ) in oOO these options are mutually exclusive
-	// 5 There is a pop up to do with transparent objects in the print source
+	// 4 There is a pop up to do with transparent objects in the print source
 	//   should be able to disable that via configuration for the duration
 	//   of this method
 }
 
+rtl::OUString getAnyAsString( const uno::Any& pvargItem ) throw ( uno::RuntimeException )
+{
+	uno::Type aType = pvargItem.getValueType();
+	uno::TypeClass eTypeClass = aType.getTypeClass();
+	rtl::OUString sString;
+	switch ( eTypeClass )
+	{
+		case uno::TypeClass_BOOLEAN:
+		{
+			sal_Bool bBool = sal_False;
+			pvargItem >>= bBool;
+			sString = rtl::OUString::valueOf( bBool );
+			break;
+		}
+		case uno::TypeClass_STRING:
+			pvargItem >>= sString;
+			break;
+		case uno::TypeClass_FLOAT:
+			float aFloat;
+			pvargItem >>= aFloat;
+			sString = rtl::OUString::valueOf( aFloat );
+			break;
+		case uno::TypeClass_DOUBLE:
+			double aDouble;
+			pvargItem >>= aDouble;
+			sString = rtl::OUString::valueOf( aDouble );
+			break;
+		case uno::TypeClass_SHORT:
+		case uno::TypeClass_LONG:
+		case uno::TypeClass_BYTE:
+			sal_Int32 aNum;
+			pvargItem >>= aNum;
+			sString = rtl::OUString::valueOf( aNum );
+			break;
+
+		case uno::TypeClass_HYPER:
+			sal_Int64 aHyper;
+			pvargItem >>= aHyper;
+			sString = rtl::OUString::valueOf( aHyper );
+			break;
+		default:
+       			throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid type, can't convert" ), uno::Reference< uno::XInterface >() );
+	}
+	return sString;
 }
+
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator)
+{
+	return getUniqueName(_slist, _sElementName, _sSuffixSeparator, sal_Int32(2));
+}
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix)
+{
+	sal_Int32 a = _nStartSuffix;
+	rtl::OUString scompname = _sElementName;
+	bool bElementexists = true;
+	sal_Int32 nLen = _slist.getLength();
+	if ( nLen == 0 )
+		return _sElementName;
+
+	while (bElementexists == true) 
+	{
+		for (sal_Int32 i = 0; i < nLen; i++)
+		{
+			if (FieldInList(_slist, scompname) == -1)
+			{
+				return scompname;
+			}
+		}
+		scompname = _sElementName + _sSuffixSeparator + rtl::OUString::valueOf( a++ );
+	}
+	return rtl::OUString();
 }
+
+sal_Int32 
+ContainerUtilities::FieldInList( const uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString )
+{
+	sal_Int32 FieldLen = SearchList.getLength();
+	sal_Int32 retvalue = -1;
+	for (sal_Int32 i = 0; i < FieldLen; i++) 
+	{
+		// I wonder why comparing lexicographically is done
+		// when its a match is whats interesting?
+		//if (SearchList[i].compareTo(SearchString) == 0) 
+		if ( SearchList[i].equals( SearchString ) ) 
+		{
+			retvalue = i;
+			break;
+		}
+	}
+	return retvalue;
+
+}
+
+} // openoffice
+} //org
