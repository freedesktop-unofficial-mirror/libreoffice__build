diff --git basic/inc/basic/sbmod.hxx basic/inc/basic/sbmod.hxx
index ab496bc..3da76ae 100644
--- basic/inc/basic/sbmod.hxx
+++ basic/inc/basic/sbmod.hxx
@@ -38,6 +38,7 @@
 #include <rtl/ustring.hxx>
 #endif
 #include <com/sun/star/script/ModuleType.hpp>
+#include <vector>
 class SbMethod;
 class SbProperty;
 class SbiRuntime;
@@ -59,6 +60,7 @@ class SbModule : public SbxObject
 	friend class	SbClassModuleObject;
 
 	SbModuleImpl*	mpSbModuleImpl;		// Impl data
+	std::vector< String > mModuleVariableNames;
 	SbModule();
 	SbModule(const SbModule&);
 
@@ -138,6 +140,8 @@ public:
         INT32 GetModuleType() { return mnType; }
         void SetModuleType( INT32 nType ) { mnType = nType; }
 	bool GetIsProxyModule() { return bIsProxyModule; }
+        void AddVarName( const String& aName ) { mModuleVariableNames.push_back( aName ); }
+        void RemoveVars();
 };
 
 #ifndef __SB_SBMODULEREF_HXX
diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index cf5b5a5..71e2cb6 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -822,6 +822,17 @@ void SbModule::RunInit()
 }
 
 // Mit private/dim deklarierte Variablen loeschen
+void SbModule::RemoveVars()
+{
+    std::vector< String >::iterator it_end = mModuleVariableNames.end();
+    for ( std::vector< String >::iterator it = mModuleVariableNames.begin(); it != it_end; ++it )
+    {
+	SbxVariableRef p = Find( *it, SbxCLASS_PROPERTY );
+	if( p.Is() )
+		Remove (p);
+    }
+
+}
 void SbModule::ClearPrivateVars()
 {
 	for( USHORT i = 0 ; i < pProps->Count() ; i++ )
@@ -871,6 +882,7 @@ void StarBASIC::ClearAllModuleVars( void )
 	{
 		SbModule* pModule = (SbModule*)pModules->Get( nMod );
 		// Nur initialisieren, wenn der Startcode schon ausgefuehrt wurde
+		pModule->RemoveVars();
 		if( pModule->pImage && pModule->pImage->bInit )
 			pModule->ClearPrivateVars();
 	}
diff --git basic/source/runtime/step2.cxx basic/source/runtime/step2.cxx
index 17da5f0..644ecdb 100644
--- basic/source/runtime/step2.cxx
+++ basic/source/runtime/step2.cxx
@@ -121,18 +121,12 @@ SbxVariable* SbiRuntime::FindElement
 			{
 				if( pElem->IsSet( SBX_PRIVATE ) )
 				{
-					if( pObj != pElem->GetParent() )
+					SbiInstance* pInst_ = pINST;
+					if( pInst_ && pInst_->IsCompatibility() && pObj != pElem->GetParent() )
 						pElem = NULL;	// Found but in wrong module!
 
 					// Interfaces: Use SBX_EXTFOUND
 				}
-                // Find if it is a global public variable
-                if( !pElem )
-                {
-                    pElem  = rBasic.FindGlobalVar( aName, SbxCLASS_DONTCARE );
-                    if( pElem && pElem->IsSet( SBX_PRIVATE ) )
-                        pElem = NULL;
-                }
 			}
 			rBasic.bNoRtl = bSave;
 
@@ -1137,16 +1131,26 @@ void SbiRuntime::StepGLOBAL( UINT32 nOp1, UINT32 nOp2 )
 	if( pImg->GetFlag( SBIMG_CLASSMODULE ) )
 		StepPUBLIC_Impl( nOp1, nOp2, true );
 
+        SbxObject* pStorage = &rBasic;
 	String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+	// Store module scope variables at module scope ( what about global )
+	// in mso global is about visibility not scope, scope is always
+	// determined by the placement of the variables
+	if ( SbiRuntime::isVBAEnabled() ) 
+        {
+            pStorage = pMod;
+            pMod->AddVarName( aName );
+        }
+
 	SbxDataType t = (SbxDataType) nOp2;
-	BOOL bFlag = rBasic.IsSet( SBX_NO_MODIFY );
+	BOOL bFlag = pStorage->IsSet( SBX_NO_MODIFY );
 	rBasic.SetFlag( SBX_NO_MODIFY );
-	SbxVariableRef p = rBasic.Find( aName, SbxCLASS_PROPERTY );
+	SbxVariableRef p = pStorage->Find( aName, SbxCLASS_PROPERTY );
 	if( p.Is() )
-		rBasic.Remove (p);
-	p = rBasic.Make( aName, SbxCLASS_PROPERTY, t );
+		pStorage->Remove (p);
+	p = pStorage->Make( aName, SbxCLASS_PROPERTY, t );
 	if( !bFlag )
-		rBasic.ResetFlag( SBX_NO_MODIFY );
+		pStorage->ResetFlag( SBX_NO_MODIFY );
 	if( p )
 	{
 		p->SetFlag( SBX_DONTSTORE );
