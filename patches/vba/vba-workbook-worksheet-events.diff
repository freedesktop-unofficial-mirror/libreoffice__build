--- offapi/com/sun/star/document/VbaEventId.idl.old	1970-01-01 00:00:00.000000000 +0000
+++ offapi/com/sun/star/document/VbaEventId.idl	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventId_idl__
+#define __org_openoffice_vba_VbaEventId_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+/* VBA compatibility event id */
+constants VbaEventId
+{
+    // Worksheet
+    const long VBAEVENT_WORKSHEET_ACTIVATE                  	= 1;
+    const long VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK         	= 2;
+    const long VBAEVENT_WORKSHEET_BEFORERIGHTCLICK          	= 3;
+    const long VBAEVENT_WORKSHEET_CALCULATE                 	= 4;
+    const long VBAEVENT_WORKSHEET_CHANGE                    	= 5;
+    const long VBAEVENT_WORKSHEET_DEACTIVATE                	= 6;
+    const long VBAEVENT_WORKSHEET_FOLLOWHYPERLINK           	= 7;
+    const long VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE          	= 8;
+    const long VBAEVENT_WORKSHEET_SELECTIONCHANGE           	= 9;
+    // Workbook
+    const long VBAEVENT_WORKBOOK_ACTIVATE            			= 20;
+    const long VBAEVENT_WORKBOOK_DEACTIVATE          			= 21;
+    const long VBAEVENT_WORKBOOK_OPEN                			= 22;
+    const long VBAEVENT_WORKBOOK_AUTOOPEN            			= 23;
+    const long VBAEVENT_WORKBOOK_BEFORECLOSE         			= 24;
+    const long VBAEVENT_WORKBOOK_BEFOREPRINT         			= 25;
+    const long VBAEVENT_WORKBOOK_BEFORESAVE          			= 26;
+    const long VBAEVENT_WORKBOOK_NEWSHEET            			= 27;
+    const long VBAEVENT_WORKBOOK_WINDOWACTIVATE      			= 28;
+    const long VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    			= 29;
+    const long VBAEVENT_WORKBOOK_WINDOWRESIZE        			= 30;
+    // Workbook_sheet
+    const long VBAEVENT_WORKBOOK_SHEET_ACTIVATE               	= 51;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK      	= 52;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK       	= 53;
+    const long VBAEVENT_WORKBOOK_SHEET_CALCULATE              	= 54;
+    const long VBAEVENT_WORKBOOK_SHEET_CHANGE                 	= 55;
+    const long VBAEVENT_WORKBOOK_SHEET_DEACTIVATE             	= 56;
+    const long VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK        	= 57;
+    const long VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE       	= 58;
+    const long VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE        	= 59;
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XVbaEventsHelper.idl.old	1970-01-01 00:00:00.000000000 +0000
+++ offapi/com/sun/star/document/XVbaEventsHelper.idl	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_XVbaEventsHelper_idl__
+#define __org_openoffice_vba_XVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {  module sun {  module star {  module document {
+//=============================================================================
+
+interface XVbaEventsHelper
+{
+    /**
+        Execute VBA compatible event.
+        VbaEvent: Compatible VBA event id.
+        aArgs: the array of input arguments.
+        return: True if execute successfully, or False.
+    **/
+    boolean ProcessCompatibleVbaEvent( [in] long nEventId, [in] sequence< any > aArgs );
+    [attribute ] boolean IgnoreEvents;
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/VbaEventsHelper.idl.old	1970-01-01 00:00:00.000000000 +0000
+++ offapi/com/sun/star/document/VbaEventsHelper.idl	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventsHelper_idl__
+#define __org_openoffice_vba_VbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#include <com/sun/star/frame/XModel.idl>
+#include <com/sun/star/document/XVbaEventsHelper.idl>
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+service VbaEventsHelper : XVbaEventsHelper
+{
+  	createVbaEventsHelper(  [in] ::com::sun::star::frame::XModel xModel );
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl.old	1970-01-01 00:00:00.000000000 +0000
+++ offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaEventHelper.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+#define __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+
+//=============================================================================
+interface XDocumentEventCompatibleHelper
+{
+    /* Execute some compatible VBA event related to document, such as document save, document print.
+       nEventId: event id.
+    */
+    boolean processCompatibleEvent( [in] short nEventId );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/makefile.mk.old	2009-04-06 16:41:59.000000000 +0000
+++ offapi/com/sun/star/document/makefile.mk	2009-04-06 16:42:00.000000000 +0000
@@ -117,6 +117,10 @@ IDLFILES=\
     DocumentRevisionListPersistence.idl \
     XDocumentLanguages.idl \
     XCodeNameQuery.idl \
+    XDocumentEventCompatibleHelper.idl \
+    VbaEventId.idl \
+    XVbaEventsHelper.idl \
+    VbaEventsHelper.idl \
 
 
 # ------------------------------------------------------------------
--- sc/source/ui/vba/vbaeventshelper.hxx.old	1970-01-01 00:00:00.000000000 +0000
+++ sc/source/ui/vba/vbaeventshelper.hxx	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_VBAEVENTS_HXX
+#define SC_VBAEVENTS_HXX
+
+#include "document.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include "vbahelper.hxx"
+
+#define INVALID_TAB -1
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::document::XVbaEventsHelper > VBAWorkbookEvent_BASE;
+
+class VbaEventsListener;
+class ScVbaEventsHelper : public VBAWorkbookEvent_BASE
+{
+private:
+    ScDocument* pDoc;
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    VbaEventsListener* mpVbaEventsListener;
+    sal_Bool mbOpened;
+    sal_Bool mbIgnoreEvents;
+
+    String getSheetModuleName( SCTAB nTab );
+    String workbookMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro );
+    css::uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+    css::uno::Any createRange( const css::uno::Any& aRange );
+    css::uno::Any createHyperlink( const css::uno::Any& rCell );
+    css::uno::Any createWindow( SfxObjectShell* pShell );
+    sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, css::uno::Sequence< css::uno::Any >& aArgs, css::uno::Any& aRet );
+    SCTAB getTabFromArgs( const css::uno::Sequence< css::uno::Any > aArgs, const sal_Int32 nPos = 0 );
+    rtl::OUString getEventName( const sal_Int32 nEventId );
+    rtl::OUString getMacroPath( const sal_Int32 nEventId, const SCTAB nTab = INVALID_TAB );
+    sal_Bool processVbaEvent( const sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& rArgs, const SCTAB nTab = INVALID_TAB );
+
+public:
+    ScVbaEventsHelper( ScDocument* pDocument ):pDoc( pDocument ), mpVbaEventsListener( NULL ), mbOpened( sal_False ){};
+    ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~ScVbaEventsHelper();
+    ScDocument* getDocument() { return pDoc; };
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+};
+
+#endif
+
--- sc/source/ui/vba/vbaeventshelper.cxx.old	1970-01-01 00:00:00.000000000 +0000
+++ sc/source/ui/vba/vbaeventshelper.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -0,0 +1,1066 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include "helperdecl.hxx"
+#include <sfx2/objsh.hxx> 
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbx.hxx>
+#include "scextopt.hxx"
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/table/XCell.hpp> 
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/util/XCloseListener.hpp>
+#include <com/sun/star/util/XCloseBroadcaster.hpp>
+#include <com/sun/star/frame/XControllerBorder.hpp>
+#include <com/sun/star/frame/XBorderResizeListener.hpp>
+#include "cellsuno.hxx" 
+
+#include <map>
+
+using namespace std;
+using namespace com::sun::star;
+using namespace ooo::vba;
+using namespace com::sun::star::document::VbaEventId;
+
+const static String sLibrary( RTL_CONSTASCII_USTRINGPARAM("Standard"));
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
+const static rtl::OUString sUrlPart2 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+
+typedef ::cppu::WeakImplHelper3< awt::XWindowListener, util::XCloseListener, frame::XBorderResizeListener > WindowListener_BASE;
+
+// This class is to process Workbook window related event
+class VbaEventsListener : public WindowListener_BASE
+{
+    ScVbaEventsHelper* pVbaEventsHelper;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bPrepare;
+    sal_Bool m_bWindowResized;
+    sal_Bool m_bBorderChanged;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    uno::Reference< frame::XFrame > GetFrame();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, Timer* );
+    void processWindowResizeMacro();
+public :
+    VbaEventsListener( ScVbaEventsHelper* pHelper );
+    void startEventsLinstener();
+    void stopEventsLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XCloseListener
+    virtual void SAL_CALL queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException);
+    virtual void SAL_CALL notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException);
+    // XBorderResizeListener
+    virtual void SAL_CALL borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException);
+};
+VbaEventsListener::VbaEventsListener( ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper )
+{
+    m_xModel.set( pVbaEventsHelper->getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    m_bPrepare = sal_False;
+    m_bWindowResized = sal_False;
+    m_bBorderChanged = sal_False;
+}
+uno::Reference< frame::XFrame > 
+VbaEventsListener::GetFrame()
+{
+    try
+    {
+        if( pVbaEventsHelper )
+        {
+            if( m_xModel.is() )
+            {
+                uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+                if( xController.is() )
+                {
+                    uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY );
+                    if( xFrame.is() )
+                    {
+                            return xFrame;
+                    }
+                }
+            }
+        }
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< frame::XFrame >();
+}
+uno::Reference< awt::XWindow > 
+VbaEventsListener::GetContainerWindow() 
+{
+    try
+    {
+        uno::Reference< frame::XFrame > xFrame( GetFrame(), uno::UNO_QUERY );
+        if( xFrame.is() )
+        {
+            uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY );
+            if( xWindow.is() )
+                return xWindow;
+        }
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaEventsListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaEventsListener::startEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        // add window listener
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+            xWindow->addWindowListener( this );
+        // add close listener
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->addCloseListener( this );
+        }
+        // add Border resize listener
+        uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+        if( xController.is() )
+        {
+            uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+            if( xControllerBorder.is() )
+            {
+                xControllerBorder->addBorderResizeListener( this );
+            }
+        }
+    }
+}
+void
+VbaEventsListener::stopEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+        {
+            xWindow->removeWindowListener( this );
+        }
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->removeCloseListener( this );
+        }
+        uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+        if( xController.is() )
+        {
+            uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+            if( xControllerBorder.is() )
+            {
+                xControllerBorder->removeBorderResizeListener( this );
+            }
+        }
+        pVbaEventsHelper = NULL;
+    }
+}
+void
+VbaEventsListener::processWindowResizeMacro()
+{
+    if( pVbaEventsHelper )
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWRESIZE, uno::Sequence< uno::Any >() );
+}
+IMPL_LINK( VbaEventsListener, fireResizeMacro, Timer*, pTimer )
+{
+    if( pVbaEventsHelper && m_bPrepare && pTimer )
+    {
+        if( IsMouseReleased() )
+        {
+            pTimer->Stop();
+            delete pTimer;
+            pTimer = 0;
+            m_bPrepare = sal_False;
+            processWindowResizeMacro();
+        }
+    }
+    return 0;
+}
+void SAL_CALL
+VbaEventsListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // Workbook_window_resize event
+    OSL_TRACE("VbaEventsListener::windowResized");
+    m_bWindowResized = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && !m_bPrepare && m_bBorderChanged )
+    {
+        m_bPrepare = sal_True;
+        m_bBorderChanged = m_bWindowResized = sal_False;
+        AutoTimer* pTimer = new AutoTimer();
+        pTimer->SetTimeoutHdl( LINK( this, VbaEventsListener, fireResizeMacro ) );
+        pTimer->Start();
+    }
+}
+void SAL_CALL
+VbaEventsListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    pVbaEventsHelper = NULL;
+}
+void SAL_CALL 
+VbaEventsListener::queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException)
+{
+     // it can cancel the close, but need to throw a CloseVetoException, and it will be transmit to caller.
+}
+void SAL_CALL 
+VbaEventsListener::notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+    OSL_TRACE("VbaEventsListener::notifyClosing");
+    stopEventsLinstener();
+}
+void SAL_CALL 
+VbaEventsListener::borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException)
+{
+    // work with WindowResized event to guard Window Resize event.
+    OSL_TRACE("VbaEventsListener::borderWidthsChanged");
+    m_bBorderChanged = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && !m_bPrepare && m_bWindowResized )
+    {
+        m_bPrepare = sal_True;
+        m_bWindowResized = m_bBorderChanged = sal_False;
+        AutoTimer* pTimer = new AutoTimer();
+        pTimer->SetTimeoutHdl( LINK( this, VbaEventsListener, fireResizeMacro ) );
+        pTimer->Start();
+    }
+}
+
+class ImplVbaEventNameInfo
+{
+private:
+    map< sal_Int32, rtl::OUString > m_aEventNameMap;
+
+protected:
+    static ImplVbaEventNameInfo* pImplVbaEventNameInfo;
+    ImplVbaEventNameInfo() { InitImplVbaEventNameInfo(); }
+private:
+    void insert( const sal_Int32 nId, const rtl::OUString sEventName )
+    {
+        m_aEventNameMap.insert( make_pair( nId, sEventName ) );
+    }
+    void InitImplVbaEventNameInfo();
+public:
+    virtual ~ImplVbaEventNameInfo();
+    rtl::OUString getEventName( const sal_Int32 nId )
+    {
+        map< sal_Int32, rtl::OUString >::iterator iter = m_aEventNameMap.find( nId );
+        if( iter != m_aEventNameMap.end() )
+            return iter->second;
+        return rtl::OUString();
+    }
+    static ImplVbaEventNameInfo* GetImplVbaEventNameInfo();
+};
+ImplVbaEventNameInfo* ImplVbaEventNameInfo::pImplVbaEventNameInfo = NULL;
+
+ImplVbaEventNameInfo::~ImplVbaEventNameInfo()
+{
+    if( pImplVbaEventNameInfo )
+    {
+        delete pImplVbaEventNameInfo;
+        pImplVbaEventNameInfo = NULL;
+    }
+}
+
+ImplVbaEventNameInfo* 
+ImplVbaEventNameInfo::GetImplVbaEventNameInfo()
+{
+    if( !pImplVbaEventNameInfo )
+    {
+        pImplVbaEventNameInfo = new ImplVbaEventNameInfo;
+    }
+    return pImplVbaEventNameInfo;
+}
+
+#define CREATEOUSTRING(asciistr) rtl::OUString::createFromAscii(asciistr)
+
+#define INSERT_EVENT_INFO( Object, Event, ObjectName, EventName ) \
+        insert( VBAEVENT_##Object##_##Event, ObjectName + CREATEOUSTRING( EventName ) )
+
+#define INSERT_WORKSHEET_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO( WORKSHEET, Event,CREATEOUSTRING("Worksheet_"), EventName ); \
+        INSERT_EVENT_INFO( WORKBOOK_SHEET, Event, CREATEOUSTRING("Workbook_Sheet"), EventName )
+
+#define INSERT_WORKBOOK_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO(  WORKBOOK, Event, CREATEOUSTRING("Workbook_"), EventName )
+
+void ImplVbaEventNameInfo::InitImplVbaEventNameInfo()
+{
+    INSERT_WORKSHEET_EVENT_INFO( ACTIVATE, "Activate");
+    INSERT_WORKSHEET_EVENT_INFO( BEFOREDOUBLECLICK, "BeforeDoubleClick" );
+    INSERT_WORKSHEET_EVENT_INFO( BEFORERIGHTCLICK, "BeforeRightClick" );
+    INSERT_WORKSHEET_EVENT_INFO( CALCULATE, "Calculate" );
+    INSERT_WORKSHEET_EVENT_INFO( CHANGE, "Change" );
+    INSERT_WORKSHEET_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKSHEET_EVENT_INFO( FOLLOWHYPERLINK, "FollowHyperlink" );
+    INSERT_WORKSHEET_EVENT_INFO( PIVOTTABLEUPDATE, "PivotTableUpdate" );
+    INSERT_WORKSHEET_EVENT_INFO( SELECTIONCHANGE, "SelectionChange" );
+
+    // Workbook
+    INSERT_WORKBOOK_EVENT_INFO( ACTIVATE, "Activate" );
+    INSERT_WORKBOOK_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( OPEN, "Open" );
+    // AUTOOPEN doesn't be used. TODO, this should be "auto_open"
+    INSERT_WORKBOOK_EVENT_INFO( BEFORECLOSE, "BeforeClose" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFOREPRINT, "BeforePrint" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFORESAVE, "BeforeSave" );
+    INSERT_WORKBOOK_EVENT_INFO( NEWSHEET, "NewSheet" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWACTIVATE, "WindowActivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWDEACTIVATE, "WindowDeactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWRESIZE, "WindowResize" );
+}
+
+ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext )
+    : m_xContext( xContext ), mpVbaEventsListener( NULL ), mbOpened( sal_False ), mbIgnoreEvents( sal_False )
+{
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    ScDocShell* pDocShell = getDocShell( xModel );
+    pDoc = pDocShell->GetDocument();
+}
+
+ScVbaEventsHelper::~ScVbaEventsHelper()
+{
+    if( mpVbaEventsListener )
+    {
+        mpVbaEventsListener = NULL;
+    }
+}
+
+rtl::OUString
+ScVbaEventsHelper::getEventName( const sal_Int32 nId )
+{
+    rtl::OUString sEventName;
+    ImplVbaEventNameInfo* pEventInfo = ImplVbaEventNameInfo::GetImplVbaEventNameInfo();
+    if( pEventInfo )
+        sEventName = pEventInfo->getEventName( nId );
+    return sEventName;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+sal_Bool ScVbaEventsHelper::executeMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet )
+{
+    // until ObjectModules ( and persisting of codenames ) is supported, if this is a
+    // document saved from XL then we won't be able to determine the codename for the Workbook
+    // Module, so... we have no choice but to search all modules for the moment, thus the macro
+    // passed in should be the fully specified name. 	
+    rtl::OUString sUrl = sUrlPart0.concat( sMacroName ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sUrlPart2 ) ;
+    uno::Sequence< sal_Int16 > aOutArgsIndex;
+    uno::Sequence< uno::Any > aOutArgs;
+    ErrCode nErr = pShell->CallXScript( sUrl,  aArgs, aRet,
+            aOutArgsIndex, aOutArgs, sal_False );
+
+    // Script Executed?
+    if ( nErr != ERRCODE_NONE )
+        return sal_False;
+
+    sal_Int32 nLen = aOutArgs.getLength();
+    // convert any out params to seem like they were inouts
+    if ( nLen )
+    {
+        for ( sal_Int32 index=0; index < nLen; ++index )
+        {
+            sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+            aArgs[ nOutIndex ] = aOutArgs[ index ];
+        }
+
+    }
+    return sal_True;
+}
+String ScVbaEventsHelper::workbookMacroExists( SfxObjectShell* pShell, const String& sMod, const String& sMacro )
+{
+    String sFullName;	
+    // would use the script provider to see if the macro exists but
+    // called at this stage tdoc content handler stuff is not set up
+    // so it fails
+
+    BasicManager* pBasicMgr = pShell-> GetBasicManager();
+    if ( pBasicMgr )
+    {
+        StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+        if ( !pBasic )
+        {
+            USHORT nId = pBasicMgr->GetLibId( sLibrary );
+            pBasicMgr->LoadLib( nId );
+            pBasic = pBasicMgr->GetLib( sLibrary );
+        }
+        if ( pBasic )
+        {
+            if ( sMod.Len() ) // we wish to find the macro is a specific module
+            {
+                SbModule* pModule = pBasic->FindModule( sMod );
+                if ( pModule )
+                {
+                    SbxArray* pMethods = pModule->GetMethods();
+                    if ( pMethods )
+                    {
+                        SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+                        if ( pMethod )
+                        {
+                            sFullName = sMacro;
+                            sFullName.Insert( '.', 0 ).Insert( sMod, 0 ).Insert( '.', 0 ).Insert( sLibrary, 0 );
+                        }
+                    }
+                }
+            }
+            else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+            {
+                    if( SbModule* pModule = pMethod->GetModule() )
+                    {
+                        sFullName = sMacro;
+                        sFullName.Insert( '.', 0 ).Insert( pModule->GetName(), 0).Insert( '.', 0 ).Insert( sLibrary, 0 );
+                    }
+            }		
+                
+        }
+    }
+    return sFullName;
+}
+
+uno::Any ScVbaEventsHelper::createWorkSheet( SfxObjectShell* pShell, SCTAB nTab )
+{
+    uno::Any aRet;
+    try
+    {
+        uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+        uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+        // Eventually we will be able to pull the Workbook/Worksheet objects
+        // directly from basic and register them as listeners
+
+        // create Workbook
+        uno::Sequence< uno::Any > aArgs(2);
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( pShell->GetModel() );
+        uno::Reference< uno::XInterface > xWorkbook( xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Workbook") ), aArgs, xCtx ), uno::UNO_QUERY );
+
+        // create WorkSheet
+        String sSheetName;
+        pDoc->GetName( nTab, sSheetName );
+        aArgs = uno::Sequence< uno::Any >(3);
+        aArgs[ 0 ] <<= xWorkbook;
+        aArgs[ 1 ] <<= pShell->GetModel();
+        aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+        aRet <<= xSMgr->createInstanceWithArgumentsAndContext(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Worksheet") ), aArgs, xCtx );
+    }
+    catch( uno::Exception& e )
+    {
+    }
+    return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createRange( const uno::Any& aRange )
+{
+    uno::Any aRet;
+    try
+    {
+        uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+        uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+        uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+        if (  xRanges.is() || xRange.is() )
+        {
+            uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+            uno::Sequence< uno::Any > aArgs(2);
+            aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+            if ( xRanges.is() )
+            {
+                aArgs[1] <<= xRanges;
+            }
+            else if ( xRange.is() )
+            {
+                aArgs[1] <<= xRange;
+            }
+            else
+            {
+                throw uno::RuntimeException(); // 
+            }
+            aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Range") ), aArgs, xCtx  );	
+        }
+    }
+    catch( uno::Exception& e ) 
+    {
+    }
+    return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createHyperlink( const uno::Any& rCell )
+{
+    uno::Any aRet;
+    try
+    {
+        uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW ); 
+        uno::Reference< table::XCell > xCell( rCell, uno::UNO_QUERY );
+        if( xCell.is() )
+        {
+            uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+            uno::Sequence< uno::Any > aArgs(2);
+            aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+            aArgs[1] <<= rCell;
+            
+            aRet <<= xSMgr->createInstanceWithArgumentsAndContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Hyperlink") ), aArgs, xCtx  );	
+        }
+        else
+        {
+            throw uno::RuntimeException(); // 
+        }
+    }
+    catch( uno::Exception& e ) 
+    {
+    }
+    return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createWindow( SfxObjectShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+    catch( uno::Exception& e )
+    {
+    }
+    return uno::Any();
+}
+
+String ScVbaEventsHelper::getSheetModuleName( SCTAB nTab )
+{
+    ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+    String aCodeName;
+    pDoc->GetName( nTab, aCodeName);
+    // Use code name if that exists
+    if ( pExtOptions )
+        aCodeName = pExtOptions->GetCodeName( nTab );
+    return aCodeName;	
+}
+
+rtl::OUString
+ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
+{
+    SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    rtl::OUString sMacroPath;
+    rtl::OUString sMacroName = getEventName( nEventId );
+    switch( nEventId )
+    {
+        // Worksheet
+        case VBAEVENT_WORKSHEET_ACTIVATE                      :
+        case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK             :
+        case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK              :
+        case VBAEVENT_WORKSHEET_CALCULATE                     :
+        case VBAEVENT_WORKSHEET_CHANGE                        :
+        case VBAEVENT_WORKSHEET_DEACTIVATE                    :
+        case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK               :
+        case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE              :
+        case VBAEVENT_WORKSHEET_SELECTIONCHANGE               :
+        {
+            rtl::OUString  aSheetModuleName = getSheetModuleName( nTab );
+            sMacroPath = workbookMacroExists( pShell, aSheetModuleName, sMacroName );
+            break;
+        }
+        // Workbook
+        case VBAEVENT_WORKBOOK_ACTIVATE                       :
+        case VBAEVENT_WORKBOOK_DEACTIVATE                     :
+        case VBAEVENT_WORKBOOK_OPEN                           :
+        case VBAEVENT_WORKBOOK_AUTOOPEN                       :
+        case VBAEVENT_WORKBOOK_BEFORECLOSE                    :
+        case VBAEVENT_WORKBOOK_BEFOREPRINT                    :
+        case VBAEVENT_WORKBOOK_BEFORESAVE                     :
+        case VBAEVENT_WORKBOOK_NEWSHEET                       :
+        case VBAEVENT_WORKBOOK_WINDOWACTIVATE                 :
+        case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE               :
+        case VBAEVENT_WORKBOOK_WINDOWRESIZE                   :
+        // Workbook_sheet
+        case VBAEVENT_WORKBOOK_SHEET_ACTIVATE                 :
+        case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK        :
+        case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK         :
+        case VBAEVENT_WORKBOOK_SHEET_CALCULATE                :
+        case VBAEVENT_WORKBOOK_SHEET_CHANGE                   :
+        case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE               :
+        case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK          :
+        case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE         :
+        case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE          :
+        {
+            ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+            String sWorkbookModuleName = pDoc->GetCodeName();
+            if( pExtOptions )
+            {
+                ScExtDocSettings aExtDocSettings = pExtOptions->GetDocSettings();
+                sWorkbookModuleName = aExtDocSettings.maGlobCodeName;
+            }
+           
+            sMacroPath = workbookMacroExists( pShell, sWorkbookModuleName, sMacroName );
+            break;
+        }
+        default:
+            break;
+    }
+    return sMacroPath;
+}
+
+sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& rArgs, const SCTAB nTab )
+{
+    SfxObjectShell* pShell = pDoc->GetDocumentShell();
+
+    sal_Bool result = sal_False;
+    sal_Bool bCancel = sal_False;
+    uno::Sequence< uno::Any > aArgs;
+    uno::Any aRet;
+    
+    // For most cases, there is no corresponsible event macro in the document. 
+    // It is better fo check if the event macro exists before process the arguments to improve performance.
+    rtl::OUString sMacroPath = getMacroPath( nEventId, nTab );
+    if( sMacroPath.getLength() )
+    {
+        switch( nEventId )
+        {
+            case VBAEVENT_WORKSHEET_ACTIVATE:
+            case VBAEVENT_WORKSHEET_CALCULATE:
+            case VBAEVENT_WORKSHEET_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_ACTIVATE:
+            case VBAEVENT_WORKBOOK_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_OPEN:
+            {
+                // no arguments
+                break;
+            }
+            case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+            case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+            case VBAEVENT_WORKBOOK_NEWSHEET:
+            {
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = createWorkSheet( pShell, nTab ); 
+                break;
+            }
+            case VBAEVENT_WORKSHEET_CHANGE:
+            case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+            {
+                // one argument: range
+                uno::Any aRange = createRange( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = aRange;
+                break;
+            }
+            case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+            case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+            {
+                uno::Any aRange = createRange( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = createWorkSheet( pShell, nTab );
+                aArgs[1] = aRange;
+                break;
+            }
+            case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+            case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+            {
+                // two aruments: range and cancel
+                uno::Any aRange = createRange( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = aRange;
+                aArgs[1] <<= bCancel;
+                // TODO: process "cancel" action  
+                break;
+            }
+            case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+            case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+            {
+                uno::Any aRange = createRange( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(3);
+                aArgs[0] = createWorkSheet( pShell, nTab );
+                aArgs[1] = aRange;
+                aArgs[2] <<= bCancel;
+                // TODO: process "cancel" action  
+                break;
+            }
+            case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+            {
+                // one argument: hyperlink
+                uno::Any aHyperlink = createHyperlink( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = aHyperlink;
+                break;
+            }
+            case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+            {
+                uno::Any aHyperlink = createHyperlink( rArgs[0] );
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = createWorkSheet( pShell, nTab );
+                aArgs[1] = aHyperlink;
+                break;
+            }
+            case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+            case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+            {
+                // one argument: pivottable
+                // TODO: not support yet
+                return result;
+            }
+            case VBAEVENT_WORKBOOK_BEFORECLOSE:
+            case VBAEVENT_WORKBOOK_BEFOREPRINT:
+            {
+                // process Cancel argument
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet );
+                aArgs[0] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_BEFORESAVE:
+            {
+                // two arguments: SaveAs and Cancel
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = rArgs[0];
+                aArgs[1] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet );
+                aArgs[1] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+            {
+                // one argument: windows
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = createWindow( pShell );
+                break;
+            }
+            default:
+                return result;
+        }
+    
+        // excute the macro
+        result = executeMacro( pShell, sMacroPath, aArgs, aRet );
+    }
+    
+    return result;
+}
+
+SCTAB ScVbaEventsHelper::getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos )
+{
+    SCTAB nTab = -1;
+    uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( getXSomethingFromArgs< sheet::XCellRangeAddressable >( aArgs, nPos ), uno::UNO_QUERY );
+    if( xCellRangeAddressable.is() )
+    {
+        table::CellRangeAddress aAddress = xCellRangeAddressable->getRangeAddress();
+        nTab = aAddress.Sheet;
+    }
+    return nTab;
+}
+
+sal_Bool SAL_CALL 
+ScVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 nEventId, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+    SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    if( !pShell || mbIgnoreEvents)
+        return sal_False;
+    
+    // In order to better support "withevents" in the future, 
+    // it is better to process a event at a time
+    SCTAB nTab = INVALID_TAB;
+    switch( nEventId )
+    {
+        // Worksheet
+        case VBAEVENT_WORKSHEET_ACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                // process the event
+                processVbaEvent( nEventId, aArgs, nTab );
+                // recursive process related workbook sheet event.
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_ACTIVATE, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_CALCULATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CALCULATE, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_CHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CHANGE, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_DEACTIVATE, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+            // TODO
+            break;
+        case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE, aArgs );
+            }
+            break;
+        }
+        // Workbook_sheet
+        case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+        case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+        case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+        case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+        case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+        case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+        case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+        case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+        case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+        // TODO
+            break;
+        // Workbook
+        case VBAEVENT_WORKBOOK_ACTIVATE:
+        {
+            // if workbook open event do not be fired. fired it before 
+            // workbook activate event to compatible with MSO.
+            if( mbOpened )
+            {
+                // process workbook activate event
+                processVbaEvent( nEventId, aArgs );
+                // process workbook window activate event at the same time
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
+            }
+            break;
+        }
+        case VBAEVENT_WORKBOOK_DEACTIVATE:
+        {
+            processVbaEvent( nEventId, aArgs );
+            // same as workbook window deactivate
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWDEACTIVATE, aArgs );
+            break;
+        }
+        case VBAEVENT_WORKBOOK_OPEN:
+        {
+            // process workbook open macro
+            // does auto open work here?
+            if( !mbOpened )
+            {
+                processVbaEvent( nEventId, aArgs );
+                mbOpened = sal_True;
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+            // register the window listener.
+            if( !mpVbaEventsListener )
+            {
+                mpVbaEventsListener = new VbaEventsListener( this );
+                mpVbaEventsListener->startEventsLinstener();
+            }
+            break;
+        }
+        case VBAEVENT_WORKBOOK_AUTOOPEN:
+            // TODO
+            break;
+        case VBAEVENT_WORKBOOK_BEFORECLOSE:
+        {
+            sal_Bool bCancel = processVbaEvent( nEventId, aArgs ); 
+            if( mpVbaEventsListener && !bCancel )
+            {
+                mpVbaEventsListener->stopEventsLinstener();
+                mpVbaEventsListener = NULL;
+            }
+            return bCancel;
+        }
+        case VBAEVENT_WORKBOOK_BEFOREPRINT:
+        case VBAEVENT_WORKBOOK_BEFORESAVE:
+        case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+        case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+        case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+        {
+            return processVbaEvent( nEventId, aArgs );
+        }
+        case VBAEVENT_WORKBOOK_NEWSHEET:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaEventsHelper::getIgnoreEvents() throw (uno::RuntimeException)
+{
+    return mbIgnoreEvents;
+}
+
+void SAL_CALL 
+ScVbaEventsHelper::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (uno::RuntimeException)
+{
+    mbIgnoreEvents = _ignoreevents;
+}
+
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ScVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaEventsHelper",
+    "com.sun.star.document.VbaEventsHelper" );
+}
--- sc/inc/document.hxx.old	2009-04-06 16:41:59.000000000 +0000
+++ sc/inc/document.hxx	2009-04-06 16:42:00.000000000 +0000
@@ -157,6 +157,9 @@ namespace com { namespace sun { namespac
     }
 } } }
 
+namespace com { namespace sun { namespace star { namespace document {
+    class XVbaEventsHelper;
+} } } }
 #include <svtools/zforlist.hxx>
 /*
 #ifdef _ZFORLIST_DECLARE_TABLE
@@ -319,6 +322,8 @@ private:
 
 	Timer				aTrackTimer;
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > mxVbaEventsHelper;
+
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -1707,6 +1712,8 @@ public:
 	void GetSortParam( ScSortParam& rParam, SCTAB nTab );
 	void SetSortParam( ScSortParam& rParam, SCTAB nTab );
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > GetVbaEventsHelper();
+
     /** Should only be GRAM_PODF or GRAM_ODFF. */
     void                SetStorageGrammar( formula::FormulaGrammar::Grammar eGrammar );
     formula::FormulaGrammar::Grammar  GetStorageGrammar() const
--- sc/source/core/data/documen2.cxx
+++ sc/source/core/data/documen2.cxx
@@ -96,6 +96,7 @@
 #include "externalrefmgr.hxx"
 #include "tabprotection.hxx"
 #include "formulaparserpool.hxx"
 #include "clipparam.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
@@ -1267,6 +1268,29 @@ void ScDocument::RemoveLookupCache( ScLo
     }
 }
 
+using namespace com::sun::star;
+uno::Reference< document::XVbaEventsHelper > 
+ScDocument::GetVbaEventsHelper()
+{
+    if( !mxVbaEventsHelper.is() )
+    {
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pShell ? pShell->GetModel() : NULL, uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.document.VbaEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            mxVbaEventsHelper.set( xVbaEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+    }
+    return mxVbaEventsHelper;
+}
+
 void ScDocument::ClearLookupCaches()
 {
     if( pLookupCacheMapImpl )
--- sc/source/ui/docshell/docsh.cxx.old	2009-04-06 16:41:50.000000000 +0000
+++ sc/source/ui/docshell/docsh.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -127,6 +127,13 @@
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
+#include "uiitems.hxx"
+#include "cellsuno.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 using namespace com::sun::star;
 
@@ -272,7 +279,11 @@ sal_uInt16 ScDocShell::GetHiddenInformat
 void ScDocShell::BeforeXMLLoading()
 {
     aDocument.DisableIdle( TRUE );
-
+    // suppress VBA events when loading the xml
+    uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+    if ( xEvt.is() )
+       xEvt->setIgnoreEvents( sal_True );
+    
     // prevent unnecessary broadcasts and updates
     DBG_ASSERT(pModificator == NULL, "The Modificator should not exist");
 	pModificator = new ScDocShellModificator( *this );
@@ -357,6 +368,10 @@ void ScDocShell::AfterXMLLoading(sal_Boo
     else
 		aDocument.SetInsertingFromOtherDoc( FALSE );
 
+        // suppress VBA events when loading the xml
+        uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+        if ( xEvt.is() )
+            xEvt->setIgnoreEvents( sal_False );
 	aDocument.SetImportingXML( FALSE );
     aDocument.EnableUndo( TRUE );
     bIsEmpty = FALSE;
@@ -498,9 +513,71 @@ BOOL __EXPORT ScDocShell::Load( SfxMediu
 	return bRet;
 }
 
+void lcl_processCompatibleSfxHint( uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper, const SfxHint& rHint )
+{
+    if (rHint.ISA(ScTablesHint) )
+    {
+        USHORT nId = ((ScTablesHint&)rHint).GetId();	
+        SCTAB nTab = ((ScTablesHint&)rHint).GetTab1();	
+        if( nId == SC_TAB_INSERTED )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= nTab;
+            xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_NEWSHEET, aArgs );
+        }
+    }
+    else if ( rHint.ISA( SfxEventHint ) )
+    {
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch ( nEventId )
+        {
+            case SFX_EVENT_ACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+                break;
+            case SFX_EVENT_DEACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_DEACTIVATE, aArgs );
+            }
+                break;
+            /*case SFX_EVENT_CLOSEDOC :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_CLOSE, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEVIEW :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWCOLSE, aArgs );
+            }
+                break;
+            */    
+            case SFX_EVENT_OPENDOC:
+            {
+                // some later than workbook activate.
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+            }
+                break;
+            default:
+                {
+                }
+                break;
+        }
+    }
+}
 
 void __EXPORT ScDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
 {
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+    {
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
+    }
 	if (rHint.ISA(SfxSimpleHint))								// ohne Parameter
 	{
 		ULONG nSlot = ((const SfxSimpleHint&)rHint).GetId();
@@ -2144,6 +2221,16 @@ USHORT __EXPORT ScDocShell::PrepareClose
 
 	DoEnterHandler();
 
+    // start handler for possible veto from DocBefore_Close
+    uno::Sequence< uno::Any > aArgs;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( !IsInPrepareClose() && xVbaEventsHelper.is() )
+    {
+        if ( xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORECLOSE, aArgs ) )
+            return sal_False;
+    }
+    // end handler code
+
 	USHORT nRet = SfxObjectShell::PrepareClose( bUI, bForBrowsing );
 	if (nRet == TRUE)						// TRUE = schliessen
 		aDocument.DisableIdle(TRUE);		// nicht mehr drin rumpfuschen !!!
--- sc/source/ui/inc/docsh.hxx.old	2009-04-06 16:41:53.000000000 +0000
+++ sc/source/ui/inc/docsh.hxx	2009-04-06 16:42:00.000000000 +0000
@@ -47,6 +47,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
--- sc/source/ui/unoobj/viewuno.cxx
+++ sc/source/ui/unoobj/viewuno.cxx
@@ -71,9 +71,13 @@
 #include "gridwin.hxx"
 #include <com/sun/star/view/DocumentZoomType.hpp>
 #include "AccessibilityHints.hxx"
+#include <com/sun/star/awt/MouseButton.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 #include <svx/sdrhittesthelper.hxx>
 
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -458,6 +462,78 @@ void SAL_CALL ScViewPaneObj::release() t
 	OWeakObject::release();
 }
 
+// To process sheet compatibile event
+typedef ::cppu::WeakImplHelper2< awt::XEnhancedMouseClickHandler, view::XSelectionChangeListener > TabViewEventListener_BASE;
+class ScTabViewEventListener: public TabViewEventListener_BASE
+{
+private:
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper;
+    ScTabViewObj* pViewObj;
+    
+public:
+    ScTabViewEventListener( ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper);
+    ~ScTabViewEventListener();
+    // XEnhancedMouseClickHandler
+    virtual sal_Bool SAL_CALL mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+    virtual sal_Bool SAL_CALL mouseReleased( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+
+    // XSelectionChangeListener
+    virtual void SAL_CALL selectionChanged( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+
+ScTabViewEventListener::ScTabViewEventListener(ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper):
+                        pViewObj( pObj ),xVbaEventsHelper( rVbaEventsHelper )
+{
+}
+
+ScTabViewEventListener::~ScTabViewEventListener()
+{
+}
+
+void SAL_CALL ScTabViewEventListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException)
+{
+    sal_Bool result =  sal_False;
+    // process BeforeDoubleClick and BeforeRightClick events
+    if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+    {
+        // ensure the target is a cell
+        uno::Reference< table::XCell > xCell( e.Target, uno::UNO_QUERY );
+        if( xCell.is() && xVbaEventsHelper.is() && pViewObj)
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = pViewObj->getSelection();
+            sal_Int32 nEventId = VBAEVENT_WORKSHEET_BEFORERIGHTCLICK;
+            if( e.ClickCount == 2 )
+                nEventId = VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK;
+            
+            result = xVbaEventsHelper->ProcessCompatibleVbaEvent( nEventId, aArgs );
+            // TODO: process Cancel argument	
+        }
+    }
+    return result;
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mouseReleased( const awt::EnhancedMouseEvent&/*e*/) throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL ScTabViewEventListener::selectionChanged( const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    if ( xVbaEventsHelper.is() && pViewObj)
+    {
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] = pViewObj->getSelection();
+        xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_SELECTIONCHANGE, aArgs );
+    }
+}
+
 //------------------------------------------------------------------------
 
 //	Default-ctor wird fuer SMART_REFLECTION_IMPLEMENTATION gebraucht
@@ -482,7 +558,19 @@ ScTabViewObj::ScTabViewObj( ScTabViewShe
 	bDrawSelModeSet(sal_False),
     bFilteredRangeSelection(sal_True)
 {
-	//!	Listening oder so
+    if( pViewSh )
+    {
+        ScViewData* pViewData = pViewSh->GetViewData();
+        if( pViewData )
+        {
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper (pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+            ScTabViewEventListener* pEventListener = new ScTabViewEventListener( this, xVbaEventsHelper );
+            uno::Reference< awt::XEnhancedMouseClickHandler > aMouseClickHandler( *pEventListener, uno::UNO_QUERY );
+            addEnhancedMouseClickHandler( aMouseClickHandler );
+            uno::Reference< view::XSelectionChangeListener > aSelectionChangeListener( *pEventListener, uno::UNO_QUERY );
+            addSelectionChangeListener( aSelectionChangeListener );
+        }
+    }
 }
 
 ScTabViewObj::~ScTabViewObj()
--- sc/source/ui/unoobj/docuno.cxx.old	2009-04-06 16:41:59.000000000 +0000
+++ sc/source/ui/unoobj/docuno.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -97,7 +97,10 @@
 #include <svx/unoshape.hxx>
 #endif
 
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -313,6 +316,7 @@ uno::Any SAL_CALL ScModelObj::queryInter
 	SC_QUERYINTERFACE( document::XLinkTargetSupplier )
 	SC_QUERYINTERFACE( beans::XPropertySet )
 	SC_QUERYINTERFACE( document::XCodeNameQuery )
+    SC_QUERYINTERFACE( document::XDocumentEventCompatibleHelper)
 	SC_QUERYINTERFACE( lang::XMultiServiceFactory )
 	SC_QUERYINTERFACE( lang::XServiceInfo )
     SC_QUERYINTERFACE( util::XChangesNotifier )
@@ -1762,6 +1766,39 @@ ScModelObj::getCodeNameForObject( const
     // Probably should throw here ( if !bMatched )
      return sCodeName;
 }
+// XVbaEventHelper
+// For Vba Event
+sal_Bool SAL_CALL
+ScModelObj::processCompatibleEvent( sal_Int16 nSlotId ) throw( ::com::sun::star::uno::RuntimeException )
+{
+    USHORT nId = (USHORT)nSlotId;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+    if( xVbaEventsHelper.is() )
+    {
+        switch( nId )
+        {
+            case SID_SAVEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_False;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_SAVEASDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_True;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_PRINTDOC:
+            case SID_PRINTDOCDIRECT:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFOREPRINT, aArgs );
+            }
+        }
+    }
+    return sal_False;
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
--- sc/inc/docuno.hxx.old	2009-04-06 16:41:59.000000000 +0000
+++ sc/inc/docuno.hxx	2009-04-06 16:42:00.000000000 +0000
@@ -56,6 +56,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/sheet/XCellRangesAccess.hpp>
 #include <com/sun/star/util/XChangesNotifier.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
@@ -92,6 +93,7 @@ class SC_DLLPUBLIC ScModelObj : public S
 					public com::sun::star::document::XLinkTargetSupplier,
 					public com::sun::star::beans::XPropertySet,
 					public com::sun::star::document::XCodeNameQuery,
+                    public com::sun::star::document::XDocumentEventCompatibleHelper,
 					public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo,
                     public ::com::sun::star::util::XChangesNotifier
@@ -320,6 +322,8 @@ public:
                                 throw (::com::sun::star::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getCodeNameForObject( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& aObj ) 
                                 throw(::com::sun::star::uno::RuntimeException); 
+                            // XVbaEventHelper
+    virtual sal_Bool SAL_CALL processCompatibleEvent( sal_Int16 nEventId ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 
--- sc/source/ui/view/gridwin.cxx.old	2009-04-06 16:41:50.000000000 +0000
+++ sc/source/ui/view/gridwin.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -130,7 +130,13 @@
 #include <svx/sdr/overlay/overlaymanager.hxx>
 #include <vcl/svapp.hxx>
 
+#include "cellsuno.hxx"
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Any;
 
@@ -356,6 +362,32 @@ void lcl_UnLockComment( ScDrawView* pVie
     }
 }
 
+sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTAB nTab, ScBaseCell*& rpCell )
+{
+    BOOL bFound = FALSE;
+    do
+    {
+        pDoc->GetCell( rPosX, rPosY, nTab, rpCell );
+        if ( !rpCell || rpCell->GetCellType() == CELLTYPE_NOTE )
+        {
+            if ( rPosX <= 0 )
+                return FALSE;							// alles leer bis links
+            else
+                --rPosX;								// weitersuchen
+        }
+                else if ( rpCell->GetCellType() == CELLTYPE_EDIT)
+                    bFound = TRUE;
+                else if (rpCell->GetCellType() == CELLTYPE_FORMULA &&
+                  static_cast<ScFormulaCell*>(rpCell)->IsHyperLinkCell())
+                    bFound = TRUE;
+        else
+            return FALSE;								// andere Zelle
+    }
+    while ( !bFound );
+
+    return bFound;
+}
+
 // ---------------------------------------------------------------------------
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
 ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhichPos )
@@ -1403,6 +1435,7 @@ void ScGridWindow::HandleMouseButtonDown
 	SCCOL	nOldColFBox	  = bWasFilterBox ? pFilterBox->GetCol() : 0;
 	SCROW  nOldRowFBox	  = bWasFilterBox ? pFilterBox->GetRow() : 0;
 #endif
+#include "cellsuno.hxx" 
 
 	ClickExtern();	// loescht FilterBox, wenn vorhanden
 
@@ -2085,6 +2118,26 @@ void __EXPORT ScGridWindow::MouseButtonU
 		{
 			nMouseStatus = SC_GM_NONE;				// keinen Doppelklick anfangen
 			ScGlobal::OpenURL( aUrl, aTarget );
+            
+            // fire worksheet_followhyperlink event
+            Point aPos = rMEvt.GetPosPixel();
+            SCsCOL nPosX;
+            SCsROW nPosY;
+            SCTAB nTab = pViewData->GetTabNo();
+            pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
+            ScBaseCell* pCell = NULL;
+
+            BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+            if( bFound )
+            {
+                ScAddress aCellPos( nPosX, nPosY, nTab );
+                ScCellObj* pObj = new ScCellObj( pViewData->GetDocShell(), aCellPos );
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+                uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+                if( xVbaEventsHelper.is() )
+                    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_FOLLOWHYPERLINK, aArgs );
+            }
 			return;
 		}
 	}
@@ -2412,7 +2465,7 @@ long ScGridWindow::PreNotify( NotifyEven
 			                lcl_InitMouseEvent( aEvent, *rNEvt.GetMouseEvent() );
 	                        if ( rNEvt.GetWindow() )
 		                        aEvent.Source = rNEvt.GetWindow()->GetComponentInterface();
-                            if ( nType == EVENT_MOUSEBUTTONDOWN)
+                            if ( nType == EVENT_MOUSEBUTTONDOWN )
 					            pImp->MousePressed( aEvent );
                             else
                                 pImp->MouseReleased( aEvent );
@@ -4827,26 +4880,9 @@ BOOL ScGridWindow::GetEditUrlOrError( BO
 	ScDocument* pDoc = pDocSh->GetDocument();
 	ScBaseCell* pCell = NULL;
 
-	BOOL bFound = FALSE;
-	do
-	{
-		pDoc->GetCell( nPosX, nPosY, nTab, pCell );
-		if ( !pCell || pCell->GetCellType() == CELLTYPE_NOTE )
-		{
-			if ( nPosX <= 0 )
-				return FALSE;							// alles leer bis links
-			else
-				--nPosX;								// weitersuchen
-		}
-                else if ( pCell->GetCellType() == CELLTYPE_EDIT)
-                    bFound = TRUE;
-                else if (pCell->GetCellType() == CELLTYPE_FORMULA &&
-                  static_cast<ScFormulaCell*>(pCell)->IsHyperLinkCell())
-                    bFound = TRUE;
-	    else
-			return FALSE;								// andere Zelle
-	}
-	while ( !bFound );
+    BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+    if( !bFound )
+        return FALSE;
 
 	ScHideTextCursor aHideCursor( pViewData, eWhich );	// before GetEditArea (MapMode is changed)
 
--- sc/source/ui/view/tabview3.cxx.old	2009-04-06 16:41:50.000000000 +0000
+++ sc/source/ui/view/tabview3.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -82,6 +82,10 @@
 #include "tabprotection.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star::document::VbaEventId;
 
 namespace
 {
@@ -1600,6 +1604,17 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 										//	nicht InputEnterHandler wegen Referenzeingabe !
 
 		ScDocument* pDoc = aViewData.GetDocument();
+        if( !bNew )
+        {
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_DEACTIVATE, aArgs );
+            }
+        }
+            
 		pDoc->MakeTable( nTab );
 
 		SCTAB nTabCount = pDoc->GetTableCount();
@@ -1698,8 +1713,20 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
 					if ( pGridWin[i]->IsVisible() )
 						pGridWin[i]->UpdateEditViewPos();
 		}
-
+        
 		TabChanged();										// DrawView
+
+        if( !bNew )
+        {
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_ACTIVATE,  aArgs );
+            }
+        }
+            
 		aViewData.GetViewShell()->WindowChanged();			// falls das aktive Fenster anders ist
         if ( !bUnoRefDialog )
             aViewData.GetViewShell()->DisconnectAllClients();   // important for floating frames
--- sc/source/ui/vba/makefile.mk.old	2009-04-06 16:41:59.000000000 +0000
+++ sc/source/ui/vba/makefile.mk	2009-04-06 16:42:00.000000000 +0000
@@ -134,7 +134,8 @@ SLOFILES= \
         		$(SLO)$/vbapagebreaks.obj \
 		        $(SLO)$/vbaspinbutton.obj \
 		        $(SLO)$/vbaimage.obj \
-				$(SLO)$/service.obj
+                $(SLO)$/service.obj \
+        $(SLO)$/vbaeventshelper.obj
 
 # --- Targets ------------------------------------------------------
 
--- sc/source/ui/vba/service.cxx.old	2009-04-02 10:45:35.000000000 +0000
+++ sc/source/ui/vba/service.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -69,6 +69,10 @@ namespace hyperlink
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
 
 extern "C"
 {
@@ -86,7 +90,7 @@ extern "C"
 
 	// Component registration
         if ( component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) )
+        range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl ) )
 		{
 			// Singleton registration
 			try
@@ -115,6 +119,8 @@ extern "C"
 		OSL_TRACE("In component_getFactory for %s", pImplName );
 	void* pRet =  component_getFactoryHelper(
         	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl );
+    if( !pRet )
+        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl );
 	OSL_TRACE("Ret is 0x%x", pRet);
 	return pRet;
     }
--- sfx2/inc/sfx2/objsh.hxx.old	2009-04-06 16:41:53.000000000 +0000
+++ sfx2/inc/sfx2/objsh.hxx	2009-04-06 16:42:00.000000000 +0000
@@ -308,6 +308,7 @@ public:
     void                        SetNoName();
     sal_Bool                    IsInModalMode() const;
     sal_Bool					HasModalViews() const;
+    sal_Bool                    IsInPrepareClose() const;
     sal_Bool                    IsHelpDocument() const;
 
     sal_Bool                    IsDocShared() const;
@@ -408,7 +409,8 @@ public:
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true
     );
 
     static ErrCode  CallXScript(
@@ -417,7 +419,8 @@ public:
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true
     );
 
     /** adjusts the internal macro mode, according to the current security settings
--- sfx2/source/doc/objmisc.cxx.old	2009-04-02 10:43:58.000000000 +0000
+++ sfx2/source/doc/objmisc.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -1632,7 +1632,7 @@ namespace
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError )
 {
     OSL_TRACE( "in CallXScript" );
 	ErrCode nErr = ERRCODE_NONE;
@@ -1673,7 +1673,7 @@ ErrCode SfxObjectShell::CallXScript( con
         nErr = ERRCODE_BASIC_INTERNAL_ERROR;
     }
 
-	if ( bCaughtException )
+    if ( bCaughtException && bRaiseError )
 	{
         ::std::auto_ptr< VclAbstractDialog > pScriptErrDlg;
 		SfxAbstractDialogFactory* pFact = SfxAbstractDialogFactory::Create();
@@ -1697,9 +1697,9 @@ ErrCode SfxObjectShell::CallXScript( con
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
-            aOutParam)
+            aOutParam, bool bRaiseError )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError );
 }
 
 //-------------------------------------------------------------------------
--- sfx2/source/doc/objserv.cxx.old	2009-04-06 16:41:53.000000000 +0000
+++ sfx2/source/doc/objserv.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -103,6 +103,7 @@
 #include <com/sun/star/embed/XTransactedObject.hpp>
 #include <com/sun/star/util/XCloneable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 
 #include "helpid.hrc"
 
@@ -507,6 +508,18 @@ void SfxObjectShell::ExecFile_Impl(SfxRe
 		case SID_SAVEASDOC:
 		case SID_SAVEDOC:
 		{
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                        return;
+                    }
+                }
+            }
 			//!! detaillierte Auswertung eines Fehlercodes
 			SfxObjectShellRef xLock( this );
 
--- sfx2/source/view/viewprn.cxx.old	2009-04-02 10:44:00.000000000 +0000
+++ sfx2/source/view/viewprn.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -32,6 +32,7 @@
 #include "precompiled_sfx2.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <com/sun/star/view/PrintableState.hpp>
 #include <svtools/itempool.hxx>
 #ifndef _MSGBOX_HXX //autogen
@@ -67,6 +68,8 @@
 #include "view.hrc"
 #include "helpid.hrc"
 
+using namespace com::sun::star;
+
 TYPEINIT1(SfxPrintingHint, SfxHint);
 
 // -----------------------------------------------------------------------
@@ -405,6 +408,22 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 		case SID_SETUPPRINTER:
 	    case SID_PRINTER_NAME :
 		{
+            if( nId == SID_PRINTDOC )
+            {
+                SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc )
+                {
+                    uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                    if( xVbaEventHelper.is() )
+                    {
+                        if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                        {
+                            rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                            return;
+                        }
+                    }
+                }
+            }
 	        // quiet mode (AppEvent, API call)
 			SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
 			bSilent = pSilentItem && pSilentItem->GetValue();
@@ -717,6 +736,15 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
 	        if ( SID_PRINTDOCDIRECT == nId )
 	        {
 				SfxObjectShell* pDoc = GetObjectShell();
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                        return;
+                    }
+                }
 				bool bDetectHidden = ( !bSilent && pDoc );
 				if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
 					return;
--- sfx2/source/doc/objxtor.cxx.old	2009-04-02 10:43:58.000000000 +0000
+++ sfx2/source/doc/objxtor.cxx	2009-04-06 16:42:00.000000000 +0000
@@ -579,6 +579,13 @@ SfxObjectShell* SfxObjectShell::Current(
 	return pFrame ? pFrame->GetObjectShell() : 0;
 }
 
+//-------------------------------------------------------------------------
+
+sal_Bool SfxObjectShell::IsInPrepareClose() const
+{
+    return pImp->bInPrepareClose;
+}
+
 //------------------------------------------------------------------------
 
 struct BoolEnv_Impl
