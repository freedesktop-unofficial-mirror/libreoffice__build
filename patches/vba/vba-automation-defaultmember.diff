diff --git basic/source/runtime/step2.cxx basic/source/runtime/step2.cxx
index 558eff7..adde4fa 100644
--- basic/source/runtime/step2.cxx
+++ basic/source/runtime/step2.cxx
@@ -264,10 +264,12 @@ SbxVariable* SbiRuntime::FindElement
 			if( bSet )
 				pElem->SetType( t2 );
 			pElem = pNew;
-		}
+        } 
 		// Index-Access bei UnoObjekten beruecksichtigen
-		/*
-		else if( pElem->ISA(SbUnoProperty) )
+        // definitely we want this for VBA where properties are often 
+        // collections ( which need index access ), but lets only do 
+        // this if we actually have params following
+        else if( bVBAEnabled && pElem->ISA(SbUnoProperty) && pElem->GetParameters() )
 		{
 			// pElem auf eine Ref zuweisen, um ggf. eine Temp-Var zu loeschen
 			SbxVariableRef refTemp = pElem;
@@ -277,7 +279,6 @@ SbxVariable* SbiRuntime::FindElement
 			pElem->SetParameters( NULL ); // sonst bleibt Ref auf sich selbst
 			pElem = pNew;
 		}
-		*/
 	}
 	return CheckArray( pElem );
 }
diff --git extensions/source/ole/oleobjw.cxx extensions/source/ole/oleobjw.cxx
index 7c6d6d6..0e6520d 100644
--- extensions/source/ole/oleobjw.cxx
+++ extensions/source/ole/oleobjw.cxx
@@ -72,6 +72,7 @@ using namespace boost;
 using namespace osl;
 using namespace rtl;
 using namespace cppu;
+using namespace com::sun::star::script;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::bridge;
 using namespace com::sun::star::bridge::oleautomation;
@@ -111,7 +112,7 @@ IUnknownWrapper_Impl::IUnknownWrapper_Impl( Reference<XMultiServiceFactory>& xFa
 										   sal_uInt8 unoWrapperClass, sal_uInt8 comWrapperClass):
 	UnoConversionUtilities<IUnknownWrapper_Impl>( xFactory, unoWrapperClass, comWrapperClass),
 	m_pxIdlClass( NULL), m_eJScript( JScriptUndefined),
-    m_bComTlbIndexInit(false)
+    m_bComTlbIndexInit(false),  m_bHasDfltMethod(false), m_bHasDfltProperty(false)
 {
 }
 
@@ -150,17 +151,15 @@ IUnknownWrapper_Impl::~IUnknownWrapper_Impl()
 Any IUnknownWrapper_Impl::queryInterface(const Type& t)
     throw (RuntimeException)
 {
-    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)))
-    {
-        if (m_spDispatch)
-            return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-                XInitialization, XAutomationObject>::queryInterface(t);
-        else
-            return Any();
-    }
-
-    return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-        XInitialization, XAutomationObject>::queryInterface(t);
+    if (t == getCppuType(static_cast<Reference<XDefaultMethod>*>( 0)) && !m_bHasDfltMethod )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XDefaultProperty>*>( 0)) && !m_bHasDfltProperty )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)) && !m_spDispatch)
+        return Any();
+
+    return WeakImplHelper6<XInvocation, XBridgeSupplier2,
+        XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>::queryInterface(t);
 }
 
 Reference<XIntrospectionAccess> SAL_CALL IUnknownWrapper_Impl::getIntrospection(void)
@@ -1197,6 +1196,47 @@ void SAL_CALL IUnknownWrapper_Impl::initialize( const Sequence< Any >& aArgument
 
     aArguments[1] >>= m_bOriginalDispatch;    
 	aArguments[2] >>= m_seqTypes;
+    try
+    {
+        ITypeInfo* pType= getTypeInfo();
+        // Get Default member
+        CComBSTR defaultMemberName;
+        if ( SUCCEEDED( pType->GetDocumentation(0, &defaultMemberName, 0, 0, 0 ) ) )
+        {
+            OUString usName(reinterpret_cast<const sal_Unicode*>(LPCOLESTR(defaultMemberName)));
+            FuncDesc aDescGet(pType);
+            FuncDesc aDescPut(pType);
+            VarDesc aVarDesc(pType);
+            // see if this is a property first ( more likely to be a property then a method )
+            getPropDesc( usName, & aDescGet, & aDescPut, & aVarDesc);
+
+            if ( !aDescGet && !aDescPut )
+            {
+                getFuncDesc( usName, &aDescGet );
+                if ( !aDescGet )
+                    // we're knackered
+                    throw RuntimeException();
+                
+            }
+            // now for some funny heuristics to make basic understand what to do
+            // a single aDescGet ( that doesn't take any params ) would be 
+            // a read only ( defaultmember ) property e.g. this object
+            // should implement XDefaultProperty
+            // a single aDescGet ( that *does* ) take params is basically a
+            // default method e.g. implement XDefaultMethod
+            
+            // a DescPut ( I guess we only really support a default param with '1' param ) as a setValue ( but I guess we can leave it through, the object will fail if we don't get it right anyway )
+            if ( aDescPut || ( aDescGet && aDescGet->cParams == 0 ) )
+                m_bHasDfltProperty = true;
+            if ( aDescGet->cParams > 0 )
+                m_bHasDfltMethod = true;
+            if ( m_bHasDfltProperty || m_bHasDfltMethod )
+                m_sDefaultMember = usName;
+        }
+    }
+    catch( Exception& )
+    {
+    } 
 }
 
 // UnoConversionUtilities --------------------------------------------------------------------------------
diff --git extensions/source/ole/oleobjw.hxx extensions/source/ole/oleobjw.hxx
index d10c9e7..00b6b6a 100644
--- extensions/source/ole/oleobjw.hxx
+++ extensions/source/ole/oleobjw.hxx
@@ -49,11 +49,14 @@
 #pragma warning (pop)
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
+#include <cppuhelper/implbase6.hxx>
 
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 #include <rtl/ustring.hxx>
 
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 
 #include <typelib/typedescription.hxx>
 #include "unoconversionutilities.hxx"
@@ -77,7 +80,8 @@ typedef hash_multimap<OUString, unsigned int, hashOUString_Impl, equalOUString_I
 // This class wraps an IDispatch and maps XInvocation calls to IDispatch calls on the wrapped object.
 // If m_TypeDescription is set then this class represents an UNO interface implemented in a COM component.
 // The interface is not a real interface in terms of an abstract class but is realized through IDispatch.
-class IUnknownWrapper_Impl : public WeakImplHelper4<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject>,
+class IUnknownWrapper_Impl : public WeakImplHelper6<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>,
+
 							 public UnoConversionUtilities<IUnknownWrapper_Impl>
 
 {
@@ -125,8 +129,10 @@ public:
 	// XInitialization
     virtual void SAL_CALL initialize( const Sequence< Any >& aArguments )
         throw(Exception, RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
 protected:
-    
+    virtual ::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
+
 	// ----------------------------------------------------------------------------
     virtual Any invokeWithDispIdUnoTlb(const OUString& sFunctionName,
                                        const Sequence< Any >& Params,
@@ -252,6 +258,9 @@ protected:
     bool m_bComTlbIndexInit;
 	// Keeps the ITypeInfo obtained from IDispatch::GetTypeInfo
 	CComPtr< ITypeInfo > m_spTypeInfo;
+    rtl::OUString m_sDefaultMember;
+    bool m_bHasDfltMethod;
+    bool m_bHasDfltProperty;
 };
 
 } // end namespace
