diff -rupp /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/comp/parser.cxx basic/source/comp/parser.cxx
--- /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/comp/parser.cxx	2006-05-22 08:25:25.000000000 +0100
+++ basic/source/comp/parser.cxx	2006-05-30 11:43:19.000000000 +0100
@@ -605,7 +605,12 @@ void SbiParser::Set()
 		if( pDef->GetTypeId() )
 			aGen.Gen( _SETCLASS, pDef->GetTypeId() );
 		else
-			aGen.Gen( _SET );
+		{
+			if ( bVBASupportOn )
+				aGen.Gen( _VBASET );		
+			else
+				aGen.Gen( _SET );
+		}
 	}
 	// aGen.Gen( _SET );
 }
diff -rupp /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/inc/opcodes.hxx basic/source/inc/opcodes.hxx
--- /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/inc/opcodes.hxx	2005-09-29 17:31:38.000000000 +0100
+++ basic/source/inc/opcodes.hxx	2006-05-30 11:50:31.000000000 +0100
@@ -98,6 +98,7 @@ enum SbiOpcode {
 	_RSET,              // Speichern Objekt TOS ==> TOS-1
 	_REDIMP_ERASE,		// Copies array to be later used by REDIM PRESERVE before erasing it
 	_INITFOREACH,
+	_VBASET,            // VBA-like Set
 	SbOP0_END,
 
 	// Alle Opcodes mit einem Operanden
diff -rupp /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/inc/runtime.hxx basic/source/inc/runtime.hxx
--- /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/inc/runtime.hxx	2006-05-22 08:25:25.000000000 +0100
+++ basic/source/inc/runtime.hxx	2006-05-30 14:23:17.000000000 +0100
@@ -434,8 +434,8 @@ class SbiRuntime
 	void StepNOT(),     StepCAT(),      StepLIKE(),     StepIS();
 	void StepCLONE(),   StepOLDBASED(), StepARGC();
 	void StepARGV(),    StepINPUT(),	StepLINPUT(),	StepSTOP();
-	void StepGET(),		StepSET(),	 	StepPUT(),		StepPUTC();
-	void StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar );
+	void StepGET(),		StepSET(),	StepVBASET(), 	 	StepPUT(),		StepPUTC();
+	void StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar, bool bDefaultHandling = true );
 	void StepDIM(),     StepREDIM(),	StepREDIMP(),	StepERASE();
 	void StepINITFOR(), StepNEXT(),		StepERROR(),	StepINITFOREACH();
 	void StepCASE(),	StepENDCASE(),  StepSTDERROR();
diff -rupp /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/runtime/runtime.cxx basic/source/runtime/runtime.cxx
--- /data4/sles/ooo-mLnew/ooo-build/build/ooc680-m2/basic/source/runtime/runtime.cxx	2006-05-22 08:25:25.000000000 +0100
+++ basic/source/runtime/runtime.cxx	2006-05-30 14:45:51.000000000 +0100
@@ -154,6 +154,7 @@ SbiRuntime::pStep0 SbiRuntime::aStep0[] 
 	MEMBER(SbiRuntime::StepRSET),		// Speichern Objekt TOS ==> TOS-1
 	MEMBER(SbiRuntime::StepREDIMP_ERASE),// Copy array object for REDIMP
 	MEMBER(SbiRuntime::StepINITFOREACH),// Init for each loop
+	MEMBER(SbiRuntime::StepVBASET),// vba-like set statement
 };
 
 SbiRuntime::pStep1 SbiRuntime::aStep1[] = {	// Alle Opcodes mit einem Operanden

Index: basic/source/runtime/step0.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step0.cxx,v
retrieving revision 1.21
diff -u -p -r1.21 step0.cxx
--- basic/source/runtime/step0.cxx	7 Sep 2005 21:42:01 -0000	1.21
+++ basic/source/runtime/step0.cxx	15 Dec 2005 10:31:53 -0000
@@ -52,6 +52,10 @@
 
 #include <algorithm>
 
+#ifdef ENABLE_VBA
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+#endif //ENABLE_VBA
+
 void SbiRuntime::StepNOP()
 {}

@@ -62,6 +66,32 @@ void SbiRuntime::StepArith( SbxOperator 
 	SbxVariableRef p1 = PopVar();
 	TOSMakeTemp();
 	SbxVariable* p2 = GetTOS();
+#ifdef ENABLE_VBA
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+	SbxVariable* defaultProp = NULL;
+
+	// This could & should be moved to the MakeTempTOS() method in runtime.cxx
+	// In the code which this is cut'npaste from there is a check for a ref
+	// count != 1 based on which the copy of the SbxVariable is done.
+	// see orig code in MakeTempTOS ( and I'm not sure what the significance,
+	// of that is )
+	// here we alway seem to have a refcount of 1. Also it seems that
+	// MakeTempTOS is called for other operation, so I hold off for now
+	// until I have a better idea
+	if ( bVBAInterop
+		&& ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
+	)
+	{
+		SbxVariable* pDflt = getDefaultProp( p2 );
+		if ( pDflt )
+		{
+			pDflt->Broadcast( SBX_HINT_DATAWANTED );
+			p2 = new SbxVariable( *pDflt );
+			p2->SetFlag( SBX_READWRITE );
+			refExprStk->Put( p2, nExprLvl - 1 );
+		}
+	}
+#endif //ENABLE_VBA
 	p2->ResetFlag( SBX_FIXED );
 	p2->Compute( eOp, *p1 );
 
@@ -213,9 +243,37 @@ void SbiRuntime::StepPUT()
 		n = refVar->GetFlags();
 		refVar->SetFlag( SBX_WRITE );
 	}
+#ifdef ENABLE_VBA
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+
+	// if left side arg is an object or variant and right handside isn't 
+	// either an object or a variant then try and see if a default 
+	// property exists.
+	// to use e.g. Range{"A1") = 34
+	// could equate to Range("A1").Value = 34 
+	if ( bVBAInterop
+		&& ( refVar->GetType() == SbxOBJECT  ) )
+	{
+		SbxVariable* pDflt = getDefaultProp( refVar );
+		if ( pDflt )
+			refVar = pDflt;
+	}
+	if ( bVBAInterop
+		&& ( refVal->GetType() == SbxOBJECT  ) )
+	{
+		SbxVariable* pDflt = getDefaultProp( refVal );
+		if ( pDflt )
+			refVal = pDflt;
+	}
+#endif //ENABLE_VBA
+
 	*refVar = *refVal;
+#ifdef ENABLE_VBA
+	// lhs is a property who's value is currently null
+	if ( !bVBAInterop || ( bVBAInterop && refVar->GetType() != SbxEMPTY ) )
+#endif //ENABLE_VBA
 	// #67607 Uno-Structs kopieren
-	checkUnoStructCopy( refVal, refVar );
+		checkUnoStructCopy( refVal, refVar );
 	if( bFlagsChanged )
 		refVar->SetFlags( n );
 }
@@ -224,30 +282,51 @@ void SbiRuntime::StepPUT()
 // Speichern Objektvariable
 // Nicht-Objekt-Variable fuehren zu Fehlern
 
-void SbiRuntime::StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar )
+void SbiRuntime::StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar, bool bHandleDefaultProp )
 {
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
 	// #67733 Typen mit Array-Flag sind auch ok
 	SbxDataType eValType = refVal->GetType();
 	SbxDataType eVarType = refVar->GetType();
-	if( (eValType != SbxOBJECT && eValType != SbxEMPTY && !(eValType & SbxARRAY)) ||
-		(eVarType != SbxOBJECT && eVarType != SbxEMPTY && !(eVarType & SbxARRAY) ) )
+        if( (eValType != SbxOBJECT 
+			&& eValType != SbxEMPTY 
+#ifdef ENABLE_VBA
+// seems like when using the default method its possible for objects
+// to be empty ( no broadcast has taken place yet ) or the actual value is
+
+			&& !bVBAInterop
+#endif //ENABLE_VBA
+			&& !(eValType & SbxARRAY)) ||
+            (eVarType != SbxOBJECT 
+			&& eVarType != SbxEMPTY 
+#ifdef ENABLE_VBA
+			&& !bVBAInterop
+#endif //ENABLE_VBA
+			&& !(eVarType & SbxARRAY) ) )
 	{
 		Error( SbERR_INVALID_USAGE_OBJECT );
 	}
 	else
 	{
-		// Auf refVal GetObject fuer Collections ausloesen
-		SbxBase* pObjVarObj = refVal->GetObject();
-		if( pObjVarObj )
+#ifdef ENABLE_VBA
+		if ( refVal->GetType() == SbxOBJECT )
 		{
-			SbxVariableRef refObjVal = PTR_CAST(SbxObject,pObjVarObj);
+#endif //ENABLE_VBA
+		// Auf refVal GetObject fuer Collections ausloesen
+			SbxBase* pObjVarObj = refVal->GetObject();
+			if( pObjVarObj )
+			{
+				SbxVariableRef refObjVal = PTR_CAST(SbxObject,pObjVarObj);
 
-			// #67733 Typen mit Array-Flag sind auch ok
-			if( refObjVal )
-				refVal = refObjVal;
-			else if( !(eValType & SbxARRAY) )
-				refVal = NULL;
+				// #67733 Typen mit Array-Flag sind auch ok
+				if( refObjVal )
+					refVal = refObjVal;
+				else if( !(eValType & SbxARRAY) )
+					refVal = NULL;
+			}
+#ifdef ENABLE_VBA
 		}
+#endif //ENABLE_VBA
 
 		// #52896 Wenn Uno-Sequences bzw. allgemein Arrays einer als
 		// Object deklarierten Variable zugewiesen werden, kann hier
@@ -270,8 +349,67 @@ void SbiRuntime::StepSET_Impl( SbxVariab
 			SbProcedureProperty* pProcProperty = PTR_CAST(SbProcedureProperty,(SbxVariable*)refVar);
 			if( pProcProperty )
 				pProcProperty->setSet( true );
+#ifdef ENABLE_VBA
+			if ( bHandleDefaultProp )
+			{
+				// get default properties for lhs & rhs where necessary
+				// have to be careful though where a lhs object is null
+				// meaning a 'set something = someObject' has taken places
+				// which means we don't want to get the default prop for the rhs
+				SbxVariable* defaultProp = NULL;
+				bool bLHSHasDefaultProp = false;
+				// LHS try determine if a default prop exists
+				if ( bVBAInterop
+					&& ( refVar->GetType() == SbxOBJECT ) )
+				{
+						SbxVariable* pDflt = getDefaultProp( refVar );
+						if ( pDflt )
+						{
+							refVar = pDflt;
+							bLHSHasDefaultProp = true;
+						}
+				}
+				// RHS only get a default prop is the rhs has one
+				if ( bVBAInterop
+					&& ( refVal->GetType() == SbxOBJECT ) )
+				{
+					// check if lhs is a null object
+					// if it is then use the object not the default property
+					SbxObject* pObj = NULL;
+	
+					if ( refVar->GetType() == SbxOBJECT || refVar->GetType() == SbxEMPTY ) 
+					{
+					
+						pObj = PTR_CAST(SbxObject,(SbxVariable*)refVar);
 
+						// calling GetObject on a SbxEMPTY variable raises
+						// object not set errors, make sure its an Object
+						if ( !pObj && refVar->GetType() == SbxOBJECT )
+						{
+							SbxBase* pObjVarObj = refVar->GetObject();
+							pObj = PTR_CAST(SbxObject,pObjVarObj);
+						}	
+						SbxVariable* pDflt = NULL;
+						if ( pObj || bLHSHasDefaultProp )
+							// lhs is either a valid object || or has a defaultProp
+							// e.g. ( NOT a 'set obj = anotherObj' operation )
+							pDflt = getDefaultProp( refVal );
+						if ( pDflt )
+							refVal = pDflt;
+					}		
+				}
+			}	
+#endif //ENABLE_VBA
+			
 			*refVar = *refVal;
+#ifdef ENABLE_VBA
+	// lhs is a property who's value is currently (Empty e.g. no broadcast yet)
+	// in this case if there is a default prop involved the value of the 
+	// default property may infact be void so the type will also be SbxEMPTY
+	// in this case we do not want to call checkUnoStructCopy 'cause that will
+	// cause an error also
+		if ( !bVBAInterop || ( bVBAInterop && ( refVar->GetType() != SbxEMPTY ) ) )
+#endif //ENABLE_VBA
 			// #67607 Uno-Structs kopieren
 			checkUnoStructCopy( refVal, refVar );
 			if( bFlagsChanged )
@@ -288,6 +426,15 @@ void SbiRuntime::StepSET()
 	StepSET_Impl( refVal, refVar );
 }
 
+void SbiRuntime::StepVBASET()
+{
+	SbxVariableRef refVal = PopVar();
+	SbxVariableRef refVar = PopVar();
+	// don't handle default property
+	StepSET_Impl( refVal, refVar, false );
+}
+
+
 // JSM 07.10.95
 void SbiRuntime::StepLSET()
 {

--- basic.orig/source/classes/sbunoobj.cxx	2005-10-06 23:48:06.000000000 +0100
+++ basic/source/classes/sbunoobj.cxx	2005-10-10 10:25:20.000000000 +0100
@@ -137,6 +137,56 @@
 static OUString defaultNameSpace( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.") );
 static OUString defaultNameSpaceParent( RTL_CONSTASCII_USTRINGPARAM("org.openoffice") );
 
+#ifdef ENABLE_VBA
+// Gets the default property for an uno object. Note: There is some 
+// redirection built in. The property "_$DefaultProp" specifies the name
+// of the default property. This allows the implementing object to change
+// the name of the default property depending on its state.
+
+bool getDefaultPropName( SbUnoObject* pUnoObj, String& sDfltProp )
+{
+	OUString sName;
+	bool result = false;
+	Any aUnoObj = pUnoObj->getUnoAny();
+	Reference< XPropertySet > xProps( aUnoObj, UNO_QUERY );	
+	if ( xProps.is() )
+	{
+		try
+		{
+			if ( xProps->getPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM( "_$DefaultProp" ) ) ) >>= sName )
+			{
+				sDfltProp = sName;
+				result = true;
+			}
+		}
+		catch( Exception& e )
+		{
+		}// swallow exceptions
+	}
+	return result;
+}
+
+SbxVariable* getDefaultProp( SbxVariable* pRef )
+{
+	SbxVariable* pDefaultProp = NULL;		
+	SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
+	if ( !pObj )
+	{
+		SbxBase* pObjVarObj = pRef->GetObject();
+		pObj = PTR_CAST(SbxObject,pObjVarObj);
+	}	
+	if ( pObj && pObj->ISA(SbUnoObject) )
+	{
+		String sDfltPropName;
+		SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);	
+		if ( getDefaultPropName( pUnoObj, sDfltPropName ) )
+		{
+			pDefaultProp = pUnoObj->Find( sDfltPropName , SbxCLASS_PROPERTY );
+		}
+	}
+	return pDefaultProp;
+}
+#endif // ENABLE_VBA
 
 Reference< XComponentContext > getComponentContext_Impl( void )
 {
@@ -551,6 +572,16 @@
 			// SbUnoObject instanzieren
 			String aName;
 			SbUnoObject* pSbUnoObject = new SbUnoObject( aName, aValue );
+#ifdef ENABLE_VBA
+			String sDfltPropName;
+			if ( getDefaultPropName( pSbUnoObject, sDfltPropName ) )
+			{
+				SbxProperty* pDefaultProp = ( SbxProperty*)pSbUnoObject->Find( 
+					String ( sDfltPropName ), SbxCLASS_PROPERTY );
+				if ( pDefaultProp )
+					pSbUnoObject->SetDfltProperty( pDefaultProp );
+			}
+#endif //ENABLE_VBA
 			SbxObjectRef xWrapper = (SbxObject*)pSbUnoObject;
 
 			// #51475 Wenn das Objekt ungueltig ist null liefern
