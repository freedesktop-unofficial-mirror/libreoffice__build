Index: comp/exprtree.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprtree.cxx,v
retrieving revision 1.24
diff -u -r1.24 exprtree.cxx
--- basic/source/comp/exprtree.cxx	2 Jul 2008 09:58:29 -0000	1.24
+++ basic/source/comp/exprtree.cxx	6 Aug 2008 12:13:04 -0000
@@ -505,8 +505,15 @@
 			pParser->Next();
 			pRes = new SbiExprNode( pParser, pParser->GetSym() ); break;
 		case LPAREN:
-			nParenLevel++;
 			pParser->Next();
+			if( nParenLevel == 0 && m_eMode == EXPRMODE_LPAREN_PENDING && pParser->Peek() == RPAREN )
+			{
+				m_eMode = EXPRMODE_EMPTY_PAREN;
+				pRes = new SbiExprNode();	// Dummy node
+				pParser->Next();
+				break;
+			}
+			nParenLevel++;
 			pRes = Boolean();
 			if( pParser->Peek() != RPAREN )
 			{
@@ -581,9 +588,12 @@
 SbiExprNode* SbiExpression::Exp()
 {
 	SbiExprNode* pNd = Unary();
-	while( pParser->Peek() == EXPON ) {
-		SbiToken eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Unary() );
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
+	{
+		while( pParser->Peek() == EXPON ) {
+			SbiToken eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Unary() );
+		}
 	}
 	return pNd;
 }
@@ -591,13 +601,16 @@
 SbiExprNode* SbiExpression::MulDiv()
 {
 	SbiExprNode* pNd = Exp();
-	for( ;; )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		SbiToken eTok = pParser->Peek();
-		if( eTok != MUL && eTok != DIV )
-			break;
-		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Exp() );
+		for( ;; )
+		{
+			SbiToken eTok = pParser->Peek();
+			if( eTok != MUL && eTok != DIV )
+				break;
+			eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Exp() );
+		}
 	}
 	return pNd;
 }
@@ -605,9 +618,12 @@
 SbiExprNode* SbiExpression::IntDiv()
 {
 	SbiExprNode* pNd = MulDiv();
-	while( pParser->Peek() == IDIV ) {
-		SbiToken eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, MulDiv() );
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
+	{
+		while( pParser->Peek() == IDIV ) {
+			SbiToken eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, MulDiv() );
+		}
 	}
 	return pNd;
 }
@@ -615,9 +631,12 @@
 SbiExprNode* SbiExpression::Mod()
 {
 	SbiExprNode* pNd = IntDiv();
-	while( pParser->Peek() == MOD ) {
-		SbiToken eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, IntDiv() );
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
+	{
+		while( pParser->Peek() == MOD ) {
+			SbiToken eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, IntDiv() );
+		}
 	}
 	return pNd;
 }
@@ -625,13 +644,16 @@
 SbiExprNode* SbiExpression::AddSub()
 {
 	SbiExprNode* pNd = Mod();
-	for( ;; )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		SbiToken eTok = pParser->Peek();
-		if( eTok != PLUS && eTok != MINUS )
-			break;
-		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Mod() );
+		for( ;; )
+		{
+			SbiToken eTok = pParser->Peek();
+			if( eTok != PLUS && eTok != MINUS )
+				break;
+			eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Mod() );
+		}
 	}
 	return pNd;
 }
@@ -639,13 +661,16 @@
 SbiExprNode* SbiExpression::Cat()
 {
 	SbiExprNode* pNd = AddSub();
-	for( ;; )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		SbiToken eTok = pParser->Peek();
-		if( eTok != CAT )
-			break;
-		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, AddSub() );
+		for( ;; )
+		{
+			SbiToken eTok = pParser->Peek();
+			if( eTok != CAT )
+				break;
+			eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, AddSub() );
+		}
 	}
 	return pNd;
 }
@@ -653,24 +678,27 @@
 SbiExprNode* SbiExpression::Comp()
 {
 	SbiExprNode* pNd = Cat();
-	short nCount = 0;
-	for( ;; )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		SbiToken eTok = pParser->Peek();
-		if( m_eMode == EXPRMODE_ARRAY_OR_OBJECT )
-			break;
-		if( eTok != EQ && eTok != NE && eTok != LT
-		 && eTok != GT && eTok != LE && eTok != GE )
-			break;
-		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Cat() );
-		nCount++;
-	}
-	// Mehrere Operatoren hintereinander gehen nicht
-	if( nCount > 1 )
-	{
-		pParser->Error( SbERR_SYNTAX );
-		bError = TRUE;
+		short nCount = 0;
+		for( ;; )
+		{
+			SbiToken eTok = pParser->Peek();
+			if( m_eMode == EXPRMODE_ARRAY_OR_OBJECT )
+				break;
+			if( eTok != EQ && eTok != NE && eTok != LT
+			 && eTok != GT && eTok != LE && eTok != GE )
+				break;
+			eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Cat() );
+			nCount++;
+		}
+		// Mehrere Operatoren hintereinander gehen nicht
+		if( nCount > 1 )
+		{
+			pParser->Error( SbERR_SYNTAX );
+			bError = TRUE;
+		}
 	}
 	return pNd;
 }
@@ -678,16 +706,19 @@
 SbiExprNode* SbiExpression::Like()
 {
 	SbiExprNode* pNd = Comp();
-	short nCount = 0;
-	while( pParser->Peek() == LIKE ) {
-		SbiToken eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Comp() ), nCount++;
-	}
-	// Mehrere Operatoren hintereinander gehen nicht
-	if( nCount > 1 )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		pParser->Error( SbERR_SYNTAX );
-		bError = TRUE;
+		short nCount = 0;
+		while( pParser->Peek() == LIKE ) {
+			SbiToken eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Comp() ), nCount++;
+		}
+		// Mehrere Operatoren hintereinander gehen nicht
+		if( nCount > 1 )
+		{
+			pParser->Error( SbERR_SYNTAX );
+			bError = TRUE;
+		}
 	}
 	return pNd;
 }
@@ -695,14 +726,17 @@
 SbiExprNode* SbiExpression::Boolean()
 {
 	SbiExprNode* pNd = Like();
-	for( ;; )
+	if( m_eMode != EXPRMODE_EMPTY_PAREN )
 	{
-		SbiToken eTok = pParser->Peek();
-		if( eTok != AND && eTok != OR && eTok != XOR
-		 && eTok != EQV && eTok != IMP && eTok != IS )
-			break;
-		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Like() );
+		for( ;; )
+		{
+			SbiToken eTok = pParser->Peek();
+			if( eTok != AND && eTok != OR && eTok != XOR
+			 && eTok != EQV && eTok != IMP && eTok != IS )
+				break;
+			eTok = pParser->Next();
+			pNd = new SbiExprNode( pParser, pNd, eTok, Like() );
+		}
 	}
 	return pNd;
 }
@@ -924,6 +958,12 @@
 					bAssumeArrayMode = true;
 					eTok = NIL;
 				}
+				else if( eModeAfter == EXPRMODE_EMPTY_PAREN )
+				{
+					bBracket = TRUE;
+					delete pExpr;
+					return;
+				}
 			}
 			else
 				pExpr = new SbiExpression( pParser );
Index: comp/exprnode.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprnode.cxx,v
retrieving revision 1.19
diff -u -r1.19 exprnode.cxx
--- basic/source/comp/exprnode.cxx	24 Jun 2008 16:01:40 -0000	1.19
+++ basic/source/comp/exprnode.cxx	6 Aug 2008 12:13:05 -0000
@@ -39,6 +39,13 @@
 
 //////////////////////////////////////////////////////////////////////////
 
+SbiExprNode::SbiExprNode( void )
+{
+	pLeft = NULL;
+	pRight = NULL;
+	eNodeType = SbxDUMMY;
+}
+
 SbiExprNode::SbiExprNode( SbiParser* p, SbiExprNode* l, SbiToken t, SbiExprNode* r )
 {
 	BaseInit( p );
Index: inc/expr.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/expr.hxx,v
retrieving revision 1.15
diff -u -r1.15 expr.hxx
--- basic/source/inc/expr.hxx	26 Jun 2008 21:16:55 -0000	1.15
+++ basic/source/inc/expr.hxx	6 Aug 2008 12:13:05 -0000
@@ -67,9 +67,10 @@
 	EXPRMODE_STANDALONE,            // a param1, param2 OR a( param1, param2 ) = 42
 	EXPRMODE_LPAREN_PENDING,        // start of parameter list with bracket, special handling
 	EXPRMODE_LPAREN_NOT_NEEDED,     // pending LPAREN has not been used
-	EXPRMODE_ARRAY_OR_OBJECT        // '=' or '(' or '.' found after ')' on ParenLevel 0, stopping
+	EXPRMODE_ARRAY_OR_OBJECT,       // '=' or '(' or '.' found after ')' on ParenLevel 0, stopping
 									// expression, assuming array syntax a(...)[(...)] = ?
 									// or a(...).b(...)
+	EXPRMODE_EMPTY_PAREN            // It turned out that the paren don't contain anything: a()
 };
 
 enum SbiNodeType {
@@ -77,7 +78,8 @@
 	SbxSTRVAL,                      // aStrVal = Wert, before #i59791/#i45570: nStringId = Wert
 	SbxVARVAL,                      // aVar = Wert
 	SbxTYPEOF,                      // TypeOf ObjExpr Is Type
-	SbxNODE							// Node
+	SbxNODE,						// Node
+	SbxDUMMY
 };
 
 enum RecursiveMode
@@ -117,6 +119,7 @@
 	void  GenElement( SbiOpcode );  // Element
 	void  BaseInit( SbiParser* p );	// Hilfsfunktion fuer Ctor, AB 17.12.95
 public:
+	SbiExprNode( void );
 	SbiExprNode( SbiParser*, double, SbxDataType );
 	SbiExprNode( SbiParser*, const String& );
 	SbiExprNode( SbiParser*, const SbiSymDef&, SbxDataType, SbiExprList* = NULL );

