Index: source/classes/disas.cxx
===================================================================
RCS file: /cvs/script/basic/source/classes/disas.cxx,v
retrieving revision 1.26
retrieving revision 1.26.16.2
diff -u -r1.26 -r1.26.16.2
--- basic/source/classes/disas.cxx	28 Jan 2008 13:59:35 -0000	1.26
+++ basic/source/classes/disas.cxx	4 Apr 2008 10:44:57 -0000	1.26.16.2
@@ -98,7 +98,9 @@
 	"RSET",             // Speichern Objekt TOS ==> TOS-1
     "REDIMP_ERASE",
     "INITFOREACH",
-	"VBASET"
+	"VBASET",
+	"ERASE_CLEAR",
+	"ARRAYACCESS"
 };
 
 static const char* pOp2[] = {
@@ -128,6 +130,7 @@
 	// Neues ab Beta 3
 	"BASED",			// TOS wird um BASE erhoeht, BASE davor gepusht
 	"ARGTYP",          	// Letzten Parameter in Argv konvertieren (+Typ)
+	"VBASETCLASS",
 };
 
 static const char* pOp3[] = {
@@ -156,6 +159,7 @@
     "FIND_G",        	// Sucht globale Variable mit Spezialbehandlung wegen _GLOBAL_P
 	"DCREATE_REDIMP",	// User defined Objekt-Array redimensionieren (+StringId+StringId)
 	"FIND_CM",        	// Search inside a class module (CM) to enable global search in time
+	"PUBLIC_P",        	// Module global Variable (persisted between calls)(+StringID+Typ)
 };
 
 static const char** pOps[3] = { pOp1, pOp2, pOp3 };
@@ -187,7 +191,8 @@
 	&SbiDisas::StrOp,	// TESTCLASS, Check TOS class (+StringId)
 	&SbiDisas::StrOp,	// Libnamen fuer Declare-Procs setzen (+StringId)
 	&SbiDisas::ImmOp,	// TOS wird um BASE erhoeht, BASE davor gepusht
-	&SbiDisas::TypeOp,  	// Letzten Parameter in Argv konvertieren (+Typ)
+	&SbiDisas::TypeOp,  // Letzten Parameter in Argv konvertieren (+Typ)
+	&SbiDisas::StrOp,	// VBASETCLASS (+StringId)
 };
 
 static const Func pOperand3[] = {
@@ -207,15 +212,16 @@
 	&SbiDisas::VarDefOp, // Lokale Variable definieren (+StringID+Typ)
 	&SbiDisas::VarDefOp, // Modulglobale Variable definieren (+StringID+Typ)
 	&SbiDisas::VarDefOp, // Globale Variable definieren (+StringID+Typ)
-	&SbiDisas::Str2Op,	// Objekt kreieren (+StringId+StringId)
+	&SbiDisas::Str2Op,	 // Objekt kreieren (+StringId+StringId)
 	&SbiDisas::VarDefOp, // Statische Variable definieren (+StringID+Typ)
-	&SbiDisas::Str2Op,	// User defined Objekt kreieren (+StringId+StringId)
-	&SbiDisas::Str2Op,	// User defined Objekt-Array kreieren (+StringId+StringId)
+	&SbiDisas::Str2Op,	 // User defined Objekt kreieren (+StringId+StringId)
+	&SbiDisas::Str2Op,	 // User defined Objekt-Array kreieren (+StringId+StringId)
 	&SbiDisas::VarDefOp, // Globale Variable definieren, die beim Neustart von Basic
                                 // nicht ueberschrieben wird, P=PERSIST (+StringID+Typ)
     &SbiDisas::VarOp,    // Sucht globale Variable mit Spezialbehandlung wegen _GLOBAL_P
-	&SbiDisas::Str2Op,	// User defined Objekt-Array redimensionieren (+StringId+StringId)
-	&SbiDisas::VarOp,	// FIND_CM
+	&SbiDisas::Str2Op,	 // User defined Objekt-Array redimensionieren (+StringId+StringId)
+	&SbiDisas::VarOp,	 // FIND_CM
+	&SbiDisas::VarDefOp, // PUBLIC_P
 };
 
 
@@ -248,7 +254,7 @@
 	nLine = 0;
 	nOff = 0;
 	nPC = 0;
-	nOp1 = nOp2 = nParts = (USHORT) 0;
+	nOp1 = nOp2 = nParts = 0;
 	eOp = _NOP;
 	// Label-Bits setzen
 	nOff = 0;
@@ -266,7 +272,7 @@
 			case _CASEIS:
 			case _CASETO:
 			case _ERRHDL:
-                cLabels[ nOp1 >> 3 ] |= ( 1 << ( nOp1 & 7 ) );
+                cLabels[ (nOp1 & 0xffff) >> 3 ] |= ( 1 << ( nOp1 & 7 ) );
                 break;
 			default: break;
 		}
@@ -291,7 +297,7 @@
 	nPC = nOff;
 	if( nOff >= rImg.GetCodeSize() )
 		return FALSE;
-	const char* p = rImg.GetCode() + nOff;
+	const unsigned char* p = (const unsigned char*)( rImg.GetCode() + nOff );
 	eOp = (SbiOpcode) ( *p++ & 0xFF );
 	if( eOp <= SbOP0_END )
 	{
@@ -302,20 +308,20 @@
 	}
 	else if( eOp <= SbOP1_END )
 	{
-		nOff += 3;
+		nOff += 5;
 		if( nOff > rImg.GetCodeSize() )
 			return FALSE;
-		nOp1 = *p++ & 0xFF; nOp1 |= *p << 8;
+		nOp1 = *p++; nOp1 |= *p++ << 8; nOp1 |= *p++ << 16; nOp1 |= *p++ << 24;
 		nParts = 2;
 		return TRUE;
 	}
 	else if( eOp <= SbOP2_END )
 	{
-		nOff += 5;
+		nOff += 9;
 		if( nOff > rImg.GetCodeSize() )
 			return FALSE;
-		nOp1 = *p++ & 0xFF; nOp1 |= *p++ << 8;
-		nOp2 = *p++ & 0xFF; nOp2 |= *p   << 8;
+		nOp1 = *p++; nOp1 |= *p++ << 8; nOp1 |= *p++ << 16; nOp1 |= *p++ << 24;
+		nOp2 = *p++; nOp2 |= *p++ << 8; nOp2 |= *p++ << 16; nOp2 |= *p++ << 24;
 		nParts = 3;
 		return TRUE;
 	}
@@ -349,21 +355,23 @@
 
 BOOL SbiDisas::DisasLine( String& rText )
 {
-	char cBuf[ 30 ];
+	char cBuf[ 100 ];
 	const char* pMask[] = {
-		"%08" SAL_PRIXUINT32 "                ",
-		"%08" SAL_PRIXUINT32 " %02X           ",
-		"%08" SAL_PRIXUINT32 " %02X %04X      ",
-		"%08" SAL_PRIXUINT32 " %02X %04X %04X " };
+		"%08" SAL_PRIXUINT32 "                            ",
+		"%08" SAL_PRIXUINT32 " %02X                   ",
+		"%08" SAL_PRIXUINT32 " %02X %08X          ",
+		"%08" SAL_PRIXUINT32 " %02X %08X %08X " };
 	rText.Erase();
 	if( !Fetch() )
 		return FALSE;
 	// Neue Zeile?
-	if( eOp == _STMNT && (short) nOp1 != nLine )
+	if( eOp == _STMNT && nOp1 != nLine )
 	{
 		// Zeile raussuchen
         String aSource = rImg.aOUSource;
-		USHORT n = 0, l = nLine = nOp1;
+		nLine = nOp1;
+		USHORT n = 0;
+		USHORT l = (USHORT)nLine;
 		while( --l ) {
 			n = aSource.SearchAscii( "\n", n );
 			if( n == STRING_NOTFOUND ) break;
@@ -449,7 +457,7 @@
 
 void SbiDisas::StrOp( String& rText )
 {
-	String aStr = rImg.GetString( nOp1 );
+	String aStr = rImg.GetString( (USHORT)nOp1 );
 	ByteString aByteString( aStr, RTL_TEXTENCODING_ASCII_US );
 	const char* p = aByteString.GetBuffer();
 	if( p )
@@ -461,7 +469,7 @@
 	else
 	{
 		rText.AppendAscii( "?String? " );
-		rText += nOp1;
+		rText += (USHORT)nOp1;
 	}
 }
 
@@ -555,17 +563,17 @@
 		rText += '\'';
 	else
 		rText.AppendAscii( "char " ),
-		rText += nOp1;
+		rText += (USHORT)nOp1;
 }
 
 // Variable ausgeben: String-ID und Typ
 
 void SbiDisas::VarOp( String& rText )
 {
-	rText += rImg.GetString( nOp1 & 0x7FFF );
+	rText += rImg.GetString( (USHORT)(nOp1 & 0x7FFF) );
 	rText.AppendAscii( "\t; " );
 	// Der Typ
-	USHORT n = nOp1;
+	UINT32 n = nOp1;
 	nOp1 = nOp2;
 	TypeOp( rText );
 	if( n & 0x8000 )
@@ -576,7 +584,7 @@
 
 void SbiDisas::VarDefOp( String& rText )
 {
-	rText += rImg.GetString( nOp1 );
+	rText += rImg.GetString( (USHORT)(nOp1 & 0x7FFF) );
 	rText.AppendAscii( "\t; " );
 	// Der Typ
 	nOp1 = nOp2;
@@ -590,7 +598,7 @@
 	rText += String::CreateFromInt32( nOp1 & 0x7FFF );
 	rText.AppendAscii( "\t; " );
 	// Der Typ
-	USHORT n = nOp1;
+	UINT32 n = nOp1;
 	nOp1 = nOp2;
 	TypeOp( rText );
 	if( n & 0x8000 )
@@ -626,7 +634,7 @@
 	else
 	{
 		rText.AppendAscii( "type " );
-		rText += nOp1;
+		rText += (USHORT)nOp1;
 	}
 }
 #ifdef HP9000
@@ -648,8 +656,8 @@
 {
 	rText += String::CreateFromInt32( nOp1 );
 	rText += ',';
-	USHORT nCol = nOp2 & 0xFF;
-	USHORT nFor = nOp2 / 0x100;
+	UINT32 nCol = nOp2 & 0xFF;
+	UINT32 nFor = nOp2 / 0x100;
     rText += String::CreateFromInt32( nCol );
 	rText.AppendAscii( " (For-Level: " );
 	rText += String::CreateFromInt32( nFor );
Index: basic/source/comp/exprgen.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprgen.cxx,v
retrieving revision 1.16
retrieving revision 1.16.150.1
diff -u -r1.16 -r1.16.150.1
--- basic/source/comp/exprgen.cxx	12 Oct 2006 14:26:47 -0000	1.16
+++ basic/source/comp/exprgen.cxx	4 Apr 2008 10:52:57 -0000	1.16.150.1
@@ -182,6 +182,7 @@
 		nId |= 0x8000;
 		aVar.pPar->Gen();
 	}
+		
 	SbiProcDef* pProc = aVar.pDef->GetProcDef();
 	// per DECLARE definiert?
 	if( pProc )
@@ -194,6 +195,18 @@
 			nId = ( nId & 0x8000 ) | pGen->GetParser()->aGblStrings.Add( pProc->GetAlias() );
 	}
 	pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
+
+	if( aVar.pvMorePar )
+	{
+		SbiExprListVector* pvMorePar = aVar.pvMorePar;
+		SbiExprListVector::iterator it;
+		for( it = pvMorePar->begin() ; it != pvMorePar->end() ; ++it )
+		{
+			SbiExprList* pExprList = *it;
+			pExprList->Gen();
+			pGen->Gen( _ARRAYACCESS );
+		}
+	}
 }
 
 // Erzeugen einer Argv-Tabelle
Index: basic/source/comp/exprnode.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprnode.cxx,v
retrieving revision 1.17
retrieving revision 1.17.60.1
diff -u -r1.17 -r1.17.60.1
--- basic/source/comp/exprnode.cxx	30 Aug 2007 09:59:55 -0000	1.17
+++ basic/source/comp/exprnode.cxx	4 Apr 2008 10:53:41 -0000	1.17.60.1
@@ -83,6 +83,7 @@
 	eNodeType = SbxVARVAL;
 	aVar.pDef = (SbiSymDef*) &r;
 	aVar.pPar = l;
+	aVar.pvMorePar = NULL;
 	aVar.pNext= NULL;
 
 	// Funktionsergebnisse sind nie starr
@@ -121,6 +122,14 @@
 	{
 		delete aVar.pPar;
 		delete aVar.pNext;
+		SbiExprListVector* pvMorePar = aVar.pvMorePar;
+		if( pvMorePar )
+		{
+			SbiExprListVector::iterator it;
+			for( it = pvMorePar->begin() ; it != pvMorePar->end() ; ++it )
+				delete *it;
+			delete pvMorePar;
+		}
 	}
 }
 
Index: basic/source/comp/exprtree.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprtree.cxx,v
retrieving revision 1.21
diff -u -r1.21 exprtree.cxx
--- basic/source/comp/exprtree.cxx	27 Feb 2008 10:33:36 -0000	1.21
+++ basic/source/comp/exprtree.cxx	30 May 2008 11:58:19 -0000
@@ -46,12 +46,14 @@
 |*
 ***************************************************************************/
 
-SbiExpression::SbiExpression( SbiParser* p, SbiExprType t )
+SbiExpression::SbiExpression( SbiParser* p, SbiExprType t, SbiExprMode eMode )
 {
 	pParser = p;
-	bError = bByVal = bBased = FALSE;
+	bError = bByVal = bBased = bBracket = FALSE;
+	nParenLevel = 0;
 	eCurExpr = t;
-	pNext = NULL;
+	m_eMode = eMode;
+	pNext = NULL;	
 	pExpr = (t != SbSTDEXPR ) ? Term() : Boolean();
 	if( t != SbSYMBOL )
 		pExpr->Optimize();
@@ -66,7 +68,7 @@
 	pParser = p;
 	eCurExpr = SbOPERAND;
 	pNext = NULL;
-	bError = bByVal = bBased = FALSE;
+	bError = bByVal = bBased = bBracket = FALSE;
 	pExpr = new SbiExprNode( pParser, n, t );
 	pExpr->Optimize();
 }
@@ -75,7 +77,7 @@
 {
 	pParser = p;
 	pNext = NULL;
-	bError = bByVal = bBased = FALSE;
+	bError = bByVal = bBased = bBracket = FALSE;
 	eCurExpr = SbOPERAND;
 	pExpr = new SbiExprNode( pParser, r );
 }
@@ -84,7 +86,7 @@
 {
 	pParser = p;
 	pNext = NULL;
-	bError = bByVal = bBased = FALSE;
+	bError = bByVal = bBased = bBracket = FALSE;
 	eCurExpr = SbOPERAND;
 	pExpr = new SbiExprNode( pParser, r, SbxVARIANT, pPar );
 }
@@ -93,7 +95,7 @@
 {
 	pParser = p;
 	pNext = NULL;
-	bError = bByVal = bBased = FALSE;
+	bError = bByVal = bBased = bBracket = FALSE;
 	eCurExpr = SbOPERAND;
 	pExpr = new SbiExprNode( pParser, NULL, t, NULL );
 }
@@ -119,7 +121,7 @@
 	// Aber nur, wenn CALL-aehnlich!
 	if( !p->WhiteSpace() || eCurExpr != SbSYMBOL )
 		return FALSE;
-	if (   eTok == NUMBER || eTok == FIXSTRING
+	if (   eTok == NUMBER || eTok == MINUS || eTok == FIXSTRING
 		|| eTok == SYMBOL || eTok == COMMA  || eTok == DOT )
 	{
 		return TRUE;
@@ -183,7 +185,7 @@
 
 // Zur Zeit sind sogar Keywords zugelassen (wg. gleichnamiger Dflt-Properties)
 
-SbiExprNode* SbiExpression::Term()
+SbiExprNode* SbiExpression::Term( void )
 {
 	if( pParser->Peek() == DOT )
 	{
@@ -216,6 +218,7 @@
 	String aSym( pParser->GetSym() );
 	SbxDataType eType = pParser->GetType();
 	SbiParameters* pPar = NULL;
+	SbiExprListVector* pvMoreParLcl = NULL;
 	// Folgen Parameter?
 	SbiToken eNextTok = pParser->Peek();
 	// Ist es ein benannter Parameter?
@@ -242,9 +245,23 @@
 
 	if( DoParametersFollow( pParser, eCurExpr, eTok = eNextTok ) )
 	{
-		pPar = new SbiParameters( pParser );
+		bool bStandaloneExpression = (m_eMode == EXPRMODE_STANDALONE);
+		pPar = new SbiParameters( pParser, bStandaloneExpression );
 		bError |= !pPar->IsValid();
+		if( !bError )
+			bBracket = pPar->IsBracket();
 		eTok = pParser->Peek();
+
+		// i75443 check for additional sets of parameters
+		while( eTok == LPAREN )
+		{
+			if( pvMoreParLcl == NULL )
+				pvMoreParLcl = new SbiExprListVector();
+			SbiParameters* pAddPar = new SbiParameters( pParser );
+			pvMoreParLcl->push_back( pAddPar );
+			bError |= !pPar->IsValid();
+			eTok = pParser->Peek();
+		}
 	}
 	// Es koennte ein Objektteil sein, wenn . oder ! folgt
 	// Bei . muss aber die Variable bereits definiert sein; wenn pDef
@@ -253,6 +270,7 @@
 					&& !pParser->WhiteSpace() );
 	if( bObj )
 	{
+		bBracket = FALSE;	// Now the bracket for the first term is obsolete
 		if( eType == SbxVARIANT )
 			eType = SbxOBJECT;
 		else
@@ -350,6 +368,7 @@
 	if( !pPar )
 		pPar = new SbiParameters( pParser,FALSE,FALSE );
 	pNd->aVar.pPar = pPar;
+	pNd->aVar.pvMorePar = pvMoreParLcl;
 	if( bObj )
 	{
 		// AB, 8.1.95: Objekt kann auch vom Typ SbxVARIANT sein
@@ -486,11 +505,30 @@
 			pParser->Next();
 			pRes = new SbiExprNode( pParser, pParser->GetSym() ); break;
 		case LPAREN:
+			nParenLevel++;
 			pParser->Next();
 			pRes = Boolean();
 			if( pParser->Peek() != RPAREN )
-				pParser->Error( SbERR_BAD_BRACKETS );
-			else pParser->Next();
+			{
+				// If there was a LPARAM, it does not belong to the expression
+				if( nParenLevel == 1 && m_eMode == EXPRMODE_LPAREN_PENDING )
+					m_eMode = EXPRMODE_LPAREN_NOT_NEEDED;
+				else
+					pParser->Error( SbERR_BAD_BRACKETS );
+			}
+			else
+			{
+				pParser->Next();
+				if( nParenLevel == 1 && m_eMode == EXPRMODE_LPAREN_PENDING )
+				{
+					SbiToken eTokAfterRParen = pParser->Peek();
+					if( eTokAfterRParen == EQ || eTokAfterRParen == LPAREN || eTokAfterRParen == DOT )
+						m_eMode = EXPRMODE_ARRAY_OR_OBJECT;
+					else
+						m_eMode = EXPRMODE_STANDARD;
+				}
+			}
+			nParenLevel--;
 			pRes->bComposite = TRUE;
 			break;
 		default:
@@ -619,6 +657,8 @@
 	for( ;; )
 	{
 		SbiToken eTok = pParser->Peek();
+		if( m_eMode == EXPRMODE_ARRAY_OR_OBJECT )
+			break;
 		if( eTok != EQ && eTok != NE && eTok != LT
 		 && eTok != GT && eTok != LE && eTok != GE )
 			break;
@@ -813,45 +853,85 @@
 // Dann handelt es sich um eine Funktion ohne Parameter
 // respektive um die Angabe eines Arrays als Prozedurparameter.
 
-SbiParameters::SbiParameters( SbiParser* p, BOOL bConst, BOOL bPar) :
+// #i79918/#i80532: bConst has never been set to true
+// -> reused as bStandaloneExpression
+//SbiParameters::SbiParameters( SbiParser* p, BOOL bConst, BOOL bPar) :
+SbiParameters::SbiParameters( SbiParser* p, BOOL bStandaloneExpression, BOOL bPar) :
 	SbiExprList( p )
 {
-	if (bPar)
-	{
-		SbiExpression *pExpr;
-		SbiToken eTok = pParser->Peek();
+	if( !bPar )
+		return;
 
-		// evtl. Klammer auf weg:
-		if( eTok == LPAREN )
+	SbiExpression *pExpr;
+	SbiToken eTok = pParser->Peek();
+
+	// evtl. Klammer auf weg:
+	bool bAssumeExprLParenMode = false;
+	bool bAssumeArrayMode = false;
+	if( eTok == LPAREN )
+	{
+		if( bStandaloneExpression )
 		{
-			bBracket = TRUE; pParser->Next(); eTok = pParser->Peek();
+			bAssumeExprLParenMode = true;
 		}
-
-		// Ende-Test
-		if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
+		else
 		{
-			if( eTok == RPAREN )
-				pParser->Next();
-			return;
+			bBracket = TRUE;
+			pParser->Next();
+			eTok = pParser->Peek();
 		}
-		// Parametertabelle einlesen und in richtiger Folge ablegen!
-		SbiExpression* pLast = NULL;
-		String aName;
-		while( !bError )
-		{
-			aName.Erase();
-			// Fehlendes Argument
-			if( eTok == COMMA )
-			{
-				pExpr = new SbiExpression( pParser, 0, SbxEMPTY );
-				if( bConst )
-					pParser->Error( SbERR_SYNTAX ), bError = TRUE;
+	}
+
+	// Ende-Test
+	if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
+	{
+		if( eTok == RPAREN )
+			pParser->Next();
+		return;
+	}
+	// Parametertabelle einlesen und in richtiger Folge ablegen!
+	SbiExpression* pLast = NULL;
+	String aName;
+	while( !bError )
+	{
+		aName.Erase();
+		// Fehlendes Argument
+		if( eTok == COMMA )
+		{
+			pExpr = new SbiExpression( pParser, 0, SbxEMPTY );
+			//if( bConst )
+			//	pParser->Error( SbERR_SYNTAX ), bError = TRUE;
+		}
+		// Benannte Argumente: entweder .name= oder name:=
+		else
+		{
+			if( bAssumeExprLParenMode )
+			{
+				pExpr = new SbiExpression( pParser, SbSTDEXPR, EXPRMODE_LPAREN_PENDING );
+				bAssumeExprLParenMode = FALSE;
+
+				SbiExprMode eModeAfter = pExpr->m_eMode;
+				if( eModeAfter == EXPRMODE_LPAREN_NOT_NEEDED )
+				{
+					bBracket = TRUE;
+				}
+				else if( eModeAfter == EXPRMODE_ARRAY_OR_OBJECT )
+				{
+					// Expression "looks" like an array assignment
+					// a(...)[(...)] = ? or a(...).b(...)
+					// RPAREN is already parsed
+					bBracket = TRUE;
+					bAssumeArrayMode = true;
+					eTok = NIL;
+				}
 			}
-			// Benannte Argumente: entweder .name= oder name:=
 			else
+				pExpr = new SbiExpression( pParser );
+
+			//pExpr = bConst ? new SbiConstExpression( pParser )
+			//				: new SbiExpression( pParser );
+			if( !bAssumeArrayMode )
 			{
-				pExpr = bConst ? new SbiConstExpression( pParser )
-								: new SbiExpression( pParser );
 				if( pParser->Peek() == ASSIGN )
 				{
 					// VBA mode: name:=
@@ -860,50 +940,54 @@
 					delete pExpr;
 					pParser->Next();
 					pExpr = new SbiExpression( pParser );
-					if( bConst )
-						pParser->Error( SbERR_SYNTAX ), bError = TRUE;
+					//if( bConst )
+					//	pParser->Error( SbERR_SYNTAX ), bError = TRUE;
 				}
 				pExpr->GetName() = aName;
 			}
-			pExpr->pNext = NULL;
-			if( !pLast )
-				pFirst = pLast = pExpr;
-			else
-				pLast->pNext = pExpr, pLast = pExpr;
-			nExpr++;
-			bError |= !pExpr->IsValid();
-			// Naechstes Element?
-			eTok = pParser->Peek();
-			if( eTok != COMMA )
-			{
-				if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
-					break;
-				pParser->Error( bBracket
-								? SbERR_BAD_BRACKETS
-								: SbERR_EXPECTED, COMMA );
-				bError = TRUE;
-			}
-			else
-			{
-				pParser->Next();
-				eTok = pParser->Peek();
-				if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
-					break;
-			}
 		}
-		// Schliessende Klammer
-		if( eTok == RPAREN )
+		pExpr->pNext = NULL;
+		if( !pLast )
+			pFirst = pLast = pExpr;
+		else
+			pLast->pNext = pExpr, pLast = pExpr;
+		nExpr++;
+		bError |= !pExpr->IsValid();
+
+		if( bAssumeArrayMode )
+			break;
+
+		// Naechstes Element?
+		eTok = pParser->Peek();
+		if( eTok != COMMA )
+		{
+			if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
+				break;
+			pParser->Error( bBracket
+							? SbERR_BAD_BRACKETS
+							: SbERR_EXPECTED, COMMA );
+			bError = TRUE;
+		}
+		else
 		{
 			pParser->Next();
-			pParser->Peek();
-			if( !bBracket )
-			{
-				pParser->Error( SbERR_BAD_BRACKETS );
-				bError = TRUE;
-			}
+			eTok = pParser->Peek();
+			if( ( bBracket && eTok == RPAREN ) || pParser->IsEoln( eTok ) )
+				break;
+		}
+	}
+	// Schliessende Klammer
+	if( eTok == RPAREN )
+	{
+		pParser->Next();
+		pParser->Peek();
+		if( !bBracket )
+		{
+			pParser->Error( SbERR_BAD_BRACKETS );
+			bError = TRUE;
 		}
-		nDim = nExpr;
 	}
+	nDim = nExpr;
 }
 
 /***************************************************************************
Index: basic/source/comp/parser.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/parser.cxx,v
retrieving revision 1.22
retrieving revision 1.22.54.1
diff -u -r1.22 -r1.22.54.1
--- basic/source/comp/parser.cxx	6 Sep 2007 13:54:06 -0000	1.22
+++ basic/source/comp/parser.cxx	1 Apr 2008 09:20:30 -0000	1.22.54.1
@@ -399,7 +399,7 @@
 			Next();
 			Push( eCurTok );
 			aGen.Statement();
-			Symbol();
+				Symbol();
 		}
 	}
 	else
@@ -484,9 +484,13 @@
 
 void SbiParser::Symbol()
 {
-	SbiExpression aVar( this, SbSYMBOL );
+	SbiExprMode eMode = bVBASupportOn ? EXPRMODE_STANDALONE : EXPRMODE_STANDARD;
+	SbiExpression aVar( this, SbSYMBOL, eMode );
 
 	bool bEQ = ( Peek() == EQ );
+	if( !bEQ && bVBASupportOn && aVar.IsBracket() )
+		Error( SbERR_EXPECTED, "=" );
+
 	RecursiveMode eRecMode = ( bEQ ? PREVENT_CALL : FORCE_CALL );
 	bool bSpecialMidHandling = false;
 	SbiSymDef* pDef = aVar.GetRealVar();
Index: basic/source/inc/disas.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/disas.hxx,v
retrieving revision 1.6
retrieving revision 1.6.74.1
diff -u -r1.6 -r1.6.74.1
--- basic/source/inc/disas.hxx	3 Aug 2007 09:55:30 -0000	1.6
+++ basic/source/inc/disas.hxx	31 Mar 2008 11:50:49 -0000	1.6.74.1
@@ -48,9 +48,9 @@
 	UINT32	 nOff;					// aktuelle Position
 	UINT32   nPC;					// Position des Opcodes
 	SbiOpcode eOp;					// Opcode
-	USHORT   nOp1, nOp2;			// Operanden
-	short	 nParts;				// 1, 2 oder 3
-	short	 nLine;					// aktuelle Zeile
+	UINT32   nOp1, nOp2;			// Operanden
+	UINT32	 nParts;				// 1, 2 oder 3
+	UINT32	 nLine;					// aktuelle Zeile
 	BOOL 	 DisasLine( String& );
 	BOOL	 Fetch();				// naechster Opcode
 public:
Index: basic/source/inc/expr.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/expr.hxx,v
retrieving revision 1.12
diff -u -r1.12 expr.hxx
--- basic/source/inc/expr.hxx	27 Feb 2008 10:33:49 -0000	1.12
+++ basic/source/inc/expr.hxx	30 May 2008 11:58:19 -0000
@@ -53,10 +53,15 @@
 class SbiSymDef;
 class SbiProcDef;
 
+
+#include <vector>
+typedef ::std::vector<SbiExprList*> SbiExprListVector;
+
 struct SbVar {                      // Variablen-Element:
-	SbiExprNode*   pNext;			// Weiteres Element (bei Strukturen)
-	SbiSymDef*     pDef;			// Symboldefinition
-	SbiExprList*   pPar;			// optionale Parameter (wird geloescht)
+	SbiExprNode*        pNext;		// Weiteres Element (bei Strukturen)
+	SbiSymDef*          pDef;		// Symboldefinition
+	SbiExprList*        pPar;		// optionale Parameter (wird geloescht)
+	SbiExprListVector*  pvMorePar;  // Array of arrays foo(pPar)(avMorePar[0])(avMorePar[1])...
 };
 
 enum SbiExprType {					// Expression-Typen:
@@ -66,6 +71,16 @@
 	SbOPERAND						// Variable/Funktion
 };
 
+enum SbiExprMode {					// Expression context:
+	EXPRMODE_STANDARD,              // default
+	EXPRMODE_STANDALONE,            // a param1, param2 OR a( param1, param2 ) = 42
+	EXPRMODE_LPAREN_PENDING,        // start of parameter list with bracket, special handling
+	EXPRMODE_LPAREN_NOT_NEEDED,     // pending LPAREN has not been used
+	EXPRMODE_ARRAY_OR_OBJECT,       // '=' or '(' or '.' found after ')' on ParenLevel 0, stopping
+									// expression, assuming array syntax a(...)[(...)] = ?
+									// or a(...).b(...)
+};
+
 enum SbiNodeType {
 	SbxNUMVAL,                      // nVal = Wert
 	SbxSTRVAL,                      // aStrVal = Wert, before #i59791/#i45570: nStringId = Wert
@@ -136,6 +151,7 @@
 	short GetDepth();               // Tiefe eines Baumes berechnen
 	const String& GetString() 		{ return aStrVal; }
 	SbiExprList* GetParameters()	{ return aVar.pPar; }
+	SbiExprListVector* GetMoreParameters()	{ return aVar.pvMorePar; }
 
 	void Optimize();                // Baumabgleich
 
@@ -152,9 +168,12 @@
 	SbiExpression* pNext;            // Link bei Parameterlisten
 	SbiExprNode*   pExpr;            // Der Expression-Baum
 	SbiExprType	  eCurExpr;			// Art des Ausdrucks
+	SbiExprMode   m_eMode;			// Expression context
 	BOOL  		  bBased;			// TRUE: einfacher DIM-Teil (+BASE)
 	BOOL          bError;           // TRUE: Fehler
 	BOOL          bByVal;           // TRUE: ByVal-Parameter
+	BOOL          bBracket;         // TRUE: Parameter list with brackets
+	USHORT        nParenLevel;
 	SbiExprNode* Term();
 	SbiExprNode* ObjTerm( SbiSymDef& );
 	SbiExprNode* Operand();
@@ -169,7 +188,7 @@
 	SbiExprNode* Comp();
 	SbiExprNode* Boolean();
 public:
-	SbiExpression( SbiParser*, SbiExprType = SbSTDEXPR ); // Parsender Ctor
+	SbiExpression( SbiParser*, SbiExprType = SbSTDEXPR, SbiExprMode eMode = EXPRMODE_STANDARD ); // Parsender Ctor
 	SbiExpression( SbiParser*, const String& );
 	SbiExpression( SbiParser*, double, SbxDataType = SbxDOUBLE );
 	SbiExpression( SbiParser*, const SbiSymDef&, SbiExprList* = NULL );
@@ -180,6 +199,7 @@
 	BOOL IsBased()					{ return bBased; 			  }
 	void SetByVal()                 { bByVal = TRUE;              }
 	BOOL IsByVal()                  { return bByVal;              }
+	BOOL IsBracket()                { return bBracket;            }
 	BOOL IsValid()                  { return pExpr->IsValid();    }
 	BOOL IsConstant()               { return pExpr->IsConstant(); }
 	BOOL IsVariable()               { return pExpr->IsVariable(); }
Index: basic/source/inc/opcodes.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/opcodes.hxx,v
retrieving revision 1.12
retrieving revision 1.12.60.1
diff -u -r1.12 -r1.12.60.1
--- basic/source/inc/opcodes.hxx	30 Aug 2007 10:00:44 -0000	1.12
+++ basic/source/inc/opcodes.hxx	4 Apr 2008 10:13:31 -0000	1.12.60.1
@@ -100,6 +100,7 @@
 	_INITFOREACH,
 	_VBASET,            // VBA-like Set
 	_ERASE_CLEAR,       // Erase array and clear variable
+	_ARRAYACCESS,       // Assign parameters to TOS and get value, used for array of arrays
 	SbOP0_END,
 
 	// Alle Opcodes mit einem Operanden
Index: basic/source/inc/runtime.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/runtime.hxx,v
retrieving revision 1.35
retrieving revision 1.35.60.1
diff -u -r1.35 -r1.35.60.1
--- basic/source/inc/runtime.hxx	30 Aug 2007 10:01:05 -0000	1.35
+++ basic/source/inc/runtime.hxx	4 Apr 2008 10:13:31 -0000	1.35.60.1
@@ -451,6 +451,7 @@
 	void StepPRINTF(),	StepWRITE(),    StepRENAME(),   StepPROMPT();
 	void StepRESTART(), StepEMPTY(),    StepLEAVE();
 	void StepLSET(),	StepRSET(),		StepREDIMP_ERASE(), 	StepERASE_CLEAR();
+	void StepARRAYACCESS();
 	// Alle Opcodes mit einem Operanden
 	void StepLOADNC( UINT32 ),  StepLOADSC( UINT32 ),   StepLOADI( UINT32 );
 	void StepARGN( UINT32 ),	StepBASED( UINT32 ),	StepPAD( UINT32 );
Index: basic/source/runtime/runtime.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/runtime.cxx,v
retrieving revision 1.36
retrieving revision 1.36.60.1
diff -u -r1.36 -r1.36.60.1
--- basic/source/runtime/runtime.cxx	30 Aug 2007 10:01:29 -0000	1.36
+++ basic/source/runtime/runtime.cxx	4 Apr 2008 10:28:24 -0000	1.36.60.1
@@ -154,6 +154,7 @@
 	&SbiRuntime::StepINITFOREACH,// Init for each loop
 	&SbiRuntime::StepVBASET,// vba-like set statement
 	&SbiRuntime::StepERASE_CLEAR,// vba-like set statement
+	&SbiRuntime::StepARRAYACCESS,// access TOS as array
 };
 
 SbiRuntime::pStep1 SbiRuntime::aStep1[] = {	// Alle Opcodes mit einem Operanden
Index: basic/source/runtime/step0.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step0.cxx,v
retrieving revision 1.29
retrieving revision 1.29.60.1
diff -u -r1.29 -r1.29.60.1
--- basic/source/runtime/step0.cxx	30 Aug 2007 10:01:41 -0000	1.29
+++ basic/source/runtime/step0.cxx	4 Apr 2008 10:28:24 -0000	1.29.60.1
@@ -908,6 +908,16 @@
 	lcl_clearImpl( refVar, eType );
 }
 
+void SbiRuntime::StepARRAYACCESS()
+{
+	if( !refArgv )
+		StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+    SbxVariableRef refVar = PopVar();
+	refVar->SetParameters( refArgv );
+	PopArgv();
+	PushVar( CheckArray( refVar ) );
+}
+
 // Einrichten eines Argvs
 // nOp1 bleibt so -> 1. Element ist Returnwert
 
