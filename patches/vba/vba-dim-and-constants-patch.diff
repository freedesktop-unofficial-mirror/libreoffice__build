--- basic.orig/source/runtime/step1.cxx	2005-09-19 09:36:54.000000000 +0100
+++ basic/source/runtime/step1.cxx	2005-09-19 09:28:25.000000000 +0100
@@ -71,6 +71,11 @@
 
 #include "segmentc.hxx"
 #pragma SW_SEGMENT_CLASS( SBRUNTIME, SBRUNTIME_CODE )
+#ifdef ENABLE_VBA
+#include <svtools/fltrcfg.hxx>
+bool checkUnoObjectType( SbUnoObject* refVal, 
+	const String& aClass );
+#endif //ENABLE_VBA
 
 // Laden einer numerischen Konstanten (+ID)
 
@@ -141,8 +146,8 @@
 		SbxDataType t = (SbxDataType) (nOp1 & 0x7FFF);
 		SbxVariable* pVar = refArgv->Get( refArgv->Count() - 1 );	// letztes Arg
 
-		// BYVAL prüfen
-		if( pVar->GetRefCount() > 2 )		// 2 ist normal für BYVAL
+		// BYVAL prfen
+		if( pVar->GetRefCount() > 2 )		// 2 ist normal fr BYVAL
 		{
 			// Parameter ist eine Referenz
 			if( bByVal )
@@ -153,7 +158,7 @@
 				refExprStk->Put( pVar, refArgv->Count() - 1 );
 			}
 			else
-				pVar->SetFlag( SBX_REFERENCE );		// Ref-Flag für DllMgr
+				pVar->SetFlag( SBX_REFERENCE );		// Ref-Flag fr DllMgr
 		}
 		else
 		{
@@ -501,9 +506,23 @@
 		{
 			if( !implIsClass( pObj, aClass ) )
 			{
+#ifndef ENABLE_VBA
 				if( bRaiseErrors )
 					Error( SbERR_INVALID_USAGE_OBJECT );
 				bOk = false;
+#else
+				SvtFilterOptions* pFiltOpt = SvtFilterOptions::Get();	
+				if ( pFiltOpt->IsLoadExcelBasicCode() && pObj->IsA( TYPE(SbUnoObject) ) )
+				{
+					SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,pObj);
+					bOk = checkUnoObjectType( pUnoObj, aClass );
+				}
+				else
+					bOk = false;
+				if ( !bOk )
+					if( bRaiseErrors )
+						Error( SbERR_INVALID_USAGE_OBJECT );
+#endif // ENABLE_VBA
 			}
 			else
 			{
--- basic.orig/source/runtime/step2.cxx	2005-09-19 09:36:54.000000000 +0100
+++ basic/source/runtime/step2.cxx	2005-09-19 09:40:10.000000000 +0100
@@ -72,14 +72,20 @@
 #include "opcodes.hxx"
 
 #include <com/sun/star/container/XIndexAccess.hpp>
+
 #ifdef ENABLE_VBA
 #include <org/openoffice/vba/XCollection.hpp>
+#include <svtools/fltrcfg.hxx>
 #endif //ENABLE_VBA
+
 #include <com/sun/star/uno/Any.hxx>
 
 using namespace com::sun::star::container;
 using namespace com::sun::star::lang;
+#ifdef ENABLE_VBA
+SbxVariable* getVBAConstant( const String& rName );
 
+#endif //ENABLE_VBA
 Any sbxToUnoValue( SbxVariable* pVar ); 
 
 // Suchen eines Elements
@@ -136,7 +142,9 @@
 					aRes.pObj = pUnoClass;
 					pElem->SbxVariable::Put( aRes );
 				}
-
+#ifdef ENABLE_VBA
+				SvtFilterOptions* pFiltOpt = SvtFilterOptions::Get();	
+#endif //ENABLE_VBA
 				// #62939 Wenn eine Uno-Klasse gefunden wurde, muss
 				// das Wrapper-Objekt gehalten werden, da sonst auch
 				// die Uno-Klasse, z.B. "stardiv" immer wieder neu
@@ -152,10 +160,25 @@
 					pElem->SetName( aName );
 					refLocals->Put( pElem, refLocals->Count() );
 				}
+#ifndef ENABLE_VBA
+				else if ( pFiltOp->IsLoadExcelBasicCode() )
+				{
+					// last gasp see if name matches a 
+					// vba idl constant (with no namespace)
+					//
+					pElem = getVBAConstant( aName ); 
+					//Not sure whether I should
+					//store this as a local ref or not,
+					//what are the implications?
+
+					//refLocals->Put( pElem, refLocals->Count() );
+				}
+#endif //ENABLE_VBA
 			}
 
 			if( !pElem )
 			{
+				
 				// Nicht da und nicht im Objekt?
 				// Hat das Ding Parameter, nicht einrichten!
 				if( nOp1 & 0x8000 )
@@ -667,7 +690,7 @@
 
 // Laden eines Parameters (+Offset+Typ)
 // Wenn der Datentyp nicht stimmen sollte, eine Kopie anlegen
-// Der Datentyp SbxEMPTY zeigt an, daá kein Parameter angegeben ist.
+// Der Datentyp SbxEMPTY zeigt an, da kein Parameter angegeben ist.
 // Get( 0 ) darf EMPTY sein
 
 void SbiRuntime::StepPARAM( USHORT nOp1, USHORT nOp2 )
@@ -831,7 +854,7 @@
 	// #29955 for-Schleifen-Ebene korrigieren, #67452 NICHT im Error-Handler sonst Chaos
 	if( !bInError )
 	{
-		// (Bei Sprüngen aus Schleifen tritt hier eine Differenz auf)
+		// (Bei Sprngen aus Schleifen tritt hier eine Differenz auf)
 		USHORT nExspectedForLevel = nOp2 / 0x100;
 		if( pGosubStk )
 			nExspectedForLevel += pGosubStk->nStartForLvl;
@@ -843,7 +866,7 @@
 	}
 
 	// 16.10.96: #31460 Neues Konzept fuer StepInto/Over/Out
-	// Erklärung siehe bei _ImplGetBreakCallLevel.
+	// Erklrung siehe bei _ImplGetBreakCallLevel.
 	if( pInst->nCallLvl <= pInst->nBreakCallLvl )
 	//if( nFlags & SbDEBUG_STEPINTO )
 	{
--- basic.orig/source/classes/sbunoobj.cxx	2005-09-19 09:36:54.000000000 +0100
+++ basic/source/classes/sbunoobj.cxx	2005-09-19 09:11:20.000000000 +0100
@@ -134,6 +134,12 @@
 #include<runtime.hxx>
 
 #include<math.h>
+#ifdef ENABLE_VBA
+#include <hash_map>
+#include <com/sun/star/reflection/XTypeDescriptionEnumerationAccess.hpp>
+#include <com/sun/star/reflection/XConstantsTypeDescription.hpp>
+#include <svtools/fltrcfg.hxx>
+#endif //ENABLE_VBA
 
 TYPEINIT1(SbUnoMethod,SbxMethod)
 TYPEINIT1(SbUnoProperty,SbxProperty)
@@ -154,6 +160,8 @@
 static String aIllegalArgumentExceptionName
     ( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.lang.IllegalArgumentException" ) );
 static OUString aSeqLevelStr( RTL_CONSTASCII_USTRINGPARAM("[]") );
+static OUString defaultNameSpace( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.") );
+static OUString defaultNameSpaceParent( RTL_CONSTASCII_USTRINGPARAM("org.openoffice") );
 
 
 Reference< XComponentContext > getComponentContext_Impl( void )
@@ -1383,6 +1391,47 @@
 	return aName;
 }
 
+bool checkUnoObjectType( SbUnoObject* pUnoObj, 
+	const String& aClass )
+{
+	bool result = false;
+	Any aToInspectObj = pUnoObj->getUnoAny();
+	TypeClass eType = aToInspectObj.getValueType().getTypeClass();
+	if( eType != TypeClass_INTERFACE )
+		return false;
+	const Reference< XInterface > x = *(Reference< XInterface >*)aToInspectObj.getValue();
+	Reference< XTypeProvider > xTypeProvider( x, UNO_QUERY );
+	if( xTypeProvider.is() )
+	{
+		Sequence< Type > aTypeSeq = xTypeProvider->getTypes();
+		const Type* pTypeArray = aTypeSeq.getConstArray();
+		UINT32 nIfaceCount = aTypeSeq.getLength();
+		for( UINT32 j = 0 ; j < nIfaceCount ; j++ )
+		{
+			const Type& rType = pTypeArray[j];
+
+			Reference<XIdlClass> xClass = TypeToIdlClass( rType );
+			if( xClass.is() )
+			{
+				OUString sClassName = xClass->getName();
+				OSL_TRACE("Checking if object implements %s",
+					OUStringToOString( defaultNameSpace + aClass, 
+						RTL_TEXTENCODING_UTF8 ).getStr() );
+				if ( sClassName.equals( defaultNameSpace + aClass ) ||
+					sClassName.equals( aClass ) ) 
+				{
+					result = true;
+					break;
+				}
+				result = true;
+				break;
+			}
+			else
+				break;
+		}
+	}		
+	return result;
+}
 
 // Dbg-Hilfsmethode zum Auslesen der in einem Object implementierten Interfaces
 String Impl_GetSupportedInterfaces( SbUnoObject* pUnoObj )
@@ -2896,29 +2945,180 @@
 		refVar->PutBool( TRUE );
 }
 
-// Funktion, um einen globalen Bezeichner im
-// UnoScope zu suchen und fuer Sbx zu wrappen
-SbxVariable* findUnoClass( const String& rName )
+#ifdef ENABLE_VBA
+typedef std::hash_map< OUString, std::vector< OUString >, OUStringHash, ::std::equal_to< OUString > > ModuleHash;
+
+
+// helper wrapper function to interact with TypeProvider and
+// XTypeDescriptionEnumerationAccess.
+// if it fails for whatever reason 
+// returned Reference<> be null e.g. .is() will be false
+
+Reference< XTypeDescriptionEnumeration > 
+getTypeDescriptorEnumeration( const OUString& sSearchRoot,
+	const Sequence< TypeClass >& types, TypeDescriptionSearchDepth depth )
+{
+	Reference< XTypeDescriptionEnumeration > xEnum;
+	Reference< XTypeDescriptionEnumerationAccess> xTypeEnumAccess( getTypeProvider_Impl(), UNO_QUERY );
+	if ( xTypeEnumAccess.is() )
+	{
+		try
+		{
+			xEnum = xTypeEnumAccess->createTypeDescriptionEnumeration(
+				sSearchRoot, types, depth );
+		}
+		catch( NoSuchTypeNameException& nstne ) {}
+		catch( InvalidTypeNameException& nstne ) {}
+	}
+	return xEnum;
+}
+
+// Returns the list of child modules relative to sSearchRoot
+// names are fully qualified e.g. search with sSearchRoot = "org.openoffice.vba"
+// will return elements like "org.openoffice.vba.child"
+
+const std::vector< OUString >& getModulesToSearch( const OUString& sSearchRoot )
 {
-    // #105550 Check if module exists
-	SbUnoClass* pUnoClass = NULL;
+	// cache previous searches ( creating EnumerationAccess is expensive
+	// apparently see api doc for XTypeDescriptionEnumerationAccess )
+	static ModuleHash aModCache;
+	
+	ModuleHash::const_iterator it = aModCache.find( sSearchRoot );
+
+	if ( it != aModCache.end() )
+		return it->second;
+
+	Sequence< TypeClass > types(2);
+	types[ 0 ] = TypeClass_MODULE;
+	types[ 1 ] = TypeClass_CONSTANTS;
+	Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( sSearchRoot, types, TypeDescriptionSearchDepth_INFINITE  );
+	if ( xEnum.is() )
+	{
+		std::vector< OUString > modules;
+		while ( xEnum->hasMoreElements() )
+		{
+			Reference< XTypeDescription > xType( xEnum->nextElement(), UNO_QUERY );
+			if ( xType.is() )
+					modules.push_back( xType->getName() );
+		}
+		aModCache[ sSearchRoot ] = modules;	
+	}
+
+	// any failures above will result in no names to search	(returned)
+	return aModCache[ sSearchRoot ]; 
+}
+
+typedef std::hash_map< OUString, Any, OUStringHash, ::std::equal_to< OUString > > VBAConstantsHash;
+
+SbxVariable* getVBAConstant( const String& rName )
+{
+	SbxVariable* pConst = NULL;
+	static VBAConstantsHash aConstCache;	
+	static bool isInited = false;
+	if ( !isInited )
+	{
+		Sequence< TypeClass > types(1);
+		types[ 0 ] = TypeClass_CONSTANTS;
+		Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( defaultNameSpace, types, TypeDescriptionSearchDepth_INFINITE  );
+	
+		while ( xEnum->hasMoreElements() )
+		{
+			Reference< XConstantsTypeDescription > xConstants( xEnum->nextElement(), UNO_QUERY );
+			if ( xConstants.is() )
+			{
+				Sequence< Reference< XConstantTypeDescription > > aConsts = xConstants->getConstants();
+				Reference< XConstantTypeDescription >* pSrc = aConsts.getArray();
+				sal_Int32 nLen = aConsts.getLength();
+				for ( sal_Int32 index =0;  index<nLen; ++pSrc, ++index )
+				{
+					Reference< XConstantTypeDescription >& rXConst =
+						*pSrc;
+					OUString sFullName = rXConst->getName();
+					sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
+					OUString sLeafName;
+					if ( indexLastDot > -1 )
+						sLeafName = sFullName.copy( indexLastDot + 1);
+					aConstCache[ sLeafName ] = rXConst->getConstantValue();	
+				}
+			}
+		}
+		isInited = true;
+	}
+	VBAConstantsHash::const_iterator it = aConstCache.find( rName );
+	if ( it != aConstCache.end() )
+	{
+		pConst = new SbxVariable( SbxVARIANT );
+		pConst->SetName( rName );
+		unoToSbxValue( pConst, it->second );
+	}
+	return pConst;	
+}
+
+#endif //ENABLE_VBA
+
+SbUnoClass* findUnoClass_Impl( const String& rName )
+{
+	OSL_TRACE("findUnoClass_Impl for %s",
+		OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
 
+	SbUnoClass* pUnoClass = NULL;
     Reference< XHierarchicalNameAccess > xTypeAccess = getTypeProvider_Impl();
     Reference< XTypeDescription > xTypeDesc;
     if( xTypeAccess->hasByHierarchicalName( rName ) )
     {
         Any aRet = xTypeAccess->getByHierarchicalName( rName );
         aRet >>= xTypeDesc;
-
+                                                                                
         if( xTypeDesc.is() )
         {
             TypeClass eTypeClass = xTypeDesc->getTypeClass();
             if( eTypeClass == TypeClass_MODULE || eTypeClass == TypeClass_CONSTANTS )
-        		pUnoClass = new SbUnoClass( rName );
+                        pUnoClass = new SbUnoClass( rName );
         }
     }
 	return pUnoClass;
 }
+// Funktion, um einen globalen Bezeichner im
+// UnoScope zu suchen und fuer Sbx zu wrappen
+SbxVariable* findUnoClass( const String& rName )
+{
+	OSL_TRACE("findUnoClass for %s",
+		OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    // #105550 Check if module exists
+	SbUnoClass* pUnoClass = NULL;
+#ifdef ENABLE_VBA
+
+	SvtFilterOptions* pFiltOpt = SvtFilterOptions::Get();
+	pUnoClass = findUnoClass_Impl( rName );
+	// only search thru namespaces if handling imported vba code is set
+	// and of course not after finding a constant group or module for 
+	// rName
+	if ( !pUnoClass && pFiltOpt->IsLoadExcelBasicCode() )
+	{
+		if ( rName.CompareTo( defaultNameSpace.getStr(), defaultNameSpace.getLength() ) != COMPARE_EQUAL )
+		
+		{
+			const std::vector< OUString >& modules = getModulesToSearch( defaultNameSpaceParent );
+			std::vector< OUString >::const_iterator it = modules.begin();
+			std::vector< OUString >::const_iterator it_end = modules.end();
+			for ( ; it != it_end; ++it )
+			{
+				static OUString sDot( RTL_CONSTASCII_USTRINGPARAM(".") );
+				OUString sClassName = *it;
+				sClassName += (sDot + rName);
+				OSL_TRACE("...Searching for %s",
+					OUStringToOString( sClassName, RTL_TEXTENCODING_UTF8 ).getStr() );
+				if ( pUnoClass = findUnoClass_Impl( sClassName ) )
+					break;	
+			}
+		}
+	}
+#else
+	pUnoClass = findUnoClass_Impl( rName );
+#endif //ENABLE_VBA
+
+	return pUnoClass;
+}
 
 SbxVariable* SbUnoClass::Find( const XubString& rName, SbxClassType t )
 {
@@ -2978,6 +3178,7 @@
 			{
 				// Ist es eine Konstante?
 				Reference< XHierarchicalNameAccess > xHarryName( xCoreReflection, UNO_QUERY );
+
 				if( xHarryName.is() )
 				{
 					try
