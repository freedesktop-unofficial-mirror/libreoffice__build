--- basic/source/classes/sbunoobj.cxx	2009-06-23 05:13:01.671875000 +0100
+++ basic/source/classes/sbunoobj.cxx	2009-07-16 22:12:04.187500000 +0100
@@ -1616,6 +1616,23 @@ bool checkUnoObjectType( SbUnoObject* pU
 				break;
 			}
 			::rtl::OUString sClassName = xClass->getName();
+			if ( sClassName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.bridge.oleautomation.XAutomationObject" ) ) ) )
+			{
+				// there is a hack in the extensions/source/ole/oleobj.cxx  to return the typename of the automation object, lets check if it
+				// matches
+				Reference< XInvocation > xInv( aToInspectObj, UNO_QUERY );
+				if ( xInv.is() )
+				{
+					rtl::OUString sTypeName;
+					xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sTypeName;
+					if ( sTypeName.getLength() == 0 || sTypeName.equals(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") ) ) )
+						// can't check type, leave it pass
+						result = true;	
+					else
+						result = sTypeName.equals( aClass );
+				}
+				break; // finished checking automation object
+			}
 			OSL_TRACE("Checking if object implements %s",
 				OUStringToOString( defaultNameSpace + aClass,
 					RTL_TEXTENCODING_UTF8 ).getStr() );
--- extensions/source/ole/oleobjw.cxx	2008-11-11 10:00:41.000000000 +0000
+++ extensions/source/ole/oleobjw.cxx	2009-07-16 21:37:49.890625000 +0100
@@ -425,6 +425,46 @@ Any SAL_CALL IUnknownWrapper_Impl::getVa
     {
         o2u_attachCurrentThread();
         ITypeInfo * pInfo = getTypeInfo();
+        // I was going to implement an XServiceInfo interface to allow the type
+        // of the automation object to be exposed.. but it seems
+        // from looking at comments in the code that it is possible for a 
+        // this object to actually wrap an UNO object ( I guess if automation is
+        // used from MSO to create Openoffice objects ) Therefore, those objects
+        // will more than likely already have an XServiceInfo interface.
+        // Instead here I chose a name that should be illegal both in COM and
+        // UNO ( from an IDL point of view ) therefore I think this is a safe
+        // hack
+        if ( aPropertyName.equals( rtl::OUString::createFromAscii("$GetTypeName") )) 
+        {
+            if ( pInfo && m_sTypeName.getLength() == 0 )
+            {
+            	 m_sTypeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") );
+                CComBSTR sName;
+                
+                if ( SUCCEEDED( pInfo->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                {
+                    rtl::OUString sTmp( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                    if ( sTmp.indexOf('_')  == 0 )
+                       sTmp = sTmp.copy(1);
+                    // do we own the memory for pTypeLib, msdn doco is vague
+                    // I'll assume we do 
+                    CComPtr< ITypeLib > pTypeLib;
+                    unsigned int index;
+                    if ( SUCCEEDED(  pInfo->GetContainingTypeLib(  &pTypeLib.p, &index )) )
+                    {
+                        if ( SUCCEEDED( pTypeLib->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                        {
+                            rtl::OUString sLibName( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                            m_sTypeName = sLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sTmp );
+                            
+                        }
+                    }
+                }
+                
+            }
+            ret <<= m_sTypeName;
+            return ret;
+        }
         FuncDesc aDescGet(pInfo);
         FuncDesc aDescPut(pInfo);
         VarDesc aVarDesc(pInfo);
--- extensions/source/ole/oleobjw.hxx	2008-04-11 11:14:30.000000000 +0100
+++ extensions/source/ole/oleobjw.hxx	2009-07-16 19:46:02.750000000 +0100
@@ -233,6 +235,7 @@ protected:
 	Sequence<Type> m_seqTypes;
 	CComPtr<IUnknown> m_spUnknown;
 	CComPtr<IDispatch> m_spDispatch;
+        rtl::OUString m_sTypeName; // is "" ( not initialised ), "IDispatch" ( we have no idea ) or "SomeLibrary.SomeTypeName" if we managed to get a type
     /** This value is set dureing XInitialization::initialize. It indicates that the COM interface
     was transported as VT_DISPATCH in a VARIANT rather then a VT_UNKNOWN
     */
