--- basic/source/sbx/sbxconv.hxx.orig	2007-12-05 04:53:44.000000000 +0800
+++ basic/source/sbx/sbxconv.hxx	2007-12-05 05:02:02.000000000 +0800
@@ -38,6 +38,8 @@
 
 #include "sbxdec.hxx"
 
+class SbxArray;
+
 // SBXSCAN.CXX
 extern void ImpCvtNum( double nNum, short nPrec, String& rRes, BOOL bCoreString=FALSE );
 extern SbxError ImpScan
@@ -150,4 +152,8 @@ void    ImpPutULong( SbxValues*, UINT32 
 enum SbxBOOL ImpGetBool( const SbxValues* );
 void    ImpPutBool( SbxValues*, INT16 );
 
+// ByteArry <--> String
+SbxArray* StringToByteArray(const String& rStr);
+String ByteArrayToString(SbxArray* pArr);
+
 #endif
--- basic/source/sbx/sbxstr.cxx.orig	2007-12-05 04:53:55.000000000 +0800
+++ basic/source/sbx/sbxstr.cxx	2007-12-06 13:53:10.000000000 +0800
@@ -43,6 +43,9 @@
 #include "sbxconv.hxx"
 #include "sbxres.hxx"
 
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
 // AB 29.10.99 Unicode
 #ifndef _USE_NO_NAMESPACE
 using namespace rtl;
@@ -102,6 +105,13 @@ XubString ImpGetString( const SbxValues*
 			SbxValue* pVal = PTR_CAST(SbxValue,p->pObj);
 			if( pVal )
 				aRes = pVal->GetString();
+			else if( p->pObj && (p->pObj->GetType() & (SbxARRAY | SbxBYTE )) )
+			{
+				// convert byte array to string
+				SbxArray* pArr = PTR_CAST(SbxArray, p->pObj);
+				if( pArr )
+					aRes = ByteArrayToString( pArr );
+			}
 			else
 				SbxBase::SetError( SbxERR_NO_OBJECT );
 			break;
@@ -257,3 +267,59 @@ void ImpPutString( SbxValues* p, const X
 	delete pTmp;
 }
 
+// Convert string to an array of bytes, preserving unicode (2bytes per character)
+SbxArray* StringToByteArray(const String& rStr)
+{
+	USHORT nArraySize = rStr.Len() * 2;
+	const sal_Unicode* pSrc = rStr.GetBuffer();
+	SbxDimArray* pArray = new SbxDimArray(SbxBYTE);
+	if( nArraySize )
+		pArray->AddDim( 0, nArraySize-1 );	
+	else
+	{
+		pArray->unoAddDim( 0, -1 );
+	}
+
+	for( USHORT	i=0; i< nArraySize; i++)
+	{
+		SbxVariable* pNew = new SbxVariable( SbxBYTE );
+		BYTE aByte = i%2 ? ((*pSrc) >> 8) & 0xff : (*pSrc) & 0xff;
+		pNew->PutByte( aByte );
+		pNew->SetFlag( SBX_WRITE );
+		pArray->Put( pNew, i );	
+		if( i%2 )
+			pSrc++;
+	}
+	return pArray;
+}	
+
+// Convert an array of bytes to string (2bytes per character)
+String ByteArrayToString(SbxArray* pArr)
+{
+	USHORT nCount = pArr->Count();
+	OUStringBuffer aStrBuf;
+	sal_Unicode aChar = 0;
+	for(int i=0; i< nCount; i++)
+	{
+		sal_Unicode aTempChar = pArr->Get(i)->GetByte();
+		if( i%2 )
+		{
+			aChar = (aTempChar << 8 ) | aChar;
+			aStrBuf.append(aChar);
+			aChar = 0;
+		}
+		else
+		{
+			aChar = aTempChar;	
+		}
+	}
+	
+	if( nCount%2 )
+	{
+		aStrBuf.append(aChar);
+	}
+
+	String aStr(aStrBuf.makeStringAndClear());
+	
+	return aStr;
+}
--- basic/source/sbx/sbxvalue.cxx.orig	2007-12-05 04:54:05.000000000 +0800
+++ basic/source/sbx/sbxvalue.cxx	2007-12-05 11:07:07.000000000 +0800
@@ -333,6 +333,30 @@ SbxValue& SbxValue::operator=( const Sbx
 			SetError( SbxERR_PROP_READONLY );
 		else
 		{
+			// string -> byte array
+			if( (aData.eType == SbxOBJECT)
+				&& aData.pObj && ( aData.pObj->GetType() & (SbxARRAY | SbxBYTE) )		   	
+				&& (r.aData.eType == SbxSTRING) )
+			{
+				String aStr = r.GetString();
+				SbxArray* pArr = StringToByteArray(aStr);
+				PutObject(pArr);
+				return *this;
+			}
+			// byte array -> string
+			if( (r.aData.eType == SbxOBJECT)
+				&& r.aData.pObj && ( r.aData.pObj->GetType() & (SbxARRAY | SbxBYTE) )
+				&& (aData.eType == SbxSTRING) )
+			{
+				SbxBase* pObj = r.GetObject();
+				SbxArray* pArr = PTR_CAST(SbxArray, pObj);
+				if( pArr )
+				{
+					String aStr = ByteArrayToString( pArr );
+					PutString(aStr);
+					return *this;
+				}
+			}
 			// Den Inhalt der Variablen auslesen
 			SbxValues aNew;
 			if( IsFixed() )
