diff --git basctl/source/basicide/baside3.cxx basctl/source/basicide/baside3.cxx
index e307720..fbd83c8 100644
--- basctl/source/basicide/baside3.cxx
+++ basctl/source/basicide/baside3.cxx
@@ -82,6 +82,7 @@
 #include <com/sun/star/resource/XStringResourceResolver.hpp>
 #include <com/sun/star/resource/StringResourceWithLocation.hpp>
 #include <com/sun/star/task/XInteractionHandler.hpp>
+#include <com/sun/star/script/vba/XVBACompatibility.hpp>
 
 using namespace comphelper;
 using namespace	::com::sun::star;
@@ -112,8 +113,16 @@ DialogWindow::DialogWindow( Window* pParent, const ScriptDocument& rDocument, St
 {
     InitSettings( TRUE, TRUE, TRUE );
 
-    pEditor = new DlgEditor();
+	pEditor = new DlgEditor( rDocument.isDocument() ? rDocument.getDocument() : Reference< frame::XModel >() );
     pEditor->SetWindow( this );
+	// set vba mode on DialogModel ( allows it to work in 100thmm instead of MAP_APPFONT )
+	if ( rDocument.isDocument() && rDocument.getDocument().is() )
+	{
+		uno::Reference< script::vba::XVBACompatibility > xDocVBAMode( rDocument.getLibraryContainer( E_SCRIPTS ), uno::UNO_QUERY );
+		uno::Reference< script::vba::XVBACompatibility > xDialogModelVBAMode( xDialogModel, uno::UNO_QUERY );
+		if ( xDocVBAMode.is()  &&  xDialogModelVBAMode.is() )
+			xDialogModelVBAMode->setVBACompatibilityMode( xDocVBAMode->getVBACompatibilityMode() );
+	}
     pEditor->SetDialog( xDialogModel );
 
     // Undo einrichten
@@ -728,7 +737,7 @@ BOOL DialogWindow::SaveDialog()
         Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
         OSL_ASSERT( xProps.is() );
         OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-        Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().isDocument() ? GetDocument().getDocument() : Reference< frame::XModel >() );
         Reference< XInputStream > xInput( xISP->createInputStream() );
 
         Reference< XSimpleFileAccess > xSFI( xMSF->createInstance
@@ -1010,7 +1019,7 @@ BOOL implImportDialog( Window* pWin, const String& rCurPath, const ScriptDocumen
             Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
             OSL_ASSERT( xProps.is() );
             OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+			::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.isDocument() ? rDocument.getDocument() : Reference< frame::XModel >() );
 
             String aXmlDlgName;
             Reference< beans::XPropertySet > xDialogModelPropSet( xDialogModel, UNO_QUERY );
@@ -1236,7 +1245,7 @@ BOOL implImportDialog( Window* pWin, const String& rCurPath, const ScriptDocumen
                 }
             }
 
-            Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+			Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDocument.isDocument() ? rDocument.getDocument() : Reference< frame::XModel >() );
             bool bSuccess = rDocument.insertDialog( aLibName, aNewDlgName, xISP );
             if( bSuccess )
             {
@@ -1346,7 +1355,7 @@ void DialogWindow::StoreData()
                     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+					Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().isDocument() ? GetDocument().getDocument() : Reference< frame::XModel >() );
                     xLib->replaceByName( ::rtl::OUString( GetName() ), makeAny( xISP ) );
                 }
             }
diff --git basctl/source/basicide/basides3.cxx basctl/source/basicide/basides3.cxx
index 1b71e43..6ec1dcd 100644
--- basctl/source/basicide/basides3.cxx
+++ basctl/source/basicide/basides3.cxx
@@ -96,7 +96,7 @@ DialogWindow* BasicIDEShell::CreateDlgWin( const ScriptDocument& rDocument, cons
                 Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                 OSL_ASSERT( xProps.is() );
                 OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+				::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.isDocument() ? rDocument.getDocument() : Reference< frame::XModel >() );
                 LocalizationMgr::setStringResourceAtDialog( rDocument, rLibName, aDlgName, xDialogModel );
 
                 // new dialog window
diff --git basctl/source/basicide/moduldlg.cxx basctl/source/basicide/moduldlg.cxx
index e2a2377..b00acdd 100644
--- basctl/source/basicide/moduldlg.cxx
+++ basctl/source/basicide/moduldlg.cxx
@@ -312,7 +312,7 @@ void BasicIDEShell::CopyDialogResources( Reference< io::XInputStreamProvider >&
     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-    ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+	::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rSourceDoc.isDocument() ? rSourceDoc.getDocument() : Reference< frame::XModel >() );
 
     if( xDialogModel.is() )
     {
@@ -329,7 +329,7 @@ void BasicIDEShell::CopyDialogResources( Reference< io::XInputStreamProvider >&
         {
             LocalizationMgr::setResourceIDsForDialog( xDialogModel, xDestMgr );
         }
-        io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDestDoc.isDocument() ? rDestDoc.getDocument() : Reference< frame::XModel >() );
     }
 }
 
diff --git basctl/source/basicide/scriptdocument.cxx basctl/source/basicide/scriptdocument.cxx
index cfbd761..14d8dc8 100644
--- basctl/source/basicide/scriptdocument.cxx
+++ basctl/source/basicide/scriptdocument.cxx
@@ -453,14 +453,12 @@ namespace basctl
     bool ScriptDocument_Impl::isInVBAMode() const
     {
         bool bResult = false;
-#ifdef FUTURE_VBA_CWS
         if ( !isApplication() )
         {
             Reference< XVBACompatibility > xVBACompat( getLibraryContainer( E_SCRIPTS ), UNO_QUERY );
             if ( xVBACompat.is() )
                 bResult = xVBACompat->getVBACompatibilityMode();
         }
-#endif
         return bResult; 
     }
 
@@ -678,7 +676,7 @@ namespace basctl
                 if ( !_rxExistingDialogModel.is() )
                 {
                     Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
-                    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext() );
+    			    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext(), isDocument() ? getDocument() : Reference< XModel >() );
                 }
 
                 // set new name as property
@@ -686,12 +684,12 @@ namespace basctl
                 xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rNewName ) );
 
                 // export dialog model
-                xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+			    xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), isDocument() ? getDocument() : Reference< XModel >() );
                 aElement <<= xISP;
             }
 
             // insert element by new name in container
-            else if ( _eType == E_SCRIPTS )
+            if ( _eType == E_SCRIPTS )
             {
                 Reference< XVBAModuleInfo > xVBAModuleInfo( xLib, UNO_QUERY );
                 if ( xVBAModuleInfo->hasModuleInfo( _rOldName ) )
@@ -798,7 +796,7 @@ namespace basctl
             xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rDialogName ) );
 
             // export dialog model
-            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), isDocument() ? getDocument() : Reference< XModel >() );
 
             // insert dialog into library
             xLib->insertByName( _rDialogName, makeAny( _out_rDialogProvider ) );
diff --git basctl/source/dlged/dlged.cxx basctl/source/dlged/dlged.cxx
index 04bc7e5..020f934 100644
--- basctl/source/dlged/dlged.cxx
+++ basctl/source/dlged/dlged.cxx
@@ -205,7 +205,7 @@ BOOL DlgEditor::RemarkDialog()
 
 //----------------------------------------------------------------------------
 
-DlgEditor::DlgEditor()
+DlgEditor::DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel )
     :pHScroll(NULL)
     ,pVScroll(NULL)
     ,pDlgEdModel(NULL)
@@ -227,6 +227,7 @@ DlgEditor::DlgEditor()
     ,bCreateOK(TRUE)
     ,bDialogModelChanged(FALSE)
     ,mnPaintGuard(0)
+	,m_xDocument( xModel )
 {
     pDlgEdModel = new DlgEdModel();
     pDlgEdModel->GetItemPool().FreezeIdRanges();
@@ -835,7 +836,7 @@ void DlgEditor::Copy()
     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
     Reference< XInputStream > xStream( xISP->createInputStream() );
     Sequence< sal_Int8 > DialogModelBytes;
     implCopyStreamToByteSequence( xStream, DialogModelBytes );
@@ -868,7 +869,7 @@ void DlgEditor::Copy()
             uno::Reference< resource::XStringResourceManager >
                 xStringResourceManager( xStringResourcePersistence, uno::UNO_QUERY );
             LocalizationMgr::resetResourceForDialog( xClipDialogModel, xStringResourceManager );
-            Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+			Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
             Reference< XInputStream > xStream2( xISP2->createInputStream() );
             Sequence< sal_Int8 > NoResourceDialogModelBytes;
             implCopyStreamToByteSequence( xStream2, NoResourceDialogModelBytes );
@@ -1014,7 +1015,7 @@ void DlgEditor::Paste()
                     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                    ::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext );
+					::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext, m_xDocument );
                 }
 
                 // get control models from clipboard dialog model
diff --git basctl/source/dlged/dlgedobj.cxx basctl/source/dlged/dlgedobj.cxx
index 50b54c6..a56985e 100644
--- basctl/source/dlged/dlgedobj.cxx
+++ basctl/source/dlged/dlgedobj.cxx
@@ -74,6 +74,22 @@ TYPEINIT1(DlgEdObj, SdrUnoObj);
 DBG_NAME(DlgEdObj);
 
 //----------------------------------------------------------------------------
+MapMode lcl_getMapModeForForm( DlgEdForm* pForm )
+{
+	MapMode aMode( MAP_APPFONT ); //Default
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps( pForm ? pForm->GetUnoControlModel() : NULL, uno::UNO_QUERY_THROW );
+		sal_Bool bVBAForm = sal_False;
+		xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBAForm;	
+		if ( bVBAForm )
+			aMode = MapMode( MAP_100TH_MM );
+	}
+	catch ( Exception& )
+	{
+	}
+	return aMode;
+}
 
 DlgEdObj::DlgEdObj()
           :SdrUnoObj(String(), sal_False)
@@ -194,8 +210,9 @@ bool DlgEdObj::TransformSdrToControlCoordinates(
     }
     
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -242,10 +259,10 @@ bool DlgEdObj::TransformSdrToFormCoordinates(
         aSize.Width() -= aDeviceInfo.LeftInset + aDeviceInfo.RightInset;
         aSize.Height() -= aDeviceInfo.TopInset + aDeviceInfo.BottomInset;
     }
-
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -287,9 +304,10 @@ bool DlgEdObj::TransformControlToSdrCoordinates(
     DBG_ASSERT( pDevice, "DlgEdObj::TransformControlToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
-    aFormPos = pDevice->LogicToPixel( aFormPos, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+    aFormPos = pDevice->LogicToPixel( aFormPos, aConvMode );
 
     // add form position
     aPos.Width() += aFormPos.Width();
@@ -333,14 +351,16 @@ bool DlgEdObj::TransformFormToSdrCoordinates(
     DBG_ASSERT( pDevice, "DlgEdObj::TransformFormToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
 
     // take window borders into account
     DlgEdForm* pForm = NULL;
     if ( !lcl_getDlgEdForm( this, pForm ) )
         return false;
 
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+
     // take window borders into account
     Reference< beans::XPropertySet > xPSetForm( pForm->GetUnoControlModel(), UNO_QUERY );
     DBG_ASSERT( xPSetForm.is(), "DlgEdObj::TransformFormToSdrCoordinates: no form property set!" );
diff --git basctl/source/inc/dlged.hxx basctl/source/inc/dlged.hxx
index a8adcda..a2ea57c 100644
--- basctl/source/inc/dlged.hxx
+++ basctl/source/inc/dlged.hxx
@@ -32,6 +32,7 @@
 #include <com/sun/star/awt/XControlContainer.hpp>
 #include <com/sun/star/datatransfer/DataFlavor.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/frame/XModel.hpp>
 #include <tools/link.hxx>
 #include <tools/gen.hxx> 
 #include <vcl/timer.hxx>
@@ -128,9 +129,11 @@ protected:
     BOOL				bDialogModelChanged;
     Timer               aMarkTimer;
     long				mnPaintGuard;
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > m_xDocument;
 
+	DlgEditor(); // not implemented
 public:
-    DlgEditor();
+	DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel );
     ~DlgEditor();
 
     void			SetWindow( Window* pWindow );
diff --git basic/inc/basic/basmgr.hxx basic/inc/basic/basmgr.hxx
index 886aa7f..58cf623 100644
--- basic/inc/basic/basmgr.hxx
+++ basic/inc/basic/basmgr.hxx
@@ -236,7 +236,7 @@ public:
             takes the names of modules whose size exceeds the legacy limit
     */
     bool            LegacyPsswdBinaryLimitExceeded( ::com::sun::star::uno::Sequence< rtl::OUString >& _out_rModuleNames );
-
+    bool HasExeCode( const String& );
 private:
     BOOL		    IsReference( USHORT nLib );
 
diff --git basic/inc/basic/sbmeth.hxx basic/inc/basic/sbmeth.hxx
index 38319ac..89f88da 100644
--- basic/inc/basic/sbmeth.hxx
+++ basic/inc/basic/sbmeth.hxx
@@ -46,6 +46,7 @@ class SbMethod : public SbxMethod
     friend class SbIfaceMapperMethod;
 
     SbMethodImpl* mpSbMethodImpl;			// Impl data
+	SbxVariable* mCaller;                   // caller
     SbModule* pMod;
     USHORT    nDebugFlags;
     USHORT	  nLine1, nLine2;
@@ -72,7 +73,7 @@ public:
     void 	  GetLineRange( USHORT&, USHORT& );
 
     // Interface to execute a method from the applications
-    virtual ErrCode Call( SbxValue* pRet = NULL );
+	virtual ErrCode Call( SbxValue* pRet = NULL,  SbxVariable* pCaller = NULL );
     virtual void Broadcast( ULONG nHintId );
 };
 
diff --git basic/inc/basic/sbmod.hxx basic/inc/basic/sbmod.hxx
index 15afc1f..f960b89 100644
--- basic/inc/basic/sbmod.hxx
+++ basic/inc/basic/sbmod.hxx
@@ -58,6 +58,8 @@ class SbModule : public SbxObject
 
     SbModuleImpl*	mpSbModuleImpl;		// Impl data
     std::vector< String > mModuleVariableNames;
+	SbModule();
+	SbModule(const SbModule&);
 
 protected:
     com::sun::star::uno::Reference< com::sun::star::script::XInvocation > mxWrapper;
@@ -130,6 +132,7 @@ public:
     BOOL LoadBinaryData( SvStream& );
     BOOL ExceedsLegacyModuleSize();
     void fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg = NULL ) const;
+    bool HasExeCode();
     BOOL IsVBACompat() const;
     void SetVBACompat( BOOL bCompat );
     INT32 GetModuleType() { return mnType; }
diff --git basic/inc/basic/sbuno.hxx basic/inc/basic/sbuno.hxx
index 27fe320..c5e0209 100644
--- basic/inc/basic/sbuno.hxx
+++ basic/inc/basic/sbuno.hxx
@@ -38,6 +38,7 @@ SbxObjectRef GetSbUnoObject( const String& aName, const com::sun::star::uno::Any
 
 // Force creation of all properties for debugging
 void createAllObjectProperties( SbxObject* pObj );
+void SetSbUnoObjectDfltPropName( SbxObject* pObj );
 
 ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 
diff --git basic/source/basmgr/basmgr.cxx basic/source/basmgr/basmgr.cxx
index b2e0f58..ba0085f 100644
--- basic/source/basmgr/basmgr.cxx
+++ basic/source/basmgr/basmgr.cxx
@@ -1139,6 +1139,25 @@ void BasicManager::LegacyDeleteBasicManager( BasicManager*& _rpManager )
     _rpManager = NULL;
 }
 
+
+bool BasicManager::HasExeCode( const String& sLib )
+{
+	StarBASIC* pLib = GetLib(sLib);	
+	if ( pLib )
+	{
+		SbxArray* pMods = pLib->GetModules();
+		USHORT nMods = pMods ? pMods->Count() : 0;
+		for( USHORT i = 0; i < nMods; i++ )
+		{
+			SbModule* p = (SbModule*) pMods->Get( i );
+			if ( p )
+				if ( p->HasExeCode() )
+					return true;
+		}
+	}
+	return false;
+}
+
 void BasicManager::Init()
 {
     DBG_CHKTHIS( BasicManager, 0 );
diff --git basic/source/classes/sb.cxx basic/source/classes/sb.cxx
index df5bd58..605bd4e 100755
--- basic/source/classes/sb.cxx
+++ basic/source/classes/sb.cxx
@@ -577,93 +577,7 @@ SbClassModuleObject::~SbClassModuleObject()
 void SbClassModuleObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
                            const SfxHint& rHint, const TypeId& rHintType )
 {
-    bool bDone = false;
-
-    const SbxHint* pHint = PTR_CAST(SbxHint,&rHint);
-    if( pHint )
-    {
-        SbxVariable* pVar = pHint->GetVar();
-        SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
-        if( pProcProperty )
-        {
-            bDone = true;
-
-            if( pHint->GetId() == SBX_HINT_DATAWANTED )
-            {
-                String aProcName;
-                aProcName.AppendAscii( "Property Get " );
-                aProcName += pProcProperty->GetName();
-
-                SbxVariable* pMeth = Find( aProcName, SbxCLASS_METHOD );
-                if( pMeth )
-                {
-                    SbxValues aVals;
-                    aVals.eType = SbxVARIANT;
-
-                    SbxArray* pArg = pVar->GetParameters();
-                    USHORT nVarParCount = (pArg != NULL) ? pArg->Count() : 0;
-                    if( nVarParCount > 1 )
-                    {
-                        SbxArrayRef xMethParameters = new SbxArray;
-                        xMethParameters->Put( pMeth, 0 );	// Method as parameter 0
-                        for( USHORT i = 1 ; i < nVarParCount ; ++i )
-                        {
-                            SbxVariable* pPar = pArg->Get( i );
-                            xMethParameters->Put( pPar, i );
-                        }
-
-                        pMeth->SetParameters( xMethParameters );
-                        pMeth->Get( aVals );
-                        pMeth->SetParameters( NULL );
-                    }
-                    else
-                    {
-                        pMeth->Get( aVals );
-                    }
-
-                    pVar->Put( aVals );
-                }
-            }
-            else if( pHint->GetId() == SBX_HINT_DATACHANGED )
-            {
-                SbxVariable* pMeth = NULL;
-
-                bool bSet = pProcProperty->isSet();
-                if( bSet )
-                {
-                    pProcProperty->setSet( false );
-
-                    String aProcName;
-                    aProcName.AppendAscii( "Property Set " );
-                    aProcName += pProcProperty->GetName();
-                    pMeth = Find( aProcName, SbxCLASS_METHOD );
-                }
-                if( !pMeth )	// Let
-                {
-                    String aProcName;
-                    aProcName.AppendAscii( "Property Let " );
-                    aProcName += pProcProperty->GetName();
-                    pMeth = Find( aProcName, SbxCLASS_METHOD );
-                }
-
-                if( pMeth )
-                {
-                    // Setup parameters
-                    SbxArrayRef xArray = new SbxArray;
-                    xArray->Put( pMeth, 0 );	// Method as parameter 0
-                    xArray->Put( pVar, 1 );
-                    pMeth->SetParameters( xArray );
-
-                    SbxValues aVals;
-                    pMeth->Get( aVals );
-                    pMeth->SetParameters( NULL );
-                }
-            }
-        }
-    }
-
-    if( !bDone )
-        SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
+    SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
 }
 
 SbxVariable* SbClassModuleObject::Find( const XubString& rName, SbxClassType t )
@@ -1093,7 +1007,6 @@ SbxVariable* StarBASIC::Find( const String& rName, SbxClassType t )
             INT32 nType = p->GetModuleType();
             if ( nType == ModuleType::DOCUMENT || nType == ModuleType::FORM )
                 continue;
-
             // otherwise check if the element is available
             // unset GBLSEARCH-Flag (due to Rekursion)
             USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
diff --git basic/source/classes/sbunoobj.cxx basic/source/classes/sbunoobj.cxx
index 1a9e046..dfc8dfd 100755
--- basic/source/classes/sbunoobj.cxx
+++ basic/source/classes/sbunoobj.cxx
@@ -61,6 +61,7 @@
 #include <com/sun/star/script/XInvocationAdapterFactory.hpp>
 #include <com/sun/star/script/XTypeConverter.hpp>
 #include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XIdlArray.hpp>
@@ -71,7 +72,7 @@
 #include <com/sun/star/bridge/oleautomation/Decimal.hpp>
 #include <com/sun/star/bridge/oleautomation/Currency.hpp>
 #include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
-
+#include <com/sun/star/script/XAutomationInvocation.hpp>
 
 using com::sun::star::uno::Reference;
 using namespace com::sun::star::uno;
@@ -157,6 +158,21 @@ SbxVariable* getDefaultProp( SbxVariable* pRef )
     return pDefaultProp;
 }
 
+void SetSbUnoObjectDfltPropName( SbxObject* pObj )
+{
+	SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*) pObj);
+	if ( pUnoObj )
+	{
+		String sDfltPropName;
+		
+		if ( SbUnoObject::getDefaultPropName( pUnoObj, sDfltPropName ) )
+		{
+			OSL_TRACE("SetSbUnoObjectDfltPropName setting dflt prop for %s", rtl::OUStringToOString( pObj->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+			pUnoObj->SetDfltProperty( sDfltPropName );
+		}
+	}
+}
+
 Reference< XComponentContext > getComponentContext_Impl( void )
 {
     static Reference< XComponentContext > xContext;
@@ -453,6 +469,32 @@ void implHandleWrappedTargetException( const Any& _rWrappedTargetException )
     SbError nError( ERRCODE_BASIC_EXCEPTION );
     ::rtl::OUStringBuffer aMessageBuf;
 
+    // Add for VBA, to get the correct error code and message.
+    if ( SbiRuntime::isVBAEnabled() )
+    {
+        if ( aExamine >>= aBasicError )
+        {
+            if ( aBasicError.ErrorCode != 0 )
+            {
+                nError = StarBASIC::GetSfxFromVBError( (USHORT) aBasicError.ErrorCode );
+                if ( nError == 0 )
+                {
+                    nError = (SbError) aBasicError.ErrorCode;
+                }
+                aMessageBuf.append( aBasicError.ErrorMessageArgument );
+                aExamine.clear();
+            }
+        }
+
+        IndexOutOfBoundsException aIdxOutBndsExp;
+        if ( aExamine >>= aIdxOutBndsExp )
+        {
+            nError = SbERR_OUT_OF_RANGE;
+            aExamine.clear();
+        }
+    }
+    // End add
+
     // strip any other WrappedTargetException instances, but this time preserve the error messages.
     WrappedTargetException aWrapped;
     sal_Int32 nLevel = 0;
@@ -1502,6 +1544,103 @@ Any sbxToUnoValue( SbxVariable* pVar, const Type& rType, Property* pUnoProperty
     return aRetVal;
 }
 
+void processAutomationParams( SbxArray* pParams, Sequence< Any >& args, bool bOLEAutomation, UINT32 nParamCount )
+{
+	AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
+	if( bOLEAutomation )
+		pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
+
+	args.realloc( nParamCount );
+	Any* pAnyArgs = args.getArray();
+	bool bBlockConversionToSmallestType = pINST->IsCompatibility();
+	UINT32 i = 0;	
+	if( pArgNamesArray )
+	{
+		Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
+		::rtl::OUString* pNames = rNameSeq.getArray();
+		Any aValAny;
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			USHORT iSbx = (USHORT)(i+1);
+	
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
+			bBlockConversionToSmallestType );
+	
+			::rtl::OUString aParamName = pNames[iSbx];
+			if( aParamName.getLength() )
+			{
+				oleautomation::NamedArgument aNamedArgument;
+				aNamedArgument.Name = aParamName;
+				aNamedArgument.Value = aValAny;
+				pAnyArgs[i] <<= aNamedArgument;
+			}
+			else
+			{
+				pAnyArgs[i] = aValAny;
+			}
+		}
+	}
+	else
+	{
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
+			bBlockConversionToSmallestType );
+		}
+	}
+
+}
+enum INVOKETYPE
+{
+   GetProp = 0, 
+   SetProp, 
+   Func
+};
+Any invokeAutomationMethod( const String& Name, Sequence< Any >& args, SbxArray* pParams, UINT32 nParamCount, Reference< XInvocation >& rxInvocation, INVOKETYPE invokeType = Func )
+{
+	Sequence< INT16 > OutParamIndex;
+	Sequence< Any > OutParam;
+    
+	Any aRetAny;
+	switch( invokeType )
+	{
+		case Func:
+			aRetAny = rxInvocation->invoke( Name, args, OutParamIndex, OutParam );
+			break;
+		case GetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY );
+				aRetAny = xAutoInv->invokeGetProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		case SetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY_THROW );
+				aRetAny = xAutoInv->invokePutProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		default:
+			break; // should introduce an error here
+	
+	}
+	const INT16* pIndices = OutParamIndex.getConstArray();
+	UINT32 nLen = OutParamIndex.getLength();
+	if( nLen )
+	{
+		const Any* pNewValues = OutParam.getConstArray();
+		for( UINT32 j = 0 ; j < nLen ; j++ )
+		{
+			INT16 iTarget = pIndices[ j ];
+			if( iTarget >= (INT16)nParamCount )
+				break;
+			unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
+		}
+	}
+    return aRetAny;
+}
+
 // Dbg-Hilfsmethode zum Auslesen der in einem Object implementierten Interfaces
 String Impl_GetInterfaceInfo( const Reference< XInterface >& x, const Reference< XIdlClass >& xClass, USHORT nRekLevel )
 {
@@ -2008,11 +2147,26 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
                 {
                     try
                     {
-                        // Wert holen
-                        Any aRetAny = mxInvocation->getValue( pProp->GetName() );
+						UINT32 nParamCount = pParams ? ((UINT32)pParams->Count() - 1) : 0;
+						sal_Bool bCanBeConsideredAMethod = mxInvocation->hasMethod( pProp->GetName() );
+						Any aRetAny;
+					   	if ( bCanBeConsideredAMethod && nParamCount )
+						{
+							// Automation properties have methods, so.. we need to invoke this through
+							// XInvocation
+							Sequence<Any> args;
+							processAutomationParams( pParams, args, true, nParamCount );
+							aRetAny = invokeAutomationMethod( pProp->GetName(), args, pParams, nParamCount, mxInvocation, GetProp );
+						}	
+						else
+							// Wert holen
+							aRetAny = mxInvocation->getValue( pProp->GetName() );
 
                         // Wert von Uno nach Sbx uebernehmen
                         unoToSbxValue( pVar, aRetAny );
+						if( pParams && bCanBeConsideredAMethod )
+							pVar->SetParameters( NULL );
+
                     }
                     catch( const Exception& )
                     {
@@ -2137,52 +2291,7 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
                 else if( bInvocation && pParams && mxInvocation.is() )
                 {
                     bool bOLEAutomation = true;
-                    // TODO: bOLEAutomation = xOLEAutomation.is()
-
-                    AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
-                    if( bOLEAutomation )
-                        pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
-
-                    args.realloc( nParamCount );
-                    Any* pAnyArgs = args.getArray();
-                    bool bBlockConversionToSmallestType = pINST->IsCompatibility();
-                    if( pArgNamesArray )
-                    {
-                        Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
-                        ::rtl::OUString* pNames = rNameSeq.getArray();
-
-                        Any aValAny;
-                        for( i = 0 ; i < nParamCount ; i++ )
-                        {
-                            USHORT iSbx = (USHORT)(i+1);
-
-                            // ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-                            aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
-                                                        bBlockConversionToSmallestType );
-
-                            ::rtl::OUString aParamName = pNames[iSbx];
-                            if( aParamName.getLength() )
-                            {
-                                oleautomation::NamedArgument aNamedArgument;
-                                aNamedArgument.Name = aParamName;
-                                aNamedArgument.Value = aValAny;
-                                pAnyArgs[i] <<= aNamedArgument;
-                            }
-                            else
-                            {
-                                pAnyArgs[i] = aValAny;
-                            }
-                        }
-                    }
-                    else
-                    {
-                        for( i = 0 ; i < nParamCount ; i++ )
-                        {
-                            // ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-                            pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
-                                                            bBlockConversionToSmallestType );
-                        }
-                    }
+					processAutomationParams( pParams, args, bOLEAutomation, nParamCount );
                 }
 
                 // Methode callen
@@ -2217,26 +2326,8 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
                     }
                     else if( bInvocation && mxInvocation.is() )
                     {
-                        Sequence< INT16 > OutParamIndex;
-                        Sequence< Any > OutParam;
-                        Any aRetAny = mxInvocation->invoke( pMeth->GetName(), args, OutParamIndex, OutParam );
-
-                        // Wert von Uno nach Sbx uebernehmen
+						Any aRetAny = invokeAutomationMethod( pMeth->GetName(), args, pParams, nParamCount, mxInvocation );
                         unoToSbxValue( pVar, aRetAny );
-
-                        const INT16* pIndices = OutParamIndex.getConstArray();
-                        UINT32 nLen = OutParamIndex.getLength();
-                        if( nLen )
-                        {
-                            const Any* pNewValues = OutParam.getConstArray();
-                            for( UINT32 j = 0 ; j < nLen ; j++ )
-                            {
-                                INT16 iTarget = pIndices[ j ];
-                                if( iTarget >= (INT16)nParamCount )
-                                    break;
-                                unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
-                            }
-                        }
                     }
 
                     // #55460, Parameter hier weghauen, da das in unoToSbxValue()
@@ -3165,11 +3256,16 @@ getTypeDescriptorEnumeration( const ::rtl::OUString& sSearchRoot,
 
 typedef std::hash_map< ::rtl::OUString, Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
 
-SbxVariable* getVBAConstant( const String& rName )
+VBAConstantHelper&
+VBAConstantHelper::instance()
+{
+    static VBAConstantHelper aHelper;
+    return aHelper;
+}
+
+void
+VBAConstantHelper::init()
 {
-    SbxVariable* pConst = NULL;
-    static VBAConstantsHash aConstCache;
-    static bool isInited = false;
     if ( !isInited )
     {
         Sequence< TypeClass > types(1);
@@ -3177,39 +3273,77 @@ SbxVariable* getVBAConstant( const String& rName )
         Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( defaultNameSpace, types, TypeDescriptionSearchDepth_INFINITE  );
 
         if ( !xEnum.is() )
-            return NULL;
+            return; //NULL;
 
         while ( xEnum->hasMoreElements() )
         {
             Reference< XConstantsTypeDescription > xConstants( xEnum->nextElement(), UNO_QUERY );
             if ( xConstants.is() )
             {
+                // store constant group name 
+                ::rtl::OUString sFullName = xConstants->getName();
+                sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
+                ::rtl::OUString sLeafName( sFullName );
+                if ( indexLastDot > -1 )
+                    sLeafName = sFullName.copy( indexLastDot + 1);
+                aConstCache.push_back( sLeafName ); // assume constant group names are unique
                 Sequence< Reference< XConstantTypeDescription > > aConsts = xConstants->getConstants();
                 Reference< XConstantTypeDescription >* pSrc = aConsts.getArray();
                 sal_Int32 nLen = aConsts.getLength();
                 for ( sal_Int32 index =0;  index<nLen; ++pSrc, ++index )
                 {
+                    // store constant member name
                     Reference< XConstantTypeDescription >& rXConst =
                         *pSrc;
-                    ::rtl::OUString sFullName = rXConst->getName();
-                    sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
-                    ::rtl::OUString sLeafName;
+                    sFullName = rXConst->getName();
+                    indexLastDot = sFullName.lastIndexOf('.');
+                    sLeafName = sFullName;
                     if ( indexLastDot > -1 )
                         sLeafName = sFullName.copy( indexLastDot + 1);
-                    aConstCache[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
+                    aConstHash[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
                 }
             }
         }
         isInited = true;
     }
+}
+
+bool
+VBAConstantHelper::isVBAConstantType( const String& rName )
+{
+    init();
+    bool bConstant = false;
+    ::rtl::OUString sKey( rName );
+    VBAConstantsVector::const_iterator it = aConstCache.begin();
+
+    for( ; it != aConstCache.end(); it++ )
+    {
+        if( sKey.equalsIgnoreAsciiCase( *it ) )
+        {
+            bConstant = true;
+            break;
+        }
+    }
+    return bConstant; 
+}
+
+SbxVariable* 
+VBAConstantHelper::getVBAConstant( const String& rName )
+{
+    SbxVariable* pConst = NULL;
+    init();
+
     ::rtl::OUString sKey( rName );
-    VBAConstantsHash::const_iterator it = aConstCache.find( sKey.toAsciiLowerCase() );
-    if ( it != aConstCache.end() )
+
+    VBAConstantsHash::const_iterator it = aConstHash.find( sKey.toAsciiLowerCase() );
+
+    if ( it != aConstHash.end() )
     {
         pConst = new SbxVariable( SbxVARIANT );
         pConst->SetName( rName );
         unoToSbxValue( pConst, it->second );
     }
+
     return pConst;
 }
 
diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index 834d731..0b9b351 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -58,6 +58,7 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/script/ModuleType.hpp>
 #include <com/sun/star/script/vba/XVBACompatibility.hpp>
+#include <com/sun/star/document/XVbaMethodParameter.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 
 using namespace com::sun::star;
@@ -500,7 +500,6 @@ IMPL_LINK( AsyncQuitHandler, OnAsyncQuit, void*, /*pNull*/ )
     return 0L;
 }
 
-#if 0
 bool UnlockControllerHack( StarBASIC* pBasic )
 {
     bool bRes = false;
@@ -526,7 +525,7 @@ bool UnlockControllerHack( StarBASIC* pBasic )
     }
     return bRes;
 }
-#endif
+
 /////////////////////////////////////////////////////////////////////////////
 
 // Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
@@ -795,6 +794,82 @@ void SbModule::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
         SbxVariable* pVar = pHint->GetVar();
         SbProperty* pProp = PTR_CAST(SbProperty,pVar);
         SbMethod* pMeth = PTR_CAST(SbMethod,pVar);
+		SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
+        if( pProcProperty )
+        {
+
+            if( pHint->GetId() == SBX_HINT_DATAWANTED )
+            {
+                String aProcName;
+                aProcName.AppendAscii( "Property Get " );
+                aProcName += pProcProperty->GetName();
+
+                SbxVariable* pMethVar = Find( aProcName, SbxCLASS_METHOD );
+                if( pMethVar )
+                {
+                    SbxValues aVals;
+                    aVals.eType = SbxVARIANT;
+
+                    SbxArray* pArg = pVar->GetParameters();
+                    USHORT nVarParCount = (pArg != NULL) ? pArg->Count() : 0;
+                    if( nVarParCount > 1 )
+                    {
+                        SbxArrayRef xMethParameters = new SbxArray;
+                        xMethParameters->Put( pMethVar, 0 );	// Method as parameter 0
+                        for( USHORT i = 1 ; i < nVarParCount ; ++i )
+                        {
+                            SbxVariable* pPar = pArg->Get( i );
+                            xMethParameters->Put( pPar, i );
+                        }
+
+                        pMethVar->SetParameters( xMethParameters );
+                        pMethVar->Get( aVals );
+                        pMethVar->SetParameters( NULL );
+                    }
+                    else
+                    {
+                        pMethVar->Get( aVals );
+                    }
+
+                    pVar->Put( aVals );
+                }
+            }
+            else if( pHint->GetId() == SBX_HINT_DATACHANGED )
+            {
+                SbxVariable* pMethVar = NULL;
+
+                bool bSet = pProcProperty->isSet();
+                if( bSet )
+                {
+                    pProcProperty->setSet( false );
+
+                    String aProcName;
+                    aProcName.AppendAscii( "Property Set " );
+                    aProcName += pProcProperty->GetName();
+                    pMethVar = Find( aProcName, SbxCLASS_METHOD );
+                }
+                if( !pMethVar )	// Let
+                {
+                    String aProcName;
+                    aProcName.AppendAscii( "Property Let " );
+                    aProcName += pProcProperty->GetName();
+                    pMethVar = Find( aProcName, SbxCLASS_METHOD );
+                }
+
+                if( pMethVar )
+                {
+                    // Setup parameters
+                    SbxArrayRef xArray = new SbxArray;
+                    xArray->Put( pMethVar, 0 );	// Method as parameter 0
+                    xArray->Put( pVar, 1 );
+                    pMethVar->SetParameters( xArray );
+
+                    SbxValues aVals;
+                    pMethVar->Get( aVals );
+                    pMethVar->SetParameters( NULL );
+                }
+            }
+        }
         if( pProp )
         {
             if( pProp->GetModule() != this )
@@ -849,6 +925,7 @@ void SbModule::SetSource32( const ::rtl::OUString& r )
     aOUSource = r;
     StartDefinitions();
     SbiTokenizer aTok( r );
+        aTok.SetCompatible( IsVBACompat() );
     while( !aTok.IsEof() )
     {
         SbiToken eEndTok = NIL;
@@ -1036,12 +1113,14 @@ void SbModule::SetVBACompat( BOOL bCompat )
 // Ausfuehren eines BASIC-Unterprogramms
 USHORT SbModule::Run( SbMethod* pMeth )
 {
+	OSL_TRACE("About to run %s, vba compatmode is %d", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), mbVBACompat );
     static USHORT nMaxCallLevel = 0;
     static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
     static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
 
     USHORT nRes = 0;
     BOOL bDelInst = BOOL( pINST == NULL );
+        bool bQuit = false;
     StarBASICRef xBasic;
     if( bDelInst )
     {
@@ -1174,6 +1253,15 @@ USHORT SbModule::Run( SbMethod* pMeth )
 
             delete pRt;
             pMOD = pOldMod;
+			if ( pINST->nCallLvl == 0 && IsVBACompat() )
+			{
+				// VBA always ensure screenupdating is enabled after completing
+				StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
+				if ( pBasic && pBasic->IsDocBasic() )
+				{
+					UnlockControllerHack( pBasic );
+				}
+			}
             if( bDelInst )
             {
                 // #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -1201,10 +1289,8 @@ USHORT SbModule::Run( SbMethod* pMeth )
 
     // VBA always ensure screenupdating is enabled after completing
     StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
-#if 0
     if ( pBasic && pBasic->IsDocBasic() && !pINST )
         UnlockControllerHack( pBasic );
-#endif
     if( bDelInst )
     {
         // #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -1215,6 +1301,8 @@ USHORT SbModule::Run( SbMethod* pMeth )
         pINST = NULL;
     }
     if ( pBasic && pBasic->IsDocBasic() && pBasic->IsQuitApplication() && !pINST )
+            bQuit = true;
+        if ( bQuit )
     {
         Application::PostUserEvent( LINK( &AsyncQuitHandler::instance(), AsyncQuitHandler, OnAsyncQuit ), NULL );
     }
@@ -1676,6 +1764,48 @@ BOOL SbModule::ExceedsLegacyModuleSize()
     return false;
 }
 
+class ErrorHdlResetter
+{
+    Link    mErrHandler;
+    bool mbError;
+    public:
+    ErrorHdlResetter() : mbError( false )
+    {
+        // save error handler 
+        mErrHandler = StarBASIC::GetGlobalErrorHdl();
+        // set new error handler
+        StarBASIC::SetGlobalErrorHdl( LINK( this, ErrorHdlResetter, BasicErrorHdl ) );
+    }
+    ~ErrorHdlResetter()
+    {
+        // restore error handler 
+        StarBASIC::SetGlobalErrorHdl(mErrHandler);
+    }
+    DECL_LINK( BasicErrorHdl, StarBASIC * );
+    bool HasError() { return mbError; }
+};
+IMPL_LINK( ErrorHdlResetter, BasicErrorHdl, StarBASIC *, /*pBasic*/)
+{
+    mbError = true;
+    return 0;        
+}
+
+bool SbModule::HasExeCode()
+{
+
+        ErrorHdlResetter aGblErrHdl;
+	// And empty Image always has the Global Chain set up
+        static const unsigned char pEmptyImage[] = { 0x45, 0x0 , 0x0, 0x0, 0x0 };
+        // lets be stricter for the moment than VBA
+
+	bool bRes = false;
+	if ( !IsCompiled() )
+		Compile();
+	if ( pImage && !( pImage->GetCodeSize() == 5 && ( memcmp( pImage->GetCode(), pEmptyImage, pImage->GetCodeSize() ) == 0 ) )
+        || aGblErrHdl.HasError() )
+		bRes = true;
+	return bRes;
+}
 
 // Store only image, no source
 BOOL SbModule::StoreBinaryData( SvStream& rStrm )
@@ -1725,7 +1855,6 @@ BOOL SbModule::LoadBinaryData( SvStream& rStrm )
     return bRet;
 }
 
-
 BOOL SbModule::LoadCompleted()
 {
     SbxArray* p = GetMethods();
@@ -1793,6 +1922,7 @@ SbMethod::SbMethod( const String& r, SbxDataType t, SbModule* p )
     nLine1		 =
     nLine2		 = 0;
     refStatics = new SbxArray;
+    mCaller          = 0;
     // AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
     SetFlag( SBX_NO_MODIFY );
 }
@@ -1807,6 +1937,7 @@ SbMethod::SbMethod( const SbMethod& r )
     nLine1		 = r.nLine1;
     nLine2		 = r.nLine2;
         refStatics = r.refStatics; 
+ 	mCaller          = r.mCaller; 
     SetFlag( SBX_NO_MODIFY );
 }
 
@@ -1875,8 +2006,13 @@ SbxInfo* SbMethod::GetInfo()
 // Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
 // #34191# Mit speziellem RefCounting, damit das Basic nicht durch CloseDocument()
 // abgeschossen werden kann. Rueckgabewert wird als String geliefert.
-ErrCode SbMethod::Call( SbxValue* pRet )
+ErrCode SbMethod::Call( SbxValue* pRet, SbxVariable* pCaller )
 {
+	if ( pCaller )
+	{
+ 		OSL_TRACE("SbMethod::Call Have been passed a caller 0x%x", pCaller );
+		mCaller = pCaller;
+	}
     // RefCount vom Modul hochzaehlen
     SbModule* pMod_ = (SbModule*)GetParent();
     pMod_->AddRef();
@@ -1904,7 +2040,7 @@ ErrCode SbMethod::Call( SbxValue* pRet )
     // Objekte freigeben
     pMod_->ReleaseRef();
     pBasic->ReleaseRef();
-
+	mCaller = 0;
     return nErr;
 }
 
@@ -2087,9 +2223,8 @@ public:
     }
     
     //liuchen 2009-7-21, support Excel VBA Form_QueryClose event
-    virtual void SAL_CALL windowClosing( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    virtual void SAL_CALL windowClosing( const lang::EventObject& e ) throw (uno::RuntimeException)
     {    
-#if IN_THE_FUTURE
         uno::Reference< awt::XDialog > xDialog( e.Source, uno::UNO_QUERY );
         if ( xDialog.is() )
         {
@@ -2117,7 +2252,6 @@ public:
         }
         
         mpUserForm->triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ) );
-#endif
     }
     //liuchen 2009-7-21
     
@@ -2214,14 +2348,13 @@ void SbUserFormModule::triggerMethod( const String& aMethodToRun )
     Sequence< Any > aArguments;
     triggerMethod( aMethodToRun, aArguments );
 }
-void SbUserFormModule::triggerMethod( const String& aMethodToRun, Sequence< Any >& /*aArguments*/)
+void SbUserFormModule::triggerMethod( const String& aMethodToRun, Sequence< Any >& aArguments)
 {
     OSL_TRACE("*** trigger %s ***", rtl::OUStringToOString( aMethodToRun, RTL_TEXTENCODING_UTF8 ).getStr() );
     // Search method
     SbxVariable* pMeth = SbObjModule::Find( aMethodToRun, SbxCLASS_METHOD );
     if( pMeth )
     {		
-#if IN_THE_FUTURE
                  //liuchen 2009-7-21, support Excel VBA UserForm_QueryClose event with parameters
         if ( aArguments.getLength() > 0 )   // Setup parameters
         {
@@ -2251,7 +2384,6 @@ void SbUserFormModule::triggerMethod( const String& aMethodToRun, Sequence< Any
         }
         else
 //liuchen 2009-7-21
-#endif
         {
             SbxValues aVals;
             pMeth->Get( aVals );
@@ -2414,7 +2546,7 @@ void SbUserFormModule::InitObject()
             aArgs[ 0 ] = uno::Any();
             aArgs[ 1 ] <<= m_xDialog;
             aArgs[ 2 ] <<= m_xModel;
-            aArgs[ 3 ] <<= rtl::OUString( GetParent()->GetName() );
+            aArgs[ 3 ] <<= sProjectName;
             pDocObject = new SbUnoObject( GetName(), uno::makeAny( xVBAFactory->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.UserForm")), aArgs  ) ) );
             uno::Reference< lang::XComponent > xComponent( aArgs[ 1 ], uno::UNO_QUERY_THROW );
             // remove old listener if it exists
diff --git basic/source/comp/codegen.cxx basic/source/comp/codegen.cxx
index c7e8f11..be7c357 100644
--- basic/source/comp/codegen.cxx
+++ basic/source/comp/codegen.cxx
@@ -161,8 +161,6 @@ void SbiCodeGen::Save()
         rMod.bIsProxyModule = false;
     }
 
-    if( pParser->bText )
-        p->SetFlag( SBIMG_COMPARETEXT );
     // GlobalCode-Flag
     if( pParser->HasGlobalCode() )
         p->SetFlag( SBIMG_INITCODE );
@@ -242,6 +240,8 @@ void SbiCodeGen::Save()
                     if( nPass == 1 )
                         aPropName = aPropName.Copy( aIfaceName.Len() + 1 );
                     SbProcedureProperty* pProcedureProperty = NULL;
+                                        OSL_TRACE("*** getProcedureProperty for thing %s",
+						rtl::OUStringToOString( aPropName,RTL_TEXTENCODING_UTF8 ).getStr() );
                     pProcedureProperty = rMod.GetProcedureProperty( aPropName, ePropType );
                 }
                 if( nPass == 1 )
diff --git basic/source/comp/dim.cxx basic/source/comp/dim.cxx
index b5131c9..19d9d38 100644
--- basic/source/comp/dim.cxx
+++ basic/source/comp/dim.cxx
@@ -29,6 +29,8 @@
 #include "precompiled_basic.hxx"
 #include <basic/sbx.hxx>
 #include "sbcomp.hxx"
+#include "sbunoobj.hxx"
+
 
 SbxObject* cloneTypeObjectImpl( const SbxObject& rTypeObj );
 
@@ -153,7 +155,7 @@ void SbiParser::TypeDecl( SbiSymDef& rDef, BOOL bAsNewAlreadyParsed )
                             }
                         }
                     }
-                    else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) )
+					else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) || ( IsVBASupportOn() && VBAConstantHelper::instance().isVBAConstantType( aCompleteName ) ) )
                     {
                         eType = SbxLONG;
                         break;
@@ -423,7 +425,10 @@ void SbiParser::DefVar( SbiOpcode eOp, BOOL bStatic )
                 aExpr.Gen();
                 SbiOpcode eOp_ = pDef->IsNew() ? _CREATE : _TCREATE;
                 aGen.Gen( eOp_, pDef->GetId(), pDef->GetTypeId() );
-                aGen.Gen( _SET );
+				if ( bVBASupportOn )
+					aGen.Gen( _VBASET );
+				else	
+					aGen.Gen( _SET );
             }
         }
         else
@@ -975,6 +980,24 @@ void SbiParser::DefDeclare( BOOL bPrivate )
     }
 }
 
+void SbiParser::Attribute()
+{
+	// TODO: Need to implement the method as an attributed object.
+	while( Next() != EQ )
+	{
+		String aSym( GetSym() );
+		if( Next() != DOT) 
+			break;
+	}
+	
+	if( eCurTok != EQ )
+		Error( SbERR_SYNTAX );
+	else
+		SbiExpression aValue( this );
+
+	// Don't generate any code - just discard it.
+}
+
 // Aufruf einer SUB oder FUNCTION
 
 void SbiParser::Call()
diff --git basic/source/comp/exprtree.cxx basic/source/comp/exprtree.cxx
index 389b9e4..dd696d5 100644
--- basic/source/comp/exprtree.cxx
+++ basic/source/comp/exprtree.cxx
@@ -382,8 +382,12 @@ SbiExprNode* SbiExpression::Term( const KeywordSymbolInfo* pKeywordSymbolInfo )
         // Typ SbxOBJECT sein
         if( pDef->GetType() != SbxOBJECT && pDef->GetType() != SbxVARIANT )
         {
-            pParser->Error( SbERR_BAD_DECLARATION, aSym );
-            bError = TRUE;
+			// defer error until runtime if in vba mode
+			if ( !pParser->IsVBASupportOn() )
+                        {
+				pParser->Error( SbERR_BAD_DECLARATION, aSym );
+				bError = TRUE;
+			}
         }
         if( !bError )
             pNd->aVar.pNext = ObjTerm( *pDef );
@@ -589,7 +593,11 @@ SbiExprNode* SbiExpression::Unary()
             eTok = NEG;
         case NOT:
             pParser->Next();
-            pNd = new SbiExprNode( pParser, Unary(), eTok, NULL );
+            // process something like "Do While Not "foo"="" "
+            if( pParser->IsVBASupportOn() )
+                pNd = new SbiExprNode( pParser, Like(), eTok, NULL );
+            else    
+                pNd = new SbiExprNode( pParser, Unary(), eTok, NULL );
             break;
         case PLUS:
             pParser->Next();
@@ -745,7 +753,7 @@ SbiExprNode* SbiExpression::Like()
             pNd = new SbiExprNode( pParser, pNd, eTok, Comp() ), nCount++;
         }
         // Mehrere Operatoren hintereinander gehen nicht
-        if( nCount > 1 )
+		if( nCount > 1 && !pParser->IsVBASupportOn() )
         {
             pParser->Error( SbERR_SYNTAX );
             bError = TRUE;
diff --git basic/source/comp/parser.cxx basic/source/comp/parser.cxx
index 83e7bbd..81fd9d6 100644
--- basic/source/comp/parser.cxx
+++ basic/source/comp/parser.cxx
@@ -49,6 +49,7 @@ struct SbiStatement {
 #define	N	FALSE
 
 static SbiStatement StmntTable [] = {
+{ ATTRIBUTE, &SbiParser::Attribute, Y, Y, }, // ATTRIBUTE
 { CALL,		&SbiParser::Call,   	N, Y, }, // CALL
 { CLOSE,	&SbiParser::Close,		N, Y, }, // CLOSE
 { _CONST_,	&SbiParser::Dim, 		Y, Y, }, // CONST
@@ -387,6 +388,18 @@ BOOL SbiParser::Parse()
         Next(); return TRUE;
     }
 
+        // In vba it's possible to do Error.foobar ( even if it results in
+	// a runtime error
+        if ( eCurTok == _ERROR_ && IsVBASupportOn() ) // we probably need to define a subset of keywords where this madness applies e.g. if ( IsVBASupportOn() && SymbolCanBeRedined( eCurTok ) )
+        {
+            SbiTokenizer tokens( *(SbiTokenizer*)this );
+            tokens.Next();
+            if ( tokens.Peek()  == DOT )
+            {
+                eCurTok = SYMBOL;
+		ePush = eCurTok;
+            }
+	}
     // Kommt ein Symbol, ist es entweder eine Variable( LET )
     // oder eine SUB-Prozedur( CALL ohne Klammern )
     // DOT fuer Zuweisungen im WITH-Block: .A=5
@@ -795,7 +808,7 @@ void SbiParser::Option()
             bClassModule = TRUE; 
             aGen.GetModule().SetModuleType( com::sun::star::script::ModuleType::CLASS );
             break;
-        case VBASUPPORT:
+		case VBASUPPORT: // Option VBASupport used to override the module mode ( in fact this must reset the mode
             if( Next() == NUMBER )
             {
                 if ( nVal == 1 || nVal == 0 )
diff --git basic/source/comp/token.cxx basic/source/comp/token.cxx
index 0069079..25dd885 100644
--- basic/source/comp/token.cxx
+++ basic/source/comp/token.cxx
@@ -58,6 +58,7 @@ static TokenTable aTokTable_Basic [] = {		// Token-Tabelle:
     { ANY,		"Any" },
     { APPEND,	"Append" },
     { AS,		"As" },
+	{ ATTRIBUTE,"Attribute" },
     { BASE,		"Base" },
     { BINARY,	"Binary" },
     { TBOOLEAN,	"Boolean" },
diff --git basic/source/inc/dlgcont.hxx basic/source/inc/dlgcont.hxx
index 7d22f4d..fe70a45 100644
--- basic/source/inc/dlgcont.hxx
+++ basic/source/inc/dlgcont.hxx
@@ -96,7 +96,9 @@ public:
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Service
     static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static();
     static ::rtl::OUString getImplementationName_static();
diff --git basic/source/inc/namecont.hxx basic/source/inc/namecont.hxx
index 72cdcee..29bc734 100644
--- basic/source/inc/namecont.hxx
+++ basic/source/inc/namecont.hxx
@@ -35,6 +35,7 @@
 #include <com/sun/star/script/XStorageBasedLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/script/XLibraryContainerExport.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
 #include <com/sun/star/script/XLibraryContainer3.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/container/XContainer.hpp>
@@ -59,6 +60,7 @@
 
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/compbase8.hxx>
+#include <cppuhelper/compbase9.hxx>
 #include <cppuhelper/interfacecontainer.hxx>
 #include <com/sun/star/script/vba/XVBACompatibility.hpp>
 
@@ -67,13 +69,14 @@ class BasicManager;
 namespace basic
 {
 
-typedef ::cppu::WeakComponentImplHelper8< 
+typedef ::cppu::WeakComponentImplHelper9< 
     ::com::sun::star::lang::XInitialization,
     ::com::sun::star::script::XStorageBasedLibraryContainer,
     ::com::sun::star::script::XLibraryContainerPassword,
     ::com::sun::star::script::XLibraryContainerExport,
     ::com::sun::star::script::XLibraryContainer3,
     ::com::sun::star::container::XContainer,
+    ::com::sun::star::script::XLibraryQueryExecutable,
     ::com::sun::star::script::vba::XVBACompatibility,
     ::com::sun::star::lang::XServiceInfo > LibraryContainerHelper;
 
diff --git basic/source/inc/parser.hxx basic/source/inc/parser.hxx
index 4fb7b18..f9a159d 100644
--- basic/source/inc/parser.hxx
+++ basic/source/inc/parser.hxx
@@ -106,6 +106,7 @@ public:
     void BadSyntax();				// Falsches SbiToken
     void NoIf();					// ELSE/ELSE IF ohne IF
     void Assign();					// LET
+    void Attribute();                                   // Attribute
     void Call();					// CALL
     void Close();					// CLOSE
     void Declare();					// DECLARE
diff --git basic/source/inc/runtime.hxx basic/source/inc/runtime.hxx
index 96de7e5..b95b13c 100644
--- basic/source/inc/runtime.hxx
+++ basic/source/inc/runtime.hxx
@@ -203,7 +203,6 @@ class SbiInstance
     BOOL			bCompatibility; // Flag: TRUE = VBA runtime compatibility mode
 
     ComponentVector_t ComponentVector;
-
 public:
     SbiRuntime*  pRun;        		// Call-Stack
     SbiInstance* pNext;             // Instanzen-Chain
@@ -292,7 +291,9 @@ class SbiRuntime
     SbxArrayRef   refExprStk;       // expression stack
     SbxArrayRef   refCaseStk;       // CASE expression stack
     SbxArrayRef   refRedimpArray;   // Array saved to use for REDIM PRESERVE
+	SbxVariableRef   refRedim;   // Array saved to use for REDIM
     SbxVariableRef xDummyVar;		// Ersatz fuer nicht gefundene Variablen
+	SbxVariable* mpExtCaller;		// Caller ( external - e.g. button name, shape, range object etc. - only in vba mode )
     SbiArgvStack*  pArgvStk;		// ARGV-Stack
     SbiGosubStack* pGosubStk;		// GOSUB stack
     SbiForStack*   pForStk;			// FOR/NEXT-Stack
@@ -462,6 +463,7 @@ public:
     SbMethod* GetCaller();
     SbxArray* GetLocals();
     SbxArray* GetParams();
+	SbxVariable* GetExternalCaller(){ return mpExtCaller; }
 
     SbxBase* FindElementExtern( const String& rName );
     static bool isVBAEnabled();
diff --git basic/source/inc/sbunoobj.hxx basic/source/inc/sbunoobj.hxx
index b8993c1..edbe260 100644
--- basic/source/inc/sbunoobj.hxx
+++ basic/source/inc/sbunoobj.hxx
@@ -43,6 +43,7 @@
 #include <com/sun/star/reflection/XServiceTypeDescription2.hpp> 
 #include <com/sun/star/reflection/XSingletonTypeDescription.hpp> 
 #include <rtl/ustring.hxx>
+#include <hash_map>
 
 class SbUnoObject: public SbxObject
 {
@@ -320,6 +321,26 @@ public:
     virtual void Clear();
 };
 
+typedef std::hash_map< ::rtl::OUString, ::com::sun::star::uno::Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
+
+typedef std::vector< rtl::OUString > VBAConstantsVector;
+
+class VBAConstantHelper
+{
+private:
+
+    VBAConstantsVector aConstCache;
+    VBAConstantsHash aConstHash;
+    bool isInited;
+    VBAConstantHelper():isInited( false ) {}
+    VBAConstantHelper(const VBAConstantHelper&);
+    void init();
+public:    
+    static VBAConstantHelper& instance(); 
+    SbxVariable* getVBAConstant( const String& rName );
+    bool isVBAConstantType( const String& rName );
+};
+
 #endif
 
 
diff --git basic/source/inc/scriptcont.hxx basic/source/inc/scriptcont.hxx
index 71ad535..3fb35ed 100644
--- basic/source/inc/scriptcont.hxx
+++ basic/source/inc/scriptcont.hxx
@@ -122,7 +122,9 @@ public:
         throw (::com::sun::star::lang::IllegalArgumentException, 
                ::com::sun::star::container::NoSuchElementException, 
                ::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Methods XServiceInfo
     virtual ::rtl::OUString SAL_CALL getImplementationName( )
         throw (::com::sun::star::uno::RuntimeException);
diff --git basic/source/inc/token.hxx basic/source/inc/token.hxx
index 7c3ff75..068a107 100644
--- basic/source/inc/token.hxx
+++ basic/source/inc/token.hxx
@@ -72,7 +72,7 @@ enum SbiToken {
     IF, _IN_, INPUT,
     LET, LINE, LINEINPUT, LOCAL, LOOP, LPRINT, LSET,
     NAME, NEW, NEXT,
-    ON, OPEN, OPTION, IMPLEMENTS,
+	ON, OPEN, OPTION, ATTRIBUTE, IMPLEMENTS,
     PRINT, PRIVATE, PROPERTY, PUBLIC,
     REDIM, REM, RESUME, RETURN, RSET,
     SELECT, SET, SHARED, STATIC, STEP, STOP, SUB,
diff --git basic/source/runtime/methods.cxx basic/source/runtime/methods.cxx
index cafa0ee..a8e7d84 100644
--- basic/source/runtime/methods.cxx
+++ basic/source/runtime/methods.cxx
@@ -48,6 +48,7 @@
 #include <unotools/ucbstreamhelper.hxx>
 #include <tools/wldcrd.hxx>
 #include <i18npool/lang.h>
+#include <rtl/string.hxx>
 
 #include "runtime.hxx"
 #include "sbunoobj.hxx"
@@ -75,13 +76,16 @@
 #include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XSeekable.hpp>
-
+#include <com/sun/star/script/XErrorQuery.hpp>
+#include <ooo/vba/XHelperInterface.hpp>
+#include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 using namespace comphelper;
 using namespace osl;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::ucb;
 using namespace com::sun::star::io;
+using namespace com::sun::star::script;
 
 #endif /* _USE_UNO */
 
@@ -103,6 +107,8 @@ using namespace com::sun::star::io;
 #include <stdlib.h>
 #include <ctype.h>
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 #if defined (WIN) || defined (WNT) || defined (OS2)
 #include <direct.h>   // _getdcwd get current work directory, _chdrive
 #endif
@@ -121,6 +127,9 @@ using namespace com::sun::star::io;
 #include <io.h>
 #endif
 
+
+#include <basic/sbobjmod.hxx>
+
 #include <basic/sbobjmod.hxx>
 
 static void FilterWhiteSpace( String& rStr )
@@ -706,6 +716,36 @@ RTLFUNC(MkDir) // JSM
             {
                 try
                 {
+					if ( SbiRuntime::isVBAEnabled() )
+					{
+						// If aPath is the folder name, not a path, then create the folder under current directory.
+						INetURLObject aTryPathURL( aPath );
+						::rtl::OUString sPathURL = aTryPathURL.GetMainURL( INetURLObject::NO_DECODE );
+						if ( !sPathURL.getLength() )
+						{
+							File::getFileURLFromSystemPath( aPath, sPathURL );
+						}
+						INetURLObject aPathURL( sPathURL );
+						if ( !aPathURL.GetPath().getLength() )
+						{
+							::rtl::OUString sCurDirURL;
+							SbxArrayRef pPar = new SbxArray;
+							SbxVariableRef pVar = new SbxVariable();
+							pPar->Put( pVar, 0 );
+							SbRtl_CurDir( pBasic, *pPar, FALSE );
+							String aCurPath = pPar->Get(0)->GetString();
+
+							File::getFileURLFromSystemPath( aCurPath, sCurDirURL );
+							INetURLObject aDirURL( sCurDirURL );
+							aDirURL.Append( aPath );
+							::rtl::OUString aTmpPath = aDirURL.GetMainURL( INetURLObject::NO_DECODE );
+							if ( aTmpPath.getLength() > 0 )
+							{
+								aPath = aTmpPath;
+							}
+						}
+					}
+
                     xSFI->createFolder( getFullPath( aPath ) );
                 }
                 catch( Exception & )
@@ -940,6 +980,26 @@ RTLFUNC(Hex)
     }
 }
 
+RTLFUNC(FuncCaller)
+{
+    (void)pBasic;
+    (void)bWrite;
+    if ( SbiRuntime::isVBAEnabled() &&  pINST && pINST->pRun )
+    {
+        if ( pINST->pRun->GetExternalCaller() )
+            *rPar.Get(0) =  *pINST->pRun->GetExternalCaller();
+        else
+        {
+            SbxVariableRef pVar = new SbxVariable(SbxVARIANT);
+            *rPar.Get(0) = *pVar;
+        }
+    }
+    else
+    {
+        StarBASIC::Error( SbERR_NOT_IMPLEMENTED );
+    }
+
+}
 // InStr( [start],string,string,[compare] )
 
 RTLFUNC(InStr)
@@ -2411,7 +2471,18 @@ RTLFUNC(IsEmpty)
     if ( rPar.Count() < 2 )
         StarBASIC::Error( SbERR_BAD_ARGUMENT );
     else
-        rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	{
+		SbxVariable* pVar = NULL;
+		if( SbiRuntime::isVBAEnabled() )
+			pVar = getDefaultProp( rPar.Get(1) );
+		if ( pVar )
+		{
+			pVar->Broadcast( SBX_HINT_DATAWANTED );
+			rPar.Get( 0 )->PutBool( pVar->IsEmpty() );
+		}
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	}
 }
 
 RTLFUNC(IsError)
@@ -2422,7 +2493,22 @@ RTLFUNC(IsError)
     if ( rPar.Count() < 2 )
         StarBASIC::Error( SbERR_BAD_ARGUMENT );
     else
-        rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	{
+		SbxVariable* pVar =rPar.Get( 1 );
+		SbUnoObject* pObj = PTR_CAST(SbUnoObject,pVar );
+                if ( !pObj )
+                { 
+                    if ( SbxBase* pBaseObj = pVar->GetObject() )
+                        pObj = PTR_CAST(SbUnoObject, pBaseObj );
+                }
+		Reference< XErrorQuery > xError;
+		if ( pObj )
+			xError.set( pObj->getUnoAny(), UNO_QUERY );
+		if ( xError.is() )
+			rPar.Get( 0 )->PutBool( xError->hasError() );
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	}
 }
 
 RTLFUNC(IsNull)
@@ -3542,6 +3628,13 @@ RTLFUNC(Shell)
             NAMESPACE_VOS(OArgumentList) aArgList( pArgumentList, nParamCount );
             bSucc = pApp->execute( eOptions, aArgList ) == NAMESPACE_VOS(OProcess)::E_None;
         }
+		long nResult = 0;
+		NAMESPACE_VOS(OProcess)::TProcessInfo aInfo;
+		// We should return the identifier of the executing process when is running VBA, because method Shell(...) returns it in Excel.
+		if ( bSucc && SbiRuntime::isVBAEnabled() && pApp->getInfo( NAMESPACE_VOS(OProcess)::TData_Identifier, &aInfo ) == NAMESPACE_VOS(OProcess)::E_None )
+		{
+			nResult = aInfo.Ident;
+		}
 
         /*
         if( nParamCount == 0 )
@@ -3556,7 +3649,7 @@ RTLFUNC(Shell)
         if( !bSucc )
             StarBASIC::Error( SbERR_FILE_NOT_FOUND );
         else
-            rPar.Get(0)->PutLong( 0 );
+			rPar.Get(0)->PutLong( nResult );
     }
 }
 
@@ -3627,6 +3720,65 @@ String getBasicTypeName( SbxDataType eType )
     return aRetStr;
 }
 
+String getObjectTypeName( SbxVariable* pVar )
+{
+    rtl::OUString sRet( RTL_CONSTASCII_USTRINGPARAM("Object") );
+    if ( pVar )
+    {
+        SbxBase* pObj = pVar->GetObject();
+        if( !pObj )
+           sRet = String( RTL_CONSTASCII_USTRINGPARAM("Nothing") );
+        else
+        {
+            SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,pVar );
+            if ( !pUnoObj )
+            { 
+                if ( SbxBase* pBaseObj = pVar->GetObject() )
+                    pUnoObj = PTR_CAST(SbUnoObject, pBaseObj );
+            }
+            if ( pUnoObj )
+            { 
+                Any aObj = pUnoObj->getUnoAny();
+                // For upstreaming unless we start to build oovbaapi by default
+                // we need to get detect the vba-ness of the object in some
+                // other way        
+                // note: Automation objects do not support XServiceInfo
+                Reference< XServiceInfo > xServInfo( aObj, UNO_QUERY );
+                if ( xServInfo.is() )
+                {
+                    // is this a VBA object ?
+                    Reference< ooo::vba::XHelperInterface > xVBA( aObj, UNO_QUERY );
+                    Sequence< rtl::OUString > sServices = xServInfo->getSupportedServiceNames();
+                    if ( sServices.getLength() )
+                        sRet = sServices[ 0 ];
+                }
+                else
+                {
+                    Reference< com::sun::star::bridge::oleautomation::XAutomationObject > xAutoMation( aObj, UNO_QUERY );
+                    if ( xAutoMation.is() )
+                    {
+                        Reference< XInvocation > xInv( aObj, UNO_QUERY );
+                        if ( xInv.is() )
+                        {
+                            try
+                            {
+                                xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sRet;
+                            }
+                            catch( Exception& )
+                            {
+                            }
+                        }
+                    }
+                }
+                sal_Int32 nDot = sRet.lastIndexOf( '.' );
+                if ( nDot != -1 && nDot < sRet.getLength() )
+                       sRet = sRet.copy( nDot + 1 );
+            }
+        }
+    }         
+    return sRet;
+}
+
 RTLFUNC(TypeName)
 {
     (void)pBasic;
@@ -3638,7 +3790,12 @@ RTLFUNC(TypeName)
     {
         SbxDataType eType = rPar.Get(1)->GetType();
         BOOL bIsArray = ( ( eType & SbxARRAY ) != 0 );
-        String aRetStr = getBasicTypeName( eType );
+
+        String aRetStr;
+        if ( SbiRuntime::isVBAEnabled() && eType == SbxOBJECT )
+            aRetStr = getObjectTypeName( rPar.Get(1) );
+        else
+            aRetStr = getBasicTypeName( eType );
         if( bIsArray )
             aRetStr.AppendAscii( "()" );
         rPar.Get(0)->PutString( aRetStr );
diff --git basic/source/runtime/methods1.cxx basic/source/runtime/methods1.cxx
index f22a52c..9d3b51a 100644
--- basic/source/runtime/methods1.cxx
+++ basic/source/runtime/methods1.cxx
@@ -78,11 +78,15 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/i18n/XCalendar.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
 
 using namespace comphelper;
+using namespace com::sun::star::sheet;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::i18n;
 
+void unoToSbxValue( SbxVariable* pVar, const Any& aValue );
+Any sbxToUnoValue( SbxVariable* pVar, const Type& rType, com::sun::star::beans::Property* pUnoProperty = NULL );
 
 static Reference< XCalendar > getLocaleCalendar( void )
 {
@@ -2518,6 +2522,546 @@ RTLFUNC(Round)
     rPar.Get(0)->PutDouble( dRes );
 }
 
+void CallFunctionAccessFunction( const Sequence< Any >& aArgs, const rtl::OUString& sFuncName, SbxVariable* pRet )
+{
+    static Reference< XFunctionAccess > xFunc;
+    Any aRes;
+    try
+    {
+        if ( !xFunc.is() )
+        {
+            Reference< XMultiServiceFactory > xFactory( getProcessServiceFactory() );
+            if( xFactory.is() )
+            {
+                xFunc.set( xFactory->createInstance(::rtl::OUString::createFromAscii( "com.sun.star.sheet.FunctionAccess")), UNO_QUERY_THROW); 
+            }
+        }
+        Any aRet = xFunc->callFunction( sFuncName, aArgs );
+     
+        unoToSbxValue( pRet, aRet );
+
+    }
+    catch( Exception& )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+    }
+}
+
+RTLFUNC(SYD)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 4 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    aParams[ 3 ] <<= makeAny( rPar.Get(4)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SYD") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(SLN)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SLN") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Pmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Pmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetDouble();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    Any aValues = sbxToUnoValue( rPar.Get(2),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 1 ] <<= aValues;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPer)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double pmt = rPar.Get(2)->GetDouble();
+    double pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPer") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(MIRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("MIRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    // set default values for Optional args
+    double guess = 0.1;    
+    // guess
+    if ( nArgCount >= 2 )
+    {
+        if( rPar.Get(2)->GetType() != SbxEMPTY )
+            guess = rPar.Get(2)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetInteger();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(FV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double pv = 0;    
+    double type = 0;    
+    
+    // pv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            pv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(DDB)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double cost = rPar.Get(1)->GetDouble();
+    double salvage = rPar.Get(2)->GetDouble();
+    double life = rPar.Get(3)->GetDouble();
+    double period = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double factor = 2;    
+    
+    // factor
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            factor = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= cost;
+    aParams[ 1 ] <<= salvage;
+    aParams[ 2 ] <<= life;
+    aParams[ 3 ] <<= period;
+    aParams[ 4 ] <<= factor;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DDB") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Rate)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double nper = 0;    
+    double pmt = 0;    
+    double pv = 0;
+
+    nper = rPar.Get(1)->GetDouble();
+    pmt = rPar.Get(2)->GetDouble();
+    pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    double guess = 0.1;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    // guess
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= nper;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    aParams[ 5 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Rate") ), rPar.Get( 0 ) );
+}
+
 RTLFUNC(StrReverse)
 {
     (void)pBasic;
diff --git basic/source/runtime/rtlproto.hxx basic/source/runtime/rtlproto.hxx
index e3b2a05..b1145c8 100644
--- basic/source/runtime/rtlproto.hxx
+++ basic/source/runtime/rtlproto.hxx
@@ -165,29 +165,41 @@ extern RTLFUNC(Kill); // JSM
 extern RTLFUNC(MkDir); // JSM
 extern RTLFUNC(RmDir); // JSM
 extern RTLFUNC(SendKeys); // JSM
+extern RTLFUNC(DDB);
 extern RTLFUNC(DimArray);
 extern RTLFUNC(Dir);
 extern RTLFUNC(DoEvents);
 extern RTLFUNC(Exp);
 extern RTLFUNC(FileLen);
 extern RTLFUNC(Fix);
+extern RTLFUNC(FV);
 extern RTLFUNC(Hex);
 extern RTLFUNC(Input);
 extern RTLFUNC(InStr);
 extern RTLFUNC(InStrRev);
 extern RTLFUNC(Int);
+extern RTLFUNC(IPmt);
+extern RTLFUNC(IRR);
 extern RTLFUNC(Join);
 extern RTLFUNC(LCase);
 extern RTLFUNC(Left);
 extern RTLFUNC(Log);
 extern RTLFUNC(LTrim);
 extern RTLFUNC(Mid);
+extern RTLFUNC(MIRR);
+extern RTLFUNC(NPer);
+extern RTLFUNC(NPV);
 extern RTLFUNC(Oct);
+extern RTLFUNC(Pmt);
+extern RTLFUNC(PPmt);
+extern RTLFUNC(PV);
+extern RTLFUNC(Rate);
 extern RTLFUNC(Replace);
 extern RTLFUNC(Right);
 extern RTLFUNC(RTrim);
 extern RTLFUNC(RTL);
 extern RTLFUNC(Sgn);
+extern RTLFUNC(SLN);
 extern RTLFUNC(Space);
 extern RTLFUNC(Split);
 extern RTLFUNC(Sqr);
@@ -195,6 +207,7 @@ extern RTLFUNC(Str);
 extern RTLFUNC(StrComp);
 extern RTLFUNC(String);
 extern RTLFUNC(StrReverse);
+extern RTLFUNC(SYD);
 extern RTLFUNC(Tan);
 extern RTLFUNC(UCase);
 extern RTLFUNC(Val);
@@ -297,6 +310,7 @@ extern RTLFUNC(Switch);
 extern RTLFUNC(Wait);
 //i#64882# add new WaitUntil
 extern RTLFUNC(WaitUntil);
+extern RTLFUNC(FuncCaller);
 
 extern RTLFUNC(GetGUIVersion);
 extern RTLFUNC(Choose);
diff --git basic/source/runtime/runtime.cxx basic/source/runtime/runtime.cxx
index a8eff4d..e08ebeb 100755
--- basic/source/runtime/runtime.cxx
+++ basic/source/runtime/runtime.cxx
@@ -46,6 +46,8 @@
 #include "errobject.hxx"
 #include "sbtrace.hxx"
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 using namespace ::com::sun::star;
 
 bool SbiRuntime::isVBAEnabled()
@@ -544,7 +546,7 @@ SbxArray* SbiInstance::GetLocals( SbMethod* pMeth )
 
 SbiRuntime::SbiRuntime( SbModule* pm, SbMethod* pe, UINT32 nStart )
          : rBasic( *(StarBASIC*)pm->pParent ), pInst( pINST ), 
-           pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), m_nLastTime(0)
+		   pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), mpExtCaller(0), m_nLastTime(0)
 {
     nFlags	  = pe ? pe->GetDebugFlags() : 0;
     pIosys	  = pInst->pIosys;
@@ -601,6 +603,13 @@ SbiRuntime::~SbiRuntime()
 void SbiRuntime::SetVBAEnabled(bool bEnabled )
 {
     bVBAEnabled = bEnabled; 
+	if ( bVBAEnabled )
+	{
+		if ( pMeth )
+			mpExtCaller = pMeth->mCaller;
+	}
+	else
+		mpExtCaller = 0;
 }
 
 // Aufbau der Parameterliste. Alle ByRef-Parameter werden direkt
@@ -1029,7 +1038,25 @@ SbxVariable* SbiRuntime::GetTOS( short n )
 void SbiRuntime::TOSMakeTemp()
 {
     SbxVariable* p = refExprStk->Get( nExprLvl - 1 );
-    if( p->GetRefCount() != 1 )
+	if ( p->GetType() == SbxEMPTY )
+		p->Broadcast( SBX_HINT_DATAWANTED );
+
+	SbxVariable* pDflt = NULL;
+	if ( bVBAEnabled &&  ( p->GetType() == SbxOBJECT || p->GetType() == SbxVARIANT  ) && ( pDflt = getDefaultProp( p ) ) )
+	{
+		pDflt->Broadcast( SBX_HINT_DATAWANTED );
+		// replacing new p on stack causes object pointed by 
+		// pDft->pParent to be deleted, when p2->Compute() is
+		// called below pParent is accessed ( but its deleted )
+		// so set it to NULL now
+		pDflt->SetParent( NULL );  
+		p = new SbxVariable( *pDflt );
+		p->SetFlag( SBX_READWRITE );
+		refExprStk->Put( p, nExprLvl - 1 );
+//		return;
+	}
+
+	else if( p->GetRefCount() != 1 )
     {
         SbxVariable* pNew = new SbxVariable( *p );
         pNew->SetFlag( SBX_READWRITE );
@@ -1038,7 +1065,6 @@ void SbiRuntime::TOSMakeTemp()
 }
 
 // Der GOSUB-Stack nimmt Returnadressen fuer GOSUBs auf
-
 void SbiRuntime::PushGosub( const BYTE* pc )
 {
     if( ++nGosubLvl > MAXRECURSION )
diff --git basic/source/runtime/stdobj.cxx basic/source/runtime/stdobj.cxx
index d621a12..9605df5 100644
--- basic/source/runtime/stdobj.cxx
+++ basic/source/runtime/stdobj.cxx
@@ -33,7 +33,7 @@
 #include <basic/sbstdobj.hxx>
 #include "rtlproto.hxx"
 #include "sbintern.hxx"
-
+#include <hash_map>
 // Das nArgs-Feld eines Tabelleneintrags ist wie folgt verschluesselt:
 // Zur Zeit wird davon ausgegangen, dass Properties keine Parameter
 // benoetigen!
@@ -69,6 +69,45 @@ struct Methods {
     USHORT		nHash;		// Hashcode
 };
 
+struct StringHashCode
+{
+    size_t operator()( const String& rStr ) const
+    {
+        return rtl_ustr_hashCode_WithLength( rStr.GetBuffer(), rStr.Len() );
+    }
+};
+
+class VBABlacklist
+{
+friend class VBABlackListQuery;
+    std::hash_map< String, bool, StringHashCode > mBlackList;
+    VBABlacklist()
+    {
+        const char* list[] = { "Red" };
+        sal_Int32 nSize = sizeof( list ) / sizeof( list[ 0 ] );
+        for ( sal_Int32 index = 0; index < nSize; ++index )
+        {
+            mBlackList[ String::CreateFromAscii( list[ index ] ).ToLowerAscii() ] = true;
+        }
+    } 
+public:
+    bool isBlackListed( const String& sName )
+    {
+        String sNameLower( sName );
+        sNameLower.ToLowerAscii();
+        return ( mBlackList.find( sNameLower ) != mBlackList.end() );
+    }
+};
+
+class VBABlackListQuery
+{
+public:
+    static bool isBlackListed( const String& sName )
+    {
+        static VBABlacklist blackList;
+        return blackList.isBlackListed( sName );
+    }
+};
 static Methods aMethods[] = {
 
 { "AboutStarBasic", SbxNULL,      1 | _FUNCTION, RTLNAME(AboutStarBasic),0  },
@@ -171,7 +210,12 @@ static Methods aMethods[] = {
   { "expression",   SbxVARIANT, 0,NULL,0 },
 { "CVErr",          SbxVARIANT,   1 | _FUNCTION, RTLNAME(CVErr),0           },
   { "expression",   SbxVARIANT, 0,NULL,0 },
-
+{ "DDB",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(DDB),0       },
+  { "Cost",       SbxDOUBLE,  0, NULL,0 },
+  { "Salvage",       SbxDOUBLE,  0, NULL,0 },
+  { "Life",       SbxDOUBLE,  0, NULL,0 },
+  { "Period",       SbxDOUBLE,  0, NULL,0 },
+  { "Factor",     SbxVARIANT,  _OPT, NULL,0 },
 { "Date",           SbxDATE,          _LFUNCTION,RTLNAME(Date),0            },
 { "DateAdd",        SbxDATE,	  3 | _FUNCTION, RTLNAME(DateAdd),0         },
   { "Interval",     SbxSTRING, 0,NULL,0 },
@@ -271,6 +315,12 @@ static Methods aMethods[] = {
 { "FreeLibrary",    SbxNULL,      1 | _FUNCTION, RTLNAME(FreeLibrary),0     },
   { "Modulename",   SbxSTRING, 0,NULL,0 },
 
+{ "FV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(FV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
 { "Get",            SbxNULL,   3 | _FUNCTION, RTLNAME(Get),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
@@ -331,6 +381,16 @@ static Methods aMethods[] = {
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
 { "Int",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Int),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "IPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(IPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "IRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(IRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "Guess",       SbxVARIANT,  _OPT, NULL,0 },
 { "IsArray",        SbxBOOL,      1 | _FUNCTION, RTLNAME(IsArray),0         },
   { "Variant",      SbxVARIANT, 0,NULL,0 },
 { "IsDate",         SbxBOOL,      1 | _FUNCTION, RTLNAME(IsDate),0          },
@@ -401,6 +461,10 @@ static Methods aMethods[] = {
   { "Length",       SbxLONG,          _OPT, NULL,0 },
 { "Minute",         SbxINTEGER,   1 | _FUNCTION, RTLNAME(Minute),0          },
   { "Date",         SbxDATE, 0,NULL,0 },
+{ "MIRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(MIRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "FinanceRate",       SbxDOUBLE,  0, NULL,0 },
+  { "ReinvestRate",       SbxDOUBLE,  0, NULL,0 },
 { "MkDir",          SbxNULL,      1 | _FUNCTION, RTLNAME(MkDir),0           },
   { "pathname",     SbxSTRING, 0,NULL,0 },
 { "Month",          SbxINTEGER,   1 | _FUNCTION, RTLNAME(Month),0           },
@@ -417,6 +481,15 @@ static Methods aMethods[] = {
 
 { "Nothing",        SbxOBJECT,        _CPROP,    RTLNAME(Nothing),0         },
 { "Now",            SbxDATE,          _FUNCTION, RTLNAME(Now),0             },
+{ "NPer",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(NPer),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "NPV",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(NPV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
 { "Null",			SbxNULL,          _CPROP,    RTLNAME(Null),0			},
 
 { "Oct",            SbxSTRING,    1 | _FUNCTION, RTLNAME(Oct),0             },
@@ -428,16 +501,46 @@ static Methods aMethods[] = {
   { "stop",  	    SbxLONG, 	0,NULL,0 },
   { "interval",     SbxLONG, 	0,NULL,0 },
 { "Pi",				SbxDOUBLE,		  _CPROP,    RTLNAME(PI),0		      	},
+
+{ "Pmt",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(Pmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
+{ "PPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(PPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "Put",            SbxNULL,   3 | _FUNCTION, RTLNAME(Put),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
   { "variablename",	SbxVARIANT, 0,NULL,0 },
 
+{ "PV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(PV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "QBColor",		SbxLONG,	  1 | _FUNCTION, RTLNAME(QBColor),0			},
   { "number",		SbxINTEGER, 0,NULL,0 },
 
 { "Randomize",      SbxNULL,      1 | _FUNCTION, RTLNAME(Randomize),0       },
   { "Number",       SbxDOUBLE,        _OPT, NULL,0 },
+{ "Rate",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(Rate),0       },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",       SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Guess",    SbxVARIANT,  _OPT, NULL,0 },
 { "Red",        SbxINTEGER,   1 | _FUNCTION, RTLNAME(Red),0                 },
   { "RGB-Value",     SbxLONG, 0,NULL,0 },
 { "Reset",          SbxNULL,      0 | _FUNCTION, RTLNAME(Reset),0           },
@@ -491,6 +594,15 @@ static Methods aMethods[] = {
   { "WindowStyle",  SbxINTEGER,       _OPT, NULL,0 },
 { "Sin",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Sin),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "SLN",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SLN),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Double",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+{ "SYD",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SYD),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Salvage",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+  { "Period",       SbxDOUBLE, 0,NULL,0 },
 { "Space",          SbxSTRING,      1 | _FUNCTION, RTLNAME(Space),0         },
   { "string",       SbxLONG, 0,NULL,0 },
 { "Spc",          	SbxSTRING,      1 | _FUNCTION, RTLNAME(Spc),0           },
@@ -605,6 +717,7 @@ static Methods aMethods[] = {
 
 { "Wait",        	SbxNULL,      1 | _FUNCTION, RTLNAME(Wait),0            },
   { "Milliseconds", SbxLONG, 0,NULL,0 },
+{ "FuncCaller",          SbxVARIANT,      _FUNCTION, RTLNAME(FuncCaller),0      },
 //#i64882#
 { "WaitUntil",          SbxNULL,      1 | _FUNCTION, RTLNAME(WaitUntil),0      },
   { "Date", SbxDOUBLE, 0,NULL,0 },
@@ -683,13 +796,15 @@ SbxVariable* SbiStdObject::Find( const String& rName, SbxClassType t )
              && ( p->nHash == nHash_ )
              && ( rName.EqualsIgnoreCaseAscii( p->pName ) ) )
             {
+                SbiInstance* pInst = pINST;
                 bFound = TRUE;
                 if( p->nArgs & _COMPTMASK )
                 {
-                    SbiInstance* pInst = pINST;
                     if( !pInst || !pInst->IsCompatibility() )
                         bFound = FALSE;
                 }
+                if ( pInst && pInst->IsCompatibility() && VBABlackListQuery::isBlackListed( rName ) )
+                            bFound = FALSE;
                 break;
             }
             nIndex += ( p->nArgs & _ARGSMASK ) + 1;
diff --git basic/source/runtime/step0.cxx basic/source/runtime/step0.cxx
index 112c88b..979013d 100644
--- basic/source/runtime/step0.cxx
+++ basic/source/runtime/step0.cxx
@@ -48,6 +48,11 @@ Reference< XInterface > createComListener( const Any& aControlAny, const ::rtl::
 
 #include <algorithm>
 
+// for a patch forward declaring these methods below makes sense
+// but, #FIXME lets really just move the methods to the top
+void lcl_clearImpl( SbxVariableRef& refVar, SbxDataType& eType );
+void lcl_eraseImpl( SbxVariableRef& refVar, bool bVBAEnabled );
+
 SbxVariable* getDefaultProp( SbxVariable* pRef );
 
 void SbiRuntime::StepNOP()
@@ -59,34 +64,6 @@ void SbiRuntime::StepArith( SbxOperator eOp )
     TOSMakeTemp();
     SbxVariable* p2 = GetTOS();
 
-
-    // This could & should be moved to the MakeTempTOS() method in runtime.cxx
-    // In the code which this is cut'npaste from there is a check for a ref
-    // count != 1 based on which the copy of the SbxVariable is done.
-    // see orig code in MakeTempTOS ( and I'm not sure what the significance,
-    // of that is )
-    // here we alway seem to have a refcount of 1. Also it seems that
-    // MakeTempTOS is called for other operation, so I hold off for now
-    // until I have a better idea
-    if ( bVBAEnabled
-        && ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
-    )
-    {
-        SbxVariable* pDflt = getDefaultProp( p2 );
-        if ( pDflt )
-        {
-            pDflt->Broadcast( SBX_HINT_DATAWANTED );
-            // replacing new p2 on stack causes object pointed by 
-            // pDft->pParent to be deleted, when p2->Compute() is
-            // called below pParent is accessed ( but its deleted )
-            // so set it to NULL now
-            pDflt->SetParent( NULL );  
-            p2 = new SbxVariable( *pDflt );
-            p2->SetFlag( SBX_READWRITE );
-            refExprStk->Put( p2, nExprLvl - 1 );
-        }
-    }
-
     p2->ResetFlag( SBX_FIXED );
     p2->Compute( eOp, *p1 );
 
@@ -109,19 +86,24 @@ void SbiRuntime::StepCompare( SbxOperator eOp )
     // values ( and type ) set as appropriate
     SbxDataType p1Type = p1->GetType(); 
     SbxDataType p2Type = p2->GetType(); 
+	if ( p1Type == SbxEMPTY )
+	{
+		p1->Broadcast( SBX_HINT_DATAWANTED );
+		p1Type = p1->GetType(); 
+	}
+	if ( p2Type == SbxEMPTY )
+	{
+		p2->Broadcast( SBX_HINT_DATAWANTED );
+		p2Type = p2->GetType(); 
+	}
     if ( p1Type == p2Type )
     {
-        if ( p1Type == SbxEMPTY )
-        {
-            p1->Broadcast( SBX_HINT_DATAWANTED );
-            p2->Broadcast( SBX_HINT_DATAWANTED );
-        }
         // if both sides are an object and have default props
         // then we need to use the default props
         // we don't need to worry if only one side ( lhs, rhs ) is an 
         // object ( object side will get coerced to correct type in 
         // Compare )
-        else if ( p1Type ==  SbxOBJECT )
+		if ( p1Type ==  SbxOBJECT )
         {
             SbxVariable* pDflt = getDefaultProp( p1 );
             if ( pDflt )
@@ -141,8 +123,21 @@ void SbiRuntime::StepCompare( SbxOperator eOp )
 #ifndef WIN
     static SbxVariable* pTRUE = NULL;
     static SbxVariable* pFALSE = NULL;
-
-    if( p2->Compare( eOp, *p1 ) )
+	static SbxVariable* pNULL = NULL;
+	// why do this on non-windows ?
+	// why do this at all ?
+	// I dumbly follow the pattern :-/
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
+	{
+		if( !pNULL )
+		{
+			pNULL = new SbxVariable;
+			pNULL->PutNull();
+			pNULL->AddRef();
+		}
+		PushVar( pNULL );
+	}
+	else if( p2->Compare( eOp, *p1 ) )
     {
         if( !pTRUE )
         {
@@ -163,9 +158,14 @@ void SbiRuntime::StepCompare( SbxOperator eOp )
         PushVar( pFALSE );
     }
 #else
-    BOOL bRes = p2->Compare( eOp, *p1 );
     SbxVariable* pRes = new SbxVariable;
-    pRes->PutBool( bRes );
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
+		pRes->PutNull();
+	else
+	{
+		BOOL bRes = p2->Compare( eOp, *p1 );
+		pRes->PutBool( bRes );
+	}
     PushVar( pRes );
 #endif
 }
@@ -680,6 +680,17 @@ void SbiRuntime::StepDIM()
 // #56204 DIM-Funktionalitaet in Hilfsmethode auslagern (step0.cxx)
 void SbiRuntime::DimImpl( SbxVariableRef refVar )
 {
+	// If refDim then this DIM statement is terminating a ReDIM and
+	// previous StepERASE_CLEAR for an array, the following actions have 
+	// been delayed from ( StepERASE_CLEAR ) 'till here
+	if ( refRedim ) 
+	{
+		if ( !refRedimpArray ) // only erase the array not ReDim Preserve
+			lcl_eraseImpl( refVar, bVBAEnabled );
+		SbxDataType eType = refVar->GetType();
+		lcl_clearImpl( refVar, eType );
+		refRedim = NULL;
+	}
     SbxArray* pDims = refVar->GetParameters();
     // Muss eine gerade Anzahl Argumente haben
     // Man denke daran, dass Arg[0] nicht zaehlt!
@@ -845,6 +856,7 @@ void SbiRuntime::StepREDIMP()
 void SbiRuntime::StepREDIMP_ERASE()
 {
     SbxVariableRef refVar = PopVar();
+	refRedim = refVar;
     SbxDataType eType = refVar->GetType();
     if( eType & SbxARRAY )
     {
@@ -855,12 +867,6 @@ void SbiRuntime::StepREDIMP_ERASE()
             refRedimpArray = pDimArray;
         }
 
-        // As in ERASE
-        USHORT nSavFlags = refVar->GetFlags();
-        refVar->ResetFlag( SBX_FIXED );
-        refVar->SetType( SbxDataType(eType & 0x0FFF) );
-        refVar->SetFlags( nSavFlags );
-        refVar->Clear();
     }
     else
     if( refVar->IsFixed() )
@@ -933,10 +939,7 @@ void SbiRuntime::StepERASE()
 
 void SbiRuntime::StepERASE_CLEAR()
 {
-    SbxVariableRef refVar = PopVar();
-    lcl_eraseImpl( refVar, bVBAEnabled );
-    SbxDataType eType = refVar->GetType();
-    lcl_clearImpl( refVar, eType );
+	refRedim = PopVar();
 }
 
 void SbiRuntime::StepARRAYACCESS()
diff --git basic/source/runtime/step1.cxx basic/source/runtime/step1.cxx
index f448f79..0e564f0 100644
--- basic/source/runtime/step1.cxx
+++ basic/source/runtime/step1.cxx
@@ -93,6 +93,15 @@ void SbiRuntime::StepARGN( UINT32 nOp1 )
     {
         String aAlias( pImg->GetString( static_cast<short>( nOp1 ) ) );
         SbxVariableRef pVal = PopVar();
+		if( bVBAEnabled && ( pVal->ISA(SbxMethod) || pVal->ISA(SbUnoProperty) || pVal->ISA(SbProcedureProperty) ) )
+		{
+			// named variables ( that are Any especially properties ) can be empty at this point and need a broadcast
+			if ( pVal->GetType() == SbxEMPTY )
+				pVal->Broadcast( SBX_HINT_DATAWANTED );
+			// Methoden und Properties evaluieren!
+			SbxVariable* pRes = new SbxVariable( *pVal );
+			pVal = pRes;
+		}
         refArgv->Put( pVal, nArgc );
         refArgv->PutAlias( aAlias, nArgc++ );
     }
@@ -182,7 +191,9 @@ void SbiRuntime::StepJUMPT( UINT32 nOp1 )
 void SbiRuntime::StepJUMPF( UINT32 nOp1 )
 {
     SbxVariableRef p = PopVar();
-    if( !p->GetBool() )
+	// In a test e.g. If Null then 	
+        // will evaluate Null will act as if False
+	if( ( bVBAEnabled && p->IsNull() ) || !p->GetBool() )
         StepJUMP( nOp1 );
 }
 
diff --git basic/source/runtime/step2.cxx basic/source/runtime/step2.cxx
index 995c425..68bef06 100755
--- basic/source/runtime/step2.cxx
+++ basic/source/runtime/step2.cxx
@@ -141,7 +141,7 @@ SbxVariable* SbiRuntime::FindElement
                     if ( pElem )
                         bSetName = false; // don't overwrite uno name
                     else
-                        pElem = getVBAConstant( aName );
+                        pElem = VBAConstantHelper::instance().getVBAConstant( aName );
                 }
                 // #72382 VORSICHT! Liefert jetzt wegen unbekannten
                 // Modulen IMMER ein Ergebnis!
@@ -457,7 +457,7 @@ SbxVariable* SbiRuntime::CheckArray( SbxVariable* pElem )
 {
     // Falls wir ein Array haben, wollen wir bitte das Array-Element!
     SbxArray* pPar;
-    if( pElem->GetType() & SbxARRAY )
+	if( ( pElem->GetType() & SbxARRAY ) && (SbxVariable*)refRedim != pElem )
     {
         SbxBase* pElemObj = pElem->GetObject();
         SbxDimArray* pDimArray = PTR_CAST(SbxDimArray,pElemObj);
@@ -489,7 +489,7 @@ SbxVariable* SbiRuntime::CheckArray( SbxVariable* pElem )
             pPar->Put( NULL, 0 );
     }
     // Index-Access bei UnoObjekten beruecksichtigen
-    else if( pElem->GetType() == SbxOBJECT && !pElem->ISA(SbxMethod) )
+	else if( pElem->GetType() == SbxOBJECT && !pElem->ISA(SbxMethod) && !pElem->ISA(SbxProperty) )
     {
         pPar = pElem->GetParameters();
         if ( pPar )
@@ -733,6 +733,8 @@ void SbiRuntime::StepPARAM( UINT32 nOp1, UINT32 nOp2 )
         SaveRef( q );
         *q = *p;
         p = q;
+		if ( i ) 
+                	refParams->Put( p, i );
     }
     SetupArgs( p, nOp1 );
     PushVar( CheckArray( p ) );
diff --git basic/source/sbx/sbxvalue.cxx basic/source/sbx/sbxvalue.cxx
index 34ca872..f535925 100644
--- basic/source/sbx/sbxvalue.cxx
+++ basic/source/sbx/sbxvalue.cxx
@@ -1144,8 +1144,8 @@ BOOL SbxValue::Compute( SbxOperator eOp, const SbxValue& rOp )
     {
         SbxValues aL, aR;
         bool bDecimal = false;
-        if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING ) || 
-             ( eThisType != SbxSTRING && eOpType == SbxSTRING ) ) &&
+		if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING && eOpType != SbxEMPTY ) || 
+			 ( eThisType != SbxSTRING && eThisType != SbxEMPTY && eOpType == SbxSTRING ) ) &&
              ( eOp == SbxMUL || eOp == SbxDIV || eOp == SbxPLUS || eOp == SbxMINUS ) )
         {
             goto Lbl_OpIsDouble;
@@ -1192,6 +1192,8 @@ BOOL SbxValue::Compute( SbxOperator eOp, const SbxValue& rOp )
                     aL.eType = aR.eType = GetType();
 //				else if( GetType() == SbxDouble || GetType() == SbxSingle )
 //					aL.eType = aR.eType = SbxLONG64;
+				else if ( bVBAInterop && eOpType == SbxBOOL )
+					aL.eType = aR.eType = SbxBOOL;
                 else
                     aL.eType = aR.eType = SbxLONG;
             }
@@ -1278,7 +1280,12 @@ BOOL SbxValue::Compute( SbxOperator eOp, const SbxValue& rOp )
                         break;
                     case SbxNOT:
                         if( aL.eType != SbxLONG && aL.eType != SbxULONG )
-                            aL.nLong64 = ~aL.nLong64;
+						{
+							if ( aL.eType != SbxBOOL )
+								aL.nLong64 = ~aL.nLong64;
+							else
+								aL.nLong = ~aL.nLong;
+						}
                         else
                             aL.nLong = ~aL.nLong;
                         break;
diff --git basic/source/uno/dlgcont.cxx basic/source/uno/dlgcont.cxx
index aee3d18..e0611ab 100644
--- basic/source/uno/dlgcont.cxx
+++ basic/source/uno/dlgcont.cxx
@@ -321,8 +321,8 @@ Any SAL_CALL SfxDialogLibraryContainer::importLibraryElement
     source.sSystemId 	= aFile;
 
     try {
-        // start parsing
-        xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext ) );
+		// start parsing 
+		xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext, mxOwnerDocument ) );
         xParser->parseStream( source );
     }
     catch( Exception& )
@@ -336,7 +336,7 @@ Any SAL_CALL SfxDialogLibraryContainer::importLibraryElement
 
     // Create InputStream, TODO: Implement own InputStreamProvider
     // to avoid creating the DialogModel here!
-    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, mxOwnerDocument );
     aRetAny <<= xISP;
     return aRetAny;
 }
@@ -484,7 +484,11 @@ void SfxDialogLibraryContainer::onNewRootStorage()
     }
 }
 
-
+sal_Bool SAL_CALL
+SfxDialogLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	return sal_False; // dialog library has no executable code
+}
 //============================================================================
 // Service
 
diff --git basic/source/uno/scriptcont.cxx basic/source/uno/scriptcont.cxx
index e10d111..38eefcf 100644
--- basic/source/uno/scriptcont.cxx
+++ basic/source/uno/scriptcont.cxx
@@ -66,7 +66,8 @@
 #include <xmlscript/xmlmod_imexp.hxx>
 #include <cppuhelper/factory.hxx>
 #include <com/sun/star/util/VetoException.hpp>
-
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
+#include <cppuhelper/implbase1.hxx>
 namespace basic
 {
 
@@ -137,7 +138,6 @@ sal_Bool SfxScriptLibraryContainer::hasLibraryPassword( const String& rLibraryNa
     return pImplLib->mbPasswordProtected;
 }
 
-
 // Ctor for service
 SfxScriptLibraryContainer::SfxScriptLibraryContainer( void )
     :maScriptLanguage( RTL_CONSTASCII_USTRINGPARAM( "StarBasic" ) )
@@ -1165,6 +1165,17 @@ void SfxScriptLibraryContainer::onNewRootStorage()
 {
 }
 
+sal_Bool SAL_CALL
+SfxScriptLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	BasicManager* pBasicMgr = getBasicManager();
+    	OSL_ENSURE( pBasicMgr, "we need a basicmanager, really we do" );
+	if ( pBasicMgr )
+		return pBasicMgr->HasExeCode( Library ); // need to change this to take name
+	// default to it has code if we can't decide
+	return sal_True;
+}
+
 //============================================================================
 // Service
 void createRegistryInfo_SfxScriptLibraryContainer()
diff --git cui/source/customize/cfg.cxx cui/source/customize/cfg.cxx
index 211deef..b4a8c88 100644
--- cui/source/customize/cfg.cxx
+++ cui/source/customize/cfg.cxx
@@ -5718,7 +5718,7 @@ bool SvxIconSelectorDialog::ReplaceGraphicItem(
                 if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
                 {
                     BitmapEx aBitmap = aImage.GetBitmapEx();
-                    BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
                     aImage = Image( aBitmapex);
                 }
                 aTbSymbol.InsertItem( nId,aImage, aURL, 0, 0 ); //modify
@@ -5882,7 +5882,7 @@ bool SvxIconSelectorDialog::ImportGraphic( const OUString& aURL )
                 if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
                 {
                     BitmapEx aBitmap = aImage.GetBitmapEx();
-                    BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
                     aImage = Image( aBitmapex);
                 }
                 if ( bOK && !!aImage )
diff --git cui/source/options/optfltr.cxx cui/source/options/optfltr.cxx
index 51034c9..229ee76 100644
--- cui/source/options/optfltr.cxx
+++ cui/source/options/optfltr.cxx
@@ -54,6 +54,7 @@ OfaMSFilterTabPage::OfaMSFilterTabPage(Window* pParent, const SfxItemSet& rSet)
     : SfxTabPage( pParent, CUI_RES( RID_OFAPAGE_MSFILTEROPT ), rSet ),
     aMSWordGB		( this, CUI_RES( GB_WORD	    ) ),
     aWBasicCodeCB	( this, CUI_RES( CB_WBAS_CODE ) ),
+	aWBasicWbctblCB ( this, CUI_RES( CB_WBAS_WBCTBL ) ),
     aWBasicStgCB	( this, CUI_RES( CB_WBAS_STG  ) ),
     aMSExcelGB      ( this, CUI_RES( GB_EXCEL     ) ),
     aEBasicCodeCB   ( this, CUI_RES( CB_EBAS_CODE ) ),
@@ -65,6 +66,7 @@ OfaMSFilterTabPage::OfaMSFilterTabPage(Window* pParent, const SfxItemSet& rSet)
 {
     FreeResource();
 
+    aWBasicCodeCB.SetClickHdl( LINK( this, OfaMSFilterTabPage, LoadWordBasicCheckHdl_Impl ) );
     aEBasicCodeCB.SetClickHdl( LINK( this, OfaMSFilterTabPage, LoadExcelBasicCheckHdl_Impl ) );
 }
 
@@ -72,6 +74,12 @@ OfaMSFilterTabPage::~OfaMSFilterTabPage()
 {
 }
 
+IMPL_LINK( OfaMSFilterTabPage, LoadWordBasicCheckHdl_Impl, CheckBox*, EMPTYARG )
+{
+    aWBasicWbctblCB.Enable( aWBasicCodeCB.IsChecked() );
+    return 0;
+}
+
 IMPL_LINK( OfaMSFilterTabPage, LoadExcelBasicCheckHdl_Impl, CheckBox*, EMPTYARG )
 {
     aEBasicExectblCB.Enable( aEBasicCodeCB.IsChecked() );
@@ -91,6 +99,8 @@ BOOL OfaMSFilterTabPage::FillItemSet( SfxItemSet& )
     BOOL bFlag;
     if( aWBasicCodeCB.GetSavedValue() != (bFlag = aWBasicCodeCB.IsChecked()))
         pOpt->SetLoadWordBasicCode( bFlag );
+    if( aWBasicWbctblCB.GetSavedValue() != (bFlag = aWBasicWbctblCB.IsChecked()))
+        pOpt->SetLoadWordBasicExecutable( bFlag );
     if( aWBasicStgCB.GetSavedValue() != (bFlag = aWBasicStgCB.IsChecked()))
         pOpt->SetLoadWordBasicStorage( bFlag );
 
@@ -119,8 +129,11 @@ void OfaMSFilterTabPage::Reset( const SfxItemSet& )
 
     aWBasicCodeCB.Check( pOpt->IsLoadWordBasicCode() );
     aWBasicCodeCB.SaveValue();
+    aWBasicWbctblCB.Check( pOpt->IsLoadWordBasicExecutable() );
+    aWBasicWbctblCB.SaveValue();
     aWBasicStgCB.Check( pOpt->IsLoadWordBasicStorage() );
     aWBasicStgCB.SaveValue();
+    LoadWordBasicCheckHdl_Impl( &aWBasicCodeCB );
 
     aEBasicCodeCB.Check( pOpt->IsLoadExcelBasicCode() );
     aEBasicCodeCB.SaveValue();
diff --git cui/source/options/optfltr.hrc cui/source/options/optfltr.hrc
index 5938604..40204b7 100644
--- cui/source/options/optfltr.hrc
+++ cui/source/options/optfltr.hrc
@@ -40,6 +40,7 @@
 #define CB_EBAS_STG     5
 #define CB_PBAS_CODE    6
 #define CB_PBAS_STG     7
+#define CB_WBAS_WBCTBL	8
 
 #define CLB_SETTINGS    1
 #define ST_CHG_MATH     1
diff --git cui/source/options/optfltr.hxx cui/source/options/optfltr.hxx
index 8014281..0fb4aee 100644
--- cui/source/options/optfltr.hxx
+++ cui/source/options/optfltr.hxx
@@ -43,6 +43,7 @@ class OfaMSFilterTabPage : public SfxTabPage
 {
     FixedLine       aMSWordGB;
     CheckBox		aWBasicCodeCB;
+    CheckBox		aWBasicWbctblCB;
     CheckBox		aWBasicStgCB;
     FixedLine       aMSExcelGB;
     CheckBox		aEBasicCodeCB;
@@ -55,6 +56,7 @@ class OfaMSFilterTabPage : public SfxTabPage
     OfaMSFilterTabPage( Window* pParent, const SfxItemSet& rSet );
     virtual ~OfaMSFilterTabPage();
 
+    DECL_LINK( LoadWordBasicCheckHdl_Impl, CheckBox* );
     DECL_LINK( LoadExcelBasicCheckHdl_Impl, CheckBox* );
 public:
 
diff --git cui/source/options/optfltr.src cui/source/options/optfltr.src
index e24da54..d9ff1c8 100644
--- cui/source/options/optfltr.src
+++ cui/source/options/optfltr.src
@@ -51,9 +51,16 @@ TabPage RID_OFAPAGE_MSFILTEROPT
         TabStop = TRUE ;
         Text [ en-US ] = "Load Basic ~code";
     };
+    CheckBox CB_WBAS_WBCTBL
+    {
+        Pos = MAP_APPFONT ( 22 , 28 ) ;
+        Size = MAP_APPFONT ( 236 , 10 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "E~xecutable code";
+    };
     CheckBox CB_WBAS_STG
     {
-        Pos = MAP_APPFONT ( 12 , 28 ) ;
+        Pos = MAP_APPFONT ( 12 , 42 ) ;
         Size = MAP_APPFONT ( 236 , 10 ) ;
         TabStop = TRUE ;
         Text [ en-US ] = "Save ~original Basic code";
@@ -61,27 +68,27 @@ TabPage RID_OFAPAGE_MSFILTEROPT
 
     FixedLine GB_EXCEL
     {
-        Pos = MAP_APPFONT ( 6 , 44 ) ;
+        Pos = MAP_APPFONT ( 6 , 58 ) ;
         Size = MAP_APPFONT ( 248 , 8 ) ;
         Text [ en-US ] = "Microsoft Excel 97/2000/XP";
     };
     CheckBox CB_EBAS_CODE
     {
-        Pos = MAP_APPFONT ( 12 , 55 ) ;
+        Pos = MAP_APPFONT ( 12 , 69 ) ;
         Size = MAP_APPFONT ( 236 , 10 ) ;
         TabStop = TRUE ;
         Text [ en-US ] = "Lo~ad Basic code";
     };
     CheckBox CB_EBAS_EXECTBL
     {
-        Pos = MAP_APPFONT ( 22 , 69 ) ;
+        Pos = MAP_APPFONT ( 22 , 83 ) ;
         Size = MAP_APPFONT ( 236 , 10 ) ;
         TabStop = TRUE ;
         Text [ en-US ] = "E~xecutable code";
     };
     CheckBox CB_EBAS_STG
     {
-        Pos = MAP_APPFONT ( 12 , 83 ) ;
+        Pos = MAP_APPFONT ( 12 , 97 ) ;
         Size = MAP_APPFONT ( 236 , 10 ) ;
         TabStop = TRUE ;
         Text [ en-US ] = "Sa~ve original Basic code";
diff --git dbaccess/source/ext/macromigration/migrationengine.cxx dbaccess/source/ext/macromigration/migrationengine.cxx
index 9e6781d..b54c3be 100644
--- dbaccess/source/ext/macromigration/migrationengine.cxx
+++ dbaccess/source/ext/macromigration/migrationengine.cxx
@@ -1835,7 +1835,7 @@ namespace dbmm
             Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
 
             Reference< XNameContainer > xDialogModel( m_aContext.createComponent( "com.sun.star.awt.UnoControlDialogModel" ), UNO_QUERY_THROW );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext() );
+            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
 
             // adjust the events of the dialog
             impl_adjustDialogElementEvents_throw( xDialogModel );
@@ -1850,7 +1850,7 @@ namespace dbmm
             }
 
             // export dialog model
-            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext() );
+            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
             _inout_rDialogLibraryElement <<= xISP;
         }
         catch( const Exception& )
diff --git extensions/inc/propctrlr.hrc extensions/inc/propctrlr.hrc
index a559b30..ab11bf4 100644
--- extensions/inc/propctrlr.hrc
+++ extensions/inc/propctrlr.hrc
@@ -326,9 +326,10 @@
 #define HID_FM_PROPDLG_TAB_GENERAL              ( HID_PROPC_START + 294)
 #define HID_FM_PROPDLG_TAB_DATA                 ( HID_PROPC_START + 295)
 #define HID_FM_PROPDLG_TAB_EVT                  ( HID_PROPC_START + 296)
+#define HID_PROP_GROUP_NAME                     ( HID_PROPC_START + 297)
     // please adjust HID_LAST_PROPC_ID if you add new ids here!
 
-#define HID_LAST_PROPC_ID   HID_FM_PROPDLG_TAB_EVT
+#define HID_LAST_PROPC_ID   HID_PROP_GROUP_NAME
 
 #if HID_LAST_PROPC_ID > HID_PROPC_END
     #error help id overflow (PROPC)
diff --git extensions/source/ole/oleobjw.cxx extensions/source/ole/oleobjw.cxx
index 7a73ed7..aca6e53 100755
--- extensions/source/ole/oleobjw.cxx
+++ extensions/source/ole/oleobjw.cxx
@@ -49,6 +49,7 @@
 #include <com/sun/star/script/XEngine.hpp>
 #include <com/sun/star/script/InterruptEngineEvent.hpp>
 #include <com/sun/star/script/XLibraryAccess.hpp>
+#include <com/sun/star/script/BasicErrorException.hpp>
 #include <com/sun/star/bridge/ModelDependent.hpp>
 
 #include "com/sun/star/bridge/oleautomation/NamedArgument.hpp"
@@ -152,10 +153,10 @@ Any IUnknownWrapper_Impl::queryInterface(const Type& t)
         return Any();
     if (t == getCppuType(static_cast<Reference<XDefaultProperty>*>( 0)) && !m_bHasDfltProperty )
         return Any();
-    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)) && !m_spDispatch)
+    if ( ( t == getCppuType(static_cast<Reference<XInvocation>*>( 0)) || t == getCppuType(static_cast<Reference<XAutomationInvocation>*>( 0)) ) && !m_spDispatch)
         return Any();
 
-    return WeakImplHelper6<XInvocation, XBridgeSupplier2,
+    return WeakImplHelper6<XAutomationInvocation, XBridgeSupplier2,
         XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>::queryInterface(t);
 }
 
@@ -167,6 +168,61 @@ Reference<XIntrospectionAccess> SAL_CALL IUnknownWrapper_Impl::getIntrospection(
     return ret;
 }
 
+Any SAL_CALL IUnknownWrapper_Impl::invokeGetProperty( const OUString& aPropertyName, const Sequence< Any >& aParams, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam )
+{
+    Any aResult;
+    try
+    {
+        o2u_attachCurrentThread();
+        ITypeInfo * pInfo = getTypeInfo();
+        FuncDesc aDescGet(pInfo);
+        FuncDesc aDescPut(pInfo);
+        VarDesc aVarDesc(pInfo);
+        getPropDesc(aPropertyName, & aDescGet, & aDescPut, & aVarDesc);
+        if ( !aDescGet )
+        {
+            OUString msg(OUSTR("[automation bridge]Property \"") + aPropertyName +
+                OUSTR("\" is not supported"));
+            throw UnknownPropertyException(msg, Reference<XInterface>());
+        }
+        aResult = invokeWithDispIdComTlb( aDescGet, aPropertyName, aParams, aOutParamIndex, aOutParam );
+    }
+    catch ( Exception& e )
+    {
+       throw RuntimeException(OUSTR("[automation bridge] unexpected exception in "
+               "IUnknownWrapper_Impl::invokeGetProperty ! Message : \n") +
+                e.Message, Reference<XInterface>());
+    }
+    return aResult;
+}
+
+Any SAL_CALL IUnknownWrapper_Impl::invokePutProperty( const OUString& aPropertyName, const Sequence< Any >& aParams, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam )
+{
+    Any aResult;
+    try
+    {
+        o2u_attachCurrentThread();
+        ITypeInfo * pInfo = getTypeInfo();
+        FuncDesc aDescGet(pInfo);
+        FuncDesc aDescPut(pInfo);
+        VarDesc aVarDesc(pInfo);
+        getPropDesc(aPropertyName, & aDescGet, & aDescPut, & aVarDesc);
+        if ( !aDescPut )
+        {
+            OUString msg(OUSTR("[automation bridge]Property \"") + aPropertyName +
+                OUSTR("\" is not supported"));
+            throw UnknownPropertyException(msg, Reference<XInterface>());
+        }
+        aResult = invokeWithDispIdComTlb( aDescPut, aPropertyName, aParams, aOutParamIndex, aOutParam );
+    }
+    catch ( Exception& e )
+    {
+       throw RuntimeException(OUSTR("[automation bridge] unexpected exception in "
+               "IUnknownWrapper_Impl::invokePutProperty ! Message : \n") +
+                e.Message, Reference<XInterface>());
+    }
+    return aResult;
+}
 
 
 Any SAL_CALL IUnknownWrapper_Impl::invoke( const OUString& aFunctionName,
@@ -210,6 +266,10 @@ Any SAL_CALL IUnknownWrapper_Impl::invoke( const OUString& aFunctionName,
         throw;
     }
     catch (CannotConvertException &)
+	{
+		throw;
+	}
+	catch (InvocationTargetException &)
     {
         throw;
     }
@@ -658,12 +718,16 @@ sal_Bool SAL_CALL IUnknownWrapper_Impl::hasProperty( const OUString& aName )
         FuncDesc aDescPut(pInfo);
         VarDesc aVarDesc(pInfo);
         getPropDesc(aName, & aDescGet, & aDescPut, & aVarDesc);
-        // Automation properties can have parameters. If so, we access them through 
-        // XInvocation::invoke. Thas is, hasProperty must return false for such a 
-        // property
+
+	// we should probably just check the funckind
+        // basic has been modified to handle properties ( 'get' ) props at
+	// least with paramaters
+	// additionally you can call invoke(Get|Set)Property on the bridge
+        // you can determine if a property has parameter is hasMethod 
+	// returns true for the name 
         if (aVarDesc
-            || aDescPut && aDescPut->cParams == 0
-            || aDescGet && aDescGet->cParams == 0)
+            || aDescPut 
+            || aDescGet )
         {
             ret = sal_True;
         }
@@ -1392,6 +1456,19 @@ Any  IUnknownWrapper_Impl::invokeWithDispIdComTlb(const OUString& sFuncName,
                                                   Sequence< sal_Int16 >& OutParamIndex, 
                                                   Sequence< Any >& OutParam) 
 {
+    // Get type info for the call. It can be a method call or property put or
+    // property get operation.
+    FuncDesc aFuncDesc(getTypeInfo());
+    getFuncDescForInvoke(sFuncName, Params, & aFuncDesc);
+    return invokeWithDispIdComTlb( aFuncDesc, sFuncName, Params, OutParamIndex, OutParam ); 
+}
+
+Any  IUnknownWrapper_Impl::invokeWithDispIdComTlb(FuncDesc& aFuncDesc, 
+                                                  const OUString& sFuncName,
+                                                  const Sequence< Any >& Params, 
+                                                  Sequence< sal_Int16 >& OutParamIndex, 
+                                                  Sequence< Any >& OutParam) 
+{
     Any ret;
     HRESULT result;
 
@@ -1410,10 +1487,6 @@ Any  IUnknownWrapper_Impl::invokeWithDispIdComTlb(const OUString& sFuncName,
     sal_Int32 revIndex = 0;
     bool bVarargParam = false;
 
-    // Get type info for the call. It can be a method call or property put or
-    // property get operation.
-    FuncDesc aFuncDesc(getTypeInfo());
-    getFuncDescForInvoke(sFuncName, Params, & aFuncDesc);
 
     //Set the array of DISPIDs for named args if it is a property put operation.
     //If there are other named arguments another array is set later on.
@@ -1832,11 +1905,24 @@ Any  IUnknownWrapper_Impl::invokeWithDispIdComTlb(const OUString& sFuncName,
                   "DISP_E_BADVARTYPE."), 0);
             break;
         case DISP_E_EXCEPTION:
+			{
                 message = OUSTR("[automation bridge]: ");
                 message += OUString(reinterpret_cast<const sal_Unicode*>(excepinfo.bstrDescription), 
                     ::SysStringLen(excepinfo.bstrDescription));
-                throw InvocationTargetException(message, Reference<XInterface>(), Any());
+
+				// Add for VBA, to throw an exception with the correct error code and message.
+				sal_Int32 nErrorCode = excepinfo.wCode;
+				if ( nErrorCode == 0 )
+				{
+					// The low 16-bit of scode describing the error or warning.
+					nErrorCode = ( excepinfo.scode & 0xFFFF );
+				}
+				BasicErrorException aBasicErrExp(message, Reference<XInterface>(), nErrorCode, message);
+				throw InvocationTargetException(message, Reference<XInterface>(), makeAny(aBasicErrExp));
+				// End add
+
                 break;
+			}
         case DISP_E_MEMBERNOTFOUND:
             message = OUSTR("[automation bridge]: A function with the name \"")
                 + sFuncName + OUSTR("\" is not supported. Object returned "
@@ -1969,11 +2055,17 @@ void IUnknownWrapper_Impl::getFuncDesc(const OUString & sFuncName, FUNCDESC ** p
                 //get the associated index and add an entry to the map
                 //with the name sFuncName which differs in the casing of the letters to 
                 //the actual name as obtained from ITypeInfo
-                cit itOrg  = m_mapComFunc.find(OUString(reinterpret_cast<const sal_Unicode*>(LPCOLESTR(memberName))));
+				OUString sRealName(reinterpret_cast<const sal_Unicode*>(LPCOLESTR(memberName)));
+				cit itOrg  = m_mapComFunc.find(sRealName);
                 OSL_ASSERT(itOrg != m_mapComFunc.end());
+				// maybe this is a property, if so we need
+				// to store either both id's ( put/get ) or
+				// just the get. Storing both is more consistent
+				pair<cit, cit> pItems = m_mapComFunc.equal_range( sRealName );
+    				for ( ;pItems.first != pItems.second; ++pItems.first )
+					m_mapComFunc.insert( TLBFuncIndexMap::value_type ( make_pair(sFuncName, pItems.first->second ) ));
                 itIndex =
-                    m_mapComFunc.insert( TLBFuncIndexMap::value_type
-                    ( make_pair(sFuncName, itOrg->second ) ));
+					m_mapComFunc.find( sFuncName );
             }
         }
     }
@@ -2080,56 +2172,69 @@ void IUnknownWrapper_Impl::getPropDesc(const OUString & sFuncName, FUNCDESC ** p
    //else no entry for sFuncName, pFuncDesc will not be filled in    
 }
 
-VARTYPE IUnknownWrapper_Impl::getElementTypeDesc(const TYPEDESC *desc)
+VARTYPE IUnknownWrapper_Impl::getUserDefinedElementType( ITypeInfo* pTypeInfo, const DWORD nHrefType )
 {
     VARTYPE _type( VT_NULL );
-
-    if (desc->vt == VT_PTR)
+    if ( pTypeInfo )
     {
-        _type = getElementTypeDesc(desc->lptdesc);
-        _type |= VT_BYREF;
-    }
-    else if (desc->vt == VT_SAFEARRAY)
-    {
-        _type = getElementTypeDesc(desc->lptdesc);
-        _type |= VT_ARRAY;
-    }
-    else if (desc->vt == VT_USERDEFINED)
-    {
-        ITypeInfo* thisInfo = getTypeInfo(); //kept by this instance
-        CComPtr<ITypeInfo>	spRefInfo;
-        thisInfo->GetRefTypeInfo(desc->hreftype, & spRefInfo.p);
-        if (spRefInfo)
+        CComPtr<ITypeInfo> spRefInfo;
+        pTypeInfo->GetRefTypeInfo( nHrefType, &spRefInfo.p );
+        if ( spRefInfo )
         {
-            TypeAttr  attr(spRefInfo);
-            spRefInfo->GetTypeAttr( & attr);
-            if (attr->typekind == TKIND_ENUM)
+            TypeAttr attr( spRefInfo );
+            spRefInfo->GetTypeAttr( &attr );
+            if ( attr->typekind == TKIND_ENUM )
             {
-                //We use the type of the first enum value.
-                if (attr->cVars == 0)
+                // We use the type of the first enum value.
+                if ( attr->cVars == 0 )
                 {
-                    throw BridgeRuntimeError(OUSTR("[automation bridge] Could "
-                        "not obtain type description"));
+                    throw BridgeRuntimeError(OUSTR("[automation bridge] Could not obtain type description"));
                 }
-                VarDesc var(spRefInfo);
-                spRefInfo->GetVarDesc(0, & var);
-                _type = var->lpvarValue->vt; 
+                VarDesc var( spRefInfo );
+                spRefInfo->GetVarDesc( 0, &var );
+                _type = var->lpvarValue->vt;
             }
-            else if (attr->typekind == TKIND_INTERFACE)
+            else if ( attr->typekind == TKIND_INTERFACE )
             {
                 _type = VT_UNKNOWN;
             }
-            else if (attr->typekind == TKIND_DISPATCH)
+            else if ( attr->typekind == TKIND_DISPATCH )
             {
                 _type = VT_DISPATCH;
             }
-            else 
+            else if ( attr->typekind == TKIND_ALIAS )
             {
-                throw BridgeRuntimeError(OUSTR("[automation bridge] "
-                    "Unhandled user defined type."));
+                // TKIND_ALIAS is a type that is an alias for another type. So get that alias type.
+                _type = getUserDefinedElementType( pTypeInfo, attr->tdescAlias.hreftype );
+            }
+            else
+            {
+                throw BridgeRuntimeError( OUSTR("[automation bridge] Unhandled user defined type.") );
             }
         }
     }
+    return _type;
+}
+
+VARTYPE IUnknownWrapper_Impl::getElementTypeDesc(const TYPEDESC *desc)
+{
+    VARTYPE _type( VT_NULL );
+
+    if (desc->vt == VT_PTR)
+    {
+        _type = getElementTypeDesc(desc->lptdesc);
+        _type |= VT_BYREF;
+    }
+    else if (desc->vt == VT_SAFEARRAY)
+    {
+        _type = getElementTypeDesc(desc->lptdesc);
+        _type |= VT_ARRAY;
+    }
+    else if (desc->vt == VT_USERDEFINED)
+    {
+        ITypeInfo* thisInfo = getTypeInfo(); //kept by this instance
+		_type = getUserDefinedElementType( thisInfo, desc->hreftype );
+    }
     else
     {
         _type = desc->vt;
diff --git extensions/source/ole/oleobjw.hxx extensions/source/ole/oleobjw.hxx
index 334fb18..ae879f2 100644
--- extensions/source/ole/oleobjw.hxx
+++ extensions/source/ole/oleobjw.hxx
@@ -54,6 +54,7 @@
 
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
+#include <com/sun/star/script//XAutomationInvocation.hpp>
 #include <rtl/ustring.hxx>
 
 #include <com/sun/star/script/XDefaultProperty.hpp>
@@ -81,7 +82,7 @@ typedef hash_multimap<OUString, unsigned int, hashOUString_Impl, equalOUString_I
 // This class wraps an IDispatch and maps XInvocation calls to IDispatch calls on the wrapped object.
 // If m_TypeDescription is set then this class represents an UNO interface implemented in a COM component.
 // The interface is not a real interface in terms of an abstract class but is realized through IDispatch.
-class IUnknownWrapper_Impl : public WeakImplHelper6<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>,
+class IUnknownWrapper_Impl : public WeakImplHelper6<XAutomationInvocation, XBridgeSupplier2, XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>,
 
                              public UnoConversionUtilities<IUnknownWrapper_Impl>
 
@@ -134,6 +135,9 @@ public:
 protected:
     virtual ::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
 
+    virtual ::com::sun::star::uno::Any SAL_CALL invokeGetProperty( const ::rtl::OUString& aFunctionName, const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams, ::com::sun::star::uno::Sequence< ::sal_Int16 >& aOutParamIndex, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::script::CannotConvertException, ::com::sun::star::reflection::InvocationTargetException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL invokePutProperty( const ::rtl::OUString& aFunctionName, const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams, ::com::sun::star::uno::Sequence< ::sal_Int16 >& aOutParamIndex, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::script::CannotConvertException, ::com::sun::star::reflection::InvocationTargetException, ::com::sun::star::uno::RuntimeException);
+
     // ----------------------------------------------------------------------------
     virtual Any invokeWithDispIdUnoTlb(const OUString& sFunctionName,
                                        const Sequence< Any >& Params,
@@ -149,6 +149,12 @@
                                        Sequence< sal_Int16 >& OutParamIndex,
                                        Sequence< Any >& OutParam);
 
+  Any  IUnknownWrapper_Impl::invokeWithDispIdComTlb(FuncDesc& aFuncDesc,
+						    const OUString& sFuncName,
+						    const Sequence< Any >& Params,
+						    Sequence< sal_Int16 >& OutParamIndex,
+						    Sequence< Any >& OutParam);
+
 //    virtual void setValueWithDispId(DISPID dispID, const Any& Value);
 
 //    virtual Any getValueWithDispId(const OUString& sName, DISPID dispID);
@@ -188,7 +192,10 @@ protected:
     /** Returns the DISPID for a function or property name. If true is returned then
         id contains a valid DISPID.
     */
+
     bool getDispid(const OUString& sFuncName, DISPID * id);
+
+	VARTYPE getUserDefinedElementType( ITypeInfo* pTypeInfo, const DWORD nHrefType );
     
     /** Gets the element type in a VARIANT like style. E.g. if desc->lptdesc contains
         a VT_PTR than it is replaced by VT_BYREF and VT_SAFEARRAY is replaced by VT_ARRAY
diff --git extensions/source/propctrlr/defaultforminspection.cxx extensions/source/propctrlr/defaultforminspection.cxx
index 2fab077..ac57f9e 100644
--- extensions/source/propctrlr/defaultforminspection.cxx
+++ extensions/source/propctrlr/defaultforminspection.cxx
@@ -149,7 +149,7 @@ namespace pcr
             { "com.sun.star.form.inspection.EventHandler", false },
 
             // a handler which introduces virtual properties for binding controls to spreadsheet cells
-            { "com.sun.star.form.inspection.CellBindingPropertyHandler", true },
+            { "com.sun.star.form.inspection.CellBindingPropertyHandler", false },
 
             // properties related to binding to an XForms DOM node
             { "com.sun.star.form.inspection.XMLFormsPropertyHandler", true },
diff --git extensions/source/propctrlr/formmetadata.cxx extensions/source/propctrlr/formmetadata.cxx
index f6ab37e..58df4cd 100644
--- extensions/source/propctrlr/formmetadata.cxx
+++ extensions/source/propctrlr/formmetadata.cxx
@@ -138,6 +138,7 @@ namespace pcr
         DEF_INFO_3( LABEL,             LABEL,              LABEL,             FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( CONTROLLABEL,      LABELCONTROL,       CONTROLLABEL,      FORM_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( WRITING_MODE,      WRITING_MODE,       WRITING_MODE,      FORM_VISIBLE, ENUM, COMPOSEABLE ),
+        DEF_INFO_3( GROUP_NAME,        GROUP_NAME,         GROUP_NAME,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( TEXT,              TEXT,               TEXT,              DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( MAXTEXTLEN,        MAXTEXTLEN,         MAXTEXTLEN,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( EDITMASK,          EDITMASK,           EDITMASK,          FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
diff --git extensions/source/propctrlr/formmetadata.hxx extensions/source/propctrlr/formmetadata.hxx
index e5413f2..c11797a 100644
--- extensions/source/propctrlr/formmetadata.hxx
+++ extensions/source/propctrlr/formmetadata.hxx
@@ -163,6 +163,7 @@ namespace pcr
     #define PROPERTY_ID_ALLOWADDITIONS		 20
     #define PROPERTY_ID_ALLOWEDITS			 21
     #define PROPERTY_ID_ALLOWDELETIONS		 22
+	#define PROPERTY_ID_GROUP_NAME    		 23
     #define PROPERTY_ID_NAVIGATION			 24
     #define PROPERTY_ID_CYCLE				 25
     #define PROPERTY_ID_HIDDEN_VALUE		 26
diff --git extensions/source/propctrlr/formres.src extensions/source/propctrlr/formres.src
index c853723..11c08c0 100644
--- extensions/source/propctrlr/formres.src
+++ extensions/source/propctrlr/formres.src
@@ -231,6 +231,10 @@ String RID_STR_NAME
 {
     Text [ en-US ] = "Name" ;
 };
+String RID_STR_GROUP_NAME
+{
+	Text [ en-US ] = "Group name" ;
+};
 String RID_STR_TABINDEX
 {
     Text [ en-US ] = "Tab order" ;
diff --git extensions/source/propctrlr/formresid.hrc extensions/source/propctrlr/formresid.hrc
index 613db7d..e05a6bb 100644
--- extensions/source/propctrlr/formresid.hrc
+++ extensions/source/propctrlr/formresid.hrc
@@ -149,6 +149,7 @@
 #define RID_STR_CURSOR_TYPE					( RID_FORMBROWSER_START + 121 )
 #define RID_STR_ENABLE_VISIBLE              ( RID_FORMBROWSER_START + 122 )
 #define RID_STR_WHEEL_BEHAVIOR              ( RID_FORMBROWSER_START + 123 )
+#define RID_STR_GROUP_NAME                  ( RID_FORMBROWSER_START + 124 )
     // FREE
     // FREE
     // FREE
diff --git extensions/source/propctrlr/formstrings.hxx extensions/source/propctrlr/formstrings.hxx
index b338653..95a57b1 100644
--- extensions/source/propctrlr/formstrings.hxx
+++ extensions/source/propctrlr/formstrings.hxx
@@ -48,6 +48,7 @@ namespace pcr
     PCR_CONSTASCII_STRING( PROPERTY_WHEEL_BEHAVIOR,         "MouseWheelBehavior");
     PCR_CONSTASCII_STRING( PROPERTY_TAG,					"Tag");
     PCR_CONSTASCII_STRING( PROPERTY_NAME,					"Name");
+	PCR_CONSTASCII_STRING( PROPERTY_GROUP_NAME,             "GroupName");
     PCR_CONSTASCII_STRING( PROPERTY_VALUE,					"Value");
     PCR_CONSTASCII_STRING( PROPERTY_TEXT,					"Text");
     PCR_CONSTASCII_STRING( PROPERTY_NAVIGATION,				"NavigationBarMode");
diff --git extensions/util/hidother.src extensions/util/hidother.src
index 2aa0413..48f2e8e 100644
--- extensions/util/hidother.src
+++ extensions/util/hidother.src
@@ -207,6 +207,7 @@ hidspecial HID_PROP_FOCUSONCLICK                { HelpId = HID_PROP_FOCUSONCLICK
 hidspecial HID_PROP_FONT                        { HelpId = HID_PROP_FONT; }
 hidspecial HID_PROP_FORMATKEY                   { HelpId = HID_PROP_FORMATKEY; }
 hidspecial HID_PROP_GROUPBOX                    { HelpId = HID_PROP_GROUPBOX; }
+hidspecial HID_PROP_GROUP_NAME                  { HelpId = HID_PROP_GROUP_NAME; }
 hidspecial HID_PROP_HEIGHT                      { HelpId = HID_PROP_HEIGHT; }
 hidspecial HID_PROP_HELPTEXT                    { HelpId = HID_PROP_HELPTEXT; }
 hidspecial HID_PROP_HELPURL                     { HelpId = HID_PROP_HELPURL; }
diff --git filter/inc/filter/msfilter/escherex.hxx filter/inc/filter/msfilter/escherex.hxx
index 53f6f9b..0ee4916 100644
--- filter/inc/filter/msfilter/escherex.hxx
+++ filter/inc/filter/msfilter/escherex.hxx
@@ -45,6 +45,7 @@
 #include <com/sun/star/drawing/BitmapMode.hpp>
 #include <com/sun/star/drawing/Hatch.hpp>
 #include <svx/msdffdef.hxx>
+#include <memory>
 #include "filter/msfilter/msfilterdllapi.h"
 
         /*Record Name       FBT-Value   Instance                  Contents                                                          Wrd Exl PPt Ver*/
@@ -1305,6 +1306,19 @@ public:
                                     const Rectangle& rRect ) = 0;
 };
 
+class InteractionInfo
+{
+	bool 			mbHasInteraction;
+	std::auto_ptr<SvMemoryStream>		mpHyperlinkRecord;
+	InteractionInfo();
+public:
+	InteractionInfo( SvMemoryStream* pStream, bool bInteraction ) : mbHasInteraction( bInteraction )
+	{
+		mpHyperlinkRecord.reset( pStream );
+	}
+	bool	hasInteraction() { return mbHasInteraction; }
+	const std::auto_ptr< SvMemoryStream >&	getHyperlinkRecord() { return mpHyperlinkRecord; }
+};
 
 class EscherExHostAppData
 {
@@ -1312,14 +1326,17 @@ private:
         EscherExClientAnchor_Base*	pClientAnchor;
         EscherExClientRecord_Base*	pClientData;
         EscherExClientRecord_Base*	pClientTextbox;
+		InteractionInfo*		pInteractionInfo;
         // ignore single shape if entire pages are written
         BOOL						bDontWriteShape;
 
 public:
         EscherExHostAppData() : pClientAnchor(0), pClientData(0),
-                                pClientTextbox(0), bDontWriteShape(FALSE)
+								pClientTextbox(0), pInteractionInfo(0), bDontWriteShape(FALSE)
         {}
 
+		void SetInteractionInfo( InteractionInfo* p )
+			{ pInteractionInfo = p; }
         void SetClientAnchor( EscherExClientAnchor_Base* p )
             { pClientAnchor = p; }
         void SetClientData( EscherExClientRecord_Base* p )
@@ -1328,6 +1345,8 @@ public:
             { pClientTextbox = p; }
         void SetDontWriteShape( BOOL b )
             { bDontWriteShape = b; }
+		InteractionInfo* GetInteractionInfo() const
+			{ return pInteractionInfo; }
         EscherExClientAnchor_Base* GetClientAnchor() const
             { return pClientAnchor; }
         EscherExClientRecord_Base* GetClientData() const
diff --git filter/inc/filter/msfilter/msocximex.hxx filter/inc/filter/msfilter/msocximex.hxx
index b8733b1..7caf854 100644
--- filter/inc/filter/msfilter/msocximex.hxx
+++ filter/inc/filter/msfilter/msocximex.hxx
@@ -29,6 +29,7 @@
 
 #include <sot/storage.hxx>
 #include <tools/debug.hxx>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //!! no such defines in global namespaces - it will break other existing code that uses the same define!!
 //#ifndef C2U
@@ -287,7 +288,10 @@ public:
     bool mbVisible;
     UniString sName;
     UniString msToolTip;
+	UniString msParentName;
     OCX_FontData aFontData;
+    rtl::OUString msCtrlSource;
+    rtl::OUString msRowSource;
         SfxObjectShell *pDocSh;
 protected:
 
@@ -324,14 +328,13 @@ public:
     nMultiState(0), nValueLen(0), nCaptionLen(0), nVertPos(1), nHorzPos(7),
     nSpecialEffect(2), nIcon(0), nPicture(0), nAccelerator(0), nGroupNameLen(0),
     pValue(0), pCaption(0), pGroupName(0), nIconLen(0), pIcon(0),
-    nPictureLen(0), pPicture(0) {}
+    nPictureLen(0) {}
 
     ~OCX_ModernControl() {
         if (pValue) delete[] pValue;
         if (pCaption) delete[] pCaption;
         if (pGroupName) delete[] pGroupName;
         if (pIcon) delete[] pIcon;
-        if (pPicture) delete[] pPicture;
     }
     sal_Bool Read(SotStorageStream *pS);
 
@@ -412,7 +415,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32 nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
 };
 
@@ -461,6 +465,7 @@ public:
 
         bool bAutoSize;
         ::rtl::OUString sImageUrl;
+		com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
         sal_Bool Read(SotStorageStream *pS);
 
     using OCX_Control::Import; // to not hide the other two import methods
@@ -485,6 +490,8 @@ struct ContainerRecord
 
     ::rtl::OUString cName;
     ::rtl::OUString controlTip;
+    ::rtl::OUString sCtrlSource;
+    ::rtl::OUString sRowSource;
 
     sal_uInt32 nTop;
     sal_uInt32 nLeft;
@@ -499,54 +506,8 @@ typedef std::vector<OCX_Control*>::iterator CtrlIterator;
 typedef std::vector<OCX_Control*>::const_iterator CtrlIteratorConst;
 typedef std::vector<OCX_Control*>  CtrlList;
 
-
-
-class RBGroup
-{
-    public:
-    RBGroup():mRBGroupPos(0){}
-    RBGroup(sal_uInt16& groupPos ):mRBGroupPos(groupPos){}
-    sal_Int16 tabPos() const { return mRBGroupPos; }
-    std::vector<OCX_Control*>::size_type numControls()
-    { return mpControls.size(); }
-    std::vector<OCX_Control*>& controls() { return mpControls; }
-
-    void add(OCX_Control* pRB);
-    private:
-    sal_uInt16 mRBGroupPos;
-    std::vector<OCX_Control*> mpControls;
-};
-
-typedef ::std::hash_map < ::rtl::OUString, RBGroup*, ::rtl::OUStringHash,
-    ::std::equal_to< ::rtl::OUString > > RBGroupHash;
-typedef std::vector<RBGroup*>::iterator GroupIterator;
-
 class OCX_OptionButton;
 
-class RBGroupManager
-{
-public:
-    RBGroupManager( String& defaultName );
-    ~RBGroupManager();
-
-    CtrlList insertGroupsIntoControlList( const CtrlList& sourceList );
-    void addRadioButton( OCX_OptionButton* pRButton );
-private:
-
-    void addSeperator( std::vector< OCX_Control* >& dest );
-    void copyList( std::vector< OCX_Control* >& src,
-                  std::vector< OCX_Control* >& dest,
-                  bool addGroupSeperator );
-
-    RBGroupHash rbGroups;
-    String mSDefaultName;
-    std::vector< RBGroup* > groupList;
-    sal_uInt16 numRadioButtons;
-};
-
-
-
-
 class OCX_ContainerControl : public OCX_Control
 {
 public:
@@ -572,8 +533,9 @@ public:
         SotStorageStreamRef getContainerStream() { return mContainerStream; }
 
         virtual void ProcessControl( OCX_Control* pControl, SvStorageStream* pS, ContainerRecord& rec );
-        bool createFromContainerRecord( const ContainerRecord& record,
+        bool createFromContainerRecord( ContainerRecord& record,
             OCX_Control*& );
+        SotStorageStreamRef getContainedControlsStream(){ return mContainedControlsStream; }
 protected:
         // This class not meant to be instantiated
         // needs to be subclassed
@@ -585,10 +547,10 @@ protected:
             OCX_Control* pParent = NULL );
         rtl::OUString createSubStreamName( const sal_uInt32& subStorageID );
 
-        RBGroupManager rbGroupMgr;
         com::sun::star::uno::Reference<
                 com::sun::star::container::XNameContainer > mxParent;
     std::vector<OCX_Control*> mpControls;
+        std::hash_map<sal_uInt16, sal_uInt16> mActiveXIDMap;
         SotStorageRef mContainerStorage;
         SotStorageStreamRef mContainerStream;
         SotStorageStreamRef mContainedControlsStream;
@@ -856,7 +818,6 @@ public:
     {
         delete[] pCaption;
         delete[] pIcon;
-        delete[] pPicture;
     }
 
     virtual sal_Bool Read(SvStorageStream *pS);
@@ -920,7 +881,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 private:
         com::sun::star::uno::Reference<
                 com::sun::star::uno::XComponentContext> mxCtx;
@@ -959,7 +921,8 @@ public:
     OCX_OptionButton() : OCX_ModernControl(rtl::OUString::createFromAscii("OptionButton"))
     {
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
-        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
         mnBackColor = 0x80000005L;
         mnForeColor = 0x80000008L;
         aFontData.SetHasAlign(TRUE);
@@ -1060,7 +1023,7 @@ class OCX_ComboBox : public OCX_ModernControl
 public:
     OCX_ComboBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ComboBox")){
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
-            msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlComboBoxModel");
+	        msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
         mnBackColor = 0x80000005;
         mnForeColor = 0x80000008;
         nBorderColor = 0x80000006;
@@ -1085,7 +1048,8 @@ class OCX_ListBox : public OCX_ModernControl
 public:
     OCX_ListBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ListBox")){
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
-        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
         mnBackColor = 0x80000005;
         mnForeColor = 0x80000008;
         nBorderColor = 0x80000006;
@@ -1113,7 +1077,7 @@ public:
     fEnabled(1), fLocked(0), fBackStyle(1), fWordWrap(0), fAutoSize(0),
         nCaptionLen(0), nVertPos(1), nHorzPos(7), nMousePointer(0), nPicture(0),
         nAccelerator(0), nIcon(0), pCaption(0), nIconLen(0), pIcon(0), nPictureLen(0),
-        pPicture(0), mbTakeFocus( true )
+        mbTakeFocus( true )
     {
             msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.CommandButton");
             msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlButtonModel");
@@ -1124,7 +1088,6 @@ public:
     ~OCX_CommandButton() {
         if (pCaption) delete[] pCaption;
         if (pIcon) delete[] pIcon;
-        if (pPicture) delete[] pPicture;
     }
     sal_Bool Read(SotStorageStream *pS);
 
@@ -1167,7 +1130,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
     bool        mbTakeFocus;
 
@@ -1285,7 +1249,7 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+ 	sal_uInt8 *pPicture;
 
     static OCX_Control *Create() { return new OCX_Label;}
 
diff --git filter/inc/filter/msfilter/mstoolbar.hxx filter/inc/filter/msfilter/mstoolbar.hxx
new file mode 100644
index 0000000..c117645
--- /dev/null
+++ filter/inc/filter/msfilter/mstoolbar.hxx
@@ -0,0 +1,334 @@
+#ifndef _MSTOOLBAR_HXX
+#define _MSTOOLBAR_HXX
+#include "filter/msfilter/msfilterdllapi.h"
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/ImageType.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vcl/bitmap.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+namespace css = ::com::sun::star;
+
+class TBCHeader;
+
+
+class MSOCommandConvertor
+{
+public:
+    virtual ~MSOCommandConvertor() {}
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd ) = 0; 
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID ) = 0; 
+};
+
+class SfxObjectShell;
+
+class MSFILTER_DLLPUBLIC CustomToolBarImportHelper
+{
+    struct iconcontrolitem
+    {
+        rtl::OUString sCommand;
+        css::uno::Reference< css::graphic::XGraphic > image;
+    };
+    std::vector< iconcontrolitem > iconcommands;
+    std::auto_ptr< MSOCommandConvertor > pMSOCmdConvertor;
+    css::uno::Reference< css::ui::XUIConfigurationManagerSupplier > m_xCfgSupp;
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xAppCfgMgr;
+    SfxObjectShell& mrDocSh;
+    void ScaleImage( css::uno::Reference< css::graphic::XGraphic >& xGraphic, long nNewSize );
+public:
+    CustomToolBarImportHelper( SfxObjectShell& rDocSh, const css::uno::Reference< css::ui::XUIConfigurationManager >& rxAppCfgMgr );
+
+    void setMSOCommandMap( MSOCommandConvertor* pCnvtr ) { pMSOCmdConvertor.reset( pCnvtr ); }
+    css::uno::Reference< css::ui::XUIConfigurationManager > getCfgManager();
+    css::uno::Reference< css::ui::XUIConfigurationManager > getAppCfgManager();
+
+
+    css::uno::Any createCommandFromMacro( const rtl::OUString& sCmd );
+
+    void addIcon( const css::uno::Reference< css::graphic::XGraphic >& xImage, const rtl::OUString& sString );
+    void applyIcons();
+    rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID );
+    SfxObjectShell& GetDocShell() { return mrDocSh; }
+    void showToolbar( const rtl::OUString& rName );
+    bool createMenu( const rtl::OUString& rName, const css::uno::Reference< css::container::XIndexAccess >& xMenuDesc, bool bPersist );
+};
+
+class MSFILTER_DLLPUBLIC TBBase
+{
+friend class Indent;
+    static int nIndent; // num spaces to indent before printing 
+protected:
+    void indent_printf(FILE* fp, const char* format, ... );
+    sal_uInt32 nOffSet; // usually for debug we can store the offset in the stream to this record
+public:
+    TBBase() : nOffSet( 0 ) {}
+    virtual ~TBBase(){}
+    rtl::OUString readUnicodeString( SvStream* pS, sal_Int32 nChars );
+
+    virtual bool Read(SvStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+    sal_uInt32 GetOffset() { return nOffSet; }
+};
+
+class Indent
+{
+public:
+    Indent( bool binit = false ) 
+    { 
+        if ( binit )
+            init();
+        else
+            TBBase::nIndent = TBBase::nIndent + 2; 
+    }
+    ~Indent() { TBBase::nIndent = TBBase::nIndent - 2; }
+    void init() { TBBase::nIndent = 0; }
+};
+
+
+class MSFILTER_DLLPUBLIC WString : public TBBase
+{
+    rtl::OUString sString;
+
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SvStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class MSFILTER_DLLPUBLIC TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString getOnAction();
+};
+
+class MSFILTER_DLLPUBLIC TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControlData( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >& );
+    rtl::OUString CustomText() { return customText.getString(); }
+    rtl::OUString DescriptionText() { return descriptionText.getString(); }
+    rtl::OUString Tooltip() { return tooltip.getString(); }
+};
+
+class MSFILTER_DLLPUBLIC TBCBitMap : public TBBase
+{
+friend class TBCBSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+    Bitmap mBitMap;
+    int size;
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    Bitmap& getBitMap(); 
+};
+
+class MSFILTER_DLLPUBLIC TBCMenuSpecific : public TBBase
+{
+    sal_Int32 tbid;
+    boost::shared_ptr< WString > name; //exist only if tbid equals 0x00000001
+public:
+    TBCMenuSpecific();
+    ~TBCMenuSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString Name();
+};
+
+class MSFILTER_DLLPUBLIC TBCCDData : public TBBase
+{
+    sal_Int16 cwstrItems; //Signed integer that specifies the number of items in wstrList. MUST be positive.
+    std::vector< WString > wstrList;  // Zero-based index array of WString structures. Number of elements MUST be equal to cwstrItems.
+    sal_Int16 cwstrMRU; // Signed integer that specifies the number of most recently used string
+    sal_Int16 iSel ; // Signed integer that specifies the zero-based index of the selected item in the wstrList field. MUST be equal to 0xFFFF (-1) or greater than or equal to 0x0000.
+    sal_Int16 cLines; // Signed integer that specifies the suggested number of lines that the toolbar control will display at any time when displaying the elements of wstrList of available items. 
+    sal_Int16 dxWidth; // Signed integer that specifies the width in pixels that the interior of the dropdown has. This excludes the width of the toolbar control border and scroll bar.
+    WString wstrEdit; //Structure of type WString. Editable text for editable area of the ComboBox toolbar control.
+
+public:
+    TBCCDData();
+    ~TBCCDData();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCComboDropdownSpecific : public TBBase
+{
+    boost::shared_ptr< TBCCDData > data;
+public:
+    TBCComboDropdownSpecific( const TBCHeader& header );
+    TBCComboDropdownSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    boost::shared_ptr< TBCBitMap > icon; // optional
+    boost::shared_ptr< TBCBitMap > iconMask; // optional
+    boost::shared_ptr< sal_uInt16 > iBtnFace; // optional
+    boost::shared_ptr< WString > wstrAcc; // optional
+   
+public:
+    TBCBSpecific();
+    ~TBCBSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    // #TODO just add a getGraphic member here
+    TBCBitMap* getIcon();
+    TBCBitMap* getIconMask();
+    sal_uInt16* getBtnFace() { return iBtnFace.get(); }
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+class MSFILTER_DLLPUBLIC TBCHeader : public TBBase
+{
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    boost::shared_ptr< sal_uInt16 > width;  //optional
+    boost::shared_ptr< sal_uInt16 > height; //optional
+
+public:
+    TBCHeader();
+    ~TBCHeader();
+    sal_uInt8 getTct() const { return tct; }
+    sal_uInt16 getTcID() const { return tcid; }
+    bool isVisible() { return !( bFlagsTCR & 0x1 ); }
+    bool isBeginGroup() { return ( bFlagsTCR & 0x2 ); }
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_uInt32 getTbct() { return tbct; };
+};
+
+class MSFILTER_DLLPUBLIC TBCData : public TBBase
+{
+    TBCHeader rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    boost::shared_ptr< TBBase > controlSpecificInfo; // can be one of TBCBSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header );
+    ~TBCData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >&, bool& bBeginGroup, bool bIsMenuBar );
+    TBCGeneralInfo& getGeneralInfo() { return controlGeneralInfo; }
+    TBCMenuSpecific* getMenuSpecific();
+};
+
+class MSFILTER_DLLPUBLIC TB : public TBBase
+{
+    sal_uInt8 bSignature;// Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_uInt8 bVersion; // Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; // Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid;// Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr;// Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault;// Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name
+public:
+    TB();
+    ~TB(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_Int16 getcCL(){ return cCL; }
+    WString& getName(){ return name; }
+    bool IsEnabled();
+    bool IsMenuToolbar(){ return ( ( ltbtr & 0x2000000 ) == 0x2000000 ); }
+    bool NeedsPositioning();
+};
+
+class MSFILTER_DLLPUBLIC SRECT : public TBBase
+{
+public:
+    SRECT() : left(0), top(0), right(0), bottom(0) {}
+    sal_Int16 left;
+    sal_Int16 top;
+    sal_Int16 right;
+    sal_Int16 bottom;
+    bool Read( SvStream* pS ) { *pS >> left >> top >> right >> bottom; return true; }
+    void Print( FILE* fo );
+};
+
+typedef cppu::WeakImplHelper1< css::container::XIndexContainer > PropertyValueIndexContainer_BASE;
+
+class MSFILTER_DLLPUBLIC TBVisualData : public TBBase
+{
+    sal_Int8 tbds;
+    sal_Int8 tbv;
+    sal_Int8 tbdsDock;
+    sal_Int8 iRow;
+
+    SRECT rcDock;
+    SRECT rcFloat;
+
+public:
+    TBVisualData();
+    ~TBVisualData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+#endif
diff --git filter/inc/filter/msfilter/svxmsbas.hxx filter/inc/filter/msfilter/svxmsbas.hxx
index 3a945fe..a619c99 100644
--- filter/inc/filter/msfilter/svxmsbas.hxx
+++ filter/inc/filter/msfilter/svxmsbas.hxx
@@ -32,6 +32,8 @@
 #include "filter/msfilter/msfilterdllapi.h"
 
 #include <sot/storage.hxx>
+#include <map>
+#include <hash_map>
 
 class SfxObjectShell;
 
@@ -50,6 +52,12 @@ class SfxObjectShell;
  * probably what the user expects to see when viewing the code
  */
 
+typedef std::hash_map< sal_Int32, String >  ObjIdToName;
+
+typedef std::map< String, ObjIdToName >  ControlAttributeInfo;
+
+class VBA_Impl;
+
 class MSFILTER_DLLPUBLIC SvxImportMSVBasic
 {
 public:
@@ -76,23 +84,31 @@ public:
 
     // check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
     // If it exist, then return the WarningId for loosing the information.
+
+        const ControlAttributeInfo& ControlNameForObjectId(){ return m_ModuleNameToObjIdHash; }
     static ULONG GetSaveWarningOfMSVBAStorage( SfxObjectShell &rDocS );
 
     static String GetMSBasicStorageName();
+        rtl::OUString GetVBAProjectName() { return msProjectName; }
 private:
     SotStorageRef xRoot;
     SfxObjectShell &rDocSh;
     BOOL bImport;
     BOOL bCopy;
+	ControlAttributeInfo m_ModuleNameToObjIdHash;
+	MSFILTER_DLLPRIVATE void extractAttribute( const String& rAttribute, const String& rModName );
 
     MSFILTER_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
                           const String &rSubStorageName,
                           const std::vector< String >& codeNames,
                           BOOL bAsComment, BOOL bStripped);
     MSFILTER_DLLPRIVATE bool ImportForms_Impl(const String& rStorageName, 
-        const String &rSubStorageName);
+		const String &rSubStorageName, BOOL bVBAMode);
     MSFILTER_DLLPRIVATE BOOL CopyStorage_Impl( const String& rStorageName,
                            const String &rSubStorageName);
+        rtl::OUString msProjectName;
+	MSFILTER_DLLPRIVATE BOOL ImportCode_Impl( VBA_Impl&, const std::vector< String >&, BOOL, BOOL );
+	MSFILTER_DLLPRIVATE bool ImportForms_Impl( VBA_Impl&, const String&, const String&, BOOL);
 };
 
 #endif
diff --git filter/source/msfilter/eschesdo.cxx filter/source/msfilter/eschesdo.cxx
index ed82269..e8fe184 100644
--- filter/source/msfilter/eschesdo.cxx
+++ filter/source/msfilter/eschesdo.cxx
@@ -244,6 +244,19 @@ UINT32 ImplEESdrWriter::ImplWriteShape( ImplEESdrObject& rObj,
         // #i51348# shape name
         if( aShapeName.Len() > 0 )
             aPropOpt.AddOpt( ESCHER_Prop_wzName, aShapeName );
+        if ( InteractionInfo* pInteraction = mpHostAppData->GetInteractionInfo() )
+		{
+			const std::auto_ptr< SvMemoryStream >& pMemStrm = pInteraction->getHyperlinkRecord();
+			if ( pMemStrm.get() )
+			{
+				pMemStrm->ObjectOwnsMemory( FALSE );
+				sal_uInt8* pBuf = (sal_uInt8*) pMemStrm->GetData();
+				sal_uInt32 nSize = pMemStrm->Seek( STREAM_SEEK_TO_END );
+				aPropOpt.AddOpt( ESCHER_Prop_pihlShape, sal_False, nSize, pBuf, nSize );;       
+			}
+			if ( pInteraction->hasInteraction() )
+				aPropOpt.AddOpt( ESCHER_Prop_fPrint, 0x00080008 );       
+        }
 
         if ( rObj.GetType().EqualsAscii( "drawing.Custom" ) )
         {
diff --git filter/source/msfilter/makefile.mk filter/source/msfilter/makefile.mk
index 7780529..c59a126 100644
--- filter/source/msfilter/makefile.mk
+++ filter/source/msfilter/makefile.mk
@@ -53,6 +53,7 @@ SLOFILES= \
     $(SLO)$/svdfppt.obj		\
     $(SLO)$/svxmsbas2.obj \
     $(SLO)$/msvbahelper.obj \
+	$(SLO)$/mstoolbar.obj\
 
 SHL1TARGET= msfilter$(DLLPOSTFIX)
 SHL1IMPLIB=	i$(TARGET)
@@ -61,6 +62,7 @@ SHL1USE_EXPORTS=name
 SHL1STDLIBS= \
              $(EDITENGLIB) \
              $(SVXCORELIB) \
+             $(SVTOOLLIB) \
              $(SFX2LIB) \
              $(XMLOFFLIB) \
              $(BASEGFXLIB) \
diff --git filter/source/msfilter/msocximex.cxx filter/source/msfilter/msocximex.cxx
index 0391c5c..3405ad4 100644
--- filter/source/msfilter/msocximex.cxx
+++ filter/source/msfilter/msocximex.cxx
@@ -46,6 +46,10 @@
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
 #include <com/sun/star/form/XForm.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
 #include <com/sun/star/form/FormComponentType.hpp>
 #include <com/sun/star/awt/FontWeight.hpp>
 #include <com/sun/star/awt/FontSlant.hpp>
@@ -70,7 +74,22 @@
 #include <com/sun/star/ucb/XSimpleFileAccess.hpp>
 #include <algorithm>
 #include <memory>
-
+#include <com/sun/star/graphic/GraphicObject.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <unotools/streamwrap.hxx>
+
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <svtools/filterutils.hxx>
+ 
 #ifndef C2S
 #define C2S(cChar)	String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(cChar))
 #endif
@@ -84,6 +103,7 @@ using namespace cppu;
 
 
 #define WW8_ASCII2STR(s) String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(s))
+#define GRAPHOBJ_URLPREFIX "vnd.sun.star.GraphicObject:"
 
 
 static char sWW8_form[] = "WW-Standard";
@@ -112,126 +132,48 @@ long ReadAlign(SvStorageStream *pS, long nPos, int nAmount)
     return 0;
 }
 
-
 // NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
 // referenced externally. On import from ms document try to save images for controls here.
 // Images are stored in directory called temp in the user installation directory. Next version of OO/SO
 // hopefully will address this issue and allow a choice e.g. images for controls to be stored as links
 // or embeded in the document.
-
-// [out]location     path to the stream to where the image is to be stored,
-//               if same name exists in folder then this function calcuates a new name
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-//
-// returns, true if successful
-
-bool storePictureInFileSystem( OUString& location, sal_uInt8* data, sal_uInt32 dataLen )
-{
-    bool result = true;
-    OUString origPath = location;
-    try
-    {
-        uno::Reference<lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(),
-                                                      uno::UNO_QUERY_THROW );
-        uno::Reference< com::sun::star::ucb::XSimpleFileAccess> xSFA( xMSF->createInstance(
-                                                       S2U("com.sun.star.ucb.SimpleFileAccess" ) ),
-                                                       uno::UNO_QUERY_THROW );
-        OUString ext;
-        sal_Int32 index = 0;
-        while (  xSFA->exists( location ) )
-        {
-            ext = OUString::valueOf( ++index );
-            location = origPath + ext;
-        }
-
-        SvStream*  pStream = ::utl::UcbStreamHelper::CreateStream( location, STREAM_WRITE | STREAM_TRUNC );
-        if ( pStream )
-        {
-            pStream->Write(data, dataLen);
-            delete pStream;
-        }
-        else
-        {
-            result = false;
-        }
-    }
-    catch( uno::Exception& )
-    {
-        result = false;
-    }
-    return result;
+uno::Reference< graphic::XGraphicObject> lcl_readGraphicObject( SotStorageStream *pS )
+{
+	uno::Reference< graphic::XGraphicObject > xGrfObj;
+	uno::Reference< lang::XMultiServiceFactory > xServiceManager = ::comphelper::getProcessServiceFactory();
+	if( xServiceManager.is() )
+	{
+		try
+		{
+			// use the GraphicProvider service to get the XGraphic
+			uno::Reference< graphic::XGraphicProvider > xGraphProvider(
+					xServiceManager->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.graphic.GraphicProvider" ) ), uno::UNO_QUERY );
+			if( xGraphProvider.is() )
+			{
+				uno::Reference< io::XInputStream > xStream( new utl::OInputStreamWrapper( *pS ) );
+				if( xStream.is() )
+				{
+					uno::Sequence< beans::PropertyValue > aMediaProps( 1 );
+					aMediaProps[0].Name = ::rtl::OUString::createFromAscii( "InputStream" );
+					aMediaProps[0].Value <<= xStream;
+					uno::Reference< graphic::XGraphic > xGraphic = xGraphProvider->queryGraphic( aMediaProps );
+					if( xGraphic.is() )
+					{
+						// create an XGraphicObject
+						::comphelper::ComponentContext aContext( xServiceManager );
+						xGrfObj = graphic::GraphicObject::create( aContext.getUNOContext() );
+						xGrfObj->setGraphic(xGraphic);
+					}
+				}
+			}
+		}
+		catch( uno::Exception& )
+		{
+		}
+	}
+	return xGrfObj;
 }
 
-// NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
-// referenced externally. On import from ms document try to save images from controls here so this
-// at least a macro programmer has a chance to accessed them manually later. Next version of OO/SO
-// hopefully will address this issue.
-// Images will be stored in a top level folder in the document package, folder is named "MigratedImages"
-
-// [in] pDocSh*  the document shell.
-// [in] name     name of stream image to stored in.
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-
-bool storePictureInDoc( SfxObjectShell* pDocSh, OUString& name, sal_uInt8* data, sal_uInt32 dataLen )
-{
-    uno::Reference < embed::XStorage > xStor;
-    if (pDocSh)
-    {
-        xStor = pDocSh->GetStorage();
-        if( xStor.is() )
-        {
-            try
-            {
-                uno::Reference< embed::XStorage > xPictures = xStor->openStorageElement(
-                    OUString( RTL_CONSTASCII_USTRINGPARAM( "MigratedImages" ) ),
-                    embed::ElementModes::READWRITE );
-                uno::Reference< beans::XPropertySet > xPropSet( xPictures, uno::UNO_QUERY );
-
-                // Set media type of folder MigratedImages to something ( that is unknown ) so that
-                // it will get copied to exported OO/SO format after SaveAs
-                if ( xPropSet.is() )
-                {
-                    OUString aMediaType = C2U("MigrationImages");
-                    uno::Any a;
-                    a <<= aMediaType;
-                    xPropSet->setPropertyValue( C2U("MediaType"), a );
-                }
-
-                uno::Reference< io::XStream > xObjReplStr = xPictures->openStreamElement(
-                        name,
-                        embed::ElementModes::READWRITE | embed::ElementModes::TRUNCATE );
-                uno::Reference< io::XOutputStream > xOutStream( xObjReplStr->getOutputStream(), uno::UNO_QUERY_THROW );
-                uno::Sequence< sal_Int8 > imageBytes( (sal_Int8*)data, dataLen );
-                xOutStream->writeBytes( imageBytes );
-                xOutStream->closeOutput();
-
-                uno::Reference< embed::XTransactedObject > xTransact( xPictures, uno::UNO_QUERY );
-                if ( xTransact.is() )
-                {
-                    xTransact->commit();
-                }
-            }
-            catch( uno::Exception& )
-            {
-                return false;
-            }
-
-        }
-        else
-        {
-            // no storage something wrong
-            return false;
-        }
-    }
-    else
-    {
-        //No doc shell
-        return false;
-    }
-    return true;
-}
 
 long WriteAlign(SvStorageStream *pS, int nAmount)
 {
@@ -395,35 +337,11 @@ void lclReadCharArray( SvStorageStream& rStrm, char*& rpcCharArr, sal_uInt32 nLe
  */
 OUString lclCreateOUString( const char* pcCharArr, sal_uInt32 nLenFld )
 {
-    OUStringBuffer aBuffer;
     sal_uInt32 nBufSize = lclGetBufferSize( nLenFld );
     if( lclIsCompressed( nLenFld ) )
-    {
-        // buffer contains compressed Unicode, not encoded bytestring
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
-    }
-    else
-    {
-        // buffer contains Little-Endian Unicode
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
-        {
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
-            cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
-            aBuffer.setCharAt( nChar, cChar );
-        }
-    }
-    return aBuffer.makeStringAndClear();
+        return svt::BinFilterUtils::CreateOUStringFromStringArray( pcCharArr, nBufSize );
+
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray( pcCharArr, nBufSize );
 }
 
 // export ---------------------------------------------------------------------
@@ -543,8 +461,129 @@ const sal_uInt16 TOGGLEBUTTON = (sal_uInt16)0x1C;
 const sal_uInt16 SCROLLBAR = (sal_uInt16)0x2F;
 
 const sal_uInt16 MULTIPAGE = (sal_uInt16)0x39;
+// The IDs with bit 0x8000 set appear to be generated.
+// It looks like these ID's are used with the non-toolbox [1]
+// ActiveX controls that can be present in a Userform
+// ( note: RefEdit seems to be an exception )
+// In UserForm::Read just before the Container record starts
+// you will notice there can be sometimes trailing records, 
+// it seems that these records have a 1:1 relationship with the non-toolbox
+// controls present in the Userform. An id in the trailing record
+// seems to identify the specific ActiveX control and an artificial nTypeIdent
+// e.g. 0x8000, 0x8001 etc. is created so as to be able to associate
+// the ActiveX control when referenced later 
+// [1] Such ActiveX controls are added via Tools/AddionalControls
+// menu
+
+// create a fixed set of those special id(s)
+// ahem, we can only read one Progress bars at the moment so....
 const sal_uInt16 PROGRESSBAR = (sal_uInt16)0x8000;
 
+// A set of IDs from the trailing records mentioned above that seem to
+// identify the following ActiveX controls 
+// Currently we only can process ( in a limited way ) the ProgressBar
+// the other ID's are for reference ( & future )
+
+// RefEdit control {00024512-0000-0000-c000-000000000046}
+const sal_uInt8 aRefEditID[] =
+{
+0x12, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+// Microsoft ProgressBar Control, version 6.0 {35053A22-8589-11D1-B16A-00C0F0283628}
+const sal_uInt8 aProgressID[] =
+{
+0x22, 0x3a, 0x05, 0x35, 0x89, 0x85, 0xd1, 0x11,  0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Calendar Control 10.0 
+const sal_uInt8 aCalendarID[] =
+{
+0x2b, 0xc9, 0x27, 0x8e, 0x64, 0x12, 0x1c, 0x10, 0x8a, 0x2f, 0x04, 0x02, 0x24, 0x00, 0x9c, 0x02,
+};
+
+
+// Microsoft ImageComboxBox Control, version 6.0 {DD9DA666-8594-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageComboID[] =
+{
+0x66, 0xa6, 0x9d, 0xdd, 0x94, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft ImageList Control, version 6.0 {2C247F23-8591-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageListID[] =
+{
+0x23, 0x7f, 0x24, 0x2c, 0x91, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Slider Control, version 6.0 {F08DF954-8592-11D1-B16A-00C0F0283628}
+const sal_uInt8 aSliderID[] =
+{
+0x54, 0xf9, 0x8d, 0xf0, 0x92, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft StatusBar Control, version 6.0 {8E3867A3-8586-11D1-B16A-00C0F0283628}
+const sal_uInt8 aStatusBarID[] =
+{
+0xa3, 0x67, 0x38, 0x8e, 0x86, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Office Chart 10.0
+const sal_uInt8 aChartSpaceID[] =
+{
+0x46, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+const sal_Int16 ActiveXIDLen = 0x10; // CLSID len
+const sal_Int16 ActiveXIDBlockLen = 0x30; // the block len that contains the CLSID
+
+bool lcl_handleActiveXControl(  SvStorageStream *pS, sal_uInt16& nTypeID )
+{
+    nTypeID = 0; // Illegal ActiveX ID 
+    bool bRes = false;
+    sal_uInt16 nIdentifier, nFixedAreaLen;
+    *pS >> nIdentifier;    
+    *pS >> nFixedAreaLen;    
+    pS->SeekRel( ( nFixedAreaLen - ActiveXIDBlockLen ) );
+    sal_uInt8 aID[ ActiveXIDLen ];
+    if ( !pS->IsEof() )
+    {
+        pS->Read( aID, ActiveXIDLen );
+        pS->SeekRel( ActiveXIDBlockLen - ActiveXIDLen ); // read remainer of record
+        if ( memcmp( aID, aProgressID, ActiveXIDLen ) == 0 )
+        {
+            nTypeID = PROGRESSBAR;
+            OSL_TRACE("Found supported ***PROGRESSBAR*** ActiveX control");
+            bRes = true;
+        }
+#if (OSL_DEBUG_LEVEL > 0)
+        // If we really want to process these more controls we should put them in 
+        // a list or array and have a single loop testing each id. For the moment 
+        // as we only can process PROGRESSBAR, not much point doing that until 
+        // we add support for at least another activex control
+
+        else if ( memcmp( aID, aCalendarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CALENDAR*** ActiveX control");
+        else if ( memcmp( aID, aRefEditID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***REFEDIT*** ActiveX control");
+        else if ( memcmp( aID, aImageComboID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGECOMBO*** ActiveX control");
+        else if ( memcmp( aID, aImageListID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGELIST*** ActiveX control");
+        else if ( memcmp( aID, aChartSpaceID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CHARTSPACE*** ActiveX control");
+        else if ( memcmp( aID, aSliderID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***SLIDER*** ActiveX control");
+        else if ( memcmp( aID, aStatusBarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***STATUSBAR*** ActiveX control");
+#endif
+        else
+        {
+            OSL_TRACE("Unknown activeX ID !");
+        }
+    }
+    return bRes;
+}
+
 typedef std::vector< ContainerRecord > ContainerRecordList;
 
 class ContainerRecReader
@@ -619,6 +658,8 @@ class ContainerRecReader
             // control type
             if( nContentFlags & 0x00000080 )
                 *pS >> rec.nTypeIdent;
+            if( nContentFlags & 0x00000200 )
+                pS->SeekRel( 4 ); // Grouping?
             // length of infotip
             sal_uInt32 nTipLen = 0;
             if( nContentFlags & 0x00000800 )
@@ -693,14 +734,22 @@ class ContainerRecReader
             if( nCtrlSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nCtrlSrcBufSize );
+                std::auto_ptr< sal_Char > pCtrlSrcName;
+                pCtrlSrcName.reset( new sal_Char[ nCtrlSrcBufSize ] );
+                pS->Read( pCtrlSrcName.get(), nCtrlSrcBufSize );
+                rec.sCtrlSource = lclCreateOUString( pCtrlSrcName.get(), nCtrlSrcLen );
+                OSL_TRACE("*** *** *** ControlSourceName -> %s ", rtl::OUStringToOString( rec.sCtrlSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
             // row source name
             sal_uInt32 nRowSrcBufSize = lclGetBufferSize( nRowSrcLen );
             if( nRowSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nRowSrcBufSize );
+                std::auto_ptr< sal_Char > pRowSrcName;
+                pRowSrcName.reset( new sal_Char[ nRowSrcBufSize ] );
+                pS->Read( pRowSrcName.get(), nRowSrcBufSize );
+                rec.sRowSource =  lclCreateOUString( pRowSrcName.get(), nRowSrcLen );
+                OSL_TRACE("*** *** *** RowSourceName -> %s ", rtl::OUStringToOString( rec.sRowSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
 
             // seek to end of data
@@ -717,6 +766,13 @@ class ContainerRecReader
                 pControl->pDocSh = pContainerControl->pDocSh;
                 pContainerControl->ProcessControl( pControl, pS, rec );
             }
+            else if ( rec.nTypeIdent & 0x8000 )
+            {
+                // Skip ActiveX Controls we can't import
+                SotStorageStreamRef oStream = pContainerControl->getContainedControlsStream(); 
+                ULONG nStrmPos = oStream->Tell();
+                oStream->Seek( nStrmPos + rec.nSubStreamLen );
+            }  
             else
             {
                 DBG_ERROR("Terminating import, unexpected error");
@@ -737,6 +793,11 @@ class ContainerRecReader
     {
         sal_uInt8 aUnknown11[4];
         pS->Read(aUnknown11, sizeof(aUnknown11));
+        // discovered a dialog with value of 0xFF for aUnknown11 
+        // needed an extra 4 bytes to offset correctly  into the control
+        // records. Valid test or coincidence ?
+        if ( aUnknown11[1] == 0xFF )
+           pS->Read( aUnknown11, sizeof(aUnknown11));
         return true;
     }
 
@@ -811,176 +872,6 @@ class ContainerRecordReaderFac
 
 // ============================================================================
 
-void RBGroup::add(OCX_Control* pRB)
-{
-    // The tab index for the group is calculated as
-    // the lowest tab index found in the list of RadioButtons
-    if ( pRB->mnTabPos < mRBGroupPos )
-    {
-        mRBGroupPos = pRB->mnTabPos;
-        CtrlIterator aEnd = mpControls.end();
-        for (CtrlIterator aIter = mpControls.begin(); aIter != aEnd; ++ aIter )
-        {
-            (*aIter)->mnTabPos = mRBGroupPos;
-        }
-    }
-    mpControls.push_back( pRB );
-}
-
-struct SortGroupByTabPos
-{
-    bool operator()( const RBGroup* a, const RBGroup* b )
-    {
-        return a->tabPos() < b->tabPos();
-    }
-};
-
-RBGroupManager::RBGroupManager( String& defaultName ):mSDefaultName( defaultName ),
-    numRadioButtons(0)
-{
-    groupList.reserve( 8 ); // reserve far more than we expect
-}
-
-RBGroupManager::~RBGroupManager()
-{
-    for ( GroupIterator gIter=groupList.begin(); gIter!=groupList.end(); ++gIter )
-    {
-        delete( *gIter );
-    }
-}
-
-// Loose description of the method below ( I sure there is a better way to do
-// this )
-// In order to "fake" MS grouping behavior for OptionButtons the OptionButtons
-// in the same group need to have consecutive tab indices ( regardless of the
-// imported tab indices of the RadioButtons ). Additionally if two
-// groups of OptionButtons end up having all consecutive indices they
-// will be treated as a single group by OpenOffice. In this case
-// a dummy seperator control needs to be inserted between the groups.
-//
-// This method returns a new list "destinationList" containing the controls
-// passed in "sourceList" and the OptionButtons contained in the various
-// Groups maintained by this  class.
-// Controls are ordered in the destination list by tab index.
-// Each RadioButtonGroup has a tab index associated with it.
-// ( Tab index of a RadioGroup is determined as the tab index of the
-// OptionButton control with the lowest tab index in the group )
-
-
-void RBGroupManager::addRadioButton( OCX_OptionButton* pRButton )
-{
-    if ( pRButton )
-    {
-        OUString groupName = mSDefaultName;
-        if ( pRButton->nGroupNameLen )
-        {
-            groupName =
-                lclCreateOUString(pRButton->pGroupName,
-                    pRButton->nGroupNameLen);
-        }
-        ++numRadioButtons;
-        RBGroupHash::iterator iter = rbGroups.find( groupName );
-        if ( iter != rbGroups.end() )
-        {
-            iter->second->controls().push_back( pRButton );
-        }
-        else
-        {
-            RBGroup* newGroup = new RBGroup(pRButton->mnTabPos);
-            newGroup->controls().push_back( pRButton );
-            rbGroups[ groupName ] = newGroup;
-            groupList.push_back( newGroup );
-        }
-
-    }
-}
-
-CtrlList RBGroupManager::insertGroupsIntoControlList( const CtrlList& sourceList )
-{
-    ::std::sort( groupList.begin(), groupList.end(), SortGroupByTabPos() );
-    std::vector<OCX_Control*> destinationList;
-    if ( groupList.size() )
-    {
-        destinationList.reserve( sourceList.size() + numRadioButtons );
-
-        GroupIterator groupEnd = groupList.end();
-        CtrlIteratorConst sourceEnd = sourceList.end();
-
-        size_t prevGroupListSize = 0;
-
-        CtrlIteratorConst containees = sourceList.begin();
-        GroupIterator groupIter=groupList.begin();
-        while ( containees != sourceEnd ||
-                groupIter != groupEnd )
-        {
-            bool addGroupSeperator = false;
-            if ( containees != sourceEnd )
-            {
-                if ( groupIter != groupEnd )
-                {
-                    sal_Int16 groupTabPos = (*groupIter)->tabPos();
-                    if ( (*containees)->mnTabPos >= groupTabPos )
-                    {
-                       if ( !(destinationList.size() >=  prevGroupListSize ))
-                        {
-                            addGroupSeperator = true;
-                        }
-                        copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                        ++groupIter;
-
-                        prevGroupListSize = destinationList.size();
-                    }
-                }
-                destinationList.push_back(*containees);
-                ++containees;
-            }
-            else
-            {
-               if ( groupIter != groupEnd )
-               {
-                    if ( !(destinationList.size() >  prevGroupListSize ))
-                    {
-                        addGroupSeperator = true;
-                    }
-                    copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                    ++groupIter;
-                    prevGroupListSize = destinationList.size();
-                }
-            }
-        }
-    }
-    else
-    {
-        destinationList = sourceList;
-    }
-    return destinationList;
-
-}
-
-
-void RBGroupManager::addSeperator( std::vector< OCX_Control* >& dest )
-{
-    OCX_Control* seperator = new OCX_CommandButton;
-    seperator->SetInDialog(true);
-    seperator->sName = C2S("GroupSeperator");
-    dest.push_back( seperator );
-}
-
-void RBGroupManager::copyList( std::vector< OCX_Control* >& src,
-    std::vector< OCX_Control* >& dest,
-    bool addGroupSeperator )
-{
-    if ( addGroupSeperator )
-    {
-        addSeperator( dest );
-    }
-
-    for ( CtrlIterator rbIter = src.begin(); rbIter != src.end(); ++rbIter )
-    {
-        dest.push_back( *rbIter );
-    }
-}
-
 class OCX_UserFormLabel : public OCX_Label
 {
 public:
@@ -1147,6 +1038,9 @@ sal_Bool OCX_Control::Import(
 sal_Bool OCX_Control::Import(uno::Reference<container::XNameContainer> &rDialog
     )
 {
+    uno::Reference<beans::XPropertySet > xDlgProps( rDialog, uno::UNO_QUERY);
+
+    
     uno::Reference<lang::XMultiServiceFactory>
         xFactory(rDialog, uno::UNO_QUERY);
 
@@ -1159,11 +1053,15 @@ sal_Bool OCX_Control::Import(uno::Reference<container::XNameContainer> &rDialog
     if (!xModel.is())
         return sal_False;
 
+    sal_Bool bVBA = sal_False;
     /*  #147900# sometimes insertion of a control fails due to existing name,
         do not break entire form import then... */
     try
     {
         rDialog->insertByName(sName, uno::makeAny(xModel));
+        if ( xDlgProps.is() )
+            xDlgProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+
     }
     catch( uno::Exception& )
     {
@@ -1179,16 +1077,31 @@ sal_Bool OCX_Control::Import(uno::Reference<container::XNameContainer> &rDialog
 
     if (!Import(xPropSet))
         return sal_False;
-
+    
     uno::Any aTmp;
-    aTmp <<= sal_Int32((mnLeft * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
-    aTmp <<= sal_Int32((mnTop * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+
+    if ( !bVBA  )
+    {
+        aTmp <<= sal_Int32((mnLeft * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32((mnTop * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32((nWidth * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32(mnLeft); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32(mnTop); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32(nWidth); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
     if ( msToolTip.Len() > 0 )
         xPropSet->setPropertyValue(WW8_ASCII2STR("HelpText"), uno::Any(OUString(msToolTip)));
 
@@ -1403,6 +1316,12 @@ sal_Bool OCX_CommandButton::Import( com::sun::star::uno::Reference<
     rPropSet->setPropertyValue( WW8_ASCII2STR( "FocusOnClick" ), aTmp );
 
     aFontData.Import(rPropSet);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
     return sal_True;
 }
 
@@ -1650,6 +1569,99 @@ sal_Bool OCX_ImageButton::Export(SvStorageRef &rObj,
     return WriteContents(xContents,rPropSet,rSize);
 }
 
+bool lcl_isNamedRange( const rtl::OUString& sAddress, uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
+
+void lcl_ApplyListSourceAndBindableStuff( uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& rPropSet, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+}
 
 sal_Bool OCX_OptionButton::Import(com::sun::star::uno::Reference<
         com::sun::star::beans::XPropertySet> &rPropSet)
@@ -1682,12 +1694,51 @@ sal_Bool OCX_OptionButton::Import(com::sun::star::uno::Reference<
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-    if (pValue && !bSetInDialog)
+	if (pValue)
     {
         INT16 nTmp = pValue[0]-0x30;
         aTmp <<= nTmp;
-        rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
-    }
+		if (!bSetInDialog)
+			rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		{
+			// dialog ( but we might be using the form model )
+			if ( rPropSet->getPropertySetInfo()->hasPropertyByName( WW8_ASCII2STR("DefaultState") ) )
+				rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+			else
+				rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
+		}
+	}
+    // If this is a dialog control then we need to  set a groupname *always*
+    rtl::OUString sGroupName = lclCreateOUString( pGroupName, nGroupNameLen );
+    if ( GetInDialog() ) // Userform/Dialog
+    {
+        // By default groupnames are not set in Excel, it's not unusual to have
+        // a number of groups of radiobuttons located inside frame ( or other container
+        // controls ) where there is *no* specific groupname set for the radiobuttons.
+        // But... there is implicit grouping for radio buttons in seperate containers
+        // e.g. radio buttons in a frame are by default in the same group.
+        // Unfortunately in openoffice there are no containers below the dialog itself :-(
+        // To ensure correct grouping for imported radiobuttons either with no groupname
+        // or identical groupnames that are in separate containers we *must* ensure
+        // that a suitable groupname is applied. 
+        // Because controlNames are unique even across different containers we can use the
+        // controls container (e.g. parent) name as a prefix for a group name
+	rtl::OUString sParentName = msParentName;
+        sGroupName = sParentName.concat( C2U( ":" ) ).concat( sGroupName );
+    }
+    if ( sGroupName.getLength() == 0 )
+        sGroupName = rtl::OUString::createFromAscii("DefaultGroup");
+	OSL_TRACE("RadioButton %s has groupname %s", 
+		rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sGroupName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        try
+        {
+            aTmp <<= sGroupName;
+            rPropSet->setPropertyValue( WW8_ASCII2STR("GroupName"), aTmp);
+        }
+        catch( uno::Exception& )
+        {
+        }
 
     if (pCaption)
     {
@@ -1699,6 +1750,14 @@ sal_Bool OCX_OptionButton::Import(com::sun::star::uno::Reference<
     aTmp <<= ::com::sun::star::style::VerticalAlignment_MIDDLE;
     rPropSet->setPropertyValue( WW8_ASCII2STR("VerticalAlign"), aTmp );
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
+
     aFontData.Import(rPropSet);
     return sal_True;
 }
@@ -2323,8 +2382,9 @@ sal_Bool OCX_ToggleButton::Import(com::sun::star::uno::Reference<
     if (pValue)
     {
         INT16 nTmp=pValue[0]-0x30;
-        aTmp <<= nTmp == 1;
-        rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+        //aTmp <<= nTmp == 1;
+        aTmp <<= nTmp;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
     }
 
     if (pCaption)
@@ -2334,6 +2394,12 @@ sal_Bool OCX_ToggleButton::Import(com::sun::star::uno::Reference<
     }
 
     aFontData.Import(rPropSet);
+	
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
     return sal_True;
 }
 
@@ -2589,6 +2655,8 @@ sal_Bool OCX_ComboBox::Import(com::sun::star::uno::Reference<
     rPropSet->setPropertyValue( WW8_ASCII2STR("MaxTextLen"), aTmp);
 
     aFontData.Import(rPropSet);
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
     return sal_True;
 }
 
@@ -2808,7 +2876,8 @@ sal_Bool OCX_ListBox::Import(com::sun::star::uno::Reference<
 
     aTmp <<= ImportColor( nBorderColor );
     rPropSet->setPropertyValue( WW8_ASCII2STR("BorderColor"), aTmp);
-
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
     aFontData.Import(rPropSet);
     return sal_True;
 }
@@ -3186,8 +3255,15 @@ sal_Bool OCX_ModernControl::Read(SvStorageStream *pS)
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
     }
 
     return sal_True;
@@ -3277,8 +3353,15 @@ sal_Bool OCX_CommandButton::Read(SvStorageStream *pS)
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
     }
 
     return sal_True;
@@ -3399,7 +3482,7 @@ OCX_ContainerControl::OCX_ContainerControl( SotStorageRef& parent,
             const ::rtl::OUString& sN,
             const uno::Reference< container::XNameContainer >  &rParent,
             OCX_Control* pParent ) :
-                OCX_Control(sN, pParent), rbGroupMgr( sName ), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
+                OCX_Control(sN, pParent), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
 {
 
     mContainerStorage = parent->OpenSotStorage(storageName,
@@ -3462,9 +3545,18 @@ OUString OCX_ContainerControl::createSubStreamName( const sal_uInt32& subStorage
     return buf.makeStringAndClear();
 }
 
-bool OCX_ContainerControl::createFromContainerRecord( const ContainerRecord& record, OCX_Control*& pControl )
+
+bool OCX_ContainerControl::createFromContainerRecord( ContainerRecord& record, OCX_Control*& pControl )
 {
     pControl = NULL;
+    if (  record.nTypeIdent & 0x8000 )
+    {
+        std::hash_map<sal_uInt16, sal_uInt16>::iterator it = mActiveXIDMap.find( record.nTypeIdent );
+        if ( it == mActiveXIDMap.end() )
+            return false;
+        // replace the generated id with our hardcoded one
+        record.nTypeIdent = it->second; 
+    }
     switch ( record.nTypeIdent)
         {
             case CMDBUTTON:
@@ -3572,8 +3664,7 @@ void OCX_ContainerControl::ProcessControl(OCX_Control* pControl,SvStorageStream*
     SotStorageStreamRef oStream = mContainedControlsStream;
 
     // can insert into OO Dialog (e.g is this a supported dialog control)??
-    if ( rec.nTypeIdent == SPINBUTTON ||
-        rec.nTypeIdent == TABSTRIP)
+    if ( rec.nTypeIdent == TABSTRIP )
     {
         // skip the record in the stream, discard the control
         oStream->SeekRel( rec.nSubStreamLen );
@@ -3583,15 +3674,27 @@ void OCX_ContainerControl::ProcessControl(OCX_Control* pControl,SvStorageStream*
     {
         // A container control needs to read the f stream in
         // the folder ( substorage ) associated with this control
-        if (  rec.nTypeIdent ==  FRAME ||
-            rec.nTypeIdent ==  MULTIPAGE||
-            rec.nTypeIdent ==  PAGE )
+        switch ( rec.nTypeIdent )
         {
-            OCX_ContainerControl* pContainer =
-               static_cast< OCX_ContainerControl* >( pControl );
-            oStream = pContainer->getContainerStream();
+            case FRAME:
+            case MULTIPAGE:
+            case PAGE:
+                {
+                    OCX_ContainerControl* pContainer =
+                        static_cast< OCX_ContainerControl* >( pControl );
+                    oStream = pContainer->getContainerStream();
+                    break;
+                }
+            case LISTBOX:
+            case OPTIONBUTTON:
+            case COMBOBOX:
+			case SPINBUTTON:
+			case SCROLLBAR:
+                {
+                    pControl->msCtrlSource = rec.sCtrlSource;
+                    pControl->msRowSource = rec.sRowSource;
+                }
         }
-
         pControl->sName = rec.cName;
         pControl->msToolTip = rec.controlTip;
         // Position of controls is relative to the container
@@ -3611,6 +3714,7 @@ void OCX_ContainerControl::ProcessControl(OCX_Control* pControl,SvStorageStream*
             // applied to all containees
             pControl->mnStep = mnStep;
         }
+        pControl->msParentName = sName;
 
         // #117490# DR: container records provide size of substream, use it here...
 
@@ -3621,17 +3725,7 @@ void OCX_ContainerControl::ProcessControl(OCX_Control* pControl,SvStorageStream*
         // set stream to position behind substream of this control
         oStream->Seek( nStrmPos + rec.nSubStreamLen );
 
-        //need to fake grouping behaviour for radio ( option ) buttons
-        if ( rec.nTypeIdent == OPTIONBUTTON )
-        {
-            OCX_OptionButton* pRButton =
-                static_cast< OCX_OptionButton*>(pControl);
-            rbGroupMgr.addRadioButton( pRButton );
-        }
-        else
-        {
-            mpControls.push_back( pControl );
-        }
+        mpControls.push_back( pControl );
     }
 }
 
@@ -3654,7 +3748,6 @@ sal_Bool OCX_ContainerControl::Read(SvStorageStream *pS)
     // this ensures that the default tab index created by Star/Open office
     // reflects the "flattened" ms tab order.
     ::std::sort( mpControls.begin(), mpControls.end(), SortOrderByTabPos() );
-    mpControls = rbGroupMgr.insertGroupsIntoControlList( mpControls );
     return true;
 }
 
@@ -3672,7 +3765,8 @@ OCX_MultiPage::OCX_MultiPage( SotStorageRef& parent,
         nScrollWidth(0), nScrollHeight(0), nIconLen(0), pIcon(0), nPictureLen(0),
         pPicture(0)
 {
-    msDialogType = C2U("NotSupported");
+    //msDialogType = C2U("NotSupported");
+    msDialogType = C2U("com.sun.star.awt.UnoMultiPageModel");
     mnForeColor = 0x80000012L,
     mnBackColor = 0x8000000FL;
     bSetInDialog = true;// UserForm control only
@@ -3736,7 +3830,6 @@ sal_Bool OCX_MultiPage::Read(SvStorageStream *pS)
 sal_Bool OCX_MultiPage::Import(com::sun::star::uno::Reference<
     com::sun::star::beans::XPropertySet> &rPropSet)
 {
-    // Calls import on contained controls
     OCX_ContainerControl::Import( rPropSet );
     return sal_True;
 }
@@ -3757,6 +3850,43 @@ sal_Bool OCX_MultiPage::Import(com::sun::star::uno::Reference<
 
     if ( xPropSet.is() )
     {
+        uno::Reference<lang::XMultiServiceFactory>
+            xFactory(rDialog, uno::UNO_QUERY);
+	OSL_TRACE("** MultiPage creating control %s", rtl::OUStringToOString( msDialogType, RTL_TEXTENCODING_UTF8 ).getStr() );
+	uno::Reference<uno::XInterface> xCreate = xFactory->createInstance(msDialogType);
+	if (!xCreate.is())
+		return sal_False;
+
+	uno::Reference<awt::XControlModel> xModel(xCreate, uno::UNO_QUERY);
+	if (!xModel.is())
+		return sal_False;
+
+        try
+        {
+		// we should just call MultiPage::Import( XPropertySet )
+    		OSL_TRACE("********* MULTIPAGE cName %s", rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+		uno::Any aTmp(&sName,getCppuType((OUString *)0));
+		uno::Reference<beans::XPropertySet> xPrps(xModel, uno::UNO_QUERY);
+		xPrps->setPropertyValue( WW8_ASCII2STR("Name"), aTmp );
+		aTmp = uno::makeAny( mnCurrentPageStep );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValueMax"), aTmp );
+		// default current page to 0 ( #FIXME, we need to read this value )
+		aTmp = uno::makeAny( sal_Int32(0) );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValue"), aTmp );
+    		OSL_TRACE("********* MULTIPAGE vomitted out properties");
+
+    // Calls import on contained controls
+            rDialog->insertByName(sName, uno::makeAny(xModel));
+            OSL_TRACE("*** inserted ***");
+        }
+        catch( uno::Exception& )
+        {
+            DBG_ERRORFILE(
+                ByteString( "OCX_Control::Import - cannot insert control \"" ).
+                Append( ByteString( sName, RTL_TEXTENCODING_UTF8 ) ).
+                Append( '"' ).GetBuffer() );
+        }
+
         // Calls import on contained pages
         return OCX_ContainerControl::Import( xPropSet );
     }
@@ -4043,8 +4173,7 @@ OCX_UserForm::OCX_UserForm( SotStorageRef& parent,
         nKeepScrollBarsVisible(3), nCycle(0), nBorderStyle(0), nSpecialEffect(0),
         nPicture(0), nPictureAlignment(2), nPictureSizeMode(0),
         bPictureTiling(FALSE), nAccelerator(0), nIcon(0), pCaption(0),
-        nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0),
-        pPicture(0)
+		nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0)
     {
             mnForeColor = 0x80000012;
             mnBackColor = 0x8000000F;
@@ -4174,24 +4303,30 @@ sal_Bool OCX_UserForm::Read(SvStorageStream *pS)
         pS->Read(pIcon,nIconLen);
     }
 
+	ReadAlign( pS, pS->Tell() - nStart, 4);
+	if (pBlockFlags[2] & 0x10)
+	{
+		//Font Stuff..
+		pS->SeekRel(0x1a);
+		sal_uInt8 nFontLen;
+		*pS >> nFontLen;
+		pS->SeekRel(nFontLen);
+	}
     if (nPicture)
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
-    }
-
-    ReadAlign( pS, pS->Tell() - nStart, 4);
-
-    if (pBlockFlags[2] & 0x10)
-    {
-        //Font Stuff..
-        pS->SeekRel(0x1a);
-        sal_uInt8 nFontLen;
-        *pS >> nFontLen;
-        pS->SeekRel(nFontLen);
-    }
+		long imagePos = pS->Tell();
+		// great embedded object
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image.
+		pS->Seek( imagePos + nPictureLen );
+	}
 
     sal_Int16 numTrailingRecs = 0;
     *pS >> numTrailingRecs;
@@ -4200,10 +4335,14 @@ sal_Bool OCX_UserForm::Read(SvStorageStream *pS)
     // ( unknown what these trailing records are for)
     if ( numTrailingRecs )
     {
-        for ( ; numTrailingRecs ; --numTrailingRecs )
+        for ( sal_Int16 i = 0 ; numTrailingRecs ; --numTrailingRecs, ++i )
         {
-            OCX_Control skip(C2S("dummy")) ;
-            skip.Read( pS );
+            sal_uInt16 nTypeID = 0;
+            if ( lcl_handleActiveXControl( pS, nTypeID ) )
+            {
+                if ( nTypeID & 0x8000 ) // valid ActiveXID
+                    mActiveXIDMap[ ( i | 0x8000 ) ] = nTypeID;
+            }
         }
     }
     return OCX_ContainerControl::Read( pS );
@@ -4214,6 +4353,8 @@ sal_Bool OCX_UserForm::Import(
 {
     uno::Reference<beans::XPropertySet>
         xDialogPropSet(mxParent, uno::UNO_QUERY);
+    if ( !xDialogPropSet.is() )
+        return sal_False;
     uno::Any aTmp(&sName,getCppuType((OUString *)0));
     xDialogPropSet->setPropertyValue(
         OUString(RTL_CONSTASCII_USTRINGPARAM("Name")), aTmp);
@@ -4221,22 +4362,55 @@ sal_Bool OCX_UserForm::Import(
         OUString(RTL_CONSTASCII_USTRINGPARAM("Title")), aTmp);
     aTmp <<= ImportColor(mnBackColor);
     xDialogPropSet->setPropertyValue( WW8_ASCII2STR("BackgroundColor"), aTmp);
+    sal_Bool bVBA = sal_False;
+    // Ok we are importing xls but maybe we aren't in VBA mode
+    // if we are not in VBA mode then we should import sizes etc. ( as before )
+    try
+    {
+        xDialogPropSet->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+    }
+    catch( uno::Exception& e )
+    {
+    }
+    if ( !bVBA )
+    {
+        aTmp <<= sal_Int32((nWidth * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32( nWidth + 160 ); // 100thmm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight + 662 - 714); //100th mm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
 
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
 
     uno::Reference<beans::XPropertySet> xPropSet( mxParent, uno::UNO_QUERY );
     OCX_ContainerControl::Import( xPropSet );
 
     uno::Reference<io::XInputStreamProvider> xSource =
-        xmlscript::exportDialogModel(mxParent, mxCtx);
+        xmlscript::exportDialogModel(mxParent, mxCtx, pDocSh->GetModel() );
     uno::Any aSourceAny(uno::makeAny(xSource));
     if (rLib->hasByName(sName))
         rLib->replaceByName(sName, aSourceAny);
     else
         rLib->insertByName(sName, aSourceAny);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+		try
+		{
+        	xDialogPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+		}
+		catch( uno::Exception& )
+		{
+			OSL_TRACE("OCX_UserForm::Import, Image fails to import");
+		}
+    }
     return sal_True;
 }
 
@@ -4761,11 +4935,14 @@ sal_Bool OCX_CheckBox::Import(com::sun::star::uno::Reference<
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-    if (pValue && !bSetInDialog)
+	if (pValue)
     {
         INT16 nTmp=pValue[0]-0x30;
         aTmp <<= nTmp;
-        rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		if ( !bSetInDialog )
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
     }
 
     if (pCaption)
@@ -5175,12 +5352,6 @@ sal_Bool OCX_TabStrip::ReadFontData(SotStorageStream *pS)
 
 sal_Bool OCX_Image::Read(SotStorageStream *pS)
 {
-    if ( !bSetInDialog )
-    {
-        // preserve the present behavior at the moment.
-        // only import image control for UserForms
-        return sal_False;
-    }
     ULONG nStart = pS->Tell();
     *pS >> nIdentifier;
     DBG_ASSERT(nStandardId==nIdentifier,
@@ -5271,16 +5442,14 @@ sal_Bool OCX_Image::Read(SotStorageStream *pS)
 
         long imagePos = pS->Tell();
 
-        pS->Seek( imagePos );
-
-        sImageUrl =  C2U("vnd.sun.star.expand:${$BRAND_BASE_DIR/program/") + C2U( SAL_CONFIGFILE( "bootstrap" ) ) + C2U("::UserInstallation}/user/temp/") + sName;
-
-        sal_uInt8* pImage = new sal_uInt8[ nImageLen ];
-        pS->Read(pImage, nImageLen);
-        bool result = storePictureInFileSystem( sImageUrl, pImage, nImageLen );
-        OUString pictName = sImageUrl.copy( sImageUrl.lastIndexOf('/') + 1 );
-        result = storePictureInDoc( pDocSh, pictName, pImage, nImageLen );
-        delete [] pImage;
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nImageLen );
     }
     return sal_True;
 }
@@ -5448,7 +5617,7 @@ OCX_SpinButton::OCX_SpinButton() :
     mbPropThumb( true )
 {
     msFormType = C2U("com.sun.star.form.component.SpinButton");
-    msDialogType = C2U("com.sun.star.awt.UnoControlSpinButtonModel");
+    msDialogType = C2U("com.sun.star.form.component.SpinButton");
     mnBackColor = 0x8000000F;
     mnForeColor = 0x80000012;
 }
@@ -5485,8 +5654,8 @@ sal_Bool OCX_SpinButton::Read( SvStorageStream *pS )
     if( mnBlockFlags & 0x00000080 )     rStrm >> mnValue;
     if( mnBlockFlags & 0x00000100 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00000200 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000400 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000800 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000400 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000800 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00001000 )     rStrm >> mnPageStep;
     if( mnBlockFlags & 0x00002000 )     rStrm >> mnOrient;
     if( mnBlockFlags & 0x00004000 )
@@ -5571,6 +5740,9 @@ sal_Bool OCX_SpinButton::Import(com::sun::star::uno::Reference<
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
@@ -5738,7 +5910,7 @@ OCX_ScrollBar::OCX_ScrollBar()
     sName = OUString( RTL_CONSTASCII_USTRINGPARAM( "ScrollBar" ) );
     mnMax = 32767;
     msFormType = C2U("com.sun.star.form.component.ScrollBar");
-    msDialogType = C2U("com.sun.star.awt.UnoControlScrollBarModel");
+    msDialogType = C2U("com.sun.star.form.component.ScrollBar");
 
 }
 
@@ -5804,6 +5976,9 @@ sal_Bool OCX_ScrollBar::Import(com::sun::star::uno::Reference<
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
diff --git filter/source/msfilter/msoleexp.cxx filter/source/msfilter/msoleexp.cxx
index e782c5f..76220ee 100644
--- filter/source/msfilter/msoleexp.cxx
+++ filter/source/msfilter/msoleexp.cxx
@@ -219,7 +219,12 @@ void SvxMSExportOLEObjects::ExportOLEObject( svt::EmbeddedObjectRef& rObj, SvSto
             aSeq[1].Name = ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "FilterName" ) );
             aSeq[1].Value <<= ::rtl::OUString( pExpFilter->GetName() );
             uno::Reference < frame::XStorable > xStor( rObj->getComponent(), uno::UNO_QUERY );
+        try
+        {
             xStor->storeToURL( ::rtl::OUString::createFromAscii( "private:stream" ), aSeq );
+        }
+        catch( uno::Exception& ) {} // #TODO really handle exceptions - interactionalhandler etc. ? 
+        
             SotStorageRef xOLEStor = new SotStorage( pStream, TRUE );
             xOLEStor->CopyTo( &rDestStg );
             rDestStg.Commit();
diff --git filter/source/msfilter/mstoolbar.cxx filter/source/msfilter/mstoolbar.cxx
new file mode 100644
index 0000000..eead43c
--- /dev/null
+++ filter/source/msfilter/mstoolbar.cxx
@@ -0,0 +1,817 @@
+#include <filter/msfilter/mstoolbar.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <fstream>
+#include <vcl/graph.hxx>
+#include <vcl/bitmapex.hxx>
+#include <vcl/image.hxx>
+#include <map>
+#include <sfx2/objsh.hxx>
+#include <basic/basmgr.hxx>
+#include <svtools/filterutils.hxx>
+#include <boost/scoped_array.hpp>
+#include <filter/msfilter/msvbahelper.hxx>
+#include <svtools/miscopt.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/window.hxx>
+
+using namespace com::sun::star;
+
+int TBBase::nIndent = 0;
+
+void CustomToolBarImportHelper::showToolbar( const rtl::OUString& rName )
+{
+    try
+    {
+        uno::Reference< frame::XController > xCntrller( mrDocSh.GetModel()->getCurrentController(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xCntrller->getFrame(), uno::UNO_QUERY_THROW );
+        uno::Reference< frame::XLayoutManager > xLayoutMgr( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LayoutManager") ) ), uno::UNO_QUERY_THROW );
+        xLayoutMgr->showElement( rName );
+    }
+    catch( uno::Exception& ) {}
+}
+
+void CustomToolBarImportHelper::ScaleImage( uno::Reference< graphic::XGraphic >& xGraphic, long nNewSize )
+{
+    Graphic aGraphic( xGraphic );
+    Size aSize = aGraphic.GetSizePixel();
+    if ( aSize.Height() && ( aSize.Height() == aSize.Width() ) )
+    {
+        Image aImage( xGraphic );
+        if ( aSize.Height() != nNewSize )
+        {
+            BitmapEx aBitmap = aImage.GetBitmapEx();
+            BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, nNewSize );
+            aImage = Image( aBitmapex);
+            xGraphic = aImage.GetXGraphic();
+        }
+    } 
+}
+
+void CustomToolBarImportHelper::applyIcons()
+{
+    for ( std::vector< iconcontrolitem >::iterator it = iconcommands.begin(); it != iconcommands.end(); ++it )
+    {
+        uno::Sequence< rtl::OUString > commands(1);
+        commands[ 0 ] = it->sCommand;
+        uno::Sequence< uno::Reference< graphic::XGraphic > > images(1);
+        images[ 0 ] = it->image;
+       
+        OSL_TRACE("About to applyIcons for command %s, have image ? %s", rtl::OUStringToOString( commands[ 0 ], RTL_TEXTENCODING_UTF8 ).getStr(), images[ 0 ].is() ? "yes" : "no" );
+        uno::Reference< ui::XImageManager > xImageManager( getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        sal_uInt16 nColor = ui::ImageType::COLOR_NORMAL; 
+
+        Window* topwin = Application::GetActiveTopWindow();
+	if ( topwin != NULL && topwin->GetDisplayBackground().GetColor().IsDark() )
+            nColor = css::ui::ImageType::COLOR_HIGHCONTRAST;
+
+        ScaleImage( images[ 0 ], 16 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_DEFAULT | nColor,  commands, images );
+        ScaleImage( images[ 0 ], 26 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_LARGE | nColor,  commands, images );
+    }
+}
+
+void CustomToolBarImportHelper::addIcon( const uno::Reference< graphic::XGraphic >& xImage, const rtl::OUString& sString )
+{
+    iconcontrolitem item;
+    item.sCommand = sString;
+    item.image = xImage;
+    iconcommands.push_back( item );
+}
+
+CustomToolBarImportHelper::CustomToolBarImportHelper( SfxObjectShell& rDocShell,  const css::uno::Reference< css::ui::XUIConfigurationManager>& rxAppCfgMgr ) : mrDocSh( rDocShell ) 
+{
+    m_xCfgSupp.set( mrDocSh.GetModel(), uno::UNO_QUERY_THROW );
+    m_xAppCfgMgr.set( rxAppCfgMgr, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getCfgManager()
+{
+    return m_xCfgSupp->getUIConfigurationManager();
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getAppCfgManager()
+{
+    return m_xAppCfgMgr;
+}
+
+uno::Any 
+CustomToolBarImportHelper::createCommandFromMacro( const rtl::OUString& sCmd )
+{
+//"vnd.sun.star.script:Standard.Module1.Main?language=Basic&location=document"    
+    static rtl::OUString scheme = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document");
+    // create script url
+    rtl::OUString scriptURL = scheme + sCmd + part2;
+    return uno::makeAny( scriptURL );
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOCommandToOOCommand( sal_Int16 msoCmd )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOCommandToOOCommand( msoCmd );
+    return result;
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOTCIDToOOCommand( sal_Int16 msoTCID )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOTCIDToOOCommand( msoTCID );
+    return result;
+}
+
+bool
+CustomToolBarImportHelper::createMenu( const rtl::OUString& rName, const uno::Reference< container::XIndexAccess >& xMenuDesc, bool bPersist )
+{
+    bool bRes = true;
+    try
+    {
+        uno::Reference< ui::XUIConfigurationManager > xCfgManager( getCfgManager() );
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        sMenuBar += rName;
+        uno::Reference< container::XIndexContainer > xPopup( xCfgManager->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xPopup, uno::UNO_QUERY_THROW ); 
+        // set name for menubar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( rName ) );
+        if ( xPopup.is() )
+        {
+            uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+            aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + rName );
+            aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+            aPopupMenu[1].Value <<= rName;
+            aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+            aPopupMenu[2].Value = uno::makeAny( xMenuDesc );
+            aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+            aPopupMenu[3].Value <<= sal_Int32( 0 );
+            
+            xPopup->insertByIndex( xPopup->getCount(), uno::makeAny( aPopupMenu ) );
+            if ( bPersist )
+            {
+                xCfgManager->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xPopup, uno::UNO_QUERY ) );
+                uno::Reference< ui::XUIConfigurationPersistence > xPersistence( xCfgManager, uno::UNO_QUERY_THROW );
+                xPersistence->store();
+            }
+        }
+    }
+    catch( uno::Exception& )
+    {
+        bRes = false;
+    }
+    return bRes;
+}
+
+void
+TBBase::indent_printf( FILE* fp, const char* format, ... )
+{
+   va_list ap;
+   va_start ( ap, format );
+
+   // indent nIndent spaces
+   for ( int i=0; i<nIndent; ++i)
+      fprintf(fp," ");
+   // append the rest of the message
+   vfprintf( fp, format, ap );
+   va_end( ap );
+}
+
+rtl::OUString TBBase::readUnicodeString( SvStream* pS, sal_Int32 nChars )
+{
+    sal_Int32 nBufSize = nChars * 2;
+    boost::scoped_array< sal_uInt8 > pArray( new sal_uInt8[ nBufSize ] );
+    pS->Read( pArray.get(), nBufSize );
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray(  reinterpret_cast< const char* >( pArray.get() ), nBufSize );
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+}
+
+bool TBCHeader::Read( SvStream* pS )
+{
+    OSL_TRACE("TBCHeader::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width.reset( new sal_uInt16 );
+        height.reset( new sal_uInt16 );
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCHeader -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  bFlagsTCR 0x%x\n", bFlagsTCR );
+    indent_printf(fp,"  tct 0x%x\n", tct );
+    indent_printf(fp,"  tcid 0x%x\n", tcid );
+    indent_printf(fp,"  tbct 0x%x\n", static_cast< unsigned int >( tbct ));
+    indent_printf(fp,"  bPriority 0x%x\n", bPriority );
+    if ( width.get() )
+        indent_printf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height.get() )
+        indent_printf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+TBCData::TBCData( const TBCHeader& Header ) : rHeader( Header )
+{
+}
+
+bool TBCData::Read(SvStream *pS)
+{
+    OSL_TRACE("TBCData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    switch ( rHeader.getTct() )
+    {
+        case 0x01: // (Button control)
+        case 0x10: // (ExpandingGrid control)
+            controlSpecificInfo.reset( new TBCBSpecific() );
+            break;
+        case 0x0A: // (Popup control)
+        case 0x0C: // (ButtonPopup control)
+        case 0x0D: // (SplitButtonPopup control)
+        case 0x0E: // (SplitButtonMRUPopup control)
+            controlSpecificInfo.reset( new TBCMenuSpecific() );
+            break;
+        case 0x02: // (Edit control)
+        case 0x04: // (ComboBox control)
+        case 0x14: // (GraphicCombo control)
+        case 0x03: // (DropDown control)
+        case 0x06: // (SplitDropDown control)
+        case 0x09: // (GraphicDropDown control)
+            controlSpecificInfo.reset( new TBCComboDropdownSpecific( rHeader ) );
+            break;
+        default:
+            break;
+    }
+    if ( controlSpecificInfo.get() )
+        return controlSpecificInfo->Read( pS );
+    //#FIXME I need to be able to handle different controlSpecificInfo types.
+    return true;
+}
+
+TBCMenuSpecific* TBCData::getMenuSpecific()
+{
+    TBCMenuSpecific* pMenu = dynamic_cast< TBCMenuSpecific* >( controlSpecificInfo.get() );
+    return pMenu;
+}
+bool TBCData::ImportToolBarControl( CustomToolBarImportHelper& helper, std::vector< css::beans::PropertyValue >& props, bool& bBeginGroup, bool bIsMenuBar )
+{
+    sal_uInt16  nStyle = 0;
+    bBeginGroup = rHeader.isBeginGroup();
+    controlGeneralInfo.ImportToolBarControlData( helper, props );
+    beans::PropertyValue aProp;
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Visible") ) ;
+    aProp.Value = uno::makeAny( rHeader.isVisible() ); // where is the visible attribute stored
+    props.push_back( aProp );
+    if ( rHeader.getTct() == 0x01
+    || rHeader.getTct() == 0x10 )
+    {
+        TBCBSpecific* pSpecificInfo = dynamic_cast< TBCBSpecific* >( controlSpecificInfo.get() );
+        if ( pSpecificInfo )
+        {
+            // if we have a icon then lets  set it for the command 
+            rtl::OUString sCommand;
+            for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it )
+            {
+                if ( it->Name.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ) )
+                    it->Value >>= sCommand;
+            }
+            if ( TBCBitMap* pIcon = pSpecificInfo->getIcon() )
+            {
+                // Without a command openoffice won't display the icon
+                if ( sCommand.getLength() )
+                {    
+                    BitmapEx aBitEx( pIcon->getBitMap() );
+                    if ( pSpecificInfo->getIconMask() )
+                         // according to the spec:
+                         // "the iconMask is white in all the areas in which the icon is
+                         // displayed as transparent and is black in all other areas."
+                         aBitEx = BitmapEx( aBitEx.GetBitmap(), pSpecificInfo->getIconMask()->getBitMap().CreateMask( Color( COL_WHITE ) ) );
+    
+                    Graphic aGraphic( aBitEx );
+                    helper.addIcon( aGraphic.GetXGraphic(), sCommand );
+                }
+            }
+            else if ( pSpecificInfo->getBtnFace() )
+            {
+               
+                rtl::OUString sBuiltInCmd = helper.MSOTCIDToOOCommand(  *pSpecificInfo->getBtnFace() );
+                if ( sBuiltInCmd.getLength() )
+                {
+                    uno::Sequence< rtl::OUString> sCmds(1);
+                    sCmds[ 0 ] = sBuiltInCmd;
+                    uno::Reference< ui::XImageManager > xImageManager( helper.getAppCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+                    // 0 = default image size
+                    uno::Sequence< uno::Reference< graphic::XGraphic > > sImages = xImageManager->getImages( 0, sCmds );
+                    if ( sImages.getLength() && sImages[0].is() )
+                        helper.addIcon( sImages[0], sCommand );
+                }
+            }
+        }
+    }
+    else if ( rHeader.getTct() == 0x0a )
+    {
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ;
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        
+        TBCMenuSpecific* pMenu = getMenuSpecific();
+        if ( pMenu )
+            aProp.Value = uno::makeAny( sMenuBar += pMenu->Name() ); // name of popup
+        nStyle |= ui::ItemStyle::DROP_DOWN;
+        props.push_back( aProp );
+    }
+
+    short icontext =  ( rHeader.getTbct() & 0x03 );
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Style") ) ;
+    if ( bIsMenuBar )
+    {
+        nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || icontext == 0x3 )
+            // Text And image
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    else 
+    {
+        if ( ( icontext & 0x02 ) == 0x02 )
+            nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || ( icontext & 0x03 ) == 0x03 )
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    aProp.Value <<= nStyle;
+    props.push_back( aProp );
+    return true; // just ignore
+}
+
+void TBCData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCData -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    //if ( rHeader.getTct() == 1 )
+    if ( controlSpecificInfo.get() )
+    {
+        indent_printf(fp,"  dumping controlSpecificInfo( TBCBSpecificInfo )\n");
+        controlSpecificInfo->Print( fp );
+    }
+}
+
+bool
+WString::Read( SvStream *pS )
+{
+    OSL_TRACE("WString::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCExtraInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCExtraInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    indent_printf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tbcu 0x%x\n", tbcu );
+    indent_printf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+rtl::OUString
+TBCExtraInfo::getOnAction()
+{
+    return wstrOnAction.getString();
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCGeneralInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    if ( ( bFlags & 0x1 ) && !customText.Read( pS ) )
+        return false;
+    if ( ( bFlags & 0x2 ) && ( !descriptionText.Read( pS ) ||  !tooltip.Read( pS ) ) )
+        return false;
+    if ( ( bFlags & 0x4 ) && !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCGeneralInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    indent_printf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( bFlags & 0x4 ) 
+        extraInfo.Print( fp );
+}
+
+bool 
+TBCGeneralInfo::ImportToolBarControlData( CustomToolBarImportHelper& helper, std::vector< beans::PropertyValue >& sControlData )
+{
+    if ( ( bFlags & 0x5 ) )
+    {
+        beans::PropertyValue aProp;
+        // probably access to the header would be a better test than seeing if there is an action, e.g.
+        // if ( rHeader.getTct() == 0x01 && rHeader.getTcID() == 0x01 ) // not defined, probably this is a command
+        if ( extraInfo.getOnAction().getLength() )
+        {
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            ooo::vba::VBAMacroResolvedInfo aMacroInf = ooo::vba::resolveVBAMacro( &helper.GetDocShell(), extraInfo.getOnAction(), true );
+            if ( aMacroInf.IsResolved() )
+                aProp.Value = helper.createCommandFromMacro( aMacroInf.ResolvedMacro() );
+            else
+                aProp.Value <<= rtl::OUString::createFromAscii("UnResolvedMacro[").concat( extraInfo.getOnAction() ).concat( rtl::OUString::createFromAscii("]") );
+            sControlData.push_back( aProp );
+        }
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+        aProp.Value = uno::makeAny( customText.getString().replace('&','~') );
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+        aProp.Value = uno::makeAny( ui::ItemType::DEFAULT ); 
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Tooltip") );
+        aProp.Value = uno::makeAny( tooltip.getString() ); 
+        sControlData.push_back( aProp );
+/*
+aToolbarItem(0).Name = "CommandURL" wstrOnAction
+aToolbarItem(0).Value = Command
+aToolbarItem(1).Name = "Label"      customText
+aToolbarItem(1).Value = Label
+aToolbarItem(2).Name = "Type"
+aToolbarItem(2).Value = 0
+aToolbarItem(3).Name = "Visible"
+aToolbarItem(3).Value = true        
+*/
+    }
+    return true;
+}
+
+TBCMenuSpecific::TBCMenuSpecific() : tbid( 0 )
+{
+}
+
+bool
+TBCMenuSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCMenuSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbid;
+    if ( tbid == 1 ) 
+    {
+        name.reset( new WString() );
+        return name->Read( pS );
+    }
+    return true;
+}
+
+void 
+TBCMenuSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCMenuSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  tbid 0x%x\n", static_cast< unsigned int >( tbid ) );
+    if ( tbid == 1 )
+        indent_printf( fp, "  name %s\n", rtl::OUStringToOString( name->getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+rtl::OUString TBCMenuSpecific::Name()
+{
+    rtl::OUString aName;
+    if ( name.get() )
+        aName = name->getString();
+    return aName;
+}
+TBCBSpecific::TBCBSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCBSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCBSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCBSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCBSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    indent_printf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent b;
+        indent_printf( fp, "  icon: \n");
+        icon->Print( fp ); // will dump size
+    }
+    bResult = ( iconMask.get() != NULL );
+    indent_printf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent c;
+        indent_printf( fp, "  icon mask: \n");
+        iconMask->Print( fp ); // will dump size
+    }
+    if ( iBtnFace.get() )
+    {
+        indent_printf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    }
+    bResult = ( wstrAcc.get() != NULL );
+    indent_printf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCBitMap* 
+TBCBSpecific::getIcon()
+{
+    return icon.get();
+}
+
+TBCBitMap* 
+TBCBSpecific::getIconMask()
+{
+    return iconMask.get();
+}
+
+TBCComboDropdownSpecific::TBCComboDropdownSpecific(const TBCHeader& header ) 
+{
+    if ( header.getTcID() == 0x01 )
+        data.reset( new TBCCDData() );
+}
+
+bool TBCComboDropdownSpecific::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    if ( data.get() )
+        return data->Read( pS );
+    return true;
+}
+
+void TBCComboDropdownSpecific::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCComboDropdownSpecific -- dump\n", nOffSet );
+    if ( data.get() )
+        data->Print( fp );
+    else
+        indent_printf(fp," no data " );
+}
+
+TBCCDData::TBCCDData() : cwstrItems( 0 )
+,iSel( 0 )
+,cLines( 0 )
+,dxWidth( 0 )
+{
+}
+
+TBCCDData::~TBCCDData()
+{
+}
+
+bool TBCCDData::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    *pS >> cwstrItems;
+    if ( cwstrItems )
+    {
+        for( sal_Int32 index=0; index < cwstrItems; ++index )
+        {
+            WString aString;
+            if ( !aString.Read( pS ) )
+                return false;
+            wstrList.push_back( aString );
+        } 
+    }
+    *pS >> cwstrMRU >> iSel >> cLines >> dxWidth;
+
+    return wstrEdit.Read( pS );
+}
+
+void TBCCDData::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCCDData -- dump\n", nOffSet );
+    indent_printf(fp,"  cwstrItems items in wstrList 0x%d\n", cwstrItems);
+    for ( sal_Int32 index=0; index < cwstrItems; ++index )
+    {
+        Indent b;
+        indent_printf(fp, "  wstrList[%d] %s", static_cast< int >( index ), rtl::OUStringToOString( wstrList[index].getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    indent_printf(fp,"  cwstrMRU num most recently used string 0x%d item\n", cwstrMRU);
+    indent_printf(fp,"  iSel index of selected item 0x%d item\n", iSel);
+    indent_printf(fp,"  cLines num of suggested lines to display 0x%d", cLines);
+    indent_printf(fp,"  dxWidth width in pixels 0x%d", dxWidth);
+    indent_printf(fp,"  wstrEdit %s", rtl::OUStringToOString( wstrEdit.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), size( 0 )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+}
+
+// #FIXME Const-ness
+Bitmap& 
+TBCBitMap::getBitMap()
+{
+    return mBitMap;
+}
+
+bool TBCBitMap::Read( SvStream* pS)
+{
+    OSL_TRACE("TBCBitMap::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    return mBitMap.Read( *pS, FALSE, TRUE );
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] TBCBitMap -- dump\n", nOffSet );
+    indent_printf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
+
+TB::TB() : bSignature(0x2),
+bVersion(0x1),
+cCL(0),
+ltbid( 0x1 ),
+ltbtr(0),
+cRowsDefault( 0 ),
+bFlags( 0 )
+{
+}
+
+bool TB::Read(SvStream *pS)
+{
+    OSL_TRACE("TB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    name.Read( pS );
+    return true;
+ 
+}
+
+bool TB::IsEnabled()
+{
+    return ( bFlags & 0x01 ) != 0x01;
+}
+
+bool TB::NeedsPositioning()
+{
+    return ( bFlags & 0x10 ) == 0x10;
+}
+
+void TB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TB -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  cCL 0x%x\n", cCL );
+    indent_printf(fp,"  ltbid 0x%x\n", ltbid );
+    indent_printf(fp,"  ltbtr 0x%x\n", ltbtr );
+    indent_printf(fp,"  cRowsDefault 0x%x\n", cRowsDefault );
+    indent_printf(fp,"  bFlags 0x%x\n", bFlags );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBVisualData::TBVisualData() : tbds(0), tbv(0), tbdsDock(0), iRow(0)
+{
+}
+
+bool TBVisualData::Read( SvStream* pS )
+{
+    OSL_TRACE("TBVisualData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbds >> tbv >> tbdsDock >> iRow;
+    rcDock.Read( pS );
+    rcFloat.Read( pS );
+    return true;
+}
+
+void SRECT::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "  left 0x%x\n", left);
+    indent_printf( fp, "  top 0x%x\n", top);
+    indent_printf( fp, "  right 0x%x\n", right);
+    indent_printf( fp, "  bottom 0x%x\n", bottom);
+}
+
+void TBVisualData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBVisualData -- dump\n", nOffSet );
+    indent_printf( fp, "  tbds 0x%x\n", tbds);
+    indent_printf( fp, "  tbv  0x%x\n", tbv);
+    indent_printf( fp, "  tbdsDoc  0x%x\n", tbdsDock);
+    indent_printf( fp, "  iRow  0x%x\n", iRow);
+    rcDock.Print( fp );
+    rcFloat.Print( fp );
+}
+
diff --git filter/source/msfilter/msvbasic.cxx filter/source/msfilter/msvbasic.cxx
index 33a76ac..bcd021a 100644
--- filter/source/msfilter/msvbasic.cxx
+++ filter/source/msfilter/msvbasic.cxx
@@ -37,11 +37,804 @@
 #include <osl/endian.h>
 #include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
 #include "msvbasic.hxx"
+#include <memory>
+#include <rtl/ustrbuf.hxx>
+#include <boost/shared_ptr.hpp>
+#include <boost/scoped_array.hpp>
+#include <boost/shared_array.hpp>
+#include <svtools/filterutils.hxx>
 
 #include <com/sun/star/script/ModuleType.hpp>
+#include <fstream>
 
 using namespace ::com::sun::star::script;
 
+namespace MSLZSS {
+
+static unsigned int getShift( sal_uInt32 nPos )
+{
+    if (nPos <= 0x80) {
+        if (nPos <= 0x20)
+            return (nPos <= 0x10) ? 12 : 11;
+        else
+            return (nPos <= 0x40) ? 10 : 9;
+    } else {
+    if (nPos <= 0x200)
+        return (nPos <= 0x100) ? 8 : 7;
+    else if (nPos <= 0x800)
+        return (nPos <= 0x400) ? 6 : 5;
+    else
+        return 4;
+    }
+}
+
+SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL )
+{
+    SvMemoryStream *pResult;
+    const sal_Int32 nWINDOWLEN = 4096;
+    pResult = new SvMemoryStream();
+
+    sal_uInt8 nLeadbyte;
+    unsigned int nPos = 0;
+    int nLen, nDistance, nShift, nClean=1;
+    sal_uInt8 aHistory[ nWINDOWLEN ];
+
+    pStream->Seek( nOffset + 3 );
+
+    while( pStream->Read( &nLeadbyte, 1 ) )
+    {
+        for(int nMask=0x01; nMask < 0x100; nMask = nMask<<1)
+        {
+            // we see if the leadbyte has flagged this location as a dataunit
+            // which is actually a token which must be looked up in the history
+            if( nLeadbyte & nMask )
+            {
+                sal_uInt16 nToken;
+            
+                *pStream >> nToken;
+    
+                if (nClean == 0)
+                    nClean=1;
+    
+                //For some reason the division of the token into the length
+                //field of the data to be inserted, and the distance back into
+                //the history differs depending on how full the history is
+                nShift = getShift( nPos % nWINDOWLEN );
+        
+                nLen = (nToken & ((1<<nShift) - 1)) + 3;
+                nDistance = nToken >> nShift;
+        
+                //read the len of data from the history, wrapping around the
+                //nWINDOWLEN boundary if necessary data read from the history
+                //is also copied into the recent part of the history as well.
+                for (int i = 0; i < nLen; i++)
+                {
+                    unsigned char c;
+                    c = aHistory[(nPos-nDistance-1) % nWINDOWLEN];
+                    aHistory[nPos % nWINDOWLEN] = c;
+                    nPos++;
+                }
+            }
+            else
+            {
+                // special boundary case code, not guarantueed to be correct
+                // seems to work though, there is something wrong with the
+                // compression scheme (or maybe a feature) where when the data
+                // ends on a nWINDOWLEN boundary and the excess bytes in the 8
+                // dataunit list are discarded, and not interpreted as tokens
+                // or normal data.
+                if ((nPos != 0) && ((nPos % nWINDOWLEN) == 0) && (nClean))
+                {
+                    pStream->SeekRel(2);
+                    nClean=0;
+                    pResult->Write( aHistory, nWINDOWLEN );
+                    break;
+                }
+                //This is the normal case for when the data unit is not a
+                //token to be looked up, but instead some normal data which
+                //can be output, and placed in the history.
+                if (pStream->Read(&aHistory[nPos % nWINDOWLEN],1))
+                    nPos++;
+                    
+                if (nClean == 0)
+                    nClean=1;
+            }
+        }
+    }
+    if (nPos % nWINDOWLEN)
+        pResult->Write( aHistory, nPos % nWINDOWLEN );
+    pResult->Flush();
+
+    if( pCompressedLength )
+        *pCompressedLength = nPos;
+    
+    if( pLength )
+        *pLength = pResult->Tell();
+
+    pResult->Seek( 0 );
+
+    return pResult;
+} 
+
+} //MSZSS
+
+// also _VBA_PROJECT_VDPI can be used to create a usable 
+// ( and much smaller ) "_VBA_PROJECT" stream
+
+// _VBA_PROJECT Stream Version Dependant Project Information
+// _VBA_PROJECT Stream Version Dependant Project Information
+
+class _VBA_PROJECT_VDPI
+{
+public:
+sal_Int16 Reserved1;
+sal_Int16 Version;
+sal_Int8 Reserved2;
+sal_Int16 Reserved3;
+boost::scoped_array< sal_uInt8 > PerformanceCache;
+sal_Int32 PerformanceCacheSize;
+_VBA_PROJECT_VDPI(): Reserved1( 0x61CC), Version( 0xFFFF ), Reserved2(0x0), Reserved3(0x0), PerformanceCacheSize(0) {}
+~_VBA_PROJECT_VDPI()
+{
+    PerformanceCacheSize = 0;
+}
+void read(){}
+void write( SvStream* pStream )
+{
+    *pStream << Reserved1 << Version << Reserved2 << Reserved3;
+    if ( PerformanceCacheSize )
+    {
+        PerformanceCache.reset( new sal_uInt8[ PerformanceCacheSize ] );
+        pStream->Read( PerformanceCache.get(), PerformanceCacheSize );
+    }
+}
+};
+
+class ProjectSysKindRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 SysKind;
+ProjectSysKindRecord(): Id(0x1), Size(0x4), SysKind( 0x1 ) {}
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> Size >> SysKind;
+}
+};
+
+class ProjectLcidRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 Lcid;
+
+ProjectLcidRecord() : Id( 0x2 ), Size( 0x4 ), Lcid( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> Lcid;
+}
+};
+
+class ProjectLcidInvokeRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 LcidInvoke;
+public:
+ProjectLcidInvokeRecord() : Id( 0x14 ), Size( 0x4 ), LcidInvoke( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidInvokeRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> LcidInvoke;
+}
+};
+
+class ProjectCodePageRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int16 CodePage;
+public:
+// #FIXME get a better default for the CodePage
+ProjectCodePageRecord() : Id( 0x03 ), Size( 0x2 ), CodePage( 0x0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectCodePageRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> CodePage;
+}
+};
+class ProjectNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfProjectName;
+rtl::OUString ProjectName;
+ProjectNameRecord() : Id( 0x04 ), SizeOfProjectName( 0x0 ){}
+~ProjectNameRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectNameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfProjectName;
+
+    if ( SizeOfProjectName ) 
+    {
+        boost::scoped_array< sal_uInt8 > pProjectName( new sal_uInt8[ SizeOfProjectName ] );
+        OSL_TRACE("ProjectNameRecord about to read name from [0x%x], size %d", pStream->Tell(), SizeOfProjectName );
+        pStream->Read( pProjectName.get(), SizeOfProjectName );
+        ProjectName = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pProjectName.get() ), SizeOfProjectName );
+    }
+}
+};
+
+class ProjectDocStringRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfDocString;
+sal_Int16 Reserved;
+sal_Int32 SizeOfDocStringUnicode;
+rtl::OUString DocString;
+rtl::OUString DocStringUnicode; 
+
+ProjectDocStringRecord() : Id( 0x5 ), SizeOfDocString( 0x0 ), Reserved( 0x0 ), SizeOfDocStringUnicode( 0 ){}
+
+~ProjectDocStringRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectDocStringRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfDocString;
+
+
+    boost::scoped_array< sal_uInt8 > pDocString( new sal_uInt8[ SizeOfDocString ] );
+    pStream->Read( pDocString.get(), SizeOfDocString );
+ 
+    DocString = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pDocString.get() ), SizeOfDocString );
+
+    *pStream >> Reserved >> SizeOfDocStringUnicode;
+
+    boost::scoped_array< sal_uInt8 > pDocStringUnicode( new sal_uInt8[ SizeOfDocStringUnicode ] );
+
+    pStream->Read( pDocStringUnicode.get(), SizeOfDocStringUnicode );
+    DocStringUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pDocStringUnicode.get() ), SizeOfDocString );
+
+}
+
+};
+
+class ProjectHelpFilePath
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfHelpFile1;
+boost::scoped_array< sal_uInt8 > HelpFile1;
+sal_Int16 Reserved;
+sal_Int32 SizeOfHelpFile2;
+boost::scoped_array< sal_uInt8 > HelpFile2;
+
+ProjectHelpFilePath() : Id( 0x06 ), SizeOfHelpFile1(0), Reserved(0x0), SizeOfHelpFile2(0) {}
+~ProjectHelpFilePath()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectHelpFilePath [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfHelpFile1;
+
+    HelpFile1.reset( new sal_uInt8[ SizeOfHelpFile1 ] );
+    pStream->Read( HelpFile1.get(), SizeOfHelpFile1 );
+
+    *pStream >> Reserved >> SizeOfHelpFile2;
+
+    HelpFile2.reset( new sal_uInt8[ SizeOfHelpFile2 ] );
+    pStream->Read( HelpFile2.get(), SizeOfHelpFile2 );
+  
+}
+};
+
+class ProjectHelpContextRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;    
+sal_Int32 HelpContext;    
+
+ProjectHelpContextRecord() : Id( 0x7 ), Size( 0x4 ), HelpContext( 0 ) {}
+void read( SvStream* pStream )
+{
+    
+   OSL_TRACE("ProjectHelpContextRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> Size >> HelpContext;
+}
+
+};
+
+class ProjectLibFlagsRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 ProjectLibFlags;
+
+public:
+ProjectLibFlagsRecord() : Id( 0x8 ), Size( 0x4 ), ProjectLibFlags( 0x0 ) {}
+void read( SvStream* pStream ) 
+{
+    OSL_TRACE("ProjectLibFlagsRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> ProjectLibFlags;
+}
+};
+
+class ProjectVersionRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Reserved;
+sal_Int32 VersionMajor;
+sal_Int16 VersionMinor;
+ProjectVersionRecord() : Id( 0x9 ), Reserved( 0x4 ), VersionMajor( 0x1 ), VersionMinor( 0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectVersionRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Reserved >> VersionMajor >> VersionMinor;
+}
+};
+
+class ProjectConstantsRecord
+{
+sal_Int16 Id;
+sal_Int32 SizeOfConstants;
+boost::scoped_array< sal_uInt8 > Constants;
+sal_Int16 Reserved;
+sal_Int32 SizeOfConstantsUnicode;
+boost::scoped_array< sal_uInt8 > ConstantsUnicode;
+public:
+ProjectConstantsRecord() : Id( 0xC ), SizeOfConstants( 0 ), Constants( 0 ), Reserved( 0x3C ), SizeOfConstantsUnicode( 0 ), ConstantsUnicode(0) {}
+
+~ProjectConstantsRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectConstantsRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> SizeOfConstants;
+    Constants.reset( new sal_uInt8[ SizeOfConstants ] );
+
+    pStream->Read( Constants.get(), SizeOfConstants );
+
+    *pStream >> Reserved;
+
+    *pStream >> SizeOfConstantsUnicode;
+
+    ConstantsUnicode.reset( new sal_uInt8[ SizeOfConstantsUnicode ] );
+    pStream->Read( ConstantsUnicode.get(), SizeOfConstantsUnicode );
+}
+
+};
+
+class ReferenceNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfName;
+rtl::OUString Name;
+sal_Int16 Reserved;
+sal_Int32 SizeOfNameUnicode;
+rtl::OUString NameUnicode;
+
+ReferenceNameRecord() : Id( 0x16 ), SizeOfName( 0 ), Reserved( 0x3E ), SizeOfNameUnicode( 0 ){}
+~ReferenceNameRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("NameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfName;
+ 
+    boost::scoped_array< sal_uInt8 > pName( new sal_uInt8[ SizeOfName ] );
+
+    pStream->Read( pName.get(), SizeOfName );
+    Name = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pName.get() ), SizeOfName );
+
+    *pStream >> Reserved >> SizeOfNameUnicode;
+
+    boost::scoped_array< sal_uInt8 > pNameUnicode( new sal_uInt8[ SizeOfNameUnicode ] );
+    pStream->Read( pNameUnicode.get(), SizeOfNameUnicode );
+    NameUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pNameUnicode.get() ), SizeOfName );
+}
+
+};
+
+// Baseclass for ReferenceControlRecord, ReferenceRegisteredRecord, ReferenceProjectRecord
+class DirDumper; 
+
+class BaseReferenceRecord 
+{
+public:
+virtual ~BaseReferenceRecord(){}
+virtual bool read( SvStream* pStream ) = 0;
+virtual void import( VBA_Impl& ){}
+};
+
+
+class ReferenceProjectRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibidAbsolute;
+    sal_uInt32 SizeOfLibidRelative; 
+    sal_uInt32 MajorVersion;
+    sal_uInt16 MinorVersion;
+    rtl::OUString AbsoluteLibid; 
+    rtl::OUString RelativeLibid; 
+
+    virtual bool read( SvStream* pStream );
+    virtual void import( VBA_Impl& rDir );
+    ReferenceProjectRecord();
+    ~ReferenceProjectRecord();
+};
+
+ReferenceProjectRecord::ReferenceProjectRecord() : Id( 0x000E ), Size( 0 ), SizeOfLibidAbsolute( 0 ), SizeOfLibidRelative( 0 ), MajorVersion( 0 ), MinorVersion( 0 )
+{ 
+}
+
+ReferenceProjectRecord::~ReferenceProjectRecord()
+{
+}
+
+bool ReferenceProjectRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceProjectRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibidAbsolute;
+
+    boost::scoped_array< sal_uInt8 > pLibidAbsolute( new sal_uInt8[ SizeOfLibidAbsolute ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidAbsolute at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidAbsolute.get(), SizeOfLibidAbsolute );
+
+    *pStream >> SizeOfLibidRelative; 
+
+    boost::scoped_array< sal_uInt8 > pLibidRelative( new sal_uInt8[ SizeOfLibidRelative ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidRelative at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidRelative.get(), SizeOfLibidRelative );
+
+    *pStream >> MajorVersion >> MinorVersion;
+
+    // array size is ORed with SVX_MSOCX_COMPRESSED to force processing of ascii bytes ( and not 
+    // 16 bit unicode )
+    // the offset of 3 is needed to skip the ProjectReference "*\" and project kind ( 0x4[1-4] ) info.
+
+    AbsoluteLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidAbsolute.get() + 3 ), (SizeOfLibidAbsolute - 3 ) );
+    RelativeLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidRelative.get() + 3 ), ( SizeOfLibidRelative -3 ) );
+
+    OSL_TRACE("ReferenceProjectRecord - absolute path %s", rtl::OUStringToOString( AbsoluteLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    OSL_TRACE("ReferenceProjectRecord - relative path %s", rtl::OUStringToOString( RelativeLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    return true;
+}
+
+void ReferenceProjectRecord::import( VBA_Impl& rDir )
+{
+    rDir.AddProjectReference( AbsoluteLibid );
+}
+
+class ReferenceRegisteredRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibid;
+    boost::scoped_array< sal_uInt8> pLibid;
+    sal_Int32 Reserved1;
+    sal_Int16 Reserved2;
+
+    ReferenceRegisteredRecord();
+    ~ReferenceRegisteredRecord();
+    bool read( SvStream* pStream );
+};
+
+ReferenceRegisteredRecord::ReferenceRegisteredRecord() : Id( 0x000D ), Size( 0 ), SizeOfLibid( 0 ), Reserved1( 0 ), Reserved2( 0 )
+{
+}
+
+ReferenceRegisteredRecord::~ReferenceRegisteredRecord()
+{
+}
+
+bool 
+ReferenceRegisteredRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRegisteredRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibid;
+    if ( SizeOfLibid )
+    {
+        pLibid.reset( new sal_uInt8[ SizeOfLibid] );
+        pStream->Read( pLibid.get(), SizeOfLibid );
+    }
+    *pStream >> Reserved1 >> Reserved2;
+    return true;
+}
+
+class ReferenceOriginalRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 SizeOfLibOriginal;
+    boost::scoped_array< sal_uInt8 > pLibidOriginal;
+
+
+ReferenceOriginalRecord() : Id( 0x033 ), SizeOfLibOriginal( 0 )
+{
+}
+
+~ReferenceOriginalRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> SizeOfLibOriginal;
+    if ( SizeOfLibOriginal )
+    {
+        pLibidOriginal.reset( new sal_uInt8[ SizeOfLibOriginal ] );
+        pStream->Read( pLibidOriginal.get(), SizeOfLibOriginal );
+    }
+}
+
+};
+
+class ReferenceControlRecord : public BaseReferenceRecord
+{
+public:
+std::auto_ptr< ReferenceOriginalRecord > OriginalRecord;
+sal_Int16 Id;
+sal_uInt32 SizeTwiddled;
+sal_uInt32 SizeOfLibidTwiddled;
+boost::shared_array< sal_uInt8 > LibidTwiddled;
+sal_uInt32 Reserved1;
+sal_uInt16 Reserved2;
+std::auto_ptr< ReferenceNameRecord > NameRecordExtended;// Optional
+sal_uInt16 Reserved3;
+sal_uInt32 SizeExtended;
+sal_uInt32 SizeOfLibidExtended;
+boost::shared_array< sal_uInt8 > LibidExtended;
+sal_uInt32 Reserved4;
+sal_uInt16 Reserved5;
+sal_uInt8  OriginalTypeLib[ 16 ];
+sal_uInt32 Cookie;
+
+ReferenceControlRecord() : Id( 0x2F ), SizeTwiddled( 0 ), SizeOfLibidTwiddled( 0 ), Reserved1( 0 ), Reserved2( 0 ), Reserved3( 0x30 ), SizeExtended( 0 ), SizeOfLibidExtended( 0 ), Reserved4( 0 ), Reserved5( 0 ), Cookie( 0 )
+{
+    for( int i = 0; i < 16; ++i )
+        OriginalTypeLib[ i ] = 0;
+}
+
+~ReferenceControlRecord()
+{
+}
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceControlRecord [0x%x]", pStream->Tell() ); 
+    long nPos = pStream->Tell();
+
+    *pStream >> Id;
+    pStream->Seek( nPos ); // point before the peeked Id
+    if ( Id == 0x33 ) // we have an OriginalRecord
+    {
+        OriginalRecord.reset( new ReferenceOriginalRecord() );
+        OriginalRecord->read( pStream );
+    }
+    *pStream >> Id >> SizeTwiddled >> SizeOfLibidTwiddled;
+
+    if ( SizeOfLibidTwiddled )
+    {
+        LibidTwiddled.reset( new sal_uInt8[ SizeOfLibidTwiddled ] );
+        pStream->Read( LibidTwiddled.get(),  SizeOfLibidTwiddled );
+    }
+
+    *pStream >> Reserved1 >> Reserved2;
+
+    nPos = pStream->Tell();
+    // peek at the id for optional NameRecord
+    sal_Int16 nTmpId;
+    *pStream >> nTmpId;
+    if ( nTmpId == 0x30 )
+    {
+        Reserved3 = 0x30;
+    }
+    else
+    {
+        pStream->Seek( nPos );
+        NameRecordExtended.reset( new ReferenceNameRecord() );
+        NameRecordExtended->read( pStream );
+        *pStream >> Reserved3;
+    }
+    *pStream >> SizeExtended >> SizeOfLibidExtended;
+
+    if ( SizeExtended )
+    {
+        LibidExtended.reset( new sal_uInt8[ SizeOfLibidExtended ] ); 
+        pStream->Read( LibidExtended.get(), SizeOfLibidExtended );
+    } 
+
+    *pStream >> Reserved4;
+    *pStream >> Reserved5;
+
+    pStream->Read( OriginalTypeLib, sizeof( OriginalTypeLib ) );
+    *pStream >> Cookie;
+    return true;
+}
+
+};
+
+class ReferenceRecord : public BaseReferenceRecord
+{
+public:
+// NameRecord is Optional
+std::auto_ptr< ReferenceNameRecord > NameRecord;
+std::auto_ptr< BaseReferenceRecord >  aReferenceRecord;
+
+ReferenceRecord(){}
+~ReferenceRecord()
+{
+}
+
+// false return would mean failed to read Record e.g. end of array encountered
+// Note: this read routine will make sure the stream is pointing to where it was the 
+// method was called ) 
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRecord [0x%x]", pStream->Tell() );
+    bool bRead = true;
+    long nStart = pStream->Tell();
+    long nPos = nStart;
+    // Peek at the ID 
+    sal_Int16 Id;
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+    if ( Id == 0x16 ) // Optional NameRecord
+    {
+        NameRecord.reset( new ReferenceNameRecord() );
+        NameRecord->read( pStream ); 
+    }
+    else if ( Id == 0x0f )
+    {
+        pStream->Seek( nStart );
+        bRead = false;
+        return bRead; // start of module, terminate read
+    }
+
+    nPos = pStream->Tell(); // mark position, peek at next Id
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+
+    switch( Id )
+    {
+        case 0x0D:
+            aReferenceRecord.reset( new ReferenceRegisteredRecord() );
+            break; 
+        case 0x0E:
+            aReferenceRecord.reset( new ReferenceProjectRecord() );
+            break; 
+        case 0x2F:
+        case 0x33:
+            aReferenceRecord.reset( new ReferenceControlRecord() );
+            break; 
+        default:
+            bRead = false;
+            OSL_TRACE("Big fat error, unknown ID 0x%x", Id);
+            break;
+    } 
+    if ( bRead )
+        aReferenceRecord->read( pStream );
+    return bRead;
+}
+
+void import( VBA_Impl& rVBA )
+{
+    if ( aReferenceRecord.get() )
+        aReferenceRecord->import( rVBA );
+}
+
+};
+
+class DirDumper
+{
+public:
+ProjectSysKindRecord mSysKindRec;
+ProjectLcidRecord mLcidRec;
+ProjectLcidInvokeRecord mLcidInvokeRec;
+ProjectCodePageRecord mCodePageRec;
+ProjectNameRecord mProjectNameRec;
+ProjectDocStringRecord mDocStringRec;
+ProjectHelpFilePath mHelpFileRec;
+ProjectHelpContextRecord mHelpContextRec;
+ProjectLibFlagsRecord mLibFlagsRec;
+ProjectVersionRecord mVersionRec;
+ProjectConstantsRecord mConstantsRecord;
+std::vector< ReferenceRecord* > ReferenceArray;
+
+DirDumper() {}
+~DirDumper() 
+{
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        delete *it;
+    
+}
+
+void read( SvStream* pStream )
+{
+    sal_Int32 nPos = pStream->Tell();
+#ifdef DEBUG
+    std::ofstream aDump("dir.dump");
+    while ( !pStream->IsEof() ) 
+    {
+        sal_Int8 aByte;
+        *pStream >> aByte;
+        aDump << aByte;
+    }
+    aDump.flush();
+#endif
+    pStream->Seek( nPos );
+    readProjectInformation( pStream );
+    readProjectReferenceInformation( pStream );
+}
+
+void readProjectReferenceInformation( SvStream* pStream )
+{
+    bool bKeepReading = true;
+    while( bKeepReading )
+    {
+        ReferenceRecord* pRef = new ReferenceRecord();
+        bKeepReading = pRef->read( pStream );
+        if ( bKeepReading ) 
+            ReferenceArray.push_back( pRef );
+    }
+}
+
+void readProjectInformation( SvStream* pStream )
+{
+    mSysKindRec.read( pStream );
+    mLcidRec.read( pStream ); 
+    mLcidInvokeRec.read( pStream );
+    mCodePageRec.read( pStream );
+    mProjectNameRec.read( pStream );
+    mDocStringRec.read( pStream );
+    mHelpFileRec.read( pStream );
+    mHelpContextRec.read( pStream );
+    mLibFlagsRec.read( pStream );
+    mVersionRec.read( pStream ); 
+    sal_Int32 nPos = pStream->Tell();
+    sal_uInt16 nTmp;
+    *pStream >> nTmp;
+    if ( nTmp == 0x0C )
+    {
+        pStream->Seek( nPos );
+        mConstantsRecord.read( pStream );
+    }
+    OSL_TRACE("After Information pos is 0x%x", pStream->Tell() );
+}
+
+void import( VBA_Impl& rVBA )
+{
+    // get project references
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        (*it)->import( rVBA );
+    rVBA.SetProjectName( mProjectNameRec.ProjectName );
+    
+}
+};
+
+
 /*
 A few urls which may in the future be of some use
 http://www.virusbtn.com/vb2000/Programme/papers/bontchev.pdf
@@ -154,7 +947,21 @@ int VBA_Impl::ReadVBAProject(const SvStorageRef &rxVBAStorage)
     xVBAProject = rxVBAStorage->OpenSotStream(
                     String( RTL_CONSTASCII_USTRINGPARAM( "_VBA_PROJECT" ) ),
                     STREAM_STD_READ | STREAM_NOCREATE );
-
+    // read Dir stream
+    SvStorageStreamRef xDir = rxVBAStorage->OpenSotStream(
+                    String( RTL_CONSTASCII_USTRINGPARAM( "dir" ) ),
+					STREAM_STD_READ | STREAM_NOCREATE );
+// disable read and import of Dir stream bits, e.g. project references and
+// project name for 3.1 ( a bit unstable yet )
+#if 1
+    // decompress the stream
+    std::auto_ptr< SvMemoryStream > xCmpDir;
+    xCmpDir.reset( MSLZSS::decompressAsStream( xDir, 0 ) );
+    // try to parse the dir stream
+    DirDumper dDump;
+    dDump.read( xCmpDir.get() );
+    dDump.import( *this );
+#endif
     if( !xVBAProject.Is() || SVSTREAM_OK != xVBAProject->GetError() )
     {
         DBG_WARNING("Not able to find vba project, cannot find macros");
@@ -415,6 +1222,7 @@ bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
     if( !xMacros.Is() || SVSTREAM_OK != xMacros->GetError() )
     {
         DBG_WARNING("No Macros Storage");
+		OSL_TRACE("No Macros Storage");
     }
     else
     {
@@ -424,6 +1232,7 @@ bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
         if( !xVBA.Is() || SVSTREAM_OK != xVBA->GetError() )
         {
             DBG_WARNING("No Visual Basic in Storage");
+			OSL_TRACE("No Visual Basic in Storage");
         }
         else
         {
@@ -438,6 +1247,7 @@ bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
          * ( value ) is either a Class Module, Form Module or a plain VB Module.        */
         SvStorageStreamRef xProject = xMacros->OpenSotStream(
             String( RTL_CONSTASCII_USTRINGPARAM( "PROJECT" ) ) );
+
         SvStorageStream* pStp = xProject;
         UniString tmp;
         static const String sThisDoc(   RTL_CONSTASCII_USTRINGPARAM( "ThisDocument" ) );
diff --git filter/source/msfilter/msvbasic.hxx filter/source/msfilter/msvbasic.hxx
index b163662..f35e3c8 100644
--- filter/source/msfilter/msvbasic.hxx
+++ filter/source/msfilter/msvbasic.hxx
@@ -36,6 +36,8 @@
 #include <tools/dynary.hxx>
 #include <vector>
 #include <map>
+#include <com/sun/star/script/ModuleType.hpp>
+using namespace ::com::sun::star::script::ModuleType;
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -86,8 +88,14 @@ public:
     //
     // #117718# member map of module names to types of module
     ModType GetModuleType( const UniString& rModuleName );
-    std::vector<String> maReferences;
+    rtl::OUString& ProjectName() { return msProjectName; }
+    void SetProjectName( const rtl::OUString& rPName ) { msProjectName = rPName; }
+    const std::vector<rtl::OUString>& ProjectReferences() { return maPrjReferences; }
+    void AddProjectReference( const rtl::OUString& rProject ) { maPrjReferences.push_back( rProject); }
+    SvStorage* GetStorage() { return xStor; }
 private:
+    std::vector<rtl::OUString> maReferences;
+    std::vector<rtl::OUString> maPrjReferences;
     struct VBAOffset_Impl
     {
         String sName;
@@ -113,6 +121,7 @@ private:
     int ReadVBAProject(const SvStorageRef &rxVBAStorage);
     int DecompressVBA(int index, SvStorageStreamRef &rxVBAStream);
     sal_uInt8 ReadPString(SvStorageStreamRef &xVBAProject, bool bIsUnicode);
+    rtl::OUString msProjectName;
 };
 
 #endif
diff --git filter/source/msfilter/svxmsbas.cxx filter/source/msfilter/svxmsbas.cxx
index fc1afa4..a123ada 100644
--- filter/source/msfilter/svxmsbas.cxx
+++ filter/source/msfilter/svxmsbas.cxx
@@ -65,26 +65,47 @@ using rtl::OUString;
 
 static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
 
+void SvxImportMSVBasic::extractAttribute( const String& rAttribute, const String& rModName )
+{
+    // format of the attribute we are interested in is
+    // Attribute VB_Control = "ControlName", intString, MSForms, ControlTypeAsString
+    // e.g.
+    // Attribute VB_Control = "CommandButton1, 201, 19, MSForms, CommandButton"
+    String sControlAttribute( RTL_CONSTASCII_USTRINGPARAM("Attribute VB_Control = \"") );
+    if ( rAttribute.Search( sControlAttribute ) !=  STRING_NOTFOUND )
+    {
+        String sRest = rAttribute.Copy( sControlAttribute.Len() );
+        xub_StrLen nPos = 0; 
+        String sCntrlName = sRest.GetToken( 0, ',', nPos );
+        
+        sal_Int32 nCntrlId = sRest.GetToken( 0, ',', nPos).ToInt32();
+        OSL_TRACE("In module %s, assiging %d controlname %s", 
+            rtl::OUStringToOString( rModName, RTL_TEXTENCODING_UTF8 ).getStr(), nCntrlId,
+            rtl::OUStringToOString( sCntrlName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        m_ModuleNameToObjIdHash[ rModName ][ nCntrlId ] =  sCntrlName;
+    }
+}
+
 int SvxImportMSVBasic::Import( const String& rStorageName,
-                                const String &rSubStorageName,
-                                BOOL bAsComment, BOOL bStripped )
+								const String &rSubStorageName,
+								BOOL bAsComment, BOOL bStripped )
 {
     std::vector< String > codeNames;
     return Import(  rStorageName, rSubStorageName, codeNames, bAsComment, bStripped );
 }
-
 int SvxImportMSVBasic::Import( const String& rStorageName,
                                 const String &rSubStorageName,
                                 const std::vector< String >& codeNames,
                                 BOOL bAsComment, BOOL bStripped )
 {
+        msProjectName = rtl::OUString();
     int nRet = 0;
-    if( bImport && ImportCode_Impl( rStorageName, rSubStorageName, codeNames,
+	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName, codeNames, 
                                     bAsComment, bStripped ))
         nRet |= 1;
 
     if (bImport)
-        ImportForms_Impl(rStorageName, rSubStorageName);
+        ImportForms_Impl(rStorageName, rSubStorageName, !bAsComment);
 
     if( bCopy && CopyStorage_Impl( rStorageName, rSubStorageName ))
         nRet |= 2;
@@ -93,9 +114,44 @@ int SvxImportMSVBasic::Import( const String& rStorageName,
 }
 
 bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
-    const String& rSubStorageName)
+    const String& rSubStorageName, BOOL bVBAMode )
 {
-    SvStorageRef xVBAStg(xRoot->OpenSotStorage(rStorageName,
+    BOOL bRet = FALSE;
+    // #FIXME VBA_Impl ( or some other new class ) should handle both userforms
+    // and code 
+	VBA_Impl aVBA( *xRoot, TRUE );
+    // This call is a waste we read the source ( again ) only to get the refereneces
+    // *AGAIN*, we really need to rewrite all of this
+    aVBA.Open( rStorageName, rSubStorageName ); 
+
+    bRet = ImportForms_Impl( aVBA, rStorageName, rSubStorageName, bVBAMode );
+	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+
+	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+    {
+       rtl::OUString sFileName = *it;
+#ifndef WIN 
+#ifdef DEBUG
+       // hacky test code to read referenced projects on linux
+       sal_Int32 nPos = (*it).lastIndexOf('\\');
+       sFileName = (*it).copy( nPos + 1 );
+       sFileName =  rtl::OUString::createFromAscii("~/Documents/") + sFileName;
+#endif
+#endif
+       SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+	   VBA_Impl refVBA( *rRoot, TRUE );        
+       refVBA.Open( rStorageName, rSubStorageName );
+       // The return from ImportForms doesn't indicate and error ( it could )
+       // but also it just means no userforms were imported
+       if ( ImportForms_Impl( refVBA, rStorageName, rSubStorageName, bVBAMode ) )
+           bRet = true; // mark that at least on userform was imported
+    }
+    return bRet;
+}
+
+bool SvxImportMSVBasic::ImportForms_Impl( VBA_Impl& rVBA, const String& rStorageName, const String& rSubStorageName, BOOL bVBAMode )
+{
+    SvStorageRef xVBAStg(rVBA.GetStorage()->OpenSotStorage(rStorageName,
         STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL));
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
@@ -128,6 +184,10 @@ bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
         DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
 
         String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
+        if (rVBA.ProjectName().getLength() )
+            aLibName = rVBA.ProjectName();
+        OSL_TRACE( "userformage lib name %s", rtl::OUStringToOString( aLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
         Reference<XNameContainer> xLib;
         if (xLibContainer.is())
         {
@@ -177,7 +237,17 @@ bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
                     xSF->createInstance(
                        OUString(RTL_CONSTASCII_USTRINGPARAM(
                            "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
-
+                // #FIXME HACK - mark the Model with the VBA mode
+                // In vba mode the imported userform uses 100th mm as units
+                // or geometry 
+                // In non vba mode MAP_APPFONT is used ( same as normal basic
+                // dialogs
+                if ( bVBAMode )
+                {
+                    Reference<XPropertySet> xDlgProps(xDialog, UNO_QUERY); 
+                    if ( xDlgProps.is() )
+                        xDlgProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ), uno::makeAny( sal_True ) );
+                }
                 OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
                 aForm.pDocSh = &rDocSh;
                 sal_Bool bOk = aForm.Read(xTypes);
@@ -246,8 +316,34 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 {
     BOOL bRet = FALSE;
     VBA_Impl aVBA( *xRoot, bAsComment );
+        
     if( aVBA.Open(rStorageName,rSubStorageName) )
     {
+        msProjectName = aVBA.ProjectName();
+
+        if ( msProjectName.getLength() )
+            rDocSh.GetBasicManager()->SetName( msProjectName ); // set name of Project
+
+        bRet = ImportCode_Impl( aVBA, codeNames, bAsComment, bStripped );
+    	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+    
+    	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+        {
+            rtl::OUString sFileName = *it;
+    		OSL_TRACE("referenced project %s ", rtl::OUStringToOString( sFileName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+    	    VBA_Impl refVBA( *rRoot, bAsComment );
+			std::vector< String > codeNamesNone;
+    	    if( refVBA.Open(rStorageName,rSubStorageName) && ImportCode_Impl( refVBA, codeNamesNone, bAsComment, bStripped ) )
+                bRet = TRUE; // mark that some code was imported
+        }
+    }
+    return bRet;
+}
+
+BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, const std::vector< String >& codeNames, BOOL bAsComment, BOOL bStripped )
+{
+	BOOL bRet = FALSE;
         SFX_APP()->EnterBasicCall();
         Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
         DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
@@ -268,6 +364,8 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
         UINT16 nStreamCount = aVBA.GetNoStreams();
         Reference<XNameContainer> xLib;
         String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        if ( aVBA.ProjectName().getLength() )
+            aLibName = aVBA.ProjectName();
         if( xLibContainer.is() && nStreamCount )
         {
             if( !xLibContainer->hasByName( aLibName ) )
@@ -416,7 +514,11 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
                             if( nEnd == STRING_NOTFOUND )
                                 pStr->Erase();
                             else
+                            {
+                                String sAttr= pStr->Copy( nBegin, (nEnd-nBegin)+1);
+                                extractAttribute( sAttr, sModule );
                                 pStr->Erase(nBegin, (nEnd-nBegin)+1);
+                            }
                         }
                     }
                     if( aDecompressed.Get(j)->Len() )
@@ -495,7 +597,6 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
             bRet = true;
         }
         SFX_APP()->LeaveBasicCall();
-    }
     return bRet;
 }
 
diff --git forms/source/component/FormComponent.cxx forms/source/component/FormComponent.cxx
index 2513636..55d19fb 100644
--- forms/source/component/FormComponent.cxx
+++ forms/source/component/FormComponent.cxx
@@ -2751,8 +2751,8 @@ void SAL_CALL OBoundControlModel::setValueBinding( const Reference< XValueBindin
     OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::setValueBinding: How did you reach this method?" );
         // the interface for this method should not have been exposed if we do not
         // support binding to external data
-
-    if ( !impl_approveValueBinding_nolock( _rxBinding ) )
+    // allow reset
+    if ( _rxBinding.is() && !impl_approveValueBinding_nolock( _rxBinding ) )
     {
         throw IncompatibleTypesException(
             FRM_RES_STRING( RID_STR_INCOMPATIBLE_TYPES ),
diff --git forms/source/component/GroupManager.cxx forms/source/component/GroupManager.cxx
index dfc679d..c4c8224 100644
--- forms/source/component/GroupManager.cxx
+++ forms/source/component/GroupManager.cxx
@@ -124,14 +124,13 @@ OGroupComp::OGroupComp(const Reference<XPropertySet>& rxSet, sal_Int32 nInsertPo
     ,m_xControlModel(rxSet,UNO_QUERY)
     ,m_nPos( nInsertPos )
     ,m_nTabIndex(0)
+    ,m_aName( OGroupManager::GetGroupName( rxSet ) )
 {
     if (m_xComponent.is())
     {
         if (hasProperty( PROPERTY_TABINDEX, m_xComponent ) )
             // Indices kleiner 0 werden wie 0 behandelt
             m_nTabIndex = Max(getINT16(m_xComponent->getPropertyValue( PROPERTY_TABINDEX )) , sal_Int16(0));
-
-        m_xComponent->getPropertyValue( PROPERTY_NAME ) >>= m_aName;
     }
 }
 
@@ -318,7 +317,8 @@ void OGroupManager::removeFromGroupMap(const ::rtl::OUString& _sGroupName,const
         aFind->second.RemoveComponent( _xSet );
 
         // Wenn Anzahl der Gruppenelemente == 1 ist, Gruppe deaktivieren
-        if ( aFind->second.Count() == 1 )
+		sal_Int32 nCount = aFind->second.Count();
+		if ( nCount == 1 || nCount == 0 )
         {
             OActiveGroups::iterator aActiveFind = ::std::find(
                 m_aActiveGroupMap.begin(),
@@ -329,7 +329,7 @@ void OGroupManager::removeFromGroupMap(const ::rtl::OUString& _sGroupName,const
             {
                 // the group is active. Deactivate it if the remaining component
                 // is *no* radio button
-                if ( !isRadioButton( aFind->second.GetObject( 0 ) ) )
+                if ( nCount == 0 || !isRadioButton( aFind->second.GetObject( 0 ) ) )
                     m_aActiveGroupMap.erase( aActiveFind );
             }
         }
@@ -338,6 +338,8 @@ void OGroupManager::removeFromGroupMap(const ::rtl::OUString& _sGroupName,const
 
     // Bei Component als PropertyChangeListener abmelden
     _xSet->removePropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, _xSet))
+		_xSet->removePropertyChangeListener( PROPERTY_GROUP_NAME, this );
     if (hasProperty(PROPERTY_TABINDEX, _xSet))
         _xSet->removePropertyChangeListener( PROPERTY_TABINDEX, this );
 }
@@ -348,10 +350,23 @@ void SAL_CALL OGroupManager::propertyChange(const PropertyChangeEvent& evt) thro
 
     // Component aus Gruppe entfernen
     ::rtl::OUString		sGroupName;
-    if (evt.PropertyName == PROPERTY_NAME)
+	if (hasProperty( PROPERTY_GROUP_NAME, xSet ))
+		xSet->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+	if (evt.PropertyName == PROPERTY_NAME) {
+		if (sGroupName.getLength() > 0)
+			return; // group hasn't changed; ignore this name change.
+		// no GroupName; use Name as GroupNme
         evt.OldValue >>= sGroupName;
+	}
+	else if (evt.PropertyName == PROPERTY_GROUP_NAME) {
+		evt.OldValue >>= sGroupName;
+		if (sGroupName.getLength() == 0) {
+			// No prior GroupName; fallback to Nme
+			xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		}
+	}
     else
-        xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		sGroupName = GetGroupName( xSet );
 
     removeFromGroupMap(sGroupName,xSet);
 
@@ -434,8 +449,7 @@ void OGroupManager::InsertElement( const Reference<XPropertySet>& xSet )
     m_pCompGroup->InsertComponent( xSet );
 
     // Component in Gruppe aufnehmen
-    ::rtl::OUString sGroupName;
-    xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString sGroupName( GetGroupName( xSet ) );
 
     OGroupArr::iterator aFind = m_aGroupArr.find(sGroupName);
 
@@ -473,6 +487,8 @@ void OGroupManager::InsertElement( const Reference<XPropertySet>& xSet )
 
     // Bei Component als PropertyChangeListener anmelden
     xSet->addPropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, xSet))
+		xSet->addPropertyChangeListener( PROPERTY_GROUP_NAME, this );
 
     // Tabindex muss nicht jeder unterstuetzen
     if (hasProperty(PROPERTY_TABINDEX, xSet))
@@ -489,12 +505,26 @@ void OGroupManager::RemoveElement( const Reference<XPropertySet>& xSet )
         return;
 
     // Component aus Gruppe entfernen
-    ::rtl::OUString		sGroupName;
-    xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString		sGroupName( GetGroupName( xSet ) );
 
     removeFromGroupMap(sGroupName,xSet);
 }
 
+::rtl::OUString OGroupManager::GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent )
+{
+    if (!xComponent.is())
+        return ::rtl::OUString();
+    ::rtl::OUString sGroupName;
+    if (hasProperty( PROPERTY_GROUP_NAME, xComponent )) {
+        xComponent->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+        if (sGroupName.getLength() == 0)
+            xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    }
+    else
+        xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    return sGroupName;
+}
+
 //.........................................................................
 }	// namespace frm
 //.........................................................................
diff --git forms/source/component/GroupManager.hxx forms/source/component/GroupManager.hxx
index f514771..2143c76 100644
--- forms/source/component/GroupManager.hxx
+++ forms/source/component/GroupManager.hxx
@@ -217,6 +217,8 @@ public:
     void getGroup(sal_Int32 nGroup, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup, ::rtl::OUString& Name);
     void getGroupByName(const ::rtl::OUString& Name, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup);
     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> > getControlModels();
+
+	static ::rtl::OUString GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent );
 };
 
 
diff --git forms/source/component/ListBox.cxx forms/source/component/ListBox.cxx
index fe24fc2..51661d1 100644
--- forms/source/component/ListBox.cxx
+++ forms/source/component/ListBox.cxx
@@ -1555,6 +1555,8 @@ namespace frm
     void SAL_CALL OListBoxControl::itemStateChanged(const ItemEvent& _rEvent) throw(RuntimeException)
     {
         // forward this to our listeners
+        Reference< XChild > xChild( getModel(), UNO_QUERY );
+        if ( xChild.is() && xChild->getParent().is() )
         {
             ::osl::MutexGuard aGuard( m_aMutex );
             if ( m_aItemListeners.getLength() )
@@ -1567,6 +1569,8 @@ namespace frm
                 m_pItemBroadcaster->addEvent( new ItemEventDescription( _rEvent ), this );
             }
         }
+        else
+            m_aItemListeners.notifyEach( &XItemListener::itemStateChanged, _rEvent );
 
         // and do the handling for the ChangeListeners
         ::osl::ClearableMutexGuard aGuard(m_aMutex);
diff --git forms/source/component/RadioButton.cxx forms/source/component/RadioButton.cxx
index 27ae8cd..05e9bb6 100644
--- forms/source/component/RadioButton.cxx
+++ forms/source/component/RadioButton.cxx
@@ -28,6 +28,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_forms.hxx"
 #include "RadioButton.hxx"
+#include "GroupManager.hxx"
 #include "property.hxx"
 #ifndef _FRM_PROPERTY_HRC_
 #include "property.hrc"
@@ -119,6 +120,7 @@ ORadioButtonModel::ORadioButtonModel(const Reference<XMultiServiceFactory>& _rxF
     m_nClassId = FormComponentType::RADIOBUTTON;
     m_aLabelServiceName = FRM_SUN_COMPONENT_GROUPBOX;
     initValueProperty( PROPERTY_STATE, PROPERTY_ID_STATE );
+	startAggregatePropertyListening( PROPERTY_GROUP_NAME );
 }
 
 //------------------------------------------------------------------
@@ -166,7 +168,11 @@ StringSequence SAL_CALL	ORadioButtonModel::getSupportedServiceNames() throw(Runt
 void ORadioButtonModel::SetSiblingPropsTo(const ::rtl::OUString& rPropName, const Any& rValue)
 {
     // mein Name
-    ::rtl::OUString sMyName(m_aName);
+    ::rtl::OUString sMyGroup;
+    if (hasProperty(PROPERTY_GROUP_NAME, this))
+        this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sMyGroup;
+    if (sMyGroup.getLength() == 0)
+        sMyGroup = m_aName;
 
     // meine Siblings durchiterieren
     Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
@@ -174,8 +180,9 @@ void ORadioButtonModel::SetSiblingPropsTo(const ::rtl::OUString& rPropName, cons
     {
         Reference<XPropertySet> xMyProps;
         query_interface(static_cast<XWeak*>(this), xMyProps);
-        ::rtl::OUString	sCurrentName;
-        for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+		::rtl::OUString	sCurrentGroup;
+		sal_Int32 nNumSiblings = xIndexAccess->getCount();
+		for (sal_Int32 i=0; i<nNumSiblings; ++i)
         {
             Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
             if (!xSiblingProperties.is())
@@ -192,8 +199,8 @@ void ORadioButtonModel::SetSiblingPropsTo(const ::rtl::OUString& rPropName, cons
                 continue;
 
             // das 'zur selben Gruppe gehoeren' wird am Namen festgemacht
-            xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sCurrentName;
-            if (sCurrentName == sMyName)
+			sCurrentGroup = OGroupManager::GetGroupName( xSiblingProperties );
+			if (sCurrentGroup == sMyGroup)
                 xSiblingProperties->setPropertyValue(rPropName, rValue);
         }
     }
@@ -220,40 +227,7 @@ void ORadioButtonModel::setFastPropertyValue_NoBroadcast(sal_Int32 nHandle, cons
     // die andere Richtung : wenn sich mein Name aendert ...
     if (nHandle == PROPERTY_ID_NAME)
     {
-        // ... muss ich testen, ob ich Siblings mit dem selben Namen habe, damit ich deren ControlSource uebernehmen kann
-        Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
-        if (xIndexAccess.is())
-        {
-            ::rtl::OUString			sName;
-            ::rtl::OUString			sControlSource;
-
-            Reference<XPropertySet> xMyProps;
-            query_interface(static_cast<XWeak*>(this), xMyProps);
-            for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
-            {
-                Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
-                if (!xSiblingProperties.is())
-                    continue;
-
-                if (xMyProps == xSiblingProperties)
-                    // nur wenn ich nicht mich selber gefunden habe
-                    continue;
-
-                sal_Int16 nType = 0;
-                xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
-                if (nType != FormComponentType::RADIOBUTTON)
-                    // nur Radio-Buttons
-                    continue;
-
-                xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sName;
-                // Control, das zur gleichen Gruppe gehoert ?
-                if (rValue == sName)
-                {
-                    setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
-                    break;
-                }
-            }
-        }
+        setControlSource();
     }
 
     if (nHandle == PROPERTY_ID_DEFAULT_STATE)
@@ -271,6 +245,52 @@ void ORadioButtonModel::setFastPropertyValue_NoBroadcast(sal_Int32 nHandle, cons
     }
 }
 
+void ORadioButtonModel::setControlSource()
+{
+    Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
+    if (xIndexAccess.is())
+    {
+        ::rtl::OUString sName, sGroupName;
+
+        if (hasProperty(PROPERTY_GROUP_NAME, this))
+            this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sGroupName;
+        this->getPropertyValue(PROPERTY_NAME) >>= sName;
+
+        Reference<XPropertySet> xMyProps;
+        query_interface(static_cast<XWeak*>(this), xMyProps);
+        for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+        {
+            Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
+            if (!xSiblingProperties.is())
+                continue;
+
+            if (xMyProps == xSiblingProperties)
+                // nur wenn ich nicht mich selber gefunden habe
+                continue;
+
+            sal_Int16 nType = 0;
+            xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
+            if (nType != FormComponentType::RADIOBUTTON)
+                // nur Radio-Buttons
+                continue;
+
+            ::rtl::OUString sSiblingName, sSiblingGroupName;
+            if (hasProperty(PROPERTY_GROUP_NAME, xSiblingProperties))
+                xSiblingProperties->getPropertyValue(PROPERTY_GROUP_NAME) >>= sSiblingGroupName;
+            xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sSiblingName;
+
+            if ((sGroupName.getLength() == 0 && sSiblingGroupName.getLength() == 0 &&   // (no group name
+                 sName == sSiblingName) ||                                              //  names match) or
+                (sGroupName.getLength() != 0 && sSiblingGroupName.getLength() != 0 &&   // (have group name
+                 sGroupName == sSiblingGroupName))                                      //  they match)
+            {
+                setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
+                break;
+            }
+        }
+    }
+}
+
 //------------------------------------------------------------------------------
 void ORadioButtonModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
@@ -360,6 +380,13 @@ void ORadioButtonModel::_propertyChanged(const PropertyChangeEvent& _rEvent) thr
             SetSiblingPropsTo( PROPERTY_STATE, aZero );
         }
     }
+    else if ( _rEvent.PropertyName.equals( PROPERTY_GROUP_NAME ) )
+    {
+        setControlSource();
+        // Can't call OReferenceValueComponent::_propertyChanged(), as it
+        // doesn't know what to do with the GroupName property.
+        return;
+    }
 
     OReferenceValueComponent::_propertyChanged( _rEvent );
 }
diff --git forms/source/component/RadioButton.hxx forms/source/component/RadioButton.hxx
index 0b1ab0e..0d10b05 100644
--- forms/source/component/RadioButton.hxx
+++ forms/source/component/RadioButton.hxx
@@ -84,6 +84,8 @@ private:
             our mutex is aquired exactly once
     */
     void    setNewAggregateState( const ::com::sun::star::uno::Any& _rValue );
+
+    void setControlSource();
 };
 
 //==================================================================
diff --git forms/source/inc/frm_strings.hxx forms/source/inc/frm_strings.hxx
index 1f57f42..ae411ac 100644
--- forms/source/inc/frm_strings.hxx
+++ forms/source/inc/frm_strings.hxx
@@ -97,6 +97,7 @@ namespace frm
     FORMS_CONSTASCII_STRING( PROPERTY_TABINDEX,                 "TabIndex" );
     FORMS_CONSTASCII_STRING( PROPERTY_TAG,                      "Tag" );
     FORMS_CONSTASCII_STRING( PROPERTY_NAME,                     "Name" );
+    FORMS_CONSTASCII_STRING( PROPERTY_GROUP_NAME,               "GroupName" );
     FORMS_CONSTASCII_STRING( PROPERTY_CLASSID,                  "ClassId" );
     FORMS_CONSTASCII_STRING( PROPERTY_FETCHSIZE,                "FetchSize" );
     FORMS_CONSTASCII_STRING( PROPERTY_VALUE,                    "Value" );
diff --git forms/source/inc/property.hrc forms/source/inc/property.hrc
index e70dff4..5c44b93 100644
--- forms/source/inc/property.hrc
+++ forms/source/inc/property.hrc
@@ -60,7 +60,8 @@ namespace frm
 #define PROPERTY_ID_INPUT_REQUIRED      (PROPERTY_ID_START + 19)
 #define PROPERTY_ID_WRITING_MODE        (PROPERTY_ID_START + 20)
 #define PROPERTY_ID_CONTEXT_WRITING_MODE    (PROPERTY_ID_START + 21)
-#define PROPERTY_ID_VERTICAL_ALIGN      (PROPERTY_ID_START + 22)
+#define PROPERTY_ID_GROUP_NAME          (PROPERTY_ID_START + 22)
+#define PROPERTY_ID_VERTICAL_ALIGN      (PROPERTY_ID_START + 23)
     // free
     // free
     // free
diff --git formula/inc/formula/FormulaCompiler.hxx formula/inc/formula/FormulaCompiler.hxx
index 47fefb3..1f40d74 100644
--- formula/inc/formula/FormulaCompiler.hxx
+++ formula/inc/formula/FormulaCompiler.hxx
@@ -219,6 +219,8 @@ public:
     void            SetCompileForFAP( BOOL bVal )
                         { bCompileForFAP = bVal; bIgnoreErrors = bVal; }
 
+    static bool IsOpCodeVolatile( OpCode eOp );
+
     static BOOL DeQuote( String& rStr );
 
     static const String&    GetNativeSymbol( OpCode eOp );
diff --git formula/source/core/api/FormulaCompiler.cxx formula/source/core/api/FormulaCompiler.cxx
index fed0aab..fca0dc4 100644
--- formula/source/core/api/FormulaCompiler.cxx
+++ formula/source/core/api/FormulaCompiler.cxx
@@ -741,6 +741,30 @@ OpCode FormulaCompiler::GetEnglishOpCode( const String& rName ) const
     return bFound ? (*iLook).second : OpCode(ocNone);
 }
 
+bool FormulaCompiler::IsOpCodeVolatile( OpCode eOp )
+{
+    switch (eOp)
+    {
+        // no parameters:
+        case ocRandom:
+        case ocGetActDate:
+        case ocGetActTime:
+        // one parameter:
+        case ocFormula:
+        case ocInfo:
+        // more than one parameters:
+            // ocIndirect/ocIndirectXL otherwise would have to do
+            // StopListening and StartListening on a reference for every
+            // interpreted value.
+        case ocIndirect:
+        case ocIndirectXL:
+            // ocOffset results in indirect references.
+        case ocOffset:
+            return true;
+    }
+    return false;
+}
+
 // Remove quotes, escaped quotes are unescaped.
 BOOL FormulaCompiler::DeQuote( String& rStr )
 {
@@ -957,44 +981,32 @@ void FormulaCompiler::Factor()
     {
         if( nNumFmt == NUMBERFORMAT_UNDEFINED )
             nNumFmt = lcl_GetRetFormat( eOp );
-        // Functions that have to be always recalculated
-        switch( eOp )
+
+        if ( IsOpCodeVolatile(eOp) )
+            pArr->SetRecalcModeAlways();
+        else
         {
-            // no parameters:
-            case ocRandom:
-            case ocGetActDate:
-            case ocGetActTime:
-            // one parameter:
-            case ocFormula:
-            case ocInfo:
-            // more than one parameters:
-                // ocIndirect/ocIndirectXL otherwise would have to do
-                // StopListening and StartListening on a reference for every
-                // interpreted value.
-            case ocIndirect:
-            case ocIndirectXL:
-                // ocOffset results in indirect references.
-            case ocOffset:
-                pArr->SetRecalcModeAlways();
-            break;
-                // Functions recalculated on every document load.
-                // Don't use SetRecalcModeOnLoad() which would override
-                // ModeAlways.
-            case ocConvert :
-                pArr->AddRecalcMode( RECALCMODE_ONLOAD );
-            break;
-                // If the referred cell is moved the value changes.
-            case ocColumn :
-            case ocRow :
-                // ocCell needs recalc on move for some possible type values.
-            case ocCell :
-                pArr->SetRecalcModeOnRefMove();
-            break;
-            case ocHyperLink :
-                pArr->SetHyperLink(TRUE);
-            break;
-            default:
-                ;   // nothing
+            switch( eOp )
+            {
+                    // Functions recalculated on every document load.
+                    // Don't use SetRecalcModeOnLoad() which would override
+                    // ModeAlways.
+                case ocConvert :
+                    pArr->AddRecalcMode( RECALCMODE_ONLOAD );
+                break;
+                    // If the referred cell is moved the value changes.
+                case ocColumn :
+                case ocRow :
+                    // ocCell needs recalc on move for some possible type values.
+                case ocCell :
+                    pArr->SetRecalcModeOnRefMove();
+                break;
+                case ocHyperLink :
+                    pArr->SetHyperLink(TRUE);
+                break;
+                default:
+                    ;   // nothing
+            }
         }
         if (SC_OPCODE_START_NO_PAR <= eOp && eOp < SC_OPCODE_STOP_NO_PAR)
         {
diff --git offapi/com/sun/star/document/XCompatWriterDocProperties.idl offapi/com/sun/star/document/XCompatWriterDocProperties.idl
new file mode 100644
index 0000000..435ffb3
--- /dev/null
+++ offapi/com/sun/star/document/XCompatWriterDocProperties.idl
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocumentProperties.idl,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCompatWriterDocProperties_idl__
+#define __com_sun_star_document_XCompatWriterDocProperties_idl__
+
+#ifndef __com_sun_star_document_XDocumentProperties_idl__
+#include <com/sun/star/document/XDocumentProperties.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+interface XCompatWriterDocProperties
+{
+//    interface ::com::sun::star::document::XDocumentProperties;
+    [attribute] string Manager;
+    [attribute] string Category;
+    [attribute] string Company;
+
+
+}; }; }; };
+};
+#endif
diff --git offapi/com/sun/star/document/XVbaMethodParameter.idl offapi/com/sun/star/document/XVbaMethodParameter.idl
new file mode 100644
index 0000000..7ef5296
--- /dev/null
+++ offapi/com/sun/star/document/XVbaMethodParameter.idl
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright IBM Corporation 2009
+ * Copyright 2009 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaMethodParameter,v $
+ * $Revision: 1.13 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __org_openoffice_vba_XVbaMethodParameter_idl__
+#define __org_openoffice_vba_XVbaMethodParameter_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//============================================================================= 
+
+module com {  module sun {  module star {  module document {
+
+//============================================================================= 
+//gives access to vba method input/output parameters
+//
+//some OO objects need to implement this interface to support the passing of input/output parameters
+//for certain VBA events
+
+interface XVbaMethodParameter : com::sun::star::uno::XInterface
+{
+	//------------------------------------------------------------------------- 
+	 
+	/** sets the value of the parameter with the specified name.
+	 */
+	void setVbaMethodParameter( [in] string PropertyName, 
+			 [in] any Value ); 
+ 
+	//------------------------------------------------------------------------- 
+
+	/** returns the value of the parameter with the specified name.
+     */
+	any getVbaMethodParameter( [in] string PropertyName ); 
+};
+
+//============================================================================= 
+
+}; }; }; };
+#endif
diff --git offapi/com/sun/star/document/makefile.mk offapi/com/sun/star/document/makefile.mk
index 48394a6..6796fcf 100644
--- offapi/com/sun/star/document/makefile.mk
+++ offapi/com/sun/star/document/makefile.mk
@@ -114,7 +114,9 @@ IDLFILES=\
     XDocumentRevisionListPersistence.idl\
     DocumentRevisionListPersistence.idl \
     XDocumentLanguages.idl \
-    XCodeNameQuery.idl
+    XCodeNameQuery.idl \
+    XCompatWriterDocProperties.idl \
+    XVbaMethodParameter.idl \
 
 
 # ------------------------------------------------------------------
diff --git offapi/com/sun/star/drawing/Shape.idl offapi/com/sun/star/drawing/Shape.idl
index 360352a..92fbdff 100644
--- offapi/com/sun/star/drawing/Shape.idl
+++ offapi/com/sun/star/drawing/Shape.idl
@@ -200,6 +200,10 @@ published service Shape
         the z-order.
     */
     [optional, property] long NavigationOrder;
+
+	/** this property lets you get and set a hyperlink for this shape.
+	 */
+	[optional, property] string Hyperlink;
 };
 
 //=============================================================================
diff --git offapi/com/sun/star/script/XLibraryQueryExecutable.idl offapi/com/sun/star/script/XLibraryQueryExecutable.idl
new file mode 100644
index 0000000..48dbfaa
--- /dev/null
+++ offapi/com/sun/star/script/XLibraryQueryExecutable.idl
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+#define __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XLibraryQueryExecutable: com::sun::star::uno::XInterface
+{ 
+	boolean HasExecutableCode( [in] string name );
+};
+
+//============================================================================= 
+ 
+ 
+}; }; }; };  
+ 
+#endif 
diff --git offapi/com/sun/star/script/makefile.mk offapi/com/sun/star/script/makefile.mk
index da8e911..8c46453 100644
--- offapi/com/sun/star/script/makefile.mk
+++ offapi/com/sun/star/script/makefile.mk
@@ -48,6 +48,7 @@ IDLFILES=\
     XLibraryContainerExport.idl\
     XPersistentLibraryContainer.idl\
     XStorageBasedLibraryContainer.idl\
+	XLibraryQueryExecutable.idl \
     ModuleSizeExceededRequest.idl\
     ModuleInfo.idl\
     ModuleType.idl
diff --git officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu
index 5629a4f..f9c9970 100644
--- officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu
+++ officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu
@@ -1205,6 +1205,12 @@
                     <value xml:lang="en-US">~Remove Filter</value>
                 </prop>
             </node>
+                        <node oor:name=".uno:DataForm" oor:op="replace">
+                                <prop oor:name="Label" oor:type="xs:string">
+                                        <value xml:lang="de">D~atenForm...</value>
+                                        <value xml:lang="en-US">D~ataForm...</value>
+                                </prop>
+                        </node>
             <node oor:name=".uno:DataSubTotals" oor:op="replace">
                 <prop oor:name="Label" oor:type="xs:string">
                     <value xml:lang="en-US">Sub~totals...</value>
diff --git officecfg/registry/schema/org/openoffice/Office/Calc.xcs officecfg/registry/schema/org/openoffice/Office/Calc.xcs
index 2db99d2..97a3cd2 100644
--- officecfg/registry/schema/org/openoffice/Office/Calc.xcs
+++ officecfg/registry/schema/org/openoffice/Office/Calc.xcs
@@ -1394,7 +1394,7 @@
               <desc>Indicates whether VBA macros are imported without comments to be executable.</desc>
               <label>Executable code</label>
             </info>
-            <value>false</value>
+            <value>true</value>
           </prop>
           <prop oor:name="Save" oor:type="xs:boolean">
 						<!-- OldPath: Filter/MS_Office/Basic/Excel -->
diff --git officecfg/registry/schema/org/openoffice/Office/Writer.xcs officecfg/registry/schema/org/openoffice/Office/Writer.xcs
index 9abada4..de76f80 100644
--- officecfg/registry/schema/org/openoffice/Office/Writer.xcs
+++ officecfg/registry/schema/org/openoffice/Office/Writer.xcs
@@ -746,6 +746,17 @@
 		</group>
 	</templates>
 	<component>
+        <group oor:name="GlobalTemplateList">
+            <info>
+               <desc>Contains the most recently opened documents.</desc>
+            </info>
+            <prop oor:name="Paths" oor:type="oor:string-list">
+                <info>
+                    <desc>Lists the file global templates loaded when importing writer documents.</desc>
+                </info>
+                <value oor:separator=";"></value> 
+            </prop>
+        </group>
         <group oor:name="MailMergeWizard">
             <info>
                 <desc>Settings of the mail merge wizard.</desc>
@@ -6021,6 +6032,14 @@
 						</info>
 						<value>true</value>
 					</prop>
+                    <prop oor:name="Executable" oor:type="xs:boolean">
+                        <info>
+                            <author>pflin</author>
+                            <desc>Indicates whether VBA macros are imported without comments to be executable.</desc>
+                             <label>Executable code</label>
+                         </info>
+                        <value>true</value>
+                    </prop>
 					<prop oor:name="Save" oor:type="xs:boolean">
 						<!-- OldPath: Filter/MS_Office/Basic/Word -->
 						<!-- OldLocation: soffice.cfg -->
diff --git oovbaapi/genconstidl/api-to-idl.pl oovbaapi/genconstidl/api-to-idl.pl
index 33e28e2..972e8b3 100644
--- oovbaapi/genconstidl/api-to-idl.pl
+++ oovbaapi/genconstidl/api-to-idl.pl
@@ -125,6 +125,9 @@ sub generate_idls($) {
     foreach $module ( keys %result ) {
         foreach $type ( keys %{$result{$module}} ) {
             my $fname = $path . "/" . $type . ".idl";
+            if ( uc($module) eq "ADODB" || uc($module) eq "DAO" ) {
+                $fname = $path . "/" . uc($module) . "_" . $type . ".idl";
+            }
             open( IDL, ">$fname" ) || die "Cannot write $fname.";
             
             if( $module eq "vba" ) {
diff --git oovbaapi/ooo/vba/XApplicationBase.idl oovbaapi/ooo/vba/XApplicationBase.idl
index 2a98305..c1490fc 100644
--- oovbaapi/ooo/vba/XApplicationBase.idl
+++ oovbaapi/ooo/vba/XApplicationBase.idl
@@ -50,7 +50,7 @@ interface XApplicationBase
     void Quit();
 
     any CommandBars( [in] any aIndex );
-    void Run([in] string MacroName, [in] /*Optional*/ any varg1, [in] /*Optional*/ any varg2, [in] /*Optional*/ any varg3, [in] /*Optional*/ any varg4, [in] /*Optional*/ any varg5, [in] /*Optional*/ any varg6, [in] /*Optional*/ any varg7, [in] /*Optional*/ any varg8, [in] /*Optional*/ any varg9, [in] /*Optional*/ any varg10, [in] /*Optional*/ any varg11, [in] /*Optional*/ any varg12, [in] /*Optional*/ any varg13, [in] /*Optional*/ any varg14, [in] /*Optional*/ any varg15, [in] /*Optional*/ any varg16, [in] /*Optional*/ any varg17, [in] /*Optional*/ any varg18, [in] /*Optional*/ any varg19, [in] /*Optional*/ any varg20, [in] /*Optional*/ any varg21, [in] /*Optional*/ any varg22, [in] /*Optional*/ any varg23, [in] /*Optional*/ any varg24, [in] /*Optional*/ any varg25, [in] /*Optional*/ any varg26, [in] /*Optional*/ any varg27, [in] /*Optional*/ any varg28, [in] /*Optional*/ any varg29, [in] /*Optional*/ any varg30);
+    any Run([in] string MacroName, [in] /*Optional*/ any varg1, [in] /*Optional*/ any varg2, [in] /*Optional*/ any varg3, [in] /*Optional*/ any varg4, [in] /*Optional*/ any varg5, [in] /*Optional*/ any varg6, [in] /*Optional*/ any varg7, [in] /*Optional*/ any varg8, [in] /*Optional*/ any varg9, [in] /*Optional*/ any varg10, [in] /*Optional*/ any varg11, [in] /*Optional*/ any varg12, [in] /*Optional*/ any varg13, [in] /*Optional*/ any varg14, [in] /*Optional*/ any varg15, [in] /*Optional*/ any varg16, [in] /*Optional*/ any varg17, [in] /*Optional*/ any varg18, [in] /*Optional*/ any varg19, [in] /*Optional*/ any varg20, [in] /*Optional*/ any varg21, [in] /*Optional*/ any varg22, [in] /*Optional*/ any varg23, [in] /*Optional*/ any varg24, [in] /*Optional*/ any varg25, [in] /*Optional*/ any varg26, [in] /*Optional*/ any varg27, [in] /*Optional*/ any varg28, [in] /*Optional*/ any varg29, [in] /*Optional*/ any varg30);
     void OnTime( [in] any aEarliestTime, [in] string aFunction, [in] any aLatestTime, [in] any aSchedule );
     float CentimetersToPoints([in] float Centimeters );
     void Undo();
diff --git oovbaapi/ooo/vba/XDialogBase.idl oovbaapi/ooo/vba/XDialogBase.idl
index ee5c833..48fa3d8 100644
--- oovbaapi/ooo/vba/XDialogBase.idl
+++ oovbaapi/ooo/vba/XDialogBase.idl
@@ -46,7 +46,7 @@ interface XDialogBase
 {
     interface ::ooo::vba::XHelperInterface;
 
-    void Show();
+	boolean Show();
 };
                                                                                                                              
 }; };
diff --git oovbaapi/ooo/vba/XDocumentBase.idl oovbaapi/ooo/vba/XDocumentBase.idl
index bb45caf..04181bb 100644
--- oovbaapi/ooo/vba/XDocumentBase.idl
+++ oovbaapi/ooo/vba/XDocumentBase.idl
@@ -53,7 +53,6 @@ interface XDocumentBase
     void Close([in] any SaveChanges, [in] any FileName, [in] any RouteWorkBook);
     void Save();
     void Activate();
-    void Protect( [in] any Password );
     void Unprotect( [in] any Password );
 };
 
diff --git oovbaapi/ooo/vba/XFileDialog.idl oovbaapi/ooo/vba/XFileDialog.idl
new file mode 100644
index 0000000..846e16f
--- /dev/null
+++ oovbaapi/ooo/vba/XFileDialog.idl
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_excel_XFileDialog_idl__
+#define __ooo_vba_excel_XFileDialog_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#include <ooo/vba/XFileDialogSelectedItems.idl>
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {
+                                                                                                                             
+//=============================================================================
+
+interface XFileDialog : com::sun::star::uno::XInterface
+{
+	[attribute, readonly] ooo::vba::XFileDialogSelectedItems SelectedItems;
+
+	long Show();
+};
+                                                                                                                             
+}; };
+                                                                                                                             
+#endif
+
diff --git oovbaapi/ooo/vba/XFileDialogSelectedItems.idl oovbaapi/ooo/vba/XFileDialogSelectedItems.idl
new file mode 100644
index 0000000..b844667
--- /dev/null
+++ oovbaapi/ooo/vba/XFileDialogSelectedItems.idl
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+#ifndef __ooo_vba_excel_XFileDialogSelectedItems_idl__
+#define __ooo_vba_excel_XFileDialogSelectedItems_idl__
+                                                                                                                             
+// #ifndef __com_sun_star_uno_XInterface_idl__
+// #include <com/sun/star/uno/XInterface.idl>
+// #endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  
+                                                                                                                             
+//=============================================================================
+
+interface XFileDialogSelectedItems 
+{
+	interface ooo::vba::XCollection;
+};
+                                                                                                                             
+}; }; 
+                                                                                                                             
+#endif
+
diff --git oovbaapi/ooo/vba/XFileSearch.idl oovbaapi/ooo/vba/XFileSearch.idl
new file mode 100644
index 0000000..b88f87c
--- /dev/null
+++ oovbaapi/ooo/vba/XFileSearch.idl
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_XFileSearch_idl__
+#define __ooo_vba_XFileSearch_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef  __ooo_vba_XFoundFiles_idl__
+#include <ooo/vba/XFoundFiles.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XFileSearch
+{
+	interface ::com::sun::star::uno::XInterface;
+
+    [attribute] string FileName;
+    [attribute] string LookIn;
+    [attribute] boolean SearchSubFolders;
+    [attribute] boolean MatchTextExactly;
+    [attribute, readonly] XFoundFiles FoundFiles;
+
+    long Execute();
+    void NewSearch();
+};
+
+}; };
+
+#endif
diff --git oovbaapi/ooo/vba/XFoundFiles.idl oovbaapi/ooo/vba/XFoundFiles.idl
new file mode 100644
index 0000000..ce6dba1
--- /dev/null
+++ oovbaapi/ooo/vba/XFoundFiles.idl
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_XFoundFiles_idl__
+#define __ooo_vba_XFoundFiles_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XFoundFiles
+{
+    interface ooo::vba::XCollection;
+};
+
+}; };
+
+#endif
diff --git oovbaapi/ooo/vba/excel/XApplication.idl oovbaapi/ooo/vba/excel/XApplication.idl
index ac1f4c4..a09caea 100644
--- oovbaapi/ooo/vba/excel/XApplication.idl
+++ oovbaapi/ooo/vba/excel/XApplication.idl
@@ -32,6 +32,14 @@
 #include <ooo/vba/XHelperInterface.idl>
 #include <ooo/vba/XAssistant.idl>
 
+#ifndef __ooo_vba_excel_XFileDialog_idl__
+#include <ooo/vba/XFileDialog.idl>
+#endif
+
+#ifndef __ooo_vba_XFileSearch_idl__
+#include <ooo/vba/XFileSearch.idl>
+#endif
+
 module ooo {  module vba {  module excel { 
 
 interface XRange;
@@ -41,6 +49,8 @@ interface XWorksheets;
 interface XWorksheetFunction;
 interface XWindow;
 interface XWorksheet;
+interface XFileDialog;
+interface XFileSearch;
 
 interface XApplication
 {
@@ -56,8 +66,10 @@ interface XApplication
     [attribute, readonly] XWindow ActiveWindow;
     [attribute, readonly] XWorksheet ActiveSheet;
     [attribute, readonly] ooo::vba::XAssistant Assistant;
+    [attribute, readonly] ooo::vba::XFileSearch FileSearch; //liuchen 2009-8-18, add the support of VBA Application.FileSearch
     [attribute] long Calculation;
     [attribute, readonly] XWorkbook ThisWorkbook;
+	[attribute, readonly] ooo::vba::XFileDialog FileDialog;
     [attribute, readonly] string Name;
     [attribute] boolean DisplayAlerts;
     [attribute] boolean DisplayFormulaBar;
@@ -65,11 +77,16 @@ interface XApplication
     [attribute] any StatusBar;
     [attribute] long Cursor; 
         [attribute] boolean EnableEvents;
+	[attribute] boolean Visible;
+	[attribute] boolean Iteration;  //liuchen 2009-11-25
+	[attribute] long EnableCancelKey;  //liuchen 2009-11-26		
 
     void setDefaultFilePath([in] string DefaultFilePath) raises(com::sun::star::script::BasicErrorException);
 
     string getDefaultFilePath() raises(com::sun::star::script::BasicErrorException); 
 
+	any GetOpenFilename([in] /*Optional*/ any FileFilter, [in] /*Optional*/ any FilterIndex, [in] /*Optional*/ any Title, [in] /*Optional*/ any ButtonText, [in] /*Optional*/ any MultiSelect); //minz, 2009-07-08
+
     string LibraryPath() raises(com::sun::star::script::BasicErrorException);
     string TemplatesPath() raises(com::sun::star::script::BasicErrorException);
     string PathSeparator() raises(com::sun::star::script::BasicErrorException);
@@ -91,8 +108,14 @@ interface XApplication
     XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
         raises(com::sun::star::script::BasicErrorException);
     void Volatile([in] any Volatile);
-    void DoEvents();
     any Caller( [in] any aIndex );
+	any MenuBars( [in] any aIndex );
+	any International([in] long Index);  //liuchen 2009-11-26
+	any GetSaveAsFilename( [in] any InitialFilename, [in] any FileFilter, [in] any FilterIndex, [in] any Title,[in] any ButtonText);
+	void Undo();  //2009-10-11  limingl
+	double InchesToPoints([in] double Inches);
+	void setSheetsInNewWorkbook( [in] long SheetsInNewWorkbook ) raises(com::sun::star::script::BasicErrorException);
+	long getSheetsInNewWorkbook();
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/excel/XGlobals.idl oovbaapi/ooo/vba/excel/XGlobals.idl
index c54740a..1ffcfdc 100644
--- oovbaapi/ooo/vba/excel/XGlobals.idl
+++ oovbaapi/ooo/vba/excel/XGlobals.idl
@@ -73,6 +73,7 @@ XRange Intersect([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3,
     any Names( [in] any Index );
     XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
         raises(com::sun::star::script::BasicErrorException);
+	any MenuBars( [in] any aIndex );
 
 };
 
diff --git oovbaapi/ooo/vba/excel/XMenu.idl oovbaapi/ooo/vba/excel/XMenu.idl
new file mode 100644
index 0000000..cb3698b
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenu.idl
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenu_idl__
+#define __ooo_vba_excel_XMenu_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenu
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+    any MenuItems( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/excel/XMenuBar.idl oovbaapi/ooo/vba/excel/XMenuBar.idl
new file mode 100644
index 0000000..3ead272
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenuBar.idl
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBar_idl__
+#define __ooo_vba_excel_XMenuBar_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuBar
+{
+	interface XHelperInterface;
+
+    any Menus( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/excel/XMenuBars.idl oovbaapi/ooo/vba/excel/XMenuBars.idl
new file mode 100644
index 0000000..3a46c3b
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenuBars.idl
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuBars.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBars_idl__
+#define __ooo_vba_excel_XMenuBars_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuBars
+{
+	interface ooo::vba::XCollection;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/excel/XMenuItem.idl oovbaapi/ooo/vba/excel/XMenuItem.idl
new file mode 100644
index 0000000..2dcfb2f
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenuItem.idl
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItem_idl__
+#define __ooo_vba_excel_XMenuItem_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuItem
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+    [attribute] string OnAction;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/excel/XMenuItems.idl oovbaapi/ooo/vba/excel/XMenuItems.idl
new file mode 100644
index 0000000..9ba7b38
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenuItems.idl
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuItems.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItems_idl__
+#define __ooo_vba_excel_XMenuItems_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuItem;
+
+interface XMenuItems
+{
+	interface ooo::vba::XCollection;
+
+    XMenuItem Add( [in] string Caption, [in] any OnAction, [in] any ShortcutKey, [in] any Before, [in] any Restore, [in] any StatusBar, [in] any HelpFile, [in] any HelpContextID ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/excel/XMenus.idl oovbaapi/ooo/vba/excel/XMenus.idl
new file mode 100644
index 0000000..c8e4ea2
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XMenus.idl
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenus.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenus_idl__
+#define __ooo_vba_excel_XMenus_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenu;
+
+interface XMenus
+{
+	interface ooo::vba::XCollection;
+
+    XMenu Add( [in] string Caption, [in] any Before, [in] any Restore ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/excel/XPageSetup.idl oovbaapi/ooo/vba/excel/XPageSetup.idl
index 70a1ae8..31ad1a5 100644
--- oovbaapi/ooo/vba/excel/XPageSetup.idl
+++ oovbaapi/ooo/vba/excel/XPageSetup.idl
@@ -65,6 +65,7 @@ interface XPageSetup : com::sun::star::uno::XInterface
     [attribute] boolean CenterVertically;
     [attribute] boolean CenterHorizontally;
     [attribute] boolean PrintHeadings;
+    [attribute] long PaperSize; //liuchen 2009-12-11
 
 };
 
diff --git oovbaapi/ooo/vba/excel/XPivotCache.idl oovbaapi/ooo/vba/excel/XPivotCache.idl
index 65fd014..09bbd63 100644
--- oovbaapi/ooo/vba/excel/XPivotCache.idl
+++ oovbaapi/ooo/vba/excel/XPivotCache.idl
@@ -45,6 +45,7 @@ interface XPivotCache
 {
     interface ::ooo::vba::XHelperInterface;
 
+	[attribute] long MissingItemsLimit;
     void Refresh();
 };
 
diff --git oovbaapi/ooo/vba/excel/XQueryTable.idl oovbaapi/ooo/vba/excel/XQueryTable.idl
new file mode 100644
index 0000000..c1a2442
--- /dev/null
+++ oovbaapi/ooo/vba/excel/XQueryTable.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_excel_XQueryTable_idl__
+#define __ooo_vba_excel_XQueryTable_idl__
+                                                     
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba__XHelperInterface_idl__
+#define __ooo_vba__XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  module excel {
+                                                                                                                             
+//=============================================================================
+
+interface XQueryTable 
+{
+	interface com::sun::star::uno::XInterface;
+	//interface ooo::vba::XHelperInterface;
+	boolean Refresh([in] any aBackgroundQuery);
+};
+                                                                                                                             
+}; }; };
+                                                                                                                             
+#endif
+
diff --git oovbaapi/ooo/vba/excel/XRange.idl oovbaapi/ooo/vba/excel/XRange.idl
index 5d59a3b..4ed6fc4 100644
--- oovbaapi/ooo/vba/excel/XRange.idl
+++ oovbaapi/ooo/vba/excel/XRange.idl
@@ -42,6 +42,9 @@
 #ifndef __com_sun_star_script_XDefaultMethod_idl__
 #include <com/sun/star/script/XDefaultMethod.idl>
 #endif
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#include <com/sun/star/script/XErrorQuery.idl>
+#endif
 #ifndef __ooo_vba_XCollection_idl__
 #include <ooo/vba/XCollection.idl>
 #endif
@@ -69,11 +72,14 @@ interface XBorders;
 interface XValidation;
 interface XWorksheet;
 
+interface XPivotTable;
+interface XQueryTable;
 interface XRange
 {
      interface com::sun::star::container::XEnumerationAccess;
     interface com::sun::star::script::XDefaultMethod;
     interface com::sun::star::script::XDefaultProperty;
+	interface com::sun::star::script::XErrorQuery;
     interface ::ooo::vba::excel::XFormat;
     //interface ::ooo::vba::XHelperInterface;
 
@@ -102,6 +108,7 @@ interface XRange
     [attribute] any Style;
     [attribute] any AddIndent;
     [attribute] any ShowDetail;
+	[attribute, readonly] XQueryTable QueryTable;
 
     XComment AddComment( [in] any Text ); 
     void Clear();
@@ -166,6 +173,11 @@ interface XRange
     void	Subtotal( [in] long GroupBy, [in] long Function, [in]  /*Optional*/ sequence<long> TotalList, [in]  /*Optional*/ any Replace, [in]  /*Optional*/ any PageBreaks, [in] any SummaryBelowData ) raises ( com::sun::star::script::BasicErrorException );
     XRange MergeArea( ) raises ( com::sun::star::script::BasicErrorException );
     any Hyperlinks( [in] any aIndex );
+	long   CopyFromRecordset([in] any Data, [in]  any MaxRows , [in]  any MaxColumns) raises ( com::sun::star::script::BasicErrorException );
+	XPivotTable PivotTable();
+	void TextToColumns([in] any Destination, [in] any DataType, [in] any TextQualifier, [in] any ConsecutiveDelimiter, [in] any Tab, [in] any Semicolon, [in] any Comma, 
+		[in] any Space, [in] any Other, [in] any OtherChar, [in] any FieldInfo, [in] any DecimalSeparator, [in] any ThousandsSeparator, [in] any TrailingMinusNumbers );
+	any AdvancedFilter([in] long Action, [in] any CriteriaRange, [in] any CopyToRange, [in] any Unique) raises ( com::sun::star::script::BasicErrorException );
 };
 
 //=============================================================================
diff --git oovbaapi/ooo/vba/excel/XWorkbook.idl oovbaapi/ooo/vba/excel/XWorkbook.idl
index e35b661..1a9807c 100644
--- oovbaapi/ooo/vba/excel/XWorkbook.idl
+++ oovbaapi/ooo/vba/excel/XWorkbook.idl
@@ -50,6 +50,7 @@ interface XWorkbook : com::sun::star::uno::XInterface
     [attribute, readonly] boolean ProtectStructure; 
     [attribute, readonly] XWorksheet ActiveSheet;
     [attribute, readonly] string  CodeName;
+	[attribute, readonly] long FileFormat;
     [attribute] boolean  PrecisionAsDisplayed;
 
     any  Worksheets([in] any sheet);
@@ -60,8 +61,9 @@ interface XWorkbook : com::sun::star::uno::XInterface
     void Activate();
     any Names( [in] any Index );
     any Colors([in] any Index) raises (com::sun::star::script::BasicErrorException);
-    long FileFormat() raises (com::sun::star::script::BasicErrorException);
     void SaveCopyAs( [in] string Filename );
+	void Protect( [in] any Password );
+	void SaveAs([in] string FileName, [in]any FileFormat, [in]any CreateBackup);
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/excel/XWorksheet.idl oovbaapi/ooo/vba/excel/XWorksheet.idl
index 07e9f23..c476bf4 100644
--- oovbaapi/ooo/vba/excel/XWorksheet.idl
+++ oovbaapi/ooo/vba/excel/XWorksheet.idl
@@ -38,6 +38,7 @@
 #ifndef __com_sun_star_script_XInvocation_idl__
 #include <com/sun/star/script/XInvocation.idl>
 #endif
+
  
 #ifndef __com_sun_star_container_XNamed_idl__
 #include <com/sun/star/container/XNamed.idl>
@@ -60,7 +61,7 @@ interface XWorksheet
     interface ::com::sun::star::script::XInvocation;
     interface ::com::sun::star::container::XNamed;
 
-    [attribute] boolean Visible; 
+    [attribute] long Visible; 
     [attribute, readonly] long StandardHeight;
     [attribute, readonly] long StandardWidth;
     [attribute, readonly] boolean ProtectionMode;
@@ -75,7 +77,7 @@ interface XWorksheet
     
     void Activate();
     void Calculate( );
-    void Select();
+	void Select([in] any Replace); //liuchen 2009-9-2, add the input parameter to support expand selection
     void Move([in] any Before,[in] any After );
     void Copy([in] any Before,[in] any After );
     void Paste([in] any Destination,[in] any Link);
diff --git oovbaapi/ooo/vba/excel/makefile.mk oovbaapi/ooo/vba/excel/makefile.mk
index 2515880..1143311 100644
--- oovbaapi/ooo/vba/excel/makefile.mk
+++ oovbaapi/ooo/vba/excel/makefile.mk
@@ -102,7 +102,13 @@ IDLFILES= XGlobals.idl\
      XVPageBreak.idl \
      XVPageBreaks.idl \
      TextFrame.idl \
-
+ 	XMenuBar.idl \
+ 	XMenuBars.idl \
+ 	XMenu.idl \
+ 	XMenus.idl \
+ 	XMenuItem.idl \
+ 	XMenuItems.idl \
+ 	XQueryTable.idl
 
 # ------------------------------------------------------------------
 
diff --git oovbaapi/ooo/vba/makefile.mk oovbaapi/ooo/vba/makefile.mk
index 4f6d378..ef77f77 100644
--- oovbaapi/ooo/vba/makefile.mk
+++ oovbaapi/ooo/vba/makefile.mk
@@ -61,7 +61,11 @@ IDLFILES=\
     XFontBase.idl\
     XDialogsBase.idl\
     XDialogBase.idl\
-    XPageSetupBase.idl
+    XPageSetupBase.idl \
+	XFileSearch.idl\
+	XFoundFiles.idl\
+    XFileDialog.idl \
+    XFileDialogSelectedItems.idl
 
 # ------------------------------------------------------------------
 .ENDIF
diff --git oovbaapi/ooo/vba/msforms/MSFormReturnTypes.idl oovbaapi/ooo/vba/msforms/MSFormReturnTypes.idl
index e7532e3..8fa44f9 100644
--- oovbaapi/ooo/vba/msforms/MSFormReturnTypes.idl
+++ oovbaapi/ooo/vba/msforms/MSFormReturnTypes.idl
@@ -25,27 +25,15 @@
  *
  ************************************************************************/
 module msforms
-{
-    struct ReturnBoolean
-    {
-        boolean Value;
-    };
-                                                                                
+{                                                                                
     struct ReturnEffect
     {
         //fmDropEffect Value;
         short Value;
     };
                                                                                 
-    struct ReturnInteger
-    {
-        long Value;
-    };
-                                                                                
     struct ReturnSingle
     {
         float Value;
     };
-                                                                                
-
 };
diff --git oovbaapi/ooo/vba/msforms/XCheckBox.idl oovbaapi/ooo/vba/msforms/XCheckBox.idl
new file mode 100644
index 0000000..30bdee0
--- /dev/null
+++ oovbaapi/ooo/vba/msforms/XCheckBox.idl
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XCheckBox.idl,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_msforms_XCheckBox_idl__
+#define __ooo_vba_msforms_XCheckBox_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module msforms { 
+
+//=============================================================================
+interface XCheckBox: com::sun::star::uno::XInterface 
+{
+	[attribute] string Caption;
+	[attribute] any Value;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/msforms/XComboBox.idl oovbaapi/ooo/vba/msforms/XComboBox.idl
index 8581392..49e4320 100644
--- oovbaapi/ooo/vba/msforms/XComboBox.idl
+++ oovbaapi/ooo/vba/msforms/XComboBox.idl
@@ -47,6 +47,7 @@ interface XComboBox: ::com::sun::star::uno::XInterface
     void AddItem( [in] any pvargItem, [in] any pvargIndex );
     void removeItem( [in] any index );
     void Clear();
+    any List( [in] any pvargIndex, [in] any pvarColumn );
 };
 
 //=============================================================================
diff --git oovbaapi/ooo/vba/msforms/XControl.idl oovbaapi/ooo/vba/msforms/XControl.idl
index 50d15db..48f178e 100644
--- oovbaapi/ooo/vba/msforms/XControl.idl
+++ oovbaapi/ooo/vba/msforms/XControl.idl
@@ -63,6 +63,7 @@ interface XControl
     [attribute] string Name;
     [attribute] string ControlTipText;
     [attribute] string Tag;
+	[attribute] long ForeColor;
 };
 
 //=============================================================================
diff --git oovbaapi/ooo/vba/msforms/XLabel.idl oovbaapi/ooo/vba/msforms/XLabel.idl
index 60427f6..ea4d944 100644
--- oovbaapi/ooo/vba/msforms/XLabel.idl
+++ oovbaapi/ooo/vba/msforms/XLabel.idl
@@ -39,6 +39,7 @@ interface XLabel: com::sun::star::uno::XInterface
 {
     [attribute] string Caption;
     [attribute] any Value;
+    [attribute] string Accelerator;
 };
 
 //=============================================================================
diff --git oovbaapi/ooo/vba/msforms/XListBox.idl oovbaapi/ooo/vba/msforms/XListBox.idl
index 627c541..2400602 100644
--- oovbaapi/ooo/vba/msforms/XListBox.idl
+++ oovbaapi/ooo/vba/msforms/XListBox.idl
@@ -40,7 +40,7 @@ interface XListBox: com::sun::star::uno::XInterface
 {
     [attribute] any Value;
     [attribute] string Text;
-    [attribute] boolean MultiSelect;
+	[attribute] long MultiSelect; //liuchen 2009-7-31 MultiSelect property in Excel VBA is type long
     [attribute] any ListIndex;
         [attribute, readonly ] long ListCount;
     void AddItem( [in] any pvargItem, [in] any pvargIndex );
diff --git oovbaapi/ooo/vba/msforms/XReturnBoolean.idl oovbaapi/ooo/vba/msforms/XReturnBoolean.idl
new file mode 100644
index 0000000..52eb69d
--- /dev/null
+++ oovbaapi/ooo/vba/msforms/XReturnBoolean.idl
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_msforms_XReturnInteger_idl__
+#define __ooo_vba_msforms_XReturnInteger_idl__
+
+#ifndef __com_sun_star_script_XDefaultProperty_idl__
+#include <com/sun/star/script/XDefaultProperty.idl>
+#endif
+//=============================================================================
+
+module msforms
+{
+
+//=============================================================================
+interface XReturnBoolean: com::sun::star::script::XDefaultProperty 
+{
+	[attribute] boolean Value;
+};	
+//=============================================================================
+
+}; 
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/msforms/XReturnInteger.idl oovbaapi/ooo/vba/msforms/XReturnInteger.idl
new file mode 100644
index 0000000..8ca5c6a
--- /dev/null
+++ oovbaapi/ooo/vba/msforms/XReturnInteger.idl
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_msforms_XReturnInteger_idl__
+#define __ooo_vba_msforms_XReturnInteger_idl__
+
+#ifndef __com_sun_star_script_XDefaultProperty_idl__
+#include <com/sun/star/script/XDefaultProperty.idl>
+#endif
+//=============================================================================
+
+module msforms
+{
+
+//=============================================================================
+interface XReturnInteger: com::sun::star::script::XDefaultProperty 
+{
+	[attribute] long Value;
+};	
+//=============================================================================
+
+}; 
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/msforms/XShape.idl oovbaapi/ooo/vba/msforms/XShape.idl
index e8682a6..eec1a7f 100644
--- oovbaapi/ooo/vba/msforms/XShape.idl
+++ oovbaapi/ooo/vba/msforms/XShape.idl
@@ -75,6 +75,7 @@ interface XShape : ooo::vba::XHelperInterface
     void ScaleHeight( [in] double Factor, [in] boolean RelativeToOriginalSize, [in] long Scale );
     void ScaleWidth( [in] double Factor, [in] boolean RelativeToOriginalSize, [in] long Scale );
     any ShapeRange( [in] any index );  // only here for convience
+    void Copy();
 };
 }; }; };
 
diff --git oovbaapi/ooo/vba/msforms/XShapeRange.idl oovbaapi/ooo/vba/msforms/XShapeRange.idl
index d5b0df2..2d936e0 100644
--- oovbaapi/ooo/vba/msforms/XShapeRange.idl
+++ oovbaapi/ooo/vba/msforms/XShapeRange.idl
@@ -47,6 +47,7 @@ interface XShapeRange
 {
     interface ooo::vba::XCollection;
 
+    [attribute] string Name;
     [attribute] double Height;
     [attribute] double Width;
     [attribute] double Left;
@@ -65,6 +66,7 @@ interface XShapeRange
     void IncrementRotation( [in] double Increment );
     void IncrementLeft( [in] double Increment );
     void IncrementTop( [in] double Increment );
+    void ZOrder( [in] long ZOrderCmd );
 };
 }; }; };
 
diff --git oovbaapi/ooo/vba/msforms/makefile.mk oovbaapi/ooo/vba/msforms/makefile.mk
index 56ac4ca..79313a9 100644
--- oovbaapi/ooo/vba/msforms/makefile.mk
+++ oovbaapi/ooo/vba/msforms/makefile.mk
@@ -44,6 +44,7 @@ IDLFILES=\
     XLabel.idl \
     XTextBox.idl \
     XRadioButton.idl \
+	XCheckBox.idl \
     XShape.idl \
     XShapes.idl \
     XLineFormat.idl \
@@ -62,6 +63,8 @@ IDLFILES=\
     XSpinButton.idl \
     XImage.idl \
     XControls.idl \
+	XReturnBoolean.idl \
+	XReturnInteger.idl \
     XTextFrame.idl \
 
 # ------------------------------------------------------------------
diff --git oovbaapi/ooo/vba/word/XApplication.idl oovbaapi/ooo/vba/word/XApplication.idl
index e6cde02..311f981 100644
--- oovbaapi/ooo/vba/word/XApplication.idl
+++ oovbaapi/ooo/vba/word/XApplication.idl
@@ -57,6 +57,7 @@ interface XApplication : com::sun::star::uno::XInterface
     any Documents( [in] any aIndex );
     any Addins( [in] any aIndex );
     any Dialogs( [in] any aIndex );
+    any ListGalleries( [in] any aIndex );
     float CentimetersToPoints([in] float Centimeters );
 };
 
diff --git oovbaapi/ooo/vba/word/XCell.idl oovbaapi/ooo/vba/word/XCell.idl
new file mode 100644
index 0000000..700b9dc
--- /dev/null
+++ oovbaapi/ooo/vba/word/XCell.idl
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCell_idl__
+#define __ooo_vba_word_XCell_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XCell
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Width;
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void SetWidth( [in] float ColumnWidth, [in] long RulerStyle );
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XCells.idl oovbaapi/ooo/vba/word/XCells.idl
new file mode 100644
index 0000000..9a18c55
--- /dev/null
+++ oovbaapi/ooo/vba/word/XCells.idl
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCells_idl__
+#define __ooo_vba_word_XCells_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XCells 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Width;
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void SetWidth( [in] float ColumnWidth, [in] long RulerStyle );
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XCheckBox.idl oovbaapi/ooo/vba/word/XCheckBox.idl
new file mode 100644
index 0000000..1baafe5
--- /dev/null
+++ oovbaapi/ooo/vba/word/XCheckBox.idl
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCheckBox_idl__
+#define __ooo_vba_word_XCheckBox_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XCheckBox
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] boolean Value;
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XColumn.idl oovbaapi/ooo/vba/word/XColumn.idl
new file mode 100644
index 0000000..78266fc
--- /dev/null
+++ oovbaapi/ooo/vba/word/XColumn.idl
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XColumn_idl__
+#define __ooo_vba_word_XColumn_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XColumn
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Width;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XColumns.idl oovbaapi/ooo/vba/word/XColumns.idl
new file mode 100644
index 0000000..84ed9cb
--- /dev/null
+++ oovbaapi/ooo/vba/word/XColumns.idl
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XColumns_idl__
+#define __ooo_vba_word_XColumns_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XColumns 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Width;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XDocument.idl oovbaapi/ooo/vba/word/XDocument.idl
index 4b55552..2fc26bf 100644
--- oovbaapi/ooo/vba/word/XDocument.idl
+++ oovbaapi/ooo/vba/word/XDocument.idl
@@ -49,6 +49,11 @@ interface XDocument : com::sun::star::script::XInvocation
 {
     [attribute, readonly] XRange Content;
     [attribute] any AttachedTemplate;
+    [attribute] long ProtectionType;
+    [attribute] boolean UpdateStylesOnOpen;
+    [attribute] boolean AutoHyphenation;
+    [attribute] long HyphenationZone;
+    [attribute] long ConsecutiveHyphensLimit;
 
     XRange Range( [in] any Start, [in] any End );
     any BuiltInDocumentProperties( [in] any index );
@@ -63,6 +68,14 @@ interface XDocument : com::sun::star::script::XInvocation
     any Sections([in] any Index);
     void Activate();
     any PageSetup();
+    any TablesOfContents([in] any Index);
+    any FormFields([in] any Index);
+	void Protect( [in] long Type, [in] any NOReset, [in] any Password, [in] any UseIRM, [in] any EnforceStyleLock );
+    void PrintOut([in] any Background, [in] any Append, [in] any Range, [in] any OutputFileName, [in] any From, [in] any To, [in] any Item, [in] any Copies, [in] any Pages, [in] any PageType, [in] any PrintToFile, [in] any Collate, [in] any FileName, [in] any ActivePrinterMacGX, [in] any ManualDuplexPrint, [in] any PrintZoomColumn, [in] any PrintZoomRow, [in] any PrintZoomPaperWidth, [in] any PrintZoomPaperHeight);
+    void PrintPreview();
+    void ClosePrintPreview();
+    any Revisions( [in] any index );
+    any Frames( [in] any index );
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XField.idl oovbaapi/ooo/vba/word/XField.idl
index d610da6..29d30aa 100644
--- oovbaapi/ooo/vba/word/XField.idl
+++ oovbaapi/ooo/vba/word/XField.idl
@@ -36,6 +36,8 @@ module ooo { module vba { module word {
 interface XField 
 {
     interface ::ooo::vba::XHelperInterface;
+
+    boolean Update();
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XFormField.idl oovbaapi/ooo/vba/word/XFormField.idl
new file mode 100644
index 0000000..23d2a83
--- /dev/null
+++ oovbaapi/ooo/vba/word/XFormField.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFormField_idl__
+#define __ooo_vba_word_XFormField_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFormField
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Result;
+    [attribute] boolean Enabled;
+
+    any CheckBox();
+
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XFormFields.idl oovbaapi/ooo/vba/word/XFormFields.idl
new file mode 100644
index 0000000..7a19d3b
--- /dev/null
+++ oovbaapi/ooo/vba/word/XFormFields.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFormFields_idl__
+#define __ooo_vba_word_XFormFields_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XFormFields 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XFrame.idl oovbaapi/ooo/vba/word/XFrame.idl
new file mode 100644
index 0000000..5007405
--- /dev/null
+++ oovbaapi/ooo/vba/word/XFrame.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFrame_idl__
+#define __ooo_vba_word_XFrame_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFrame
+{
+    interface ooo::vba::XHelperInterface;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XFrames.idl oovbaapi/ooo/vba/word/XFrames.idl
new file mode 100644
index 0000000..4c81545
--- /dev/null
+++ oovbaapi/ooo/vba/word/XFrames.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFrames_idl__
+#define __ooo_vba_word_XFrames_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XFrames 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XGlobals.idl oovbaapi/ooo/vba/word/XGlobals.idl
index 45b52fc..c3cfd6d 100644
--- oovbaapi/ooo/vba/word/XGlobals.idl
+++ oovbaapi/ooo/vba/word/XGlobals.idl
@@ -49,6 +49,7 @@ interface XGlobals : com::sun::star::uno::XInterface
     any Documents( [in] any aIndex );
     any Addins( [in] any aIndex );
     any Dialogs( [in] any aIndex );
+    any ListGalleries( [in] any aIndex );
     float CentimetersToPoints([in] float Centimeters );
 };
 
diff --git oovbaapi/ooo/vba/word/XHeadersFooters.idl oovbaapi/ooo/vba/word/XHeadersFooters.idl
new file mode 100644
index 0000000..22066e8
--- /dev/null
+++ oovbaapi/ooo/vba/word/XHeadersFooters.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XHeadersFooters_idl__
+#define __ooo_vba_word_XHeadersFooters_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XHeadersFooters 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XListFormat.idl oovbaapi/ooo/vba/word/XListFormat.idl
new file mode 100644
index 0000000..d9aa65a
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListFormat.idl
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListFormat_idl__
+#define __ooo_vba_word_XListFormat_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListTemplate;
+interface XListFormat
+{
+    interface ooo::vba::XHelperInterface;
+
+    void ApplyListTemplate([in] XListTemplate ListTemplate,
+        [in] any /* optional */ ContinuePreviousList,
+        [in] any /* optional */ ApplyTo,
+        [in] any /* optional */ DefaultListBehavior);
+    
+    void ConvertNumbersToText();
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XListGalleries.idl oovbaapi/ooo/vba/word/XListGalleries.idl
new file mode 100644
index 0000000..9268afc
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListGalleries.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListGalleries_idl__
+#define __ooo_vba_word_XListGalleries_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListGalleries 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XListGallery.idl oovbaapi/ooo/vba/word/XListGallery.idl
new file mode 100644
index 0000000..4bd83b9
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListGallery.idl
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListGallery_idl__
+#define __ooo_vba_word_XListGallery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListGallery
+{
+    interface ooo::vba::XHelperInterface;
+
+    any ListTemplates( [in] any aIndex );
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XListLevel.idl oovbaapi/ooo/vba/word/XListLevel.idl
new file mode 100644
index 0000000..0ea1be7
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListLevel.idl
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListLevel_idl__
+#define __ooo_vba_word_XListLevel_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFont;
+interface XListLevel
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Alignment;
+    [attribute] XFont Font;
+    [attribute, readonly] long Index;
+    [attribute] string LinkedStyle;
+    [attribute] string NumberFormat;
+    [attribute] float NumberPosition;
+    [attribute] long NumberStyle;
+    [attribute] long ResetOnHigher;
+    [attribute] long StartAt;
+    [attribute] float TabPosition;
+    [attribute] float TextPosition;
+    [attribute] long TrailingCharacter;
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XListLevels.idl oovbaapi/ooo/vba/word/XListLevels.idl
new file mode 100644
index 0000000..522d474
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListLevels.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListLevels_idl__
+#define __ooo_vba_word_XListLevels_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListLevels 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XListTemplate.idl oovbaapi/ooo/vba/word/XListTemplate.idl
new file mode 100644
index 0000000..403bfa9
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListTemplate.idl
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListTemplate_idl__
+#define __ooo_vba_word_XListTemplate_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListTemplate
+{
+    interface ooo::vba::XHelperInterface;
+
+    any ListLevels( [in] any aIndex );
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XListTemplates.idl oovbaapi/ooo/vba/word/XListTemplates.idl
new file mode 100644
index 0000000..d6ec96d
--- /dev/null
+++ oovbaapi/ooo/vba/word/XListTemplates.idl
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListTemplates_idl__
+#define __ooo_vba_word_XListTemplates_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListTemplates 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XParagraph.idl oovbaapi/ooo/vba/word/XParagraph.idl
index 057875d..a585e32 100644
--- oovbaapi/ooo/vba/word/XParagraph.idl
+++ oovbaapi/ooo/vba/word/XParagraph.idl
@@ -43,6 +43,7 @@ interface XParagraph
     interface ooo::vba::XHelperInterface;
 
     [attribute, readonly] XRange Range;
+    [attribute] any Style;
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XRange.idl oovbaapi/ooo/vba/word/XRange.idl
index 868613c..4bed0c0 100644
--- oovbaapi/ooo/vba/word/XRange.idl
+++ oovbaapi/ooo/vba/word/XRange.idl
@@ -45,13 +45,14 @@ module ooo {  module vba {  module word {
 interface XParagraphFormat;
 interface XStyle;
 interface XFont;
+interface XListFormat;
 interface XRange
 {
     interface ooo::vba::XHelperInterface;
 
     [attribute] string Text;
     [attribute] XParagraphFormat ParagraphFormat;
-    [attribute] XStyle Style;
+    [attribute] any Style;
     [attribute,readonly] ::com::sun::star::text::XTextRange XTextRange;
     // Of course Font is NOT readonly, #FIXME #TODO
     // readonly though will force an error attempting to write
@@ -59,6 +60,7 @@ interface XRange
     [attribute] long LanguageID;
     [attribute] long Start;
     [attribute] long End;
+    [attribute, readonly] XListFormat ListFormat;
 
     void InsertBreak( [in] any Type );
     void Select();
@@ -66,6 +68,10 @@ interface XRange
     void InsertParagraphBefore();
     void InsertParagraphAfter();
     any PageSetup();
+    boolean InRange( [in] XRange Range );
+    any Revisions( [in] any index );
+    any Sections( [in] any index );
+    any Fields( [in] any index );
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XReplacement.idl oovbaapi/ooo/vba/word/XReplacement.idl
index 2d6dcd2..778f9e1 100644
--- oovbaapi/ooo/vba/word/XReplacement.idl
+++ oovbaapi/ooo/vba/word/XReplacement.idl
@@ -42,6 +42,8 @@ interface XReplacement
     interface ooo::vba::XHelperInterface;
 
     [attribute] string Text;
+
+    void ClearFormatting();
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XRevision.idl oovbaapi/ooo/vba/word/XRevision.idl
new file mode 100644
index 0000000..bb3e570
--- /dev/null
+++ oovbaapi/ooo/vba/word/XRevision.idl
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRevision_idl__
+#define __ooo_vba_word_XRevision_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XRevision
+{
+    interface ooo::vba::XHelperInterface;
+
+    void Accept();
+    void Reject();
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XRevisions.idl oovbaapi/ooo/vba/word/XRevisions.idl
new file mode 100644
index 0000000..358face
--- /dev/null
+++ oovbaapi/ooo/vba/word/XRevisions.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRevisions_idl__
+#define __ooo_vba_word_XRevisions_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XRevisions 
+{
+	interface ::ooo::vba::XCollection;
+
+    void AcceptAll();
+    void RejectAll();
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XRow.idl oovbaapi/ooo/vba/word/XRow.idl
new file mode 100644
index 0000000..2c54828
--- /dev/null
+++ oovbaapi/ooo/vba/word/XRow.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRow_idl__
+#define __ooo_vba_word_XRow_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRow
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void Select();
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XRows.idl oovbaapi/ooo/vba/word/XRows.idl
new file mode 100644
index 0000000..8d0ae61
--- /dev/null
+++ oovbaapi/ooo/vba/word/XRows.idl
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRows_idl__
+#define __ooo_vba_word_XRows_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XRows 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Alignment;
+    [attribute] any AllowBreakAcrossPages;
+    [attribute] float SpaceBetweenColumns;
+
+    void Delete();
+    void SetLeftIndent( [in] float LeftIndent, [in] long RulerStyle );
+    void Select();
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XSection.idl oovbaapi/ooo/vba/word/XSection.idl
index 325ddf5..ec4569b 100644
--- oovbaapi/ooo/vba/word/XSection.idl
+++ oovbaapi/ooo/vba/word/XSection.idl
@@ -43,8 +43,8 @@ interface XSection
 
     [attribute] boolean ProtectedForForms;
 
-    any Headers();
-    any Footers();
+    any Headers( [in] any aIndex );
+    any Footers( [in] any aIndex );
     any PageSetup();
 };
 
diff --git oovbaapi/ooo/vba/word/XSelection.idl oovbaapi/ooo/vba/word/XSelection.idl
index 053cbc6..3cbcfaa 100644
--- oovbaapi/ooo/vba/word/XSelection.idl
+++ oovbaapi/ooo/vba/word/XSelection.idl
@@ -52,7 +52,7 @@ interface XSelection
     [attribute, readonly] XRange Range;
     [attribute] XParagraphFormat ParagraphFormat;
     [attribute, readonly] XFind Find;
-    [attribute] XStyle Style;
+    [attribute] any Style;
     [attribute, readonly] XFont Font;
     [attribute, readonly] XHeaderFooter HeaderFooter;
     [attribute] long LanguageID;
@@ -68,6 +68,7 @@ interface XSelection
     void MoveRight( [in] any Unit, [in] any Count, [in] any Extend );
     void MoveLeft( [in] any Unit, [in] any Count, [in] any Extend );
     void MoveDown( [in] any Unit, [in] any Count, [in] any Extend );
+    void MoveUp( [in] any Unit, [in] any Count, [in] any Extend );
     void TypeParagraph();
     void InsertParagraph();
     void InsertParagraphBefore();
@@ -77,6 +78,19 @@ interface XSelection
     any Information( [in] long Type );
     void InsertBreak( [in] any Type );
     any ShapeRange();
+    void SelectColumn();
+    void SelectRow();
+    any Rows( [in] any aIndex );
+    any Columns( [in] any aIndex );
+    any Cells( [in] any aIndex );
+    void Copy();
+    void CopyAsPicture();
+    void Paste();
+    void Collapse([in] any Direction);
+    void WholeStory();
+    boolean InRange( [in] XRange Range );
+    void SplitTable();
+    any Paragraphs( [in] any aIndex );
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XStyle.idl oovbaapi/ooo/vba/word/XStyle.idl
index b89798d..1c0f305 100644
--- oovbaapi/ooo/vba/word/XStyle.idl
+++ oovbaapi/ooo/vba/word/XStyle.idl
@@ -35,17 +35,32 @@
 #include <ooo/vba/XHelperInterface.idl>
 #endif
 
+#ifndef __com_sun_star_script_XDefaultProperty_idl__
+#include <com/sun/star/script/XDefaultProperty.idl>
+#endif
+
 module ooo {  module vba {  module word { 
 
 interface XFont;
+interface XListTemplate;
+interface XParagraphFormat;
 interface XStyle
 {
     interface ooo::vba::XHelperInterface;
+    interface com::sun::star::script::XDefaultProperty;
 
     [attribute] string Name;
     [attribute] long LanguageID;
     [attribute, readonly] long Type;
     [attribute, readonly] XFont Font;
+    [attribute] string NameLocal;
+    [attribute, readonly] XParagraphFormat ParagraphFormat;
+    [attribute] boolean AutomaticallyUpdate;
+    [attribute] any BaseStyle;
+    [attribute] any NextParagraphStyle;
+    [attribute, readonly] long ListLevelNumber;
+
+    void LinkToListTemplate( [in] XListTemplate ListTemplate, [in] any ListLevelNumber );
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XTabStop.idl oovbaapi/ooo/vba/word/XTabStop.idl
new file mode 100644
index 0000000..b9cf94d
--- /dev/null
+++ oovbaapi/ooo/vba/word/XTabStop.idl
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTabStop_idl__
+#define __ooo_vba_word_XTabStop_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XTabStop
+{
+    interface ooo::vba::XHelperInterface;
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XTabStops.idl oovbaapi/ooo/vba/word/XTabStops.idl
new file mode 100644
index 0000000..318d492
--- /dev/null
+++ oovbaapi/ooo/vba/word/XTabStops.idl
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTabStops_idl__
+#define __ooo_vba_word_XTabStops_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XTabStop;
+interface XTabStops 
+{
+	interface ::ooo::vba::XCollection;
+
+    XTabStop Add([in] float Position, [in] any Alignment, [in] any Leader );
+    void ClearAll();
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XTable.idl oovbaapi/ooo/vba/word/XTable.idl
index 235067c..edd5b39 100644
--- oovbaapi/ooo/vba/word/XTable.idl
+++ oovbaapi/ooo/vba/word/XTable.idl
@@ -69,7 +69,9 @@ interface XTable
         raises(com::sun::star::script::BasicErrorException);
 */
     any Borders( [in] any aIndex );
-
+    
+    any Rows([in] any aIndex );
+    any Columns([in] any aIndex );
 };
 
 }; }; };
diff --git oovbaapi/ooo/vba/word/XTableOfContents.idl oovbaapi/ooo/vba/word/XTableOfContents.idl
new file mode 100644
index 0000000..dcb7e8a
--- /dev/null
+++ oovbaapi/ooo/vba/word/XTableOfContents.idl
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTableOfContents_idl__
+#define __ooo_vba_word_XTableOfContents_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XTableOfContents
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long LowerHeadingLevel;
+    [attribute] long TabLeader;
+    [attribute] boolean UseFields;
+    [attribute] boolean UseOutlineLevels;
+
+    void Delete();
+    void Update();
+};
+
+}; }; };
+
+#endif
+
+
diff --git oovbaapi/ooo/vba/word/XTablesOfContents.idl oovbaapi/ooo/vba/word/XTablesOfContents.idl
new file mode 100644
index 0000000..53c557b
--- /dev/null
+++ oovbaapi/ooo/vba/word/XTablesOfContents.idl
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTablesOfContents_idl__
+#define __ooo_vba_word_XTablesOfContents_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XTableOfContents;
+interface XRange;
+interface XTablesOfContents 
+{
+	interface ::ooo::vba::XCollection;
+
+    XTableOfContents Add([in] XRange Range, [in] any UseHeadingStyles, [in] any UpperHeadingLevel, [in] any LowerHeadingLevel, [in] any UseFields, [in] any TableID, [in] any RightAlignPageNumbers, [in] any IncludePageNumbers, [in] any AddedStyles, [in] any UseHyperlinks, [in] any HidePageNumbersInWeb, [in] any UseOutlineLevels );
+};
+
+}; }; };
+
+#endif
diff --git oovbaapi/ooo/vba/word/XTemplate.idl oovbaapi/ooo/vba/word/XTemplate.idl
index 0a5f0ed..04e7063 100644
--- oovbaapi/ooo/vba/word/XTemplate.idl
+++ oovbaapi/ooo/vba/word/XTemplate.idl
@@ -42,6 +42,7 @@ interface XTemplate
     interface ooo::vba::XHelperInterface;
 
     [attribute, readonly] string Name;
+    [attribute, readonly] string Path;
 
     any AutoTextEntries( [in] any aIndex );
 };
diff --git oovbaapi/ooo/vba/word/XWindow.idl oovbaapi/ooo/vba/word/XWindow.idl
index 225a923..4ef56da 100644
--- oovbaapi/ooo/vba/word/XWindow.idl
+++ oovbaapi/ooo/vba/word/XWindow.idl
@@ -44,6 +44,7 @@ module ooo {  module vba {  module word {
 interface XWindow : com::sun::star::uno::XInterface
 {
     [attribute] any View;
+    [attribute] any WindowState;
     void Activate();
     void Close([in] any SaveChanges, [in] any RouteDocument);
     any Panes( [in] any aIndex ); // this is a fake api for it seems not support in Write
diff --git oovbaapi/ooo/vba/word/makefile.mk oovbaapi/ooo/vba/word/makefile.mk
index 543e99f..04b36d1 100644
--- oovbaapi/ooo/vba/word/makefile.mk
+++ oovbaapi/ooo/vba/word/makefile.mk
@@ -79,6 +79,31 @@ IDLFILES= XGlobals.idl\
     XPageSetup.idl \
     XSection.idl \
     XSections.idl \
+	XRow.idl \
+	XRows.idl \
+	XColumn.idl \
+	XColumns.idl \
+	XCell.idl \
+	XCells.idl \
+	XTabStop.idl \
+	XTabStops.idl \
+	XTableOfContents.idl \
+	XTablesOfContents.idl \
+	XListFormat.idl \
+	XListGalleries.idl \
+	XListGallery.idl \
+	XListTemplate.idl \
+	XListTemplates.idl \
+	XListLevel.idl \
+	XListLevels.idl \
+	XFormField.idl \
+	XFormFields.idl \
+	XRevision.idl \
+	XRevisions.idl \
+	XFrame.idl \
+	XFrames.idl \
+	XCheckBox.idl \
+	XHeadersFooters.idl \
 
 # ------------------------------------------------------------------
 
diff --git oox/inc/oox/ole/vbacontrol.hxx oox/inc/oox/ole/vbacontrol.hxx
index 71f3a70..730d46d 100755
--- oox/inc/oox/ole/vbacontrol.hxx
+++ oox/inc/oox/ole/vbacontrol.hxx
@@ -29,6 +29,7 @@
 #define OOX_OLE_VBACONTROL_HXX
 
 #include "oox/ole/axcontrol.hxx"
+#include <com/sun/star/frame/XModel.hpp>
 
 namespace com { namespace sun { namespace star {
     namespace container { class XNameContainer; }
@@ -192,6 +193,7 @@ public:
     /** Imports the form and its embedded controls, and inserts the form with
         all its controls into the passed dialog library. */
     void                importForm(
+                            const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& rxDocModel,
                             const ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameContainer >& rxDialogLib,
                             StorageBase& rVbaFormStrg,
                             const ::rtl::OUString& rModuleName,
diff --git oox/source/ole/vbacontrol.cxx oox/source/ole/vbacontrol.cxx
index 8b37c13..8a3a5c6 100755
--- oox/source/ole/vbacontrol.cxx
+++ oox/source/ole/vbacontrol.cxx
@@ -57,6 +57,7 @@ using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::UNO_QUERY_THROW;
 using ::com::sun::star::uno::UNO_SET_THROW;
 using ::com::sun::star::uno::XComponentContext;
+using ::com::sun::star::frame::XModel;
 
 namespace oox {
 namespace ole {
@@ -758,7 +759,7 @@ VbaUserForm::VbaUserForm( const Reference< XMultiServiceFactory >& rxGlobalFacto
     OSL_ENSURE( mxGlobalFactory.is(), "VbaUserForm::VbaUserForm - missing service factory" );
 }
 
-void VbaUserForm::importForm( const Reference< XNameContainer >& rxDialogLib,
+void VbaUserForm::importForm( const Reference< XModel >& rxDocModel, const Reference< XNameContainer >& rxDialogLib,
         StorageBase& rVbaFormStrg, const OUString& rModuleName, rtl_TextEncoding eTextEnc )
 {
     OSL_ENSURE( rxDialogLib.is(), "VbaUserForm::importForm - missing dialog library" );
@@ -829,7 +830,7 @@ void VbaUserForm::importForm( const Reference< XNameContainer >& rxDialogLib,
             // export the dialog to XML and insert it into the dialog library
             PropertySet aFactoryProps( mxGlobalFactory );
             Reference< XComponentContext > xCompContext( aFactoryProps.getAnyProperty( PROP_DefaultContext ), UNO_QUERY_THROW );
-            Reference< XInputStreamProvider > xDialogSource( ::xmlscript::exportDialogModel( xDialogNC, xCompContext ), UNO_SET_THROW );
+            Reference< XInputStreamProvider > xDialogSource( ::xmlscript::exportDialogModel( xDialogNC, xCompContext, rxDocModel ), UNO_SET_THROW );
             OSL_ENSURE( !rxDialogLib->hasByName( aFormName ), "VbaUserForm::importForm - multiple dialogs with equal name" );
             ContainerHelper::insertByName( rxDialogLib, aFormName, Any( xDialogSource ) );
         }
diff --git oox/source/ole/vbaproject.cxx oox/source/ole/vbaproject.cxx
index d93877d..877f16e 100755
--- oox/source/ole/vbaproject.cxx
+++ oox/source/ole/vbaproject.cxx
@@ -418,7 +418,7 @@ void VbaProject::importVba( StorageBase& rVbaPrjStrg, const GraphicHelper& rGrap
                 // create and import the form
                 Reference< XNameContainer > xDialogLib( createDialogLibrary(), UNO_SET_THROW );
                 VbaUserForm aForm( mxGlobalFactory, rGraphicHelper, bDefaultColorBgr );
-                aForm.importForm( xDialogLib, *xSubStrg, aModuleName, eTextEnc );
+                aForm.importForm( mxDocModel, xDialogLib, *xSubStrg, aModuleName, eTextEnc );
             }
             catch( Exception& )
             {
diff --git sc/inc/address.hxx sc/inc/address.hxx
index 6a8d4d7..3619fd6 100644
--- sc/inc/address.hxx
+++ sc/inc/address.hxx
@@ -232,6 +232,9 @@ inline SCTAB SanitizeTab( SCTAB nTab, SCTAB nMaxTab )
 #define SCA_VALID_ROW       0x0100
 #define SCA_VALID_COL       0x0200
 #define SCA_VALID_TAB       0x0400
+// SCA_BITS is a convience for 
+// (SCA_VALID_TAB | SCA_VALID_COL | SCA_VALID_ROW | SCA_TAB_3D | SCA_TAB_ABSOLUTE | SCA_ROW_ABSOLUTE | SCA_COL_ABSOLUTE)
+#define SCA_BITS            0x070F
 // somewhat cheesy kludge to force the display of the document name even for
 // local references.  Requires TAB_3D to be valid
 #define SCA_FORCE_DOC       0x0800
diff --git sc/inc/addruno.hxx sc/inc/addruno.hxx
index 2cf8eca..3e17398 100644
--- sc/inc/addruno.hxx
+++ sc/inc/addruno.hxx
@@ -47,7 +47,7 @@ private:
     sal_Int32               nRefSheet;
     sal_Bool                bIsRange;
 
-    sal_Bool                ParseUIString( const String& rUIString );
+    sal_Bool                ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv = ::formula::FormulaGrammar::CONV_OOO );
 
 public:
 
diff --git sc/inc/appoptio.hxx sc/inc/appoptio.hxx
index 4056b3c..12b41ff 100644
--- sc/inc/appoptio.hxx
+++ sc/inc/appoptio.hxx
@@ -44,6 +44,10 @@ public:
 
     void		SetDefaults();
 
+	// Set or get the initial tab count for new spreadsheet, it is used by VBA API currently.
+	void		SetTabCountInNewSpreadsheet( sal_Int16 nCount )  { nTabCountInNewSpreadsheet = nCount; }
+	sal_Int16	GetTabCountInNewSpreadsheet() const              { return nTabCountInNewSpreadsheet;   }
+
     void		SetAppMetric( FieldUnit eUnit )	{ eMetric = eUnit;		}
     FieldUnit	GetAppMetric() const			{ return eMetric;		}
     void		SetZoom( USHORT nNew )			{ nZoom = nNew;			}
@@ -87,6 +91,7 @@ public:
     const ScAppOptions&	operator=	( const ScAppOptions& rOpt );
 
 private:
+	sal_Int16	nTabCountInNewSpreadsheet;
     FieldUnit	eMetric;
     USHORT		nLRUFuncCount;
     USHORT*		pLRUList;
diff --git sc/inc/cell.hxx sc/inc/cell.hxx
index 93818ec..3c1605e 100644
--- sc/inc/cell.hxx
+++ sc/inc/cell.hxx
@@ -406,7 +406,7 @@ public:
                                 const formula::FormulaGrammar::Grammar = formula::FormulaGrammar::GRAM_DEFAULT ) const;
 
     void			SetDirty();
-    inline void		SetDirtyVar() { bDirty = TRUE; }
+	void			SetDirtyVar();
     // If setting entire document dirty after load, no broadcasts but still append to FormulaTree.
     void            SetDirtyAfterLoad();
     inline void		ResetTableOpDirtyVar() { bTableOpDirty = FALSE; }
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 9112c6d..59d774f 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -103,6 +103,7 @@ class ScDrawLayer;
 class ScExtDocOptions;
 class ScExternalRefManager;
 class ScFormulaCell;
+class ScMacroManager;
 class ScMarkData;
 class ScOutlineTable;
 class ScPatternAttr;
@@ -305,6 +309,8 @@ private:
     ::std::auto_ptr<ScClipParam>     mpClipParam;
 
     ::std::auto_ptr<ScExternalRefManager> pExternalRefMgr;
+    ::std::auto_ptr<ScMacroManager> mpMacroMgr;
+
 
     // mutable for lazy construction
     mutable ::std::auto_ptr< ScFormulaParserPool >
@@ -460,6 +471,8 @@ public:
     void			SetName( const String& r ) { aDocName = r; }
     const String& 	GetCodeName() const { return aDocCodeName; }
     void			SetCodeName( const String& r ) { aDocCodeName = r; }
+    
+    SC_DLLPUBLIC NameToNameMap*              GetLocalNameMap( SCTAB& rTab );
 
     void			GetDocStat( ScDocStat& rDocStat );
 
@@ -956,7 +973,7 @@ public:
                                             SCCOL nEndCol, SCROW nEndRow, SCTAB nEndTab,
                                             ScDirection eDir );
 
-    void			FindAreaPos( SCCOL& rCol, SCROW& rRow, SCTAB nTab, SCsCOL nMovX, SCsROW nMovY );
+	SC_DLLPUBLIC void			FindAreaPos( SCCOL& rCol, SCROW& rRow, SCTAB nTab, SCsCOL nMovX, SCsROW nMovY );
     SC_DLLPUBLIC void			GetNextPos( SCCOL& rCol, SCROW& rRow, SCTAB nTab, SCsCOL nMovX, SCsROW nMovY,
                                 BOOL bMarked, BOOL bUnprotected, const ScMarkData& rMark );
 
@@ -977,7 +994,7 @@ public:
                                SCROW nStartRow, SCSIZE nSize,
                                ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL,
                                const ScMarkData* pTabMark = NULL );
-    void			DeleteRow( const ScRange& rRange,
+	SC_DLLPUBLIC void	DeleteRow( const ScRange& rRange,
                                ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL );
     BOOL			InsertCol( SCROW nStartRow, SCTAB nStartTab,
                                SCROW nEndRow,   SCTAB nEndTab,
@@ -1015,7 +1032,7 @@ public:
     SC_DLLPUBLIC void			ResetClip( ScDocument* pSourceDoc, const ScMarkData* pMarks );
     SC_DLLPUBLIC void			ResetClip( ScDocument* pSourceDoc, SCTAB nTab );
     void			SetCutMode( BOOL bCut );
-    BOOL			IsCutMode();
+	SC_DLLPUBLIC BOOL			IsCutMode();
     void			SetClipArea( const ScRange& rArea, BOOL bCut = FALSE );
 
     SC_DLLPUBLIC BOOL			IsDocVisible() const						{ return bIsVisible; }
@@ -1590,6 +1607,7 @@ public:
     SC_DLLPUBLIC ScLkUpdMode		GetLinkMode() const				{ return eLinkMode ;}
     void			SetLinkMode( ScLkUpdMode nSet )	{ 	eLinkMode  = nSet;}
 
+    SC_DLLPUBLIC ScMacroManager* GetMacroManager();
 
 private:
     ScDocument(const ScDocument& r); // disabled with no definition
diff --git sc/inc/global.hxx sc/inc/global.hxx
index e456fed..cde71d8 100644
--- sc/inc/global.hxx
+++ sc/inc/global.hxx
@@ -225,6 +225,7 @@ const USHORT IDF_HARDATTR   = 0x0020;   /// Hard cell attributes.
 const USHORT IDF_STYLES     = 0x0040;   /// Cell styles.
 const USHORT IDF_OBJECTS    = 0x0080;   /// Drawing objects.
 const USHORT IDF_EDITATTR   = 0x0100;   /// Rich-text attributes.
+const USHORT IDF_SPECIAL_BOOLEAN = 0x1000;
 const USHORT IDF_ATTRIB     = IDF_HARDATTR | IDF_STYLES;
 const USHORT IDF_CONTENTS   = IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_NOTE | IDF_FORMULA;
 const USHORT IDF_ALL        = IDF_CONTENTS | IDF_ATTRIB | IDF_OBJECTS;
diff --git sc/inc/globstr.hrc sc/inc/globstr.hrc
index a783120..7503ce2 100644
--- sc/inc/globstr.hrc
+++ sc/inc/globstr.hrc
@@ -577,7 +577,23 @@
 #define STR_UNDO_SET_TAB_BG_COLOR       438
 #define STR_UNDO_SET_MULTI_TAB_BG_COLOR 439
 
-#define STR_COUNT                       440
+#define STR_SHAPE_AUTOSHAPE         440
+#define STR_SHAPE_RECTANGLE         441
+#define STR_SHAPE_LINE              442
+#define STR_SHAPE_OVAL              443
+#define STR_SHAPE_TEXTBOX           444
+
+#define STR_FORM_BUTTON             445
+#define STR_FORM_CHECKBOX           446
+#define STR_FORM_OPTIONBUTTON       447
+#define STR_FORM_LABEL              448
+#define STR_FORM_LISTBOX            449
+#define STR_FORM_GROUPBOX           450
+#define STR_FORM_DROPDOWN           451
+#define STR_FORM_SPINNER            452
+#define STR_FORM_SCROLLBAR          453
+                                       
+#define STR_COUNT                       454
 
 #endif
 
diff --git sc/inc/macromgr.hxx sc/inc/macromgr.hxx
new file mode 100644
index 0000000..35a3b2d
--- /dev/null
+++ sc/inc/macromgr.hxx
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_MACROMGR_HXX
+#define SC_MACROMGR_HXX
+
+#include <com/sun/star/container/XContainerListener.hpp>
+
+#include "rtl/ustring.hxx"
+#include "scdllapi.h"
+
+#include <hash_map>
+#include <memory>
+
+class ScDocument;
+class ScFormulaCell;
+class ScUserMacroDepTracker;
+
+class ScMacroManager
+{
+public:
+    explicit ScMacroManager(ScDocument* pDoc);
+    ~ScMacroManager();
+
+    SC_DLLPUBLIC void InitUserFuncData();
+    SC_DLLPUBLIC void SetUserFuncVolatile( const rtl::OUString& sName, bool isVolatile );
+    SC_DLLPUBLIC bool GetUserFuncVolatile( const rtl::OUString& sName );
+
+    void AddDependentCell(const ::rtl::OUString& aModuleName, ScFormulaCell* pCell);
+    void RemoveDependentCell(ScFormulaCell* pCell);
+    void BroadcastModuleUpdate(const ::rtl::OUString& aModuleName);
+
+private:
+    typedef std::hash_map< ::rtl::OUString, bool, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameBoolMap;
+    NameBoolMap mhFuncToVolatile;
+    com::sun::star::uno::Reference< com::sun::star::container::XContainerListener > mxContainerListener;
+
+    ::std::auto_ptr<ScUserMacroDepTracker> mpDepTracker;
+    ScDocument* mpDoc;
+};
+
+#endif
+
diff --git sc/inc/rangenam.hxx sc/inc/rangenam.hxx
index 7f3e123..651be23 100644
--- sc/inc/rangenam.hxx
+++ sc/inc/rangenam.hxx
@@ -142,7 +142,7 @@ public:
 
     SC_DLLPUBLIC BOOL			IsReference( ScRange& rRef ) const;
     BOOL			IsReference( ScRange& rRef, const ScAddress& rPos ) const;
-    BOOL			IsValidReference( ScRange& rRef ) const;
+    SC_DLLPUBLIC BOOL			IsValidReference( ScRange& rRef ) const;
     BOOL			IsRangeAtBlock( const ScRange& ) const;
 
     void 			UpdateTabRef(SCTAB nOldTable, USHORT nFlag, SCTAB nNewTable);
diff --git sc/inc/sc.hrc sc/inc/sc.hrc
index 87f02b5..d1ac237 100644
--- sc/inc/sc.hrc
+++ sc/inc/sc.hrc
@@ -592,11 +592,9 @@
 // #i59082# assign macro to shape
 #define SID_ASSIGNMACRO                 (SC_VIEW_START + 95)

-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 // #i66550# hyperlinks in shapes
 #define SID_DRAW_HLINK_EDIT             (SC_VIEW_START + 96)
 #define SID_DRAW_HLINK_DELETE           (SC_VIEW_START + 97)
-#endif

 // "Zoom / Synchronize sheets" in options dialog
 #define SID_SC_OPT_SYNCZOOM             (SC_VIEW_START + 98)
@@ -1669,6 +1669,11 @@
 #define RID_SCPAGE_FORMULA          (SC_OOO_BUILD_START + 2)
 #define HID_SCPAGE_FORMULA          (SC_OOO_BUILD_START + 3)

+// Data Form
+#define SID_DATAFORM_NEW            (SC_OOO_BUILD_START + 5) // message
+#define SID_DATA_FORM               (SC_OOO_BUILD_START + 6) // menu (in Data menu)
+#define RID_SCDLG_DATAFORM          (SC_OOO_BUILD_START + 7) // dialog
+
 #endif


diff --git sc/inc/scabstdlg.hxx sc/inc/scabstdlg.hxx
index 05ca719..e50f8cd 100644
--- sc/inc/scabstdlg.hxx
+++ sc/inc/scabstdlg.hxx
@@ -40,6 +40,8 @@
 #include "pivot.hxx"
 #include "i18npool/lang.h"
 
+#include <tabvwsh.hxx>
+
 class ScAsciiOptions;
 class ScAutoFormat;
 class ScAutoFormatData;
@@ -113,6 +115,12 @@ public:
     virtual DelCellCmd GetDelCellCmd() const = 0;
 };
 
+//for dataform
+class AbstractScDataFormDlg : public VclAbstractDialog  //add for ScDeleteCellDlg
+{
+
+};
+
 class AbstractScDeleteContentsDlg: public VclAbstractDialog  //add for ScDeleteContentsDlg
 {
 public:
@@ -309,7 +317,7 @@ public:
 class ScAbstractDialogFactory
 {
 public:
-    static ScAbstractDialogFactory* 	Create();
+	SC_DLLPUBLIC static ScAbstractDialogFactory* 	Create();
 
     virtual 	AbstractScImportAsciiDlg * CreateScImportAsciiDlg( Window* pParent, String aDatName, //add for ScImportAsciiDlg
                                                                     SvStream* pInStream, int nId,
@@ -343,6 +351,9 @@ public:
 
     virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId, BOOL bDisallowCellMove = FALSE ) = 0 ; //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell ) = 0 ; //add for ScDataFormDlg
+
     virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults = 0 ) = 0;
     virtual AbstractScFillSeriesDlg * CreateScFillSeriesDlg( Window*		pParent, //add for ScFillSeriesDlg
diff --git sc/inc/scmod.hxx sc/inc/scmod.hxx
index 6bbcff0..e0b0aa8 100644
--- sc/inc/scmod.hxx
+++ sc/inc/scmod.hxx
@@ -201,12 +201,12 @@ public:
 
     // Options:
     const ScViewOptions&	GetViewOptions	();
-    const ScDocOptions&		GetDocOptions	();
+SC_DLLPUBLIC	const ScDocOptions&		GetDocOptions	();
 SC_DLLPUBLIC	const ScAppOptions&		GetAppOptions	();
     const ScInputOptions&	GetInputOptions	();
 SC_DLLPUBLIC	const ScPrintOptions&	GetPrintOptions	();
     void					SetViewOptions	( const ScViewOptions& rOpt );
-    void					SetDocOptions	( const ScDocOptions& rOpt );
+SC_DLLPUBLIC	void					SetDocOptions	( const ScDocOptions& rOpt );
 SC_DLLPUBLIC	void					SetAppOptions	( const ScAppOptions& rOpt );
     void					SetInputOptions	( const ScInputOptions& rOpt );
     void					SetPrintOptions	( const ScPrintOptions& rOpt );
diff --git sc/inc/shapeuno.hxx sc/inc/shapeuno.hxx
index a80ad3c..1f8f1a5 100644
--- sc/inc/shapeuno.hxx
+++ sc/inc/shapeuno.hxx
@@ -52,6 +52,7 @@ namespace com { namespace sun { namespace star {
 class SdrObject;
 struct SvEventDescription;
 class ShapeUnoEventAccessImpl;
+class  ScMacroInfo;
 
 //------------------------------------------------------------------------
 
@@ -70,6 +71,7 @@ class ScShapeObj    :public ScShapeObj_Base
                     ,public ScShapeObj_TextBase
 {
 private:
+friend  ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate );
     ::com::sun::star::uno::Reference< ::com::sun::star::uno::XAggregation > mxShapeAgg;
     // cached pointers to avoid repeated queryAggregation calls:
     ::com::sun::star::beans::XPropertySet*                                  pShapePropertySet;
diff --git sc/inc/table.hxx sc/inc/table.hxx
index 0fcda21..770a5cc 100644
--- sc/inc/table.hxx
+++ sc/inc/table.hxx
@@ -87,6 +87,8 @@ class ScFlatBoolRowSegments;
 class ScFlatBoolColSegments;
 struct ScSetStringParam;
 
+typedef std::hash_map< ::rtl::OUString, rtl::OUString, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameToNameMap;
+ 
 class ScTable
 {
 private:
@@ -181,6 +183,7 @@ private:
     Color           aTabBgColor;
     USHORT			nScenarioFlags;
     BOOL			bActiveScenario;
+    NameToNameMap       localNameToGlobalName;
     bool            mbPageBreaksValid;
 
 friend class ScDocument;					// fuer FillInfo
diff --git sc/inc/unonames.hxx sc/inc/unonames.hxx
index fabd595..2ca67a1 100644
--- sc/inc/unonames.hxx
+++ sc/inc/unonames.hxx
@@ -184,6 +184,8 @@
 #define SC_UNONAME_ANCHOR           "Anchor"
 #define SC_UNONAME_HORIPOS          "HoriOrientPosition"
 #define SC_UNONAME_VERTPOS          "VertOrientPosition"
+//     #i66550 HLINK_FOR_SHAPES
+#define SC_UNONAME_HYPERLINK        "Hyperlink" 
 
 //	other cell properties
 #define SC_UNONAME_CHCOLHDR			"ChartColumnAsLabel"
@@ -529,6 +531,7 @@
 #define SC_UNO_ZOOMTYPE             "ZoomType"
 #define SC_UNO_ZOOMVALUE            "ZoomValue"
 #define SC_UNO_UPDTEMPL             "UpdateFromTemplate"
+#define SC_UNO_FILTERED_RANGE_SELECTION       "FilteredRangeSelection"
  
 /*Stampit enable/disable print cancel */
 #define SC_UNO_ALLOWPRINTJOBCANCEL  "AllowPrintJobCancel"
@@ -610,6 +613,7 @@
 #define SC_UNONAME_ADDRESS          "Address"
 #define SC_UNONAME_UIREPR           "UserInterfaceRepresentation"
 #define SC_UNONAME_PERSREPR         "PersistentRepresentation"
+#define SC_UNONAME_XL_A1_REPR       "XL_A1_Representation"
 #define SC_UNONAME_REFSHEET         "ReferenceSheet"
 
 // --> PB 2004-08-23 #i33095# Security Options
diff --git sc/inc/userdat.hxx sc/inc/userdat.hxx
index 35020f8..a4fc379 100644
--- sc/inc/userdat.hxx
+++ sc/inc/userdat.hxx
@@ -99,16 +99,12 @@ public:
     void            SetMacro( const rtl::OUString& rMacro ) { maMacro = rMacro; }
     const rtl::OUString& GetMacro() const { return maMacro; }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void            SetHlink( const rtl::OUString& rHlink ) { maHlink = rHlink; }
     const rtl::OUString& GetHlink() const { return maHlink; }
-#endif
 
 private:
     rtl::OUString   maMacro;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     rtl::OUString   maHlink;
-#endif
 };
 
 //-------------------------------------------------------------------------
diff --git sc/inc/viewuno.hxx sc/inc/viewuno.hxx
index 9d3d822..f34a962 100644
--- sc/inc/viewuno.hxx
+++ sc/inc/viewuno.hxx
@@ -199,6 +199,7 @@ private:
     XActivationEventListenerArr_Impl        aActivationListeners;
     SCTAB                                   nPreviousTab;
     sal_Bool								bDrawSelModeSet;
+    sal_Bool                                bFilteredRangeSelection;
 
     ScViewPaneObj*			GetObjectByIndex_Impl(USHORT nIndex) const;
     INT16                   GetZoom(void) const;
@@ -313,6 +314,13 @@ public:
                                 ::com::sun::star::sheet::XSpreadsheet >& xActiveSheet )
                                     throw(::com::sun::star::uno::RuntimeException);
 
+	//liuchen 2009-9-2 support expand (but not replace) the active sheet
+	virtual void SAL_CALL	selectSheet( const ::com::sun::star::uno::Reference<
+									::com::sun::star::sheet::XSpreadsheet >& xActiveSheet,
+									sal_Bool bExpand)
+										throw(::com::sun::star::uno::RuntimeException);
+	//liuchen 2009-9-2
+
                             //XEnhancedMouseClickBroadcaster
 
     virtual void SAL_CALL addEnhancedMouseClickHandler( const ::com::sun::star::uno::Reference<
diff --git sc/sdi/cellsh.sdi sc/sdi/cellsh.sdi
index 957c3d1..84b23d5 100644
--- sc/sdi/cellsh.sdi
+++ sc/sdi/cellsh.sdi
@@ -60,6 +60,7 @@ interface CellSelection
     SID_SBA_BRW_INSERT		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_SELECT_DB			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_SORT				[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
+	SID_DATA_FORM			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     FID_FILTER_OK			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_AUTO_FILTER			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_AUTOFILTER_HIDE		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
diff --git sc/sdi/drawsh.sdi sc/sdi/drawsh.sdi
index e73f447..f330474 100644
--- sc/sdi/drawsh.sdi
+++ sc/sdi/drawsh.sdi
@@ -226,9 +226,9 @@ interface TableDraw
     SID_FONTWORK_CHARACTER_SPACING_DIALOG	[ ExecMethod = ExecDrawFunc ; StateMethod = GetDrawFuncState ; ]
 
 // ISSUE66550_HLINK_FOR_SHAPES
-//    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
 }
 
 
diff --git sc/sdi/scalc.sdi sc/sdi/scalc.sdi
index 3685677..efa641a 100644
--- sc/sdi/scalc.sdi
+++ sc/sdi/scalc.sdi
@@ -1598,6 +1598,31 @@ SfxVoidItem DataSort SID_SORT
 ]
 
 //--------------------------------------------------------------------------
+SfxVoidItem DataForm SID_DATA_FORM
+()
+[
+	/* flags: */
+	AutoUpdate = FALSE,
+	Cachable = Cachable,
+	FastCall = FALSE,
+	HasCoreId = FALSE,
+	HasDialog = TRUE,
+	ReadOnlyDoc = TRUE,
+	Toggle = FALSE,
+	Container = FALSE,
+	RecordAbsolute = FALSE,
+	RecordPerSet;
+	Synchron;
+
+	/* config: */
+	AccelConfig = TRUE,
+	MenuConfig = TRUE,
+	StatusBarConfig = FALSE,
+	ToolBoxConfig = FALSE,
+	GroupId = GID_DATA;
+]
+
+//--------------------------------------------------------------------------
 SfxVoidItem DataSubTotals SID_SUBTOTALS
 ()
 [
@@ -6295,55 +6320,55 @@ SfxVoidItem StandardFonts SID_STANDARD_FONTS
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = FALSE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = TRUE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
+SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
+()
+[
+   /* flags: */
+   AutoUpdate = FALSE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = TRUE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
+
 //   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = TRUE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = FALSE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
-//   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
+()
+[
+   /* flags: */
+   AutoUpdate = TRUE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = FALSE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
+
+   /* config: */
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
 
 //--------------------------------------------------------------------------
 SfxVoidItem StandardTextAttributes SID_TEXT_STANDARD
diff --git sc/source/core/data/cell.cxx sc/source/core/data/cell.cxx
index 74d7126..ce3a9b0 100644
--- sc/source/core/data/cell.cxx
+++ sc/source/core/data/cell.cxx
@@ -51,6 +51,7 @@
 #include "recursionhelper.hxx"
 #include "postit.hxx"
 #include "externalrefmgr.hxx"
+#include "macromgr.hxx"
 #include <editeng/editobj.hxx>
 #include <svl/intitem.hxx>
 #include <editeng/flditem.hxx>
@@ -819,6 +820,8 @@ ScFormulaCell::ScFormulaCell( const ScFormulaCell& rCell, ScDocument& rDoc, cons
 ScFormulaCell::~ScFormulaCell()
 {
     pDocument->RemoveFromFormulaTree( this );
+    if (pCode->HasOpCode(ocMacro))
+        pDocument->GetMacroManager()->RemoveDependentCell(this);
 
     if (pDocument->HasExternalRefManager())
         pDocument->GetExternalRefManager()->removeRefCell(this);
@@ -1742,6 +1748,36 @@ void ScFormulaCell::InterpretTail( ScInterpretTailParameter eTailParam )
         // Reschedule verlangsamt das ganze erheblich, nur bei Prozentaenderung ausfuehren
         ScProgress::GetInterpretProgress()->SetStateCountDownOnPercent(
             pDocument->GetFormulaCodeInTree()/MIN_NO_CODES_PER_PROGRESS_UPDATE );
+
+        switch (p->GetVolatileType())
+        {
+            case ScInterpreter::VOLATILE:
+                // Volatile via built-in volatile functions.  No actions needed.
+            break;
+            case ScInterpreter::VOLATILE_MACRO:
+                // The formula contains a volatile macro.
+                pCode->SetRecalcModeAlways();
+                pDocument->PutInFormulaTree(this);
+                StartListeningTo(pDocument);
+            break;
+            case ScInterpreter::NOT_VOLATILE:
+                if (pCode->IsRecalcModeAlways())
+                {
+                    // The formula was previously volatile, but no more.
+                    EndListeningTo(pDocument);
+                    pCode->SetRecalcModeNormal();
+                }
+                else
+                {    
+                    // non-volatile formula.  End listening to the area in case 
+                    // it's listening due to macro module change.
+                    pDocument->EndListeningArea(BCA_LISTEN_ALWAYS, this);
+                }
+                pDocument->RemoveFromFormulaTree(this);
+            break;
+            default:
+                ;
+        }
     }
     else
     {
@@ -1809,7 +1845,7 @@ void __EXPORT ScFormulaCell::Notify( SvtBroadcaster&, const SfxHint& rHint)
             else
             {
                 bForceTrack = !bDirty;
-                bDirty = TRUE;
+				SetDirtyVar();
             }
             // #35962# Don't remove from FormulaTree to put in FormulaTrack to
             // put in FormulaTree again and again, only if necessary.
@@ -1832,7 +1868,7 @@ void ScFormulaCell::SetDirty()
     if ( !IsInChangeTrack() )
     {
         if ( pDocument->GetHardRecalcState() )
-            bDirty = TRUE;
+			SetDirtyVar();
         else
         {
             // Mehrfach-FormulaTracking in Load und in CompileAll
@@ -1841,7 +1877,7 @@ void ScFormulaCell::SetDirty()
             // setzen, z.B. in CompileTokenArray
             if ( !bDirty || !pDocument->IsInFormulaTree( this ) )
             {
-                bDirty = TRUE;
+				SetDirtyVar();
                 pDocument->AppendToFormulaTrack( this );
                 pDocument->TrackFormulas();
             }
@@ -1852,6 +1888,13 @@ void ScFormulaCell::SetDirty()
     }
 }
 
+void ScFormulaCell::SetDirtyVar()
+{
+	bDirty = TRUE;
+	// mark the sheet of this cell to be calculated
+	//#FIXME do we need to revert this remnant of old fake vba events? pDocument->AddCalculateTable( aPos.Tab() );
+}
+
 void ScFormulaCell::SetDirtyAfterLoad()
 {
     bDirty = TRUE;
diff --git sc/source/core/data/column3.cxx sc/source/core/data/column3.cxx
index b6ffc03..6caa91b 100644
--- sc/source/core/data/column3.cxx
+++ sc/source/core/data/column3.cxx
@@ -829,8 +829,10 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE nIndex, USHORT nFlags, ScDocument& rDestD
     bool bCloneValue    = (nFlags & IDF_VALUE) != 0;
     bool bCloneDateTime = (nFlags & IDF_DATETIME) != 0;
     bool bCloneString   = (nFlags & IDF_STRING) != 0;
+    bool bCloneSpecialBoolean  = (nFlags & IDF_SPECIAL_BOOLEAN) != 0;
     bool bCloneFormula  = (nFlags & IDF_FORMULA) != 0;
     bool bCloneNote     = (nFlags & IDF_NOTE) != 0;
+    bool bForceFormula  = false;
 
     ScBaseCell* pNew = 0;
     ScBaseCell& rSource = *pItems[nIndex].pCell;
@@ -854,7 +856,18 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE nIndex, USHORT nFlags, ScDocument& rDestD
         break;
 
         case CELLTYPE_FORMULA:
-            if (bCloneFormula)
+            if ( bCloneSpecialBoolean )
+            {
+                ScFormulaCell& rForm = (ScFormulaCell&)rSource;
+                rtl::OUStringBuffer aBuf;
+                // #TODO #FIXME do we have a localisation issue here?
+                rForm.GetFormula( aBuf );
+                rtl::OUString aVal( aBuf.makeStringAndClear() );
+                if ( aVal.equalsAscii( "=TRUE()" )
+                        || aVal.equalsAscii( "=FALSE()" ) )
+                    bForceFormula = true;
+            }
+            if (bForceFormula || bCloneFormula)
             {
                 // note will be cloned below
                 pNew = rSource.CloneWithoutNote( rDestDoc, rDestPos );
diff --git sc/source/core/data/documen2.cxx sc/source/core/data/documen2.cxx
index 1c1cf39..2153170 100644
--- sc/source/core/data/documen2.cxx
+++ sc/source/core/data/documen2.cxx
@@ -94,6 +94,7 @@
 #include "tabprotection.hxx"
 #include "formulaparserpool.hxx"
 #include "clipparam.hxx"
+#include "macromgr.hxx"
 
 using namespace com::sun::star;
 
@@ -156,6 +159,7 @@ ScDocument::ScDocument( ScDocumentMode	eMode,
         pCacheFieldEditEngine( NULL ),
         pDocProtection( NULL ),
         mpClipParam( NULL),
+        mpMacroMgr( NULL ), 
         pExternalRefMgr( NULL ),
         pViewOptions( NULL ),
         pDocOptions( NULL ),
diff --git sc/source/core/data/documen8.cxx sc/source/core/data/documen8.cxx
index bc2bf8c..1daa520 100644
--- sc/source/core/data/documen8.cxx
+++ sc/source/core/data/documen8.cxx
@@ -93,6 +93,7 @@
 #include "globstr.hrc"
 #include "sc.hrc"
 #include "charthelper.hxx"
+#include "macromgr.hxx"
 #include "dpobject.hxx"
 
 #define GET_SCALEVALUE(set,id) 	((const SfxUInt16Item&)(set.Get( id ))).GetValue()
@@ -412,6 +413,13 @@ BYTE ScDocument::GetEditTextDirection(SCTAB nTab) const
     return sal::static_int_cast<BYTE>(eRet);
 }
 
+ScMacroManager* ScDocument::GetMacroManager()
+{
+    if (!mpMacroMgr.get())
+        mpMacroMgr.reset(new ScMacroManager(this));
+    return mpMacroMgr.get();
+}
+
 //------------------------------------------------------------------------
 
 void ScDocument::InvalidateTextWidth( const ScAddress* pAdrFrom, const ScAddress* pAdrTo,
diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
index 26719e5..df271f0 100644
--- sc/source/core/data/document.cxx
+++ sc/source/core/data/document.cxx
@@ -97,6 +97,8 @@
 #include <map>
 #include <limits>
 
+using namespace ::com::sun::star;
+
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::sheet::TablePageBreakData;
@@ -184,6 +186,13 @@ BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
     return FALSE;
 }
 
+NameToNameMap*
+ScDocument::GetLocalNameMap( SCTAB& rTab )
+{
+    if ( !HasTable( rTab ) )
+        return NULL;
+    return &pTab[rTab]->localNameToGlobalName;
+}
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
@@ -448,6 +457,7 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, ScDocument* pRefUndoDoc )
                 delete pTab[nTab];
                 for (i=nTab + 1; i < nTabCount; i++)
                     pTab[i - 1] = pTab[i];
+
                 pTab[nTabCount - 1] = NULL;
                 --nMaxTableNumber;
                 // UpdateBroadcastAreas must be called between UpdateDeleteTab,
diff --git sc/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
index d80573a..b28bfc1 100644
--- sc/source/core/inc/interpre.hxx
+++ sc/source/core/inc/interpre.hxx
@@ -134,6 +134,15 @@ public:
     static inline double div( const double& fNumerator, const double& fDenominator );
 
     ScMatrixRef GetNewMat(SCSIZE nC, SCSIZE nR);
+
+    enum VolatileType { 
+        VOLATILE,   
+        VOLATILE_MACRO,
+        NOT_VOLATILE
+    };
+
+    VolatileType GetVolatileType() const;
+
 private:
     static ScTokenStack*    pGlobalStack;
     static BOOL             bGlobalStackInUse;
@@ -168,6 +177,8 @@ private:
     BOOL        bCalcAsShown;           // precision as shown
     BOOL        bMatrixFormula;         // formula cell is a matrix formula
 
+    VolatileType meVolaileType;
+
 //---------------------------------Funktionen in interpre.cxx---------
 // nMust <= nAct <= nMax ? ok : PushError
 inline BOOL MustHaveParamCount( short nAct, short nMust );
diff --git sc/source/core/tool/address.cxx sc/source/core/tool/address.cxx
index a4a77c9..78d2c31 100644
--- sc/source/core/tool/address.cxx
+++ sc/source/core/tool/address.cxx
@@ -1374,7 +1374,7 @@ lcl_ScRange_Parse_OOo( ScRange &aRange, const String& r, ScDocument* pDoc, ScAdd
     }
     nRes1 = ( ( nRes1 | nRes2 ) & SCA_VALID )
           | nRes1
-          | ( ( nRes2 & 0x070F ) << 4 );
+          | ( ( nRes2 & SCA_BITS ) << 4 );
     return nRes1;
 }
 
diff --git sc/source/core/tool/appoptio.cxx sc/source/core/tool/appoptio.cxx
index e14b16c..8f27807 100644
--- sc/source/core/tool/appoptio.cxx
+++ sc/source/core/tool/appoptio.cxx
@@ -82,6 +82,9 @@ ScAppOptions::~ScAppOptions()
 
 void ScAppOptions::SetDefaults()
 {
+	// Set default tab count for new spreadsheet.
+	nTabCountInNewSpreadsheet = 3;
+
     if ( ScOptionsUtil::IsMetricSystem() )
         eMetric		= FUNIT_CM;				// default for countries with metric system
     else
@@ -119,6 +122,7 @@ void ScAppOptions::SetDefaults()
 
 const ScAppOptions& ScAppOptions::operator=( const ScAppOptions& rCpy )
 {
+	nTabCountInNewSpreadsheet = rCpy.nTabCountInNewSpreadsheet;
     eMetric			= rCpy.eMetric;
     eZoomType		= rCpy.eZoomType;
     bSynchronizeZoom = rCpy.bSynchronizeZoom;
diff --git sc/source/core/tool/interpr1.cxx sc/source/core/tool/interpr1.cxx
index 516b96e..0d2613b 100644
--- sc/source/core/tool/interpr1.cxx
+++ sc/source/core/tool/interpr1.cxx
@@ -71,6 +71,7 @@
 #include "rangenam.hxx"
 #include "compiler.hxx"
 #include "externalrefmgr.hxx"
+#include <basic/sbstar.hxx>
 #include "doubleref.hxx"
 #include "queryparam.hxx"
 
@@ -4186,7 +4187,17 @@ void ScInterpreter::ScMatch()
                 }
             }
             if ( rEntry.bQueryByString )
-                rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            {
+		BOOL bIsVBAMode = FALSE;
+                if ( pDok ) 
+                    bIsVBAMode = pDok->IsInVBAMode();
+
+                // #TODO handle MSO wildcards
+                if ( bIsVBAMode )
+                    rParam.bRegExp = FALSE;
+                else
+                    rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            }
 
             if (pMatSrc) // The source data is matrix array.
             {
diff --git sc/source/core/tool/interpr4.cxx sc/source/core/tool/interpr4.cxx
index 901bcc4..023741b 100644
--- sc/source/core/tool/interpr4.cxx
+++ sc/source/core/tool/interpr4.cxx
@@ -33,10 +33,14 @@
 #include <sfx2/app.hxx>
 #include <sfx2/docfile.hxx>
 #include <sfx2/objsh.hxx>
+#include <sfx2/docfilt.hxx>
 #include <basic/sbmeth.hxx>
 #include <basic/sbmod.hxx>
 #include <basic/sbstar.hxx>
 #include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
+#include <svl/zforlist.hxx>
 #include <svl/zforlist.hxx>
 #include <tools/urlobj.hxx>
 #include <rtl/logfile.hxx>
@@ -45,6 +49,8 @@
 #include <signal.h>
 
 #include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <comphelper/processfactory.hxx>
 
 #include "interpre.hxx"
 #include "global.hxx"
@@ -65,6 +71,8 @@
 #include "jumpmatrix.hxx"
 #include "parclass.hxx"
 #include "externalrefmgr.hxx"
+#include "formula/FormulaCompiler.hxx"
+#include "macromgr.hxx"
 #include "doubleref.hxx"
 
 #include <math.h>
@@ -72,6 +80,8 @@
 #include <map>
 #include <algorithm>
 #include <functional>
+#include <basic/basmgr.hxx>
+#include <vbahelper/vbaaccesshelper.hxx>
 #include <memory>
 
 using namespace com::sun::star;
@@ -2694,6 +2704,61 @@ void ScInterpreter::ScMissing()
     PushTempToken( new FormulaMissingToken );
 }
 
+uno::Any lcl_getSheetModule( const uno::Reference<table::XCellRange>& xCellRange, ScDocument* pDok )
+{
+    uno::Reference< sheet::XSheetCellRange > xSheetRange( xCellRange, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xSheetRange->getSpreadsheet(), uno::UNO_QUERY_THROW );
+    rtl::OUString sCodeName;
+    xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CodeName") ) ) >>= sCodeName;
+    // #TODO #FIXME ideally we should 'throw' here if we don't get a valid parent, but... it is possible
+    // to create a module ( and use 'Option VBASupport 1' ) for a calc document, in this scenario there
+    // are *NO* special document module objects ( of course being able to switch between vba/non vba mode at 
+    // the document in the future could fix this, especially IF the switching of the vba mode takes care to 
+    // create the special document module objects if they don't exist.
+    BasicManager* pBasMgr = pDok->GetDocumentShell()->GetBasicManager();
+    
+    uno::Reference< uno::XInterface > xIf;
+    if ( pBasMgr && pBasMgr->GetName().Len() )
+    {
+        String sProj = String( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        if ( pDok->GetDocumentShell()->GetBasicManager()->GetName().Len() )
+            sProj = pDok->GetDocumentShell()->GetBasicManager()->GetName();
+        StarBASIC* pBasic = pDok->GetDocumentShell()->GetBasicManager()->GetLib( sProj );
+        if ( pBasic )
+        {
+            SbModule* pMod = pBasic->FindModule( sCodeName );
+            if ( pMod )
+                xIf = pMod->GetUnoModule();
+        }
+    }
+    return uno::makeAny( xIf );
+}
+
+bool
+lcl_setVBARange( ScRange& aRange, ScDocument* pDok, SbxVariable* pPar )
+{
+	bool bOk = false;
+	try
+	{
+		uno::Reference< uno::XInterface > xVBARange;
+		uno::Reference<table::XCellRange> xCellRange = ScCellRangeObj::CreateRangeFromDoc( pDok, aRange );
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = lcl_getSheetModule( xCellRange, pDok );
+		aArgs[1] = uno::Any( xCellRange );
+		xVBARange = ooo::vba::createVBAUnoAPIServiceWithArgs( pDok->GetDocumentShell(), "ooo.vba.excel.Range", aArgs );
+		if ( xVBARange.is() )
+		{
+			String sDummy(RTL_CONSTASCII_USTRINGPARAM("A-Range") );
+			SbxObjectRef aObj = GetSbUnoObject( sDummy, uno::Any( xVBARange ) );
+			SetSbUnoObjectDfltPropName( aObj );
+			bOk = pPar->PutObject( aObj );
+		}
+	}
+	catch( uno::Exception& )
+	{
+	}
+	return bOk;
+}
 
 void ScInterpreter::ScMacro()
 {
@@ -2731,8 +2796,11 @@ void ScInterpreter::ScMacro()
         return;
     }
 
+    bool bVolatileMacro = false; 
     SbMethod* pMethod = (SbMethod*)pVar;
+
     SbModule* pModule = pMethod->GetModule();
+	bool bUseVBAObjects = pModule->IsVBACompat();
     SbxObject* pObject = pModule->GetParent();
     DBG_ASSERT(pObject->IsA(TYPE(StarBASIC)), "Kein Basic gefunden!");
     String aMacroStr = pObject->GetName();
@@ -2742,7 +2810,13 @@ void ScInterpreter::ScMacro()
     aMacroStr += pMethod->GetName();
     String aBasicStr;
     if (pObject->GetParent())
+	{
         aBasicStr = pObject->GetParent()->GetName();    // Dokumentenbasic
+		const SfxFilter* pFilter = NULL;
+		SfxMedium* pMedium = pDok->GetDocumentShell()->GetMedium();
+		if ( pMedium )
+			pFilter = pMedium->GetFilter();
+	}
     else
         aBasicStr = SFX_APP()->GetName();               // Applikationsbasic
 
@@ -2766,7 +2840,13 @@ void ScInterpreter::ScMacro()
             {
                 ScAddress aAdr;
                 PopSingleRef( aAdr );
-                bOk = SetSbxVariable( pPar, aAdr );
+				if ( bUseVBAObjects )
+				{
+					ScRange aRange( aAdr );
+					bOk = lcl_setVBARange( aRange, pDok, pPar );
+				}
+				else
+					bOk = SetSbxVariable( pPar, aAdr );
             }
             break;
             case svDoubleRef:
@@ -2785,24 +2865,32 @@ void ScInterpreter::ScMacro()
                 }
                 else
                 {
-                    SbxDimArrayRef refArray = new SbxDimArray;
-                    refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
-                    refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
-                    ScAddress aAdr( nCol1, nRow1, nTab1 );
-                    for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+					if ( bUseVBAObjects )
                     {
-                        aAdr.SetRow( nRow );
-                        INT32 nIdx[ 2 ];
-                        nIdx[ 0 ] = nRow-nRow1+1;
-                        for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
-                        {
-                            aAdr.SetCol( nCol );
-                            nIdx[ 1 ] = nCol-nCol1+1;
-                            SbxVariable* p = refArray->Get32( nIdx );
-                            bOk = SetSbxVariable( p, aAdr );
+						ScRange aRange( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
+						bOk = lcl_setVBARange( aRange, pDok, pPar );
+					}
+					else
+					{
+						SbxDimArrayRef refArray = new SbxDimArray;
+						refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
+						refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
+						ScAddress aAdr( nCol1, nRow1, nTab1 );
+						for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+						{
+							aAdr.SetRow( nRow );
+							INT32 nIdx[ 2 ];
+							nIdx[ 0 ] = nRow-nRow1+1;
+							for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
+							{
+								aAdr.SetCol( nCol );
+								nIdx[ 1 ] = nCol-nCol1+1;
+								SbxVariable* p = refArray->Get32( nIdx );
+								bOk = SetSbxVariable( p, aAdr );
+							}
                         }
+						pPar->PutObject( refArray );
                     }
-                    pPar->PutObject( refArray );
                 }
             }
             break;
@@ -2850,6 +2938,13 @@ void ScInterpreter::ScMacro()
         pDok->DecMacroInterpretLevel();
         pDok->UnlockTable( aPos.Tab() );
 
+        ScMacroManager* pMacroMgr = pDok->GetMacroManager();
+        if (pMacroMgr)
+        {
+            bVolatileMacro = pMacroMgr->GetUserFuncVolatile( pMethod->GetName() );
+            pMacroMgr->AddDependentCell(pModule->GetName(), pMyFormulaCell);
+        }
+
         SbxDataType eResType = refRes->GetType();
         if( pVar->GetError() )
             SetError( errNoValue);
@@ -2921,6 +3016,9 @@ void ScInterpreter::ScMacro()
     }
 
     pSfxApp->LeaveBasicCall();
+
+    if (bVolatileMacro && meVolaileType == NOT_VOLATILE)
+        meVolaileType = VOLATILE_MACRO;
 }
 
 
@@ -3293,7 +3391,8 @@ ScInterpreter::ScInterpreter( ScFormulaCell* pCell, ScDocument* pDoc,
     pMyFormulaCell( pCell ),
     pFormatter( pDoc->GetFormatTable() ),
     mnStringNoValueError( errNoValue),
-    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() )
+    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() ),
+    meVolaileType(NOT_VOLATILE)
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "sc", "er", "ScInterpreter::ScTTT" );
 //  pStack = new ScToken*[ MAXSTACK ];
@@ -3740,6 +3839,9 @@ StackVar ScInterpreter::Interpret()
                 continue;   // while( ( pCur = aCode.Next() ) != NULL  ...
             }
 
+            if (FormulaCompiler::IsOpCodeVolatile(eOp))
+                meVolaileType = VOLATILE;
+
             // Remember result matrix in case it could be reused.
             if (pTokenMatrixMap && sp && GetStackType() == svMatrix)
                 pTokenMatrixMap->insert( ScTokenMatrixMap::value_type( pCur,
diff --git sc/source/core/tool/interpr5.cxx sc/source/core/tool/interpr5.cxx
index 3bf95dc..af98bd1 100644
--- sc/source/core/tool/interpr5.cxx
+++ sc/source/core/tool/interpr5.cxx
@@ -321,6 +321,11 @@ ScMatrixRef ScInterpreter::GetNewMat(SCSIZE nC, SCSIZE nR)
     return pMat;
 }
 
+ScInterpreter::VolatileType ScInterpreter::GetVolatileType() const
+{
+    return meVolaileType;
+}
+
 ScMatrixRef ScInterpreter::CreateMatrixFromDoubleRef( const FormulaToken* pToken,
         SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
         SCCOL nCol2, SCROW nRow2, SCTAB nTab2 )
diff --git sc/source/core/tool/rangelst.cxx sc/source/core/tool/rangelst.cxx
index 6bd25c5..b4d5866 100644
--- sc/source/core/tool/rangelst.cxx
+++ sc/source/core/tool/rangelst.cxx
@@ -83,15 +83,18 @@ USHORT ScRangeList::Parse( const String& rStr, ScDocument* pDoc, USHORT nMask,
         for ( USHORT i=0; i<nTCount; i++ )
         {
             aOne = rStr.GetToken( i, cDelimiter );
-            // FIXME : broken for Lotus
-            if ( aOne.Search( ':' ) == STRING_NOTFOUND )
-            {	// Range muss es sein
-                String aStrTmp( aOne );
-                aOne += ':';
-                aOne += aStrTmp;
-            }
             aRange.aStart.SetTab( nTab );	// Default Tab wenn nicht angegeben
-            USHORT nRes = aRange.Parse( aOne, pDoc, eConv );
+			USHORT nRes = aRange.ParseAny( aOne, pDoc, eConv );
+			USHORT nEndRangeBits = SCA_VALID_COL2 | SCA_VALID_ROW2 |
+SCA_VALID_TAB2;
+			USHORT nTmp1 = ( nRes & SCA_BITS );
+			USHORT nTmp2 = ( nRes & nEndRangeBits );
+			// If we have a valid single range with
+			// any of the address bits we are interested in
+			// set - set the equiv end range bits
+			if ( (nRes & SCA_VALID ) && nTmp1 && ( nTmp2 != nEndRangeBits ) )
+					nRes |= ( nTmp1 << 4 );
+	
             if ( (nRes & nMask) == nMask )
                 Append( aRange );
             nResult &= nRes;		// alle gemeinsamen Bits bleiben erhalten
diff --git sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
index a601d76..6083116 100644
--- sc/source/filter/excel/excimp8.cxx
+++ sc/source/filter/excel/excimp8.cxx
@@ -99,15 +99,20 @@
 #include "stlpool.hxx"
 #include "stlsheet.hxx"
 #include "detfunc.hxx"
+#include "macromgr.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 #include <cppuhelper/component_context.hxx>
 #include <sfx2/app.hxx>
+#include "xltoolbar.hxx"
 
 using namespace com::sun::star;
 using ::rtl::OUString;
 
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
     ImportExcel( rImpData, rStrm )
@@ -242,7 +247,30 @@ void ImportExcel8::ReadBasic( void )
         {
             SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
             bool bAsComment = !bLoadExecutable;
+
+            if ( !bAsComment )
+            {
+                ScDocument& rDoc = GetDoc();
+#if 1
+                // see if we have the XCB stream
+                SvStorageStreamRef xXCB = xRootStrg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "XCB" ) ), STREAM_STD_READ | STREAM_NOCREATE  );
+                if ( xXCB.Is()|| SVSTREAM_OK == xXCB->GetError() )
+                {
+                    CTBWrapper wrapper;
+                    if ( wrapper.Read( xXCB ) )
+                    {
+#if DEBUG
+                        wrapper.Print( stderr ); 
+#endif
+                        wrapper.ImportCustomToolBar( *pShell );
+                    }
+                }
+#endif
+
+            }
             aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, bAsComment );
+            if ( !bAsComment )
+                GetObjectManager().SetOleNameOverrideInfo( aBasicImport.ControlNameForObjectId() );
         }
     }
 }
diff --git sc/source/filter/excel/makefile.mk sc/source/filter/excel/makefile.mk
index 04ba76d..a84f4aa 100644
--- sc/source/filter/excel/makefile.mk
+++ sc/source/filter/excel/makefile.mk
@@ -102,7 +102,8 @@ SLOFILES =	\
         $(SLO)$/xlstyle.obj					\
         $(SLO)$/xltools.obj					\
         $(SLO)$/xltracer.obj				\
-        $(SLO)$/xlview.obj
+		$(SLO)$/xlview.obj \
+		$(SLO)$/xltoolbar.obj \
 
 .IF "$(OS)$(COM)$(CPUNAME)"=="LINUXGCCSPARC"
 NOOPTFILES = \
@@ -151,6 +152,7 @@ EXCEPTIONSFILES = \
         $(SLO)$/xlpivot.obj					\
         $(SLO)$/xlroot.obj					\
         $(SLO)$/xlstyle.obj					\
+		$(SLO)$/xltoolbar.obj \
         $(SLO)$/xltools.obj					\
         $(SLO)$/xlview.obj
 
diff --git sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
index 5b67513..b43b581 100644
--- sc/source/filter/excel/read.cxx
+++ sc/source/filter/excel/read.cxx
@@ -831,6 +831,12 @@ FltError ImportExcel8::Read( void )
     sal_Size nProgressBasePos = 0;
     sal_Size nProgressBaseSize = 0;
 
+    bool bSheetHasCodeName = false;
+
+    std::vector< String > CodeNames;
+
+    std::vector < SCTAB > nTabsWithNoCodeName;
+
     while( eAkt != EXC_STATE_END )
     {
         if( eAkt == EXC_STATE_BEFORE_SHEET )
@@ -912,6 +918,7 @@ FltError ImportExcel8::Read( void )
                         // #i62752# possible to have BIFF8 sheet without globals
                         NeueTabelle();
                         eAkt = EXC_STATE_SHEET_PRE;  // Shrfmla Prefetch, Row-Prefetch
+                        bSheetHasCodeName = false; // reset
                         aIn.StoreGlobalPosition();
                     }
                 }
@@ -1082,12 +1089,32 @@ FltError ImportExcel8::Read( void )
                     case EXC_ID2_DIMENSIONS:
                     case EXC_ID3_DIMENSIONS:    ReadDimensions();                       break;
 
-                    case EXC_ID_CODENAME:       ReadCodeName( aIn, false );             break;
+                    case EXC_ID_CODENAME:       ReadCodeName( aIn, false ); bSheetHasCodeName = true; break;
 
                     case 0x0A:                          // EOF          [ 2345   ]
+                    {
                         eAkt = EXC_STATE_SHEET;
+                        String sName;
+                        GetDoc().GetName( GetCurrScTab(), sName );
+                        if ( !bSheetHasCodeName )
+                        {
+                            nTabsWithNoCodeName.push_back( GetCurrScTab() );
+                            OSL_TRACE("No Codename for %d", GetCurrScTab() );
+                        }
+                        else
+                        {
+                            String sCodeName;
+                            GetDoc().GetCodeName( GetCurrScTab(), sCodeName );
+                            OSL_TRACE("Have CodeName %s for SheetName %s",
+                                rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                            CodeNames.push_back( sCodeName );
+                        }
+
+                        bSheetHasCodeName = false; // reset
+
                         aIn.SeekGlobalPosition();         // und zurueck an alte Position
                         break;
+                    }
                     case 0x12:  SheetProtect(); break;
                     case 0x13:  SheetPassword(); break;
                     case 0x42:  Codepage(); break;      // CODEPAGE     [ 2345   ]
@@ -1206,6 +1233,42 @@ FltError ImportExcel8::Read( void )
 
     if( eLastErr == eERR_OK )
     {
+        // In some strange circumstances a the codename might be missing
+        // # Create any missing Sheet CodeNames
+        std::vector < SCTAB >::iterator it_end = nTabsWithNoCodeName.end();
+        for ( std::vector < SCTAB >::iterator it = nTabsWithNoCodeName.begin(); it != it_end; ++it )
+        {
+            bool bGotCodeName = false;
+            SCTAB nTab = 1;
+            OSL_TRACE("Trying to find suitable codename for %d", *it );
+            while ( true )
+            {
+                String sTmpName( RTL_CONSTASCII_USTRINGPARAM("Sheet" ) );
+                sTmpName += String::CreateFromInt32( sal_Int32(nTab++) );
+                std::vector< String >::iterator codeName_It = CodeNames.begin();
+                std::vector< String >::iterator codeName_It_end = CodeNames.end();
+                // search for codename
+                for ( ; codeName_It != codeName_It_end; ++codeName_It )
+                {
+                    if ( *codeName_It == sTmpName )
+                        break;
+                }
+
+                if ( codeName_It == codeName_It_end ) // generated codename not found
+                {
+                    OSL_TRACE("Using generated codename %s", rtl::OUStringToOString( sTmpName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    // Set new codename
+                    GetDoc().SetCodeName( *it, sTmpName );
+                    // Record newly used codename
+                    CodeNames.push_back( sTmpName );
+                    // Record those we have created so they can be created in
+                    // basic
+                    AutoGeneratedCodeNames.push_back( sTmpName );
+                    break;
+                }
+            }
+            
+        }
         // #i45843# Convert pivot tables before calculation, so they are available
         // for the GETPIVOTDATA function.
         if( GetBiff() == EXC_BIFF8 )
diff --git sc/source/filter/excel/xecontent.cxx sc/source/filter/excel/xecontent.cxx
index c5c2620..f71c8be 100644
--- sc/source/filter/excel/xecontent.cxx
+++ sc/source/filter/excel/xecontent.cxx
@@ -524,12 +524,17 @@ void XclExpHyperlink::WriteBody( XclExpStream& rStrm )
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
     sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
-    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
+    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
+    WriteEmbeddedData( rStrm );
+}
 
-    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol
-            << XclTools::maGuidStdLink
+void XclExpHyperlink::WriteEmbeddedData( XclExpStream& rStrm )
+{
+    rStrm << XclTools::maGuidStdLink
             << sal_uInt32( 2 )
             << mnFlags;
+
+    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( *mxVarData );
 }
 
diff --git sc/source/filter/excel/xeescher.cxx sc/source/filter/excel/xeescher.cxx
index 27461d2..7b4fc27 100644
--- sc/source/filter/excel/xeescher.cxx
+++ sc/source/filter/excel/xeescher.cxx
@@ -63,6 +63,9 @@
 #include "xelink.hxx"
 #include "xename.hxx"
 #include "xestyle.hxx"
+#include "userdat.hxx"
+#include "drwlayer.hxx"
+#include "svx/unoapi.hxx"
 
 #include <oox/core/tokens.hxx>
 
@@ -484,9 +487,9 @@ void XclExpOcxControlObj::WriteSubRecs( XclExpStream& rStrm )
 
 #else
 
-XclExpTbxControlObj::XclExpTbxControlObj( XclExpObjectManager& rObjMgr, Reference< XShape > xShape, const Rectangle* pChildAnchor ) :
-    XclObj( rObjMgr, EXC_OBJTYPE_UNKNOWN, true ),
-    XclExpControlHelper( rObjMgr.GetRoot() ),
+XclExpTbxControlObj::XclExpTbxControlObj( XclExpObjectManager& rRoot, Reference< XShape > xShape , const Rectangle* pChildAnchor ) :
+    XclObj( rRoot, EXC_OBJTYPE_UNKNOWN, true ),
+    XclMacroHelper( rRoot ),
     mnHeight( 0 ),
     mnState( 0 ),
     mnLineCount( 0 ),
@@ -735,6 +738,8 @@ XclExpTbxControlObj::XclExpTbxControlObj( XclExpObjectManager& rObjMgr, Referenc
 
 bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
 {
+    return XclMacroHelper::SetMacroLink( rEvent, meEventType );
+/*
     String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, meEventType );
     if( aMacroName.Len() )
     {
@@ -744,6 +749,7 @@ bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
         return true;
     }
     return false;
+*/
 }
 
 void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
@@ -884,12 +890,6 @@ void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
     }
 }
 
-void XclExpTbxControlObj::WriteMacroSubRec( XclExpStream& rStrm )
-{
-    if( mxMacroLink.is() )
-        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
-}
-
 void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId )
 {
     if( const XclTokenArray* pCellLink = GetCellLinkTokArr() )
@@ -918,6 +918,7 @@ void XclExpTbxControlObj::WriteSbs( XclExpStream& rStrm )
 
 #endif
 
+
 // ----------------------------------------------------------------------------
 
 XclExpChartObj::XclExpChartObj( XclExpObjectManager& rObjMgr, Reference< XShape > xShape, const Rectangle* pChildAnchor ) :
@@ -1061,6 +1062,7 @@ void XclExpNote::Save( XclExpStream& rStrm )
     }
 }
 
+
 void XclExpNote::WriteBody( XclExpStream& rStrm )
 {
     // BIFF5/BIFF7 is written separately
@@ -1097,6 +1099,72 @@ void XclExpNote::WriteXml( sal_Int32 nAuthorId, XclExpXmlStream& rStrm )
 
 // ============================================================================
 
+XclMacroHelper::XclMacroHelper( const XclExpRoot& rRoot ) :
+    XclExpControlHelper( rRoot )
+{
+}
+
+XclMacroHelper::~XclMacroHelper()
+{
+}
+
+void XclMacroHelper::WriteMacroSubRec( XclExpStream& rStrm )
+{
+    if( mxMacroLink.is() )
+        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
+}
+
+bool 
+XclMacroHelper::SetMacroLink( const ScriptEventDescriptor& rEvent, const XclTbxEventType& nEventType )
+{
+    String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, nEventType, GetDocShell() );
+    if( aMacroName.Len() )
+    {
+        return SetMacroLink( aMacroName );
+    }
+    return false;
+}
+
+bool
+XclMacroHelper::SetMacroLink( const String& rMacroName )
+{
+    OSL_TRACE("SetMacroLink( macroname:=%s )", rtl::OUStringToOString( rMacroName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( rMacroName.Len() )
+    {
+        sal_uInt16 nExtSheet = GetLocalLinkManager().FindExtSheet( EXC_EXTSH_OWNDOC );
+        sal_uInt16 nNameIdx = GetNameManager().InsertMacroCall( rMacroName, true, false );
+        mxMacroLink = GetFormulaCompiler().CreateNameXFormula( nExtSheet, nNameIdx );
+        return true;
+    }
+    return false;
+}
+
+XclExpShapeObj::XclExpShapeObj( XclExpObjectManager& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape ) : 
+    XclObjAny( rRoot ),
+    XclMacroHelper( rRoot )
+{
+    if( SdrObject* pSdrObj = ::GetSdrObjectFromXShape( xShape ) )
+    {
+        ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pSdrObj );
+        if ( pInfo && pInfo->GetMacro().getLength() )
+// FIXME ooo330-m2: XclControlHelper::GetXclMacroName was removed in upstream sources; they started to call XclTools::GetXclMacroName instead; is this enough? it has only one parameter
+//            SetMacroLink( XclControlHelper::GetXclMacroName( pInfo->GetMacro(), rRoot.GetDocShell() ) ); 
+            SetMacroLink( XclTools::GetXclMacroName( pInfo->GetMacro() ) );
+    }
+}
+
+XclExpShapeObj::~XclExpShapeObj()
+{
+}
+
+void XclExpShapeObj::WriteSubRecs( XclExpStream& rStrm )
+{
+    XclObjAny::WriteSubRecs( rStrm );
+    WriteMacroSubRec( rStrm );
+}
+
+// ============================================================================
+
 XclExpComments::XclExpComments( SCTAB nTab, XclExpRecordList< XclExpNote >& rNotes )
     : mnTab( nTab ), mrNotes( rNotes )
 {
diff --git sc/source/filter/excel/xiescher.cxx sc/source/filter/excel/xiescher.cxx
index 2106ac1..5ba8fe4 100644
--- sc/source/filter/excel/xiescher.cxx
+++ sc/source/filter/excel/xiescher.cxx
@@ -109,6 +109,8 @@
 #include "xipage.hxx"
 #include "xichart.hxx"
 #include "xicontent.hxx"
+#include "scextopt.hxx"
+
 #include "namebuff.hxx"
 
 using ::rtl::OUString;
@@ -236,6 +238,7 @@ XclImpDrawObjBase::~XclImpDrawObjBase()
         }
     }
 
+    xDrawObj->mnTab = rRoot.GetCurrScTab();
     xDrawObj->ImplReadObj3( rStrm );
     return xDrawObj;
 }
@@ -268,6 +271,7 @@ XclImpDrawObjBase::~XclImpDrawObjBase()
         }
     }
 
+    xDrawObj->mnTab = rRoot.GetCurrScTab();
     xDrawObj->ImplReadObj4( rStrm );
     return xDrawObj;
 }
@@ -310,6 +314,7 @@ XclImpDrawObjBase::~XclImpDrawObjBase()
         }
     }
 
+    xDrawObj->mnTab = rRoot.GetCurrScTab();
     xDrawObj->ImplReadObj5( rStrm );
     return xDrawObj;
 }
@@ -368,6 +373,7 @@ XclImpDrawObjBase::~XclImpDrawObjBase()
         }
     }
 
+    xDrawObj->mnTab = rRoot.GetCurrScTab();
     xDrawObj->ImplReadObj8( rStrm );
     return xDrawObj;
 }
@@ -468,8 +474,8 @@ void XclImpDrawObjBase::PreProcessSdrObject( XclImpDffConverter& rDffConv, SdrOb
     }
 
     // macro and hyperlink
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    if( mbSimpleMacro && ((maMacroName.Len() > 0) || (maHyperlink.getLength() > 0)) )
+    if( mbSimpleMacro && ((maMacroName.Len() > 0) ||
+ (maHyperlink.Len() > 0)) )
     {
         if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
         {
@@ -477,11 +483,6 @@ void XclImpDrawObjBase::PreProcessSdrObject( XclImpDffConverter& rDffConv, SdrOb
             pInfo->SetHlink( maHyperlink );
         }
     }
-#else
-    if( mbSimpleMacro && (maMacroName.Len() > 0) )
-        if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
-            pInfo->SetMacro( XclTools::GetSbMacroUrl( maMacroName, GetDocShell() ) );
-#endif
 
     // call virtual function for object type specific processing
     DoPreProcessSdrObj( rDffConv, rSdrObj );
@@ -1761,22 +1762,15 @@ SdrObject* XclImpControlHelper::CreateSdrObjectFromShape(
     return xSdrObj.release();
 }
 
-void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+void XclImpControlHelper::ApplySheetLinkProps() const
 {
+
     Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
     if( !xCtrlModel.is() )
         return;
-
     ScfPropertySet aPropSet( xCtrlModel );
 
-    // #118053# #i51348# set object name at control model
-    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
-
-    // control visible and printable?
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
-
-    // sheet links
+   // sheet links
     if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
     {
         Reference< XMultiServiceFactory > xFactory( pDocShell->GetModel(), UNO_QUERY );
@@ -1839,7 +1833,26 @@ void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) co
             }
         }
     }
+}
+
+void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+{
+    Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
+    if( !xCtrlModel.is() )
+        return;
+
+    ApplySheetLinkProps();
+
+    ScfPropertySet aPropSet( xCtrlModel );
+
+    // #118053# #i51348# set object name at control model
+    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
+
+    // control visible and printable?
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
 
+ 
     // virtual call for type specific processing
     DoProcessControl( aPropSet );
 }
@@ -2170,6 +2183,45 @@ void XclImpOptionButtonObj::DoProcessControl( ScfPropertySet& rPropSet ) const
 {
     XclImpCheckBoxObj::DoProcessControl( rPropSet );
     // TODO: grouping
+    XclImpOptionButtonObj* pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().GetSheetDrawing( GetTab() ).FindDrawObj( mnNextInGroup ).get() );
+    if ( ( pTbxObj && pTbxObj->mnFirstInGroup ) )
+    {
+        // Group has terminated
+        // traverse each RadioButton in group and 
+        //     a) apply the groupname 
+        //     b) propagate the linked cell from the lead radiobutton
+        //     c) apply the correct Ref value
+        XclImpOptionButtonObj* pLeader = pTbxObj;
+ ;
+        sal_Int32 nRefVal = 1;
+        OSL_TRACE( "0x%x start group ", pLeader->GetObjId()/*.mnObjId */);
+        do 
+        {
+           
+            Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( pTbxObj->mxShape );
+            if ( xCtrlModel.is() )
+            {
+                ScfPropertySet aProps( xCtrlModel );
+                rtl::OUString sGroupName = rtl::OUString::valueOf( static_cast< sal_Int32 >( pLeader->GetDffShapeId() ) );
+
+                aProps.SetStringProperty( CREATE_OUSTRING( "GroupName" ), sGroupName );
+                aProps.SetStringProperty( CREATE_OUSTRING( "RefValue" ), rtl::OUString::valueOf( nRefVal++ ) );
+                if ( pLeader->HasCellLink() && !pTbxObj->HasCellLink() )
+                {
+                    // propagate cell link info
+                    pTbxObj->mxCellLink.reset( new ScAddress( *pLeader->mxCellLink.get() ) );                
+                    pTbxObj->ApplySheetLinkProps();
+                }
+                pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().GetSheetDrawing( GetTab() ).FindDrawObj( pTbxObj->mnNextInGroup ).get() );
+            }
+            else
+                pTbxObj = NULL;
+        } while ( pTbxObj && !( pTbxObj->mnFirstInGroup == 1 ) );
+    }
+    else
+    {
+        // not the leader? try and find it
+    }
 }
 
 OUString XclImpOptionButtonObj::DoGetServiceName() const
@@ -2806,6 +2858,17 @@ SdrObject* XclImpPictureObj::DoCreateSdrObj( XclImpDffConverter& rDffConv, const
     return xSdrObj.release();
 }
 
+String XclImpPictureObj::GetObjName() const
+{
+    if( IsOcxControl() )
+    {
+        String sName( GetObjectManager().GetOleNameOverride( GetTab(), GetObjId() ) );
+        if ( sName.Len() > 0 )
+            return sName;
+    }
+    return XclImpDrawObjBase::GetObjName();
+}
+
 void XclImpPictureObj::DoPreProcessSdrObj( XclImpDffConverter& rDffConv, SdrObject& rSdrObj ) const
 {
     if( IsOcxControl() )
@@ -3120,6 +3183,27 @@ XclImpDffConverter::~XclImpDffConverter()
 {
 }
 
+String XclImpObjectManager::GetOleNameOverride( SCTAB nTab, sal_uInt16 nObjId )
+{
+    String sOleName; 
+    String sCodeName = GetExtDocOptions().GetCodeName( nTab );
+    
+    CodeNameToCntrlObjIdInfo::iterator it = maOleCtrlNameOverride.find( sCodeName );
+    if ( it != maOleCtrlNameOverride.end() )
+    {
+        CntrlObjIdToName::iterator it_id = it->second.find( nObjId );
+        if ( it_id != it->second.end() )
+        {
+            sOleName = it_id->second;
+        }
+    }
+    OSL_TRACE("XclImpObjectManager::GetOleNameOverride tab %d, ( module %s ) object id ( %d ) is %s", nTab,
+        rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(), nObjId,
+        rtl::OUStringToOString( sOleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        
+    return sOleName;
+}
+
 void XclImpDffConverter::StartProgressBar( sal_Size nProgressSize )
 {
     mxProgress.reset( new ScfProgressBar( GetDocShell(), STR_PROGRESS_CALCULATING ) );
@@ -3990,27 +4074,27 @@ XclImpObjectManager::XclImpObjectManager( const XclImpRoot& rRoot ) :
     XclImpRoot( rRoot )
 {
     maDefObjNames[ EXC_OBJTYPE_GROUP ]          = CREATE_STRING( "Group" );
-    maDefObjNames[ EXC_OBJTYPE_LINE ]           = CREATE_STRING( "Line" );
-    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = CREATE_STRING( "Rectangle" );
-    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = CREATE_STRING( "Oval" );
+    maDefObjNames[ EXC_OBJTYPE_LINE ]           = ScGlobal::GetRscString( STR_SHAPE_LINE );
+    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = ScGlobal::GetRscString( STR_SHAPE_RECTANGLE );
+    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = ScGlobal::GetRscString( STR_SHAPE_OVAL );
     maDefObjNames[ EXC_OBJTYPE_ARC ]            = CREATE_STRING( "Arc" );
     maDefObjNames[ EXC_OBJTYPE_CHART ]          = CREATE_STRING( "Chart" );
     maDefObjNames[ EXC_OBJTYPE_TEXT ]           = CREATE_STRING( "Text" );
-    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         = CREATE_STRING( "Button" );
+    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         =  ScGlobal::GetRscString( STR_FORM_BUTTON );
     maDefObjNames[ EXC_OBJTYPE_PICTURE ]        = CREATE_STRING( "Picture" );
     maDefObjNames[ EXC_OBJTYPE_POLYGON ]        = CREATE_STRING( "Freeform" );
-    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = CREATE_STRING( "Check Box" );
-    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = CREATE_STRING( "Option Button" );
+    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = ScGlobal::GetRscString( STR_FORM_CHECKBOX ); 
+    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = ScGlobal::GetRscString( STR_FORM_OPTIONBUTTON );
     maDefObjNames[ EXC_OBJTYPE_EDIT ]           = CREATE_STRING( "Edit Box" );
-    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = CREATE_STRING( "Label" );
+    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = ScGlobal::GetRscString( STR_FORM_LABEL );
     maDefObjNames[ EXC_OBJTYPE_DIALOG ]         = CREATE_STRING( "Dialog Frame" );
-    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = CREATE_STRING( "Spinner" );
-    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = CREATE_STRING( "Scroll Bar" );
-    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = CREATE_STRING( "List Box" );
-    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = CREATE_STRING( "Group Box" );
-    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = CREATE_STRING( "Drop Down" );
+    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = ScGlobal::GetRscString( STR_FORM_SPINNER );
+    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = ScGlobal::GetRscString( STR_FORM_SCROLLBAR );
+    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = ScGlobal::GetRscString( STR_FORM_LISTBOX );
+    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = ScGlobal::GetRscString( STR_FORM_GROUPBOX );
+    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = ScGlobal::GetRscString( STR_FORM_DROPDOWN );
     maDefObjNames[ EXC_OBJTYPE_NOTE ]           = CREATE_STRING( "Comment" );
-    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = CREATE_STRING( "AutoShape" );
+    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = ScGlobal::GetRscString( STR_SHAPE_AUTOSHAPE );
 }
 
 XclImpObjectManager::~XclImpObjectManager()
diff --git sc/source/filter/excel/xiname.cxx sc/source/filter/excel/xiname.cxx
index 38e08b0..94e0b77 100644
--- sc/source/filter/excel/xiname.cxx
+++ sc/source/filter/excel/xiname.cxx
@@ -35,7 +35,8 @@
 #include "excform.hxx"
 // for filter manager
 #include "excimp8.hxx"
-
+#include "scextopt.hxx"
+#include "document.hxx"
 // ============================================================================
 // *** Implementation ***
 // ============================================================================
@@ -127,6 +128,7 @@ XclImpName::XclImpName( XclImpStream& rStrm, sal_uInt16 nXclNameIdx ) :
         maScName = maXclName;
         ScfTools::ConvertToScDefinedName( maScName );
     }
+    rtl::OUString aRealOrigName = maScName;
 
     // add index for local names
     if( nXclTab != EXC_NAME_GLOBAL )
@@ -219,6 +221,25 @@ XclImpName::XclImpName( XclImpStream& rStrm, sal_uInt16 nXclNameIdx ) :
         pData->GuessPosition();             // calculate base position for relative refs
         pData->SetIndex( nXclNameIdx );     // used as unique identifier in formulas
         rRangeNames.Insert( pData );        // takes ownership of pData
+        if( nXclTab != EXC_NAME_GLOBAL )
+        {
+            if (GetBiff() == EXC_BIFF8)
+            {
+                ScRange aRange;
+                // discard deleted ranges ( for the moment at least )
+                if ( pData->IsValidReference( aRange ) )
+                {
+                    ScExtTabSettings& rTabSett = GetExtDocOptions().GetOrCreateTabSettings( nXclTab );
+                    // create a mapping between the unmodified localname to
+                    // the name in the global name container for named ranges
+                    OSL_TRACE(" mapping local name to global name for tab %d which exists? %s", nXclTab, GetDoc().HasTable( mnScTab ) ? "true" : "false" );
+                    SCTAB nTab( static_cast< SCTAB >( mnScTab ) );
+                    NameToNameMap* pMap = GetDoc().GetLocalNameMap( nTab );
+                    if ( pMap )
+                       (*pMap)[ aRealOrigName ] = maScName;
+                }
+            }
+        }
         mpScData = pData;                   // cache for later use
     }
 }
diff --git sc/source/filter/excel/xistyle.cxx sc/source/filter/excel/xistyle.cxx
index b1ce3a0..fdd537a 100644
--- sc/source/filter/excel/xistyle.cxx
+++ sc/source/filter/excel/xistyle.cxx
@@ -65,10 +65,70 @@
 #include "root.hxx"
 #include "colrowst.hxx"
 
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
+typedef ::std::vector< ColorData > ColorDataVec;
+
+class PaletteIndex : public XIndexAccess_BASE
+{
+public:
+    PaletteIndex( const ColorDataVec& rColorDataTable ) : maColorData( rColorDataTable ) {}
+
+    // Methods XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
+    {
+         return  maColorData.size();
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        //--Index;  // apparently the palette is already 1 based
+        return uno::makeAny( sal_Int32( maColorData[ Index ] ) );
+    }
+
+    // Methods XElementAcess
+    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (sal_Int32*)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
+    {
+        return (maColorData.size() > 0);
+    }
+
+private:
+    ColorDataVec        maColorData; 
+};
+
+void
+XclImpPalette::ExportPalette()
+{
+    if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
+    {
+        // copy values in color palette
+        sal_Int16 nColors =  maColorTable.size();
+        ColorDataVec aColors;
+        aColors.resize( nColors );
+        for( sal_uInt16 nIndex = 0; nIndex < nColors; ++nIndex )
+            aColors[ nIndex ] = GetColorData( nIndex );
+
+        uno::Reference< beans::XPropertySet > xProps( pDocShell->GetModel(), uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            uno::Reference< container::XIndexAccess > xIndex( new PaletteIndex( aColors ) ); 
+            xProps->setPropertyValue( CREATE_OUSTRING("ColorPalette"), uno::makeAny( xIndex ) ); 
+        }
+    }
+            
+}
 // PALETTE record - color information =========================================
 
 XclImpPalette::XclImpPalette( const XclImpRoot& rRoot ) :
-    XclDefaultPalette( rRoot )
+    XclDefaultPalette( rRoot ), mrRoot( rRoot )
 {
 }
 
@@ -102,6 +162,7 @@ void XclImpPalette::ReadPalette( XclImpStream& rStrm )
         rStrm >> aColor;
         maColorTable[ nIndex ] = aColor.GetColor();
     }
+    ExportPalette();
 }
 
 // FONT record - font information =============================================
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index ec4828d..3360b02 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -366,7 +366,7 @@ bool XclControlHelper::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor,
 }
 
 String XclControlHelper::ExtractFromMacroDescriptor(
-        const ScriptEventDescriptor& rDescriptor, XclTbxEventType eEventType )
+        const ScriptEventDescriptor& rDescriptor, XclTbxEventType eEventType, SfxObjectShell* pShell )
 {
     if( (rDescriptor.ScriptCode.getLength() > 0) &&
             rDescriptor.ScriptType.equalsIgnoreAsciiCaseAscii( "Script" ) &&
diff --git sc/source/filter/excel/xltoolbar.cxx sc/source/filter/excel/xltoolbar.cxx
new file mode 100644
index 0000000..019a146
--- /dev/null
+++ sc/source/filter/excel/xltoolbar.cxx
@@ -0,0 +1,433 @@
+#include "xltoolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOExcelCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOExcelCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOExcelCommandConvertor::MSOExcelCommandConvertor()
+{
+/*
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+*/
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+
+CTBS::CTBS() : bSignature(0), bVersion(0), reserved1(0), reserved2(0), reserved3(0), ctb(0), ctbViews(0), ictbView(0)
+{
+}
+
+CTB::CTB() : nViews( 0 ), ectbid(0)
+{
+}
+
+CTB::CTB(sal_uInt16 nNum ) : nViews( nNum ), ectbid(0)
+{
+}
+
+bool CTB::Read( SvStream *pS )
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    tb.Read( pS );
+    for ( sal_uInt16 index = 0; index < nViews; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+    *pS >> ectbid;
+  
+    for ( sal_Int16 index = 0; index < tb.getcCL(); ++index )
+    {
+        TBC aTBC;
+        aTBC.Read( pS );
+        rTBC.push_back( aTBC ); 
+    }
+    return true;
+}
+
+void CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTB -- dump\n", nOffSet );
+    indent_printf( fp, "  nViews 0x%x\n", nViews);
+    tb.Print( fp );
+
+    std::vector<TBVisualData>::iterator visData_end = rVisualData.end();
+    sal_Int32 counter = 0;
+    for ( std::vector<TBVisualData>::iterator it = rVisualData.begin(); it != visData_end; ++it )
+    {
+        
+        indent_printf( fp, "  TBVisualData [%d]\n", counter++ );
+        Indent b;
+        it->Print( fp );
+    } 
+    indent_printf( fp, "  ectbid 0x%x\n", ectbid);
+    std::vector<TBC>::iterator it_end = rTBC.end();
+    counter = 0;
+    for ( std::vector<TBC>::iterator it = rTBC.begin(); it != it_end; ++it )
+    {
+        indent_printf( fp, "  TBC [%d]\n", counter++);
+        Indent c;
+        it->Print( fp );
+    }
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xMenuDesc, CustomToolBarImportHelper& helper )
+{
+    sal_Int32 index = 0;
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it, ++index )
+    {
+        if ( !it->ImportToolBarControl( rWrapper, xMenuDesc, helper, IsMenuToolbar() ) )
+            return false;
+    }
+    return true;
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        WString& name = tb.getName();
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif 
+    
+        bRes = true;
+    }
+    catch( uno::Exception& )
+    {
+       bRes = false; 
+    }
+    return bRes;
+}
+bool CTBS::Read( SvStream *pS )
+{
+    OSL_TRACE("CTBS::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> bSignature >> bVersion >> reserved1 >> reserved2 >> reserved3 >> ctb >> ctbViews >> ictbView;
+    return true;
+}
+
+void CTBS::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBS -- dump\n", nOffSet );
+
+    indent_printf( fp, "  bSignature 0x%x\n", bSignature);
+    indent_printf( fp, "  bVersion 0x%x\n", bVersion);
+
+    indent_printf( fp, "  reserved1 0x%x\n", reserved1 );
+    indent_printf( fp, "  reserved2 0x%x\n", reserved2 );
+    indent_printf( fp, "  reserved3 0x%x\n", reserved3 );
+
+    indent_printf( fp, "  ctb 0x%x\n", ctb );
+    indent_printf( fp, "  ctbViews 0x%x\n", ctbViews );
+    indent_printf( fp, "  ictbView 0x%x\n", ictbView );
+}
+
+TBC::TBC()
+{
+}
+
+bool 
+TBC::Read(SvStream *pS)
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    if ( !tbch.Read( pS ) )
+        return false;
+    sal_uInt16 tcid = tbch.getTcID();
+    sal_uInt8 tct = tbch.getTct();
+    if (  ( tcid != 0x0001 && tcid != 0x06CC && tcid != 0x03D8 && tcid != 0x03EC && tcid != 0x1051 ) && ( ( tct > 0 && tct < 0x0B ) || ( ( tct > 0x0B && tct < 0x10 ) || tct == 0x15 ) ) )
+    {
+        tbcCmd.reset( new TBCCmd );
+        if ( !  tbcCmd->Read( pS ) )
+            return false;
+    }
+    if ( tct != 0x16 )
+    {
+        tbcd.reset( new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+
+void
+TBC::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBC -- dump\n", nOffSet );
+    tbch.Print( fp );
+    if ( tbcCmd.get() )
+        tbcCmd->Print( fp );    
+    if ( tbcd.get() )
+        tbcd->Print( fp );    
+}
+
+bool TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuToolbar )
+{
+    // how to identify built-in-command ?
+//    bool bBuiltin = false;
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+/*
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+         
+        }
+*/
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuToolbar ) )
+            return false;
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                 if ( !pCustTB->ImportMenuTB( rWrapper, xMenuDesc, helper ) )
+                     return false;     
+                 if ( !bIsMenuToolbar ) 
+                 {
+                     if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                         return false;
+                 }
+                 else
+                 {
+                     beans::PropertyValue aProp;
+                     aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                     aProp.Value <<= xMenuDesc;
+                     props.push_back( aProp );
+                 }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+        }
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+void
+TBCCmd::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, " TBCCmd -- dump\n" );
+    indent_printf( fp, "   cmdID 0x%x\n", cmdID );
+    indent_printf( fp, "   A ( fHideDrawing ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   B ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   cmdType 0x%x\n", cmdType );
+    indent_printf( fp, "   C ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   reserved3 0x%x\n", reserved3 );
+}
+
+bool TBCCmd::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCCmd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> cmdID;
+    sal_uInt16 temp;
+    *pS >> temp;
+    OSL_TRACE("TBCmd temp = 0x%x", temp );
+    A = (temp & 0x8000 ) == 0x8000; 
+    B = (temp & 0x4000) == 0x4000; 
+    cmdType = ( temp & 0x3E00 ) >> 9;
+    C = ( temp & 0x100 ) == 0x100; 
+    reserved3 = ( temp & 0xFF ); 
+    return true;
+}
+
+CTBWrapper::CTBWrapper()
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+bool 
+CTBWrapper::Read( SvStream *pS)
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    if ( !ctbSet.Read( pS ) )
+        return false;
+    for ( sal_uInt16 index = 0; index < ctbSet.ctb; ++index )
+    {
+        CTB aCTB( ctbSet.ctbViews );
+        if ( !aCTB.Read( pS ) )
+            return false;
+        rCTB.push_back( aCTB ); 
+    }
+    return true;
+}
+
+void 
+CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBWrapper -- dump\n", nOffSet );
+    ctbSet.Print( fp );
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        Indent b;
+        it->Print( fp );
+    } 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< CTB >::iterator it = rCTB.begin(); it != rCTB.end(); ++it )
+    {
+        if ( it->GetName().equals( sTBName ) )
+        {
+            pCTB = &(*it);
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        // for each customtoolbar
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument" ) ) ) );
+        helper.setMSOCommandMap( new  MSOExcelCommandConvertor() );
+        // Ignore menu toolbars, excel doesn't ( afaics ) store
+        // menu customizations ( but you can have menus in a customtoolbar
+        // such menus will be dealt with when they are encountered 
+        // as part of importing the appropriate MenuSpecific toolbar control )
+
+
+        if ( !(*it).IsMenuToolbar() ) 
+        {
+            if ( !(*it).ImportCustomToolBar( *this, helper ) )
+                return false;
+        }
+    } 
+    return true;
+}
+
+
diff --git sc/source/filter/excel/xltoolbar.hxx sc/source/filter/excel/xltoolbar.hxx
new file mode 100644
index 0000000..5bfbe2c
--- /dev/null
+++ sc/source/filter/excel/xltoolbar.hxx
@@ -0,0 +1,95 @@
+#ifndef _XLTOOLBAR_HXX
+#define _XLTOOLBAR_HXX
+
+#include <filter/msfilter/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class CTBWrapper;
+// hmm I don't normally use these packed structures
+// but.. hey always good to do something different
+class TBCCmd : public TBBase
+{
+public:
+    TBCCmd() : cmdID(0), A(0), B(0), cmdType(0), C(0), reserved3(0) {}
+    sal_uInt16 cmdID;
+    sal_uInt16 A:1;
+    sal_uInt16 B:1;
+    sal_uInt16 cmdType:5;
+    sal_uInt16 C:1;
+    sal_uInt16 reserved3:8;
+    bool Read( SvStream* pS );
+    void Print(FILE* fp);
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr<TBCCmd> tbcCmd; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool ImportToolBarControl( CTBWrapper&, const com::sun::star::uno::Reference< com::sun::star::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar );
+};
+ 
+class CTB : public TBBase
+{
+    sal_uInt16 nViews;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_uInt32 ectbid;
+    std::vector< TBC > rTBC;
+    bool ImportCustomToolBar_Impl( CTBWrapper&, CustomToolBarImportHelper& );
+public:
+    CTB();
+    CTB(sal_uInt16);
+    ~CTB(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+
+
+};
+
+class CTBS : public TBBase
+{
+public:
+    sal_uInt8 bSignature;
+    sal_uInt8 bVersion;
+    sal_uInt16 reserved1;
+    sal_uInt16 reserved2;
+    sal_uInt16 reserved3;
+    sal_uInt16 ctb;
+    sal_uInt16 ctbViews;
+    sal_uInt16 ictbView;
+    CTBS(const CTBS&);
+    CTBS& operator = ( const CTBS&);
+    CTBS();
+    ~CTBS(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper : public TBBase
+{
+    CTBS ctbSet;
+
+    std::vector< CTB > rCTB; 
+
+public:
+    CTBWrapper();
+    ~CTBWrapper();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+};
+
+
+#endif //_XLTOOLBAR_HXX
diff --git sc/source/filter/inc/excimp8.hxx sc/source/filter/inc/excimp8.hxx
index d3cca16..cdcf128 100644
--- sc/source/filter/inc/excimp8.hxx
+++ sc/source/filter/inc/excimp8.hxx
@@ -57,6 +57,9 @@ public:
     virtual FltError		Read( void );
 
 protected:
+    // represents codename ( and associated modules ) 
+    // not speficied directly in the binary format
+    std::vector< String > AutoGeneratedCodeNames; 
     ExcScenarioList         aScenList;
 
     void					Calccount( void );				// 0x0C
diff --git sc/source/filter/inc/xcl97esc.hxx sc/source/filter/inc/xcl97esc.hxx
index e40e3f1..2c52717 100644
--- sc/source/filter/inc/xcl97esc.hxx
+++ sc/source/filter/inc/xcl97esc.hxx
@@ -70,6 +70,15 @@ class XclExpOcxControlObj;
 #else
 class XclExpTbxControlObj;
 #endif
+class XclExpShapeObj;
+class EscherExHostAppData;
+class ShapeInteractionHelper
+{
+public:
+   static XclExpShapeObj* CreateShapeObj( XclExpObjectManager& rObjMgr, const ::com::sun::star::uno::Reference<
+                            ::com::sun::star::drawing::XShape >& xShape );
+   static void PopulateShapeInteractionInfo( XclExpObjectManager& rObjMgr, const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >& xShape, EscherExHostAppData& rHostAppData );
+};
 
 class XclEscherEx : public EscherEx, protected XclExpRoot
 {
diff --git sc/source/filter/inc/xcl97rec.hxx sc/source/filter/inc/xcl97rec.hxx
index 82db773..3274d88 100644
--- sc/source/filter/inc/xcl97rec.hxx
+++ sc/source/filter/inc/xcl97rec.hxx
@@ -220,7 +220,7 @@ public:
 
 class XclObjAny : public XclObj
 {
-private:
+protected:
     virtual void                WriteSubRecs( XclExpStream& rStrm );
 
 public:
diff --git sc/source/filter/inc/xecontent.hxx sc/source/filter/inc/xecontent.hxx
index 4783814..ddb6162 100644
--- sc/source/filter/inc/xecontent.hxx
+++ sc/source/filter/inc/xecontent.hxx
@@ -113,6 +113,8 @@ public:
     inline const String* GetRepr() const { return mxRepr.get(); }
 
     virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+    virtual void        WriteEmbeddedData( XclExpStream& rStrm );
 private:
     /** Builds file name from the passed file URL. Tries to convert to relative file name.
         @param rnLevel  (out-param) The parent directory level.
diff --git sc/source/filter/inc/xeescher.hxx sc/source/filter/inc/xeescher.hxx
index 259ab97..c57993c 100644
--- sc/source/filter/inc/xeescher.hxx
+++ sc/source/filter/inc/xeescher.hxx
@@ -207,6 +207,34 @@ private:
     sal_uInt16          mnEntryCount;   /// Number of entries in source range.
 };
 
+class XclMacroHelper : public XclExpControlHelper
+{
+protected:
+    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
+
+public:
+    explicit            XclMacroHelper( const XclExpRoot& rRoot );
+    virtual             ~XclMacroHelper();
+    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
+    void                WriteMacroSubRec( XclExpStream& rStrm  );
+    /** Sets the name of a macro for object of passed type
+        @return  true = The passed event descriptor was valid, macro name has been found. */
+    bool                SetMacroLink( const ::com::sun::star::script::ScriptEventDescriptor& rEvent,  const XclTbxEventType& nEventType );
+
+    /** Sets the name of a macro 
+        @return  true = The passed macro name has been found. */
+    bool                SetMacroLink( const String& rMacro );
+};
+
+class XclExpShapeObj : public XclObjAny, public XclMacroHelper
+{
+public:
+    explicit            XclExpShapeObj( XclExpObjectManager& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual             ~XclExpShapeObj();
+private:
+    virtual void        WriteSubRecs( XclExpStream& rStrm );
+};
+
 // ----------------------------------------------------------------------------
 
 #if EXC_EXP_OCX_CTRL
@@ -234,7 +262,7 @@ private:
 #else
 
 /** Represents an OBJ record for an TBX form control. */
-class XclExpTbxControlObj : public XclObj, public XclExpControlHelper
+class XclExpTbxControlObj : public XclObj, public XclMacroHelper
 {
 public:
     explicit            XclExpTbxControlObj(
@@ -249,8 +277,6 @@ public:
 private:
     virtual void        WriteSubRecs( XclExpStream& rStrm );
 
-    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
-    void                WriteMacroSubRec( XclExpStream& rStrm );
     /** Writes a subrecord containing a cell link, or nothing, if no link present. */
     void                WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId );
     /** Writes the ftSbs sub structure containing scrollbar data. */
@@ -258,7 +284,6 @@ private:
 
 private:
     ScfInt16Vec         maMultiSel;     /// Indexes of all selected entries in a multi selection.
-    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
     XclTbxEventType     meEventType;    /// Type of supported macro event.
     sal_Int32           mnHeight;       /// Height of the control.
     sal_uInt16          mnState;        /// Checked/unchecked state.
diff --git sc/source/filter/inc/xiescher.hxx sc/source/filter/inc/xiescher.hxx
index b845207..a5998ed 100644
--- sc/source/filter/inc/xiescher.hxx
+++ sc/source/filter/inc/xiescher.hxx
@@ -30,6 +30,7 @@
 
 #include <vector>
 #include <map>
+#include <hash_map>
 #include <filter/msfilter/msdffimp.hxx>
 #include <filter/msfilter/msocximex.hxx>
 #include <vcl/graph.hxx>
@@ -92,7 +93,7 @@ public:
     /** Returns the Excel object type from OBJ record. */
     inline sal_uInt16   GetObjType() const { return mnObjType; }
     /** Returns the name of this object, may generate a default name. */
-    String              GetObjName() const;
+    virtual String              GetObjName() const;
     /** Returns associated macro name, if set, otherwise zero length string. */
     inline const String& GetMacroName() const { return maMacroName; }
 
@@ -172,7 +173,7 @@ protected:
     virtual void        DoPreProcessSdrObj( XclImpDffConverter& rDffConv, SdrObject& rSdrObj ) const;
     /** Derived classes may perform additional processing for the passed SdrObject after insertion. */
     virtual void        DoPostProcessSdrObj( XclImpDffConverter& rDffConv, SdrObject& rSdrObj ) const;
-
+    SCTAB               GetTab() const { return mnTab; }
 private:
     /** Reads the contents of a BIFF3 OBJ record. */
     void                ImplReadObj3( XclImpStream& rStrm );
@@ -186,6 +187,7 @@ private:
 private:
     XclObjAnchor        maAnchor;       /// The position of the object in its parent.
     sal_uInt16          mnObjId;        /// The object identifier (unique per drawing).
+    SCTAB               mnTab;          /// Location of object
     sal_uInt16          mnObjType;      /// The Excel object type from OBJ record.
     sal_uInt32          mnDffShapeId;   /// Shape ID from DFF stream.
     sal_uInt32          mnDffFlags;     /// Shape flags from DFF stream.
@@ -502,6 +504,10 @@ protected:
     /** Derived classes will set additional properties for the current form control. */
     virtual void        DoProcessControl( ScfPropertySet& rPropSet ) const;
 
+    void ApplySheetLinkProps() const;
+    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
+                        mxShape;        /// The UNO wrapper of the control shape.
+    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
 private:
     /** Reads a list of cell ranges from a formula at the current stream position. */
     void                ReadRangeList( ScRangeList& rScRanges, XclImpStream& rStrm );
@@ -510,9 +516,6 @@ private:
 
 private:
     const XclImpRoot&   mrRoot;         /// Not derived from XclImpRoot to allow multiple inheritance.
-    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
-                        mxShape;        /// The UNO wrapper of the control shape.
-    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
     ScfRef< ScRange >   mxSrcRange;     /// Source data range in the Calc document.
     XclCtrlBindMode     meBindMode;     /// Value binding mode.
 };
@@ -614,6 +617,7 @@ protected:
     virtual XclTbxEventType DoGetEventType() const;
 
 protected:
+    void ApplyGrouping( XclImpOptionButtonObj& rLeader, sal_Int32 nRefVal );
     sal_uInt16          mnNextInGroup;      /// Next option button in a group.
     sal_uInt16          mnFirstInGroup;     /// 1 = Button is the first in a group.
 };
@@ -862,7 +866,8 @@ class XclImpPictureObj : public XclImpRectObj, public XclImpControlHelper
 {
 public:
     explicit            XclImpPictureObj( const XclImpRoot& rRoot );
-
+    /** Returns the ObjectName - can use non-obvious lookup for override in the associated vba document module stream**/
+    virtual String              GetObjName() const;
     /** Returns the graphic imported from the IMGDATA record. */
     inline const Graphic& GetGraphic() const { return maGraphic; }
     /** Returns the visible area of the imported graphic. */
@@ -1209,6 +1214,8 @@ private:
 /** Stores all drawing and OLE objects and additional data related to these objects. */
 class XclImpObjectManager : protected XclImpRoot
 {
+typedef std::hash_map< sal_Int32, String >  CntrlObjIdToName;
+typedef std::map< String, CntrlObjIdToName > CodeNameToCntrlObjIdInfo;
 public:
     explicit            XclImpObjectManager( const XclImpRoot& rRoot );
     virtual             ~XclImpObjectManager();
@@ -1225,9 +1232,41 @@ public:
     String              GetDefaultObjName( const XclImpDrawObjBase& rDrawObj ) const;
     /** Returns the used area in the sheet with the passed index. */
     ScRange             GetUsedArea( SCTAB nScTab ) const;
+    void SetOleNameOverrideInfo( const CodeNameToCntrlObjIdInfo& rOverrideInfo ) {  maOleCtrlNameOverride = rOverrideInfo; }
+    String GetOleNameOverride( SCTAB nTab, sal_uInt16 nObjId );
+    // ------------------------------------------------------------------------
+private:
+
+    CodeNameToCntrlObjIdInfo maOleCtrlNameOverride;
+
+    /** Reads and returns a bitmap from WMF/PICT format. */
+    static void         ReadWmf( Graphic& rGraphic, XclImpStream& rStrm );
+    /** Reads and returns a bitmap from BMP format. */
+    static void         ReadBmp( Graphic& rGraphic, XclImpStream& rStrm );
+
+    /** Reads contents of an DFF record and append data to internal DFF stream. */
+    void                ReadDffRecord( XclImpStream& rStrm );
+    /** Reads a BIFF8 OBJ record following an MSODRAWING record. */
+    void                ReadObj8( XclImpStream& rStrm );
+    /** Reads the TXO record and following CONTINUE records containing string and formatting. */
+    void                ReadTxo( XclImpStream& rStrm );
+
+    /** Reads a BIFF3-BIFF5 NOTE record. */
+    void                ReadNote3( XclImpStream& rStrm );
+    /** Reads a BIFF8 NOTE record. */
+    void                ReadNote8( XclImpStream& rStrm );
+
+    /** Returns the size of the progress bar shown while processing all objects. */
+    sal_Size            GetProgressSize() const;
 
     // ------------------------------------------------------------------------
 private:
+    typedef ::std::map< sal_Size, XclImpDrawObjRef >    XclImpObjMap;
+    typedef ::std::map< XclObjId, XclImpDrawObjRef >    XclImpObjMapById;
+    typedef ScfRef< XclImpObjTextData >                 XclImpObjTextRef;
+    typedef ::std::map< sal_Size, XclImpObjTextRef >    XclImpObjTextMap;
+    typedef ::std::vector< XclObjId >                   XclObjIdVec;
+
     typedef ::std::map< sal_uInt16, String >            DefObjNameMap;
     typedef ScfRef< XclImpSheetDrawing >                XclImpSheetDrawingRef;
     typedef ::std::map< SCTAB, XclImpSheetDrawingRef >  XclImpSheetDrawingMap;
diff --git sc/source/filter/inc/xistyle.hxx sc/source/filter/inc/xistyle.hxx
index 1d3047e..ba3448f 100644
--- sc/source/filter/inc/xistyle.hxx
+++ sc/source/filter/inc/xistyle.hxx
@@ -69,8 +69,10 @@ public:
     void                ReadPalette( XclImpStream& rStrm );
 
 private:
+    void ExportPalette();
     typedef ::std::vector< ColorData > ColorDataVec;
     ColorDataVec        maColorTable;       /// Colors read from file.
+    const XclImpRoot&             mrRoot;
 };
 
 // FONT record - font information =============================================
diff --git sc/source/filter/inc/xlescher.hxx sc/source/filter/inc/xlescher.hxx
index ecc8ab9..22bb12e 100644
--- sc/source/filter/inc/xlescher.hxx
+++ sc/source/filter/inc/xlescher.hxx
@@ -441,7 +441,7 @@ public:
     /** Tries to extract an Excel macro name from the passed macro descriptor. */
     static String       ExtractFromMacroDescriptor(
                             const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
-                            XclTbxEventType eEventType );
+                            XclTbxEventType eEventType, SfxObjectShell* pShell = NULL );
 };
 
 // ============================================================================
diff --git sc/source/filter/xcl97/xcl97esc.cxx sc/source/filter/xcl97/xcl97esc.cxx
index b7e5de8..58ef6ad 100644
--- sc/source/filter/xcl97/xcl97esc.cxx
+++ sc/source/filter/xcl97/xcl97esc.cxx
@@ -54,6 +54,9 @@
 #include "global.hxx"
 #include "document.hxx"
 #include "drwlayer.hxx"
+#include "xecontent.hxx"
+#include <editeng/flditem.hxx>
+#include "userdat.hxx"
 #include "xcl97rec.hxx"
 #include "xehelper.hxx"
 #include "xechart.hxx"
@@ -256,7 +259,8 @@ EscherExHostAppData* XclEscherEx::StartShape( const Reference< XShape >& rxShape
         {
             // #107540# ignore permanent note shapes
             // #i12190# do not ignore callouts (do not filter by object type ID)
-            pCurrXclObj = new XclObjAny( mrObjMgr );   // just a metafile
+            pCurrXclObj = ShapeInteractionHelper::CreateShapeObj( mrObjMgr, rxShape );
+            ShapeInteractionHelper::PopulateShapeInteractionInfo( mrObjMgr, rxShape, *pCurrAppData );
         }
     }
     if ( pCurrXclObj )
@@ -359,7 +363,6 @@ EscherExHostAppData* XclEscherEx::EnterAdditionalTextGroup()
     return pCurrAppData;
 }
 
-
 void XclEscherEx::EndDocument()
 {
     if( mbIsRootDff )
@@ -478,6 +481,7 @@ void XclEscherEx::DeleteCurrAppData()
         delete pCurrAppData->GetClientAnchor();
 //      delete pCurrAppData->GetClientData();
         delete pCurrAppData->GetClientTextbox();
+	delete pCurrAppData->GetInteractionInfo();
         delete pCurrAppData;
     }
 }
@@ -509,4 +513,40 @@ void XclEscherClientTextbox::WriteData( EscherEx& /*rEx*/ ) const
     pXclObj->SetText( GetRoot(), rTextObj );
 }
 
+XclExpShapeObj* 
+ShapeInteractionHelper::CreateShapeObj( XclExpObjectManager& rObjMgr, const Reference< XShape >& xShape )
+{
+    return new XclExpShapeObj( rObjMgr, xShape );
+}
+
+void
+ShapeInteractionHelper::PopulateShapeInteractionInfo( XclExpObjectManager& rObjMgr, const Reference< XShape >& xShape, EscherExHostAppData& rHostAppData )
+{
+   try
+   {
+      SvMemoryStream* pMemStrm = NULL;
+      rtl::OUString sHyperLink;
+      rtl::OUString sMacro;
+      if ( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( ::GetSdrObjectFromXShape( xShape ) ) )
+      {
+         sHyperLink = pInfo->GetHlink();      
+         sMacro = pInfo->GetMacro();
+      }
+      if (  sHyperLink.getLength() > 0 )
+      {
+         pMemStrm = new SvMemoryStream();
+         XclExpStream tmpStream( *pMemStrm, rObjMgr.GetRoot() );
+         ScAddress dummyAddress;
+         SvxURLField aUrlField;
+         aUrlField.SetURL( sHyperLink );
+         XclExpHyperlink hExpHlink( rObjMgr.GetRoot(), aUrlField, dummyAddress );
+         hExpHlink.WriteEmbeddedData( tmpStream );
+      }
+      if ( ( sHyperLink.getLength() > 0 ) || ( sMacro.getLength() > 0 ) )
+          rHostAppData.SetInteractionInfo( new InteractionInfo( pMemStrm, true ) );
+   }
+   catch( Exception& )
+   {
+   }
+}
 
diff --git sc/source/filter/xml/xmlexprt.cxx sc/source/filter/xml/xmlexprt.cxx
index d46080d..e7e7bd3 100644
--- sc/source/filter/xml/xmlexprt.cxx
+++ sc/source/filter/xml/xmlexprt.cxx
@@ -3268,7 +3268,34 @@ void ScXMLExport::ExportShape(const uno::Reference < drawing::XShape >& xShape,
         }
     }
     if (!bIsChart)
+	{
+		// #i66550 HLINK_FOR_SHAPES
+		rtl::OUString sHlink;
+		uno::Reference< beans::XPropertySet > xProps( xShape, uno::UNO_QUERY );
+		if ( xProps.is() )
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_HYPERLINK ) ) ) >>= sHlink;
+
+		std::auto_ptr< SvXMLElementExport > pDrawA;
+		// enlose shapes with <draw:a> element only if sHlink contains something
+		if ( sHlink.getLength() > 0 )
+		{
+			// need to get delete the attributes that are pre-loaded
+			// for the shape export ( otherwise they will become 	
+			// attributes of the draw:a element ) This *shouldn't* 
+			// affect performance adversely as there are only a 
+			// couple of attributes involved
+			uno::Reference< xml::sax::XAttributeList > xSaveAttribs( new  SvXMLAttributeList( GetAttrList() ) );
+			ClearAttrList();
+			// Add Hlink	
+			AddAttribute( XML_NAMESPACE_XLINK, XML_TYPE, XML_SIMPLE );
+			AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, sHlink);
+			pDrawA.reset( new SvXMLElementExport( *this, XML_NAMESPACE_DRAW, XML_A, sal_False, sal_False ) );
+			// Attribute list has been cleared by previous operation
+			// re-add pre-loaded attributes
+			AddAttributeList( xSaveAttribs );
+		}
         GetShapeExport()->exportShape(xShape, SEF_DEFAULT, pPoint);
+	}
     IncrementProgressBar(sal_False);
 }
 
diff --git sc/source/ui/attrdlg/scdlgfact.cxx sc/source/ui/attrdlg/scdlgfact.cxx
index 3d261aa..901f317 100644
--- sc/source/ui/attrdlg/scdlgfact.cxx
+++ sc/source/ui/attrdlg/scdlgfact.cxx
@@ -80,6 +80,8 @@
 #include "tpusrlst.hxx" //add for ScTpUserLists
 #include "tpview.hxx" //add for ScTpContentOptions
 #include "tpformula.hxx"
+//for dataform
+#include "datafdlg.hxx" //add for ScDataFormDlg
 
 // ause
 #include "editutil.hxx"
@@ -93,6 +95,8 @@ IMPL_ABSTDLG_BASE(AbstractScDataPilotDatabaseDlg_Impl); //add for ScDataPilotDat
 IMPL_ABSTDLG_BASE(AbstractScDataPilotSourceTypeDlg_Impl); //add for ScDataPilotSourceTypeDlg
 IMPL_ABSTDLG_BASE(AbstractScDataPilotServiceDlg_Impl); //add for ScDataPilotServiceDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteCellDlg_Impl); //add for ScDeleteCellDlg
+//for dataform
+IMPL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl); //add for ScDataFormDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteContentsDlg_Impl); //add for ScDeleteContentsDlg
 IMPL_ABSTDLG_BASE(AbstractScFillSeriesDlg_Impl); //add for ScFillSeriesDlg
 IMPL_ABSTDLG_BASE(AbstractScGroupDlg_Impl); //add for ScGroupDlg
@@ -864,6 +868,26 @@ AbstractScDeleteCellDlg* ScAbstractDialogFactory_Impl::CreateScDeleteCellDlg( Wi
 
 //add for ScDeleteCellDlg  end
 
+//add for ScDataFormDlg begin
+AbstractScDataFormDlg* ScAbstractDialogFactory_Impl::CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*	pTabViewShell )
+{
+	ScDataFormDlg * pDlg=NULL;
+	switch ( nId )
+	{
+		case RID_SCDLG_DATAFORM :
+			pDlg = new ScDataFormDlg( pParent, pTabViewShell);
+			break;
+		default:
+			break;
+	}
+
+	if ( pDlg )
+		return new AbstractScDataFormDlg_Impl( pDlg );
+	return 0;
+}
+
+//add for ScDataFormDlg  end
+
 //add for ScDeleteContentsDlg begin
 AbstractScDeleteContentsDlg* ScAbstractDialogFactory_Impl::CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults )
diff --git sc/source/ui/attrdlg/scdlgfact.hxx sc/source/ui/attrdlg/scdlgfact.hxx
index d8ae113..1174723 100644
--- sc/source/ui/attrdlg/scdlgfact.hxx
+++ sc/source/ui/attrdlg/scdlgfact.hxx
@@ -37,6 +37,7 @@ class ScDataPilotDatabaseDlg;
 class ScDataPilotSourceTypeDlg;
 class ScDataPilotServiceDlg;
 class ScDeleteCellDlg;
+class ScDataFormDlg;
 class ScDeleteContentsDlg;
 class ScFillSeriesDlg;
 class ScGroupDlg;
@@ -164,6 +165,12 @@ class AbstractScDeleteCellDlg_Impl : public AbstractScDeleteCellDlg  //add for S
     virtual DelCellCmd GetDelCellCmd() const;
 };
 
+//for dataform
+class AbstractScDataFormDlg_Impl : public AbstractScDataFormDlg  //add for ScDataFormDlg
+{
+	DECL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl,ScDataFormDlg);
+};
+
 class AbstractScDeleteContentsDlg_Impl : public AbstractScDeleteContentsDlg  //add for ScDeleteContentsDlg
 {
     DECL_ABSTDLG_BASE( AbstractScDeleteContentsDlg_Impl,ScDeleteContentsDlg)
@@ -427,6 +434,9 @@ public:
     virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId,
                                                             BOOL bDisallowCellMove = FALSE ); //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell); //add for ScDeleteCellDlg
+
     virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults = 0 );
 
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index bec1b90..634456f 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -110,6 +110,7 @@ using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 using ::std::vector;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -4226,6 +4227,13 @@ BOOL ScDocFunc::FillSeries( const ScRange& rRange, const ScMarkData* pTabMark,
 BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
                             FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi )
 {
+	double		fStep = 1.0;
+	double		fMax = MAXDOUBLE;
+	return FillAuto( rRange, pTabMark, eDir, FILL_AUTO, FILL_DAY, nCount, fStep, fMax, bRecord, bApi );
+}
+
+BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax,  BOOL bRecord, BOOL bApi )
+{
     ScDocShellModificator aModificator( rDocShell );
 
     ScDocument* pDoc = rDocShell.GetDocument();
@@ -4251,10 +4259,6 @@ BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
     ScRange aSourceArea = rRange;
     ScRange aDestArea   = rRange;
 
-    FillCmd		eCmd = FILL_AUTO;
-    FillDateCmd	eDateCmd = FILL_DAY;
-    double		fStep = 1.0;
-    double		fMax = MAXDOUBLE;
 
     switch (eDir)
     {
diff --git sc/source/ui/docshell/docsh5.cxx sc/source/ui/docshell/docsh5.cxx
index aa3ca3e..82e797e 100644
--- sc/source/ui/docshell/docsh5.cxx
+++ sc/source/ui/docshell/docsh5.cxx
@@ -857,6 +857,47 @@ SCTAB ScDocShell::MakeScenario( SCTAB nTab, const String& rName, const String& r
     return nTab;
 }
 
+ULONG ScDocShell::TransferTab( ScDocShell& rSrcDocShell, SCTAB nSrcPos,
+                                SCTAB nDestPos, BOOL bInsertNew,
+                                BOOL bNotifyAndPaint )
+{
+    ScDocument* pSrcDoc = rSrcDocShell.GetDocument();
+
+    ULONG nErrVal =  aDocument.TransferTab( pSrcDoc, nSrcPos, nDestPos,
+                    bInsertNew );		// no insert
+
+    // TransferTab doesn't copy drawing objects with bInsertNew=FALSE
+    if ( nErrVal > 0 && !bInsertNew)
+        aDocument.TransferDrawPage( pSrcDoc, nSrcPos, nDestPos );
+
+    if(nErrVal>0 && pSrcDoc->IsScenario( nSrcPos ))
+    {
+        String aComment;
+        Color  aColor;
+        USHORT nFlags;
+
+        pSrcDoc->GetScenarioData( nSrcPos, aComment,aColor, nFlags);
+        aDocument.SetScenario(nDestPos,TRUE);
+        aDocument.SetScenarioData(nDestPos,aComment,aColor,nFlags);
+        BOOL bActive = pSrcDoc->IsActiveScenario(nSrcPos);
+        aDocument.SetActiveScenario(nDestPos, bActive );
+
+        BOOL bVisible=pSrcDoc->IsVisible(nSrcPos);
+        aDocument.SetVisible(nDestPos,bVisible );
+
+    }
+
+    if ( nErrVal > 0 && pSrcDoc->IsTabProtected( nSrcPos ) )
+        aDocument.SetTabProtection(nDestPos, pSrcDoc->GetTabProtection(nSrcPos));
+    if ( bNotifyAndPaint )
+    {
+            Broadcast( ScTablesHint( SC_TAB_INSERTED, nDestPos ) );
+            PostPaintExtras();
+            PostPaintGridAll();
+    } 
+    return nErrVal;
+}
+
 BOOL ScDocShell::MoveTable( SCTAB nSrcTab, SCTAB nDestTab, BOOL bCopy, BOOL bRecord )
 {
     ScDocShellModificator aModificator( *this );
diff --git sc/source/ui/docshell/macromgr.cxx sc/source/ui/docshell/macromgr.cxx
new file mode 100644
index 0000000..97623f3
--- /dev/null
+++ sc/source/ui/docshell/macromgr.cxx
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+// INCLUDE ---------------------------------------------------------------
+
+#include "macromgr.hxx"
+#include "document.hxx"
+
+#include "basic/basmgr.hxx"
+#include "cppuhelper/implbase1.hxx"
+#include "sfx2/objsh.hxx"
+#include "cell.hxx"
+#include <com/sun/star/container/XContainer.hpp>
+
+#include <list>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::RuntimeException;
+using ::com::sun::star::uno::Reference;
+using ::rtl::OUString;
+using ::rtl::OUStringHash;
+using ::std::hash_map;
+using ::std::list;
+using ::std::for_each;
+using ::std::pair;
+
+// ============================================================================
+
+/** 
+ * A simple container to keep track of cells that depend on basic modules 
+ * changes.  We don't check for duplicates at insertion time; instead, we 
+ * remove duplicates at query time. 
+ */
+class ScUserMacroDepTracker
+{
+public:
+    void addCell(const OUString& rModuleName, ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+        {
+            pair<ModuleCellMap::iterator, bool> r = maCells.insert(
+                ModuleCellMap::value_type(rModuleName, list<ScFormulaCell*>()));
+
+            if (!r.second)
+                // insertion failed.
+                return;
+
+            itr = r.first;
+        }
+        itr->second.push_back(pCell);
+    }
+
+    void removeCell(ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.begin(), itrEnd = maCells.end();
+        for (; itr != itrEnd; ++itr)
+            itr->second.remove(pCell);
+    }
+
+    void getCellsByModule(const OUString& rModuleName, list<ScFormulaCell*>& rCells)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+            return;
+
+        list<ScFormulaCell*>& rCellList = itr->second;
+
+        // Remove duplicates.
+        rCellList.sort();
+        rCellList.unique();
+        // exception safe copy
+        list<ScFormulaCell*> temp(rCellList);
+        rCells.swap(temp);
+    }
+
+private:
+    typedef hash_map<OUString, list<ScFormulaCell*>, OUStringHash> ModuleCellMap;
+    ModuleCellMap maCells;
+};
+
+
+// ============================================================================
+
+ScMacroManager::ScMacroManager(ScDocument* pDoc) :
+    mpDepTracker(new ScUserMacroDepTracker),
+    mpDoc(pDoc)
+{
+}
+
+ScMacroManager::~ScMacroManager()
+{
+}
+
+typedef ::cppu::WeakImplHelper1< ::com::sun::star::container::XContainerListener > ContainerListenerHelper;
+
+class VBAProjectListener : public ContainerListenerHelper
+{
+    ScMacroManager* mpMacroMgr;
+public:
+    VBAProjectListener( ScMacroManager* pMacroMgr ) : mpMacroMgr( pMacroMgr ) {}
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& /*Source*/ ) throw(RuntimeException) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& Event ) throw(RuntimeException)
+    {
+        rtl::OUString sModuleName;
+        Event.Accessor >>= sModuleName;
+        OSL_TRACE("VBAProjectListener::elementReplaced(%s)", rtl::OUStringToOString( sModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mpMacroMgr->InitUserFuncData();
+        mpMacroMgr->BroadcastModuleUpdate(sModuleName);
+    }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+
+};
+
+void ScMacroManager::InitUserFuncData()
+{
+    // Clear hash_map
+    mhFuncToVolatile.clear();
+    String sProjectName( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+
+    Reference< container::XContainer > xModuleContainer;
+    SfxObjectShell* pShell = mpDoc->GetDocumentShell();
+    if ( pShell && pShell->GetBasicManager()->GetName().Len() > 0 )
+        sProjectName = pShell->GetBasicManager()->GetName();
+    try
+    { 
+        Reference< script::XLibraryContainer > xLibraries( pShell->GetBasicContainer(), uno::UNO_QUERY_THROW );
+        xModuleContainer.set( xLibraries->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+        
+        if ( xModuleContainer.is() )
+        {
+            // remove old listener ( if there was one )
+            if ( mxContainerListener.is() )
+                xModuleContainer->removeContainerListener( mxContainerListener );
+            // Create listener
+            mxContainerListener = new VBAProjectListener( this );
+            xModuleContainer->addContainerListener( mxContainerListener );
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+void ScMacroManager::SetUserFuncVolatile( const OUString& sName, bool isVolatile )
+{
+    mhFuncToVolatile[ sName ] = isVolatile;
+}
+
+bool ScMacroManager::GetUserFuncVolatile( const OUString& sName )
+{
+    NameBoolMap::iterator it = mhFuncToVolatile.find( sName );
+    if ( it == mhFuncToVolatile.end() )
+        return false;
+    return it->second;
+}
+
+void ScMacroManager::AddDependentCell(const OUString& aModuleName, ScFormulaCell* pCell)
+{
+    mpDepTracker->addCell(aModuleName, pCell);
+}
+
+void ScMacroManager::RemoveDependentCell(ScFormulaCell* pCell)
+{
+    mpDepTracker->removeCell(pCell);
+}
+
+void ScMacroManager::BroadcastModuleUpdate(const OUString& aModuleName)
+{
+    list<ScFormulaCell*> aCells;
+    mpDepTracker->getCellsByModule(aModuleName, aCells);
+    list<ScFormulaCell*>::iterator itr = aCells.begin(), itrEnd = aCells.end();
+    for (; itr != itrEnd; ++itr)
+    {   
+        ScFormulaCell* pCell = *itr; 
+        mpDoc->PutInFormulaTree(pCell); // for F9 recalc
+
+        // for recalc on cell value change.  If the cell is not volatile, the
+        // cell stops listening right away after it gets re-interpreted.
+        mpDoc->StartListeningArea(BCA_LISTEN_ALWAYS, pCell);
+    }
+}
+
diff --git sc/source/ui/docshell/makefile.mk sc/source/ui/docshell/makefile.mk
index 99a7495..6851f78 100644
--- sc/source/ui/docshell/makefile.mk
+++ sc/source/ui/docshell/makefile.mk
@@ -91,7 +91,8 @@ SLOFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 
 EXCEPTIONSFILES= \
@@ -101,7 +102,8 @@ EXCEPTIONSFILES= \
         $(SLO)$/docsh8.obj \
         $(SLO)$/externalrefmgr.obj \
         $(SLO)$/dbdocimp.obj \
-        $(SLO)$/docfunc.obj
+        $(SLO)$/docfunc.obj \
+	$(SLO)$/macromgr.obj
 
 SRS1NAME=$(TARGET)
 SRC1FILES =  tpstat.src
@@ -131,7 +133,8 @@ LIB1OBJFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 # --- Tagets -------------------------------------------------------
 
diff --git sc/source/ui/drawfunc/drawsh.cxx sc/source/ui/drawfunc/drawsh.cxx
index d1ab807..04248ae 100644
--- sc/source/ui/drawfunc/drawsh.cxx
+++ sc/source/ui/drawfunc/drawsh.cxx
@@ -208,7 +208,6 @@ void ScDrawShell::ExecDrawAttr( SfxRequest& rReq )
             ExecuteTextAttrDlg( rReq );
             break;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         case SID_DRAW_HLINK_EDIT:
             if ( pSingleSelectedObj )
                 pViewData->GetDispatcher().Execute( SID_HYPERLINK_DIALOG );
@@ -236,7 +235,6 @@ void ScDrawShell::ExecDrawAttr( SfxRequest& rReq )
                     ScGlobal::OpenURL( pInfo->GetHlink(), String::EmptyString() );
             }
             break;
-#endif
 
         case SID_ATTR_TRANSFORM:
             {
@@ -489,7 +487,6 @@ void ScDrawShell::ExecuteTextAttrDlg( SfxRequest& rReq, USHORT /* nTabPage */ )
     delete( pDlg );
 }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 void ScDrawShell::SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk )
 {
     if ( pObj )
@@ -499,5 +496,4 @@ void ScDrawShell::SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk
         lcl_setModified( GetObjectShell() );
     }
 }
-#endif
 
diff --git sc/source/ui/drawfunc/drawsh2.cxx sc/source/ui/drawfunc/drawsh2.cxx
index 7d1392b..05a7930 100644
--- sc/source/ui/drawfunc/drawsh2.cxx
+++ sc/source/ui/drawfunc/drawsh2.cxx
@@ -197,24 +197,20 @@ void ScDrawShell::GetDrawFuncState( SfxItemSet& rSet )		// Funktionen disablen
     BOOL bCanRename = FALSE;
     if ( nMarkCount > 1 )
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         // no hypelink options for a selected group
         rSet.DisableItem( SID_DRAW_HLINK_EDIT );
         rSet.DisableItem( SID_DRAW_HLINK_DELETE );
         rSet.DisableItem( SID_OPEN_HYPERLINK );
-#endif
     }
     else if ( nMarkCount == 1 )
     {
         SdrObject* pObj = rMarkList.GetMark( 0 )->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( !pInfo || (pInfo->GetHlink().getLength() == 0) )
         {
             rSet.DisableItem( SID_DRAW_HLINK_DELETE );
             rSet.DisableItem( SID_OPEN_HYPERLINK );
         }
-#endif
         SdrLayerID nLayerID = pObj->GetLayer();
         if ( nLayerID != SC_LAYER_INTERN )
             bCanRename = TRUE;                          // #i51351# anything except internal objects can be renamed
diff --git sc/source/ui/drawfunc/drawsh5.cxx sc/source/ui/drawfunc/drawsh5.cxx
index 2908af8..cb2e019 100644
--- sc/source/ui/drawfunc/drawsh5.cxx
+++ sc/source/ui/drawfunc/drawsh5.cxx
@@ -92,14 +92,12 @@ void ScDrawShell::GetHLinkState( SfxItemSet& rSet )             //  Hyperlink
     if ( nMarkCount == 1 )              // URL-Button markiert ?
     {
         SdrObject* pObj = rMarkList.GetMark(0)->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
         {
             aHLinkItem.SetURL( pInfo->GetHlink() );
             aHLinkItem.SetInsertMode(HLINK_FIELD);
         }
-#endif
         SdrUnoObj* pUnoCtrl = PTR_CAST(SdrUnoObj, pObj);
         if (pUnoCtrl && FmFormInventor == pUnoCtrl->GetObjInventor())
         {
@@ -242,13 +240,11 @@ void ScDrawShell::ExecuteHLink( SfxRequest& rReq )
                                     bDone = TRUE;
                                 }
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             else
                             {
                                 SetHlinkForObject( pObj, rURL );
                                 bDone = TRUE;
                             }
-#endif
                         }
                     }
 
diff --git sc/source/ui/drawfunc/fudraw.cxx sc/source/ui/drawfunc/fudraw.cxx
index 4cbd08d..ee901e2 100644
--- sc/source/ui/drawfunc/fudraw.cxx
+++ sc/source/ui/drawfunc/fudraw.cxx
@@ -828,11 +828,7 @@ void FuDraw::ForcePointer(const MouseEvent* pMEvt)
             SdrObjMacroHitRec aHitRec;	//! muss da noch irgendwas gesetzt werden ????
             pViewShell->SetActivePointer( pObj->GetMacroPointer(aHitRec) );
         }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         else if ( !bAlt && pInfo && ((pInfo->GetMacro().getLength() > 0) || (pInfo->GetHlink().getLength() > 0)) )
-#else
-        else if ( !bAlt && pInfo && (pInfo->GetMacro().getLength() > 0) )
-#endif
             pWindow->SetPointer( Pointer( POINTER_REFHAND ) );
         else if ( IsDetectiveHit( aPnt ) )
             pViewShell->SetActivePointer( Pointer( POINTER_DETECTIVE ) );
diff --git sc/source/ui/drawfunc/fusel.cxx sc/source/ui/drawfunc/fusel.cxx
index 2c284d3..538cf1f 100644
--- sc/source/ui/drawfunc/fusel.cxx
+++ sc/source/ui/drawfunc/fusel.cxx
@@ -202,7 +202,6 @@ BOOL __EXPORT FuSelection::MouseButtonDown(const MouseEvent& rMEvt)
                    }
 
                    ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj, TRUE );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                    // For interoperability favour links over macros if both are defined
                    if ( pInfo->GetHlink().getLength() > 0 )
                    {
@@ -210,20 +209,27 @@ BOOL __EXPORT FuSelection::MouseButtonDown(const MouseEvent& rMEvt)
                        sURL = pInfo->GetHlink();
                    }
                    else if ( pInfo->GetMacro().getLength() > 0 )
-#else
-                   if ( pInfo->GetMacro().getLength() > 0 )
-#endif
                    {
                        SfxObjectShell* pObjSh = SfxObjectShell::Current();
                        if ( pObjSh && SfxApplication::IsXScriptURL( pInfo->GetMacro() ) )
                        {
+                           uno::Reference< beans::XPropertySet > xProps( pObj->getUnoShape(), uno::UNO_QUERY );
+                           uno::Any aCaller;
+                           if ( xProps.is() )
+                           {
+                               try
+                               {
+                                   aCaller = xProps->getPropertyValue( rtl::OUString::createFromAscii("Name") );
+                               }
+                               catch( uno::Exception& ) {}
+                           }
                            uno::Any aRet;
                            uno::Sequence< sal_Int16 > aOutArgsIndex;
                            uno::Sequence< uno::Any > aOutArgs;
                            uno::Sequence< uno::Any >* pInArgs =
                                new uno::Sequence< uno::Any >(0);
                            pObjSh->CallXScript( pInfo->GetMacro(),
-                               *pInArgs, aRet, aOutArgsIndex, aOutArgs);
+                               *pInArgs, aRet, aOutArgsIndex, aOutArgs, true, &aCaller );
                            pViewShell->FakeButtonUp( pViewShell->GetViewData()->GetActivePart() );
                            return TRUE;        // kein CaptureMouse etc.
                        }
diff --git sc/source/ui/drawfunc/makefile.mk sc/source/ui/drawfunc/makefile.mk
index a50c450..f82008e 100644
--- sc/source/ui/drawfunc/makefile.mk
+++ sc/source/ui/drawfunc/makefile.mk
@@ -75,6 +75,7 @@ SLOFILES =  \
         $(SLO)$/mediash.obj
 
 EXCEPTIONSFILES= \
+        $(SLO)$/fusel.obj \
         $(SLO)$/fuins2.obj \
         $(SLO)$/graphsh.obj	\
         $(SLO)$/mediash.obj
diff --git sc/source/ui/drawfunc/objdraw.src sc/source/ui/drawfunc/objdraw.src
index 81d1e2c..9fb1b96 100644
--- sc/source/ui/drawfunc/objdraw.src
+++ sc/source/ui/drawfunc/objdraw.src
@@ -186,7 +186,6 @@
         ITEM_FORMAT_PARA_DLG\
     };
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 #define MN_EDITLNK \
     MenuItem\
     {\
@@ -202,7 +201,6 @@
         HelpID = SID_DRAW_HLINK_DELETE ; \
         Text [ en-US ] = "~Remove Hyperlink" ; \
     };
-#endif
 
 #define MN_DRWTXTATTR \
     MenuItem\
@@ -1297,14 +1295,12 @@ Menu RID_POPUP_DRAW
         MenuItem { Separator = TRUE ; };
          //------------------------------
         ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
          //------------------------------
         MenuItem { Separator = TRUE ; };
          //------------------------------
         MN_EDITLNK
         MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
     };
 };
 
@@ -1374,14 +1370,12 @@ Menu RID_POPUP_GRAPHIC
         MenuItem { Separator = TRUE ; };
          //------------------------------
         ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
          //------------------------------
         MenuItem { Separator = TRUE ; };
          //------------------------------
         MN_EDITLNK
         MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
     };
 };
 
diff --git sc/source/ui/inc/asciiopt.hxx sc/source/ui/inc/asciiopt.hxx
index 0c6df4b..783650c 100644
--- sc/source/ui/inc/asciiopt.hxx
+++ sc/source/ui/inc/asciiopt.hxx
@@ -56,7 +56,7 @@
 
 // ============================================================================
 
-class ScAsciiOptions
+class SC_DLLPUBLIC ScAsciiOptions
 {
 private:
     BOOL		bFixedLen;
diff --git sc/source/ui/inc/datafdlg.hrc sc/source/ui/inc/datafdlg.hrc
new file mode 100644
index 0000000..8fa8999
--- /dev/null
+++ sc/source/ui/inc/datafdlg.hrc
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hrc,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:37:12 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sc.hrc"	// -> RID_SCDLG_DATAFORM
+
+//dataform
+#define BTN_DATAFORM_NEW          1001
+#define BTN_DATAFORM_DELETE       1002
+#define BTN_DATAFORM_RESTORE      1003
+#define BTN_DATAFORM_LAST         1004
+#define BTN_DATAFORM_NEXT         1005
+#define BTN_DATAFORM_CLOSE        1007
+#define WND_DATAFORM_SCROLLBAR    1008
+#define LAB_DATAFORM_RECORDNO     1009
+
+#define FT_DATAFORM_FIXEDTEXT1    2001
+#define ED_DATAFORM_EDIT1         2002
\ No newline at end of file
diff --git sc/source/ui/inc/datafdlg.hxx sc/source/ui/inc/datafdlg.hxx
new file mode 100644
index 0000000..3e6d8e3
--- /dev/null
+++ sc/source/ui/inc/datafdlg.hxx
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:20:35 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DATAFDLG_HXX
+#define SC_DATAFDLG_HXX
+
+
+#ifndef _SV_DIALOG_HXX //autogen
+#include <vcl/dialog.hxx>
+#endif
+
+#ifndef _SV_BUTTON_HXX //autogen
+#include <vcl/imagebtn.hxx>
+#endif
+
+#ifndef _SV_FIXED_HXX //autogen
+#include <vcl/fixed.hxx>
+#endif
+
+
+#include "global.hxx"
+
+#include <tabvwsh.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/dispatch.hxx>
+
+#define MAX_DATAFORM_COLS   256
+#define MAX_DATAFORM_ROWS   32000
+#define CTRL_HEIGHT         22
+#define FIXED_WIDTH         60
+#define EDIT_WIDTH          140 
+#define FIXED_LEFT          12
+#define EDIT_LEFT           78
+#define LINE_HEIGHT         30
+
+//zhangyun
+class ScDataFormDlg : public ModalDialog
+{
+private:
+
+    PushButton      aBtnNew;
+    PushButton      aBtnDelete;
+    PushButton      aBtnRestore;
+    PushButton      aBtnLast;
+    PushButton      aBtnNext;
+    PushButton      aBtnClose;
+    ScrollBar       aSlider;
+    FixedText       aFixedText;
+    //FixedText       aFixedText1;
+    //Edit            aEdit1;
+    
+    ScTabViewShell* pTabViewShell;
+    ScDocument*     pDoc;
+    sal_uInt16      aColLength;
+    SCROW           aCurrentRow;
+    SCCOL           nStartCol;
+    SCCOL           nEndCol;
+    SCROW           nStartRow;
+    SCROW           nEndRow;
+    SCTAB           nTab;
+    BOOL            bNoSelection;
+    
+    FixedText** pFixedTexts;
+    Edit** pEdits;
+
+public:
+    ScDataFormDlg( Window* pParent, ScTabViewShell* pTabViewShell);
+    ~ScDataFormDlg();
+    
+    void FillCtrls(SCROW nCurrentRow);
+private:
+
+    void SetButtonState();
+
+    // Handler:
+    DECL_LINK( Impl_NewHdl,     PushButton*    );
+    DECL_LINK( Impl_LastHdl,    PushButton*    );
+    DECL_LINK( Impl_NextHdl,    PushButton*    );
+    
+    DECL_LINK( Impl_RestoreHdl, PushButton*    );
+    DECL_LINK( Impl_DeleteHdl,  PushButton*    );
+    DECL_LINK( Impl_CloseHdl,   PushButton*    );
+    
+    DECL_LINK( Impl_ScrollHdl,  ScrollBar*    );
+    DECL_LINK( Impl_DataModifyHdl,  Edit*    );
+};
+#endif // SC_DATAFDLG_HXX
+
+
diff --git sc/source/ui/inc/docfunc.hxx sc/source/ui/inc/docfunc.hxx
index a39bda5..9a6ee54 100644
--- sc/source/ui/inc/docfunc.hxx
+++ sc/source/ui/inc/docfunc.hxx
@@ -167,7 +167,9 @@ public:
                                 double fStart, double fStep, double fMax,
                                 BOOL bRecord, BOOL bApi );
                     // FillAuto: rRange wird von Source-Range auf Dest-Range angepasst
-    BOOL            FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
+	SC_DLLPUBLIC	BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax, BOOL bRecord, BOOL bApi );
+
+    BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
                                 FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi );
 
     BOOL            ResizeMatrix( const ScRange& rOldRange, const ScAddress& rNewEnd, BOOL bApi );
diff --git sc/source/ui/inc/docsh.hxx sc/source/ui/inc/docsh.hxx
index b1b1b0b..53abd68 100644
--- sc/source/ui/inc/docsh.hxx
+++ sc/source/ui/inc/docsh.hxx
@@ -42,6 +42,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
@@ -298,6 +299,10 @@ public:
                                     ScMarkData& rMark, BOOL bRecord = TRUE );
     void			ModifyScenario( SCTAB nTab, const String& rName, const String& rComment,
                                     const Color& rColor, USHORT nFlags );
+    ULONG TransferTab( ScDocShell& rSrcDocShell, SCTAB nSrcPos,
+                                SCTAB nDestPos, BOOL bInsertNew,
+                                BOOL bNotifyAndPaint );
+
     BOOL			MoveTable( SCTAB nSrcTab, SCTAB nDestTab, BOOL bCopy, BOOL bRecord );
 
     void			DoRecalc( BOOL bApi );
diff --git sc/source/ui/inc/drawsh.hxx sc/source/ui/inc/drawsh.hxx
index 47ea4ce..5e6e568 100644
--- sc/source/ui/inc/drawsh.hxx
+++ sc/source/ui/inc/drawsh.hxx
@@ -44,9 +44,7 @@ class ScDrawShell : public SfxShell
 
     DECL_LINK( NameObjectHdl, AbstractSvxNameDialog* );
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk );
-#endif
 
 protected:
     ScViewData*	GetViewData()	{ return pViewData; }
diff --git sc/source/ui/inc/impex.hxx sc/source/ui/inc/impex.hxx
index e28b34e..491d933 100644
--- sc/source/ui/inc/impex.hxx
+++ sc/source/ui/inc/impex.hxx
@@ -50,7 +50,7 @@ struct ScExportTextOptions
     bool mbAddQuotes;
 };
 
-class ScImportExport
+class SC_DLLPUBLIC ScImportExport
 {
     ScDocShell* pDocSh;
     ScDocument* pDoc;
diff --git sc/source/ui/inc/tabvwsh.hxx sc/source/ui/inc/tabvwsh.hxx
index 91add9d..aba6f9d 100644
--- sc/source/ui/inc/tabvwsh.hxx
+++ sc/source/ui/inc/tabvwsh.hxx
@@ -252,7 +252,7 @@ public:
 
     virtual			~ScTabViewShell();
 
-    Window*			GetDialogParent();
+	SC_DLLPUBLIC Window* GetDialogParent();
 
     bool            IsRefInputMode() const;
     void			ExecuteInputDirect();
@@ -298,7 +298,7 @@ public:
     void			GetSaveState( SfxItemSet& rSet );
     void			ExecSearch( SfxRequest& rReq );
 
-    void			ExecuteUndo(SfxRequest& rReq);
+	SC_DLLPUBLIC    void			ExecuteUndo(SfxRequest& rReq);
     void			GetUndoState(SfxItemSet &rSet);
 
     void			ExecuteSbx( SfxRequest& rReq );
diff --git sc/source/ui/inc/undodat.hxx sc/source/ui/inc/undodat.hxx
index 81da22e..cba77ef 100644
--- sc/source/ui/inc/undodat.hxx
+++ sc/source/ui/inc/undodat.hxx
@@ -528,7 +528,43 @@ private:
     void				Init();
 };
 
+// amelia
+class ScUndoDataForm: public ScBlockUndo
+{
+public:
+					TYPEINFO();
+					ScUndoDataForm( ScDocShell* pNewDocShell,
+								SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+								SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+								const ScMarkData& rMark,
+								ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+								USHORT nNewFlags,
+								ScRefUndoData* pRefData, void* pFill1, void* pFill2, void* pFill3,
+								BOOL bRedoIsFilled = TRUE
+								 );
+	virtual		~ScUndoDataForm();
+
+	virtual	void	Undo();
+	virtual	void	Redo();
+	virtual void	Repeat(SfxRepeatTarget& rTarget);
+	virtual BOOL	CanRepeat(SfxRepeatTarget& rTarget) const;
+
+	virtual String	GetComment() const;
 
+private:
+	ScMarkData		aMarkData;
+	ScDocument*		pUndoDoc;
+	ScDocument*		pRedoDoc;
+	USHORT			nFlags;
+	ScRefUndoData*		pRefUndoData;
+	ScRefUndoData*		pRefRedoData;
+	ULONG			nStartChangeAction;
+	ULONG			nEndChangeAction;
+	BOOL			bRedoFilled;
+
+	void			DoChange( const BOOL bUndo );
+	void			SetChangeTrack();
+};
 
 
 #endif
diff --git sc/source/ui/inc/viewfunc.hxx sc/source/ui/inc/viewfunc.hxx
index 8a5aeee..6e9ec02 100644
--- sc/source/ui/inc/viewfunc.hxx
+++ sc/source/ui/inc/viewfunc.hxx
@@ -338,6 +338,13 @@ public:
     void			ForgetFormatArea()		{ bFormatValid = FALSE; }
     BOOL			SelectionEditable( BOOL* pOnlyNotBecauseOfMatrix = NULL );
 
+        // Amelia Wang
+        SC_DLLPUBLIC void                   DataFormPutData( SCROW nCurrentRow ,
+                                                             SCROW nStartRow , SCCOL nStartCol ,
+                                                             SCROW nEndRow , SCCOL nEndCol ,
+                                                             Edit** pEdits ,
+                                                             sal_uInt16 aColLength );
+
                                                 // interne Hilfsfunktionen
 protected:
     void			UpdateLineAttrs( SvxBorderLine&		  rLine,
diff --git sc/source/ui/miscdlgs/datafdlg.cxx sc/source/ui/miscdlgs/datafdlg.cxx
new file mode 100644
index 0000000..619355c
--- /dev/null
+++ sc/source/ui/miscdlgs/datafdlg.cxx
@@ -0,0 +1,422 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.cxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: kz $ $Date: 2006/07/21 14:04:33 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+#undef SC_DLLIMPLEMENTATION
+
+//------------------------------------------------------------------
+
+#include "datafdlg.hxx"
+#include "scresid.hxx"
+#include "datafdlg.hrc"
+#include "viewdata.hxx"
+//#include "document.hxx"
+#include "docsh.hxx"
+#include "refundo.hxx"
+#include "undodat.hxx"
+
+#define HDL(hdl)            LINK( this, ScDataFormDlg, hdl )
+
+//zhangyun
+ScDataFormDlg::ScDataFormDlg( Window* pParent, ScTabViewShell*  pTabViewShellOri) :
+    ModalDialog     ( pParent, ScResId( RID_SCDLG_DATAFORM ) ),
+    //
+    aBtnNew          ( this, ScResId( BTN_DATAFORM_NEW ) ),
+    aBtnDelete          ( this, ScResId( BTN_DATAFORM_DELETE ) ),
+    aBtnRestore          ( this, ScResId( BTN_DATAFORM_RESTORE ) ),
+    aBtnLast          ( this, ScResId( BTN_DATAFORM_LAST ) ),
+    aBtnNext          ( this, ScResId( BTN_DATAFORM_NEXT ) ),
+    aBtnClose          ( this, ScResId( BTN_DATAFORM_CLOSE ) ),
+    aSlider         ( this, ScResId( WND_DATAFORM_SCROLLBAR ) ),
+    aFixedText          ( this, ScResId( LAB_DATAFORM_RECORDNO ) )
+{
+    pTabViewShell = pTabViewShellOri;
+    FreeResource();
+    //read header form current document, and add new controls
+    DBG_ASSERT( pTabViewShell, "pTabViewShell is NULL! :-/" );
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    
+    pDoc = pViewData->GetDocument();
+    if (pDoc)
+    {
+        ScRange aRange;
+        pViewData->GetSimpleArea( aRange );
+        ScAddress aStart = aRange.aStart;
+        ScAddress aEnd = aRange.aEnd;
+        
+        nStartCol = aStart.Col();
+        nEndCol = aEnd.Col();
+        nStartRow   = aStart.Row();
+        nEndRow = aEnd.Row();
+        
+        nTab = pViewData->GetTabNo();
+        //if there is no selection
+        if ((nStartCol == nEndCol) && (nStartRow == nEndRow))
+            bNoSelection = TRUE;
+        
+        if (bNoSelection)
+        {
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                nEndCol++;
+                pDoc->GetString( nEndCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nEndCol--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                if (nStartCol <= 0)
+                    break;
+                nStartCol--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nStartCol++;
+                    break;
+                }
+            }
+            
+            //skip leading hide column
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                int nColWidth = pDoc->GetColWidth( nStartCol, nTab );
+                if (nColWidth)
+                    break;
+                nStartCol++;
+            }
+
+            if (nEndCol < nStartCol)
+                nEndCol = nStartCol;
+                
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                nEndRow++;
+                pDoc->GetString( nStartCol, nEndRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nEndRow--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                if (nStartRow <= 0)
+                    break;
+                nStartRow--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nStartRow++;
+                    break;
+                }
+            }
+
+            if (nEndRow < nStartRow)
+                nEndRow = nStartRow;
+        }
+        
+        aCurrentRow = nStartRow + 1;
+        
+        String  aFieldName;
+
+        int nTop = 12;
+
+        Size    nFixedSize(FIXED_WIDTH, CTRL_HEIGHT );
+        Size    nEditSize(EDIT_WIDTH, CTRL_HEIGHT );
+        
+        //pFtArray = new FixedText(this);
+        aColLength = nEndCol - nStartCol + 1;
+        
+        //new the controls
+        pFixedTexts = new FixedText*[aColLength];
+        pEdits = new Edit*[aColLength];
+        
+        for(sal_uInt16 nIndex = 0; nIndex < aColLength; nIndex++)
+        {
+            pDoc->GetString( nIndex + nStartCol, nStartRow, nTab, aFieldName );
+            int nColWidth = pDoc->GetColWidth( nIndex + nStartCol, nTab );
+            if (nColWidth)
+            {
+                pFixedTexts[nIndex] = new FixedText(this);
+                pEdits[nIndex] = new Edit(this, WB_BORDER);
+        
+                pFixedTexts[nIndex]->SetSizePixel(nFixedSize);
+                pEdits[nIndex]->SetSizePixel(nEditSize);
+                pFixedTexts[nIndex]->SetPosPixel(Point(FIXED_LEFT, nTop));
+                pEdits[nIndex]->SetPosPixel(Point(EDIT_LEFT, nTop));
+                //pFixedTexts[nIndex]->SetText(String::CreateFromAscii("W4W-Filter Nr. "));
+                pFixedTexts[nIndex]->SetText(aFieldName);
+                pFixedTexts[nIndex]->Show();
+                pEdits[nIndex]->Show();
+                
+                nTop += LINE_HEIGHT;
+            }
+            else
+            {
+                pFixedTexts[nIndex] = NULL;
+                pEdits[nIndex] = NULL;
+            }
+        pEdits[nIndex]->SetModifyHdl( HDL(Impl_DataModifyHdl) );
+        }
+        
+        Size nDialogSize = this->GetSizePixel();
+        if (nTop > nDialogSize.Height())
+        {
+            nDialogSize.setHeight(nTop);
+            this->SetSizePixel(nDialogSize);
+        }
+        Size nScrollSize = aSlider.GetSizePixel();
+        nScrollSize.setHeight(nDialogSize.Height()-20);
+        aSlider.SetSizePixel(nScrollSize);
+    }
+    
+    FillCtrls(aCurrentRow);
+    
+    aSlider.SetPageSize( 10 );
+    aSlider.SetVisibleSize( 1 );
+    aSlider.SetLineSize( 1 );
+    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+    aSlider.Show();
+    
+    aBtnNew.SetClickHdl     ( HDL(Impl_NewHdl)    );
+    aBtnLast.SetClickHdl    ( HDL(Impl_LastHdl)    );
+    aBtnNext.SetClickHdl    ( HDL(Impl_NextHdl)    );
+    
+    aBtnRestore.SetClickHdl     ( HDL(Impl_RestoreHdl)    );
+    aBtnDelete.SetClickHdl  ( HDL(Impl_DeleteHdl)    );
+    aBtnClose.SetClickHdl   ( HDL(Impl_CloseHdl)    );
+    
+    aSlider.SetEndScrollHdl( HDL( Impl_ScrollHdl ) );
+
+    SetButtonState();
+
+    //end
+    //FreeResource();
+}
+
+ScDataFormDlg::~ScDataFormDlg()
+{
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+            delete pEdits[i];
+        if (pFixedTexts[i])
+            delete pFixedTexts[i];
+    }
+    if (pEdits)
+        delete pEdits;
+    if (pFixedTexts)
+        delete pFixedTexts;
+}
+
+void ScDataFormDlg::FillCtrls(SCROW /*nCurrentRow*/)
+{
+    //ScViewData*   pViewData = pTabViewShell->GetViewData();
+    
+    //pDoc = pViewData->GetDocument();
+    String  aFieldName;
+    int nRecordNum = nEndRow - nStartRow;
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+        {
+            if (aCurrentRow<=nEndRow)
+            {
+                pDoc->GetString( i + nStartCol, aCurrentRow, nTab, aFieldName );
+                pEdits[i]->SetText(aFieldName);
+            }
+            else
+                pEdits[i]->SetText(String());
+        }
+    }
+    char sRecordStr[256];
+    if (aCurrentRow<=nEndRow)
+        aFixedText.SetText(String::CreateFromAscii(sRecordStr));
+    else
+        aFixedText.SetText(String::CreateFromAscii("New Record"));
+        
+    aSlider.SetThumbPos(aCurrentRow-nStartRow-1);
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DataModifyHdl, Edit*, pEdit)
+{
+    if ( pEdit->IsModified() )
+        aBtnRestore.Enable( TRUE );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NewHdl, PushButton*, EMPTYARG )
+{
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if ( pDoc )
+    {
+        sal_Bool bHasData = sal_False;
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+            if (pEdits[i])
+                if ( pEdits[i]->GetText().Len() != 0 )
+                {
+                    bHasData = sal_True;
+                    break;
+                }
+
+        if ( bHasData )
+        {
+            pTabViewShell->DataFormPutData( aCurrentRow , nStartRow , nStartCol , nEndRow , nEndCol , pEdits , aColLength );
+            aCurrentRow++;
+            if (aCurrentRow >= nEndRow + 2)
+            {
+                    nEndRow ++ ;
+                    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+            }
+            SetButtonState();
+            FillCtrls(aCurrentRow);
+            pDocSh->SetDocumentModified();
+            pDocSh->PostPaintGridAll();
+            }
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_LastHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow > nStartRow +1 )
+            aCurrentRow--;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NextHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow <= nEndRow)
+            aCurrentRow++;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_RestoreHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DeleteHdl, PushButton*, EMPTYARG )
+{   
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if (pDoc)
+    {
+        ScRange aRange(nStartCol, aCurrentRow, nTab, nEndCol, aCurrentRow, nTab);
+        pDoc->DeleteRow(aRange);
+        nEndRow--;
+        
+        SetButtonState();
+        pDocSh->GetUndoManager()->Clear();
+
+        FillCtrls(aCurrentRow);
+        pDocSh->SetDocumentModified();
+        pDocSh->PostPaintGridAll();
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_CloseHdl, PushButton*, EMPTYARG )
+{   
+    EndDialog( );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_ScrollHdl, ScrollBar*, EMPTYARG )
+{   
+    long nOffset = aSlider.GetThumbPos();
+    aCurrentRow = nStartRow + nOffset + 1;
+    SetButtonState();
+    FillCtrls(aCurrentRow);
+    return 0;
+}
+
+void ScDataFormDlg::SetButtonState()
+{
+    if ( aCurrentRow > nEndRow )
+    {
+        aBtnDelete.Enable( FALSE );
+        aBtnLast.Enable( TRUE );
+        aBtnNext.Enable( FALSE );
+    }
+    else
+    {
+        aBtnDelete.Enable( TRUE );
+        aBtnNext.Enable( TRUE );
+    }
+    if ( 1 == aCurrentRow )
+        aBtnLast.Enable( FALSE );
+
+    aBtnRestore.Enable( FALSE );
+    if ( pEdits )
+        pEdits[0]->GrabFocus();
+}
diff --git sc/source/ui/miscdlgs/makefile.mk sc/source/ui/miscdlgs/makefile.mk
index 8c56101..07e70a1 100644
--- sc/source/ui/miscdlgs/makefile.mk
+++ sc/source/ui/miscdlgs/makefile.mk
@@ -41,6 +41,7 @@ LIBTARGET=no
 # --- Files --------------------------------------------------------
 
 SLOFILES =  \
+	$(SLO)$/datafdlg.obj		\
     $(SLO)$/delcldlg.obj		\
     $(SLO)$/inscldlg.obj		\
     $(SLO)$/delcodlg.obj		\
diff --git sc/source/ui/src/datafdlg.src sc/source/ui/src/datafdlg.src
new file mode 100644
index 0000000..535ec66
--- /dev/null
+++ sc/source/ui/src/datafdlg.src
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.src,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: hr $ $Date: 2005/09/23 15:07:30 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "datafdlg.hrc"
+
+//zhangyun, dataform
+ModalDialog RID_SCDLG_DATAFORM
+{
+    OutputSize = TRUE ;
+    SVLook = TRUE ;
+    Size = MAP_APPFONT ( 191 , 180 ) ;
+    Text [ en-US ] = "Data Form" ;
+    Moveable = TRUE ;
+    Closeable = TRUE ;
+    FixedText LAB_DATAFORM_RECORDNO
+    {
+        Pos = MAP_APPFONT ( 136 , 6 ) ;
+        Size = MAP_APPFONT ( 50 , 12 ) ;
+        Text [ en-US ] = "/" ;
+    };
+    PushButton BTN_DATAFORM_NEW
+    {
+        Pos = MAP_APPFONT ( 135 , 23 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        DefButton = TRUE ;
+        Text [ en-US ] = "New" ;
+    };
+    PushButton BTN_DATAFORM_DELETE
+    {
+        Pos = MAP_APPFONT ( 135 , 40 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Delete" ;
+    };
+    PushButton BTN_DATAFORM_RESTORE
+    {
+        Pos = MAP_APPFONT ( 135 , 57 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Restore" ;
+    };
+    PushButton BTN_DATAFORM_LAST
+    {
+        Pos = MAP_APPFONT ( 135 , 82 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Last Record" ;
+    };
+    PushButton BTN_DATAFORM_NEXT
+    {
+        Pos = MAP_APPFONT ( 135 , 99 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Next Record" ;
+    };
+    PushButton BTN_DATAFORM_CLOSE
+    {
+        Pos = MAP_APPFONT ( 135 , 116 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Close" ;
+    };
+    ScrollBar WND_DATAFORM_SCROLLBAR
+    {
+        Pos = MAP_APPFONT ( 124 , 6 ) ;
+        Size = MAP_APPFONT ( 8 , 135 ) ;
+        HScroll = FALSE ;
+        TabStop = FALSE ;
+    };
+};
+//end
+
+
+
+
diff --git sc/source/ui/src/globstr.src sc/source/ui/src/globstr.src
index 37f0d31..eceefa6 100644
--- sc/source/ui/src/globstr.src
+++ sc/source/ui/src/globstr.src
@@ -1718,6 +1718,77 @@ Resource RID_GLOBSTR
     {
         Text [ en-US ] = "Unknown User";
     };
+
+    String STR_SHAPE_AUTOSHAPE
+    {
+        Text [ en-US ] = "AutoShape";
+    };
+
+    String STR_SHAPE_RECTANGLE
+    {
+        Text [ en-US ] = "Rectangle";
+    };
+
+    String STR_SHAPE_LINE
+    {
+        Text [ en-US ] = "Line";
+    };
+
+    String STR_SHAPE_OVAL
+    {
+        Text [ en-US ] = "Oval";
+    };
+
+    String STR_SHAPE_TEXTBOX
+    {
+        Text [ en-US ] = "Text Box";
+    };
+
+    String STR_FORM_BUTTON
+    {
+        Text [ en-US ] = "Button";
+    };
+
+    String STR_FORM_CHECKBOX
+    {
+        Text [ en-US ] = "Check Box";
+    };
+
+    String STR_FORM_OPTIONBUTTON
+    {
+        Text [ en-US ] = "Option Button";
+    };
+
+    String STR_FORM_LABEL
+    {
+        Text [ en-US ] = "Label";
+    };
+
+    String STR_FORM_LISTBOX
+    {
+        Text [ en-US ] = "List Box";
+    };
+
+    String STR_FORM_GROUPBOX
+    {
+        Text [ en-US ] = "Group Box";
+    };
+
+    String STR_FORM_DROPDOWN 
+    {
+        Text [ en-US ] = "Drop Down";
+    };
+
+    String STR_FORM_SPINNER
+    {
+        Text [ en-US ] = "Spinner";
+    };
+
+    String STR_FORM_SCROLLBAR
+    {
+        Text [ en-US ] = "Scroll Bar";
+    };
+
     String STR_STYLE_FAMILY_CELL
     {
         Text [ en-US ] = "Cell Styles";
diff --git sc/source/ui/src/makefile.mk sc/source/ui/src/makefile.mk
index 96bb78e..c935a08 100644
--- sc/source/ui/src/makefile.mk
+++ sc/source/ui/src/makefile.mk
@@ -53,6 +53,7 @@ SRC1FILES = \
     dbnamdlg.src \
     subtdlg.src  \
     miscdlgs.src \
+	datafdlg.src \
     autofmt.src  \
     solvrdlg.src \
     optsolver.src \
diff --git sc/source/ui/undo/undodat.cxx sc/source/ui/undo/undodat.cxx
index d42dc64..a175ea6 100644
--- sc/source/ui/undo/undodat.cxx
+++ sc/source/ui/undo/undodat.cxx
@@ -52,6 +52,8 @@
 #include "attrib.hxx"
 #include "hints.hxx"
 #include "sc.hrc"
+#include "chgtrack.hxx"  // Amelia Wang
+#include "refundo.hxx"  // Amelia Wang
 
 // -----------------------------------------------------------------------
 
@@ -72,6 +74,7 @@ TYPEINIT1(ScUndoRepeatDB,           ScSimpleUndo);
 TYPEINIT1(ScUndoDataPilot,          ScSimpleUndo);
 TYPEINIT1(ScUndoConsolidate,        ScSimpleUndo);
 TYPEINIT1(ScUndoChartData,          ScSimpleUndo);
+TYPEINIT1(ScUndoDataForm,           SfxUndoAction);    // amelia
 
 // -----------------------------------------------------------------------
 
@@ -2186,8 +2189,210 @@ BOOL __EXPORT ScUndoChartData::CanRepeat(SfxRepeatTarget& /* rTarget */) const
     return FALSE;
 }
 
+// Amelia Wang
+ScUndoDataForm::ScUndoDataForm( ScDocShell* pNewDocShell,
+                                SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+                                SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+                                const ScMarkData& rMark,
+                                ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+                                USHORT nNewFlags,
+                                ScRefUndoData* pRefData,
+                                void* /*pFill1*/, void* /*pFill2*/, void* /*pFill3*/,
+                                BOOL bRedoIsFilled ) :
+        ScBlockUndo( pNewDocShell, ScRange( nStartX, nStartY, nStartZ, nEndX, nEndY, nEndZ ), SC_UNDO_SIMPLE ),
+        aMarkData( rMark ),
+        pUndoDoc( pNewUndoDoc ),
+        pRedoDoc( pNewRedoDoc ),
+        nFlags( nNewFlags ),
+        pRefUndoData( pRefData ),
+        pRefRedoData( NULL ),
+        bRedoFilled( bRedoIsFilled )
+{
+        //      pFill1,pFill2,pFill3 are there so the ctor calls for simple paste (without cutting)
+        //      don't have to be changed and branched for 641.
+        //      They can be removed later.
+
+        if ( !aMarkData.IsMarked() )                            // no cell marked:
+                aMarkData.SetMarkArea( aBlockRange );   //  mark paste block
+
+        if ( pRefUndoData )
+                pRefUndoData->DeleteUnchanged( pDocShell->GetDocument() );
+
+        SetChangeTrack();
+}
+
+ScUndoDataForm::~ScUndoDataForm()
+{
+        delete pUndoDoc;
+        delete pRedoDoc;
+        delete pRefUndoData;
+        delete pRefRedoData;
+}
+
+String ScUndoDataForm::GetComment() const
+{
+        return ScGlobal::GetRscString( STR_UNDO_PASTE ); 
+}
+
+void ScUndoDataForm::SetChangeTrack()
+{
+        ScChangeTrack* pChangeTrack = pDocShell->GetDocument()->GetChangeTrack();
+        if ( pChangeTrack && (nFlags & IDF_CONTENTS) )
+                pChangeTrack->AppendContentRange( aBlockRange, pUndoDoc,
+                        nStartChangeAction, nEndChangeAction, SC_CACM_PASTE );
+        else
+                nStartChangeAction = nEndChangeAction = 0;
+}
+
+
+void ScUndoDataForm::Undo()
+{
+        BeginUndo();
+        DoChange( TRUE );
+        ShowTable( aBlockRange );
+        EndUndo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Redo()
+{
+        BeginRedo();
+        ScDocument* pDoc = pDocShell->GetDocument();
+        EnableDrawAdjust( pDoc, FALSE );                                //! include in ScBlockUndo?
+        DoChange( FALSE );
+        EnableDrawAdjust( pDoc, TRUE );                                 //! include in ScBlockUndo?
+        EndRedo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Repeat(SfxRepeatTarget& /*rTarget*/)
+{
+}
+
+BOOL ScUndoDataForm::CanRepeat(SfxRepeatTarget& rTarget) const
+{
+        return (rTarget.ISA(ScTabViewTarget));
+}
 
+void ScUndoDataForm::DoChange( const BOOL bUndo )
+{
+    ScDocument* pDoc = pDocShell->GetDocument();
 
+    //      RefUndoData for redo is created before first undo
+    //      (with DeleteUnchanged after the DoUndo call)
+    BOOL bCreateRedoData = ( bUndo && pRefUndoData && !pRefRedoData );
+    if ( bCreateRedoData )
+            pRefRedoData = new ScRefUndoData( pDoc );
 
+    ScRefUndoData* pWorkRefData = bUndo ? pRefUndoData : pRefRedoData;
+
+    //      fuer Undo immer alle oder keine Inhalte sichern
+    USHORT nUndoFlags = IDF_NONE;
+    if (nFlags & IDF_CONTENTS)
+            nUndoFlags |= IDF_CONTENTS;
+    if (nFlags & IDF_ATTRIB)
+            nUndoFlags |= IDF_ATTRIB;
+
+    BOOL bPaintAll = FALSE;
+
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
 
+    // marking is in ScBlockUndo...
+    //ScUndoUtil::MarkSimpleBlock( pDocShell, aBlockRange );
 
+    SCTAB nTabCount = pDoc->GetTableCount();
+    if ( bUndo && !bRedoFilled )
+    {
+        if (!pRedoDoc)
+        {
+            BOOL bColInfo = ( aBlockRange.aStart.Row()==0 && aBlockRange.aEnd.Row()==MAXROW );
+            BOOL bRowInfo = ( aBlockRange.aStart.Col()==0 && aBlockRange.aEnd.Col()==MAXCOL );
+
+            pRedoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pRedoDoc->InitUndoSelected( pDoc, aMarkData, bColInfo, bRowInfo );
+        }
+        //  read "redo" data from the document in the first undo
+            //  all sheets - CopyToDocument skips those that don't exist in pRedoDoc
+        ScRange aCopyRange = aBlockRange;
+        aCopyRange.aStart.SetTab(0);
+        aCopyRange.aEnd.SetTab(nTabCount-1);
+        pDoc->CopyToDocument( aCopyRange, 1, FALSE, pRedoDoc );
+        bRedoFilled = TRUE;
+    }
+
+    USHORT nExtFlags = 0;
+    pDocShell->UpdatePaintExt( nExtFlags, aBlockRange );
+
+    for ( sal_uInt16 i=0; i <= ( aBlockRange.aEnd.Col() - aBlockRange.aStart.Col() ); i++ )
+    {
+        String aOldString;
+        pUndoDoc->GetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+        pDoc->SetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+    }
+
+    //ScRange aTabSelectRange = aBlockRange;
+
+    if (pWorkRefData)
+    {
+        pWorkRefData->DoUndo( pDoc, TRUE );             // TRUE = bSetChartRangeLists for SetChartListenerCollection
+        if ( pDoc->RefreshAutoFilter( 0,0, MAXCOL,MAXROW, aBlockRange.aStart.Tab() ) )
+            bPaintAll = TRUE;
+    }
+
+    if ( bCreateRedoData && pRefRedoData )
+            pRefRedoData->DeleteUnchanged( pDoc );
+    
+    if ( bUndo )
+    {
+        ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+        if ( pChangeTrack )
+            pChangeTrack->Undo( nStartChangeAction, nEndChangeAction );
+    }
+    else
+        SetChangeTrack();
+
+    ScRange aDrawRange( aBlockRange );
+    pDoc->ExtendMerge( aDrawRange, TRUE );      // only needed for single sheet (text/rtf etc.)
+    USHORT nPaint = PAINT_GRID;
+    if (bPaintAll)
+    {
+        aDrawRange.aStart.SetCol(0);
+        aDrawRange.aStart.SetRow(0);
+        aDrawRange.aEnd.SetCol(MAXCOL);
+        aDrawRange.aEnd.SetRow(MAXROW);
+        nPaint |= PAINT_TOP | PAINT_LEFT;
+/*A*/   if (pViewShell)
+            pViewShell->AdjustBlockHeight(FALSE);
+    }
+    else
+    {
+        if ( aBlockRange.aStart.Row() == 0 && aBlockRange.aEnd.Row() == MAXROW )        // ganze Spalte
+        {
+            nPaint |= PAINT_TOP;
+            aDrawRange.aEnd.SetCol(MAXCOL);
+        }
+        if ( aBlockRange.aStart.Col() == 0 && aBlockRange.aEnd.Col() == MAXCOL )        // ganze Zeile
+        {
+            nPaint |= PAINT_LEFT;
+            aDrawRange.aEnd.SetRow(MAXROW);
+        }
+/*A*/   if ((pViewShell) && pViewShell->AdjustBlockHeight(FALSE))
+        {
+            aDrawRange.aStart.SetCol(0);
+            aDrawRange.aStart.SetRow(0);
+            aDrawRange.aEnd.SetCol(MAXCOL);
+            aDrawRange.aEnd.SetRow(MAXROW);
+            nPaint |= PAINT_LEFT;
+        }
+        pDocShell->UpdatePaintExt( nExtFlags, aDrawRange );
+    }
+
+    if ( !bUndo )                               //      draw redo after updating row heights
+        RedoSdrUndoAction( pDrawUndo );                 //!     include in ScBlockUndo?
+
+    pDocShell->PostPaint( aDrawRange, nPaint, nExtFlags );
+
+    pDocShell->PostDataChanged();
+    if (pViewShell)
+        pViewShell->CellContentChanged();
+}
diff --git sc/source/ui/unoobj/addruno.cxx sc/source/ui/unoobj/addruno.cxx
index 4bea38e..fa1d4ee 100644
--- sc/source/ui/unoobj/addruno.cxx
+++ sc/source/ui/unoobj/addruno.cxx
@@ -69,7 +69,7 @@ void ScAddressConversionObj::Notify( SfxBroadcaster&, const SfxHint& rHint )
     }
 }
 
-sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString )
+sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv )
 {
     if (!pDocShell)
         return sal_False;
@@ -78,7 +78,7 @@ sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString )
     sal_Bool bSuccess = sal_False;
     if ( bIsRange )
     {
-        USHORT nResult = aRange.ParseAny( rUIString, pDoc );
+        USHORT nResult = aRange.ParseAny( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -92,7 +92,7 @@ sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString )
     }
     else
     {
-        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc );
+        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -116,6 +116,7 @@ uno::Reference<beans::XPropertySetInfo> SAL_CALL ScAddressConversionObj::getProp
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellRangeAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -129,6 +130,7 @@ uno::Reference<beans::XPropertySetInfo> SAL_CALL ScAddressConversionObj::getProp
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -190,8 +192,11 @@ void SAL_CALL ScAddressConversionObj::setPropertyValue( const rtl::OUString& aPr
             bSuccess = ParseUIString( aUIString );
         }
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
         //  parse the file format string
         rtl::OUString sRepresentation;
         if (aValue >>= sRepresentation)
@@ -212,7 +217,7 @@ void SAL_CALL ScAddressConversionObj::setPropertyValue( const rtl::OUString& aPr
             }
 
             //  parse the rest like a UI string
-            bSuccess = ParseUIString( aUIString );
+            bSuccess = ParseUIString( aUIString, aConv );
         }
     }
     else
@@ -265,17 +270,24 @@ uno::Any SAL_CALL ScAddressConversionObj::getPropertyValue( const rtl::OUString&
             aRange.aStart.Format( aFormatStr, nFlags, pDoc );
         aRet <<= rtl::OUString( aFormatStr );
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
+
         //  generate file format string - always include sheet
         String aFormatStr;
-        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc );
+        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
         if ( bIsRange )
         {
             //  manually concatenate range so both parts always have the sheet name
             aFormatStr.Append( (sal_Unicode) ':' );
             String aSecond;
-            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc );
+            USHORT nFlags = SCA_VALID;
+            if( aConv != ::formula::FormulaGrammar::CONV_XL_A1 )
+		nFlags |= SCA_TAB_3D;
+            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
             aFormatStr.Append( aSecond );
         }
         aRet <<= rtl::OUString( aFormatStr );
diff --git sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
index ccf3ddf..39caf07 100644
--- sc/source/ui/unoobj/docuno.cxx
+++ sc/source/ui/unoobj/docuno.cxx
@@ -101,6 +101,7 @@
 #include "scresid.hxx"
 
 using namespace com::sun::star;
+#define SC_UNO_VBADOCOBJ "ThisVBADocObj" // perhaps we want to actually make this ThisWorkbook ?
 
 //------------------------------------------------------------------------
 
@@ -117,6 +122,7 @@ const SfxItemPropertyMapEntry* lcl_GetDocOptPropertyMap()
         {MAP_CHAR_LEN(SC_UNO_AUTOCONTFOC),       0, &getBooleanCppuType(),                                    0, 0},
         {MAP_CHAR_LEN(SC_UNO_BASICLIBRARIES),    0, &getCppuType((uno::Reference< script::XLibraryContainer >*)0), beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN(SC_UNO_DIALOGLIBRARIES),   0, &getCppuType((uno::Reference< script::XLibraryContainer >*)0), beans::PropertyAttribute::READONLY, 0},
+        {MAP_CHAR_LEN(SC_UNO_VBADOCOBJ),   0, &getCppuType((beans::PropertyValue*)0), beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN(SC_UNO_CALCASSHOWN),       PROP_UNO_CALCASSHOWN, &getBooleanCppuType(),                                    0, 0},
         {MAP_CHAR_LEN(SC_UNONAME_CLOCAL),        0, &getCppuType((lang::Locale*)0),                           0, 0},
         {MAP_CHAR_LEN(SC_UNO_CJK_CLOCAL),        0, &getCppuType((lang::Locale*)0),                           0, 0},
@@ -1873,6 +1880,18 @@ uno::Any SAL_CALL ScModelObj::getPropertyValue( const rtl::OUString& aPropertyNa
         {
             aRet <<= pDocShell->GetDialogContainer();
         }
+        else if ( aString.EqualsAscii( SC_UNO_VBADOCOBJ ) )
+        {
+            // PropertyValue seems extreme because we store
+            // the model ( as the value member ) of the PropertyValue that is
+            // itself a property of the model ( the intention however is to 
+            // store something like a Workbook object... but we don't do that )
+            // yet
+            beans::PropertyValue aProp;
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisExcelDoc") );
+            aProp.Value <<= pDocShell->GetModel();
+            aRet <<= aProp;
+        }
         else if ( aString.EqualsAscii( SC_UNO_RUNTIMEUID ) )
         {
             aRet <<= getRuntimeUID();
diff --git sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
index a9a83b7..32106fa 100644
--- sc/source/ui/unoobj/servuno.cxx
+++ sc/source/ui/unoobj/servuno.cxx
@@ -35,6 +35,7 @@
 #include <svx/unofill.hxx>
 #include <editeng/unonrule.hxx>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
 
 #include "servuno.hxx"
 #include "unoguard.hxx"
@@ -71,8 +72,27 @@
 #include <basic/basmgr.hxx>
 #include <sfx2/app.hxx>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <cppuhelper/component_context.hxx>
+#include <vbahelper/vbaaccesshelper.hxx>
+#include <com/sun/star/script/vba/XVBACompatibility.hpp>
+
 using namespace ::com::sun::star;
 
+bool isInVBAMode( ScDocShell& rDocSh )
+{
+    uno::Reference<script::XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
+    uno::Reference<script::vba::XVBACompatibility> xVBACompat( xLibContainer, uno::UNO_QUERY );
+    if ( xVBACompat.is() )
+        return xVBACompat->getVBACompatibilityMode();
+    return false;
+}
+
 class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
 {
     uno::Any maWorkbook;
@@ -285,7 +305,8 @@ static const ProvNamesId_Type __FAR_DATA aProvNamesId[] =
     { "com.sun.star.text.textfield.Time",               SC_SERVICE_TIMEFIELD },
     { "com.sun.star.text.textfield.DocumentTitle",      SC_SERVICE_TITLEFIELD },
     { "com.sun.star.text.textfield.FileName",           SC_SERVICE_FILEFIELD },
-    { "com.sun.star.text.textfield.SheetName",          SC_SERVICE_SHEETFIELD }
+    { "com.sun.star.text.textfield.SheetName",          SC_SERVICE_SHEETFIELD },
+    { "ooo.vba.VBAGlobals",          SC_SERVICE_VBAGLOBALS },
 };
 
 //
@@ -554,7 +575,7 @@ uno::Reference<uno::XInterface> ScServiceProvider::MakeInstance(
             }
             break;
         case SC_SERVICE_VBACODENAMEPROVIDER:
-            if (pDocShell && pDocShell->GetDocument()->IsInVBAMode())
+            if ( pDocShell && ooo::vba::isAlienExcelDoc( *pDocShell ) && isInVBAMode( *pDocShell ) )
             {
                 OSL_TRACE("**** creating VBA Object provider");
                 xRet.set(static_cast<document::XCodeNameQuery*>(new ScVbaCodeNameProvider( pDocShell )));
diff --git sc/source/ui/unoobj/shapeuno.cxx sc/source/ui/unoobj/shapeuno.cxx
index 2533354..dcea134 100644
--- sc/source/ui/unoobj/shapeuno.cxx
+++ sc/source/ui/unoobj/shapeuno.cxx
@@ -70,6 +70,8 @@ const SfxItemPropertyMapEntry* lcl_GetShapeMap()
         {MAP_CHAR_LEN(SC_UNONAME_HORIPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_IMAGEMAP),	0, &getCppuType((uno::Reference<container::XIndexContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VERTPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
+		// #i66550 HLINK_FOR_SHAPES
+		{MAP_CHAR_LEN(SC_UNONAME_HYPERLINK), 0, &getCppuType((rtl::OUString*)0), 0, 0 },
         {0,0,0,0,0,0}
     };
     return aShapeMap_Impl;
@@ -84,6 +86,14 @@ const SvEventDescription* ScShapeObj::GetSupportedMacroItems()
     };
     return aMacroDescriptionsImpl;
 }
+// #i66550 HLINK_FOR_SHAPES
+ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate = FALSE )
+{
+        if( pShape )
+            if( SdrObject* pObj = pShape->GetSdrObject() )
+                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
+        return 0;
+}
 
 //------------------------------------------------------------------------
 
@@ -635,6 +645,13 @@ void SAL_CALL ScShapeObj::setPropertyValue(
             }
         }
     }
+	else if  ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+                rtl::OUString sHlink;
+        	ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this, TRUE);
+        	if ( ( aValue >>= sHlink ) && pInfo )
+			pInfo->SetHlink( sHlink );
+	}
     else
     {
         GetShapePropertySet();
@@ -816,6 +833,13 @@ uno::Any SAL_CALL ScShapeObj::getPropertyValue( const rtl::OUString& aPropertyNa
             }
         }
     }
+	else if ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+		rtl::OUString sHlink;
+		if ( ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this) )
+			sHlink = pInfo->GetHlink();
+		aAny <<= sHlink;
+	}
     else
     {
         GetShapePropertySet();
@@ -1339,11 +1363,6 @@ SdrObject* ScShapeObj::GetSdrObject() const throw()
 }
 
 #define SC_EVENTACC_ONCLICK     ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) )
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-#define SC_EVENTACC_ONACTION    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) )
-#define SC_EVENTACC_URL         ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) )
-#define SC_EVENTACC_ACTION      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) )
-#endif
 #define SC_EVENTACC_SCRIPT      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Script" ) )
 #define SC_EVENTACC_EVENTTYPE   ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) )
 
@@ -1355,10 +1374,7 @@ private:
 
     ScMacroInfo* getInfo( BOOL bCreate = FALSE )
     {
-        if( mpShape )
-            if( SdrObject* pObj = mpShape->GetSdrObject() )
-                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
-        return 0;
+		return lcl_getShapeHyperMacroInfo( mpShape, bCreate );
     }
 
 public:
@@ -1384,11 +1400,7 @@ public:
                 isEventType = true;
                 continue;
             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( isEventType && ((pProperties->Name == SC_EVENTACC_SCRIPT) || (pProperties->Name == SC_EVENTACC_URL)) )
-#else
             if ( isEventType && (pProperties->Name == SC_EVENTACC_SCRIPT) )
-#endif
             {
                 rtl::OUString sValue;
                 if ( pProperties->Value >>= sValue )
@@ -1399,10 +1411,8 @@ public:
                         break;
                     if ( pProperties->Name == SC_EVENTACC_SCRIPT )
                         pInfo->SetMacro( sValue );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                     else
                         pInfo->SetHlink( sValue );
-#endif
                 }
             }
         }
@@ -1425,19 +1435,6 @@ public:
                 aProperties[ 1 ].Value <<= pInfo->GetMacro();
             }
         }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        else if( aName == SC_EVENTACC_ONACTION )
-        {
-            if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
-            {
-                aProperties.realloc( 2 );
-                aProperties[ 0 ].Name = SC_EVENTACC_EVENTTYPE;
-                aProperties[ 0 ].Value <<= SC_EVENTACC_ACTION;
-                aProperties[ 1 ].Name = SC_EVENTACC_URL;
-                aProperties[ 1 ].Value <<= pInfo->GetHlink();
-            }
-        }
-#endif
         else
         {
             throw container::NoSuchElementException();
@@ -1448,25 +1445,14 @@ public:
 
     virtual uno::Sequence< rtl::OUString > SAL_CALL getElementNames() throw(uno::RuntimeException)
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        uno::Sequence< rtl::OUString > aSeq( 2 );
-#else
         uno::Sequence< rtl::OUString > aSeq( 1 );
-#endif
         aSeq[ 0 ] = SC_EVENTACC_ONCLICK;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        aSeq[ 1 ] = SC_EVENTACC_ONACTION;
-#endif
         return aSeq;
     }
 
     virtual sal_Bool SAL_CALL hasByName( const rtl::OUString& aName ) throw(uno::RuntimeException)
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        return (aName == SC_EVENTACC_ONCLICK) || (aName == SC_EVENTACC_ONACTION);
-#else
         return aName == SC_EVENTACC_ONCLICK;
-#endif
     }
 
     // XElementAccess
diff --git sc/source/ui/unoobj/viewuno.cxx sc/source/ui/unoobj/viewuno.cxx
index 0a3fe3f..200e592 100644
--- sc/source/ui/unoobj/viewuno.cxx
+++ sc/source/ui/unoobj/viewuno.cxx
@@ -1173,11 +1296,21 @@ uno::Reference<sheet::XSpreadsheet> SAL_CALL ScTabViewObj::getActiveSheet()
     return NULL;
 }
 
+//liuchen 2009-9-2 support expand (but not replace) the active sheet
 void SAL_CALL ScTabViewObj::setActiveSheet( const uno::Reference<sheet::XSpreadsheet>& xActiveSheet )
                                                 throw(uno::RuntimeException)
 {
-    ScUnoGuard aGuard;
+	selectSheet(xActiveSheet, false);
+}
 
+void SAL_CALL
+ScTabViewObj::selectSheet( const uno::Reference<sheet::XSpreadsheet>& xActiveSheet,
+							 sal_Bool bExpand)
+												throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+	sal_Bool bNew = bExpand;
+	
     ScTabViewShell* pViewSh = GetViewShell();
     if ( pViewSh && xActiveSheet.is() )
     {
@@ -1191,7 +1324,7 @@ void SAL_CALL ScTabViewObj::setActiveSheet( const uno::Reference<sheet::XSpreads
             {
                 SCTAB nNewTab = rRanges.GetObject(0)->aStart.Tab();
                 if ( pViewSh->GetViewData()->GetDocument()->HasTable(nNewTab) )
-                    pViewSh->SetTabNo( nNewTab );
+					pViewSh->SetTabNo( nNewTab, bNew, bExpand );					
             }
         }
     }
@@ -1885,6 +2018,12 @@ void SAL_CALL ScTabViewObj::setPropertyValue(
     ScUnoGuard aGuard;
     String aString(aPropertyName);
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        bFilteredRangeSelection = ScUnoHelpFunctions::GetBoolFromAny(aValue);
+        return;
+    }
+
     ScTabViewShell* pViewSh = GetViewShell();
     if (pViewSh)
     {
@@ -2005,6 +2144,12 @@ uno::Any SAL_CALL ScTabViewObj::getPropertyValue( const rtl::OUString& aProperty
     String aString(aPropertyName);
     uno::Any aRet;
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        ScUnoHelpFunctions::SetBoolInAny(aRet, bFilteredRangeSelection);
+        return aRet;
+    }
+
     ScTabViewShell* pViewSh = GetViewShell();
     if (pViewSh)
     {
diff --git sc/source/ui/vba/excelvbahelper.cxx sc/source/ui/vba/excelvbahelper.cxx
index 5fc1b3c..705941b 100644
--- sc/source/ui/vba/excelvbahelper.cxx
+++ sc/source/ui/vba/excelvbahelper.cxx
@@ -43,6 +43,52 @@ namespace vba
 namespace excel
 {
 
+uno::Reference< sheet::XDatabaseRanges > 
+GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
+{
+    uno::Reference< frame::XModel > xModel;
+    if ( pShell )
+        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
+    return xDBRanges;
+}
+
+// returns the XDatabaseRange for the autofilter on sheet (nSheet)
+// also populates sName with the name of range
+uno::Reference< sheet::XDatabaseRange > 
+GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XIndexAccess > xIndexAccess( GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
+    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
+    table::CellRangeAddress dbAddress;
+    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
+    {
+        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
+        // autofilters work weirdly with openoffice, unnamed is the default 
+        // named range which is used to create an autofilter, but
+        // its also possible that another name could be used
+        //     this also causes problems when an autofilter is created on
+        //     another sheet
+        // ( but.. you can use any named range )
+        dbAddress = xDBRange->getDataArea();
+        if ( dbAddress.Sheet == nSheet )
+        {
+            sal_Bool bHasAuto = sal_False;
+            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
+            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
+            if ( bHasAuto )
+            {
+                sName = xNamed->getName();	
+                xDataBaseRange=xDBRange;
+                break;
+            }
+        }
+    }
+    return xDataBaseRange;
+} 
+
 ScDocShell* GetDocShellFromRange( const uno::Reference< uno::XInterface >& xRange ) throw ( uno::RuntimeException )
 {
     ScCellRangesBase* pScCellRangesBase = ScCellRangesBase::getImplementation( xRange );
@@ -53,6 +99,13 @@ ScDocShell* GetDocShellFromRange( const uno::Reference< uno::XInterface >& xRang
     return pScCellRangesBase->GetDocShell();
 }
 
+ScDocShell* GetDocShellFromRanges( const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges ) throw ( uno::RuntimeException ) 
+{ 
+    // need the ScCellRangesBase to get docshell 
+    uno::Reference< uno::XInterface > xIf( xRanges, uno::UNO_QUERY_THROW ); 
+    return GetDocShellFromRange( xIf );
+} 
+
 ScDocument* GetDocumentFromRange( const uno::Reference< uno::XInterface >& xRange ) throw ( uno::RuntimeException )
 {
         ScDocShell* pDocShell = GetDocShellFromRange( xRange );
@@ -63,6 +116,16 @@ ScDocument* GetDocumentFromRange( const uno::Reference< uno::XInterface >& xRang
         return pDocShell->GetDocument();
 }
 
+uno::Reference< frame::XModel > GetModelFromRange( const uno::Reference< uno::XInterface >& xRange ) throw ( uno::RuntimeException )
+{
+	ScDocShell* pDocShell = GetDocShellFromRange( xRange );
+	if ( !pDocShell )
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying model uno range object" ) ), uno::Reference< uno::XInterface >() );
+	}
+	return pDocShell->GetModel();
+}
+
 void implSetZoom( const uno::Reference< frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs )
 {
     ScTabViewShell* pViewSh = excel::getBestViewShell( xModel );
@@ -229,6 +292,19 @@ getViewFrame( const uno::Reference< frame::XModel >& xModel )
     return NULL;
 }
 
+sal_Bool IsR1C1ReferFormat( ScDocument* pDoc, const rtl::OUString& sRangeStr )
+{
+	ScRangeList aCellRanges;
+	String sAddress( sRangeStr );
+	USHORT nMask = SCA_VALID;
+	USHORT rResFlags = aCellRanges.Parse( sAddress, pDoc, nMask, formula::FormulaGrammar::CONV_XL_R1C1 );
+	if ( rResFlags & SCA_VALID )
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+
 uno::Reference< XHelperInterface > 
 getUnoSheetModuleObj( const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException )
 {
diff --git sc/source/ui/vba/excelvbahelper.hxx sc/source/ui/vba/excelvbahelper.hxx
index 528457a..ab0474e 100644
--- sc/source/ui/vba/excelvbahelper.hxx
+++ sc/source/ui/vba/excelvbahelper.hxx
@@ -29,6 +29,8 @@
 
 #include<vbahelper/vbahelper.hxx>
 #include <docsh.hxx>
+#include <com/sun/star/sheet/XDatabaseRanges.hpp>
+#include <com/sun/star/sheet/XDatabaseRange.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
 #include <ooo/vba/XHelperInterface.hpp>
@@ -39,29 +41,35 @@ namespace ooo
 {
     namespace vba 
     {
-    namespace excel
+        namespace excel
         { 
-                // nTabs empty means apply zoom to all sheets
-                void implSetZoom( const css::uno::Reference< css::frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs );
-        void implnCopy( const css::uno::Reference< css::frame::XModel>& xModel );
-        void implnPaste ( const css::uno::Reference< css::frame::XModel>& xModel );
-        void implnCut( const css::uno::Reference< css::frame::XModel>& xModel );
-        void implnPasteSpecial( const css::uno::Reference< css::frame::XModel>& xModel, sal_uInt16 nFlags,sal_uInt16 nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose);
-        ScTabViewShell* getBestViewShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
-        ScDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
-        ScTabViewShell* getCurrentBestViewShell( const css::uno::Reference< css::uno::XComponentContext >& xContext );
-        SfxViewFrame* getViewFrame( const css::uno::Reference< css::frame::XModel >& xModel );
+            // nTabs empty means apply zoom to all sheets
+            void implSetZoom( const css::uno::Reference< css::frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs );
+            void implnCopy( const css::uno::Reference< css::frame::XModel>& xModel );
+            void implnPaste ( const css::uno::Reference< css::frame::XModel>& xModel );
+            void implnCut( const css::uno::Reference< css::frame::XModel>& xModel );
+            void implnPasteSpecial( const css::uno::Reference< css::frame::XModel>& xModel, sal_uInt16 nFlags,sal_uInt16 nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose);
+            ScTabViewShell* getBestViewShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
+            ScDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
+            ScTabViewShell* getCurrentBestViewShell( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+            SfxViewFrame* getViewFrame( const css::uno::Reference< css::frame::XModel >& xModel );
+            sal_Bool IsR1C1ReferFormat( ScDocument* pDoc, const ::rtl::OUString& sRangeStr );
+            css::uno::Reference< css::sheet::XDatabaseRanges > GetDataBaseRanges( ScDocShell* pShell ) throw ( css::uno::RuntimeException );
+
+            css::uno::Reference< css::sheet::XDatabaseRange > GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( css::uno::RuntimeException );
             css::uno::Reference< ooo::vba::XHelperInterface > getUnoSheetModuleObj( const css::uno::Reference< css::sheet::XSheetCellRangeContainer >& xRanges ) throw ( css::uno::RuntimeException );
             css::uno::Reference< ooo::vba::XHelperInterface > getUnoSheetModuleObj( const css::uno::Reference< css::table::XCellRange >& xRange ) throw ( css::uno::RuntimeException );
              ScDocShell* GetDocShellFromRange( const css::uno::Reference< css::uno::XInterface >& xRange ) throw ( css::uno::RuntimeException );
+            ScDocShell* GetDocShellFromRanges( const css::uno::Reference< css::sheet::XSheetCellRangeContainer >& xRanges ) throw ( css::uno::RuntimeException );
              ScDocument* GetDocumentFromRange( const css::uno::Reference< css::uno::XInterface >& xRange ) throw ( css::uno::RuntimeException );
              css::uno::Reference< css::frame::XModel > GetModelFromRange( const css::uno::Reference< css::uno::XInterface >& xRange ) throw ( css::uno::RuntimeException );
+
             class ScVbaCellRangeAccess
             {
             public:
                 static SfxItemSet* GetDataSet( ScCellRangesBase* pRangeObj );
             };
-}
-}
+        }
+    }
 }
 #endif
diff --git sc/source/ui/vba/makefile.mk sc/source/ui/vba/makefile.mk
index 4cb7e3e..9974665 100644
--- sc/source/ui/vba/makefile.mk
+++ sc/source/ui/vba/makefile.mk
@@ -31,7 +31,7 @@ PRJNAME=sc
 TARGET=vbaobj
 ENABLE_EXCEPTIONS=TRUE
 VISIBILITY_HIDDEN=TRUE
-
+CDEFS+=-DVBA_OOBUILD_HACK
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :  settings.mk
@@ -63,18 +63,29 @@ SLOFILES= \
         $(SLO)$/vbacharttitle.obj \
         $(SLO)$/vbacomment.obj \
         $(SLO)$/vbacomments.obj \
+        $(SLO)$/vbacommentshape.obj \
         $(SLO)$/vbacondition.obj \
         $(SLO)$/vbadialog.obj \
         $(SLO)$/vbadialogs.obj \
         $(SLO)$/vbaeventshelper.obj \
+        $(SLO)$/vbafiledialog.obj \
+        $(SLO)$/vbafiledialogselecteditems.obj \
+        $(SLO)$/vbafilesearch.obj \
         $(SLO)$/vbafont.obj \
         $(SLO)$/vbaformat.obj \
         $(SLO)$/vbaformatcondition.obj \
         $(SLO)$/vbaformatconditions.obj \
+        $(SLO)$/vbafoundfiles.obj \
         $(SLO)$/vbaglobals.obj \
         $(SLO)$/vbahyperlink.obj \
         $(SLO)$/vbahyperlinks.obj \
         $(SLO)$/vbainterior.obj \
+        $(SLO)$/vbamenubar.obj  \
+        $(SLO)$/vbamenubars.obj \
+        $(SLO)$/vbamenu.obj \
+        $(SLO)$/vbamenus.obj \
+        $(SLO)$/vbamenuitem.obj \
+        $(SLO)$/vbamenuitems.obj \
         $(SLO)$/vbaname.obj \
         $(SLO)$/vbanames.obj \
         $(SLO)$/vbaoleobject.obj \
@@ -88,6 +90,7 @@ SLOFILES= \
         $(SLO)$/vbapivotcache.obj \
         $(SLO)$/vbapivottable.obj \
         $(SLO)$/vbapivottables.obj \
+        $(SLO)$/vbaquerytable.obj \
         $(SLO)$/vbarange.obj \
         $(SLO)$/vbaseriescollection.obj \
         $(SLO)$/vbasheetobject.obj \
diff --git sc/source/ui/vba/testvba/testvba.cxx sc/source/ui/vba/testvba/testvba.cxx
index 990a37a..058c874 100644
--- sc/source/ui/vba/testvba/testvba.cxx
+++ sc/source/ui/vba/testvba/testvba.cxx
@@ -159,15 +159,15 @@ mxCompLoader( _xCompLoader ), msOutDirPath( convertToURL( _outDirPath  ) )
                         Reference< script::provider::XScript > xScript;
                         try
                         {
-                            xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.TestMacros.Main?language=Basic&location=document" ));
+                            xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.TestMacros.Main?language=Basic&location=document" ));
                         } catch ( uno::Exception& e )
                         {
                             try
                             {
-                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMacro.Main?language=Basic&location=document" ));
+                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMacro.Main?language=Basic&location=document" ));
                             } catch ( uno::Exception& e2 )
                             {
-                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMain.Main?language=Basic&location=document" ));
+                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMain.Main?language=Basic&location=document" ));
                             }
                         }
                         OSL_TRACE("Got script for doc %s", rtl::OUStringToOString( sUrl, RTL_TEXTENCODING_UTF8 ).getStr() );
diff --git sc/source/ui/vba/vbaapplication.cxx sc/source/ui/vba/vbaapplication.cxx
index 63db284..d4a6ed5 100644
--- sc/source/ui/vba/vbaapplication.cxx
+++ sc/source/ui/vba/vbaapplication.cxx
@@ -27,11 +27,14 @@
  
 #include <stdio.h>
 
+#include <com/sun/star/datatransfer/clipboard/XClipboard.hpp>
+#include <com/sun/star/datatransfer/clipboard/XFlushableClipboard.hpp>
 #include <com/sun/star/sheet/XSpreadsheetView.hpp>
 #include <com/sun/star/sheet/XSpreadsheets.hpp>
 #include <com/sun/star/view/XSelectionSupplier.hpp>
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <ooo/vba/excel/XlCalculation.hpp>
+#include <ooo/vba/excel/XlCutCopyMode.hpp>
 #include <com/sun/star/sheet/XCellRangeReferrer.hpp>
 #include <com/sun/star/sheet/XCalculatable.hpp>
 #include <com/sun/star/frame/XLayoutManager.hpp>
@@ -40,6 +43,19 @@
 #include <ooo/vba/excel/XlMousePointer.hpp>
 #include <com/sun/star/sheet/XNamedRanges.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/ui/dialogs/CommonFilePickerElementIds.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker2.hpp>
+#include <com/sun/star/ui/dialogs/XFilePickerControlAccess.hpp>
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+//2009-11-06 add by limingl
+#include <com/sun/star/ui/dialogs/XFilterManager.hpp> 
+#include <com/sun/star/ui/dialogs/XExecutableDialog.hpp>
+//end
+#include<ooo/vba/XCommandBars.hpp>
+#include <ooo/vba/excel/XlEnableCancelKey.hpp> //liuchen 2009-11-26
+#include <ooo/vba/excel/XlApplicationInternational.hpp> //liuchen 2009-11-26
+#include <unotools/localedatawrapper.hxx> //liuchen 2009-11-26
 
 #include "vbaapplication.hxx"
 #include "vbaworkbooks.hxx"
@@ -51,25 +67,37 @@
 #include "vbawindow.hxx"
 #include "vbawindows.hxx"
 #include "vbaglobals.hxx"
+#include "vbamenubars.hxx"
 #include "tabvwsh.hxx"
 #include "gridwin.hxx"
 #include "vbanames.hxx"
 #include <vbahelper/vbashape.hxx>
 #include "vbatextboxshape.hxx"
 #include "vbaassistant.hxx"
+#include "vbafilesearch.hxx" //liuchen 2009-8-18, add the support of VBA Application.FileSearch
 #include "sc.hrc"
+#include "macromgr.hxx"
+#include "global.hxx" //liuchen 2009-11-26
+#include "scmod.hxx" //liuchen 2009-11-26
+#include "docoptio.hxx" //liuchen 2009-11-26
+#include "appoptio.hxx"
 
 #include <osl/file.hxx>
 
+#include <map>
+
 #include <sfx2/request.hxx>
 #include <sfx2/objsh.hxx>
 #include <sfx2/viewfrm.hxx>
 #include <sfx2/app.hxx>
 
+#include <comphelper/processfactory.hxx>
+
 #include <toolkit/awt/vclxwindow.hxx>
 #include <toolkit/helper/vclunohelper.hxx>
 
 #include <tools/diagnose_ex.h>
+#include <tools/urlobj.hxx>
 
 #include <docuno.hxx>
 
@@ -78,15 +106,29 @@
 #include <basic/sbuno.hxx>
 #include <basic/sbmeth.hxx>
 
+#include "transobj.hxx"
 #include "convuno.hxx"
 #include "cellsuno.hxx"
+#include "miscuno.hxx"
+#include "unonames.hxx"
 #include "docsh.hxx"
 #include <vbahelper/helperdecl.hxx>
 #include "excelvbahelper.hxx"
 
-
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
+//limingl 2009-07-20
+#include "vbafiledialog.hxx"
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::rtl::OUString;
 
 // #TODO is this defined somewhere else?
 #if ( defined UNX ) || ( defined OS2 ) //unix
@@ -243,16 +285,49 @@ ScVbaApplication::getAssistant() throw (uno::RuntimeException)
     return uno::Reference< XAssistant >( new ScVbaAssistant( this, mxContext ) );
 }
 
+//liuchen 2009-8-18, add support of VBA Application.FileSearch
+uno::Reference< XFileSearch > SAL_CALL
+ScVbaApplication::getFileSearch() throw (uno::RuntimeException)
+{
+	if (! m_xFileSearch.get() )
+	{
+		m_xFileSearch = uno::Reference< XFileSearch >( new ScVbaFileSearch( this, uno::Reference< XHelperInterface >( this ), mxContext ) );
+	}
+	
+    return m_xFileSearch;
+}
+//liuchen
+
 uno::Any SAL_CALL
 ScVbaApplication::getSelection() throw (uno::RuntimeException)
 {
     OSL_TRACE("** ScVbaApplication::getSelection() ** ");
     uno::Reference< frame::XModel > xModel( getCurrentDocument() );
-    uno::Reference< lang::XServiceInfo > xServiceInfo( xModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
-    rtl::OUString sImpementaionName = xServiceInfo->getImplementationName();
-    if( sImpementaionName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+
+    Reference< view::XSelectionSupplier > xSelSupp( xModel->getCurrentController(), UNO_QUERY_THROW );
+    Reference< beans::XPropertySet > xPropSet( xSelSupp, UNO_QUERY_THROW );
+    OUString aPropName = OUString::createFromAscii( SC_UNO_FILTERED_RANGE_SELECTION );
+    uno::Any aOldVal = xPropSet->getPropertyValue( aPropName );
+    uno::Any any;
+    any <<= sal_False;
+    xPropSet->setPropertyValue( aPropName, any );
+    uno::Reference< uno::XInterface > aSelection = ScUnoHelpFunctions::AnyToInterface(
+        xSelSupp->getSelection() );
+    xPropSet->setPropertyValue( aPropName, aOldVal );
+
+    if (!aSelection.is())
     {
-        uno::Reference< drawing::XShapes > xShapes( xModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
+        throw uno::RuntimeException( 
+            rtl::OUString::createFromAscii("failed to obtain current selection"), 
+            uno::Reference< uno::XInterface >() );
+    }
+
+    uno::Reference< lang::XServiceInfo > xServiceInfo( aSelection, uno::UNO_QUERY_THROW );
+    rtl::OUString sImplementationName = xServiceInfo->getImplementationName();
+
+    if( sImplementationName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+    {
+        uno::Reference< drawing::XShapes > xShapes( aSelection, uno::UNO_QUERY_THROW );
         uno::Reference< container::XIndexAccess > xIndexAccess( xShapes, uno::UNO_QUERY_THROW );
         uno::Reference< drawing::XShape > xShape( xIndexAccess->getByIndex(0), uno::UNO_QUERY_THROW );
     // if ScVbaShape::getType( xShape ) == office::MsoShapeType::msoAutoShape
@@ -271,10 +346,10 @@ ScVbaApplication::getSelection() throw (uno::RuntimeException)
     else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRange")) ||
              xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRanges")))
     {
-        uno::Reference< table::XCellRange > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	    uno::Reference< table::XCellRange > xRange( aSelection, ::uno::UNO_QUERY);
         if ( !xRange.is() )
         {
-            uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+		    uno::Reference< sheet::XSheetCellRangeContainer > xRanges( aSelection, ::uno::UNO_QUERY);
             if ( xRanges.is() )
                 return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( excel::getUnoSheetModuleObj( xRanges ), mxContext, xRanges ) ) );
 
@@ -283,7 +358,7 @@ ScVbaApplication::getSelection() throw (uno::RuntimeException)
     }
     else
     {
-        throw uno::RuntimeException( sImpementaionName + rtl::OUString::createFromAscii(" not suported"), uno::Reference< uno::XInterface >() );
+        throw uno::RuntimeException( sImplementationName + rtl::OUString::createFromAscii(" not supported"), uno::Reference< uno::XInterface >() );
     }
 }
 
@@ -372,16 +447,67 @@ ScVbaApplication::getActiveWindow() throw (uno::RuntimeException)
 uno::Any SAL_CALL 
 ScVbaApplication::getCutCopyMode() throw (uno::RuntimeException)
 {
-    //# FIXME TODO, implementation
     uno::Any result;
-    result <<= sal_False;
+	ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( NULL );
+	ScDocument* pDoc = pOwnClip ? pOwnClip->GetDocument() : NULL;
+	if ( pDoc )
+	{
+		if ( pDoc->IsCutMode() )
+		{
+			result <<= excel::XlCutCopyMode::xlCut;
+		}
+		else
+		{
+			result <<= excel::XlCutCopyMode::xlCopy;
+		}
+	}
+	else
+	{
+		result <<= sal_False;
+	}
     return result;
 }
 
 void SAL_CALL 
-ScVbaApplication::setCutCopyMode( const uno::Any& /*_cutcopymode*/ ) throw (uno::RuntimeException)
-{
-    //# FIXME TODO, implementation
+ScVbaApplication::setCutCopyMode( const uno::Any& _cutcopymode ) throw (uno::RuntimeException)
+{
+	// According to Excel's behavior, no matter what is the value of _cutcopymode, always releases the clip object.
+	sal_Bool bCutCopyMode = sal_False;
+	if ( ( _cutcopymode >>= bCutCopyMode ) )
+	{
+		ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( NULL );
+		if ( pOwnClip )
+		{
+			pOwnClip->ObjectReleased();
+			ScTabViewShell* pTabViewShell = excel::getBestViewShell( getCurrentDocument() );
+			if ( pTabViewShell )
+			{
+				ScViewData* pView = pTabViewShell->GetViewData();	
+				Window* pWindow = pView ? pView->GetActiveWin() : NULL;
+				if ( pWindow )
+				{
+					Reference< datatransfer::clipboard::XClipboard > xClipboard = pWindow->GetClipboard();
+					Reference< datatransfer::clipboard::XFlushableClipboard > xFlushableClipboard( xClipboard, uno::UNO_QUERY );
+					if ( xClipboard.is() )
+					{
+						xClipboard->setContents( NULL, NULL );
+						if ( xFlushableClipboard.is() )
+						{
+							const sal_uInt32 nRef = Application::ReleaseSolarMutex();
+							try
+							{
+								xFlushableClipboard->flushClipboard();
+							}
+							catch( const uno::Exception& )
+							{
+							}
+							Application::AcquireSolarMutex( nRef );
+						}
+					}
+				}
+			}
+		}
+	}
 }
 
 uno::Any SAL_CALL
@@ -730,6 +856,91 @@ ScVbaApplication::getEnableEvents() throw (uno::RuntimeException)
     return m_bEnableEvents;
 }
 
+sal_Bool SAL_CALL
+ScVbaApplication::getVisible() throw (uno::RuntimeException)
+{
+	sal_Bool bVisible = sal_True;	
+	return bVisible;
+}
+
+void SAL_CALL
+ScVbaApplication::setVisible(sal_Bool /*bVisible*/) throw (uno::RuntimeException)
+{
+}
+
+//liuchen 2009-11-25 add the support of Excel VBA Application.Iteration
+//The Excel Iteration option is global and unique, but in Symphony there is an Iteration property in ScModule and one in every ScDocument,
+//so the set method will set all the Iteration properties
+sal_Bool SAL_CALL
+ScVbaApplication::getIteration() throw (uno::RuntimeException)
+{
+	ScModule* pScMod = SC_MOD();
+	ScDocOptions  aDocOpt  = pScMod->GetDocOptions();
+	
+	return aDocOpt.IsIter();
+}
+
+void SAL_CALL
+ScVbaApplication::setIteration(sal_Bool bIteration) throw (uno::RuntimeException)
+{
+	ScModule* pScMod = SC_MOD();
+	ScDocOptions& aDocOpt = const_cast< ScDocOptions& > (pScMod->GetDocOptions());
+	aDocOpt.SetIter( bIteration );
+
+	uno::Any aIteration;
+	aIteration <<= bIteration;
+
+	OUString aPropName = OUString::createFromAscii( "IsIterationEnabled" );
+
+	uno::Reference< XCollection > xWorkbooks( new ScVbaWorkbooks( this, mxContext ) );
+	sal_Int32 nCount = xWorkbooks->getCount();
+
+	for (sal_Int32 i = 1; i <= nCount; i++)
+	{
+		uno::Reference< ooo::vba::excel::XWorkbook > xWorkbook;
+		uno::Any aWorkbook = xWorkbooks->Item(uno::makeAny(i), uno::Any());
+		aWorkbook >>= xWorkbook;
+		ScVbaWorkbook* pWorkbook = static_cast< ScVbaWorkbook* > ( xWorkbook.get() );
+
+		uno::Reference< frame::XModel > xModel( pWorkbook->getDocModel(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xPropertySet( xModel, uno::UNO_QUERY_THROW );
+		xPropertySet->setPropertyValue( aPropName, aIteration );
+	}    
+}
+//liuchen 2009-11-25 end
+
+//liuchen 2009-11-26 add the support of Excel VBA Application.EnableCancelKey
+sal_Int32 SAL_CALL
+ScVbaApplication::getEnableCancelKey() throw (uno::RuntimeException)
+{	
+	return ooo::vba::excel::XlEnableCancelKey::xlDisabled;
+}
+
+void SAL_CALL
+ScVbaApplication::setEnableCancelKey(sal_Int32 /*lEnableCancelKey*/) throw (uno::RuntimeException)
+{		
+}
+//liuchen 2009-11-26 end
+
+sal_Int32 SAL_CALL ScVbaApplication::getSheetsInNewWorkbook() throw (uno::RuntimeException)
+{
+	const ScAppOptions& rAppOpt = SC_MOD()->GetAppOptions();
+	return rAppOpt.GetTabCountInNewSpreadsheet();
+}
+
+void SAL_CALL ScVbaApplication::setSheetsInNewWorkbook( sal_Int32 SheetsInNewWorkbook ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( SheetsInNewWorkbook < 1 || SheetsInNewWorkbook > MAXTAB )
+	{
+		DebugHelper::exception( OUString::createFromAscii("The number must be between 1 and 255"), uno::Exception(), SbERR_METHOD_FAILED, OUString() );
+	}
+	else
+	{
+		ScAppOptions& rAppOpt = const_cast< ScAppOptions& >(SC_MOD()->GetAppOptions());
+		rAppOpt.SetTabCountInNewSpreadsheet( SheetsInNewWorkbook );
+	}
+}
+
 void SAL_CALL
 ScVbaApplication::Calculate() throw(  script::BasicErrorException , uno::RuntimeException )
 {
@@ -1218,13 +1429,19 @@ ScVbaApplication::Volatile( const uno::Any& aVolatile )  throw ( uno::RuntimeExc
 {
     sal_Bool bVolatile = sal_True;
     aVolatile >>= bVolatile;
+    SbMethod* pMeth = StarBASIC::GetActiveMethod();
+    if ( pMeth )
+    {
+        OSL_TRACE("ScVbaApplication::Volatile() In method ->%s<-", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+        uno::Reference< frame::XModel > xModel( getCurrentDocument() );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        pDoc->GetMacroManager()->SetUserFuncVolatile( pMeth->GetName(), bVolatile);
+    }
+
+// this is bound to break when loading the document
     return; 
 }
 
-void SAL_CALL
-ScVbaApplication::DoEvents() throw ( uno::RuntimeException )
-{
-}
 ::sal_Bool SAL_CALL 
 ScVbaApplication::getDisplayFormulaBar() throw ( css::uno::RuntimeException )
 {
@@ -1276,12 +1493,421 @@ ScVbaApplication::Caller( const uno::Any& /*aIndex*/ ) throw ( uno::RuntimeExcep
     return aRet;
 }
 
+//Add by minz@cn.ibm.com. 2009-07-08.
+uno::Any SAL_CALL 
+ScVbaApplication::GetOpenFilename(const uno::Any& FileFilter, const uno::Any& FilterIndex, const uno::Any& Title, const uno::Any& ButtonText, const uno::Any& MultiSelect)  throw (uno::RuntimeException)
+{
+	uno::Any aRet = uno::makeAny( sal_False );
+	try
+	{
+		const ::rtl::OUString sServiceName = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+		uno::Reference< lang::XMultiServiceFactory > xMSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+		// Set the type of File Picker Dialog: TemplateDescription::FILEOPEN_SIMPLE.
+		uno::Sequence< uno::Any > aDialogType( 1 );
+		aDialogType[0] <<= ui::dialogs::TemplateDescription::FILEOPEN_SIMPLE;
+		uno::Reference< ui::dialogs::XFilePicker > xFilePicker( xMSF->createInstanceWithArguments( sServiceName, aDialogType ), UNO_QUERY );
+		uno::Reference< ui::dialogs::XFilePicker2 > xFilePicker2( xFilePicker, UNO_QUERY );
+		uno::Reference< ui::dialogs::XFilterManager > xFilterManager( xFilePicker, UNO_QUERY );
+		uno::Reference< ui::dialogs::XExecutableDialog > xExecutableDialog( xFilePicker, UNO_QUERY );
+		uno::Reference< ui::dialogs::XFilePickerControlAccess > xPickerControlAccess( xFilePicker, UNO_QUERY );
+
+		if ( xFilterManager.is() && FileFilter.hasValue() )
+		{
+			sal_Int32 nFilterIndex = 1;
+			if ( FilterIndex.hasValue() )
+			{
+				FilterIndex >>= nFilterIndex;
+			}
+			::rtl::OUString strFilter;
+			FileFilter >>= strFilter;
+			sal_Int32 nCommaID = 0;
+			sal_Int32 nIndex = 1;
+			do
+			{
+				::rtl::OUString aFilterTitleToken = strFilter.getToken( 0, ',' , nCommaID );
+				::rtl::OUString aFilterToken;
+				if ( nCommaID >= 0 )
+				{
+					aFilterToken = strFilter.getToken( 0, ',' , nCommaID );
+				}
+				else if ( nCommaID < 0 && nIndex == 1 )
+				{
+					throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid FileFilter format!" ), uno::Reference< uno::XInterface >() );
+				}
+				xFilterManager->appendFilter( aFilterTitleToken, aFilterToken );
+				if ( nFilterIndex == nIndex )
+				{
+					xFilterManager->setCurrentFilter( aFilterTitleToken );
+				}
+				nIndex++;
+			} while ( nCommaID >= 0 );
+		}
+		if ( xExecutableDialog.is() && Title.hasValue() )
+		{
+			::rtl::OUString sTitle;
+			Title >>= sTitle;
+			xExecutableDialog->setTitle( sTitle );
+		}
+		if ( xPickerControlAccess.is() && ButtonText.hasValue() )
+		{
+			::rtl::OUString sButtonText;
+			ButtonText >>= sButtonText;
+			xPickerControlAccess->setLabel( ui::dialogs::CommonFilePickerElementIds::PUSHBUTTON_OK, sButtonText );
+		}
+		sal_Bool bMultiSelect = sal_False;
+		if ( xFilePicker.is() && MultiSelect.hasValue() )
+		{
+			MultiSelect >>= bMultiSelect;
+			xFilePicker->setMultiSelectionMode( bMultiSelect );
+		}
+
+		if ( xFilePicker.is() && xFilePicker->execute() )
+		{
+			sal_Bool bUseXFilePicker2 = sal_False;
+			uno::Reference< lang::XServiceInfo > xServiceInfo( xFilePicker, UNO_QUERY );
+			if ( xServiceInfo.is() )
+			{
+				rtl::OUString sImplName = xServiceInfo->getImplementationName();
+				if ( sImplName.equalsAscii("com.sun.star.comp.fpicker.VistaFileDialog") || sImplName.equalsAscii("com.sun.star.ui.dialogs.SalGtkFilePicker") )
+				{
+					bUseXFilePicker2 = sal_True;
+				}
+			}
+			uno::Sequence< rtl::OUString > aSelectedFiles;
+			if ( bUseXFilePicker2 && xFilePicker2.is() )
+			{
+				// On Linux, XFilePicker->getFiles() always return one selected file although we select more than one file, also on Vista 
+				// XFilePicker->getFiles() does not work well too, so we call XFilePicker2->getSelectedFiles() to get selected files.
+				aSelectedFiles = xFilePicker2->getSelectedFiles();
+			}
+			else
+			{
+				// If only one file is selected, the first entry of the sequence contains the complete path/filename in URL format. If multiple files are selected, 
+				// the first entry of the sequence contains the path in URL format, and the other entries contains the names of the selected files without path information.
+				uno::Sequence< rtl::OUString > aTmpFiles = xFilePicker->getFiles();
+				aSelectedFiles = aTmpFiles;
+				sal_Int32 iFileCount = aTmpFiles.getLength();
+				if ( iFileCount > 1 )
+				{
+					aSelectedFiles.realloc( iFileCount - 1 );
+					INetURLObject aPath( aTmpFiles[0] );
+					aPath.setFinalSlash();
+					for ( sal_Int32 i = 1; i < iFileCount; i++ )
+					{
+						if ( aTmpFiles[i].indexOf ('/') > 0 || aTmpFiles[i].indexOf ('\\') > 0 )
+						{
+							aSelectedFiles[i - 1] = aTmpFiles[i];
+						}
+						else
+						{
+							if ( i == 1 )
+								aPath.Append( aTmpFiles[i] );
+							else
+								aPath.setName( aTmpFiles[i] );
+							aSelectedFiles[i - 1] = aPath.GetMainURL( INetURLObject::NO_DECODE );
+						}
+					}
+				}
+			}
+
+			sal_Int32 iFileCount = aSelectedFiles.getLength();
+			for ( sal_Int32 i = 0; i < iFileCount; i++ )
+			{
+				INetURLObject aObj( aSelectedFiles[i] );
+				if ( aObj.GetProtocol() == INET_PROT_FILE )
+				{
+					rtl::OUString aTemp = aObj.PathToFileName();
+					aSelectedFiles[i] = aTemp.getLength() > 0 ? aTemp : aSelectedFiles[i];
+				}
+			}
+			if ( bMultiSelect )
+			{
+				aRet = uno::makeAny( aSelectedFiles );
+			}
+			else if ( aSelectedFiles.getLength() > 0 && !bMultiSelect )
+			{
+				aRet = uno::makeAny( aSelectedFiles[0] );
+			}
+		}
+	}
+	catch( const uno::Exception& )
+	{
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+	}
+
+	return aRet;
+}
+
+//liming 2009-7-17
+::com::sun::star::uno::Reference< ::ooo::vba::XFileDialog > SAL_CALL 
+ScVbaApplication::getFileDialog() throw (::com::sun::star::uno::RuntimeException)
+{	
+	uno::Reference< XFileDialog > xFileDialogs( new ScVbaFileDialog( uno::Reference< XHelperInterface >( this ), mxContext, getCurrentDocument() ) );
+	return  xFileDialogs;
+}
+
+typedef std::map< ::rtl::OUString, ::rtl::OUString > FileFilterMap;
+
+//2009-11-06 add by limingl
+uno::Any SAL_CALL 
+ScVbaApplication::GetSaveAsFilename( const ::com::sun::star::uno::Any& InitialFilename, const ::com::sun::star::uno::Any& FileFilter, const ::com::sun::star::uno::Any& FilterIndex, const ::com::sun::star::uno::Any& Title, const ::com::sun::star::uno::Any& ButtonText ) throw (::com::sun::star::uno::RuntimeException)
+{
+	uno::Any strRet;
+	try
+	{
+		const ::rtl::OUString sServiceName = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+		uno::Reference< lang::XMultiServiceFactory > xMSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+		
+		uno::Sequence< uno::Any > aDialogType( 1 );
+		aDialogType[0] <<= ui::dialogs::TemplateDescription::FILESAVE_SIMPLE;
+		uno::Reference< ui::dialogs::XFilePicker > xFilePicker( xMSF->createInstanceWithArguments( sServiceName, aDialogType ), UNO_QUERY );
+		
+		if (InitialFilename.hasValue())
+		{
+			::rtl::OUString strInitFileName;
+			InitialFilename >>= strInitFileName;
+			xFilePicker->setDefaultName(strInitFileName);
+		}
+
+		// Begin from 1.
+		sal_Int32 nFilterIndex = 1;
+		if (FilterIndex.hasValue())
+		{
+			FilterIndex >>= nFilterIndex;
+		}
+
+		uno::Reference< ui::dialogs::XFilterManager > xFilter( xFilePicker, UNO_QUERY );
+		FileFilterMap mFilterNameMap;
+		if (FileFilter.hasValue())
+		{
+			::rtl::OUString strFilter;
+			sal_Int32       nCommaID = 0;
+			FileFilter >>= strFilter;
+
+			sal_Int32 nIndex = 1;
+			do
+			{
+				::rtl::OUString aFilterTitleToken = strFilter.getToken( 0, ',' , nCommaID );
+				::rtl::OUString aFilterToken;
+				if ( nCommaID >= 0 )
+				{
+					aFilterToken = strFilter.getToken( 0, ',' , nCommaID );
+				}
+				else if ( nCommaID < 0 && nIndex == 1 )
+				{
+					throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid FileFilter format!" ), uno::Reference< uno::XInterface >() );
+				}
+
+				FileFilterMap::const_iterator aIt = mFilterNameMap.find( aFilterTitleToken );
+				if ( aIt == mFilterNameMap.end() )
+				{
+					xFilter->appendFilter( aFilterTitleToken, aFilterToken );
+					if ( nFilterIndex == nIndex )
+					{
+						xFilter->setCurrentFilter( aFilterTitleToken );
+					}
+					nIndex++;
+					mFilterNameMap[aFilterTitleToken] = aFilterToken;
+				}
+			} while ( nCommaID >= 0 );
+		}
+
+		if (Title.hasValue())
+		{
+			::rtl::OUString strTitle;
+			Title >>= strTitle;
+			uno::Reference< ::com::sun::star::ui::dialogs::XExecutableDialog> xExcTblDlg(xFilePicker, UNO_QUERY );
+			xExcTblDlg->setTitle(strTitle);
+		}
+
+		if (ButtonText.hasValue())
+		{
+			::rtl::OUString strBttTxt;
+			ButtonText >>= strBttTxt;
+		}
+		
+		
+		if ( xFilePicker.is() )
+		{
+			sal_Int16 nRet = xFilePicker->execute();
+			if (nRet == 0)
+			{
+				strRet <<= sal_False;
+			}
+			else
+			{
+				uno::Sequence < rtl::OUString > aPathSeq = xFilePicker->getFiles();
+
+				if ( aPathSeq.getLength() )
+				{
+					::rtl::OUString sSelectedFilters;
+					if ( xFilter.is() )
+					{
+						::rtl::OUString sSelectedFilterName = xFilter->getCurrentFilter();
+						FileFilterMap::const_iterator aIt = mFilterNameMap.find( sSelectedFilterName );
+						if ( aIt != mFilterNameMap.end() )
+						{
+							sSelectedFilters = aIt->second;
+						}
+					}
+					INetURLObject aURLObj( aPathSeq[0] );
+					::rtl::OUString aPathStr = aURLObj.PathToFileName();
+					if ( aURLObj.GetProtocol() == INET_PROT_FILE )
+					{
+						sal_Int32 nSemicolonID = 0;
+						::rtl::OUString sFirstFilter = sSelectedFilters.getToken( 0, ';' , nSemicolonID );
+						::rtl::OUString sFileExtension = aURLObj.GetExtension();
+						if ( sFileExtension.equalsAscii("") )
+						{
+							sFileExtension = sFirstFilter.equalsAscii("*.*") ? sFileExtension : sFirstFilter.copy( sFirstFilter.indexOfAsciiL("*.", 2) + 2 );
+							aPathStr = sFileExtension.equalsAscii("") ? aPathStr : aPathStr + ::rtl::OUString::createFromAscii(".") + sFileExtension;
+						}
+						else
+						{
+							sal_Bool bValidFilter = sal_False;
+							FileFilterMap::const_iterator aIt = mFilterNameMap.begin();
+							while ( aIt != mFilterNameMap.end() )
+							{
+								sSelectedFilters = aIt->second;
+								nSemicolonID = 0;
+								do
+								{
+									::rtl::OUString aFilterToken = sSelectedFilters.getToken( 0, ';' , nSemicolonID );
+									if ( aFilterToken.trim().equalsIgnoreAsciiCase(::rtl::OUString::createFromAscii("*.") + sFileExtension) )
+									{
+										bValidFilter = sal_True;
+										break;
+									}
+								} while ( nSemicolonID >= 0 );
+								if ( bValidFilter )
+								{
+									break;
+								}
+								aIt++;
+							}
+							if ( !bValidFilter )
+							{
+								sFileExtension = sFirstFilter.equalsAscii("*.*") ? ::rtl::OUString::createFromAscii("") : sFirstFilter.copy( sFirstFilter.indexOfAsciiL("*.", 2) + 2 );
+								aPathStr = sFileExtension.equalsAscii("") ? aPathStr : aPathStr + ::rtl::OUString::createFromAscii(".") + sFileExtension;
+							}
+						}
+					}
+					strRet <<= aPathStr;
+				}
+			}
+		}
+	}
+	catch( const uno::Exception& )
+	{
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+	}
+	return strRet;
+}
+
+//end add
+
 uno::Reference< frame::XModel > 
 ScVbaApplication::getCurrentDocument() throw (css::uno::RuntimeException)
 {
     return getCurrentExcelDoc(mxContext);
 }
 
+uno::Any SAL_CALL
+ScVbaApplication::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCommandBars > xCommandBars( CommandBars( uno::Any() ), uno::UNO_QUERY_THROW );
+	uno::Reference< XCollection > xMenuBars( new ScVbaMenuBars( this, mxContext, xCommandBars ) );
+	if (  aIndex.hasValue() )
+	{
+	    return uno::Any ( xMenuBars->Item( aIndex, uno::Any() ) );
+	}
+
+	return uno::Any( xMenuBars );
+}
+
+//liuchen 2009-11-26 add the support of Application.International
+sal_Int32 SAL_CALL
+ConvertCountryCode(const OUString& language)
+{
+	sal_Int32 nCode = 0;
+
+	if( language == OUString::createFromAscii("ar") ) nCode = 966; // Arabic
+	else if ( language == OUString::createFromAscii("cs") ) nCode = 42; // Czech	
+	else if ( language == OUString::createFromAscii("da") ) nCode = 45;	 // Danish
+	else if ( language == OUString::createFromAscii("de") ) nCode = 49;	 // German
+	else if ( language == OUString::createFromAscii("en") ) nCode = 1;	 // English
+	else if ( language == OUString::createFromAscii("es") ) nCode = 34;	 // Spanish
+	else if ( language == OUString::createFromAscii("el") ) nCode = 30;	 // Greek
+	else if ( language == OUString::createFromAscii("fa") ) nCode = 98;	 // Persian = Farsi	
+	else if ( language == OUString::createFromAscii("fi") ) nCode = 358;  // Finnish
+	else if ( language == OUString::createFromAscii("fr") ) nCode = 33;	 // French
+	else if ( language == OUString::createFromAscii("he") ) nCode = 972;	 // Hebrew
+	else if ( language == OUString::createFromAscii("hi") ) nCode = 91;	 // Indian = Hindi
+	else if ( language == OUString::createFromAscii("hu") ) nCode = 36;	 // Hungarian
+	else if ( language == OUString::createFromAscii("it") ) nCode = 39;	 // Italian
+	else if ( language == OUString::createFromAscii("ja") ) nCode = 81;	 // Japanese
+	else if ( language == OUString::createFromAscii("ko") ) nCode = 82;	 // Korean
+	else if ( language == OUString::createFromAscii("nl") ) nCode = 31;	 // Dutch
+	else if ( language == OUString::createFromAscii("no") ) nCode = 47;	 // Norwegian
+	else if ( language == OUString::createFromAscii("pl") ) nCode = 48;	 // Polish
+	else if ( language == OUString::createFromAscii("pt") ) nCode = 351;	 // Portuguese
+	else if ( language == OUString::createFromAscii("ru") ) nCode = 7;	 // Russian
+	else if ( language == OUString::createFromAscii("sv") ) nCode = 46;  // Swedish
+	else if ( language == OUString::createFromAscii("th") ) nCode = 66;	 // Thai
+	else if ( language == OUString::createFromAscii("tk") ) nCode = 90;	 // Turkish
+	else if ( language == OUString::createFromAscii("ur") ) nCode = 92;	 // Urdu
+	else if ( language == OUString::createFromAscii("vi") ) nCode = 84;	 // Vietnamese
+	else if ( language == OUString::createFromAscii("zh") ) nCode = 86;	 // Simplified Chinese
+	
+	return nCode;
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::International( sal_Int32 Index ) throw (uno::RuntimeException)
+{
+	uno::Any aRet;
+	OUString str;
+	const LocaleDataWrapper* pLocaleData = ScGlobal::GetpLocaleData();
+	switch ( Index )
+	{
+	case excel::XlApplicationInternational::xlCountryCode:
+		aRet <<= ConvertCountryCode( pLocaleData->getLanguageCountryInfo().Language );
+		break;
+	case excel::XlApplicationInternational::xlDecimalSeparator:
+		str = pLocaleData->getNumDecimalSep();
+		aRet <<= str;
+		break;
+	case excel::XlApplicationInternational::xlDateSeparator:
+		str = pLocaleData->getDateSep();
+		aRet <<= str;
+		break;
+	default:
+		break;
+	}
+	return aRet;
+}
+//liuchen 2009-11-26 end
+
+//2009-12-11 add by limingl
+void SAL_CALL ScVbaApplication::Undo(  ) throw (::com::sun::star::uno::RuntimeException)
+{
+	SfxAllItemSet reqList(  SFX_APP()->GetPool() );
+	SfxRequest      rReq(SID_UNDO, 0, reqList);
+	ScTabViewShell* pViewShell = excel::getCurrentBestViewShell( mxContext );
+
+	if (pViewShell != NULL)
+	{
+		pViewShell->ExecuteUndo(rReq);
+	}
+}
+//end
+
+double SAL_CALL ScVbaApplication::InchesToPoints( double Inches ) throw (uno::RuntimeException)
+{
+	// Convert a measurement from Inch to Point (1 inch = 72 points).
+	return MetricField::ConvertDoubleValue( Inches, 0, 0, FUNIT_INCH, FUNIT_POINT );
+}
+
 rtl::OUString& 
 ScVbaApplication::getServiceImplName()
 {
diff --git sc/source/ui/vba/vbaapplication.hxx sc/source/ui/vba/vbaapplication.hxx
index e6ebe28..a25455d 100644
--- sc/source/ui/vba/vbaapplication.hxx
+++ sc/source/ui/vba/vbaapplication.hxx
@@ -47,6 +47,7 @@ private:
      sal_Bool m_bEnableEvents;
 
     rtl::OUString getOfficePath( const rtl::OUString& sPath ) throw ( css::uno::RuntimeException );
+	css::uno::Reference< ov::XFileSearch > m_xFileSearch; //
     
 protected:
     virtual css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException);
@@ -89,6 +90,7 @@ public:
     virtual void SAL_CALL setDisplayFormulaBar( ::sal_Bool _displayformulabar ) throw ( css::uno::RuntimeException );
 
     virtual css::uno::Reference< ov::XAssistant > SAL_CALL getAssistant() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::XFileSearch > SAL_CALL getFileSearch() throw (css::uno::RuntimeException); //liuchen 2009-8-18 add the support of Application.FileSearch
     virtual css::uno::Reference< ov::excel::XWorkbook > SAL_CALL getThisWorkbook() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Workbooks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
@@ -101,6 +103,17 @@ public:
     virtual void SAL_CALL setStatusBar( const css::uno::Any& _statusbar ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getCursor() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCursor( ::sal_Int32 _cursor ) throw (css::uno::RuntimeException);
+
+	virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool bVisible ) throw (css::uno::RuntimeException);
+
+	virtual sal_Bool SAL_CALL getIteration() throw (css::uno::RuntimeException);  //liuchen 2009-11-25 add the support of Iteration
+	virtual void SAL_CALL setIteration( sal_Bool bIteration ) throw (css::uno::RuntimeException);  //liuchen 2009-11-25 add the support of Iteration
+	virtual sal_Int32 SAL_CALL getEnableCancelKey() throw (css::uno::RuntimeException);  //liuchen 2009-11-26 add the support of EnableCancelKey
+	virtual void SAL_CALL setEnableCancelKey( sal_Int32 lEnableCancelKey ) throw (css::uno::RuntimeException);  //liuchen 2009-11-26 add the support of EnableCancelKey
+
+	virtual sal_Int32 SAL_CALL getSheetsInNewWorkbook() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setSheetsInNewWorkbook( sal_Int32 SheetsInNewWorkbook ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
 
     virtual sal_Bool SAL_CALL getEnableEvents() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnableEvents( sal_Bool bEnable ) throw (css::uno::RuntimeException);
@@ -114,8 +130,16 @@ public:
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual void SAL_CALL Volatile( const css::uno::Any& Volatile ) throw (css::uno::RuntimeException );
-    virtual void SAL_CALL DoEvents() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Caller( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL GetOpenFilename( const css::uno::Any& FileFilter, const css::uno::Any& FilterIndex, const css::uno::Any& Title, const css::uno::Any& ButtonText, const css::uno::Any& MultiSelect ) throw (css::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Reference< ::ooo::vba::XFileDialog > SAL_CALL getFileDialog() throw (::com::sun::star::uno::RuntimeException); //liminl 2009-08-12 add
+	virtual css::uno::Any SAL_CALL International( sal_Int32 Index ) throw (css::uno::RuntimeException); //liuchen 2009-11-26
+	//2009-12-04 add by limingl
+	virtual css::uno::Any SAL_CALL GetSaveAsFilename( const ::com::sun::star::uno::Any& InitialFilename, const ::com::sun::star::uno::Any& FileFilter, const ::com::sun::star::uno::Any& FilterIndex, const ::com::sun::star::uno::Any& Title, const ::com::sun::star::uno::Any& ButtonText ) throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL Undo(  ) throw (::com::sun::star::uno::RuntimeException);
+	virtual double SAL_CALL InchesToPoints( double Inches ) throw (css::uno::RuntimeException);
+	
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git sc/source/ui/vba/vbacomment.cxx sc/source/ui/vba/vbacomment.cxx
index 797b080..3d2c791 100644
--- sc/source/ui/vba/vbacomment.cxx
+++ sc/source/ui/vba/vbacomment.cxx
@@ -33,14 +33,23 @@
 #include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
 #include <com/sun/star/sheet/XSheetAnnotationShapeSupplier.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/table/XCell.hpp>
 #include <com/sun/star/text/XText.hpp>
 
+#include <cellsuno.hxx>
+#include <postit.hxx>
+#include <svx/svdobj.hxx>
+#include <svx/svdocapt.hxx>
+#include <ooo/vba/msforms/XShape.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+
 #include <vbahelper/vbashape.hxx>
 #include "vbaglobals.hxx"
 #include "vbacomments.hxx"
-
+#include "vbacommentshape.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -178,8 +187,7 @@ ScVbaComment::Text( const uno::Any& aText, const uno::Any& aStart, const uno::An
     aText >>= sText;
 
     uno::Reference< text::XSimpleText > xAnnoText( getAnnotation(), uno::UNO_QUERY_THROW );
-    rtl::OUString sAnnoText = xAnnoText->getString();
-
+        
     if ( aStart.hasValue() )
     {
         sal_Int16 nStart = 0;
@@ -212,10 +220,12 @@ ScVbaComment::Text( const uno::Any& aText, const uno::Any& aStart, const uno::An
     }
     else if ( aText.hasValue() )
     {
-        xAnnoText->setString( sText );
-        return sText;
+	 uno::Reference< sheet::XCellAddressable > xCellAddr(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	 table::CellAddress aAddress = xCellAddr->getCellAddress();
+	 getAnnotations()->insertNew( aAddress, sText );
     }
 
+    rtl::OUString sAnnoText = xAnnoText->getString();
     return sAnnoText;
 }
 
diff --git sc/source/ui/vba/vbacommentshape.cxx sc/source/ui/vba/vbacommentshape.cxx
new file mode 100644
index 0000000..ab97ac4
--- /dev/null
+++ sc/source/ui/vba/vbacommentshape.cxx
@@ -0,0 +1,46 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbacommentshape.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaCommentShape::ScVbaCommentShape( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< excel::XComment >& xComment, 
+	const uno::Reference< drawing::XShapes >& xShapes, const uno::Reference< frame::XModel >& xModel, sal_Int32 nType ) : ScVbaShape( xParent, xContext, xShape, xShapes, xModel, nType )
+{
+	m_xComment.set( xComment, uno::UNO_QUERY );
+}
+
+void SAL_CALL ScVbaCommentShape::Delete() throw (uno::RuntimeException)
+{
+	if ( m_xComment.is() )
+	{
+		m_xComment->Delete();
+	}
+}
diff --git sc/source/ui/vba/vbacommentshape.hxx sc/source/ui/vba/vbacommentshape.hxx
new file mode 100644
index 0000000..ce1c9ed
--- /dev/null
+++ sc/source/ui/vba/vbacommentshape.hxx
@@ -0,0 +1,46 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_VBA_COMMENTSHAPE_HXX
+#define SC_VBA_COMMENTSHAPE_HXX
+
+#include <ooo/vba/excel/XComment.hpp>
+#include <vbahelper/vbashape.hxx>
+
+class ScVbaCommentShape : public ScVbaShape
+{
+	css::uno::Reference< ooo::vba::excel::XComment > m_xComment;
+
+public:
+	ScVbaCommentShape( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape, 
+		const css::uno::Reference< ooo::vba::excel::XComment >& xComment, const css::uno::Reference< css::drawing::XShapes >& xShapes, const css::uno::Reference< css::frame::XModel >& xModel, sal_Int32 nType );
+
+	// Methods
+	virtual void SAL_CALL Delete() throw (css::uno::RuntimeException);
+};
+#endif //SC_VBA_COMMENTSHAPE_HXX
diff --git sc/source/ui/vba/vbadialog.cxx sc/source/ui/vba/vbadialog.cxx
index 891ac75..db56765 100644
--- sc/source/ui/vba/vbadialog.cxx
+++ sc/source/ui/vba/vbadialog.cxx
@@ -29,42 +29,58 @@
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-static const rtl::OUString aStringList[]=
+//liuchen 2009-7-27 
+//solve the problem that "Application.Dialogs.Item(***).Show" and "Application.Dialogs.Count" cannot get the correct result
+struct DialogMatch
 {
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation") ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) )	
+	sal_Int32 		nVbaDlgIndex;
+	rtl::OUString	aOODlgName;
 };
 
-const sal_Int32 nDialogSize = sizeof( aStringList ) / sizeof( aStringList[ 0 ] );
+static const DialogMatch aDialogMatchList[] = 
+{
+	{ 1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ) },						// xlDialogOpen -> .uno:Open
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ) },			// ??? -> .uno:FormatCellDialog
+	{ 55, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ) },				// xlDialogInsert -> .uno:InsertCell
+	{ 8, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ) },						// xlDialogPrint -> .uno:Print
+	{ 9,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PrinterSetup" ) ) }, 				// xlDialogPrinterSetup -> .uno:PrinterSetup
+	{ 53, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ) },				// xlDialogPasteSpecial -> .uno:PasteSpecial
+	{ 28, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ) },	// xlDialogProtectDocument -> uno:ToolProtectionDocument
+	{ 47,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ) },				// xlDialogColumnWidth -> .uno:ColumnWidth
+	{ 61,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ) },				// xlDialogDefineName -> .uno:DefineName
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ) },			// ??? -> .uno:ConfigureDialog
+	{ 596, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ) },			// xlDialogInsertHyperlink -> .uno:HyperlinkDialog
+	{ 342,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ) },				// xlDialogInsertPicture -> .uno:InsertGraphic
+	{ 259, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ) },				// xlDialogInsertObject -> .uno:InsertObject
+	{ 7,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ) },			// xlDialogPageSetup -> .uno:PageFormatDialog
+	{ 39,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ) },					// xlDialogSort -> .uno:DataSort
+	{ 127, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ) },					// xlDialogRowHeight -> .uno:RowHeight
+	{ 485,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ) },			// xlDialogAutoCorrect -> .uno:AutoCorrectDlg
+	{ 583, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ) },	// xlDialogCondiationalFormatting -> .uno:ConditionalFormatDialog
+	{ 191,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ) },			// xlDialogConsolidate -> .uno:DataConsolidate
+	{ 62,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ) },				// xlDialogCreateNames -> .uno:CreateNames
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ) },				// ??? -> .uno:FillSeries
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation" ) ) },				// ??? -> .uno:Validation"
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ) },			// ??? -> .uno:DefineLabelRange
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ) },		// ??? -> .uno:DataFilterAutoFilter
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ) }, 	// ??? -> .uno:DataFilterSpecialFilter
+	{ 269,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) ) }					// xlDialogFormatAuto -> .uno:AutoFormat
+};
+
+const sal_Int32 nDialogSize = sizeof( aDialogMatchList ) / sizeof( aDialogMatchList[ 0 ] );
 
+//liuchen modified 2009-2-27
 rtl::OUString 
 ScVbaDialog::mapIndexToName( sal_Int32 nIndex )
 {
-    if( nIndex < nDialogSize )
-        return aStringList[ nIndex ];
+	for (int i = 0; i < nDialogSize; i++)
+	{
+		if ( aDialogMatchList[i].nVbaDlgIndex == nIndex )
+		{
+			return aDialogMatchList[i].aOODlgName;
+		}
+	}
+	
     return rtl::OUString();
 }
 
@@ -86,3 +102,9 @@ ScVbaDialog::getServiceNames()
     }
     return aServiceNames;
 }
+
+//liuchen add 2009-7-27
+sal_Int32 ScVbaDialog::GetSupportedDialogCount()
+{
+	return nDialogSize;
+}
\ No newline at end of file
diff --git sc/source/ui/vba/vbadialog.hxx sc/source/ui/vba/vbadialog.hxx
index a886fe3..ffbfb84 100644
--- sc/source/ui/vba/vbadialog.hxx
+++ sc/source/ui/vba/vbadialog.hxx
@@ -45,6 +45,9 @@ public:
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	//liuchen 2009-7-27
+	static sal_Int32 GetSupportedDialogCount();
 };
 
 #endif /* SC_VBA_DIALOG_HXX */
diff --git sc/source/ui/vba/vbadialogs.cxx sc/source/ui/vba/vbadialogs.cxx
index 16d3dcb..0ff0bb6 100644
--- sc/source/ui/vba/vbadialogs.cxx
+++ sc/source/ui/vba/vbadialogs.cxx
@@ -64,5 +64,13 @@ ScVbaDialogs::getServiceNames()
     return aServiceNames;
 }
 
+//liuchen 2009-7-27
+::sal_Int32
+ScVbaDialogs::getCount() throw (uno::RuntimeException)
+{	
+	return ScVbaDialog::GetSupportedDialogCount();
+}
+
+
 
 
diff --git sc/source/ui/vba/vbadialogs.hxx sc/source/ui/vba/vbadialogs.hxx
index 20fae2d..980dbf9 100644
--- sc/source/ui/vba/vbadialogs.hxx
+++ sc/source/ui/vba/vbadialogs.hxx
@@ -44,6 +44,7 @@ public:
 
     // XCollection
     virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException); //liuchen 2009-7-27
 
     // XDialogs
     virtual void SAL_CALL Dummy() throw (css::uno::RuntimeException);
diff --git sc/source/ui/vba/vbafiledialog.cxx sc/source/ui/vba/vbafiledialog.cxx
new file mode 100644
index 0000000..b7fa59f
--- /dev/null
+++ sc/source/ui/vba/vbafiledialog.cxx
@@ -0,0 +1,186 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbafiledialog.hxx"
+#include "comphelper/processfactory.hxx"
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker2.hpp>
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#include "tools/urlobj.hxx"
+
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+
+ScVbaFileDialog::ScVbaFileDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel )
+:	ScVbaFileDialog_BASE( xParent, xContext, xModel )
+{	
+	m_pFileDialogSelectedItems = new VbaFileDialogSelectedItems(xParent, xContext, (com::sun::star::container::XIndexAccess *)&m_FileDialogSelectedObj);
+} 
+
+ScVbaFileDialog::~ScVbaFileDialog() 
+{
+	if (m_pFileDialogSelectedItems != NULL)
+	{
+		delete m_pFileDialogSelectedItems;
+	}
+}
+
+rtl::OUString& 
+ScVbaFileDialog::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFileDialog") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+ScVbaFileDialog::getServiceNames()
+{
+	static Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.FileDialog" ) );
+	}
+	return aServiceNames;
+
+}
+
+css::uno::Reference< ov::XFileDialogSelectedItems > SAL_CALL 
+ScVbaFileDialog::getSelectedItems() throw (css::uno::RuntimeException)
+{
+	css::uno::Reference< ov::XFileDialogSelectedItems > xFileDlgSlc = (ov::XFileDialogSelectedItems *)m_pFileDialogSelectedItems;
+	return xFileDlgSlc;
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaFileDialog::Show( ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	// Returns an Integer indicating if user pressed "Open" button(-1) or "Cancel" button(0).
+	sal_Int32 nResult = -1;
+	try
+	{
+		m_sSelectedItems.realloc(0);
+
+		const ::rtl::OUString sServiceName = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+
+		Reference< lang::XMultiServiceFactory > xMSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+		// Set the type of File Picker Dialog: TemplateDescription::FILEOPEN_SIMPLE.
+		Sequence< uno::Any > aDialogType( 1 );
+		aDialogType[0] <<= ui::dialogs::TemplateDescription::FILEOPEN_SIMPLE;
+		Reference < ui::dialogs::XFilePicker > xFilePicker( xMSF->createInstanceWithArguments( sServiceName, aDialogType ), UNO_QUERY );
+		Reference < ui::dialogs::XFilePicker2 > xFilePicker2( xFilePicker, UNO_QUERY );
+		if ( xFilePicker.is() )
+		{
+			xFilePicker->setMultiSelectionMode(sal_True);
+			if ( xFilePicker->execute() )
+			{
+				sal_Bool bUseXFilePicker2 = sal_False;
+				Reference< lang::XServiceInfo > xServiceInfo( xFilePicker, UNO_QUERY );
+				if (xServiceInfo.is())
+				{
+					rtl::OUString sImplName = xServiceInfo->getImplementationName();
+					if (sImplName.equalsAscii("com.sun.star.comp.fpicker.VistaFileDialog") || 
+						sImplName.equalsAscii("com.sun.star.ui.dialogs.SalGtkFilePicker"))
+					{
+						bUseXFilePicker2 = sal_True;
+					}
+				}
+				if ( bUseXFilePicker2 && xFilePicker2.is() )
+				{
+					// On Linux, XFilePicker->getFiles() always return one selected file although we select 
+					// more than one file, also on Vista XFilePicker->getFiles() does not work well too, 
+					// so we call XFilePicker2->getSelectedFiles() to get selected files.
+					m_sSelectedItems = xFilePicker2->getSelectedFiles();
+				}
+				else
+				{
+					// If only one file is selected, the first entry of the sequence contains the complete path/filename in 
+					// URL format. If multiple files are selected, the first entry of the sequence contains the path in URL 
+					// format, and the other entries contains the names of the selected files without path information.
+					Sequence< rtl::OUString > aSelectedFiles = xFilePicker->getFiles();
+					sal_Int32 iFileCount = aSelectedFiles.getLength();
+					if ( iFileCount > 1 )
+					{
+						m_sSelectedItems.realloc( iFileCount - 1 );
+						INetURLObject aPath( aSelectedFiles[0] );
+						aPath.setFinalSlash();
+						for ( sal_Int32 i = 1; i < iFileCount; i++ )
+						{
+							if ( aSelectedFiles[i].indexOf ('/') > 0 || aSelectedFiles[i].indexOf ('\\') > 0 )
+							{
+								m_sSelectedItems[i - 1] = aSelectedFiles[i];
+							}
+							else
+							{
+								if ( i == 1 )
+									aPath.Append( aSelectedFiles[i] );
+								else
+									aPath.setName( aSelectedFiles[i] );
+								m_sSelectedItems[i - 1] = aPath.GetMainURL(INetURLObject::NO_DECODE);
+							}
+						}
+					}
+					else if ( iFileCount == 1 )
+					{
+						m_sSelectedItems = aSelectedFiles;
+					}
+				}
+
+				sal_Int32 iFileCount = m_sSelectedItems.getLength();
+				rtl::OUString aTemp;
+				for ( sal_Int32 i = 0; i < iFileCount; i++ )
+				{
+					INetURLObject aObj( m_sSelectedItems[i] );
+					if ( aObj.GetProtocol() == INET_PROT_FILE )
+					{
+						aTemp = aObj.PathToFileName();
+						m_sSelectedItems[i] = aTemp.getLength() > 0 ? aTemp : m_sSelectedItems[i];
+					}
+				}
+			}
+			else
+			{
+				nResult = 0;
+			}
+		}
+
+		m_FileDialogSelectedObj.SetSelectedFile(m_sSelectedItems);
+	}
+	catch( const uno::Exception& )
+	{
+		return 0;
+	}
+
+	return nResult;
+}
+
+
+
diff --git sc/source/ui/vba/vbafiledialog.hxx sc/source/ui/vba/vbafiledialog.hxx
new file mode 100644
index 0000000..2273e4b
--- /dev/null
+++ sc/source/ui/vba/vbafiledialog.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _vbafiledialog_hxx_
+#define _vbafiledialog_hxx_
+
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbadialogsbase.hxx>
+#include <ooo/vba/XFileDialog.hpp>
+#include "vbafiledialogselecteditems.hxx"
+
+
+typedef cppu::ImplInheritanceHelper1< VbaDialogsBase, ov::XFileDialog > ScVbaFileDialog_BASE;
+
+class ScVbaFileDialog : public ScVbaFileDialog_BASE
+{
+public:
+
+	ScVbaFileDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel ) ;
+	virtual ~ScVbaFileDialog() ;
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+	//XFileDialog
+	virtual css::uno::Reference< ov::XFileDialogSelectedItems > SAL_CALL getSelectedItems() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL Show(  ) throw (::com::sun::star::uno::RuntimeException) ;
+
+private:
+	css::uno::Sequence < rtl::OUString > m_sSelectedItems;
+	VbaFileDialogSelectedItems *m_pFileDialogSelectedItems;
+	VbaFileDialogSelectedObj   m_FileDialogSelectedObj;
+};
+
+#endif
\ No newline at end of file
diff --git sc/source/ui/vba/vbafiledialogselecteditems.cxx sc/source/ui/vba/vbafiledialogselecteditems.cxx
new file mode 100644
index 0000000..fbf0e14
--- /dev/null
+++ sc/source/ui/vba/vbafiledialogselecteditems.cxx
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbafiledialogselecteditems.hxx"
+
+using namespace ::com::sun::star;
+
+VbaFileDialogSelectedItems::VbaFileDialogSelectedItems( const css::uno::Reference< ov::XHelperInterface >& xParent,
+													   const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+													   const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess 
+													   )
+	: FileDialogSelectedItems_BASE( xParent, xContext,  xIndexAccess  )
+{
+}
+
+
+rtl::OUString& VbaFileDialogSelectedItems::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaFileDialogSelectedItems") );
+	return sImplName;
+
+}
+css::uno::Sequence<rtl::OUString> VbaFileDialogSelectedItems::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.FileDialogSelectedItems" ) );
+	}
+	return aServiceNames;
+
+}
+
+css::uno::Any VbaFileDialogSelectedItems::createCollectionObject( const css::uno::Any& aSource )
+{
+	css::uno::Any aRet;
+	aRet = aSource;
+	return aRet;
+}
+
+
+css::uno::Type SAL_CALL 
+VbaFileDialogSelectedItems::getElementType() throw (css::uno::RuntimeException)
+{
+	return ooo::vba::XFileDialogSelectedItems::static_type(0);
+}
+
+css::uno::Reference< css::container::XEnumeration > SAL_CALL 
+VbaFileDialogSelectedItems::createEnumeration() throw (css::uno::RuntimeException)
+{
+	css::uno::Reference< css::container::XEnumeration > xEnumRet(m_xIndexAccess, css::uno::UNO_QUERY);
+	return xEnumRet;
+}
+
+
+//VbaFileDialogSelectedObj
+//////////////////////////////////////////////////////////////////////////
+
+VbaFileDialogSelectedObj::VbaFileDialogSelectedObj()
+{
+	m_nIndex = 0;
+}
+
+
+sal_Bool 
+VbaFileDialogSelectedObj::SetSelectedFile(css::uno::Sequence<rtl::OUString> &sFList)
+{
+	m_sFileList = sFList;
+	return sal_True;
+}
+
+sal_Int32 SAL_CALL 
+VbaFileDialogSelectedObj::getCount() throw(::com::sun::star::uno::RuntimeException)
+{
+	sal_Int32 nListCnt = m_sFileList.getLength();
+	return nListCnt;
+}
+
+::com::sun::star::uno::Any SAL_CALL VbaFileDialogSelectedObj::getByIndex( sal_Int32 nIndex )
+throw(::com::sun::star::lang::IndexOutOfBoundsException,
+	  ::com::sun::star::lang::WrappedTargetException,
+	  ::com::sun::star::uno::RuntimeException)
+{
+	css::uno::Any  aRet;
+	
+	if ( nIndex >= getCount() )
+	{
+		throw css::lang::IndexOutOfBoundsException();
+	}
+
+	return uno::makeAny(m_sFileList[nIndex]);
+}
+
+::com::sun::star::uno::Type SAL_CALL 
+VbaFileDialogSelectedObj::getElementType()
+throw(::com::sun::star::uno::RuntimeException)
+{
+	return getCppuType((uno::Reference<com::sun::star::container::XIndexAccess>*)0);
+}
+
+sal_Bool SAL_CALL VbaFileDialogSelectedObj::hasElements() 
+throw(::com::sun::star::uno::RuntimeException)
+{
+	return ( getCount() != 0 );
+}
+
+::sal_Bool SAL_CALL 
+VbaFileDialogSelectedObj::hasMoreElements(  ) 
+throw (uno::RuntimeException)
+{
+	if (getCount() > m_nIndex)
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+
+uno::Any SAL_CALL 
+VbaFileDialogSelectedObj::nextElement(  ) 	
+throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+{
+	if (!hasMoreElements())
+	{
+		throw container::NoSuchElementException();
+	}
+
+	return uno::makeAny(m_sFileList[m_nIndex++]);
+}
+
+
+
diff --git sc/source/ui/vba/vbafiledialogselecteditems.hxx sc/source/ui/vba/vbafiledialogselecteditems.hxx
new file mode 100644
index 0000000..44a32cf
--- /dev/null
+++ sc/source/ui/vba/vbafiledialogselecteditems.hxx
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _vbafiledialogselecteditems_hxx_
+#define _vbafiledialogselecteditems_hxx_
+
+#include <ooo/vba/XFileDialogSelectedItems.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+
+typedef CollTestImplHelper< ov::XFileDialogSelectedItems > FileDialogSelectedItems_BASE;
+
+
+class VbaFileDialogSelectedItems : public FileDialogSelectedItems_BASE
+{
+public:
+	VbaFileDialogSelectedItems( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+		const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+		const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+protected:
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+private:
+};
+
+
+class VbaFileDialogSelectedObj : public cppu::WeakImplHelper2<css::container::XIndexAccess, css::container::XEnumeration>
+{
+public:
+	VbaFileDialogSelectedObj();
+	sal_Bool SetSelectedFile(css::uno::Sequence<rtl::OUString> &sFList);
+	//XIndexAccess
+	virtual sal_Int32 SAL_CALL getCount() throw(::com::sun::star::uno::RuntimeException);
+
+	virtual ::com::sun::star::uno::Any SAL_CALL getByIndex( sal_Int32 nIndex )
+		throw(::com::sun::star::lang::IndexOutOfBoundsException,
+		::com::sun::star::lang::WrappedTargetException,
+		::com::sun::star::uno::RuntimeException);
+
+	// XElementAccess
+	virtual ::com::sun::star::uno::Type SAL_CALL getElementType()
+		throw(::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Bool SAL_CALL hasElements() throw(::com::sun::star::uno::RuntimeException);
+
+	//XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL nextElement(  ) 	throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+
+protected:
+private:
+	css::uno::Sequence<rtl::OUString> m_sFileList;
+	sal_Int32 m_nIndex;
+};
+
+#endif
diff --git sc/source/ui/vba/vbafilesearch.cxx sc/source/ui/vba/vbafilesearch.cxx
new file mode 100644
index 0000000..7369ae5
--- /dev/null
+++ sc/source/ui/vba/vbafilesearch.cxx
@@ -0,0 +1,242 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbafilesearch.hxx"
+#include "vbaapplication.hxx"
+#include "vbafoundfiles.hxx"
+#include <comphelper/processfactory.hxx>
+#include <tools/urlobj.hxx>
+#include <tools/wldcrd.hxx>
+#include <com/sun/star/ucb/XSimpleFileAccess3.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/uno/Sequence.hxx>
+#include <vector>
+#include "unotools/viewoptions.hxx"
+#include <osl/file.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::ucb;
+using namespace ::com::sun::star::lang;
+using namespace comphelper;
+
+static Reference< XSimpleFileAccess3 > getFileAccess( void )
+{
+	static Reference< XSimpleFileAccess3 > xSFI;
+	if( !xSFI.is() )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+		if( xSMgr.is() )
+		{
+			xSFI = Reference< XSimpleFileAccess3 >( xSMgr->createInstance
+				( ::rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), UNO_QUERY );
+		}
+	}
+	return xSFI;
+}
+
+ScVbaFileSearch::ScVbaFileSearch( ScVbaApplication* pApp, const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext )
+		: ScVbaFileSearchImpl_BASE( xParent, xContext ), m_pApplication( pApp )
+{
+	NewSearch();
+}
+
+ScVbaFileSearch::~ScVbaFileSearch()
+{
+}
+
+::rtl::OUString SAL_CALL ScVbaFileSearch::getFileName() throw (css::uno::RuntimeException)
+{
+	return m_sFileName;
+}
+
+void SAL_CALL ScVbaFileSearch::setFileName(const ::rtl::OUString& _fileName ) throw (css::uno::RuntimeException)
+{
+	m_sFileName = _fileName;
+}
+
+::rtl::OUString SAL_CALL ScVbaFileSearch::getLookIn() throw (css::uno::RuntimeException)
+{
+	return m_sLookIn;
+}
+
+void SAL_CALL ScVbaFileSearch::setLookIn( const ::rtl::OUString& _lookIn ) throw (css::uno::RuntimeException)
+{
+	m_sLookIn = _lookIn;
+}
+
+sal_Bool SAL_CALL ScVbaFileSearch::getSearchSubFolders() throw (css::uno::RuntimeException)
+{
+	return m_bSearchSubFolders;
+}
+
+void SAL_CALL ScVbaFileSearch::setSearchSubFolders( sal_Bool _searchSubFolders ) throw (css::uno::RuntimeException)
+{
+	m_bSearchSubFolders = _searchSubFolders;
+}
+
+sal_Bool SAL_CALL ScVbaFileSearch::getMatchTextExactly() throw (css::uno::RuntimeException)
+{
+	return m_bMatchTextExactly;
+}
+
+void SAL_CALL ScVbaFileSearch::setMatchTextExactly( sal_Bool _matchTextExactly ) throw (css::uno::RuntimeException)
+{
+	m_bMatchTextExactly = _matchTextExactly;
+}
+
+static bool IsWildCard( const ::rtl::OUString& fileName )
+{		
+	static sal_Char cWild1 = '*';
+	static sal_Char cWild2 = '?';	
+
+	return  ( ( fileName.indexOf( cWild1 ) >= 0 )
+			|| ( fileName.indexOf( cWild2 ) >= 0 ) );
+}
+
+static void SearchWildCard(const WildCard& wildCard, const ::rtl::OUString& aDir, bool bSearchSubFolders, css::uno::Sequence< rtl::OUString >& aSearchedFiles)
+{
+	Reference< XSimpleFileAccess3 > xSFI = getFileAccess();
+	Sequence< rtl::OUString > aDirSeq;
+	try
+	{
+		if ( xSFI.is() )
+		{
+			aDirSeq = xSFI->getFolderContents( aDir, bSearchSubFolders );
+		}
+	}
+	catch( css::uno::Exception& )
+	{
+	}
+	sal_Int32 nLength = aDirSeq.getLength();
+	for ( sal_Int32 i = 0; i < nLength; i++ )
+	{
+		rtl::OUString aURLStr = aDirSeq[i];
+		if ( xSFI->isFolder( aURLStr ) )
+		{
+			if ( bSearchSubFolders )
+			{
+				SearchWildCard( wildCard, aURLStr, true, aSearchedFiles );
+			}
+		}
+		else
+		{
+			INetURLObject aFileURL( aURLStr );
+			rtl::OUString aFileName = aFileURL.GetLastName( INetURLObject::DECODE_UNAMBIGUOUS );
+			if ( wildCard.Matches( aFileName.toAsciiLowerCase() ) )
+			{
+				sal_Int32 nFilesLength = aSearchedFiles.getLength();
+				aSearchedFiles.realloc( nFilesLength + 1 );
+				rtl::OUString sSystemPath;
+				::osl::File::getSystemPathFromFileURL( aURLStr, sSystemPath );
+				aSearchedFiles[nFilesLength] = sSystemPath;
+			}
+		}
+	}
+}
+
+sal_Int32 SAL_CALL ScVbaFileSearch::Execute( )  throw (css::uno::RuntimeException)
+{
+	m_aSearchedFiles.realloc(0);
+	Reference< XSimpleFileAccess3 > xSFI = getFileAccess();
+	if ( !xSFI.is() || !xSFI->isFolder( m_sLookIn ) )
+	{
+		return 0;
+	}
+
+	if ( m_sFileName == ::rtl::OUString::createFromAscii( "" ) )
+	{
+		return 1;
+	}
+
+	::rtl::OUString aTempFileName = m_sFileName.toAsciiLowerCase();
+	if ( IsWildCard( aTempFileName ) )
+	{
+		bool bEndWithAsterisk = aTempFileName.endsWithAsciiL("*", 1);
+		bool bStartWithAsterisk = (aTempFileName.indexOf(::rtl::OUString::createFromAscii("*")) == 0);
+		if ( !bEndWithAsterisk && !bStartWithAsterisk )
+		{
+			aTempFileName = ::rtl::OUString::createFromAscii("*") + aTempFileName + ::rtl::OUString::createFromAscii("*");
+		}
+	}
+	else
+	{
+		aTempFileName = ::rtl::OUString::createFromAscii("*") + aTempFileName + ::rtl::OUString::createFromAscii("*");
+	}
+	WildCard wildCard( aTempFileName );
+	SearchWildCard( wildCard, m_sLookIn, m_bSearchSubFolders, m_aSearchedFiles );
+
+	return m_aSearchedFiles.getLength();
+}
+
+//liuchen 2009-11-5 set ScVbaApplication::getDefaultFilePath(  ) as the InitPath for FileSearch
+ ::rtl::OUString ScVbaFileSearch::getInitPath() throw (css::uno::RuntimeException)
+{
+	String aPath;
+
+	if (m_pApplication != NULL)
+	{
+		aPath = m_pApplication->getDefaultFilePath();
+	}
+
+	return aPath;	
+}
+
+void SAL_CALL ScVbaFileSearch::NewSearch( )  throw (css::uno::RuntimeException)
+{
+	m_sFileName = ::rtl::OUString::createFromAscii( "" );
+	m_sLookIn = getInitPath();
+	m_bSearchSubFolders = false;
+	m_bMatchTextExactly = false;
+	m_aSearchedFiles.realloc(0);
+}
+
+Reference< XFoundFiles > SAL_CALL ScVbaFileSearch::getFoundFiles() throw (css::uno::RuntimeException)
+{
+	css::uno::Reference< ov::XFoundFiles > xFoundFiles = new VbaFoundFiles(
+		mxParent, mxContext, (css::container::XIndexAccess *) new VbaFoundFilesEnum(m_aSearchedFiles) );
+	return xFoundFiles;
+}
+
+rtl::OUString& ScVbaFileSearch::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaFileSearch") );
+	return sImplName;
+}
+
+css::uno::Sequence< rtl::OUString > ScVbaFileSearch::getServiceNames()
+{
+	static css::uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.FileSearch") );
+	}
+	return aServiceNames;
+}
diff --git sc/source/ui/vba/vbafilesearch.hxx sc/source/ui/vba/vbafilesearch.hxx
new file mode 100644
index 0000000..2857ac5
--- /dev/null
+++ sc/source/ui/vba/vbafilesearch.hxx
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_VBA_FILESEARCH_HXX
+#define SC_VBA_FILESEARCH_HXX
+
+#include <ooo/vba/XFileSearch.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+
+namespace css = ::com::sun::star;
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::XFileSearch > ScVbaFileSearchImpl_BASE;
+
+class ScVbaApplication;
+
+class ScVbaFileSearch : public ScVbaFileSearchImpl_BASE
+{
+private:
+    rtl::OUString   m_sFileName;
+    rtl::OUString   m_sLookIn;
+    sal_Bool          m_bSearchSubFolders;
+    sal_Bool          m_bMatchTextExactly;
+    ScVbaApplication* m_pApplication;
+    css::uno::Sequence< rtl::OUString > m_aSearchedFiles;
+
+    ::rtl::OUString getInitPath() throw (css::uno::RuntimeException);
+
+public:
+    ScVbaFileSearch( ScVbaApplication* pApp, const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext );
+    virtual ~ScVbaFileSearch();
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getFileName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFileName(const ::rtl::OUString& _fileName ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getLookIn() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLookIn(const ::rtl::OUString& _lookIn ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getSearchSubFolders() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSearchSubFolders( sal_Bool _searchSubFolders ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getMatchTextExactly() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchTextExactly( sal_Bool _matchTextExactly ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::XFoundFiles > SAL_CALL getFoundFiles() throw (css::uno::RuntimeException);
+
+    virtual sal_Int32 SAL_CALL Execute(  )  throw (css::uno::RuntimeException);
+    virtual void SAL_CALL NewSearch(  )  throw (css::uno::RuntimeException);
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence< rtl::OUString > getServiceNames();
+};
+
+#endif /* SC_VBA_FILESEARCH_HXX */
diff --git sc/source/ui/vba/vbafoundfiles.cxx sc/source/ui/vba/vbafoundfiles.cxx
new file mode 100644
index 0000000..464b533
--- /dev/null
+++ sc/source/ui/vba/vbafoundfiles.cxx
@@ -0,0 +1,143 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbafoundfiles.hxx"
+
+////////////////////////////////VbaFoundFilesEnum//////////////////////////////////////////
+VbaFoundFilesEnum::VbaFoundFilesEnum() : m_nIndex(0)
+{
+
+}
+
+VbaFoundFilesEnum::VbaFoundFilesEnum( css::uno::Sequence<rtl::OUString>& sFileList ) : m_nIndex(0), m_sFileList(sFileList)
+{
+
+}
+
+VbaFoundFilesEnum::~VbaFoundFilesEnum()
+{
+
+}
+
+void VbaFoundFilesEnum::SetFileList( css::uno::Sequence<rtl::OUString>& sFileList )
+{
+    m_nIndex = 0;
+    m_sFileList = sFileList;
+}
+
+sal_Int32 SAL_CALL VbaFoundFilesEnum::getCount() throw (css::uno::RuntimeException)
+{
+    return m_sFileList.getLength();
+}
+
+css::uno::Any SAL_CALL VbaFoundFilesEnum::getByIndex( sal_Int32 nIndex )
+    throw (css::lang::IndexOutOfBoundsException, css::lang::WrappedTargetException, css::uno::RuntimeException)
+{
+    if ( nIndex >= getCount() )
+    {
+        throw css::lang::IndexOutOfBoundsException();
+    }
+
+    return css::uno::makeAny( m_sFileList[nIndex] );
+}
+
+css::uno::Type SAL_CALL VbaFoundFilesEnum::getElementType() throw (css::uno::RuntimeException)
+{
+    return getCppuType((css::uno::Reference< css::container::XIndexAccess >*)0);
+}
+
+sal_Bool SAL_CALL VbaFoundFilesEnum::hasElements() throw (css::uno::RuntimeException)
+{
+    return ( getCount() != 0 );
+}
+
+sal_Bool SAL_CALL VbaFoundFilesEnum::hasMoreElements() throw (css::uno::RuntimeException)
+{
+    if ( getCount() > m_nIndex )
+    {
+        return sal_True;
+    }
+    return sal_False;
+}
+
+css::uno::Any SAL_CALL VbaFoundFilesEnum::nextElement() throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException)
+{
+    if ( !hasMoreElements() )
+    {
+        throw css::container::NoSuchElementException();
+    }
+
+    return css::uno::makeAny( m_sFileList[m_nIndex++] );
+}
+
+////////////////////////////////VbaFoundFiles//////////////////////////////////////////
+VbaFoundFiles::VbaFoundFiles( const css::uno::Reference< ov::XHelperInterface >& xParent,
+    const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+    const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess
+    ) : VbaFoundFilesImpl_BASE( xParent, xContext, xIndexAccess )
+{
+
+}
+
+VbaFoundFiles::~VbaFoundFiles()
+{
+
+}
+
+css::uno::Reference< css::container::XEnumeration > VbaFoundFiles::createEnumeration() throw (css::uno::RuntimeException)
+{
+    css::uno::Reference< css::container::XEnumeration > xEnumRet( m_xIndexAccess, css::uno::UNO_QUERY );
+    return xEnumRet;
+}
+
+css::uno::Any VbaFoundFiles::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+css::uno::Type VbaFoundFiles::getElementType() throw (css::uno::RuntimeException)
+{
+    return ov::XFoundFiles::static_type(0);
+}
+
+rtl::OUString& VbaFoundFiles::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaFoundFiles") );
+    return sImplName;
+}
+
+css::uno::Sequence< rtl::OUString > VbaFoundFiles::getServiceNames()
+{
+    static css::uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.FoundFiles") );
+    }
+    return aServiceNames;
+}
diff --git sc/source/ui/vba/vbafoundfiles.hxx sc/source/ui/vba/vbafoundfiles.hxx
new file mode 100644
index 0000000..4a3a1db
--- /dev/null
+++ sc/source/ui/vba/vbafoundfiles.hxx
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_VBA_FOUNDFILES_HXX
+#define SC_VBA_FOUNDFILES_HXX
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <ooo/vba/XFoundFiles.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+namespace css = ::com::sun::star;
+
+typedef CollTestImplHelper< ooo::vba::XFoundFiles > VbaFoundFilesImpl_BASE;
+
+class VbaFoundFilesEnum : public cppu::WeakImplHelper2< css::container::XIndexAccess, css::container::XEnumeration >
+{
+private:
+    sal_Int32 m_nIndex;
+    css::uno::Sequence< rtl::OUString > m_sFileList;
+
+public:
+    VbaFoundFilesEnum();
+    VbaFoundFilesEnum( css::uno::Sequence< rtl::OUString >& sFileList );
+    ~VbaFoundFilesEnum();
+
+    void SetFileList( css::uno::Sequence< rtl::OUString >& sFileList );
+
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getByIndex( sal_Int32 nIndex ) throw (css::lang::IndexOutOfBoundsException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+
+    // XElementAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+
+    // XEnumeration
+    virtual sal_Bool SAL_CALL hasMoreElements() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL nextElement() throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+};
+
+class VbaFoundFiles : public VbaFoundFilesImpl_BASE
+{
+private:
+
+public:
+    VbaFoundFiles( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+        const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+        const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+    virtual ~VbaFoundFiles();
+
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);	
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence< rtl::OUString > getServiceNames();
+};
+
+#endif /* SC_VBA_FOUNDFILES_HXX */
diff --git sc/source/ui/vba/vbaglobals.cxx sc/source/ui/vba/vbaglobals.cxx
index d937784..2cd8b79 100644
--- sc/source/ui/vba/vbaglobals.cxx
+++ sc/source/ui/vba/vbaglobals.cxx
@@ -219,6 +219,12 @@ ScVbaGlobals::Rows( const uno::Any& aIndex ) throw (uno::RuntimeException)
     return uno::Any();
 }
 
+uno::Any SAL_CALL 
+ScVbaGlobals::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return uno::Any( getApplication()->MenuBars(aIndex) );
+}
+
 uno::Sequence< ::rtl::OUString > SAL_CALL 
 ScVbaGlobals::getAvailableServiceNames(  ) throw (uno::RuntimeException)
 {
diff --git sc/source/ui/vba/vbaglobals.hxx sc/source/ui/vba/vbaglobals.hxx
index 38a51f2..f06acb4 100644
--- sc/source/ui/vba/vbaglobals.hxx
+++ sc/source/ui/vba/vbaglobals.hxx
@@ -83,6 +83,7 @@ typedef ::cppu::ImplInheritanceHelper1< VbaGlobalsBase, ov::excel::XGlobals > Sc
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XApplication > SAL_CALL getExcel() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getDebug() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
 
     // XMultiServiceFactory
diff --git sc/source/ui/vba/vbahelper.cxx sc/source/ui/vba/vbahelper.cxx
deleted file mode 100644
index 1248b4c..0000000
--- sc/source/ui/vba/vbahelper.cxx
+++ /dev/null
@@ -1,758 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <cppuhelper/bootstrap.hxx>
-#include <com/sun/star/util/XURLTransformer.hpp>
-#include <com/sun/star/frame/XDispatchProvider.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-#include <com/sun/star/frame/XFrame.hpp>
-#include <com/sun/star/frame/XDesktop.hpp>
-#include <com/sun/star/frame/XController.hpp>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/lang/XMultiComponentFactory.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/beans/XIntrospection.hpp>
-
-#include <comphelper/processfactory.hxx>
-
-#include <sfx2/objsh.hxx>
-#include <sfx2/viewfrm.hxx>
-#include <sfx2/dispatch.hxx>
-#include <sfx2/app.hxx>
-#include <svl/stritem.hxx>
-
-#include <docuno.hxx>
-
-#include <basic/sbx.hxx>
-#include <basic/sbstar.hxx>
-#include <rtl/math.hxx>
-
-#include <math.h>
-#include "vbahelper.hxx"
-#include "tabvwsh.hxx"
-#include "transobj.hxx"
-#include "scmod.hxx"
-#include "vbashape.hxx"
-#include "unonames.hxx"
-#include "cellsuno.hxx"
-using namespace ::com::sun::star;
-using namespace ::ooo::vba;
-
-#define POINTTO100THMILLIMETERFACTOR 35.27778
-void unoToSbxValue( SbxVariable* pVar, const uno::Any& aValue );
-
-uno::Any sbxToUnoValue( SbxVariable* pVar );
-
-
-namespace ooo
-{
-namespace vba
-{
-
-const double Millimeter::factor =  35.27778;
-
-uno::Reference< beans::XIntrospectionAccess >
-getIntrospectionAccess( const uno::Any& aObject ) throw (uno::RuntimeException)
-{
-    static uno::Reference< beans::XIntrospection > xIntrospection;
-    if( !xIntrospection.is() )
-    {
-        uno::Reference< lang::XMultiServiceFactory > xFactory( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-        xIntrospection.set( xFactory->createInstance( rtl::OUString::createFromAscii("com.sun.star.beans.Introspection") ), uno::UNO_QUERY_THROW );
-    }
-    return xIntrospection->inspect( aObject );
-}
-
-uno::Reference< script::XTypeConverter >
-getTypeConverter( const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
-{
-    static uno::Reference< script::XTypeConverter > xTypeConv( xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), xContext ), uno::UNO_QUERY_THROW );
-    return xTypeConv;
-}
-// helper method to determine if the view ( calc ) is in print-preview mode
-bool isInPrintPreview( SfxViewFrame* pView )
-{
-    sal_uInt16 nViewNo = SID_VIEWSHELL1 - SID_VIEWSHELL0;
-    if ( pView->GetObjectShell()->GetFactory().GetViewFactoryCount() >
-nViewNo && !pView->GetObjectShell()->IsInPlaceActive() )
-    {
-        SfxViewFactory &rViewFactory =
-            pView->GetObjectShell()->GetFactory().GetViewFactory(nViewNo);
-        if (  pView->GetCurViewId() == rViewFactory.GetOrdinal() )
-            return true;
-    }
-    return false;
-}
-const ::rtl::OUString REPLACE_CELLS_WARNING(  RTL_CONSTASCII_USTRINGPARAM( "ReplaceCellsWarning"));
-const uno::Any&
-aNULL()
-{
-     static  uno::Any aNULLL = uno::makeAny( uno::Reference< uno::XInterface >() );
-    return aNULLL;
-}
-
-class PasteCellsWarningReseter
-{
-private:
-    bool bInitialWarningState;
-    static uno::Reference< beans::XPropertySet > getGlobalSheetSettings() throw ( uno::RuntimeException )
-    {
-        static uno::Reference< beans::XPropertySet > xTmpProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-        static uno::Reference<uno::XComponentContext > xContext( xTmpProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-        static uno::Reference<lang::XMultiComponentFactory > xServiceManager(
-                xContext->getServiceManager(), uno::UNO_QUERY_THROW );
-        static uno::Reference< beans::XPropertySet > xProps( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sheet.GlobalSheetSettings" ) ) ,xContext ), uno::UNO_QUERY_THROW );
-        return xProps;
-    }
-
-    bool getReplaceCellsWarning() throw ( uno::RuntimeException )
-    {
-        sal_Bool res = sal_False;
-        getGlobalSheetSettings()->getPropertyValue( REPLACE_CELLS_WARNING ) >>= res;
-        return ( res == sal_True );
-    }
-
-    void setReplaceCellsWarning( bool bState ) throw ( uno::RuntimeException )
-    {
-        getGlobalSheetSettings()->setPropertyValue( REPLACE_CELLS_WARNING, uno::makeAny( bState ) );
-    }
-public:
-    PasteCellsWarningReseter() throw ( uno::RuntimeException )
-    {
-        bInitialWarningState = getReplaceCellsWarning();
-        if ( bInitialWarningState )
-            setReplaceCellsWarning( false );
-    }
-    ~PasteCellsWarningReseter()
-    {
-        if ( bInitialWarningState )
-        {
-            // don't allow dtor to throw
-            try
-            {
-                setReplaceCellsWarning( true );
-            }
-            catch ( uno::Exception& /*e*/ ){}
-        }
-    }
-};
-
-void dispatchExecute(css::uno::Reference< css::frame::XModel>& xModel, USHORT nSlot, SfxCallMode nCall)
-{
-    ScTabViewShell* pViewShell = getBestViewShell( xModel );
-    SfxViewFrame* pViewFrame = NULL;
-    if ( pViewShell )
-        pViewFrame = pViewShell->GetViewFrame();
-    if ( pViewFrame )
-    {
-        SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
-        if( pDispatcher )
-        {
-            pDispatcher->Execute( nSlot , nCall );
-        }
-    }	
-}
-        
-void
-implnPaste()
-{
-    PasteCellsWarningReseter resetWarningBox;
-    ScTabViewShell* pViewShell = getCurrentBestViewShell();
-    if ( pViewShell )
-    {
-        pViewShell->PasteFromSystem();
-        pViewShell->CellContentChanged();
-    }
-}
-
-
-void
-implnCopy()
-{
-    ScTabViewShell* pViewShell = getCurrentBestViewShell();
-    if ( pViewShell )
-        pViewShell->CopyToClip(NULL,false,false,true);
-}
-
-void 
-implnCut()
-{
-    ScTabViewShell* pViewShell =  getCurrentBestViewShell();
-    if ( pViewShell )
-        pViewShell->CutToClip( NULL, TRUE );
-}
-
-void implnPasteSpecial(USHORT nFlags,USHORT nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose)
-{
-    PasteCellsWarningReseter resetWarningBox;
-    sal_Bool bAsLink(sal_False), bOtherDoc(sal_False);
-    InsCellCmd eMoveMode = INS_NONE;
-
-    ScTabViewShell* pTabViewShell = ScTabViewShell::GetActiveViewShell();
-    if ( !pTabViewShell ) 
-        // none active, try next best
-        pTabViewShell = getCurrentBestViewShell();
-    if ( pTabViewShell )
-    {
-        ScViewData* pView = pTabViewShell->GetViewData();	
-        Window* pWin = ( pView != NULL ) ? pView->GetActiveWin() : NULL;
-        if ( pView && pWin )
-        {
-            if ( bAsLink && bOtherDoc )
-                pTabViewShell->PasteFromSystem(0);//SOT_FORMATSTR_ID_LINK
-            else 
-            {
-                ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( pWin );
-                ScDocument* pDoc = NULL; 
-                if ( pOwnClip )
-                    pDoc = pOwnClip->GetDocument();	
-                pTabViewShell->PasteFromClip( nFlags, pDoc,
-                    nFunction, bSkipEmpty, bTranspose, bAsLink,
-                    eMoveMode, IDF_NONE, TRUE );
-                pTabViewShell->CellContentChanged();
-            }
-        }
-    }
-
-}
-
- uno::Reference< frame::XModel > 
-getCurrentDocument() throw (uno::RuntimeException)
-{
-    uno::Reference< frame::XModel > xModel;
-    SbxObject* pBasic = dynamic_cast< SbxObject* > ( SFX_APP()->GetBasic() );
-    SbxObject* basicChosen =  pBasic ;
-    if ( basicChosen == NULL)
-    {
-        OSL_TRACE("getModelFromBasic() StarBASIC* is NULL" );
-        return xModel;
-    }    
-    SbxObject* p = pBasic;
-    SbxObject* pParent = p->GetParent();
-    SbxObject* pParentParent = pParent ? pParent->GetParent() : NULL;
-
-    if( pParentParent )
-    {
-        basicChosen = pParentParent;
-    }
-    else if( pParent )
-    {
-        basicChosen = pParent;
-    }
-
-
-    uno::Any aModel; 
-    SbxVariable *pCompVar = basicChosen->Find(  UniString(RTL_CONSTASCII_USTRINGPARAM("ThisComponent")), SbxCLASS_OBJECT );
-
-    if ( pCompVar )
-    {
-        aModel = sbxToUnoValue( pCompVar );
-        if ( sal_False == ( aModel >>= xModel ) ||
-            !xModel.is() )
-        {
-            // trying last gasp try the current component
-            uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-            // test if vba service is present
-            uno::Reference< uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-            uno::Reference<lang::XMultiComponentFactory > xSMgr( xCtx->getServiceManager(), uno::UNO_QUERY_THROW );
-            uno::Reference< frame::XDesktop > xDesktop (xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), xCtx), uno::UNO_QUERY_THROW );
-            xModel.set( xDesktop->getCurrentComponent(), uno::UNO_QUERY );
-            if ( !xModel.is() )
-            {
-                throw uno::RuntimeException( 
-                    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't extract model from basic ( its obviously not set yet ) therefore don't know the currently selected document") ), uno::Reference< uno::XInterface >() );
-            }
-            return xModel;
-        }
-        else
-        {
-            OSL_TRACE("Have model ThisComponent points to url %s",
-            ::rtl::OUStringToOString( xModel->getURL(),
-                RTL_TEXTENCODING_ASCII_US ).pData->buffer );
-        }
-    }
-    else
-    {
-        OSL_TRACE("Failed to get ThisComponent");
-        throw uno::RuntimeException( 
-            rtl::OUString( 
-                RTL_CONSTASCII_USTRINGPARAM(
-                    "Can't determine the currently selected document") ),
-            uno::Reference< uno::XInterface >() );
-    }
-    return xModel;
-}
-
-ScDocShell* 
-getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) 
-{
-    uno::Reference< uno::XInterface > xIf( xModel, uno::UNO_QUERY_THROW );
-    ScModelObj* pModel = dynamic_cast< ScModelObj* >( xIf.get() );
-    ScDocShell* pDocShell = NULL;
-    if ( pModel )
-        pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
-    return pDocShell;
-
-}
-
-ScTabViewShell* 
-getBestViewShell(  css::uno::Reference< css::frame::XModel>& xModel )
-{
-    ScDocShell* pDocShell = getDocShell( xModel );
-    if ( pDocShell )
-        return pDocShell->GetBestViewShell();
-    return NULL;
-}
-
-ScTabViewShell* 
-getCurrentBestViewShell()
-{ 
-    uno::Reference< frame::XModel > xModel = getCurrentDocument();
-    return getBestViewShell( xModel );
-}
-
-SfxViewFrame* 
-getCurrentViewFrame()
-{
-    ScTabViewShell* pViewShell = getCurrentBestViewShell();	
-    if ( pViewShell )
-        return pViewShell->GetViewFrame();
-    return NULL;
-}
-
-sal_Int32 
-OORGBToXLRGB( sal_Int32 nCol )
-{
-    sal_Int32 nRed = nCol;
-    nRed &= 0x00FF0000;
-    nRed >>= 16;
-    sal_Int32 nGreen = nCol;
-    nGreen &= 0x0000FF00;
-    nGreen >>= 8;
-    sal_Int32 nBlue = nCol;
-    nBlue &= 0x000000FF;
-    sal_Int32 nRGB =  ( (nBlue << 16) | (nGreen << 8) | nRed );
-    return nRGB;
-}
-sal_Int32 
-XLRGBToOORGB( sal_Int32 nCol )
-{
-    sal_Int32 nBlue = nCol;
-    nBlue &= 0x00FF0000;
-    nBlue >>= 16;
-    sal_Int32 nGreen = nCol;
-    nGreen &= 0x0000FF00;
-    nGreen >>= 8;
-    sal_Int32 nRed = nCol;
-    nRed &= 0x000000FF;
-    sal_Int32 nRGB =  ( (nRed << 16) | (nGreen << 8) | nBlue );
-    return nRGB;
-}
-uno::Any 
-OORGBToXLRGB( const uno::Any& aCol )
-{
-    sal_Int32 nCol=0;
-    aCol >>= nCol;
-    nCol = OORGBToXLRGB( nCol );
-    return uno::makeAny( nCol );
-}
-uno::Any 
-XLRGBToOORGB(  const uno::Any& aCol )
-{
-    sal_Int32 nCol=0;
-    aCol >>= nCol;
-    nCol = XLRGBToOORGB( nCol );
-    return uno::makeAny( nCol );
-}
-
-void PrintOutHelper( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& /*ActivePrinter*/, const uno::Any& /*PrintToFile*/, const uno::Any& Collate, const uno::Any& PrToFileName, css::uno::Reference< frame::XModel >& xModel, sal_Bool bUseSelection  )
-{
-    sal_Int32 nTo = 0;
-    sal_Int32 nFrom = 0;
-    sal_Int16 nCopies = 1;
-    sal_Bool bPreview = sal_False;
-    sal_Bool bCollate = sal_False;
-    sal_Bool bSelection = bUseSelection;
-    From >>= nFrom;
-    To >>= nTo;
-    Copies >>= nCopies;
-    Preview >>= bPreview;
-    if ( nCopies > 1 ) // Collate only useful when more that 1 copy
-        Collate >>= bCollate;
-
-    rtl::OUString sRange(  RTL_CONSTASCII_USTRINGPARAM( "-" ) );
-    rtl::OUString sFileName;
-    
-    if (( nFrom || nTo ) )
-    {
-        if ( nFrom )
-            sRange = ( ::rtl::OUString::valueOf( nFrom ) + sRange );
-        if ( nTo )
-            sRange += ::rtl::OUString::valueOf( nTo );
-    }
-
-    if (  PrToFileName.getValue() )
-    {
-        PrToFileName >>= sFileName;
-    }
-    ScTabViewShell* pViewShell = getBestViewShell( xModel );
-    SfxViewFrame* pViewFrame = NULL;
-    if ( pViewShell )
-        pViewFrame = pViewShell->GetViewFrame();
-    if ( pViewFrame )
-    {
-        SfxAllItemSet aArgs( SFX_APP()->GetPool() );
-                
-        SfxBoolItem sfxCollate( SID_PRINT_COLLATE, bCollate );
-        aArgs.Put( sfxCollate, sfxCollate.Which() );
-        SfxInt16Item sfxCopies( SID_PRINT_COPIES, nCopies );
-        aArgs.Put( sfxCopies, sfxCopies.Which() );
-        if ( sFileName.getLength() )
-        {
-            SfxStringItem sfxFileName( SID_FILE_NAME, sFileName);
-            aArgs.Put( sfxFileName, sfxFileName.Which() );
-        
-        }
-        if (  sRange.getLength() )
-        {
-            SfxStringItem sfxRange( SID_PRINT_PAGES, sRange );
-            aArgs.Put( sfxRange, sfxRange.Which() );
-        }
-        SfxBoolItem sfxSelection( SID_SELECTION, bSelection );
-        aArgs.Put( sfxSelection, sfxSelection.Which() );
-        SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
-        aArgs.Put( sfxAsync, sfxAsync.Which() );
-        SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
-
-        if ( pDispatcher )
-        {
-            if ( bPreview )
-            {
-                if ( !pViewFrame->GetFrame().IsInPlace() ) 	
-                {
-                    SC_MOD()->InputEnterHandler();
-                    pViewFrame->GetDispatcher()->Execute( SID_VIEWSHELL1, SFX_CALLMODE_SYNCHRON );
-                    while ( isInPrintPreview( pViewFrame ) )
-                        Application::Yield();
-                }
-            }
-            else
-                pDispatcher->Execute( (USHORT)SID_PRINTDOC, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
-        }
-            
-    }
-    
-    // #FIXME #TODO
-    // 1 ActivePrinter ( how/can we switch a printer via API? )
-    // 2 PrintToFile ( ms behaviour if this option is specified but no 
-    //   filename supplied 'PrToFileName' then the user will be prompted )
-    // 3 Need to check behaviour of Selected sheets with range ( e.g. From & To
-    //    values ) in oOO these options are mutually exclusive
-    // 4 There is a pop up to do with transparent objects in the print source
-    //   should be able to disable that via configuration for the duration
-    //   of this method
-}
-
- void PrintPreviewHelper( const css::uno::Any& /*EnableChanges*/, css::uno::Reference< css::frame::XModel >& xModel )
-{
-    dispatchExecute( xModel, SID_VIEWSHELL1 );
-}
-
-rtl::OUString getAnyAsString( const uno::Any& pvargItem ) throw ( uno::RuntimeException )
-{
-    uno::Type aType = pvargItem.getValueType();
-    uno::TypeClass eTypeClass = aType.getTypeClass();
-    rtl::OUString sString;
-    switch ( eTypeClass )
-    {
-        case uno::TypeClass_BOOLEAN:
-        {
-            sal_Bool bBool = sal_False;
-            pvargItem >>= bBool;
-            sString = rtl::OUString::valueOf( bBool );
-            break;
-        }
-        case uno::TypeClass_STRING:
-            pvargItem >>= sString;
-            break;
-        case uno::TypeClass_FLOAT:
-            {
-                float aFloat = 0;
-                pvargItem >>= aFloat;
-                sString = rtl::OUString::valueOf( aFloat );
-                break;
-            }
-        case uno::TypeClass_DOUBLE:
-            {
-                double aDouble = 0;
-                pvargItem >>= aDouble;
-                sString = rtl::OUString::valueOf( aDouble );
-                break;
-            }
-        case uno::TypeClass_SHORT:
-        case uno::TypeClass_LONG:
-        case uno::TypeClass_BYTE:
-            {
-                sal_Int32 aNum = 0;
-                pvargItem >>= aNum;
-                sString = rtl::OUString::valueOf( aNum );
-                break;
-            }
-
-        case uno::TypeClass_HYPER:
-            {
-                sal_Int64 aHyper = 0;
-                pvargItem >>= aHyper;
-                sString = rtl::OUString::valueOf( aHyper );
-                break;
-            }
-        default:
-                   throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid type, can't convert" ), uno::Reference< uno::XInterface >() );
-    }
-    return sString;
-}
-
-
-rtl::OUString 
-ContainerUtilities::getUniqueName( const uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator)
-{
-    return getUniqueName(_slist, _sElementName, _sSuffixSeparator, sal_Int32(2));
-}
-
-rtl::OUString 
-ContainerUtilities::getUniqueName( const uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix)
-{
-    sal_Int32 a = _nStartSuffix;
-    rtl::OUString scompname = _sElementName;
-    bool bElementexists = true;
-    sal_Int32 nLen = _slist.getLength();
-    if ( nLen == 0 )
-        return _sElementName;
-
-    while (bElementexists == true) 
-    {
-        for (sal_Int32 i = 0; i < nLen; i++)
-        {
-            if (FieldInList(_slist, scompname) == -1)
-            {
-                return scompname;
-            }
-        }
-        scompname = _sElementName + _sSuffixSeparator + rtl::OUString::valueOf( a++ );
-    }
-    return rtl::OUString();
-}
-
-sal_Int32 
-ContainerUtilities::FieldInList( const uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString )
-{
-    sal_Int32 FieldLen = SearchList.getLength();
-    sal_Int32 retvalue = -1;
-    for (sal_Int32 i = 0; i < FieldLen; i++) 
-    {
-        // I wonder why comparing lexicographically is done
-        // when its a match is whats interesting?
-        //if (SearchList[i].compareTo(SearchString) == 0) 
-        if ( SearchList[i].equals( SearchString ) ) 
-        {
-            retvalue = i;
-            break;
-        }
-    }
-    return retvalue;
-
-}
-bool NeedEsc(sal_Unicode cCode)
-{
-    String sEsc(RTL_CONSTASCII_USTRINGPARAM(".^$+\\|{}()"));
-    return (STRING_NOTFOUND != sEsc.Search(cCode));
-}
-
-rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike )
-{
-    rtl::OUStringBuffer sResult;
-    const sal_Unicode *start = rIn.getStr();
-    const sal_Unicode *end = start + rIn.getLength();
-
-    int seenright = 0;
-    if ( bForLike )
-        sResult.append(static_cast<sal_Unicode>('^'));
-
-    while (start < end) 
-    {
-        switch (*start)
-        {
-            case '?':
-                sResult.append(static_cast<sal_Unicode>('.'));
-                start++;
-                break;
-            case '*':
-                sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(".*")));
-                start++;
-                break;
-            case '#':
-                sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[0-9]")));
-                start++;
-                break;
-            case '~':
-                sResult.append(static_cast<sal_Unicode>('\\'));
-                sResult.append(*(++start));
-                start++;
-                break;
-                // dump the ~ and escape the next characture
-            case ']':
-                sResult.append(static_cast<sal_Unicode>('\\'));
-                sResult.append(*start++);
-                break;
-            case '[':
-                sResult.append(*start++);
-                seenright = 0;
-                while (start < end && !seenright)
-                {
-                    switch (*start)
-                    {
-                        case '[':
-                        case '?':
-                        case '*':
-                        sResult.append(static_cast<sal_Unicode>('\\'));
-                        sResult.append(*start);
-                            break;
-                        case ']':
-                        sResult.append(*start);
-                            seenright = 1;
-                            break;
-                        case '!':
-                            sResult.append(static_cast<sal_Unicode>('^'));
-                            break;
-                        default:
-                        if (NeedEsc(*start))
-                            sResult.append(static_cast<sal_Unicode>('\\'));
-                        sResult.append(*start);
-                            break;
-                    }
-                    start++;
-                }
-                break;
-            default:
-                if (NeedEsc(*start))
-                    sResult.append(static_cast<sal_Unicode>('\\'));
-                sResult.append(*start++);
-        }
-    }
-
-    if ( bForLike )
-        sResult.append(static_cast<sal_Unicode>('$'));
-
-    return sResult.makeStringAndClear( );
-}
-
-double getPixelTo100thMillimeterConversionFactor( css::uno::Reference< css::awt::XDevice >& xDevice, sal_Bool bVertical)
-{
-    double fConvertFactor = 1.0;
-    if( bVertical )
-    {
-        fConvertFactor = xDevice->getInfo().PixelPerMeterY/100000;
-    }
-    else
-    {
-        fConvertFactor = xDevice->getInfo().PixelPerMeterX/100000;	
-    }
-    return fConvertFactor;
-}
-
-double PointsToPixels( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical)
-{
-    double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
-    return fPoints * POINTTO100THMILLIMETERFACTOR * fConvertFactor;
-}
-double PixelsToPoints( css::uno::Reference< css::awt::XDevice >& xDevice, double fPixels, sal_Bool bVertical)
-{
-    double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
-    return (fPixels/fConvertFactor)/POINTTO100THMILLIMETERFACTOR;
-}
-
-ConcreteXShapeGeometryAttributes::ConcreteXShapeGeometryAttributes( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape )
-{
-    m_xShape = new ScVbaShape( xContext, xShape );
-}
-
-#define VBA_LEFT "PositionX"
-#define VBA_TOP "PositionY"
-UserFormGeometryHelper::UserFormGeometryHelper( const uno::Reference< uno::XComponentContext >& /*xContext*/, const uno::Reference< awt::XControl >& xControl )
-{
-    mxModel.set( xControl->getModel(), uno::UNO_QUERY_THROW );
-}
-    double UserFormGeometryHelper::getLeft()
-    {
-    sal_Int32 nLeft = 0;
-    mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ) ) >>= nLeft;	
-    return Millimeter::getInPoints( nLeft );
-    }
-    void UserFormGeometryHelper::setLeft( double nLeft )
-    {
-        mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nLeft ) ) );
-    }
-    double UserFormGeometryHelper::getTop()
-    {
-    sal_Int32 nTop = 0;
-    mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	VBA_TOP ) ) ) >>= nTop;	
-    return Millimeter::getInPoints( nTop );
-    }
-    void UserFormGeometryHelper::setTop( double nTop )
-    {
-    mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	VBA_TOP ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nTop ) ) );
-    }
-    double UserFormGeometryHelper::getHeight()
-    {
-    sal_Int32 nHeight = 0;
-    mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLHGT ) ) ) >>= nHeight;	
-    return Millimeter::getInPoints( nHeight );
-    }
-    void UserFormGeometryHelper::setHeight( double nHeight )
-    {
-    mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLHGT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nHeight ) ) );
-    }
-    double UserFormGeometryHelper::getWidth()
-    {
-    sal_Int32 nWidth = 0;
-    mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLWID ) ) ) >>= nWidth;	
-    return Millimeter::getInPoints( nWidth );
-    }
-    void UserFormGeometryHelper::setWidth( double nWidth)
-    {
-    mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLWID ) ), uno::makeAny(  Millimeter::getInHundredthsOfOneMillimeter( nWidth ) ) );
-    }
-
-SfxItemSet*
-ScVbaCellRangeAccess::GetDataSet( ScCellRangeObj* pRangeObj )
-{
-    SfxItemSet* pDataSet = pRangeObj ? pRangeObj->GetCurrentDataSet( true ) : NULL ;
-    return pDataSet;
-    
-}
-
-} // vba
-} // ooo
diff --git sc/source/ui/vba/vbamenu.cxx sc/source/ui/vba/vbamenu.cxx
new file mode 100644
index 0000000..58972b0
--- /dev/null
+++ sc/source/ui/vba/vbamenu.cxx
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenu.hxx" 
+#include "vbamenuitems.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenu::ScVbaMenu( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : Menu_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenu::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenu::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+void SAL_CALL
+ScVbaMenu::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+uno::Any SAL_CALL 
+ScVbaMenu::MenuItems( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBarControl->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenuItems > xMenuItems( new ScVbaMenuItems( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenuItems->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenuItems );
+}
+
+rtl::OUString& 
+ScVbaMenu::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenu") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenu::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menu" ) );
+	}
+	return aServiceNames;
+}
diff --git sc/source/ui/vba/vbamenu.hxx sc/source/ui/vba/vbamenu.hxx
new file mode 100644
index 0000000..cd96857
--- /dev/null
+++ sc/source/ui/vba/vbamenu.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENU_HXX
+#define SC_VBA_MENU_HXX
+
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenu > Menu_BASE;
+
+class ScVbaMenu : public Menu_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenu( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL MenuItems( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENU_HXX
diff --git sc/source/ui/vba/vbamenubar.cxx sc/source/ui/vba/vbamenubar.cxx
new file mode 100644
index 0000000..9386028
--- /dev/null
+++ sc/source/ui/vba/vbamenubar.cxx
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubar.hxx" 
+#include "vbamenus.hxx"
+#include <ooo/vba/XCommandBarControls.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuBar::ScVbaMenuBar( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBar >& xCommandBar ) throw( uno::RuntimeException ) : MenuBar_BASE( xParent, xContext ), m_xCommandBar( xCommandBar )
+{
+}
+
+uno::Any SAL_CALL 
+ScVbaMenuBar::Menus( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBar->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenus > xMenus( new ScVbaMenus( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenus->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenus );
+}
+
+rtl::OUString& 
+ScVbaMenuBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBar") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBar" ) );
+	}
+	return aServiceNames;
+}
diff --git sc/source/ui/vba/vbamenubar.hxx sc/source/ui/vba/vbamenubar.hxx
new file mode 100644
index 0000000..fa39054
--- /dev/null
+++ sc/source/ui/vba/vbamenubar.hxx
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBAR_HXX
+#define SC_VBA_MENUBAR_HXX
+
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBar.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuBar > MenuBar_BASE;
+
+class ScVbaMenuBar : public MenuBar_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBar > m_xCommandBar;
+
+public:
+    ScVbaMenuBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBar >& xCommandBar ) throw( css::uno::RuntimeException );
+    
+    virtual css::uno::Any SAL_CALL Menus( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUBAR_HXX
diff --git sc/source/ui/vba/vbamenubars.cxx sc/source/ui/vba/vbamenubars.cxx
new file mode 100644
index 0000000..a5f9e9b
--- /dev/null
+++ sc/source/ui/vba/vbamenubars.cxx
@@ -0,0 +1,146 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubars.hxx"
+#include "vbamenubar.hxx"
+#include <ooo/vba/excel/XlSheetType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuBarEnumeration_BASE;
+
+class MenuBarEnumeration : public MenuBarEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuBarEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menubar
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBar > xCommandBar( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( m_xParent, m_xContext, xCommandBar ) );
+            return uno::makeAny( xMenuBar );
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuBars::ScVbaMenuBars( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBars >& xCommandBars ) throw ( uno::RuntimeException ) : MenuBars_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBars( xCommandBars )
+{
+}
+
+ScVbaMenuBars::~ScVbaMenuBars()
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuBars::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuBar::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuBars::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBars, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuBarEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuBars::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuBars::getCount() throw(css::uno::RuntimeException)
+{
+    return m_xCommandBars->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuBars::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    sal_Int16 nIndex = 0;
+    aIndex >>= nIndex;
+    if( nIndex == excel::XlSheetType::xlWorksheet )
+    {
+        uno::Any aSource;
+        aSource <<= rtl::OUString::createFromAscii( "Worksheet Menu Bar" );
+        uno::Reference< XCommandBar > xCommandBar( m_xCommandBars->Item( aSource, uno::Any() ), uno::UNO_QUERY_THROW );
+        uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( this, mxContext, xCommandBar ) );
+        return uno::makeAny( xMenuBar );
+    }
+
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    
+    return uno::Any();
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuBars::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBars") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBars::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBars" ) );
+    }
+    return aServiceNames;
+}
+
diff --git sc/source/ui/vba/vbamenubars.hxx sc/source/ui/vba/vbamenubars.hxx
new file mode 100644
index 0000000..0d8ea58
--- /dev/null
+++ sc/source/ui/vba/vbamenubars.hxx
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBARS_HXX
+#define SC_VBA_MENUBARS_HXX
+
+#include <ooo/vba/excel/XMenuBars.hpp>
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBars.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuBars > MenuBars_BASE;
+
+class ScVbaMenuBars : public MenuBars_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBars > m_xCommandBars;
+
+public:
+    ScVbaMenuBars( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBars >& xCommandBars ) throw (css::uno::RuntimeException);
+    virtual ~ScVbaMenuBars();
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& aIndex, const css::uno::Any& /*aIndex2*/ ) throw( css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUBARS_HXX
diff --git sc/source/ui/vba/vbamenuitem.cxx sc/source/ui/vba/vbamenuitem.cxx
new file mode 100644
index 0000000..48254cc
--- /dev/null
+++ sc/source/ui/vba/vbamenuitem.cxx
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitem.hxx" 
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuItem::ScVbaMenuItem( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : MenuItem_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getOnAction() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getOnAction();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setOnAction( const ::rtl::OUString& _onaction ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setOnAction( _onaction );
+}
+
+void SAL_CALL
+ScVbaMenuItem::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+rtl::OUString& 
+ScVbaMenuItem::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItem") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItem::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItem" ) );
+	}
+	return aServiceNames;
+}
diff --git sc/source/ui/vba/vbamenuitem.hxx sc/source/ui/vba/vbamenuitem.hxx
new file mode 100644
index 0000000..bf4c087
--- /dev/null
+++ sc/source/ui/vba/vbamenuitem.hxx
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEM_HXX
+#define SC_VBA_MENUITEM_HXX
+
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuItem > MenuItem_BASE;
+
+class ScVbaMenuItem : public MenuItem_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenuItem( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getOnAction() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setOnAction( const ::rtl::OUString& _onaction ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUITEM_HXX
diff --git sc/source/ui/vba/vbamenuitems.cxx sc/source/ui/vba/vbamenuitems.cxx
new file mode 100644
index 0000000..3a5cd79
--- /dev/null
+++ sc/source/ui/vba/vbamenuitems.cxx
@@ -0,0 +1,159 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitems.hxx"
+#include "vbamenuitem.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+            {
+                uno::Reference< excel::XMenuItem > xMenuItem( new ScVbaMenuItem( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenuItem );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuItems::ScVbaMenuItems( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : MenuItems_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuItems::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuItem::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuItems::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuItems::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuItems::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuItems::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+        return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+    else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+        return uno::makeAny( uno::Reference< excel::XMenuItem > ( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) ) );
+    throw uno::RuntimeException();    
+}
+
+uno::Reference< excel::XMenuItem > SAL_CALL ScVbaMenuItems::Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& /*ShortcutKey*/, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& /*StatusBar*/, const css::uno::Any& /*HelpFile*/, const css::uno::Any& /*HelpContextID*/ ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlButton;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    if( OnAction.hasValue() )
+    {
+        rtl::OUString sAction;
+        OnAction >>= sAction;
+        xCommandBarControl->setOnAction( sAction );
+    }
+    return uno::Reference< excel::XMenuItem >( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuItems::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItems") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItems::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItems" ) );
+    }
+    return aServiceNames;
+}
+
diff --git sc/source/ui/vba/vbamenuitems.hxx sc/source/ui/vba/vbamenuitems.hxx
new file mode 100644
index 0000000..8aeb931
--- /dev/null
+++ sc/source/ui/vba/vbamenuitems.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEMS_HXX
+#define SC_VBA_MENUITEMS_HXX
+
+#include <ooo/vba/excel/XMenuItems.hpp>
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuItems > MenuItems_BASE;
+
+class ScVbaMenuItems : public MenuItems_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenuItems( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenuItem > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& ShortcutKey, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& StatusBar, const css::uno::Any& HelpFile, const css::uno::Any& HelpContextID ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUITEMS_HXX
diff --git sc/source/ui/vba/vbamenus.cxx sc/source/ui/vba/vbamenus.cxx
new file mode 100644
index 0000000..7d5a21b
--- /dev/null
+++ sc/source/ui/vba/vbamenus.cxx
@@ -0,0 +1,145 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenus.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenus::ScVbaMenus( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : Menus_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenus::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenu::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenus::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenus::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenus::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenus::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() != office::MsoControlType::msoControlPopup )
+        throw uno::RuntimeException();
+    return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+}
+
+uno::Reference< excel::XMenu > SAL_CALL ScVbaMenus::Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlPopup;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    return uno::Reference< excel::XMenu >( new ScVbaMenu( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenus::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenus") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenus::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menus" ) );
+    }
+    return aServiceNames;
+}
+
diff --git sc/source/ui/vba/vbamenus.hxx sc/source/ui/vba/vbamenus.hxx
new file mode 100644
index 0000000..596127e
--- /dev/null
+++ sc/source/ui/vba/vbamenus.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUS_HXX
+#define SC_VBA_MENUS_HXX
+
+#include <ooo/vba/excel/XMenus.hpp>
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenus > Menus_BASE;
+
+class ScVbaMenus : public Menus_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenus( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenu > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUS_HXX
diff --git sc/source/ui/vba/vbaname.cxx sc/source/ui/vba/vbaname.cxx
index 66381c1..b5238cf 100644
--- sc/source/ui/vba/vbaname.cxx
+++ sc/source/ui/vba/vbaname.cxx
@@ -69,8 +69,8 @@ ScVbaName::getWorkSheet() throw (css::uno::RuntimeException)
 ScVbaName::getName() throw (css::uno::RuntimeException)
 {
     String sName;
-    sName += UniString( getWorkSheet()->getName());
-    sName += String::CreateFromAscii("!");
+	//sName += UniString( getWorkSheet()->getName()); //liuchen 2009-9-9 resolve the defect that the name get by macro code are not the same with that in UI (for example, if a name of "AA" is found in the UI "Define Names" dialog box, the result of get that name through macro code will be "Sheet1!AA")
+	//sName += String::CreateFromAscii("!");
     sName += UniString ( mxNamedRange->getName() );
     return ::rtl::OUString( sName );
 }
diff --git sc/source/ui/vba/vbapagebreaks.cxx sc/source/ui/vba/vbapagebreaks.cxx
index ebb5a0d..6103296 100644
--- sc/source/ui/vba/vbapagebreaks.cxx
+++ sc/source/ui/vba/vbapagebreaks.cxx
@@ -115,10 +115,13 @@ sal_Int32 SAL_CALL RangePageBreaks::getCount(  ) throw (uno::RuntimeException)
     for( sal_Int32 i=0; i<nLength; i++ )
     {
         sal_Int32 nPos = aTablePageBreakData[i].Position;
-        if( nPos > nUsedEnd )
-            return nCount;
-        if( nPos >= nUsedStart )
-            nCount++;
+
+		// VBA. minz@cn.ibm.com. All page breaks before the used range should be counted. 
+		// And the page break at the end of the used range also should be counted.
+		if(  nPos <= nUsedEnd + 1 )
+			nCount++;
+		else
+			return nCount;
     }
 
     return nCount;
@@ -144,26 +147,15 @@ uno::Any SAL_CALL RangePageBreaks::getByIndex( sal_Int32 Index ) throw (lang::In
 
 sheet::TablePageBreakData RangePageBreaks::getTablePageBreakData( sal_Int32 nAPIItemIndex ) throw ( script::BasicErrorException, uno::RuntimeException)
 {
-    sal_Int32 index = -1;
     sheet::TablePageBreakData aTablePageBreakData;
     uno::Reference< excel::XWorksheet > xWorksheet( mxParent, uno::UNO_QUERY_THROW );
     uno::Reference< excel::XRange > xRange = xWorksheet->getUsedRange();
-    sal_Int32 nUsedStart = getAPIStartofRange( xRange );
-    sal_Int32 nUsedEnd = getAPIEndIndexofRange( xRange, nUsedStart );
     uno::Sequence<sheet::TablePageBreakData> aTablePageBreakDataList = getAllPageBreaks();
 
     sal_Int32 nLength = aTablePageBreakDataList.getLength();
-    for( sal_Int32 i=0; i<nLength; i++ )
-    {
-        aTablePageBreakData = aTablePageBreakDataList[i];
-        sal_Int32 nPos = aTablePageBreakData.Position;
-        if( nPos >= nUsedStart )
-            index++;
-        if( nPos > nUsedEnd )
-            DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
-        if( index == nAPIItemIndex )
-            return aTablePageBreakData;
-    }
+    //VBA. minz@cn.ibm.com. No need to filter the page break. All page breaks before the used range are counted.
+    if ( nAPIItemIndex < nLength && nAPIItemIndex>=0 )
+        aTablePageBreakData = aTablePageBreakDataList[nAPIItemIndex];
 
     return aTablePageBreakData;
 }
diff --git sc/source/ui/vba/vbapagesetup.cxx sc/source/ui/vba/vbapagesetup.cxx
index eeba5be..246aa5c 100644
--- sc/source/ui/vba/vbapagesetup.cxx
+++ sc/source/ui/vba/vbapagesetup.cxx
@@ -37,6 +37,9 @@
 #include <ooo/vba/excel/XlPageOrientation.hpp>
 #include <ooo/vba/excel/XlOrder.hpp>
 #include <ooo/vba/excel/Constants.hpp>
+#include <i18npool/paper.hxx>
+#include <editeng/paperinf.hxx>
+#include <ooo/vba/excel/XlPaperSize.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -624,3 +627,105 @@ ScVbaPageSetup::getServiceNames()
     }
     return aServiceNames;
 }
+
+//liuchen 2009-12-11
+
+struct PaperSizeMap
+{
+	Paper ePaper;
+	sal_Int32 xlPaper;
+};
+
+static PaperSizeMap paperSizeMappings[] =
+{
+	{ PAPER_A3, ooo::vba::excel::XlPaperSize::xlPaperA3 },
+	{ PAPER_A4, ooo::vba::excel::XlPaperSize::xlPaperA4 },
+	{ PAPER_A5, ooo::vba::excel::XlPaperSize::xlPaperA5 },
+	{ PAPER_B4_ISO, ooo::vba::excel::XlPaperSize::xlPaperB4 },
+	{ PAPER_B5_ISO, ooo::vba::excel::XlPaperSize::xlPaperB5 },
+	{ PAPER_LETTER, ooo::vba::excel::XlPaperSize::xlPaperLetter },
+	{ PAPER_LEGAL, ooo::vba::excel::XlPaperSize::xlPaperLegal },
+	{ PAPER_TABLOID, ooo::vba::excel::XlPaperSize::xlPaperTabloid },
+	{ PAPER_USER, ooo::vba::excel::XlPaperSize::xlPaperUser },
+	{ PAPER_B6_ISO, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeB6 },
+	{ PAPER_ENV_C4, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeC4 },
+	{ PAPER_ENV_C5, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeC5 },
+	{ PAPER_ENV_C6, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeC6 },
+	{ PAPER_ENV_C65, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeC65 },
+	{ PAPER_ENV_DL, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeDL },
+	{ PAPER_C, ooo::vba::excel::XlPaperSize::xlPaperCsheet },
+	{ PAPER_D, ooo::vba::excel::XlPaperSize::xlPaperDsheet },
+	{ PAPER_E, ooo::vba::excel::XlPaperSize::xlPaperEsheet },
+	{ PAPER_ENV_MONARCH, ooo::vba::excel::XlPaperSize::xlPaperEnvelopeMonarch },
+	{ PAPER_ENV_PERSONAL, ooo::vba::excel::XlPaperSize::xlPaperEnvelopePersonal },
+	{ PAPER_ENV_9, ooo::vba::excel::XlPaperSize::xlPaperEnvelope9 },
+	{ PAPER_ENV_10, ooo::vba::excel::XlPaperSize::xlPaperEnvelope10 },
+	{ PAPER_ENV_11, ooo::vba::excel::XlPaperSize::xlPaperEnvelope11 },
+	{ PAPER_ENV_12, ooo::vba::excel::XlPaperSize::xlPaperEnvelope12 }
+};
+
+static const int nMapSize = sizeof(paperSizeMappings) / sizeof(paperSizeMappings[0]);
+
+sal_Int32 PaperSizeOOoToExcel(Paper ePaper)
+{
+	sal_Int32 nPaperSize = ooo::vba::excel::XlPaperSize::xlPaperUser;
+
+	for (int i = 0; i < nMapSize; i++)
+	{
+		if (ePaper == paperSizeMappings[i].ePaper)
+		{
+			nPaperSize = paperSizeMappings[i].xlPaper;
+			break;
+		}
+	}
+	
+	return nPaperSize;
+}
+
+sal_Int32 SAL_CALL ScVbaPageSetup::getPaperSize() throw (css::uno::RuntimeException)
+{
+	com::sun::star::awt::Size size;
+	Paper ePaper = PAPER_USER;
+
+	try
+	{  
+		uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Size")));		
+		aValue >>= size;
+		ePaper = SvxPaperInfo::GetSvxPaper( Size(size.Width, size.Height), MAP_100TH_MM, TRUE);        
+	}
+	catch( uno::Exception& )
+	{
+	}
+    
+	return PaperSizeOOoToExcel(ePaper);
+}
+
+Paper PaperSizeExcelToOOo( sal_Int32 xlPaper)
+{
+	Paper ePaper = PAPER_USER;
+
+	for (int i = 0; i < nMapSize; i++)
+	{
+		if (xlPaper == paperSizeMappings[i].xlPaper)
+		{
+			ePaper = paperSizeMappings[i].ePaper;
+			break;
+		}
+	}
+
+	return ePaper;
+}
+void SAL_CALL ScVbaPageSetup::setPaperSize( sal_Int32 paperSize) throw (css::uno::RuntimeException)
+{
+	Paper ePaper = PaperSizeExcelToOOo( paperSize );
+
+	try
+	{
+		Size size1 = SvxPaperInfo::GetPaperSize( ePaper, MAP_100TH_MM );
+		com::sun::star::awt::Size size(size1.Width(), size1.Height());
+		mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Size")), uno::makeAny( size ));
+	}
+	catch( uno::Exception& )
+	{
+	}
+}
diff --git sc/source/ui/vba/vbapagesetup.hxx sc/source/ui/vba/vbapagesetup.hxx
index 09a996c..0afb600 100644
--- sc/source/ui/vba/vbapagesetup.hxx
+++ sc/source/ui/vba/vbapagesetup.hxx
@@ -82,6 +82,8 @@ public:
     virtual void SAL_CALL setCenterHorizontally( sal_Bool centerHorizontally ) throw (css::uno::RuntimeException);
     virtual sal_Bool SAL_CALL getPrintHeadings() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setPrintHeadings( sal_Bool printHeadings ) throw (css::uno::RuntimeException);
+	virtual sal_Int32 SAL_CALL getPaperSize() throw (css::uno::RuntimeException);  //liuchen 2009-12-11
+	virtual void SAL_CALL setPaperSize( sal_Int32 paperSize ) throw (css::uno::RuntimeException);  //liuchen 2009-12-11
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sc/source/ui/vba/vbapivotcache.cxx sc/source/ui/vba/vbapivotcache.cxx
index 1ca3ca3..8d128e0 100644
--- sc/source/ui/vba/vbapivotcache.cxx
+++ sc/source/ui/vba/vbapivotcache.cxx
@@ -34,6 +34,17 @@ ScVbaPivotCache::ScVbaPivotCache( const uno::Reference< XHelperInterface >& xPar
 {
 }
 
+sal_Int32  
+ScVbaPivotCache::getMissingItemsLimit() throw (css::uno::RuntimeException)
+{
+	return -1;
+}
+
+void 
+ScVbaPivotCache::setMissingItemsLimit( sal_Int32 /*aValue*/ ) throw ( css::uno::RuntimeException)
+{
+}
+
 void SAL_CALL 
 ScVbaPivotCache::Refresh() throw (css::uno::RuntimeException)
 {
diff --git sc/source/ui/vba/vbapivotcache.hxx sc/source/ui/vba/vbapivotcache.hxx
index 682c640..e32619b 100644
--- sc/source/ui/vba/vbapivotcache.hxx
+++ sc/source/ui/vba/vbapivotcache.hxx
@@ -40,6 +40,10 @@ class ScVbaPivotCache : public PivotCacheImpl_BASE
     css::uno::Reference< css::sheet::XDataPilotTable > m_xTable;
 public:
     ScVbaPivotCache( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::sheet::XDataPilotTable >& xTable );
+	
+	virtual ::sal_Int32 SAL_CALL getMissingItemsLimit() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setMissingItemsLimit( ::sal_Int32 aValue ) throw ( css::uno::RuntimeException);
+
     virtual void SAL_CALL Refresh() throw (css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sc/source/ui/vba/vbaquerytable.cxx sc/source/ui/vba/vbaquerytable.cxx
new file mode 100644
index 0000000..5ef6eec
--- /dev/null
+++ sc/source/ui/vba/vbaquerytable.cxx
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbaquerytable.hxx"
+#include "document.hxx"
+#include "docsh.hxx"
+#include "sfx2/lnkbase.hxx"
+#include "sfx2/linkmgr.hxx"
+#include "arealink.hxx"
+#include "vbarange.hxx"
+
+using namespace com::sun::star;
+
+
+ScVbaQueryTable::ScVbaQueryTable(const css::uno::Reference< ov::XHelperInterface >& xParent, 
+								 const css::uno::Reference< css::uno::XComponentContext > & xContext,
+								 ScDocument *pDocument , 
+								 ScVbaRange *pParent
+								 )
+//:QueryTable_Base(xParent, xContext)
+{
+	m_pDocument = pDocument;
+	m_pParent = pParent;
+}
+
+ScVbaQueryTable::~ScVbaQueryTable()
+{
+
+}
+
+::sal_Bool SAL_CALL 
+ScVbaQueryTable::Refresh( const ::com::sun::star::uno::Any& aBackgroundQuery ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	
+	//Get parent Info
+	sal_Int32 nRow = m_pParent->getRow();
+	sal_Int32 nClm = m_pParent->getColumn();
+	sal_Int16 nTab = m_pParent->getWorksheet()->getIndex() - 1; //The vba index begin from 1. 
+	ScAddress crrRngAddr(nClm, nRow, nTab);
+
+	//Get link info
+	sfx2::LinkManager *pLinkMng = m_pDocument->GetLinkManager();
+	const ::sfx2::SvBaseLinks &rLinks = pLinkMng->GetLinks();
+	USHORT nCount = rLinks.Count();
+
+	for (USHORT i=0; i<nCount; i++)
+	{
+		::sfx2::SvBaseLink* pBase = *rLinks[i];
+		if (pBase->ISA(ScAreaLink))
+		{
+		
+			ScAreaLink *pAreaLink = (ScAreaLink *)pBase;
+			const ScRange &destRange = pAreaLink->GetDestArea();
+			if (destRange.In(crrRngAddr))
+			{
+				pBase->Update();
+			}
+		}
+	}
+	
+	return sal_True;
+}
+
+
diff --git sc/source/ui/vba/vbaquerytable.hxx sc/source/ui/vba/vbaquerytable.hxx
new file mode 100644
index 0000000..9c05e9a
--- /dev/null
+++ sc/source/ui/vba/vbaquerytable.hxx
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_VBA_QUERYTABLE_HXX
+#define SC_VBA_QUERYTABLE_HXX
+
+
+#include <ooo/vba/excel/XQueryTable.hpp>
+#include "vbahelper/vbahelperinterface.hxx"
+
+using namespace ::ooo::vba;
+typedef ::cppu::WeakImplHelper1<excel::XQueryTable> QueryTable_Base;
+
+class ScDocument;
+class ScVbaRange;
+
+class ScVbaQueryTable : public QueryTable_Base
+{
+private:
+	ScDocument *m_pDocument;
+	ScVbaRange *m_pParent;
+public:
+	ScVbaQueryTable(const css::uno::Reference< ov::XHelperInterface >& xParent, 
+		            const css::uno::Reference< css::uno::XComponentContext > & xContext,
+					ScDocument *pDocument = NULL, 
+					ScVbaRange *pParent = NULL
+					);
+	~ScVbaQueryTable();
+	virtual ::sal_Bool SAL_CALL Refresh( const ::com::sun::star::uno::Any& aBackgroundQuery ) 
+		throw (::com::sun::star::uno::RuntimeException);
+
+};
+
+#endif
diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
index 8fcfcd5..dd93063 100755
--- sc/source/ui/vba/vbarange.cxx
+++ sc/source/ui/vba/vbarange.cxx
@@ -43,7 +43,6 @@
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
 #include <com/sun/star/table/CellRangeAddress.hpp>
-#include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/sheet/XSpreadsheetView.hpp>
 #include <com/sun/star/sheet/XCellRangeReferrer.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
@@ -92,6 +91,15 @@
 #include <com/sun/star/sheet/XSubTotalDescriptor.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hdl>
 
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XSheetAnnotations.hpp>
+
+#include <com/sun/star/sheet/XDataPilotTable.hpp>
+#include <com/sun/star/sheet/XDataPilotTable2.hpp>
+#include <com/sun/star/sheet/XDataPilotTablesSupplier.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionData.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionType.hpp>
+
 #include <ooo/vba/excel/XlPasteSpecialOperation.hpp>
 #include <ooo/vba/excel/XlPasteType.hpp>
 #include <ooo/vba/excel/Constants.hpp>
@@ -117,12 +125,15 @@
 #include <ooo/vba/excel/XlSpecialCellsValue.hpp>
 #include <ooo/vba/excel/XlConsolidationFunction.hpp>
 #include <ooo/vba/excel/XlSearchDirection.hpp>
+#include <ooo/vba/excel/XlColumnDataType.hpp>
+#include <ooo/vba/excel/XlFilterAction.hpp>
 
 #include <scitems.hxx>
 #include <svl/srchitem.hxx>
 #include <cellsuno.hxx>
 #include <dbcolect.hxx>
 #include "docfunc.hxx"
+#include <docuno.hxx>
 
 #include <sfx2/dispatch.hxx>
 #include <sfx2/app.hxx>
@@ -133,6 +144,7 @@
 #include <sc.hrc>
 #include <globstr.hrc>
 #include <unonames.hxx>
+#include <tools/stream.hxx>
 
 #include "vbarange.hxx"
 #include "vbafont.hxx"
@@ -144,8 +156,13 @@
 #include "vbavalidation.hxx"
 #include "vbahyperlinks.hxx"
 
+#include "vbapivottable.hxx"
+
+#include "asciiopt.hxx"
+#include "impex.hxx"
 #include "tabvwsh.hxx"
 #include "rangelst.hxx"
+#include "rangenam.hxx"
 #include "convuno.hxx"
 #include "compiler.hxx"
 #include "attrib.hxx"
@@ -363,55 +380,6 @@ ScVbaRangeAreas::createCollectionObject( const uno::Any& aSource )
     return lcl_makeRange( mxParent, mxContext, aSource, mbIsRows, mbIsColumns );
 }
 
-// assume that xIf is infact a ScCellRangesBase
-ScDocShell*
-getDocShellFromIf( const uno::Reference< uno::XInterface >& xIf ) throw ( uno::RuntimeException )
-{
-    ScCellRangesBase* pUno = ScCellRangesBase::getImplementation( xIf );
-    if ( !pUno )
-        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying uno range object" ) ), uno::Reference< uno::XInterface >()  );
-    return pUno->GetDocShell();
-}
-
-ScDocShell*
-getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException )
-{
-    // need the ScCellRangesBase to get docshell
-    uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
-    return getDocShellFromIf(xIf );
-}
-
-ScDocShell*
-getDocShellFromRanges( const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges ) throw ( uno::RuntimeException )
-{
-    // need the ScCellRangesBase to get docshell
-    uno::Reference< uno::XInterface > xIf( xRanges, uno::UNO_QUERY_THROW );
-    return getDocShellFromIf(xIf );
-}
-
-uno::Reference< frame::XModel > getModelFromXIf( const uno::Reference< uno::XInterface >& xIf ) throw ( uno::RuntimeException )
-{
-    ScDocShell* pDocShell = getDocShellFromIf(xIf );
-    return pDocShell->GetModel();
-}
-
-uno::Reference< frame::XModel > getModelFromRange( const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException )
-{
-    uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
-    return getModelFromXIf( xIf );
-}
-
-ScDocument*
-getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
-{
-    ScDocShell* pDocShell = getDocShellFromRange( xRange );
-    if ( !pDocShell )
-        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying docshell from uno range object" ) ), uno::Reference< uno::XInterface >() );
-    ScDocument* pDoc = pDocShell->GetDocument();
-    return pDoc;
-}
-
-
 ScDocument*
 ScVbaRange::getScDocument() throw (uno::RuntimeException)
 {
@@ -419,9 +387,9 @@ ScVbaRange::getScDocument() throw (uno::RuntimeException)
     {
         uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
         uno::Reference< table::XCellRange > xRange( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
-        return getDocumentFromRange( xRange );
-    }
-    return getDocumentFromRange( mxRange );
+		return excel::GetDocumentFromRange( xRange );
+	}
+	return excel::GetDocumentFromRange( mxRange );
 }
 
 ScDocShell* 
@@ -431,9 +399,9 @@ ScVbaRange::getScDocShell() throw (uno::RuntimeException)
     {
         uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
         uno::Reference< table::XCellRange > xRange( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
-        return getDocShellFromRange( xRange );
-    }
-    return getDocShellFromRange( mxRange );
+		return excel::GetDocShellFromRange( xRange );
+	}
+	return excel::GetDocShellFromRange( mxRange );
 }
 
 /*static*/ ScVbaRange* ScVbaRange::getImplementation( const uno::Reference< excel::XRange >& rxRange )
@@ -479,7 +447,7 @@ class NumFormatHelper
 public:
     NumFormatHelper( const uno::Reference< table::XCellRange >& xRange )
     {
-        mxSupplier.set( getModelFromRange( xRange ), uno::UNO_QUERY_THROW );
+		mxSupplier.set( excel::GetModelFromRange( xRange ), uno::UNO_QUERY_THROW );
         mxRangeProps.set( xRange, uno::UNO_QUERY_THROW);
         mxFormats = mxSupplier->getNumberFormats();
     }
@@ -744,7 +712,15 @@ CellValueSetter::processValue( const uno::Any& aValue, const uno::Reference< tab
         {
             double nDouble = 0.0;
             if ( aValue >>= nDouble )
+			{
                 xCell->setValue( nDouble );
+				uno::Reference< table::XCellRange > xRange( xCell, uno::UNO_QUERY_THROW );
+				NumFormatHelper cellNumFormat( xRange );
+				if ( cellNumFormat.isBooleanType() )
+				{
+					cellNumFormat.setNumberFormat( util::NumberFormat::NUMBER );
+				}
+			}
             else
                 isExtracted = false;
             break;
@@ -838,9 +814,10 @@ protected:
         double aDblValue = 0.0;
         if ( aValue >>= sFormula )
         {
-            // convert to CONV_OOO style formula string because XCell::setFormula
-            // always compile it in CONV_OOO style.  Perhaps css.sheet.FormulaParser
-            // should be used in future to directly pass formula tokens.
+            // convert to GRAM_PODF_A1 style grammar because XCell::setFormula
+            // always compile it in that grammar. Perhaps
+            // css.sheet.FormulaParser should be used in future to directly
+            // pass formula tokens when that API stabilizes.
             if ( m_eGrammar != formula::FormulaGrammar::GRAM_PODF_A1 && ( sFormula.trim().indexOf('=') == 0 ) )
             {
                 uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
@@ -1146,6 +1123,24 @@ bool getScRangeListForAddress( const rtl::OUString& sName, ScDocShell* pDocSh, S
         formula::FormulaGrammar::AddressConvention eConv = aConv; 
         // spaces are illegal ( but the user of course can enter them )
         rtl::OUString sAddress = (*it).trim();
+        // if a local name ( on the active sheet ) exists this will
+        // take precedence over a global with the same name
+        if ( !xNameAccess->hasByName( sAddress ) && pDocSh )
+        {
+            // try a local name
+            ScDocument* pDoc = pDocSh->GetDocument();     
+            SCTAB nCurTab = pDocSh->GetCurTab();
+            if ( pDoc )
+            {
+                NameToNameMap* pMap = pDoc->GetLocalNameMap( nCurTab );
+                if ( pMap )
+                {
+                    NameToNameMap::iterator itTmp = pMap->find( sAddress );
+                    if ( itTmp != pMap->end() ) // found a mapping
+                        sAddress = itTmp->second;
+                }
+            }
+        }
         if ( xNameAccess->hasByName( sAddress ) )
         {
             uno::Reference< sheet::XNamedRange > xNamed( xNameAccess->getByName( sAddress ), uno::UNO_QUERY_THROW );
@@ -1242,7 +1237,7 @@ uno::Reference< sheet::XSheetCellRangeContainer > lclExpandToMerged( const uno::
         ScUnoConversion::FillScRange( aScRange, aRangeAddr );
         aScRanges.Append( aScRange );
     }
-    return new ScCellRangesObj( getDocShellFromRanges( rxCellRanges ), aScRanges );
+    return new ScCellRangesObj( excel::GetDocShellFromRanges( rxCellRanges ), aScRanges );
 }
 
 void lclExpandAndMerge( const uno::Reference< table::XCellRange >& rxCellRange, bool bMerge ) throw (uno::RuntimeException)
@@ -1276,7 +1271,7 @@ util::TriState lclGetMergedState( const uno::Reference< table::XCellRange >& rxC
         of a merged range is part of this range are not covered. */
     ScRange aScRange;
     ScUnoConversion::FillScRange( aScRange, aRangeAddr );
-    bool bHasMerged = getDocumentFromRange( rxCellRange )->HasAttrib( aScRange, HASATTR_MERGED | HASATTR_OVERLAPPED );
+    bool bHasMerged = excel::GetDocumentFromRange( rxCellRange )->HasAttrib( aScRange, HASATTR_MERGED | HASATTR_OVERLAPPED );
     return bHasMerged ? util::TriState_INDETERMINATE : util::TriState_NO;
 }
 
@@ -1293,6 +1288,28 @@ ScVbaRange::getRangeObjectForName(
     return getRangeForName( xContext, sRangeName, pDocSh, refAddr, eConv );
 }
 
+table::CellAddress ScVbaRange::getLeftUpperCellAddress()
+{
+    table::CellAddress aCellAddress;
+    uno::Reference< table::XCellRange > xCellRange = mxRange;
+    if ( mxRanges.is() && m_Areas.is() && m_Areas->getCount() > 1 )
+    {
+        uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY );
+        if ( xIndex.is() && xIndex->getCount() > 0 )
+        {
+            xCellRange.set( xIndex->getByIndex( 0 ), uno::UNO_QUERY );
+        }
+    }
+    if ( xCellRange.is() )
+    {
+        uno::Reference< sheet::XCellAddressable > xCellAddr( xCellRange->getCellByPosition( 0, 0 ), uno::UNO_QUERY );
+        if ( xCellAddr.is() )
+        {
+            aCellAddress = xCellAddr->getCellAddress();
+        }
+    }
+    return aCellAddress;
+}
 
 table::CellRangeAddress getCellRangeAddressForVBARange( const uno::Any& aParam, ScDocShell* pDocSh,  formula::FormulaGrammar::AddressConvention aConv = formula::FormulaGrammar::CONV_XL_A1) throw ( uno::RuntimeException )
 {
@@ -1320,7 +1337,14 @@ table::CellRangeAddress getCellRangeAddressForVBARange( const uno::Any& aParam,
             uno::Reference< excel::XRange > xRange;
             aParam >>= xRange;
             if ( xRange.is() )
+			{
+				ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() );
+				if ( pRange && pDocSh && pRange->getScDocument() != pDocSh->GetDocument() )
+				{
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Invalid range" ) ), uno::Reference< uno::XInterface >() );
+				}
                 xRange->getCellRange() >>= xRangeParam;
+			}
             break;
         }
         default:
@@ -1333,7 +1357,7 @@ uno::Reference< XCollection >
 lcl_setupBorders( const uno::Reference< excel::XRange >& xParentRange, const uno::Reference<uno::XComponentContext>& xContext,  const uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
 {
     uno::Reference< XHelperInterface > xParent( xParentRange, uno::UNO_QUERY_THROW ); 
-    ScDocument* pDoc = getDocumentFromRange(xRange);
+	ScDocument* pDoc = excel::GetDocumentFromRange(xRange);
     if ( !pDoc )
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
     ScVbaPalette aPalette( pDoc->GetDocumentShell() );
@@ -1341,8 +1365,21 @@ lcl_setupBorders( const uno::Reference< excel::XRange >& xParentRange, const uno
     return borders;
 }
 
+void lcl_NotifyRangeChanges( const uno::Reference< frame::XModel >& xModel, ScCellRangesBase* pUnoRangesBase )
+{
+	if ( xModel.is() && pUnoRangesBase )
+	{
+		ScModelObj* pModelObj = ScModelObj::getImplementation( xModel );
+		const ScRangeList& aCellRanges = pUnoRangesBase->GetRangeList();
+		if ( pModelObj && pModelObj->HasChangesListeners() )
+		{
+			pModelObj->NotifyChanges( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "cell-change" ) ), aCellRanges );
+		}
+	}
+}
+
 ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
-    uno::Reference< uno::XComponentContext> const & xContext )  throw ( lang::IllegalArgumentException ) : ScVbaRange_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext, getXSomethingFromArgs< beans::XPropertySet >( args, 1, false ), getModelFromXIf( getXSomethingFromArgs< uno::XInterface >( args, 1 ) ), true ), mbIsRows( sal_False ), mbIsColumns( sal_False )
+    uno::Reference< uno::XComponentContext> const & xContext )  throw ( lang::IllegalArgumentException ) : ScVbaRange_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext, getXSomethingFromArgs< beans::XPropertySet >( args, 1, false ), excel::GetModelFromRange( getXSomethingFromArgs< uno::XInterface >( args, 1 ) ), true ), mbIsRows( sal_False ), mbIsColumns( sal_False )
 {
     mxRange.set( mxPropertySet, uno::UNO_QUERY );
     mxRanges.set( mxPropertySet, uno::UNO_QUERY );
@@ -1359,7 +1396,7 @@ ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
 }
 
 ScVbaRange::ScVbaRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
-: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRange, uno::UNO_QUERY_THROW ), getModelFromRange( xRange), true ), mxRange( xRange ),
+: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRange, uno::UNO_QUERY_THROW ), excel::GetModelFromRange( xRange), true ), mxRange( xRange ),
                 mbIsRows( bIsRows ),
                 mbIsColumns( bIsColumns )
 {
@@ -1374,7 +1411,7 @@ ScVbaRange::ScVbaRange( const uno::Reference< XHelperInterface >& xParent, const
 }
 
 ScVbaRange::ScVbaRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
-: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRanges, uno::UNO_QUERY_THROW ), getModelFromXIf( uno::Reference< uno::XInterface >( xRanges, uno::UNO_QUERY_THROW ) ), true ), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
+: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRanges, uno::UNO_QUERY_THROW ), excel::GetModelFromRange( uno::Reference< uno::XInterface >( xRanges, uno::UNO_QUERY_THROW ) ), true ), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
 
 {
     uno::Reference< container::XIndexAccess >  xIndex( mxRanges, uno::UNO_QUERY_THROW );
@@ -1503,6 +1540,9 @@ ScVbaRange::setValue( const uno::Any  &aValue ) throw (uno::RuntimeException)
     }	
     CellValueSetter valueSetter( aValue );
     setValue( aValue, valueSetter );
+
+	// Fires the range change event.
+	lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 void
@@ -1510,6 +1550,9 @@ ScVbaRange::Clear() throw (uno::RuntimeException)
     using namespace ::com::sun::star::sheet::CellFlags;
     sal_Int32 nFlags = VALUE | DATETIME | STRING | FORMULA | HARDATTR | EDITATTR | FORMATTED;
     ClearContents( nFlags );
+
+    // Fires the range change event.
+    lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 //helper ClearContent
@@ -1550,6 +1593,9 @@ ScVbaRange::ClearContents() throw (uno::RuntimeException)
         sheet::CellFlags::STRING |  sheet::CellFlags::DATETIME | 
         sheet::CellFlags::FORMULA );
     ClearContents( nClearFlags );
+
+	// Fires the range change event.
+	lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 void
@@ -1558,6 +1604,9 @@ ScVbaRange::ClearFormats() throw (uno::RuntimeException)
     //FIXME: need to check if we need to combine sheet::CellFlags::FORMATTED
     sal_Int32 nClearFlags = sheet::CellFlags::HARDATTR | sheet::CellFlags::FORMATTED | sheet::CellFlags::EDITATTR;
     ClearContents( nClearFlags );
+
+	// Fires the range change event.
+	lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 void
@@ -1573,6 +1622,9 @@ ScVbaRange::setFormulaValue( const uno::Any& rFormula, formula::FormulaGrammar::
     }	
     CellFormulaValueSetter formulaValueSetter( rFormula, getScDocument(), eGram );
     setValue( rFormula, formulaValueSetter );
+
+	// Fires the range change event.
+	lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 uno::Any 
@@ -1732,6 +1784,9 @@ ScVbaRange::fillSeries( sheet::FillDirection nFillDirection, sheet::FillMode nFi
     
     uno::Reference< sheet::XCellSeries > xCellSeries(mxRange, uno::UNO_QUERY_THROW );
     xCellSeries->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
+
+	// Fires the range change event.
+	lcl_NotifyRangeChanges( getScDocShell()->GetModel(), getCellRangesBase() );
 }
 
 void 
@@ -1871,7 +1926,16 @@ ScVbaRange::getFormulaArray() throw (uno::RuntimeException)
     uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
     uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
     uno::Any aMatrix;
-    aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+
+	//VBA, minz@cn.ibm.com
+	uno::Sequence< uno::Sequence<rtl::OUString> > aFmArray = xCellRangeFormula->getFormulaArray();
+	if( aFmArray.getLength() )
+	{
+		if( aFmArray.getLength() == 1 && aFmArray[0].getLength() == 1 )
+			aMatrix <<= aFmArray[0][0];
+		else	
+			aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+	}	
     return aMatrix;
 }
 
@@ -2226,7 +2290,7 @@ ScVbaRange::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
         {
             ScAddress::Details dDetails( formula::FormulaGrammar::CONV_XL_A1, 0, 0 );
             ScRange tmpRange;
-            tmpRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			tmpRange.ParseRows( sAddress, excel::GetDocumentFromRange( mxRange ), dDetails );
             nStartRow = tmpRange.aStart.Row();
             nEndRow = tmpRange.aEnd.Row();
 
@@ -2273,7 +2337,7 @@ ScVbaRange::Columns(const uno::Any& aIndex ) throw (uno::RuntimeException)
         {
             ScAddress::Details dDetails( formula::FormulaGrammar::CONV_XL_A1, 0, 0 );
             ScRange tmpRange;
-            tmpRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			tmpRange.ParseCols( sAddress, excel::GetDocumentFromRange( mxRange ), dDetails );
             nStartCol = tmpRange.aStart.Col();
             nEndCol = tmpRange.aEnd.Col();
 
@@ -2377,7 +2441,7 @@ ScVbaRange::Copy(const ::uno::Any& Destination) throw (uno::RuntimeException)
     }
     else
     {
-        uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+		uno::Reference< frame::XModel > xModel = excel::GetModelFromRange( mxRange );
         Select();
         excel::implnCopy( xModel );
     }
@@ -2401,8 +2465,9 @@ ScVbaRange::Cut(const ::uno::Any& Destination) throw (uno::RuntimeException)
         uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
         xMover->moveRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
     }
-    {
-        uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+	//VBA, minz@cn.ibm.com.
+	else {
+		uno::Reference< frame::XModel > xModel = excel::GetModelFromRange( mxRange );
         Select();
         excel::implnCut( xModel );
     }
@@ -2721,8 +2786,6 @@ ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, cons
   
         uno::Reference< frame::XModel > xModel( ( pShell ? pShell->GetModel() : NULL ), uno::UNO_QUERY_THROW );
     uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    // save old selection
-    uno::Reference< uno::XInterface > xSel( xModel->getCurrentSelection() );
     // select this range
     xSelection->select( uno::makeAny( mxRange ) );
     // set up defaults	
@@ -2743,8 +2806,6 @@ ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, cons
     USHORT nFlags = getPasteFlags(nPaste);
     USHORT nFormulaBits = getPasteFormulaBits(nOperation);
     excel::implnPasteSpecial(pShell->GetModel(), nFlags,nFormulaBits,bSkipBlanks,bTranspose);
-    // restore selection
-    xSelection->select( uno::makeAny( xSel ) );
 }
 
 uno::Reference< excel::XRange > 
@@ -2967,7 +3028,16 @@ ScVbaRange::Replace( const ::rtl::OUString& What, const ::rtl::OUString& Replace
         // OOo.org afaik
 
         uno::Reference< util::XSearchDescriptor > xSearch( xDescriptor, uno::UNO_QUERY );
+		// Find all cells that being replaced, used to fire the range changed event.
+		uno::Reference< container::XIndexAccess > xIndexAccess = xReplace->findAll( xSearch );
         xReplace->replaceAll( xSearch );
+
+		if ( xIndexAccess.is() && xIndexAccess->getCount() > 0 )
+		{
+			// Fires the range change event.
+			ScCellRangesBase* pScCellRangesBase = ScCellRangesBase::getImplementation( xIndexAccess ); //liuchen 2010-01-05
+			lcl_NotifyRangeChanges( getScDocShell()->GetModel(), pScCellRangesBase ); //liuchen 2010-01-05 the original convert method will fail in SUSE
+		}
     }
     return sal_True; // always
 }
@@ -3118,6 +3188,13 @@ ScVbaRange::Find( const uno::Any& What, const uno::Any& After, const uno::Any& L
 
         uno::Reference< uno::XInterface > xInterface = xStartCell.is() ? xSearch->findNext( xStartCell, xDescriptor) : xSearch->findFirst( xDescriptor );
         uno::Reference< table::XCellRange > xCellRange( xInterface, uno::UNO_QUERY );
+        // if we are searching from a starting cell and failed to find a match 
+        // then try from the begining
+        if ( !xCellRange.is() && xStartCell.is() )
+        { 
+            xInterface = xSearch->findFirst( xDescriptor );
+            xCellRange.set( xInterface, uno::UNO_QUERY ); 
+        }
         if ( xCellRange.is() )
         {
             uno::Reference< excel::XRange > xResultRange = new ScVbaRange( mxParent, mxContext, xCellRange );
@@ -3411,76 +3488,45 @@ ScVbaRange::End( ::sal_Int32 Direction )  throw (uno::RuntimeException)
         return xRange->End( Direction );
     }
 
-    
-    // #FIXME #TODO
-    // euch! found my orig implementation sucked, so 
-    // trying this even suckier one ( really need to use/expose code in
-    // around  ScTabView::MoveCursorArea(), thats the bit that calcutes
-    // where the cursor should go ) 
-    // Main problem with this method is the ultra hacky attempt to preserve
-    // the ActiveCell, there should be no need to go to these extreems
-    
-    // Save ActiveCell pos ( to restore later )
-    uno::Any aDft;
-    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
-    rtl::OUString sActiveCell = xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
-
-    // position current cell upper left of this range
-    Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
-
-        uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
-
-    SfxViewFrame* pViewFrame = excel::getViewFrame( xModel );
-    if ( pViewFrame )
-    {
-        SfxAllItemSet aArgs( SFX_APP()->GetPool() );
-        // Hoping this will make sure this slot is called
-        // synchronously
-        SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
-        aArgs.Put( sfxAsync, sfxAsync.Which() );
-        SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
-
-        USHORT nSID = 0;
-    
-        switch( Direction )
-        {
-            case excel::XlDirection::xlDown:
-                nSID = SID_CURSORBLKDOWN;
-                break;
-            case excel::XlDirection::xlUp:
-                nSID = SID_CURSORBLKUP;
-                break;
-            case excel::XlDirection::xlToLeft:
-                nSID = SID_CURSORBLKLEFT;
-                break;
-            case excel::XlDirection::xlToRight:
-                nSID = SID_CURSORBLKRIGHT;
-                break;
-            default:
-                throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ": Invalid ColumnIndex" ) ), uno::Reference< uno::XInterface >() ); 
-        }
-        if ( pDispatcher )
-        {
-            pDispatcher->Execute( nSID, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
-        }
-    }
-
-    // result is the ActiveCell		
-    rtl::OUString sMoved =	xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
-
-    // restore old ActiveCell		
-    uno::Any aVoid;
-
-    uno::Reference< excel::XRange > xOldActiveCell( xApplication->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
-    xOldActiveCell->Select();
-
-    uno::Reference< excel::XRange > resultCell;
-    
-    resultCell.set( xApplication->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
-
-    // return result
-    
-    return resultCell;
+	table::CellAddress aAddress = getLeftUpperCellAddress();
+	SCTAB nTab = aAddress.Sheet;
+	SCCOL nCurX = aAddress.Column;
+	SCROW nCurY = aAddress.Row;
+	SCCOL nNewX = nCurX;
+	SCROW nNewY = nCurY;
+
+	ScDocShell* pDocShell = getScDocShell();
+	ScDocument* pDoc = pDocShell->GetDocument();
+
+	SCsCOL nMoveX = 0;
+	SCsROW nMoveY = 0;
+	switch ( Direction )
+	{
+	case excel::XlDirection::xlDown:
+		nMoveY = 1;
+		break;
+	case excel::XlDirection::xlUp:
+		nMoveY = -1;
+		break;
+	case excel::XlDirection::xlToLeft:
+		nMoveX = -1;
+		break;
+	case excel::XlDirection::xlToRight:
+		nMoveX = 1;
+		break;
+	default:
+		throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Invalid Direction" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	if ( pDoc )
+	{
+		pDoc->FindAreaPos( nNewX, nNewY, nTab, nMoveX, nMoveY );
+	}
+
+	ScRange aNewRange( (SCCOL)nNewX, (SCROW)nNewY, nTab, (SCCOL)nNewX, (SCROW)nNewY, nTab );
+	uno::Reference< table::XCellRange > xCellRange( new ScCellRangeObj( getScDocShell(), aNewRange ) );
+	uno::Reference< excel::XRange > xResultRange = new ScVbaRange( mxParent, mxContext, xCellRange );
+	return xResultRange;
 }
 
 bool
@@ -3498,7 +3544,7 @@ ScVbaRange::characters( const uno::Any& Start, const uno::Any& Length ) throw (u
     if ( !isSingleCellRange() )
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't create Characters property for multicell range ") ), uno::Reference< uno::XInterface >() );
     uno::Reference< text::XSimpleText > xSimple(mxRange->getCellByPosition(0,0) , uno::UNO_QUERY_THROW );
-    ScDocument* pDoc = getDocumentFromRange(mxRange);
+	ScDocument* pDoc = excel::GetDocumentFromRange(mxRange);
     if ( !pDoc )
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
@@ -3615,7 +3661,7 @@ ScVbaRange::getCalcColWidth( const table::CellRangeAddress& rAddress) throw (uno
 double
 ScVbaRange::getCalcRowHeight( const table::CellRangeAddress& rAddress ) throw (uno::RuntimeException)
 {
-    ScDocument* pDoc = getDocumentFromRange( mxRange );
+	ScDocument* pDoc = excel::GetDocumentFromRange( mxRange );
     USHORT nWidth = pDoc->GetOriginalHeight( rAddress.StartRow, rAddress.Sheet );
     double nPoints = lcl_TwipsToPoints( nWidth );
     nPoints = lcl_Round2DecPlaces( nPoints );
@@ -3877,7 +3923,7 @@ ScVbaRange::setRowHeight( const uno::Any& _rowheight) throw (uno::RuntimeExcepti
     table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
     USHORT nTwips = lcl_pointsToTwips( nHeight );
     
-    ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+	ScDocShell* pDocShell = excel::GetDocShellFromRange( mxRange );
     ScDocFunc aFunc(*pDocShell);
     SCCOLROW nRowArr[2];
     nRowArr[0] = thisAddress.StartRow;
@@ -3890,7 +3936,7 @@ uno::Any SAL_CALL
 ScVbaRange::getPageBreak() throw (uno::RuntimeException)
 {
     sal_Int32 nPageBreak = excel::XlPageBreak::xlPageBreakNone;
-    ScDocShell* pShell = getDocShellFromRange( mxRange );
+	ScDocShell* pShell = excel::GetDocShellFromRange( mxRange );
     if ( pShell )
     {
         RangeHelper thisRange( mxRange );
@@ -3903,7 +3949,7 @@ ScVbaRange::getPageBreak() throw (uno::RuntimeException)
         uno::Reference< frame::XModel > xModel = pShell->GetModel();
         if ( xModel.is() )
         {
-            ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	        ScDocument* pDoc = excel::GetDocumentFromRange( mxRange );
             
             ScBreakType nBreak = BREAK_NONE;
             if ( !bColumn )
@@ -3928,7 +3974,7 @@ ScVbaRange::setPageBreak( const uno::Any& _pagebreak) throw (uno::RuntimeExcepti
     sal_Int32 nPageBreak = 0; 
     _pagebreak >>= nPageBreak;
         
-    ScDocShell* pShell = getDocShellFromRange( mxRange );
+	ScDocShell* pShell = excel::GetDocShellFromRange( mxRange );
     if ( pShell )
     {
         RangeHelper thisRange( mxRange );
@@ -4022,7 +4068,7 @@ ScVbaRange::getWorksheet() throw (uno::RuntimeException)
             uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
             xRange.set( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
         }
-        ScDocShell* pDocShell = getDocShellFromRange(xRange);
+		ScDocShell* pDocShell = excel::GetDocShellFromRange(xRange);
         RangeHelper rHelper(xRange);
         // parent should be Thisworkbook
            xSheet.set( new ScVbaWorksheet( uno::Reference< XHelperInterface >(), mxContext,rHelper.getSpreadSheet(),pDocShell->GetModel()) );
@@ -4077,63 +4123,44 @@ ScVbaRange::ApplicationRange( const uno::Reference< uno::XComponentContext >& xC
             }
         }
     }
-    uno::Reference< sheet::XSpreadsheetView > xView( getCurrentExcelDoc(xContext)->getCurrentController(), uno::UNO_QUERY );
-    uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
-    ScVbaRange* pRange = new ScVbaRange( excel::getUnoSheetModuleObj( xSheetRange ), xContext, xSheetRange );
+
+	// Add these codes for supporting shortcut: Application.Range(Range1, Range2), Range1 or Range2 is not the range of current active sheet.
+	// If Range1 and Range2 are not in current active sheet, we should not use the active sheet, but use the sheet of Range1 and Range2.
+	// If Range1 and Range2 are not in the same sheet, we throw an exception.
+	uno::Reference< sheet::XSpreadsheet > xSpreadsheet;
+	uno::Reference< excel::XRange > xRange1( Cell1, uno::UNO_QUERY ), xRange2( Cell2, uno::UNO_QUERY );
+	if ( xRange1.is() )
+	{
+		RangeHelper thisRange( xRange1->getCellRange() );
+		xSpreadsheet = thisRange.getSpreadSheet();
+	}
+	else if ( xRange2.is() )
+	{
+		RangeHelper thisRange( xRange2->getCellRange() );
+		xSpreadsheet = thisRange.getSpreadSheet();
+	}
+	if ( !xSpreadsheet.is() )
+	{
+		uno::Reference< frame::XModel > xModel = getCurrentExcelDoc( xContext );
+		if ( xModel.is() )
+		{
+			uno::Reference< sheet::XSpreadsheetView > xView( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+			xSpreadsheet = xView->getActiveSheet();
+		}
+	}
+
+	uno::Reference< table::XCellRange > xSheetRange( xSpreadsheet, uno::UNO_QUERY_THROW );
+	ScVbaRange* pRange = new ScVbaRange( excel::getUnoSheetModuleObj( xSheetRange ), xContext, xSheetRange );
+
     uno::Reference< excel::XRange > xVbSheetRange( pRange );
     return pRange->Range( Cell1, Cell2, true ); 
 }
 
-uno::Reference< sheet::XDatabaseRanges > 
-lcl_GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
-{
-    uno::Reference< frame::XModel > xModel;
-    if ( pShell )
-        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
-    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
-    return xDBRanges;	
-}
-// returns the XDatabaseRange for the autofilter on sheet (nSheet)
-// also populates sName with the name of range
-uno::Reference< sheet::XDatabaseRange > 
-lcl_GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName )
-{
-    uno::Reference< container::XIndexAccess > xIndexAccess( lcl_GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
-    table::CellRangeAddress dbAddress;
-    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
-    {
-        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
-        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
-        // autofilters work weirdly with openoffice, unnamed is the default 
-        // named range which is used to create an autofilter, but
-        // its also possible that another name could be used
-        //     this also causes problems when an autofilter is created on
-        //     another sheet
-        // ( but.. you can use any named range )
-        dbAddress = xDBRange->getDataArea();
-        if ( dbAddress.Sheet == nSheet )
-        {
-            sal_Bool bHasAuto = sal_False;
-            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
-            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
-            if ( bHasAuto )
-            {
-                sName = xNamed->getName();	
-                xDataBaseRange=xDBRange;
-                break;
-            }
-        }
-    }
-    return xDataBaseRange;
-} 
-
 // Helper functions for AutoFilter
 ScDBData* lcl_GetDBData_Impl( ScDocShell* pDocShell, sal_Int16 nSheet )
 {
     rtl::OUString sName;
-    lcl_GetAutoFiltRange( pDocShell, nSheet, sName );
+    excel::GetAutoFiltRange( pDocShell, nSheet, sName );
     OSL_TRACE("lcl_GetDBData_Impl got autofilter range %s for sheet %d",
         rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
     ScDBData* pRet = NULL;
@@ -4300,7 +4327,7 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
     ScDocShell* pShell = getScDocShell();
     sal_Bool bHasAuto = sal_False;	
     rtl::OUString sAutofiltRangeName;
-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = lcl_GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
+    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = excel::GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
     if ( xDataBaseRange.is() )
         bHasAuto = true;	
 
@@ -4333,7 +4360,7 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
             autoFiltAddress = multiCellRange.getCellRangeAddressable()->getRangeAddress();
         }
 
-        uno::Reference< sheet::XDatabaseRanges > xDBRanges = lcl_GetDataBaseRanges( pShell );
+        uno::Reference< sheet::XDatabaseRanges > xDBRanges = excel::GetDataBaseRanges( pShell );
         if ( xDBRanges.is() )
         {
             rtl::OUString sGenName( RTL_CONSTASCII_USTRINGPARAM("VBA_Autofilter_") );
@@ -4386,8 +4413,21 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
     // Use the normal uno api, sometimes e.g. when you want to use ALL as the filter
     // we can't use refresh as the uno interface doesn't have a concept of ALL
     // in this case we just call the core calc functionality - 
-    bool bAll = false;;
-    if ( ( Field >>= nField )  )
+	bool bAll = false;
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+	bool bIsValidFieldValue = ( Field >>= nField );
+	if ( !bIsValidFieldValue && xConverter.is() )
+	{
+		try
+		{
+			uno::Any aConverted = xConverter->convertTo( Field, getCppuType( (sal_Int32*)0 ) );
+			bIsValidFieldValue = ( aConverted >>= nField );
+		}
+		catch( const uno::Exception& ex )
+		{
+		}
+	}
+	if ( bIsValidFieldValue )
     {
         uno::Reference< sheet::XSheetFilterDescriptor2 > xDesc(
                 xDataBaseRange->getFilterDescriptor(), uno::UNO_QUERY );
@@ -4418,7 +4458,19 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
             bAll = true;
         // not sure what the relationship between Criteria1 and Operator is,
         // e.g. can you have a Operator without a Criteria ? in openoffice it 	
-        if ( Operator.hasValue()  && ( Operator >>= nOperator ) )
+		bool bIsValidOpValue = ( Operator.hasValue()  && ( Operator >>= nOperator ) );
+		if ( Operator.hasValue() && !bIsValidOpValue && xConverter.is() )
+		{
+			try
+			{
+				uno::Any aConverted = xConverter->convertTo( Operator, getCppuType( (sal_Int32*)0 ) );
+				bIsValidOpValue = ( aConverted >>= nOperator );
+			}
+			catch( const uno::Exception& ex )
+			{
+			}
+		}
+		if ( bIsValidOpValue )
         {
             // if its a bottom/top Ten(Percent/Value) and there
             // is no value specified for critera1 set it to 10
@@ -4566,8 +4618,8 @@ ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& CopyOrigin ) throw (u
     {
         // After the insert ( this range ) actually has moved
         ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
-         uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getDocShellFromRange( mxRange ) , aRange ) );
-        uno::Reference< excel::XRange > xVbaRange( new ScVbaRange( mxParent, mxContext, xRange, mbIsRows, mbIsColumns ) );	
+	 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( excel::GetDocShellFromRange( mxRange ) , aRange ) );
+		uno::Reference< excel::XRange > xVbaRange( new ScVbaRange( mxParent, mxContext, xRange, mbIsRows, mbIsColumns ) );
         xVbaRange->PasteSpecial( uno::Any(), uno::Any(), uno::Any(), uno::Any() );
     }
 }
@@ -4590,7 +4642,7 @@ ScVbaRange::Autofit() throw (uno::RuntimeException)
 
         if ( !( mbIsColumns || mbIsRows ) )
             DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString()); 			
-        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        ScDocShell* pDocShell = excel::GetDocShellFromRange( mxRange );
         if ( pDocShell )
         {
             RangeHelper thisRange( mxRange );	
@@ -4622,8 +4674,8 @@ ScVbaRange::Autofit() throw (uno::RuntimeException)
 ***************************************************************************************/
 void SAL_CALL
 ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
-        const css::uno::Any& ConsecutinveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma,
-        const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& /*FieldInfo*/,
+        const css::uno::Any& ConsecutiveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma,
+        const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& FieldInfo,
         const css::uno::Any& DecimalSeparator, const css::uno::Any& ThousandsSeparator, const css::uno::Any& /*TrailingMinusNumbers*/  ) throw (css::uno::RuntimeException)
 {
     uno::Reference< excel::XRange > xRange;
@@ -4660,13 +4712,13 @@ ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any
         OSL_TRACE("set TextQualifier\n");
     }
 
-    sal_Bool bConsecutinveDelimiter = sal_False;
-    if( ConsecutinveDelimiter.hasValue() )
+    sal_Bool bConsecutiveDelimiter = sal_False;
+    if( ConsecutiveDelimiter.hasValue() )
     {
-        if( !( ConsecutinveDelimiter >>= bConsecutinveDelimiter ) )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ConsecutinveDelimiter parameter should be a boolean" ),
+        if( !( ConsecutiveDelimiter >>= bConsecutiveDelimiter ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ConsecutiveDelimiter parameter should be a boolean" ),
                     uno::Reference< uno::XInterface >() );
-        OSL_TRACE("set ConsecutinveDelimiter\n");
+        OSL_TRACE("set ConsecutiveDelimiter\n");
     }
 
     sal_Bool bTab = sal_False;
@@ -4718,7 +4770,13 @@ ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any
             throw uno::RuntimeException( rtl::OUString::createFromAscii( "Other parameter should be a True" ),
                     uno::Reference< uno::XInterface >() );
     }
- //TODO* FieldInfo   Optional Variant. An array containing parse information for the individual columns of data. The interpretation depends on the value of DataType. When the data is delimited, this argument is an array of two-element arrays, with each two-element array specifying the conversion options for a particular column. The first element is the column number (1-based), and the second element is one of the xlColumnDataType  constants specifying how the column is parsed.
+    // FieldInfo, Optional Variant. An array containing parse information for the individual columns of data. 
+    // The interpretation depends on the value of DataType. When the data is delimited, this argument is an array 
+    // of two-element arrays, with each two-element array specifying the conversion options for a particular column. 
+    // The first element is the column number (1-based), and the second element is one of the xlColumnDataType  
+    // constants specifying how the column is parsed.
+    uno::Sequence< uno::Sequence< uno::Any > > sFieldInfo;
+    FieldInfo >>= sFieldInfo;
 
     rtl::OUString sDecimalSeparator;
     if( DecimalSeparator.hasValue() )
@@ -4736,7 +4794,106 @@ ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any
                 uno::Reference< uno::XInterface >() );
         OSL_TRACE("set ThousandsSpeparator\n" );
     }
- //TODO* TrailingMinusNumbers  Optional Variant. Numbers that begin with a minus character.
+    //TODO* TrailingMinusNumbers  Optional Variant. Numbers that begin with a minus character.
+
+    // Get the destination range's left-upper cell address.
+    ScVbaRange* pDestVbaRange = dynamic_cast< ScVbaRange* >( xRange.get() );
+    ScAddress aScDestAddress;
+    if ( pDestVbaRange )
+    {
+        ScUnoConversion::FillScAddress( aScDestAddress, pDestVbaRange->getLeftUpperCellAddress() );
+    }
+
+    // Parse the value of parameter FieldInfo.
+    USHORT nCount = 0, nRealCount = 0;
+    xub_StrLen* pColumns = NULL;
+    BYTE* pFormats = NULL;
+    if ( sFieldInfo.getLength() > 0 )
+    {
+        nCount = sFieldInfo.getLength();
+        pColumns = new xub_StrLen[nCount];
+        pFormats = new BYTE[nCount];
+        USHORT nFormat = 1;
+        uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+        for ( sal_Int32 nIndex = 0; nIndex < nCount; nIndex++ )
+        {
+            if ( sFieldInfo[nIndex].getLength() >= 2 )
+            {
+                nFormat = 1;
+                try
+                {
+                    uno::Any aConverted = xConverter->convertTo( sFieldInfo[nIndex][0], getCppuType((xub_StrLen*)0) );
+                    aConverted >>= pColumns[nRealCount];
+                    aConverted = xConverter->convertTo( sFieldInfo[nIndex][1], getCppuType((USHORT*)0) );
+                    aConverted >>= nFormat;
+                }
+                catch( const uno::Exception& )
+                {
+                }
+                pFormats[nRealCount++] = nFormat;
+            }
+        }
+    }
+
+    sal_Unicode cTextQualifier = '"';
+    cTextQualifier = xlTextQualifier == excel::XlTextQualifier::xlTextQualifierNone ? '\0' : cTextQualifier;
+    cTextQualifier = xlTextQualifier == excel::XlTextQualifier::xlTextQualifierSingleQuote ? '\'' : cTextQualifier;
+
+    // Get field delimiters.
+    String rFieldDelimiters;
+    if ( bTab )              rFieldDelimiters += '\t';
+    if ( bSemicolon )    rFieldDelimiters += ';';
+    if ( bComma )        rFieldDelimiters += ',';
+    if ( bSpace )          rFieldDelimiters += ' ';
+    if ( bOther )          rFieldDelimiters += *sOtherChar.getStr();
+
+    // Get the text in current range to SvMemoryStream.
+    ScRange aSrcScRange;
+    ScCellRangesBase* pSrcCellRangesBase = getCellRangesBase();
+    if ( pSrcCellRangesBase )
+    {
+        ScRangeList aRangeList = pSrcCellRangesBase->GetRangeList();
+        if ( aRangeList.First() )
+        {
+            aSrcScRange = *aRangeList.First();
+        }
+    }
+    ScImportExport aExport( getScDocument(), aSrcScRange );
+    aExport.SetDelimiter( static_cast< sal_Unicode >( 0 ) );
+    SvMemoryStream aStream;
+    aStream.SetStreamCharSet( RTL_TEXTENCODING_UNICODE );
+    ScImportExport::SetNoEndianSwap( aStream );
+    aExport.ExportStream( aStream, String(), FORMAT_STRING );
+    aStream.Seek( 0 );
+
+    // Set ScAsciiOptions according to the input parameters.
+    ScAsciiOptions aOptions;
+    aOptions.SetFixedLen( !bDilimited );
+    aOptions.SetStartRow( 0 );
+    aOptions.SetColInfo( nRealCount, pColumns, pFormats );
+    if ( bDilimited )
+    {
+        aOptions.SetFieldSeps( rFieldDelimiters );
+        aOptions.SetMergeSeps( bConsecutiveDelimiter );
+        aOptions.SetTextSep( cTextQualifier );
+    }
+
+    // Split the String in to columns.
+    if ( pDestVbaRange && pDestVbaRange->getScDocument() )
+    {
+        ScImportExport aImport( pDestVbaRange->getScDocument(), aScDestAddress );
+        aImport.SetExtOptions( aOptions );
+        aImport.SetApi( false );
+        aImport.ImportStream( aStream, String(), FORMAT_STRING );
+    }
+    if ( pColumns )
+    {
+        DELETEZ( pColumns );
+    }
+    if ( pFormats )
+    {
+        DELETEZ( pFormats );
+    }
 }
 
 uno::Any SAL_CALL
@@ -4881,7 +5038,7 @@ uno::Any ScVbaRange::getShowDetail() throw ( css::uno::RuntimeException)
         (thisAddress.StartColumn == thisAddress.EndColumn && thisAddress.EndColumn == aOutlineAddress.EndColumn ))
     {
         sal_Bool bColumn =thisAddress.StartRow == thisAddress.EndRow ? sal_False:sal_True; 
-        ScDocument* pDoc = getDocumentFromRange( mxRange );
+		ScDocument* pDoc = excel::GetDocumentFromRange( mxRange );
         ScOutlineTable* pOutlineTable = pDoc->GetOutlineTable(static_cast<SCTAB>(thisAddress.Sheet), sal_True);
         const ScOutlineArray* pOutlineArray =  bColumn ? pOutlineTable->GetColArray(): pOutlineTable->GetRowArray();
         if( pOutlineArray )
@@ -4938,6 +5095,24 @@ void ScVbaRange::setShowDetail(const uno::Any& aShowDetail) throw ( css::uno::Ru
     }
 }
 
+//09-09-16 add by limingl
+::com::sun::star::uno::Reference< ::ooo::vba::excel::XQueryTable > SAL_CALL 
+ScVbaRange::getQueryTable() throw (::com::sun::star::uno::RuntimeException)
+{
+	/*
+	if (m_pQueryTable == NULL)
+	{
+		m_pQueryTable = new ScVbaQueryTable(mxParent ,mxContext, getScDocument(), this); //add by limingl
+	}
+	//*/
+	if (!m_xQueryTable.is())
+	{
+		m_xQueryTable = new ScVbaQueryTable(mxParent ,mxContext, getScDocument(), this); //add by limingl
+	}
+	
+	return m_xQueryTable;
+}
+//end add
 uno::Reference< excel::XRange > SAL_CALL 
 ScVbaRange::MergeArea() throw (script::BasicErrorException, uno::RuntimeException)
 {
@@ -4967,6 +5142,118 @@ ScVbaRange::MergeArea() throw (script::BasicErrorException, uno::RuntimeExceptio
     return new ScVbaRange( mxParent, mxContext, mxRange );
 }
 
+//2008-08-25 add by limingl
+//The recordset's member: Recordset.Fields.Item will get a Field obj. 
+//Field.value is the column value.
+::sal_Int32 SAL_CALL 
+ScVbaRange::CopyFromRecordset( const ::com::sun::star::uno::Any& Data,  const ::com::sun::star::uno::Any& MaxRows, const ::com::sun::star::uno::Any& MaxColumns ) 
+throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException)
+{
+ 	uno::Sequence< uno::Any > aParams;
+	uno::Sequence< uno::Any > aFieldsParams(1);
+ 	uno::Sequence< sal_Int16 > aOutParamIndex;
+ 	uno::Sequence< uno::Any > aOutParam;
+	uno::Reference< uno::XInterface > xIntRes;
+	uno::Reference< uno::XInterface > xIntFields;
+	uno::Reference< uno::XInterface > xIntFld;
+	uno::Any aRet;
+	uno::Any aPar;
+	uno::Any aCrrCol;
+	uno::Any aCrrRow;
+	sal_Int16 nCrrCol = 0;
+	sal_Int32 nCrrRow = 0;
+	sal_Int32  nCol;
+	sal_Int32 nMaxRows = 0;
+	sal_Int32 nMaxColumns = 0;
+	sal_Bool bEof;
+// 	sal_Bool bColName = sal_True;
+	long lColCnt = 0;
+	if (MaxColumns.hasValue())
+	{
+		MaxColumns >>= nMaxColumns;
+	}
+	
+	long lMaxCol = nMaxColumns;
+	
+	if (MaxRows.hasValue())
+	{
+		MaxRows >>= nMaxRows;
+	}
+	
+
+	Data >>= xIntRes;
+	uno::Reference< script::XInvocation > xInvRes(xIntRes, uno::UNO_QUERY_THROW);
+	rtl::OUString oMoveNext = rtl::OUString::createFromAscii("MoveNext") ;
+	rtl::OUString oEof  = rtl::OUString::createFromAscii("EOF") ;
+	rtl::OUString oFields  = rtl::OUString::createFromAscii("Fields") ;
+
+	if( !xInvRes->hasMethod(oMoveNext))
+	{
+		return -1;
+	}
+	
+	//Get columns count
+	aRet = xInvRes->getValue(oFields);
+	aRet >>= xIntFields;
+	uno::Reference< script::XInvocation > xInvFields(xIntFields, uno::UNO_QUERY_THROW);
+	aRet = xInvFields->getValue( rtl::OUString::createFromAscii("Count")) ;
+	aRet >>= lColCnt;
+
+	//Set the assign column number
+	if (lMaxCol != 0)
+	{
+		if (lColCnt > lMaxCol)
+		{
+			lColCnt = lMaxCol;
+		}		
+	}
+	
+	aCrrRow <<= nCrrRow;
+	aCrrCol <<= nCrrCol;
+
+
+	//Get start position
+	uno::Reference< excel::XRange > xRngStartRow = Rows(uno::Any(sal_Int32(1)) );
+	uno::Reference< excel::XRange > xRngPos = xRngStartRow->Columns( uno::Any(sal_Int32(1)) );
+
+	while(1)
+	{//travel recordset
+		//get every column
+		for (long l = 0; l < lColCnt ; l++)
+		{
+			nCol = l;
+			aPar <<= nCol;
+			//get every field
+			aRet = xInvFields->invoke( rtl::OUString::createFromAscii("Item"), uno::Sequence< uno::Any >(&aPar,1) , aOutParamIndex,aOutParam);
+			aRet >>= xIntFld;
+			uno::Reference< script::XInvocation > xInvFld(xIntFld, uno::UNO_QUERY_THROW); //Get the Field obj
+
+			//set the field value
+			aRet = xInvFld->getValue( rtl::OUString::createFromAscii("Value") );
+ 			uno::Reference< excel::XRange > xRngToFill = xRngPos->Offset(aCrrRow,aCrrCol );
+			
+			xRngToFill->setValue(aRet);
+			nCrrCol++;
+			aCrrCol <<= nCrrCol;
+		}
+		
+		aRet = xInvRes->invoke(oMoveNext, aParams,aOutParamIndex,aOutParam );
+		aRet = xInvRes->getValue(oEof);
+		aRet >>= bEof;
+		if (bEof || ( nCrrRow >= nMaxRows && nMaxRows != 0) )
+		{//Arrive the end of recordset
+			break;
+		}
+		
+ 		nCrrRow++;
+ 		aCrrRow <<= nCrrRow;
+		nCrrCol = 0;
+		aCrrCol <<= nCrrCol;
+	}
+
+	return 0;
+}
+//end add
 void SAL_CALL 
 ScVbaRange::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& ActivePrinter, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& PrToFileName ) throw (uno::RuntimeException)
 {
@@ -4985,7 +5272,7 @@ ScVbaRange::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any&
         {
             ScVbaRange* pRange = getImplementation( xRange );
             // initialise the doc shell and the printareas
-            pShell = getDocShellFromRange( pRange->mxRange );
+			pShell = excel::GetDocShellFromRange( pRange->mxRange );
             xPrintAreas.set( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
         }
         printAreas[ index - 1 ] = rangeAddress;
@@ -5071,7 +5358,7 @@ ScVbaRange::AutoFill(  const uno::Reference< excel::XRange >& Destination, const
             }
         }
     }	
-    ScDocShell* pDocSh= getDocShellFromRange( mxRange );
+	ScDocShell* pDocSh= excel::GetDocShellFromRange( mxRange );
 
     FillCmd eCmd = FILL_AUTO;
     FillDateCmd eDateCmd = FILL_DAY;	
@@ -5194,13 +5481,8 @@ ScVbaRange::AutoOutline(  ) throw (script::BasicErrorException, uno::RuntimeExce
     RangeHelper thisRange( mxRange );
     table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
 
-    if ( isSingleCellRange() || mbIsRows )
-    {
-        uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
-                xSheetOutline->autoOutline( thisAddress );	
-    }
-    else
-        DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+	uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+	xSheetOutline->autoOutline( thisAddress );
 }
 
 void SAL_CALL
@@ -5227,9 +5509,9 @@ ScVbaRange::groupUnGroup( bool bUnGroup ) throw ( script::BasicErrorException, u
 {
     if ( m_Areas->getCount() > 1 )
          DebugHelper::exception(SbERR_METHOD_FAILED, STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY);
-    table::TableOrientation nOrient = table::TableOrientation_ROWS;
-    if ( mbIsColumns )
-        nOrient = table::TableOrientation_COLUMNS;
+	table::TableOrientation nOrient = table::TableOrientation_COLUMNS;
+	if ( mbIsRows )
+		nOrient = table::TableOrientation_ROWS;
     RangeHelper thisRange( mxRange );
     table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
     uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
@@ -5388,6 +5670,7 @@ ScVbaRange::SpecialCells( const uno::Any& _oType, const uno::Any& _oValue) throw
     bool bIsSingleCell = isSingleCellRange(); 
     bool bIsMultiArea = ( m_Areas->getCount() > 1 );
     ScVbaRange* pRangeToUse = this;
+	uno::Reference< excel::XRange > xUsedRange( getWorksheet()->getUsedRange() );
     sal_Int32 nType = 0;
     if ( !( _oType >>= nType ) )
         DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
@@ -5533,7 +5533,6 @@ ScVbaRange::SpecialCells( const uno::Any& _oType, const uno::Any& _oValue) throw
             }
             else if ( bIsSingleCell )
             {
-                uno::Reference< excel::XRange > xUsedRange = getWorksheet()->getUsedRange();
                 pRangeToUse = static_cast< ScVbaRange* >( xUsedRange.get() );	
             }
         
@@ -5623,6 +5906,183 @@ ScVbaRange::Subtotal( ::sal_Int32 _nGroupBy, ::sal_Int32 _nFunction, const uno::
     }
 }
 
+uno::Any SAL_CALL ScVbaRange::AdvancedFilter( sal_Int32 Action, const uno::Any& CriteriaRange, 
+	const uno::Any& CopyToRange, const uno::Any& Unique ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	uno::Any aRet;
+	aRet <<= sal_True;
+
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+	ScDocument* pDoc = getScDocument();
+	if ( !pDoc )
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from range" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	// Action
+	if ( Action != excel::XlFilterAction::xlFilterInPlace && Action != excel::XlFilterAction::xlFilterCopy )
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Invalid input parameter" ) ), uno::Reference< uno::XInterface >() );
+	}
+	if ( m_Areas->getCount() > 1 )
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Invalid range" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	sal_Bool bCopyOut = ( Action != excel::XlFilterAction::xlFilterInPlace );
+	uno::Reference< sheet::XSheetFilterDescriptor > xFilterDesc;
+	uno::Reference< sheet::XSheetFilterable > xSheetFilter( mxRange, uno::UNO_QUERY_THROW );
+
+	// CriteriaRange
+	String aBuiltInCriteria; // Excel Built-In Filter Criteria.
+	ScRangeData* pData = NULL;
+	table::CellRangeAddress refParentAddr;
+	uno::Any aCriteriaRange = CriteriaRange;
+	formula::FormulaGrammar::AddressConvention aConv = formula::FormulaGrammar::CONV_XL_A1;
+	if ( aCriteriaRange.hasValue() &&  aCriteriaRange.getValueTypeClass() == uno::TypeClass_STRING )
+	{
+		rtl::OUString rRangeString;
+		aCriteriaRange >>= rRangeString;
+		aConv = excel::IsR1C1ReferFormat( pDoc, rRangeString ) ? formula::FormulaGrammar::CONV_XL_R1C1 : aConv;
+	}
+	else
+	{
+		// Get Excel BuiltIn Filter Criteria.
+		ScRangeName* pRangeNames = pDoc->GetRangeName();
+		const USHORT nCount = pRangeNames ? pRangeNames->GetCount() : 0;
+		for ( USHORT index = 0; index < nCount; index++ )
+		{
+			pData = ( ScRangeData* )( pRangeNames->At( index ) );
+			if ( pData && pData->HasType( RT_CRITERIA ) )
+			{
+				pData->GetSymbol( aBuiltInCriteria, formula::FormulaGrammar::GRAM_NATIVE_XL_A1 );
+				break;
+			}
+		}
+		aCriteriaRange = aBuiltInCriteria.Len() > 0 ? uno::makeAny( rtl::OUString( aBuiltInCriteria ) ) : aCriteriaRange;
+	}
+	if ( aCriteriaRange.hasValue() )
+	{
+		table::CellRangeAddress criteriaRangeAddress = getCellRangeAddressForVBARange( aCriteriaRange, getScDocShell(), aConv );
+		ScRange refRange;
+		ScUnoConversion::FillScRange( refRange, criteriaRangeAddress );
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getScDocShell(), refRange ) );
+		uno::Reference< sheet::XSheetFilterableEx > xCriteria( xRange, uno::UNO_QUERY );
+		if ( xCriteria.is() )
+		{
+			xFilterDesc = xCriteria->createFilterDescriptorByObject( xSheetFilter );
+		}
+	}
+	else if ( mxRange.is() )
+	{
+		uno::Reference< sheet::XSheetFilterableEx > xCriteria( mxRange, uno::UNO_QUERY );
+		if ( xCriteria.is() )
+		{
+			xFilterDesc = xCriteria->createFilterDescriptorByObject( xSheetFilter );
+		}
+	}
+
+	uno::Reference< beans::XPropertySet > xPropertySet( xFilterDesc, uno::UNO_QUERY );
+	if ( xPropertySet.is() )
+	{
+		xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_COPYOUT ) ), uno::makeAny( bCopyOut ) );
+	}
+
+	// CopyToRange
+	if ( bCopyOut && CopyToRange.hasValue() && xPropertySet.is() )
+	{
+		formula::FormulaGrammar::AddressConvention aTmpConv = formula::FormulaGrammar::CONV_XL_A1;
+		if ( CopyToRange.getValueTypeClass() == uno::TypeClass_STRING )
+		{
+			rtl::OUString rRangeString;
+			CopyToRange >>= rRangeString;
+			aTmpConv = excel::IsR1C1ReferFormat( pDoc, rRangeString ) ? formula::FormulaGrammar::CONV_XL_R1C1 : aConv;
+		}
+		ScRange refRange;
+		ScUnoConversion::FillScRange( refRange, getCellRangeAddressForVBARange( CopyToRange, getScDocShell(), aTmpConv ) );
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getScDocShell(), refRange ) );
+		uno::Reference< sheet::XCellAddressable > xCellAddr( xRange->getCellByPosition( 0, 0 ), uno::UNO_QUERY_THROW );
+		xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_OUTPOS ) ), uno::makeAny( xCellAddr->getCellAddress() ) );
+	}
+
+	// Unique
+	if ( xPropertySet.is() )
+	{
+		sal_Bool bUnique = sal_False;
+		uno::Any aUnique;
+		try
+		{
+			aUnique <<= bUnique;
+			aUnique = ( xConverter.is() && Unique.hasValue() ) ? xConverter->convertTo( Unique, getCppuType( ( sal_Bool* ) 0 ) ) : aUnique;
+		}
+		catch( const uno::Exception& )
+		{
+		}
+		xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_SKIPDUP ) ), aUnique );
+	}
+
+	// Do filter.
+	if ( xFilterDesc.is() )
+	{
+		xSheetFilter->filter( xFilterDesc );
+	}
+
+	return aRet;
+}
+
+//Add by minz@cn.ibm.com. Range.PivotTable.
+//Returns a PivotTable object that represents the PivotTable report containing the upper-left corner of the specified range.
+uno::Reference< excel::XPivotTable >
+ScVbaRange::PivotTable() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XPivotTable > xDestPVTable;
+
+	uno::Reference< sheet::XSpreadsheet > xSheet;
+	if ( mxRange.is() )
+	{
+		RangeHelper thisRange( mxRange );
+		xSheet = thisRange.getSpreadSheet();
+	}
+	else if ( mxRanges.is() )
+	{
+		uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xRange( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+		RangeHelper thisRange( xRange );
+		xSheet = thisRange.getSpreadSheet();
+	}
+
+//	RangeHelper thisRange( mxRange );
+//	uno::Reference< sheet::XSpreadsheet > xSheet = thisRange.getSpreadSheet();
+	uno::Reference< sheet::XDataPilotTablesSupplier > xTables(xSheet, uno::UNO_QUERY_THROW ) ;
+	uno::Reference< container::XIndexAccess > xIndexAccess( xTables->getDataPilotTables(), uno::UNO_QUERY_THROW );
+	if ( xIndexAccess.is() )
+	{
+		//get the upper-left cell address
+		table::CellAddress aAddress = getLeftUpperCellAddress();
+
+		sal_Int32 nCount = xIndexAccess->getCount();
+		for (sal_Int32 i=0; i < nCount; i++)
+		{
+			uno::Reference< sheet::XDataPilotTable > xDPTable(xIndexAccess->getByIndex(i), uno::UNO_QUERY);
+			uno::Reference< sheet::XDataPilotTable2 > xDPTable2(xDPTable, uno::UNO_QUERY);
+
+			//check if the cell is in the pivot table			
+			sheet::DataPilotTablePositionData posData = xDPTable2->getPositionData(aAddress);
+			table::CellRangeAddress aCellRangeAddress = xDPTable->getOutputRange();
+			ScRange aScRange( aCellRangeAddress.StartColumn, aCellRangeAddress.StartRow, aCellRangeAddress.Sheet, 
+				aCellRangeAddress.EndColumn, aCellRangeAddress.EndRow, aCellRangeAddress.Sheet );
+			ScAddress aPos( aAddress.Column, aAddress.Row, aAddress.Sheet );
+			if( !(posData.PositionType == sheet::DataPilotTablePositionType::NOT_IN_TABLE) || aScRange.In( aPos ) )
+			{
+				xDestPVTable = new ScVbaPivotTable( mxContext, xDPTable );
+				break;
+			}
+		}
+	}
+	return xDestPVTable;
+}
+
+
 rtl::OUString& 
 ScVbaRange::getServiceImplName()
 {
@@ -5642,6 +6102,25 @@ ScVbaRange::getServiceNames()
     return aServiceNames;
 }
 
+sal_Bool SAL_CALL
+ScVbaRange::hasError() throw (uno::RuntimeException)
+{
+    double dResult = sal_False;
+    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+    uno::Reference< script::XInvocation > xInvoc( xApplication->WorksheetFunction(), uno::UNO_QUERY_THROW );
+
+    static rtl::OUString FunctionName( RTL_CONSTASCII_USTRINGPARAM("IsError" ) );
+    uno::Sequence< uno::Any > Params(1);
+    uno::Reference< excel::XRange > aRange( this );
+    Params[0] = uno::makeAny( aRange );
+    uno::Sequence< sal_Int16 > OutParamIndex;
+    uno::Sequence< uno::Any > OutParam;
+    xInvoc->invoke( FunctionName, Params, OutParamIndex, OutParam ) >>= dResult;
+    if ( dResult > 0.0 )
+         return sal_True;
+    return sal_False;
+}
+
 namespace range
 {
 namespace sdecl = comphelper::service_decl;
diff --git sc/source/ui/vba/vbarange.hxx sc/source/ui/vba/vbarange.hxx
index 14f0bde..50b18ba 100644
--- sc/source/ui/vba/vbarange.hxx
+++ sc/source/ui/vba/vbarange.hxx
@@ -35,6 +35,7 @@
 #include <ooo/vba/excel/XFont.hpp>
 #include <ooo/vba/excel/XComment.hpp>
 #include <ooo/vba/XCollection.hpp>
+#include <ooo/vba/excel/XPivotTable.hpp>
 #include <ooo/vba/excel/XlPasteType.hdl>
 #include <ooo/vba/excel/XlPasteSpecialOperation.hdl>
 
@@ -49,6 +50,8 @@
 #include <com/sun/star/sheet/FillDirection.hpp>
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
 #include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include "vbaquerytable.hxx" //09-09-18 add by limingl
 
 //#include <vbahelper/vbahelperinterface.hxx>
 #include "vbaformat.hxx"
@@ -99,6 +102,7 @@ class ScVbaRange : public ScVbaRange_BASE
     sal_Bool mbIsRows;
     sal_Bool mbIsColumns;
     css::uno::Reference< ov::excel::XValidation > m_xValidation;
+	css::uno::Reference<excel::XQueryTable> m_xQueryTable; //09-09-16 add by limingl
     double getCalcColWidth( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
     double getCalcRowHeight( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
     void visitArray( ArrayVisitor& vistor );
@@ -148,6 +152,7 @@ public:
         const css::uno::Reference< css::uno::XComponentContext >& xContext,
         const rtl::OUString& sRangeName, ScDocShell* pDocSh,
         formula::FormulaGrammar::AddressConvention eConv = formula::FormulaGrammar::CONV_XL_A1  ) throw ( css::uno::RuntimeException );
+	css::table::CellAddress getLeftUpperCellAddress();
 
     // Attributes
     virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
@@ -190,6 +195,7 @@ public:
     virtual css::uno::Any SAL_CALL getPrefixCharacter() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getShowDetail() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setShowDetail(const css::uno::Any& aShowDetail) throw (css::uno::RuntimeException);	
+	virtual ::com::sun::star::uno::Reference< ::ooo::vba::excel::XQueryTable > SAL_CALL getQueryTable() throw (::com::sun::star::uno::RuntimeException); //09-09-16 add by limingl
     // Methods
     sal_Bool IsRows() { return mbIsRows; }
     sal_Bool IsColumns() { return mbIsColumns; }
@@ -239,8 +245,8 @@ public:
     virtual css::uno::Any SAL_CALL Borders( const css::uno::Any& ) throw ( css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL BorderAround( const css::uno::Any& LineStyle, 
                 const css::uno::Any& Weight, const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
-                const css::uno::Any& ConsecutinveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma, 
+	virtual void SAL_CALL TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
+                const css::uno::Any& ConsecutiveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma, 
                 const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& FieldInfo,
                 const css::uno::Any& DecimalSeparator, const css::uno::Any& ThousandsSeparator, const css::uno::Any& TrailingMinusNumbers ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Hyperlinks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
@@ -265,6 +271,11 @@ public:
     virtual void SAL_CALL RemoveSubtotal(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL MergeArea() throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual void SAL_CALL Subtotal( ::sal_Int32 GroupBy, ::sal_Int32 Function, const css::uno::Sequence< ::sal_Int32 >& TotalList, const css::uno::Any& Replace, const css::uno::Any& PageBreaks, const css::uno::Any& SummaryBelowData ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL AdvancedFilter( ::sal_Int32 Action, const css::uno::Any& CriteriaRange, const css::uno::Any& CopyToRange, const css::uno::Any& Unique ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+	
+	virtual css::uno::Reference< ov::excel::XPivotTable > SAL_CALL PivotTable(  ) throw (css::uno::RuntimeException);
+
+	virtual ::sal_Int32 SAL_CALL CopyFromRecordset( const ::com::sun::star::uno::Any& Data,  const ::com::sun::star::uno::Any& MaxRows, const ::com::sun::star::uno::Any& MaxColumns ) throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException); //2008-08-25 add by limingl
     // XEnumerationAccess
     virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
     // XElementAccess
@@ -290,6 +301,8 @@ public:
     static css::uno::Reference< ov::excel::XRange > ApplicationRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException);
     virtual sal_Bool SAL_CALL GoalSeek( const css::uno::Any& Goal, const css::uno::Reference< ov::excel::XRange >& ChangingCell ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL SpecialCells( const css::uno::Any& _oType, const css::uno::Any& _oValue) throw ( css::script::BasicErrorException );  
+	// XErrorQuery
+	virtual ::sal_Bool SAL_CALL hasError(  ) throw (css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git sc/source/ui/vba/vbavalidation.cxx sc/source/ui/vba/vbavalidation.cxx
index f76794e..e585343 100644
--- sc/source/ui/vba/vbavalidation.cxx
+++ sc/source/ui/vba/vbavalidation.cxx
@@ -25,6 +25,7 @@
  *
  ************************************************************************/
 #include "vbavalidation.hxx"
+#include "vbaformatcondition.hxx"
 #include <com/sun/star/sheet/XSheetCondition.hpp>
 #include <com/sun/star/sheet/ValidationType.hpp>
 #include <com/sun/star/sheet/ValidationAlertStyle.hpp>
@@ -225,8 +226,10 @@ ScVbaValidation::Delete(  ) throw (uno::RuntimeException)
 
     lcl_setValidationProps( m_xRange, xProps );
 }
+
+// Fix the defect that validatation cannot work when the input should be limited between a lower bound and an upper bound
 void SAL_CALL 
-ScVbaValidation::Add( const uno::Any& Type, const uno::Any& AlertStyle, const uno::Any& /*Operator*/, const uno::Any& Formula1, const uno::Any& Formula2 ) throw (uno::RuntimeException)
+ScVbaValidation::Add( const uno::Any& Type, const uno::Any& AlertStyle, const uno::Any& Operator, const uno::Any& Formula1, const uno::Any& Formula2 ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
     uno::Reference< sheet::XSheetCondition > xCond( xProps, uno::UNO_QUERY_THROW );
@@ -291,6 +294,13 @@ ScVbaValidation::Add( const uno::Any& Type, const uno::Any& AlertStyle, const un
 
     xProps->setPropertyValue( ALERTSTYLE, uno::makeAny( eStyle ) );
 
+	//2009-11-11 fix the defect that validatation cannot work when the input should be limited between a lower bound and an upper bound
+	if ( Operator.hasValue() )
+	{
+		css::sheet::ConditionOperator conOperator = ScVbaFormatCondition::retrieveAPIOperator( Operator );
+		xCond->setOperator( conOperator );
+	}
+	//2009-11-11
     if ( sFormula1.getLength() )
         xCond->setFormula1( sFormula1 );
     if ( sFormula2.getLength() )
diff --git sc/source/ui/vba/vbaworkbook.cxx sc/source/ui/vba/vbaworkbook.cxx
index 5fa25a4..4d4ad9c 100644
--- sc/source/ui/vba/vbaworkbook.cxx
+++ sc/source/ui/vba/vbaworkbook.cxx
@@ -36,6 +36,7 @@
 #include <com/sun/star/frame/XFrame.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <ooo/vba/excel/XlFileFormat.hpp>
+#include <ooo/vba/excel/XApplication.hpp>  //liuchen 2009-12-16
 
 #include "scextopt.hxx"
 #include "vbaworksheet.hxx"
@@ -124,7 +125,7 @@ ScVbaWorkbook::Colors( const ::uno::Any& Index ) throw (::script::BasicErrorExce
 }
 
 ::sal_Int32 SAL_CALL 
-ScVbaWorkbook::FileFormat(  ) throw (::script::BasicErrorException, ::uno::RuntimeException)
+ScVbaWorkbook::getFileFormat(  ) throw (::uno::RuntimeException)
 {
         sal_Int32 aFileFormat = 0;
         rtl::OUString aFilterName;
@@ -184,6 +185,24 @@ ScVbaWorkbook::FileFormat(  ) throw (::script::BasicErrorException, ::uno::Runti
         return aFileFormat;
 }
 
+//VBA by minz@cn.ibm.com. Convert Excel fileformat to OO file filter
+::rtl::OUString ScVbaWorkbook::convertFileFormat(sal_Int32 aFileFormat)
+{
+	rtl::OUString aFilterName;
+
+	switch(aFileFormat) 
+	{
+		case excel::XlFileFormat::xlCSV:
+				aFilterName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Text - txt - csv (StarCalc)" ) );
+				break;
+		case excel::XlFileFormat::xlExcel9795:
+				aFilterName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MS Excel 97" ) );
+				break;
+	}
+
+	return aFilterName;
+}
+
 void 
 ScVbaWorkbook::init()
 {
@@ -261,6 +280,12 @@ ScVbaWorkbook::Activate() throw (uno::RuntimeException)
     VbaDocumentBase::Activate();
 }
 
+void
+ScVbaWorkbook::Protect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+    VbaDocumentBase::Protect( aPassword );
+}
+
 ::sal_Bool
 ScVbaWorkbook::getProtectStructure() throw (uno::RuntimeException)
 {
@@ -296,6 +321,50 @@ ScVbaWorkbook::SaveCopyAs( const rtl::OUString& sFileName ) throw ( uno::Runtime
     xStor->storeToURL( aURL, storeProps );
 }
 
+//VBA by minz@cn.ibm.com. Add Workbook.SaveAs.
+void 
+ScVbaWorkbook::SaveAs( const rtl::OUString& FileName, const uno::Any& FileFormat, const uno::Any& /*CreateBackup*/ ) throw ( uno::RuntimeException)
+{
+	rtl::OUString aURL;
+	osl::FileBase::getFileURLFromSystemPath( FileName, aURL );
+	//liuchen 2009-12-16 if the input parameter "FileName" takes the form as "MyFile", we need to get the current directory and combine the current directory and the file name
+	INetURLObject aFileNameURL( aURL );
+	aURL = aFileNameURL.GetMainURL( INetURLObject::NO_DECODE );
+	if ( aURL.getLength() == 0 )
+	{
+		uno::Reference< excel::XApplication > xApplication ( Application(),uno::UNO_QUERY_THROW );
+		rtl::OUString aPathStr = xApplication->getDefaultFilePath();
+		rtl::OUString aPathURLStr;
+		osl::FileBase::getFileURLFromSystemPath( aPathStr, aPathURLStr );
+		INetURLObject aPathURL( aPathURLStr );
+		aPathURL.Append( FileName );
+		aURL = aPathURL.GetMainURL( INetURLObject::NO_DECODE );
+	}
+	//liuchen 2009-12-16
+	uno::Reference< frame::XStorable > xStor( getModel(), uno::UNO_QUERY_THROW );
+
+	sal_Int32 aFileFormat = excel::XlFileFormat::xlExcel9795;		
+	FileFormat >>= aFileFormat;		
+
+	if (  FileName.indexOf('.') == -1 )
+	{
+		if ( aFileFormat == excel::XlFileFormat::xlExcel9795 )
+		{
+			aURL = aURL + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".xls" ) );
+		}
+		else if ( aFileFormat == excel::XlFileFormat::xlCSV )
+		{
+			aURL = aURL + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".csv" ) );
+		}
+	}	
+
+	uno::Sequence<  beans::PropertyValue > storeProps(1);
+	storeProps[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "FilterName" ) );
+	storeProps[0].Value <<= convertFileFormat(aFileFormat);
+
+	xStor->storeAsURL( aURL, storeProps );
+}
+
 css::uno::Any SAL_CALL 
 ScVbaWorkbook::Styles( const::uno::Any& Item ) throw (uno::RuntimeException)
 {
diff --git sc/source/ui/vba/vbaworkbook.hxx sc/source/ui/vba/vbaworkbook.hxx
index 36ce6ed..eac6df1 100644
--- sc/source/ui/vba/vbaworkbook.hxx
+++ sc/source/ui/vba/vbaworkbook.hxx
@@ -41,6 +41,8 @@ class ScVbaWorkbook : public ScVbaWorkbook_BASE
     static css::uno::Sequence< sal_Int32 > ColorData;
     void initColorData( const css::uno::Sequence< sal_Int32 >& sColors );
     void init();
+
+	::rtl::OUString convertFileFormat(sal_Int32 aFileFormat);
 protected:
 
     ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext);
@@ -61,20 +63,25 @@ public:
     virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
     // Amelia Wang
     virtual css::uno::Any SAL_CALL Names( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
     virtual css::uno::Any SAL_CALL Styles( const css::uno::Any& Item ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL ResetColors(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Colors( const css::uno::Any& Index ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL FileFormat(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getFileFormat(  ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL SaveCopyAs( const rtl::OUString& Filename ) throw ( css::uno::RuntimeException);
+	virtual void SAL_CALL SaveAs( const rtl::OUString& FileName, const css::uno::Any& FileFormat, const css::uno::Any& CreateBackup ) throw (css::uno::RuntimeException);
+
     // code name
     virtual ::rtl::OUString SAL_CALL getCodeName() throw ( css::uno::RuntimeException);
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	virtual css::uno::Reference< css::frame::XModel >  getDocModel() { return mxModel; }
 };
 
 #endif /* SC_VBA_WORKBOOK_HXX */
diff --git sc/source/ui/vba/vbaworksheet.cxx sc/source/ui/vba/vbaworksheet.cxx
index c09e229..60b7bf6 100644
--- sc/source/ui/vba/vbaworksheet.cxx
+++ sc/source/ui/vba/vbaworksheet.cxx
@@ -62,6 +62,7 @@
 #include <ooo/vba/excel/XlEnableSelection.hpp>
 #include <ooo/vba/excel/XWorkbook.hpp>
 #include <ooo/vba/XControlProvider.hpp>
+#include <ooo/vba/excel/XlSheetVisibility.hpp>
 
 #include <comphelper/processfactory.hxx>
 #include <vbahelper/vbashapes.hxx>
@@ -79,7 +80,7 @@
 
 #include "cellsuno.hxx"
 #include "drwlayer.hxx"
-
+#include "tabprotection.hxx"
 #include "scextopt.hxx"
 #include "vbaoutline.hxx"
 #include "vbarange.hxx"
@@ -93,6 +94,7 @@
 #include "vbaworksheets.hxx"
 #include "vbahyperlinks.hxx"
 #include "vbasheetobjects.hxx"
+#include "viewuno.hxx" //liuchen 2009-9-2
 
 #define STANDARDWIDTH 2267
 #define STANDARDHEIGHT 427
@@ -220,7 +222,7 @@ ScVbaWorksheet::setName(const ::rtl::OUString &rName ) throw (uno::RuntimeExcept
     xNamed->setName( rName );
 }
 
-sal_Bool
+::sal_Int32
 ScVbaWorksheet::getVisible() throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xProps( getSheet(), uno::UNO_QUERY_THROW );
@@ -228,13 +230,33 @@ ScVbaWorksheet::getVisible() throw (uno::RuntimeException)
             (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsVisible" ) ) );
     sal_Bool bRet = false;
     aValue >>= bRet;
-    return bRet;
+	if ( bRet )
+	{
+		return excel::XlSheetVisibility::xlSheetVisible;
+	}
+	else
+	{
+		return excel::XlSheetVisibility::xlSheetHidden;
+	}
 }
 
 void
-ScVbaWorksheet::setVisible( sal_Bool bVisible ) throw (uno::RuntimeException)
+ScVbaWorksheet::setVisible( ::sal_Int32 _Visible ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xProps( getSheet(), uno::UNO_QUERY_THROW );
+
+	//VBA by minz@cn.ibm.com.
+	sal_Bool bVisible = true;
+	switch( _Visible )
+	{
+		case excel::XlSheetVisibility::xlSheetHidden:
+		case excel::XlSheetVisibility::xlSheetVeryHidden:
+			bVisible = false;
+			break;
+		case excel::XlSheetVisibility::xlSheetVisible:
+			bVisible = true;
+			break;
+	}
     uno::Any aValue( bVisible );
     xProps->setPropertyValue
             (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsVisible" ) ), aValue);
@@ -392,6 +414,18 @@ ScVbaWorksheet::getProtectContents()throw (uno::RuntimeException)
 sal_Bool 
 ScVbaWorksheet::getProtectDrawingObjects() throw (uno::RuntimeException) 
 {
+    SCTAB nTab = 0;
+    rtl::OUString aSheetName = getName();
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+    bool bSheetExists = ScVbaWorksheets::nameExists (xSpreadDoc, aSheetName, nTab);
+    if ( bSheetExists )
+    {
+        uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+        if ( pProtect )
+            return pProtect->isOptionEnabled( ScTableProtection::OBJECTS ); 
+    }
     return sal_False;
 }
 
@@ -403,10 +437,30 @@ ScVbaWorksheet::Activate() throw (uno::RuntimeException)
     xSpreadsheet->setActiveSheet(getSheet());	
 }
 
+//liuchen 2009-9-2, support expand (but not replace) the active sheet
 void
-ScVbaWorksheet::Select() throw (uno::RuntimeException)
-{
-    Activate();
+ScVbaWorksheet::Select(const css::uno::Any& aReplace) throw (uno::RuntimeException) 
+{	
+	sal_Bool bReplace = true;
+	if (aReplace.hasValue() && aReplace.getValueTypeClass() == uno::TypeClass_BOOLEAN)
+	{
+		aReplace >>= bReplace;
+	}
+
+	uno::Reference< sheet::XSpreadsheetView > xSpreadsheet(
+        	getModel()->getCurrentController(), uno::UNO_QUERY_THROW );
+	ScTabViewObj* pTabView = static_cast< ScTabViewObj* >( xSpreadsheet.get() );
+
+	if (bReplace)
+	{
+		pTabView->selectSheet(getSheet(), false);
+	}
+	else
+	{
+		uno::Reference< sheet::XSpreadsheet > xOldActiveSheet = pTabView->getActiveSheet();
+		pTabView->selectSheet(getSheet(), true);
+		pTabView->selectSheet(xOldActiveSheet, true);
+	}		
 }
 
 void 
@@ -468,18 +522,42 @@ ScVbaWorksheet::Copy( const uno::Any& Before, const uno::Any& After ) throw (uno
         return;
     }
 
-    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY );
+    ScVbaWorksheet* pDestSheet = static_cast< ScVbaWorksheet* >(xSheet.get());
+    uno::Reference <sheet::XSpreadsheetDocument> xDestDoc( pDestSheet->getModel(), uno::UNO_QUERY );
+    uno::Reference <sheet::XSpreadsheetDocument> xSrcDoc( getModel(), uno::UNO_QUERY );
+
     SCTAB nDest = 0;
+    SCTAB nSrc = 0;
     rtl::OUString aSheetName = xSheet->getName();
-    if ( ScVbaWorksheets::nameExists (xSpreadDoc, aSheetName, nDest ) )
+    bool bSameDoc = ( pDestSheet->getModel() == getModel() );
+    bool bDestSheetExists = ScVbaWorksheets::nameExists (xDestDoc, aSheetName, nDest );
+    bool bSheetExists = ScVbaWorksheets::nameExists (xSrcDoc, aCurrSheetName, nSrc );
+
+    // set sheet name to be newSheet name
+    aSheetName = aCurrSheetName;
+    SCTAB nDummy=0;
+    if ( bSheetExists && bDestSheetExists )
     {
         sal_Bool bAfter = After.hasValue();
         if(bAfter)
               nDest++;
-        uno::Reference<sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
-        getNewSpreadsheetName(aSheetName,aCurrSheetName,xSpreadDoc);
-        xSheets->copyByName(aCurrSheetName,aSheetName,nDest);
+        uno::Reference<sheet::XSpreadsheets> xSheets = xDestDoc->getSheets();
+        if ( bSameDoc || ScVbaWorksheets::nameExists( xDestDoc, aCurrSheetName, nDummy ) )
+            getNewSpreadsheetName(aSheetName,aCurrSheetName,xDestDoc);
+        if ( bSameDoc )
+            xSheets->copyByName(aCurrSheetName,aSheetName,nDest);
+        else
+        {
+            ScDocShell* pDestDocShell = excel::getDocShell( pDestSheet->getModel() );
+            ScDocShell* pSrcDocShell = excel::getDocShell( getModel() );
+            if ( pDestDocShell && pSrcDocShell )
+                pDestDocShell->TransferTab( *pSrcDocShell, static_cast<SCTAB>(nSrc), static_cast<SCTAB>(nDest), TRUE, TRUE );
+        }
     }
+    // active the new sheet
+    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XWorksheet > xNewSheet( xApplication->Worksheets( uno::makeAny( aSheetName ) ), uno::UNO_QUERY_THROW );
+    xNewSheet->Activate();
 }
 
 
@@ -531,13 +609,25 @@ ScVbaWorksheet::getSheetAtOffset(SCTAB offset) throw (uno::RuntimeException)
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getNext() throw (uno::RuntimeException)
 {
-    return getSheetAtOffset(static_cast<SCTAB>(1));
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(static_cast<SCTAB>(1));
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getPrevious() throw (uno::RuntimeException)
 {
-    return getSheetAtOffset(-1);
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(-1);
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 
@@ -621,7 +711,7 @@ ScVbaWorksheet::ChartObjects( const uno::Any& Index ) throw (uno::RuntimeExcepti
         uno::Reference< table::XTableChartsSupplier > xChartSupplier( getSheet(), uno::UNO_QUERY_THROW );
         uno::Reference< table::XTableCharts > xTableCharts = xChartSupplier->getCharts();
         
-        uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( getSheet(), uno::UNO_QUERY_THROW ); //VBA, minz@cn.ibm.com.
         mxCharts = new ScVbaChartObjects(  this, mxContext, xTableCharts, xDrawPageSupplier );
     }
     if ( Index.hasValue() )
@@ -940,7 +1030,7 @@ ScVbaWorksheet::getCodeName() throw (css::uno::RuntimeException)
 sal_Int16
 ScVbaWorksheet::getSheetID() throw (uno::RuntimeException)
 {
-    uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxSheet, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( getSheet(), uno::UNO_QUERY_THROW ); //VBA. minz@cn.ibm.com. if ActiveSheet, mxSheet is null.
     return xAddressable->getRangeAddress().Sheet;
 }
 
diff --git sc/source/ui/vba/vbaworksheet.hxx sc/source/ui/vba/vbaworksheet.hxx
index 4c730ab..cfa88cd 100644
--- sc/source/ui/vba/vbaworksheet.hxx
+++ sc/source/ui/vba/vbaworksheet.hxx
@@ -42,6 +42,7 @@
 #include <ooo/vba/excel/XPageSetup.hpp>
 #include <ooo/vba/excel/XHPageBreaks.hpp>
 #include <ooo/vba/excel/XVPageBreaks.hpp>
+#include <com/sun/star/container/XNamed.hpp>
 
 #include <vbahelper/vbahelperinterface.hxx>
 #include "address.hxx"
@@ -85,8 +86,8 @@ public:
     // Attributes 
     virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setName( const ::rtl::OUString &rName ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool bVisible ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( ::sal_Int32 _Visible ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getStandardWidth() throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getStandardHeight() throw (css::uno::RuntimeException);
     virtual ::sal_Bool SAL_CALL getProtectionMode() throw (css::uno::RuntimeException);
@@ -109,7 +113,7 @@ public:
 
     // Methods
     virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select(const css::uno::Any& aReplace) throw (css::uno::RuntimeException); //liuchen 2009-9-2, add the input parameter to support expand selection
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Range( const css::uno::Any& Cell1, const css::uno::Any& Cell2 ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Move( const css::uno::Any& Before, const css::uno::Any& After ) throw (css::uno::RuntimeException) ;
      virtual void SAL_CALL Copy( const css::uno::Any& Before, const css::uno::Any& After ) throw (css::uno::RuntimeException);
diff --git sc/source/ui/vba/vbawsfunction.cxx sc/source/ui/vba/vbawsfunction.cxx
index 008b969..f65ef51 100644
--- sc/source/ui/vba/vbawsfunction.cxx
+++ sc/source/ui/vba/vbawsfunction.cxx
@@ -60,6 +60,18 @@ void lclConvertDoubleToBoolean( uno::Any& rAny )
     }
 }
 
+void lclConvertBooleanToDouble( uno::Any& rAny )
+{
+    sal_Bool bValue( sal_False );
+    if ( rAny >>= bValue )
+    {
+        if ( bValue )
+           rAny <<= double( 1.0 );
+        else
+           rAny <<= double( 0.0 );
+    }
+}
+
 } // namespace
 
 ScVbaWSFunction::ScVbaWSFunction( const uno::Reference< XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) :
@@ -84,9 +96,57 @@ ScVbaWSFunction::invoke(const rtl::OUString& FunctionName, const uno::Sequence<
         uno::Any* pArrayEnd = pArray + aParamTemp.getLength();
         for( ; pArray < pArrayEnd; ++pArray )
         {
-            uno::Reference< excel::XRange > myRange( *pArray, uno::UNO_QUERY );
-            if( myRange.is() )
-                *pArray = myRange->getCellRange();
+            switch( pArray->getValueType().getTypeClass()  )
+            {
+                case uno::TypeClass_BOOLEAN:
+                    lclConvertBooleanToDouble( *pArray );
+                    break;
+                case uno::TypeClass_INTERFACE:
+                {
+                    uno::Reference< excel::XRange > myRange( *pArray, uno::UNO_QUERY );
+                    if( myRange.is() )
+                        *pArray = myRange->getCellRange();
+                }
+                    break; 
+                case uno::TypeClass_SEQUENCE:
+                {
+                    // the sheet.FunctionAccess service doesn't deal with Sequences, only Sequences of Sequence
+                    uno::Type aType = pArray->getValueType();
+                    if ( aType.equals( getCppuType( (uno::Sequence<sal_Int16>*)0 ) ) )
+                    {
+                        uno::Sequence< uno::Sequence< sal_Int16 > >  aTmp(1);
+                        (*pArray) >>= aTmp[ 0 ];
+                        (*pArray) <<= aTmp;
+                    }
+                    else if ( aType.equals( getCppuType( (uno::Sequence<sal_Int32>*)0 ) ) )
+                    {
+                        uno::Sequence< uno::Sequence< sal_Int32 > > aTmp(1);
+                        (*pArray) >>= aTmp[ 0 ];
+                        (*pArray) <<= aTmp;
+                    }
+                    else if ( aType.equals( getCppuType( (uno::Sequence<double>*)0 ) ) )
+                    {
+                        uno::Sequence< uno::Sequence< double > > aTmp(1);
+                        (*pArray) >>= aTmp[ 0 ];
+                        (*pArray) <<= aTmp;
+                    }
+                    else if ( aType.equals( getCppuType( (uno::Sequence<rtl::OUString>*)0 ) ) )
+                    {
+                        uno::Sequence< uno::Sequence< rtl::OUString > > aTmp(1);
+                        (*pArray) >>= aTmp[ 0 ];
+                        (*pArray) <<= aTmp;
+                    }
+                    else if ( aType.equals( getCppuType( (uno::Sequence<uno::Any>*)0 ) ) )
+                    {
+                        uno::Sequence< uno::Sequence<uno::Any > > aTmp(1);
+                        (*pArray) >>= aTmp[ 0 ];
+                        (*pArray) <<= aTmp;
+                    }
+                }
+                    break;
+                default:
+                    break;
+            }
             OSL_TRACE("Param[%d] is %s", (int)(pArray - aParamTemp.getConstArray()), rtl::OUStringToOString( comphelper::anyToString( *pArray ), RTL_TEXTENCODING_UTF8 ).getStr() );
         }
     }
diff --git sc/source/ui/view/cellsh2.cxx sc/source/ui/view/cellsh2.cxx
index 3908596..f4ba3d5 100644
--- sc/source/ui/view/cellsh2.cxx
+++ sc/source/ui/view/cellsh2.cxx
@@ -345,6 +345,20 @@ void ScCellShell::ExecuteDB( SfxRequest& rReq )
             }
             break;
 
+		case SID_DATA_FORM:
+			{
+				ScAbstractDialogFactory* pFact = ScAbstractDialogFactory::Create();
+	            DBG_ASSERT(pFact, "ScAbstractFactory create fail!");//CHINA001
+
+	            AbstractScDataFormDlg* pDlg = pFact->CreateScDataFormDlg( pTabViewShell->GetDialogParent(),RID_SCDLG_DATAFORM, pTabViewShell);
+	            DBG_ASSERT(pDlg, "Dialog create fail!");//CHINA001
+
+	            pDlg->Execute();
+	            
+				rReq.Done();
+			}
+			break;
+			
         case SID_SUBTOTALS:
             {
                 const SfxItemSet* pArgs = rReq.GetArgs();
diff --git sc/source/ui/view/gridwin5.cxx sc/source/ui/view/gridwin5.cxx
index 821d5da..d9e10ef 100644
--- sc/source/ui/view/gridwin5.cxx
+++ sc/source/ui/view/gridwin5.cxx
@@ -343,14 +343,12 @@ void ScGridWindow::RequestHelp(const HelpEvent& rHEvt)
                                     if ( pDrView->PickObj(aMDPos, pDrView->getHitTolLog(), pHit, pPV, SDRSEARCH_DEEP ) )
                                         pObj = pHit;
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
                             if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
                             {
                                 aPixRect = LogicToPixel(aVEvt.pObj->GetLogicRect());
                                 aHelpText = pInfo->GetHlink();
                             }
-#endif
                         }
                     }
                 }
diff --git sc/source/ui/view/tabview3.cxx sc/source/ui/view/tabview3.cxx
index 961f526..355f741 100644
--- sc/source/ui/view/tabview3.cxx
+++ sc/source/ui/view/tabview3.cxx
@@ -1419,10 +1419,12 @@ void ScTabView::MarkRange( const ScRange& rRange, BOOL bSetCursor, BOOL bContinu
     {
         SCCOL nAlignX = rRange.aStart.Col();
         SCROW nAlignY = rRange.aStart.Row();
-        if ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL )
-            nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
-        if ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW )
-            nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
+		bool bCol = ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL ) && !aViewData.GetDocument()->IsInVBAMode();
+		bool bRow = ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW );
+		if ( bCol ) 
+			nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
+		if ( bRow )
+			nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
         AlignToCursor( nAlignX, nAlignY, SC_FOLLOW_JUMP );
     }
     InitBlockMode( rRange.aStart.Col(), rRange.aStart.Row(), nTab );
@@ -1535,6 +1537,7 @@ void ScTabView::SetTabNo( SCTAB nTab, BOOL bNew, BOOL bExtendSelection )
                                         //	nicht InputEnterHandler wegen Referenzeingabe !
 
         ScDocument* pDoc = aViewData.GetDocument();
+			
         pDoc->MakeTable( nTab );
 
         // Update pending row heights before switching the sheet, so Reschedule from the progress bar
diff --git sc/source/ui/view/tabvwsh4.cxx sc/source/ui/view/tabvwsh4.cxx
index 095a6f3..43dd17a 100644
--- sc/source/ui/view/tabvwsh4.cxx
+++ sc/source/ui/view/tabvwsh4.cxx
@@ -1799,6 +1799,13 @@ void ScTabViewShell::Construct( BYTE nForceDesignMode )
             if ( pDocSh->GetCreateMode() != SFX_CREATE_MODE_EMBEDDED )
             {
                 SCTAB nInitTabCount = 3;							//!	konfigurierbar !!!
+				// Get the customized initial tab count, we only can set the count by VBA API currently.
+				const ScAppOptions& rAppOpt = SC_MOD()->GetAppOptions();
+				SCTAB nNewTabCount = rAppOpt.GetTabCountInNewSpreadsheet();
+				if ( nNewTabCount >= 1 && nNewTabCount <= MAXTAB )
+				{
+					nInitTabCount = nNewTabCount;
+				}
                 for (SCTAB i=1; i<nInitTabCount; i++)
                     pDoc->MakeTable(i,false);
             }
diff --git sc/source/ui/view/viewfun2.cxx sc/source/ui/view/viewfun2.cxx
index c341e8e..145ad8e 100644
--- sc/source/ui/view/viewfun2.cxx
+++ sc/source/ui/view/viewfun2.cxx
@@ -52,6 +52,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2223,6 +2228,8 @@ BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
     WaitObject aWait( GetFrameWin() );
     if (bRecord && !pDoc->IsUndoEnabled())
         bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
     while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
         --nNewTab;
@@ -2330,6 +2337,7 @@ BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
         pDocSh->PostPaintExtras();
         pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
@@ -2474,8 +2482,8 @@ void ScViewFunc::ImportTables( ScDocShell* pSrcShell,
     {
         SCTAB nSrcTab = pSrcTabs[i];
         SCTAB nDestTab1=nTab+i;
-        ULONG nErrVal = pDoc->TransferTab( pSrcDoc, nSrcTab, nDestTab1,
-            FALSE );		// no insert
+        ULONG nErrVal = pDocSh->TransferTab( *pSrcShell, nSrcTab, nDestTab1,
+            FALSE, FALSE );		// no insert
 
         switch (nErrVal)
         {
@@ -2493,25 +2501,6 @@ void ScViewFunc::ImportTables( ScDocShell* pSrcShell,
                 break;
         }
 
-        // TransferTab doesn't copy drawing objects with bInsertNew=FALSE
-        if ( !bError )
-            pDoc->TransferDrawPage( pSrcDoc, nSrcTab, nDestTab1 );
-
-        if(!bError &&pSrcDoc->IsScenario(nSrcTab))
-        {
-            String aComment;
-            Color  aColor;
-            USHORT nFlags;
-
-            pSrcDoc->GetScenarioData(nSrcTab, aComment,aColor, nFlags);
-            pDoc->SetScenario( nDestTab1,TRUE);
-            pDoc->SetScenarioData( nTab+i,aComment,aColor,nFlags);
-            BOOL bActive = pSrcDoc->IsActiveScenario(nSrcTab );
-            pDoc->SetActiveScenario( nDestTab1, bActive );
-            BOOL bVisible=pSrcDoc->IsVisible(nSrcTab);
-            pDoc->SetVisible(nDestTab1,bVisible );
-
-        }
     }
 
     if (bLink)
@@ -2695,33 +2684,7 @@ void ScViewFunc::MoveTable( USHORT nDestDocNo, SCTAB nDestTab, BOOL bCopy )
             nDestTab1 = nDestTab;
             for(USHORT i=0;i<TheTabs.Count();i++)
             {
-                nErrVal = pDestDoc->TransferTab( pDoc, TheTabs[i], nDestTab1,
-                    FALSE );		// no insert
-
-                // TransferTab doesn't copy drawing objects with bInsertNew=FALSE
-                if ( nErrVal > 0 )
-                    pDestDoc->TransferDrawPage( pDoc, TheTabs[i], nDestTab1 );
-
-                if(nErrVal>0 && pDoc->IsScenario(TheTabs[i]))
-                {
-                    String aComment;
-                    Color  aColor;
-                    USHORT nFlags;
-
-                    pDoc->GetScenarioData(TheTabs[i], aComment,aColor, nFlags);
-                    pDestDoc->SetScenario(nDestTab1,TRUE);
-                    pDestDoc->SetScenarioData(nDestTab1,aComment,aColor,nFlags);
-                    BOOL bActive = pDoc->IsActiveScenario(TheTabs[i]);
-                    pDestDoc->SetActiveScenario(nDestTab1, bActive );
-
-                    BOOL bVisible=pDoc->IsVisible(TheTabs[i]);
-                    pDestDoc->SetVisible(nDestTab1,bVisible );
-
-                }
-
-                if ( nErrVal > 0 && pDoc->IsTabProtected( TheTabs[i] ) )
-                    pDestDoc->SetTabProtection(nDestTab1, pDoc->GetTabProtection(TheTabs[i]));
-
+                nErrVal = pDestShell->TransferTab( *pDocShell, static_cast<SCTAB>(TheTabs[i]), static_cast<SCTAB>(nDestTab1), FALSE, FALSE );
                 nDestTab1++;
             }
         }
diff --git sc/source/ui/view/viewfun3.cxx sc/source/ui/view/viewfun3.cxx
index 8fc5acd..4c353f0 100644
--- sc/source/ui/view/viewfun3.cxx
+++ sc/source/ui/view/viewfun3.cxx
@@ -210,6 +210,7 @@
 #include "drwtrans.hxx"
 #include "docuno.hxx"
 #include "clipparam.hxx"
+#include "undodat.hxx"   // Amelia Wang
 
 using namespace com::sun::star;
 
@@ -1784,6 +1785,85 @@ BOOL ScViewFunc::LinkBlock( const ScRange& rSource, const ScAddress& rDestPos, B
     return TRUE;
 }
 
+void ScViewFunc::DataFormPutData( SCROW nCurrentRow ,
+                                  SCROW nStartRow , SCCOL nStartCol ,
+                                  SCROW nEndRow , SCCOL nEndCol ,
+                                  Edit** pEdits ,
+                                  sal_uInt16 aColLength )
+{
+    ScDocument* pDoc = GetViewData()->GetDocument();
+    ScDocShell* pDocSh = GetViewData()->GetDocShell();
+    ScMarkData& rMark = GetViewData()->GetMarkData();
+    ScDocShellModificator aModificator( *pDocSh );
+    SfxUndoManager* pUndoMgr = pDocSh->GetUndoManager();
+    if ( pDoc )
+    {
+        const BOOL bRecord( pDoc->IsUndoEnabled());
+        ScDocument* pUndoDoc = NULL;
+        ScDocument* pRedoDoc = NULL;
+        ScDocument* pRefUndoDoc = NULL;
+        ScRefUndoData* pUndoData = NULL;
+        SCTAB nTab = GetViewData()->GetTabNo();
+        SCTAB nStartTab = nTab;
+        SCTAB nEndTab = nTab;
+        
+        {
+                ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+                if ( pChangeTrack )
+                        pChangeTrack->ResetLastCut();   // kein CutMode mehr
+        }
+        ScRange aUserRange( nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );
+        BOOL bColInfo = ( nStartRow==0 && nEndRow==MAXROW );
+        BOOL bRowInfo = ( nStartCol==0 && nEndCol==MAXCOL );
+        SCCOL nUndoEndCol = nStartCol+aColLength-1;
+        SCROW nUndoEndRow = nCurrentRow;
+        USHORT nUndoFlags = IDF_NONE;
+
+        if ( bRecord )
+        {
+            pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pUndoDoc->InitUndoSelected( pDoc , rMark , bColInfo , bRowInfo );
+            pDoc->CopyToDocument( aUserRange , 1 , FALSE , pUndoDoc );
+        }
+        USHORT nExtFlags = 0;
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nStartRow, nStartTab , nEndCol, nEndRow, nEndTab ); // content before the change
+        //rMark.SetMarkArea( aUserRange );
+        pDoc->BeginDrawUndo();
+        
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+        {
+            if (pEdits[i])
+            {
+                String  aFieldName=pEdits[i]->GetText();
+                pDoc->SetString( nStartCol + i, nCurrentRow, nTab, aFieldName );
+            }
+        }
+        //pDoc->ExtendMergeSel( nStartCol, nStartRow, nEndCol, nEndRow, rMark, TRUE );    // Refresh
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );  // content after the change
+        SfxUndoAction* pUndo = new ScUndoDataForm( pDocSh,
+                                                                nStartCol, nCurrentRow, nStartTab,
+                                                                nUndoEndCol, nUndoEndRow, nEndTab, rMark,
+                                                                pUndoDoc, pRedoDoc, nUndoFlags,
+                                                                pUndoData, NULL, NULL, NULL,
+                                                                FALSE );           // FALSE = Redo data not yet copied
+        pUndoMgr->AddUndoAction( new ScUndoWrapper( pUndo ), TRUE );
+        
+        USHORT nPaint = PAINT_GRID;
+        if (bColInfo)
+        {
+                nPaint |= PAINT_TOP;
+                nUndoEndCol = MAXCOL;                           // nur zum Zeichnen !
+        }
+        if (bRowInfo)
+        {
+                nPaint |= PAINT_LEFT;
+                nUndoEndRow = MAXROW;                           // nur zum Zeichnen !
+        }
 
+        pDocSh->PostPaint( nStartCol, nCurrentRow, nStartTab,
+                                                nUndoEndCol, nUndoEndRow, nEndTab, nPaint, nExtFlags );
+        pDocSh->UpdateOle(GetViewData());
+    }
+}
 
 
diff --git sc/uiconfig/scalc/menubar/menubar.xml sc/uiconfig/scalc/menubar/menubar.xml
index 959e538..3624c29 100644
--- sc/uiconfig/scalc/menubar/menubar.xml
+++ sc/uiconfig/scalc/menubar/menubar.xml
@@ -404,6 +404,7 @@
                     <menu:menuitem menu:id=".uno:DataFilterHideAutoFilter"/>
                 </menu:menupopup>
             </menu:menu>
+			<menu:menuitem menu:id=".uno:DataForm"/>
             <menu:menuitem menu:id=".uno:DataSubTotals"/>
             <menu:menuitem menu:id=".uno:Validation"/>
             <menu:menuseparator/>
diff --git sc/util/makefile.mk sc/util/makefile.mk
index 980d271..8c0f1e0 100644
--- sc/util/makefile.mk
+++ sc/util/makefile.mk
@@ -273,6 +273,7 @@ LIB8OBJFILES = \
         $(SLO)$/filldlg.obj			\
         $(SLO)$/delcodlg.obj		\
         $(SLO)$/delcldlg.obj		\
+		$(SLO)$/datafdlg.obj		\
         $(SLO)$/dapitype.obj	\
         $(SLO)$/dapidata.obj	\
         $(SLO)$/crdlg.obj			\
@@ -316,7 +317,8 @@ SHL9STDLIBS= \
         $(VCLLIB) \
         $(TKLIB) \
         $(MSFILTERLIB)		\
-        $(FORLIB)
+        $(FORLIB) \
+        $(UNOTOOLSLIB)       
 
 SHL9DEPN=$(SHL1TARGETN) $(SHL8TARGETN)
 SHL9LIBS=$(SLB)$/$(TARGET_VBA).lib
diff --git scripting/source/basprov/basprov.cxx scripting/source/basprov/basprov.cxx
index c616371..1fd2f21 100644
--- scripting/source/basprov/basprov.cxx
+++ scripting/source/basprov/basprov.cxx
@@ -371,7 +371,33 @@ namespace basprov
             ::rtl::OUString::createFromAscii( "location" ) );
 
         sal_Int32 nIndex = 0;
-        ::rtl::OUString aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
+        // In some strange circumstances the Library name can have an 
+        // apparantly illegal '.' in it ( in imported VBA )
+     
+        BasicManager* pBasicMgr =  NULL;
+        if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
+        {
+            pBasicMgr = m_pDocBasicManager;
+        }
+        else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
+        {
+            pBasicMgr = m_pAppBasicManager;
+        }
+        rtl::OUString sProjectName;
+        if (  pBasicMgr )
+            sProjectName = pBasicMgr->GetName();
+
+        ::rtl::OUString aLibrary;
+        if ( sProjectName.getLength() && aDescription.match( sProjectName ) )
+        {
+            OSL_TRACE("LibraryName %s is part of the url %s",
+                rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr(),
+                rtl::OUStringToOString( aDescription, RTL_TEXTENCODING_UTF8 ).getStr() );
+            aLibrary = sProjectName;            
+            nIndex = sProjectName.getLength() + 1;
+        }
+        else
+            aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
         ::rtl::OUString aModule;
         if ( nIndex != -1 )
             aModule = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
@@ -381,15 +407,6 @@ namespace basprov
 
         if ( aLibrary.getLength() != 0 && aModule.getLength() != 0 && aMethod.getLength() != 0 && aLocation.getLength() != 0 )
         {
-            BasicManager* pBasicMgr =  NULL;
-            if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
-            {
-                pBasicMgr = m_pDocBasicManager;
-            }
-            else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
-            {
-                pBasicMgr = m_pAppBasicManager;
-            }
 
             if ( pBasicMgr )
             {
diff --git scripting/source/basprov/basscript.cxx scripting/source/basprov/basscript.cxx
index 620e249..e99a346 100644
--- scripting/source/basprov/basscript.cxx
+++ scripting/source/basprov/basscript.cxx
@@ -36,7 +36,10 @@
 #include <basic/sbmeth.hxx>
 #include <basic/basmgr.hxx>
 #include <com/sun/star/script/provider/ScriptFrameworkErrorType.hpp>
-
+#include "bcholder.hxx"
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <map>
 
 
@@ -45,6 +48,7 @@ using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
 
 extern ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any& aValue );
@@ -54,6 +58,10 @@ extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any&
 namespace basprov
 {
 //.........................................................................
+#define BASSCRIPT_PROPERTY_ID_CALLER         1
+#define BASSCRIPT_PROPERTY_CALLER            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Caller" ) )
+
+#define BASSCRIPT_DEFAULT_ATTRIBS()       PropertyAttribute::BOUND | PropertyAttribute::TRANSIENT
 
     typedef ::std::map< sal_Int16, Any, ::std::less< sal_Int16 > > OutParamMap;
 
@@ -64,22 +72,28 @@ namespace basprov
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod )
-        :m_xMethod( xMethod )
+        : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( NULL )
         ,m_xDocumentScriptContext()
     {
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod,
-        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext )
-        :m_xMethod( xMethod )
+        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext ) : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( &documentBasicManager )
         ,m_xDocumentScriptContext( documentScriptContext )
     {
+	// 
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
@@ -88,6 +102,48 @@ namespace basprov
     }
 
     // -----------------------------------------------------------------------------
+    // XInterface
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XINTERFACE2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // XTypeProvider
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XTYPEPROVIDER2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // OPropertySetHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper& BasicScriptImpl::getInfoHelper(  )
+    {
+        return *getArrayHelper();
+    }
+
+    // -----------------------------------------------------------------------------
+    // OPropertyArrayUsageHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper* BasicScriptImpl::createArrayHelper(  ) const
+    {
+        Sequence< Property > aProps;
+        describeProperties( aProps );
+        return new ::cppu::OPropertyArrayHelper( aProps );
+    }
+
+    // -----------------------------------------------------------------------------
+    // XPropertySet
+    // -----------------------------------------------------------------------------
+
+    Reference< XPropertySetInfo > BasicScriptImpl::getPropertySetInfo(  ) throw (RuntimeException)
+    {
+        Reference< XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+        return xInfo;
+    }
+
+    // -----------------------------------------------------------------------------
     // XScript
     // -----------------------------------------------------------------------------
 
@@ -166,8 +222,14 @@ namespace basprov
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     aOldThisComponent = m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", makeAny( m_xDocumentScriptContext ) );
 
+            if ( m_caller.getLength() && m_caller[ 0 ].hasValue()  )
+            {
+                SbxVariableRef xCallerVar = new SbxVariable( SbxVARIANT );
+                unoToSbxValue( static_cast< SbxVariable* >( xCallerVar ), m_caller[ 0 ] );
+                nErr = m_xMethod->Call( xReturn, xCallerVar );
+            }
+            else
                 nErr = m_xMethod->Call( xReturn );
-
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", aOldThisComponent );
             }
diff --git scripting/source/basprov/basscript.hxx scripting/source/basprov/basscript.hxx
index a524c18..12ac0a0 100644
--- scripting/source/basprov/basscript.hxx
+++ scripting/source/basprov/basscript.hxx
@@ -28,12 +28,14 @@
 #ifndef SCRIPTING_BASSCRIPT_HXX
 #define SCRIPTING_BASSCRIPT_HXX
 
+#include "bcholder.hxx"
 #include <com/sun/star/script/provider/XScript.hpp>
 #include <com/sun/star/document/XScriptInvocationContext.hpp>
 #include <cppuhelper/implbase1.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
 #include <basic/sbmeth.hxx>
 
-
 class BasicManager;
 
 //.........................................................................
@@ -49,7 +51,11 @@ namespace basprov
         ::com::sun::star::script::provider::XScript > BasicScriptImpl_BASE;
 
 
-    class BasicScriptImpl : public BasicScriptImpl_BASE
+    class BasicScriptImpl : public BasicScriptImpl_BASE,
+                                public ::scripting_helper::OMutexHolder,
+                                public ::scripting_helper::OBroadcastHelperHolder,
+                                public ::comphelper::OPropertyContainer,
+                                public ::comphelper::OPropertyArrayUsageHelper< BasicScriptImpl >
     {
     private:
         SbMethodRef         m_xMethod;
@@ -57,6 +63,16 @@ namespace basprov
         BasicManager*       m_documentBasicManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::document::XScriptInvocationContext >
                             m_xDocumentScriptContext;
+        // hack, OPropertyContainer doesn't allow you to define a property of unknown
+        // type ( I guess because an Any can't contain an Any... I've always wondered why?
+	// as its not unusual to do that in corba )
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > m_caller;
+    protected:
+        // OPropertySetHelper
+        virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+        // OPropertyArrayUsageHelper
+        virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
 
     public:
         BasicScriptImpl(
@@ -71,6 +87,12 @@ namespace basprov
         );
         virtual ~BasicScriptImpl();
 
+        // XInterface
+        DECLARE_XINTERFACE()
+
+        // XTypeProvider
+        DECLARE_XTYPEPROVIDER()
+
         // XScript
         virtual ::com::sun::star::uno::Any SAL_CALL invoke(
             const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
@@ -80,6 +102,9 @@ namespace basprov
                     ::com::sun::star::script::provider::ScriptFrameworkErrorException, 
                     ::com::sun::star::reflection::InvocationTargetException,
                     ::com::sun::star::uno::RuntimeException );               
+        // XPropertySet
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) 
+            throw (::com::sun::star::uno::RuntimeException);
     };
 
 //.........................................................................
diff --git scripting/source/dlgprov/dlgevtatt.cxx scripting/source/dlgprov/dlgevtatt.cxx
index 11a1014..2d8c853 100644
--- scripting/source/dlgprov/dlgevtatt.cxx
+++ scripting/source/dlgprov/dlgevtatt.cxx
@@ -108,13 +108,14 @@ namespace dlgprov
     {
         protected:
         rtl::OUString msDialogCodeName;
+        rtl::OUString msDialogLibName;
         Reference<  script::XScriptListener > mxListener;
         virtual void firing_impl( const script::ScriptEvent& aScriptEvent, uno::Any* pRet );
         public:
-        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel );
+        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName );
     };
 
-    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel ) : DialogScriptListenerImpl( rxContext )
+    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName ) : DialogScriptListenerImpl( rxContext ), msDialogLibName( sDialogLibName )
     {
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
         Sequence< Any > args(1);
@@ -145,7 +146,7 @@ namespace dlgprov
         if ( aScriptEvent.ScriptType.equals( rtl::OUString::createFromAscii("VBAInterop") ) && mxListener.is() )
         {
             ScriptEvent aScriptEventCopy( aScriptEvent );
-            aScriptEventCopy.ScriptCode = msDialogCodeName;
+            aScriptEventCopy.ScriptCode = msDialogLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "." ) ) ).concat( msDialogCodeName );
             try
             {
                 mxListener->firing( aScriptEventCopy );
@@ -163,7 +164,7 @@ namespace dlgprov
     // DialogEventsAttacherImpl
     // =============================================================================
 
-    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener   )
+    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener, const rtl::OUString& sDialogLibName )
         :mbUseFakeVBAEvents( false ), m_xContext( rxContext )
     {
         // key listeners by protocol when ScriptType = 'Script'
@@ -186,11 +187,11 @@ namespace dlgprov
             {
                 pFoundShell = reinterpret_cast<SfxObjectShell*>( xObjShellTunnel->getSomething(SfxObjectShell::getUnoTunnelId()));
                 if ( pFoundShell )
-                    mbUseFakeVBAEvents = ooo::vba::isAlienExcelDoc( *pFoundShell );
+                    mbUseFakeVBAEvents = ooo::vba::isAlienExcelDoc( *pFoundShell ) || ooo::vba::isAlienWordDoc( *pFoundShell ) ;
             }
         }
         if ( mbUseFakeVBAEvents )
-            listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel );
+            listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel, sDialogLibName );
     }
 
     // -----------------------------------------------------------------------------
@@ -217,6 +218,7 @@ namespace dlgprov
             Reference< ooo::vba::XVBAToOOEventDescGen > xVBAToOOEvtDesc( xSMgr->createInstanceWithContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAToOOEventDesc" ) ), m_xContext ), UNO_QUERY );
             if ( xVBAToOOEvtDesc.is() )
                 xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl, sControlName ), UNO_QUERY );
+            
         }
         return xEventsSupplier;
     }
@@ -409,7 +411,7 @@ namespace dlgprov
 
     void DialogAllListenerImpl::firing( const AllEventObject& Event ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( Event, NULL );
     }
@@ -419,7 +421,7 @@ namespace dlgprov
     Any DialogAllListenerImpl::approveFiring( const AllEventObject& Event )
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( Event, &aReturn );
@@ -655,7 +657,7 @@ namespace dlgprov
 
     void DialogScriptListenerImpl::firing( const ScriptEvent& aScriptEvent ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( aScriptEvent, NULL );
     }
@@ -665,7 +667,7 @@ namespace dlgprov
     Any DialogScriptListenerImpl::approveFiring( const ScriptEvent& aScriptEvent )
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( aScriptEvent, &aReturn );
diff --git scripting/source/dlgprov/dlgevtatt.hxx scripting/source/dlgprov/dlgevtatt.hxx
index c76ee09..0df79b2 100644
--- scripting/source/dlgprov/dlgevtatt.hxx
+++ scripting/source/dlgprov/dlgevtatt.hxx
@@ -78,7 +78,7 @@ namespace dlgprov
              const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& xHandler, 
              const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& xIntrospect, 
              bool bProviderMode, 
-             const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener );
+        	 const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener ,const rtl::OUString& sDialogLibName );
         virtual ~DialogEventsAttacherImpl();
 
         // XScriptEventsAttacher
diff --git scripting/source/dlgprov/dlgprov.cxx scripting/source/dlgprov/dlgprov.cxx
index e9e1299..49b0b5f 100644
--- scripting/source/dlgprov/dlgprov.cxx
+++ scripting/source/dlgprov/dlgprov.cxx
@@ -189,7 +189,15 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
         Reference< beans::XPropertySet > xDlgPropSet( xDialogModel, UNO_QUERY );
         xDlgPropSet->setPropertyValue( aDlgSrcUrlPropName, aDialogSourceURL );
 
-        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext );
+        // #TODO we really need to detect the source of the Dialog, is it
+        // located in the document or not. m_xModel need not be the location of
+        // the dialog. E.g. if the dialog was created from basic ( then we just
+        // can't tell  where its from ) 
+        // If we are happy to always substitute the form model for the awt
+        // one then maybe the presence of a document model is enough to trigger
+        // swapping out the models ( or perhaps we only want to do this 
+        // for vba mode ) there are a number of feasible and valid possibilities
+        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext, m_xModel );
         // Set resource property
         if( xStringResourceManager.is() )
         {
@@ -403,6 +411,7 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
 
             if ( xISP.is() )
                 xInput = xISP->createInputStream();
+            msDialogLibName = sLibName;
         }
 
         // import dialog model
@@ -520,7 +529,7 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
         const Reference< XControl >& rxControl,
         const Reference< XInterface >& rxHandler,
         const Reference< XIntrospectionAccess >& rxIntrospectionAccess,
-        bool bDialogProviderMode )
+		bool bDialogProviderMode, const rtl::OUString& sDialogLibName )
     {
         if ( rxControl.is() )
         {
@@ -544,7 +553,7 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
 
                 Reference< XScriptEventsAttacher > xScriptEventsAttacher = new DialogEventsAttacherImpl
                     ( m_xContext, m_xModel, rxControl, rxHandler, rxIntrospectionAccess, 
-                      bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ) );
+					  bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ), msDialogLibName );
 
                 Any aHelper;
                 xScriptEventsAttacher->attachEvents( aObjects, Reference< XScriptListener >(), aHelper );
@@ -649,7 +658,10 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
             aArguments[0] >>= m_xModel;
             m_BasicInfo.reset( new BasicRTLParams() );
             m_BasicInfo->mxInput.set( aArguments[ 1 ], UNO_QUERY_THROW );
-            m_BasicInfo->mxDlgLib.set( aArguments[ 2 ], UNO_QUERY_THROW );
+            // allow null mxDlgLib, a document dialog instantiated from 
+            // from application basic is unable to provide ( or find ) it's
+            // Library
+            aArguments[ 2 ] >>= m_BasicInfo->mxDlgLib;
             // leave the possibility to optionally allow the old dialog creation
             // to use the new XScriptListener ( which converts the old style macro
             // to a SF url )
@@ -733,7 +745,7 @@ static ::rtl::OUString aResourceResolverPropName = ::rtl::OUString::createFromAs
             {
                 //xDialog = Reference< XDialog >( xCtrl, UNO_QUERY );
                 Reference< XIntrospectionAccess > xIntrospectionAccess = inspectHandler( xHandler );
-                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode );
+                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode, msDialogLibName );
             }
         }
 
diff --git scripting/source/dlgprov/dlgprov.hxx scripting/source/dlgprov/dlgprov.hxx
index 82faef2..e2aba36 100644
--- scripting/source/dlgprov/dlgprov.hxx
+++ scripting/source/dlgprov/dlgprov.hxx
@@ -81,9 +81,9 @@ namespace dlgprov
         ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >        m_xContext;
         ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >                 m_xModel;
 
-
+	rtl::OUString msDialogLibName;
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel > createDialogModel( const ::rtl::OUString& sURL );
-
+     
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl > createDialogControl( 
             const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& rxDialogModel,
             const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer >& xParent );
@@ -91,7 +91,7 @@ namespace dlgprov
         void attachControlEvents( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl >& rxControlContainer,
             const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler,
             const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& rxIntrospectionAccess,
-            bool bDialogProviderMode );
+			bool bDialogProviderMode, const rtl::OUString& );
         ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess > inspectHandler( 
             const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler );
     // helper methods
diff --git scripting/source/vbaevents/eventhelper.cxx scripting/source/vbaevents/eventhelper.cxx
index 6975fba..703357d 100644
--- scripting/source/vbaevents/eventhelper.cxx
+++ scripting/source/vbaevents/eventhelper.cxx
@@ -46,12 +46,17 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/lang/XInitialization.hpp>
 
+#include <com/sun/star/util/XCloseListener.hpp>
+#include <com/sun/star/util/XCloseBroadcaster.hpp>
+
 #include <com/sun/star/frame/XModel.hpp>
 
 #include <com/sun/star/script/XLibraryContainer.hpp>
 #include <com/sun/star/script/ScriptEventDescriptor.hpp>
 #include <com/sun/star/script/provider/XScriptProviderSupplier.hpp>
 
+#include <com/sun/star/container/XNamed.hpp>
+
 #include <com/sun/star/drawing/XControlShape.hpp>
 
 #include <com/sun/star/awt/XControl.hpp>
@@ -62,8 +67,9 @@
 #include <com/sun/star/awt/XTextComponent.hpp> //liuchen 2009-6-5
 #include <com/sun/star/awt/XComboBox.hpp> //liuchen 2009-6-18
 #include <com/sun/star/awt/XRadioButton.hpp> //liuchen 2009-7-30
+#include <com/sun/star/awt/XListBox.hpp> 
 
-#include <msforms/ReturnInteger.hpp>
+#include "vbamsformreturntypes.hxx"
 
 #include <sfx2/objsh.hxx>
 #include <basic/sbstar.hxx>
@@ -71,6 +77,7 @@
 #include <basic/sbmeth.hxx>
 #include <basic/sbmod.hxx>
 #include <basic/sbx.hxx>
+#include <filter/msfilter/msvbahelper.hxx>
 
 
 
@@ -82,12 +89,21 @@
 #include <com/sun/star/lang/XMultiComponentFactory.hpp>
 #include <com/sun/star/script/XScriptListener.hpp>
 #include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase2.hxx>
 #include <comphelper/evtmethodhelper.hxx>
 
 #include <set>
 #include <list>
 #include <hash_map>
+#define ASYNC 0
+
+// primitive support for asynchronous handling of 
+// events from controls ( all event will be processed asynchronously 
+// in the application thread )
+#if ASYNC
+#include <vcl/svapp.hxx>
+#endif
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::script;
@@ -189,6 +205,14 @@ bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
     return true;
 }
 
+bool isFocusEventOk( awt::FocusEvent& evt, const Sequence< Any >& params )
+{
+	if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
 Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
 {
     Sequence< Any > translatedParams;
@@ -232,9 +256,14 @@ Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
 
     translatedParams.realloc(1);
 
-    msforms::ReturnInteger keyCode;
-    keyCode.Value = evt.KeyCode; 
-    translatedParams[0] <<= keyCode;
+    //The VBA events such as ComboBox_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger) may cause an error because
+    //the original input parameter data structure -- msforms::ReturnInteger -- is a struct, it cannot support default value.
+    //So the newly defined VbaReturnIntege class is used here to support default value.
+    VbaReturnInteger* pKeyCode = new VbaReturnInteger();
+    pKeyCode->Value = evt.KeyChar; 
+    ::uno::Reference< msforms::XReturnInteger > xInteger = 
+		static_cast< ::uno::Reference< msforms::XReturnInteger > > (pKeyCode);   
+    translatedParams[0] <<= xInteger;
     return  translatedParams;
 }
 
@@ -248,16 +277,38 @@ Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
 
     translatedParams.realloc(2);
 
-    msforms::ReturnInteger keyCode;
-    sal_Int8 shift = sal::static_int_cast<sal_Int8>( evt.Modifiers );
-
-    // #TODO check whether values from OOO conform to values generated from vba
-    keyCode.Value = evt.KeyCode; 
-    translatedParams[0] <<= keyCode;
+    //The VBA events such as ComboBox_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger) may cause an error because
+    //the original input parameter data structure -- msforms::ReturnInteger -- is a struct, it cannot support default value.
+    //So the newly defined VbaReturnIntege class is used here to support default value.
+    VbaReturnInteger* pKeyCode = new VbaReturnInteger();
+    sal_Int8 shift = evt.Modifiers;
+    
+    pKeyCode->Value = evt.KeyChar; 
+    ::uno::Reference< msforms::XReturnInteger > xInteger =  static_cast< ::uno::Reference< msforms::XReturnInteger > > (pKeyCode);      
+    translatedParams[0] <<= xInteger;
     translatedParams[1] <<= shift;
     return  translatedParams;
 }
 
+Sequence< Any > ooFocusLostToVBAExit( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::FocusEvent evt;
+
+    if ( !isFocusEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    VbaReturnBoolean* pCancel = new VbaReturnBoolean();
+   
+    ::uno::Reference< msforms::XReturnBoolean > xBoolean= 
+		static_cast< ::uno::Reference< msforms::XReturnBoolean > > (pCancel);      
+    translatedParams[0] <<= xBoolean;
+    return  translatedParams;
+}
+
+
 typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
 
 //liuchen 2009-6-23
@@ -287,6 +338,7 @@ bool ApproveAll(const ScriptEvent& evt, void* pPara); //allow all types of contr
 bool ApproveType(const ScriptEvent& evt, void* pPara); //certain types of controls should execute the event, those types are given by pPara
 bool DenyType(const ScriptEvent& evt, void* pPara);    //certain types of controls should not execute the event, those types are given by pPara
 bool DenyMouseDrag(const ScriptEvent& evt, void* pPara); //used for VBA MouseMove event when "Shift" key is pressed
+bool DenyKeys(const ScriptEvent& evt, void* pPara);  //For some keys, press them will cause Symphony keyPressed event, but will not cause any events in Excel, so deny these key events
 
 struct TypeList
 {
@@ -294,28 +346,30 @@ struct TypeList
     int nListLength;
 };
 
-Type typeXFixedText = GET_TYPE(awt::XFixedText)
-Type typeXTextComponent = GET_TYPE(awt::XTextComponent)
-Type typeXComboBox = GET_TYPE(awt::XComboBox)
-Type typeXRadioButton = GET_TYPE(awt::XRadioButton)
+Type typeXFixedText = GET_TYPE(awt::XFixedText);
+Type typeXTextComponent = GET_TYPE(awt::XTextComponent);
+Type typeXComboBox = GET_TYPE(awt::XComboBox);
+Type typeXRadioButton = GET_TYPE(awt::XRadioButton);
+Type typeXListBox = GET_TYPE(awt::XListBox);
 
 
 TypeList fixedTextList = {&typeXFixedText, 1};
 TypeList textCompList = {&typeXTextComponent, 1};
 TypeList radioButtonList = {&typeXRadioButton, 1};
 TypeList comboBoxList = {&typeXComboBox, 1};
+TypeList listBoxList = {&typeXListBox, 1};
 
 //this array stores the OO event to VBA event translation info
 static TranslatePropMap aTranslatePropMap_Impl[] = 
 {
+	{ MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Change"), NULL, DenyType, (void*)(&radioButtonList) } },  //liuchen 2009-7-30, OptionalButton_Change event is not the same as OptionalButton_Click event
     // actionPerformed ooo event
     { MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Click"), NULL, ApproveAll, NULL } },	
-    { MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Change"), NULL, DenyType, (void*)(&radioButtonList) } },  //liuchen 2009-7-30, OptionalButton_Change event is not the same as OptionalButton_Click event
-
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveType, (void*)(&radioButtonList) } }, //liuchen 2009-7-30, OptionalButton_Change event should be triggered when the button state is changed
     // itemStateChanged ooo event
     { MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Click"), NULL, ApproveType, (void*)(&comboBoxList) } },  //liuchen, add to support VBA ComboBox_Click event
-    { MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveType, (void*)(&radioButtonList) } }, //liuchen 2009-7-30, OptionalButton_Change event should be triggered when the button state is changed
     
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Click"), NULL, ApproveType, (void*)(&listBoxList) } },
     // changed ooo event
     { MAP_CHAR_LEN("changed"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },	
 
@@ -324,7 +378,7 @@ static TranslatePropMap aTranslatePropMap_Impl[] =
 
     // focusLost ooo event
     { MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_LostFocus"), NULL, ApproveAll, NULL } },
-    { MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_Exit"), NULL, ApproveType, (void*)(&textCompList) } }, //liuchen, add to support VBA TextBox_Exit event
+	{ MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_Exit"), ooFocusLostToVBAExit, ApproveType, (void*)(&textCompList) } }, //liuchen, add to support VBA TextBox_Exit event
 
     // adjustmentValueChanged ooo event
     { MAP_CHAR_LEN("adjustmentValueChanged"), { MAP_CHAR_LEN("_Scroll"), NULL, ApproveAll, NULL } },
@@ -349,8 +403,8 @@ static TranslatePropMap aTranslatePropMap_Impl[] =
     { MAP_CHAR_LEN("mouseDragged"), { MAP_CHAR_LEN("_MouseMove"), ooMouseEvtToVBAMouseEvt, DenyMouseDrag, NULL } }, //liuchen, add to support VBA MouseMove event when the "Shift" key is pressed
 
     // keyPressed ooo event
-    { MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyDown"), ooKeyPressedToVBAKeyPressed, ApproveAll, NULL } },
-    { MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyPress"), ooKeyPressedToVBAKeyPressed, ApproveAll, NULL } }
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyDown"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyPress"), ooKeyPressedToVBAKeyUpDown, DenyKeys, NULL } }
 };
 
 EventInfoHash& getEventTransInfo()
@@ -632,7 +686,7 @@ private:
     Reference< container::XNameContainer > m_xNameContainer;
 };
 
-typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+typedef ::cppu::WeakImplHelper3< XScriptListener, util::XCloseListener, lang::XInitialization > EventListener_BASE;
 
 #define EVENTLSTNR_PROPERTY_ID_MODEL         1
 #define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
@@ -653,6 +707,9 @@ public:
     // XScriptListener
     virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
     virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XCloseListener
+    virtual void SAL_CALL queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException);
+    virtual void SAL_CALL notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException);
     // XPropertySet
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
     // XInitialization
@@ -664,6 +721,25 @@ public:
     DECLARE_XTYPEPROVIDER()
     virtual void SAL_CALL setFastPropertyValue( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::beans::PropertyVetoException, ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
     {
+        if ( nHandle == EVENTLSTNR_PROPERTY_ID_MODEL )
+        {
+            uno::Reference< frame::XModel > xModel( rValue, uno::UNO_QUERY );
+            if( xModel != m_xModel)
+            {
+                // Remove the listener from the old XCloseBroadcaster.
+                uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+                if (xCloseBroadcaster.is())
+                {
+                    xCloseBroadcaster->removeCloseListener( this );
+                }
+                // Add the listener into the new XCloseBroadcaster.
+                xCloseBroadcaster = uno::Reference< util::XCloseBroadcaster >( xModel, uno::UNO_QUERY );
+                if (xCloseBroadcaster.is())
+                {
+                    xCloseBroadcaster->addCloseListener( this );
+                }
+            }
+        }
         OPropertyContainer::setFastPropertyValue( nHandle, rValue );
     if ( nHandle == EVENTLSTNR_PROPERTY_ID_MODEL )
             setShellFromModel();
@@ -677,17 +753,21 @@ protected:
     virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
 
 private:
+#if ASYNC
+    DECL_LINK( OnAsyncScriptEvent, ScriptEvent* );
+#endif
     void setShellFromModel();
     void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
 
     Reference< XComponentContext > m_xContext;
     Reference< frame::XModel > m_xModel;
     SfxObjectShell* mpShell;
+    sal_Bool m_bDocClosed;
     
 };
 
 EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
-OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), mpShell( 0 )
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), m_bDocClosed(sal_False), mpShell( 0 )
 {
     registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
         beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
@@ -722,9 +802,39 @@ EventListener::disposing(const lang::EventObject&)  throw( RuntimeException )
 void SAL_CALL 
 EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
 {
+#if ASYNC
+    // needs some logic to check if the event handler is oneway or not
+    // if not oneway then firing_Impl otherwise... as below
+    acquire();
+    Application::PostUserEvent( LINK( this, EventListener, OnAsyncScriptEvent ), new ScriptEvent( evt ) );
+#else
     firing_Impl( evt );
+#endif
 }
 
+#if ASYNC
+IMPL_LINK( EventListener, OnAsyncScriptEvent, ScriptEvent*, _pEvent )
+{
+	if ( !_pEvent )
+		return 1L;
+
+	{
+		// #FIXME if we enable ASYNC we probably need something like 
+		// below
+		//::osl::ClearableMutexGuard aGuard( m_aMutex );
+
+		//if ( !impl_isDisposed_nothrow() )
+		//	impl_doFireScriptEvent_nothrow( aGuard, *_pEvent, NULL );
+		firing_Impl( *_pEvent, NULL );
+	}
+
+	delete _pEvent;
+	// we acquired ourself immediately before posting the event
+	release();
+	return 0L;
+ }
+#endif 
+
 Any SAL_CALL 
 EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
 {
@@ -733,6 +843,24 @@ EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::Invocatio
     return ret;
 }
 
+// XCloseListener
+void SAL_CALL 
+EventListener::queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException)
+{
+    //Nothing to do
+}
+
+void SAL_CALL 
+EventListener::notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+    m_bDocClosed = sal_True;
+    uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+    if (xCloseBroadcaster.is())
+    {
+        xCloseBroadcaster->removeCloseListener( this );
+    }
+}
+
 // XInitialization
 void SAL_CALL 
 EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
@@ -835,13 +963,28 @@ bool DenyMouseDrag(const ScriptEvent& evt, void* )
     }
 }
 
+//For some keys, press them will cause Symphony keyPressed event, but will not cause any events in Excel, so deny these key events
+bool DenyKeys(const ScriptEvent& evt, void* /*pPara*/)
+{	
+    awt::KeyEvent aEvent;
+	evt.Arguments[ 0 ] >>= aEvent;
+	if (aEvent.KeyChar == 0 || aEvent.KeyChar == 8)
+	{
+		return false;
+	}
+	else
+	{
+		return true;
+	}    
+}
+
 
 
 //liuchen 2009-6-23
 // EventListener
 
 void
-EventListener::firing_Impl(const ScriptEvent& evt, Any* /*pRet*/ ) throw(RuntimeException)
+EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeException)
 {
     OSL_TRACE("EventListener::firing_Impl( FAKE VBA_EVENTS )");
     static const ::rtl::OUString vbaInterOp =
@@ -852,18 +995,46 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* /*pRet*/ ) throw(Runtime
         return;
     lang::EventObject aEvent;
     evt.Arguments[ 0 ] >>= aEvent;
+	OSL_TRACE("evt.MethodName is  %s", rtl::OUStringToOString( evt.MethodName, RTL_TEXTENCODING_UTF8 ).getStr() );
     OSL_TRACE("Argument[0] is  %s", rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[0] ), RTL_TEXTENCODING_UTF8 ).getStr() );
     OSL_TRACE("Getting Control");
-    uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY_THROW );
-    OSL_TRACE("Getting properties");
-    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
-
     rtl::OUString sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm") );
     OSL_TRACE("Getting Name");
 
     uno::Reference< awt::XDialog > xDlg( aEvent.Source, uno::UNO_QUERY );
     if ( !xDlg.is() )
-        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+    {
+	OSL_TRACE("Getting Control");
+        // evt.Source is 
+        // a) Dialog
+        // b) xShapeControl ( from api (sheet control) )
+        // c) eventmanager ( I guess )
+        // d) vba control ( from api also ) 
+	uno::Reference< drawing::XControlShape > xCntrlShape( evt.Source, uno::UNO_QUERY );
+	uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY );
+	if ( xCntrlShape.is() )	      
+	{
+                // for sheet controls ( that fire from the api ) we don't
+                // have the real control ( thats only available from the view )
+                // api code creates just a control instance that is transferred
+                // via aEvent.Arguments[ 0 ] that control though has no
+                // info like name etc.
+		uno::Reference< drawing::XControlShape >  xCntrlShape( evt.Source, UNO_QUERY_THROW );
+		OSL_TRACE("Got control shape");
+		uno::Reference< container::XNamed > xName( xCntrlShape->getControl(), uno::UNO_QUERY_THROW );
+		OSL_TRACE("Got xnamed ");
+		sName = xName->getName();
+	}
+	else
+        {
+                // Userform control ( fired from the api or from event manager )
+		uno::Reference< beans::XPropertySet > xProps;
+		OSL_TRACE("Getting properties");
+        	xProps.set( xControl->getModel(), uno::UNO_QUERY_THROW );
+        	xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+	}
+
+    }
     //dumpEvent( evt );
     EventInfoHash& infos = getEventTransInfo();
     EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
@@ -885,20 +1056,49 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* /*pRet*/ ) throw(Runtime
         std::list< TranslateInfo >::const_iterator txInfo =
             eventInfo_it->second.begin();
         std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
-        rtl::OUString sMacroLoc = rtl::OUString::createFromAscii("Standard.").concat( evt.ScriptCode ).concat( rtl::OUString::createFromAscii(".") );
        
         StarBASIC* pBasic = mpShell->GetBasic();
-        SbModule* pModule = pBasic->FindModule( evt.ScriptCode );
-        for ( ; pModule && txInfo != txInfo_end; ++txInfo )
+        BasicManager* pBasicManager = mpShell->GetBasicManager();
+        rtl::OUString sProject;
+        rtl::OUString sScriptCode( evt.ScriptCode );
+	// dialogs pass their own library, presence of Dot determines that
+	if ( sScriptCode.indexOf( '.' ) == -1 )
+	{
+        	//'Project' is a better default but I want to force failures
+	        //rtl::OUString sMacroLoc = rtl::OUString::createFromAscii("Project");
+        	sProject = rtl::OUString::createFromAscii("Standard");
+
+        	if ( pBasicManager->GetName().Len() > 0 )
+            		sProject =  pBasicManager->GetName();
+	}
+	else
+	{
+		sal_Int32 nIndex = sScriptCode.indexOf( '.' );
+		sProject = sScriptCode.copy( 0, nIndex );
+                sScriptCode = sScriptCode.copy( nIndex + 1 );
+	}
+        rtl::OUString sMacroLoc = sProject;
+        sMacroLoc = sMacroLoc.concat(  rtl::OUString::createFromAscii(".") );
+        sMacroLoc = sMacroLoc.concat( sScriptCode ).concat( rtl::OUString::createFromAscii(".") );
+        
+        OSL_TRACE("sMacroLoc is %s", rtl::OUStringToOString( sMacroLoc, RTL_TEXTENCODING_UTF8 ).getStr() );
+        for ( ; txInfo != txInfo_end; ++txInfo )
         {
+            // If the document is closed, we should not execute macro.
+            if (m_bDocClosed)
+            {
+                break;
+            }
+			
+            rtl::OUString sTemp = sName.concat( (*txInfo).sVBAName ); 
             // see if we have a match for the handlerextension
             // where ScriptCode is methodname_handlerextension 
-            rtl::OUString sTemp = sName.concat( (*txInfo).sVBAName ); 
+            rtl::OUString sToResolve = sMacroLoc.concat( sTemp );
             
             OSL_TRACE("*** trying to invoke %s ",
-                rtl::OUStringToOString( sTemp, RTL_TEXTENCODING_UTF8 ).getStr() );
-            SbMethod* pMeth = static_cast< SbMethod* >( pModule->Find( sTemp, SbxCLASS_METHOD ) );
-            if ( pMeth )
+                rtl::OUStringToOString( sToResolve, RTL_TEXTENCODING_UTF8 ).getStr() );
+            ooo::vba::VBAMacroResolvedInfo aMacroResolvedInfo = ooo::vba::resolveVBAMacro( mpShell, sToResolve ); 
+            if ( aMacroResolvedInfo.IsResolved() )
             {
                 //liuchen 2009-6-8
                 if (! txInfo->ApproveRule(evt, txInfo->pPara) )
@@ -916,24 +1116,21 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* /*pRet*/ ) throw(Runtime
                 {
                     // call basic event handlers for event
 
-                    static rtl::OUString part1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
-                    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document"); 
-
                     // create script url
-                    rtl::OUString url = part1 + sMacroLoc + sTemp + part2;
+                    rtl::OUString url = aMacroResolvedInfo.ResolvedMacro();
                  
-                    OSL_TRACE("script url = %s",
+                    OSL_TRACE("resolved script = %s",
                         rtl::OUStringToOString( url, 
                             RTL_TEXTENCODING_UTF8 ).getStr() );
-                    Sequence< sal_Int16 > aOutArgsIndex;
-                    Sequence< Any > aOutArgs;
                     try
                     {
-                        if ( mpShell )
+                        uno::Any aDummyCaller = uno::makeAny( rtl::OUString::createFromAscii("Error") );
+                        if ( pRet )
+                            ooo::vba::executeMacro( mpShell, url, aArguments, *pRet, aDummyCaller ); 
+                        else
                         {
                             uno::Any aRet;
-                            mpShell->CallXScript( url,
-                                aArguments, aRet, aOutArgsIndex, aOutArgs, false );
+                            ooo::vba::executeMacro( mpShell, url, aArguments, aRet, aDummyCaller ); 
                         }
                     }
                     catch ( uno::Exception& e )
diff --git scripting/source/vbaevents/makefile.mk scripting/source/vbaevents/makefile.mk
index 1946c61..a367898 100644
--- scripting/source/vbaevents/makefile.mk
+++ scripting/source/vbaevents/makefile.mk
@@ -69,6 +69,7 @@ SHL1STDLIBS= \
         $(BASICLIB) \
         $(COMPHELPERLIB) \
         $(SFXLIB) \
+		$(MSFILTERLIB) \
                 $(CPPULIB) \
                 $(TOOLSLIB) \
                 $(SALLIB)
diff --git scripting/source/vbaevents/vbaevents.map scripting/source/vbaevents/vbaevents.map
new file mode 100644
index 0000000..832e82c
--- /dev/null
+++ scripting/source/vbaevents/vbaevents.map
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
diff --git scripting/source/vbaevents/vbamsformreturntypes.hxx scripting/source/vbaevents/vbamsformreturntypes.hxx
new file mode 100644
index 0000000..e632eeb
--- /dev/null
+++ scripting/source/vbaevents/vbamsformreturntypes.hxx
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright IBM Corporation 2009, 2010.
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ * 
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef VBA_MSFORM_RETURNTYPES_HXX
+#define VBA_MSFORM_RETURNTYPES_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <msforms/XReturnBoolean.hpp>
+#include <msforms/XReturnInteger.hpp>
+
+
+typedef ::cppu::WeakImplHelper1<msforms::XReturnBoolean> ReturnBoolean_BASE;
+
+class SAL_DLLPUBLIC_EXPORT VbaReturnBoolean : public ReturnBoolean_BASE
+{
+public:
+	sal_Bool Value;
+
+public:
+	VbaReturnBoolean() : Value(false) {} ; 
+	
+	// XReturnBoolean
+	virtual ::sal_Bool SAL_CALL getValue() throw (::com::sun::star::uno::RuntimeException) { return Value; }
+	virtual void SAL_CALL setValue( ::sal_Bool _value ) throw (::com::sun::star::uno::RuntimeException) { Value = _value; }
+	
+	// XDefaultProperty
+	::rtl::OUString SAL_CALL getDefaultPropertyName() throw (com::sun::star::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+
+
+typedef ::cppu::WeakImplHelper1<msforms::XReturnInteger> ReturnInteger_BASE;
+
+class SAL_DLLPUBLIC_EXPORT VbaReturnInteger : public ReturnInteger_BASE
+{
+public:
+	sal_Int32 Value;
+
+public:
+	VbaReturnInteger() : Value(0) {} ; 
+	
+	// XReturnInteger
+	virtual ::sal_Int32 SAL_CALL getValue() throw (::com::sun::star::uno::RuntimeException) { return Value; }
+	virtual void SAL_CALL setValue( ::sal_Int32 _value ) throw (::com::sun::star::uno::RuntimeException) { Value = _value; }
+	
+	// XDefaultProperty
+	::rtl::OUString SAL_CALL getDefaultPropertyName() throw (com::sun::star::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+#endif
diff --git sfx2/inc/sfx2/objsh.hxx sfx2/inc/sfx2/objsh.hxx
index 8e4dde2..9fd0a60 100644
--- sfx2/inc/sfx2/objsh.hxx
+++ sfx2/inc/sfx2/objsh.hxx
@@ -404,8 +405,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true 
-    );
+        bool bRaiseError = true,
+        const ::com::sun::star::uno::Any* aCaller = 0 );
 
     static ErrCode  CallXScript(
         const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& _rxScriptContext,
@@ -414,7 +415,8 @@ public:
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
-        bool bRaiseError = true 
+        bool bRaiseError = true,
+        const ::com::sun::star::uno::Any* aCaller = 0
     );
 
     /** adjusts the internal macro mode, according to the current security settings
diff --git sfx2/inc/sfx2/sfx.hrc sfx2/inc/sfx2/sfx.hrc
index 87cc2b6..8c58159 100755
--- sfx2/inc/sfx2/sfx.hrc
+++ sfx2/inc/sfx2/sfx.hrc
@@ -399,8 +399,10 @@
 #define MID_DOCINFO_ENCRYPTED				 0x2c
 #define MID_DOCINFO_STATISTIC				 0x33
 #define MID_DOCINFO_CHARLOCALE				 0x34
-
-#define MID_LAST_USED_PROPID                 MID_DOCINFO_CHARLOCALE
+#define MID_CATEGORY                                     0x35
+#define MID_COMPANY                                      0x36
+#define MID_MANAGER                                      0x37
+#define MID_LAST_USED_PROPID              MID_MANAGER   
 
 // Config-Ids -----------------------------------------------------------
 
diff --git sfx2/inc/sfx2/sfxbasemodel.hxx sfx2/inc/sfx2/sfxbasemodel.hxx
index 52fe2c1..8fe1468 100644
--- sfx2/inc/sfx2/sfxbasemodel.hxx
+++ sfx2/inc/sfx2/sfxbasemodel.hxx
@@ -1505,6 +1505,7 @@ protected:
     /* returns true if the document signatures are valid, otherwise false */
     sal_Bool hasValidSignatures() const;
 
+    void setDocumentProperties( const ::com::sun::star::uno::Reference< ::com::sun::star::document::XDocumentProperties >& );
 //________________________________________________________________________________________________________
 //	private methods
 //________________________________________________________________________________________________________
diff --git sfx2/inc/sfx2/sfxsids.hrc sfx2/inc/sfx2/sfxsids.hrc
index cbd45cf..bf1cebb 100644
--- sfx2/inc/sfx2/sfxsids.hrc
+++ sfx2/inc/sfx2/sfxsids.hrc
@@ -75,6 +75,7 @@
 
 #define SID_VERSION_VISIBLE                 (SID_SFX_START + 313)
 #define SID_PASTE_UNFORMATTED				(SID_SFX_START + 314)
+#define SID_DIALOG_RETURN                   (SID_SFX_START + 318)
 #define SID_PRINTER_NOTFOUND_WARN           (SID_SFX_START + 320)
 #define SID_PRINTER_USETHREAD               (SID_SFX_START + 321)
 #define SID_PRINTER_NAME                    (SID_SFX_START + 322)
diff --git sfx2/source/appl/app.cxx sfx2/source/appl/app.cxx
index ca8062b..5c8c768 100644
--- sfx2/source/appl/app.cxx
+++ sfx2/source/appl/app.cxx
@@ -749,7 +749,7 @@ IMPL_LINK( SfxApplication, GlobalBasicErrorHdl_Impl, StarBASIC*, pStarBasic )
     basicide_handle_basic_error pSymbol = (basicide_handle_basic_error) osl_getFunctionSymbol( handleMod, aSymbol.pData );
 
     // call basicide_handle_basic_error in basctl
-    long nRet = pSymbol( pStarBasic );
+    long nRet = pSymbol ? pSymbol( pStarBasic ) : 0;
 
     return nRet;
 }
diff --git sfx2/source/appl/appuno.cxx sfx2/source/appl/appuno.cxx
index 2a7bb3f..091ffb8 100755
--- sfx2/source/appl/appuno.cxx
+++ sfx2/source/appl/appuno.cxx
@@ -2281,6 +2281,16 @@ SFX2_DLLPUBLIC sal_Bool SAL_CALL component_writeInfo(
     xNewKey = xKey->createKey( aTempStr );
     xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.document.DocumentProperties") );
 
+
+    // writer compatable document properties
+    aImpl = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+    aImpl += comp_CompatWriterDocProps::_getImplementationName();
+
+    aTempStr = aImpl;
+    aTempStr += ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/UNO/SERVICES"));
+    xNewKey = xKey->createKey( aTempStr );
+    xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.writer.DocumentProperties") );
+
     return sal_True;
 }
 
@@ -2340,6 +2350,16 @@ SFX2_DLLPUBLIC void* SAL_CALL component_getFactory(
             ::comp_SfxDocumentMetaData::_getImplementationName(),
             ::comp_SfxDocumentMetaData::_getSupportedServiceNames());
         }
+        if ( ::comp_CompatWriterDocProps::_getImplementationName().equals(
+                 ::rtl::OUString::createFromAscii( pImplementationName ) ) )
+        {
+            xFactory = ::cppu::createSingleComponentFactory(
+			::comp_CompatWriterDocProps::_create,
+			::comp_CompatWriterDocProps::_getImplementationName(),
+			::comp_CompatWriterDocProps::_getSupportedServiceNames());
+        }
+
+        // Factory is valid - service was found.
 
         // Factory is valid - service was found.
         if ( xFactory.is() )
diff --git sfx2/source/control/unoctitm.cxx sfx2/source/control/unoctitm.cxx
index 14b3fe0..0a51e21 100644
--- sfx2/source/control/unoctitm.cxx
+++ sfx2/source/control/unoctitm.cxx
@@ -702,6 +702,7 @@ void SAL_CALL SfxDispatchController_Impl::dispatch( const ::com::sun::star::util
         // Filter arguments which shouldn't be part of the sequence property value
         sal_Bool    bTemp = sal_Bool();
         sal_uInt16  nModifier(0);
+        sal_Bool    bVBARequest = sal_False;
         std::vector< ::com::sun::star::beans::PropertyValue > aAddArgs;
         for( sal_Int32 n=0; n<nCount; n++ )
         {
@@ -718,6 +719,10 @@ void SAL_CALL SfxDispatchController_Impl::dispatch( const ::com::sun::star::util
             }
             else if( rProp.Name.equalsAsciiL("KeyModifier",11))
                 rProp.Value >>= nModifier;
+            else if( rProp.Name.equalsAsciiL("VBADialogResultRequest",22) )
+            {
+                rProp.Value >>= bVBARequest;
+            }
             else
                 aAddArgs.push_back( aArgs[n] );
         }
@@ -801,6 +806,14 @@ void SAL_CALL SfxDispatchController_Impl::dispatch( const ::com::sun::star::util
                         pItem = aReq.GetReturnValue();
                         bSuccess = aReq.IsDone() || pItem != NULL;
                         bFailure = aReq.IsCancelled();
+                        if ( bVBARequest )
+                        {
+                            SFX_REQUEST_ARG( aReq, pItem, SfxBoolItem, SID_DIALOG_RETURN, FALSE );
+                            if ( pItem )
+                            {
+                                bSuccess = pItem->GetValue();
+                            }
+                        }
                     }
                 }
 #ifdef DBG_UTIL
diff --git sfx2/source/doc/SfxDocumentMetaData.cxx sfx2/source/doc/SfxDocumentMetaData.cxx
index 95fe000..9975858 100644
--- sfx2/source/doc/SfxDocumentMetaData.cxx
+++ sfx2/source/doc/SfxDocumentMetaData.cxx
@@ -87,6 +87,10 @@
 #include <cstring>
 #include <limits>
 
+
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
+
 /**
  * This file contains the implementation of the service
  * com.sun.star.document.DocumentProperties.
@@ -292,12 +296,12 @@ public:
         const css::uno::Sequence< css::beans::StringPair >& i_rNamespaces)
         throw (css::uno::RuntimeException, css::xml::sax::SAXException);
 
-private:
+protected:
     SfxDocumentMetaData(SfxDocumentMetaData &); // not defined
     SfxDocumentMetaData& operator =(SfxDocumentMetaData &); // not defined
 
     virtual ~SfxDocumentMetaData() {}
-
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new SfxDocumentMetaData( context ); };
     const css::uno::Reference< css::uno::XComponentContext > m_xContext;
 
     /// for notification
@@ -372,6 +376,54 @@ private:
     void createUserDefined();
 };
 
+typedef ::cppu::ImplInheritanceHelper1< SfxDocumentMetaData, css::document::XCompatWriterDocProperties > CompatWriterDocPropsImpl_BASE;
+
+class CompatWriterDocPropsImpl : public CompatWriterDocPropsImpl_BASE
+{
+    rtl::OUString msManager;
+    rtl::OUString msCategory;
+    rtl::OUString msCompany;
+protected:
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new CompatWriterDocPropsImpl( context ); };
+public:
+    CompatWriterDocPropsImpl( css::uno::Reference< css::uno::XComponentContext > const & context) : CompatWriterDocPropsImpl_BASE( context ) {}
+// XCompatWriterDocPropsImpl
+    virtual ::rtl::OUString SAL_CALL getManager() throw (::com::sun::star::uno::RuntimeException) { return msManager; }
+    virtual void SAL_CALL setManager( const ::rtl::OUString& _manager ) throw (::com::sun::star::uno::RuntimeException) { msManager = _manager; }
+    virtual ::rtl::OUString SAL_CALL getCategory() throw (::com::sun::star::uno::RuntimeException){ return msCategory; }
+    virtual void SAL_CALL setCategory( const ::rtl::OUString& _category ) throw (::com::sun::star::uno::RuntimeException){ msCategory = _category; }
+    virtual ::rtl::OUString SAL_CALL getCompany() throw (::com::sun::star::uno::RuntimeException){ return msCompany; }
+    virtual void SAL_CALL setCompany( const ::rtl::OUString& _company ) throw (::com::sun::star::uno::RuntimeException){ msCompany = _company; }
+
+// XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getImplementationName();
+    }
+
+    virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        css::uno::Sequence< rtl::OUString > sServiceNames= getSupportedServiceNames();
+        sal_Int32 nLen = sServiceNames.getLength();
+        rtl::OUString* pIt = sServiceNames.getArray();
+        rtl::OUString* pEnd = ( pIt + nLen );
+        sal_Bool bRes = sal_False;
+        for ( ; pIt != pEnd; ++pIt )
+        {
+            if ( pIt->equals( ServiceName ) )
+            {
+                bRes = sal_True;
+                break;
+            }
+        }
+        return bRes;
+    }
+
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getSupportedServiceNames();
+    }
+};
 ////////////////////////////////////////////////////////////////////////////
 
 bool operator== (const css::util::DateTime &i_rLeft,
@@ -2156,7 +2208,7 @@ SfxDocumentMetaData::createClone()
     ::osl::MutexGuard g(m_aMutex);
     checkInit();
 
-    SfxDocumentMetaData *pNew = new SfxDocumentMetaData(m_xContext);
+    SfxDocumentMetaData *pNew = createMe(m_xContext);
 
     // NB: do not copy the modification listeners, only DOM
     css::uno::Reference<css::xml::dom::XDocument> xDoc = createDOM();
@@ -2334,6 +2386,32 @@ void SfxDocumentMetaData::createUserDefined()
 
 
 // component helper namespace
+namespace comp_CompatWriterDocProps {
+
+    ::rtl::OUString SAL_CALL _getImplementationName() {
+        return ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
+            "CompatWriterDocPropsImpl"));
+}
+
+   css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames()
+   {
+        static css::uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+            aServiceNames.realloc( 1 );
+            aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.writer.DocumentProperties" ) ); 
+        }
+        return aServiceNames;
+   } 
+    css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        const css::uno::Reference< css::uno::XComponentContext > & context)
+            SAL_THROW((css::uno::Exception))
+    {
+        return static_cast< ::cppu::OWeakObject * >
+                    (new CompatWriterDocPropsImpl(context));
+    }
+
+}
 namespace comp_SfxDocumentMetaData {
 
 ::rtl::OUString SAL_CALL _getImplementationName() {
diff --git sfx2/source/doc/docinf.cxx sfx2/source/doc/docinf.cxx
index 15f2317..94e92ee 100644
--- sfx2/source/doc/docinf.cxx
+++ sfx2/source/doc/docinf.cxx
@@ -34,6 +34,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyContainer.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 #include <com/sun/star/uno/Exception.hpp>
 
 #include <rtl/ustring.hxx>
@@ -43,7 +44,6 @@
 #include <vcl/gdimtf.hxx>
 
 #include "oleprops.hxx"
-
 // ============================================================================
 
 // stream names
@@ -172,6 +172,28 @@ sal_uInt32 SFX2_DLLPUBLIC LoadOlePropertySet(
         }
     }
 
+    uno::Reference< document::XCompatWriterDocProperties > xWriterProps( i_xDocProps, uno::UNO_QUERY );
+    if ( xWriterProps.is() )
+    {
+        SfxOleSectionRef xBuiltin = aDocSet.GetSection( SECTION_BUILTIN );
+        if ( xBuiltin.get() )
+        {
+            try
+            {
+                String aStrValue;
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_MANAGER ) )
+                    xWriterProps->setManager( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_CATEGORY ) )
+                    xWriterProps->setCategory( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_COMPANY ) )
+                    xWriterProps->setCompany( aStrValue );
+            }
+            catch ( uno::Exception& )
+            {
+            }
+        }
+    }
+
     // return code
     return (nGlobError != ERRCODE_NONE) ? nGlobError : nDocError;
 }
diff --git sfx2/source/doc/docmacromode.cxx sfx2/source/doc/docmacromode.cxx
index 613d90c..a8695d3 100644
--- sfx2/source/doc/docmacromode.cxx
+++ sfx2/source/doc/docmacromode.cxx
@@ -38,6 +38,8 @@
 #include <com/sun/star/task/DocumentMacroConfirmationRequest.hpp>
 #include <com/sun/star/task/InteractionClassification.hpp>
 #include <com/sun/star/security/XDocumentDigitalSignatures.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
+#include <com/sun/star/script/vba/XVBACompatibility.hpp>
 /** === end UNO includes === **/
 
 #include <comphelper/componentcontext.hxx>
@@ -73,8 +75,11 @@ namespace sfx2
     using ::com::sun::star::document::XEmbeddedScripts;
     using ::com::sun::star::uno::UNO_SET_THROW;
     using ::com::sun::star::script::XLibraryContainer;
+    using ::com::sun::star::script::XLibraryQueryExecutable;
+    using ::com::sun::star::script::vba::XVBACompatibility;
     using ::com::sun::star::container::XNameAccess;
     using ::com::sun::star::uno::UNO_QUERY_THROW;
+    using ::com::sun::star::uno::UNO_QUERY;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
 
@@ -336,6 +341,8 @@ namespace sfx2
             if ( xScripts.is() )
                 xContainer.set( xScripts->getBasicLibraries(), UNO_QUERY_THROW );
 
+            Reference< XVBACompatibility > xDocVBAMode( xContainer, UNO_QUERY );
+            sal_Bool bIsVBAMode = ( xDocVBAMode.is() && xDocVBAMode->getVBACompatibilityMode() );
             if ( xContainer.is() )
             {
                 // a library container exists; check if it's empty
@@ -350,23 +357,46 @@ namespace sfx2
                     Sequence< ::rtl::OUString > aElements = xContainer->getElementNames();
                     if ( aElements.getLength() )
                     {
-                        if ( aElements.getLength() > 1 || !aElements[0].equals( aStdLibName ) )
+                        // old check, if more than 1 library or the first library isn't the expected 'Standard'
+                        // trigger the security 'nag' dialog 
+                        if ( !bIsVBAMode && ( aElements.getLength() > 1 || !aElements[0].equals( aStdLibName ) ) )
                             bHasMacroLib = sal_True;
-                        else
+                        else 
                         {
-                            // usually a "Standard" library is always present (design)
-                            // for this reason we must check if it's empty
-                            //
-                            // Note: Since #i73229#, this is not true anymore. There's no default
-                            // "Standard" lib anymore. Wouldn't it be time to get completely
-                            // rid of the "Standard" thingie - this shouldn't be necessary
-                            // anymore, should it?
-                            // 2007-01-25 / frank.schoenheit@sun.com
-                            Reference < XNameAccess > xLib;
-                            Any aAny = xContainer->getByName( aStdLibName );
-                            aAny >>= xLib;
+                            // other wise just check all libraries for executeable code
+                            Reference< XLibraryQueryExecutable > xLib( xContainer, UNO_QUERY );
                             if ( xLib.is() )
-                                bHasMacroLib = xLib->hasElements();
+                            {
+                                Sequence< ::rtl::OUString > aElements = xContainer->getElementNames();
+                                sal_Int32 nElementCount = aElements.getLength();
+                                const ::rtl::OUString* pElementName = aElements.getConstArray();
+                                for ( sal_Int32 index = 0; index < nElementCount; index++ )
+                                {
+                                    bHasMacroLib = xLib->HasExecutableCode( pElementName[index] );
+                                    if ( bHasMacroLib )
+                                        break;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if ( bIsVBAMode && !bHasMacroLib && xScripts.is() )
+            {
+                Reference< XLibraryContainer > xDlgContainer( xScripts->getDialogLibraries(), UNO_QUERY );
+                if ( xDlgContainer.is() && xDlgContainer->hasElements() )
+                {
+                    Sequence< ::rtl::OUString > aElements = xDlgContainer->getElementNames();
+                    sal_Int32 nElementCount = aElements.getLength();
+                    const ::rtl::OUString* pElementName = aElements.getConstArray();
+                    for ( sal_Int32 index = 0; index < nElementCount; index++ )
+                    {
+                        Reference< XNameAccess > xNameAccess;
+                        xDlgContainer->getByName( pElementName[index] ) >>= xNameAccess;
+                        if ( xNameAccess.is() && xNameAccess->hasElements() )
+                        {
+                            bHasMacroLib = sal_True;
+                            break;
                         }
                     }
                 }
diff --git sfx2/source/doc/objmisc.cxx sfx2/source/doc/objmisc.cxx
index 5b91b31..a82e565 100755
--- sfx2/source/doc/objmisc.cxx
+++ sfx2/source/doc/objmisc.cxx
@@ -1710,7 +1710,7 @@ namespace
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError, const ::com::sun::star::uno::Any* pCaller )
 {
     OSL_TRACE( "in CallXScript" );
     ErrCode nErr = ERRCODE_NONE;
@@ -1741,7 +1741,16 @@ ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptCon
 
         // obtain the script, and execute it
         Reference< provider::XScript > xScript( xScriptProvider->getScript( _rScriptURL ), UNO_QUERY_THROW );
-
+        if ( pCaller && pCaller->hasValue() )
+        {
+            Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY ); 
+            if ( xProps.is() )
+            {
+                Sequence< uno::Any > aArgs( 1 );
+                aArgs[ 0 ] = *pCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii("Caller"), uno::makeAny( aArgs ) );
+            }
+        }
         aRet = xScript->invoke( aParams, aOutParamIndex, aOutParam );
     }
     catch ( const uno::Exception& )
@@ -1774,10 +1783,10 @@ ErrCode SfxObjectShell::CallXScript( const String& rScriptURL,
             aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
-        , bool bRaiseError )
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
+            aOutParam, bool bRaiseError, const ::com::sun::star::uno::Any* pCaller )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError, pCaller );
 }
 
 //-------------------------------------------------------------------------
diff --git sfx2/source/doc/objuno.cxx sfx2/source/doc/objuno.cxx
index ac45ef5..ef49f5d 100644
--- sfx2/source/doc/objuno.cxx
+++ sfx2/source/doc/objuno.cxx
@@ -45,6 +45,7 @@
 #include <com/sun/star/lang/Locale.hpp>
 #include <com/sun/star/util/XModifiable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 
 #include <unotools/configmgr.hxx>
 #include <tools/inetdef.hxx>
@@ -104,6 +105,9 @@ const SfxItemPropertyMapEntry* lcl_GetDocInfoPropertyMap()
         { "AutoloadEnabled" , 15, MID_DOCINFO_AUTOLOADENABLED, &::getBooleanCppuType(),   PROPERTY_UNBOUND, 0 },
         { "AutoloadSecs"    , 12, MID_DOCINFO_AUTOLOADSECS, &::getCppuType((const sal_Int32*)0),     PROPERTY_UNBOUND, 0 },
         { "AutoloadURL"     , 11, MID_DOCINFO_AUTOLOADURL, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Category"			, 8	, MID_CATEGORY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Company"			, 7	, MID_COMPANY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Manager"			, 7	, MID_MANAGER,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "CreationDate"    , 12, WID_DATE_CREATED,   &::getCppuType((const ::com::sun::star::util::DateTime*)0),PROPERTY_MAYBEVOID, 0 },
         { "DefaultTarget"   , 13, MID_DOCINFO_DEFAULTTARGET, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "Description"     , 11, MID_DOCINFO_DESCRIPTION, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
@@ -807,6 +811,22 @@ void SAL_CALL  SfxDocumentInfoObject::setFastPropertyValue(sal_Int32 nHandle, co
                     _pImp->m_xDocProps->setDefaultTarget(sTemp);
                 break;
 //            case WID_CONTENT_TYPE : // this is readonly!
+               case MID_CATEGORY:
+               case MID_MANAGER:
+               case MID_COMPANY:
+                   {
+                       uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                       if ( xWriterProps.is() ) 
+                       {
+                           if ( nHandle ==  MID_CATEGORY )
+                               xWriterProps->setCategory( sTemp );
+                           else if ( nHandle ==  MID_MANAGER )
+                               xWriterProps->setManager( sTemp );
+                           else
+                               xWriterProps->setCompany( sTemp );
+                           break;
+                       }
+                   }
             default:
                 break;
         }
@@ -1024,6 +1044,23 @@ void SAL_CALL  SfxDocumentInfoObject::setFastPropertyValue(sal_Int32 nHandle, co
         case MID_DOCINFO_CHARLOCALE:
             aValue <<= _pImp->m_xDocProps->getLanguage();
             break;
+        case MID_CATEGORY:
+        case MID_MANAGER:
+        case MID_COMPANY:
+            {
+                uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                if ( xWriterProps.is() ) 
+                {
+                    if ( nHandle ==  MID_CATEGORY )
+                        aValue <<= xWriterProps->getCategory();
+                    else if ( nHandle ==  MID_MANAGER )
+                        aValue <<= xWriterProps->getManager();
+                    else
+                        aValue <<= xWriterProps->getCompany();
+                        break;
+               }
+           }
+	
         default:
             aValue <<= ::rtl::OUString();
             break;
diff --git sfx2/source/doc/objxtor.cxx sfx2/source/doc/objxtor.cxx
index a9a7583..c535d40 100644
--- sfx2/source/doc/objxtor.cxx
+++ sfx2/source/doc/objxtor.cxx
@@ -134,6 +134,40 @@ DBG_NAME(SfxObjectShell)
 
 static WeakReference< XInterface > s_xCurrentComponent;
 
+void lcl_UpdateAppBasicDocVars(  const Reference< XInterface >& _rxComponent, bool bClear = false )
+{
+    BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
+    if ( pAppMgr )
+    {
+        uno::Reference< beans::XPropertySet > xProps( _rxComponent, uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            try
+            {
+                // ThisVBADocObj contains a PropertyValue
+                // Name  is ( the name of the VBA global to insert )
+                // Value is the Object to insert.
+                // ( note: at the moment the Value is actually the model so
+                // it strictly is not necessary, however we do intend to store
+                // not the model in basic but a custom object, so we keep this
+                // level of indirection for future proofing )
+                beans::PropertyValue aProp;
+                xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisVBADocObj") ) ) >>= aProp;
+                rtl::OString sTmp( rtl::OUStringToOString( aProp.Name, RTL_TEXTENCODING_UTF8 ) );
+                const char* pAscii = sTmp.getStr();
+                if ( bClear )
+                    pAppMgr->SetGlobalUNOConstant( pAscii, uno::makeAny( uno::Reference< uno::XInterface >() ) );
+                else
+                    pAppMgr->SetGlobalUNOConstant( pAscii, aProp.Value );
+    
+            }
+            catch( uno::Exception& e )
+            {
+            }
+        }
+    }
+}
+
 //=========================================================================
 
 
@@ -168,6 +202,7 @@ void SAL_CALL SfxModelListener_Impl::disposing( const com::sun::star::lang::Even
     ::vos::OGuard aSolarGuard( Application::GetSolarMutex() );
     if ( SfxObjectShell::GetCurrentComponent() == _rEvent.Source )
     {
+        lcl_UpdateAppBasicDocVars( SfxObjectShell::GetCurrentComponent(), true );
         // remove ThisComponent reference from AppBasic
         SfxObjectShell::SetCurrentComponent( Reference< XInterface >() );
     }
@@ -919,7 +961,10 @@ void SfxObjectShell::SetCurrentComponent( const Reference< XInterface >& _rxComp
     BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
     s_xCurrentComponent = _rxComponent;
     if ( pAppMgr )
+    {
+        lcl_UpdateAppBasicDocVars( _rxComponent );
         pAppMgr->SetGlobalUNOConstant( "ThisComponent", makeAny( _rxComponent ) );
+    }
 
 #if OSL_DEBUG_LEVEL > 0
     const char* pComponentImplName = _rxComponent.get() ? typeid( *_rxComponent.get() ).name() : "void";
diff --git sfx2/source/doc/oleprops.hxx sfx2/source/doc/oleprops.hxx
index 0fddd50..c277ec5 100755
--- sfx2/source/doc/oleprops.hxx
+++ sfx2/source/doc/oleprops.hxx
@@ -80,6 +80,10 @@ const sal_Int32 PROPID_CREATED          = 12;
 const sal_Int32 PROPID_LASTSAVED        = 13;
 const sal_Int32 PROPID_THUMBNAIL        = 17;
 
+// some Builtin properties
+const sal_Int32 PROPID_CATEGORY         = 0x2;
+const sal_Int32 PROPID_COMPANY          = 0xf;
+const sal_Int32 PROPID_MANAGER          = 0xe;
 // predefined codepages
 const sal_uInt16 CODEPAGE_UNKNOWN       = 0;
 const sal_uInt16 CODEPAGE_UNICODE       = 1200;
diff --git sfx2/source/doc/sfxbasemodel.cxx sfx2/source/doc/sfxbasemodel.cxx
index 8122e61..7e2e934 100644
--- sfx2/source/doc/sfxbasemodel.cxx
+++ sfx2/source/doc/sfxbasemodel.cxx
@@ -882,7 +882,15 @@ uno::Reference< document::XDocumentInfo > SAL_CALL SfxBaseModel::getDocumentInfo
 
     return m_pData->m_xDocumentInfo;
 }
-
+void 
+SfxBaseModel::setDocumentProperties( const uno::Reference< document::XDocumentProperties >& rxNewDocProps )
+{
+	// object already disposed?
+    ::vos::OGuard aGuard( Application::GetSolarMutex() );
+    if ( impl_isDisposed() )
+        throw lang::DisposedException();
+    m_pData->m_xDocumentProperties.set(rxNewDocProps, uno::UNO_QUERY_THROW);
+}
 // document::XDocumentPropertiesSupplier:
 uno::Reference< document::XDocumentProperties > SAL_CALL
 SfxBaseModel::getDocumentProperties()
@@ -3551,15 +3559,23 @@ void SAL_CALL SfxBaseModel::switchToStorage( const uno::Reference< XSTORAGE >& x
         throw IOEXCEPTION(); // TODO:
 
     // the persistence should be switched only if the storage is different
-    if ( xStorage != m_pData->m_pObjectShell->GetStorage()
-      && !m_pData->m_pObjectShell->SwitchPersistance( xStorage ) )
-    {
-        sal_uInt32 nError = m_pData->m_pObjectShell->GetErrorCode();
-        throw task::ErrorCodeIOException( ::rtl::OUString(),
-                                            uno::Reference< uno::XInterface >(),
-                                            nError ? nError : ERRCODE_IO_GENERAL );
-    }
-
+    if ( xStorage != m_pData->m_pObjectShell->GetStorage() )
+	{
+        if ( !m_pData->m_pObjectShell->SwitchPersistance( xStorage ) )
+        {
+            sal_uInt32 nError = m_pData->m_pObjectShell->GetErrorCode();
+            throw task::ErrorCodeIOException( ::rtl::OUString(),
+                                                uno::Reference< uno::XInterface >(),
+                                                nError ? nError : ERRCODE_IO_GENERAL );
+        }
+        else
+        {
+            // UICfgMgr has a reference to the old storage, update it
+            uno::Reference< ui::XUIConfigurationStorage > xUICfgMgrStorage( getUIConfigurationManager(), uno::UNO_QUERY );
+            if ( xUICfgMgrStorage.is() )
+                xUICfgMgrStorage->setStorage( xStorage ); 
+        }
+	}
     m_pData->m_pObjectShell->Get_Impl()->bOwnsStorage = FALSE;
 }
 
diff --git sfx2/source/inc/SfxDocumentMetaData.hxx sfx2/source/inc/SfxDocumentMetaData.hxx
index 871ed19..6114339 100644
--- sfx2/source/inc/SfxDocumentMetaData.hxx
+++ sfx2/source/inc/SfxDocumentMetaData.hxx
@@ -45,5 +45,16 @@ css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
 
 } // closing component helper namespace
 
+namespace comp_CompatWriterDocProps {
+
+namespace css = ::com::sun::star;
+
+// component and service helper functions:
+::rtl::OUString SAL_CALL _getImplementationName();
+css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames();
+css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        css::uno::Reference< css::uno::XComponentContext > const & context );
+
+}
 #endif
 
diff --git sfx2/source/view/viewprn.cxx sfx2/source/view/viewprn.cxx
index 43c9c8b..5cc2ce8 100644
--- sfx2/source/view/viewprn.cxx
+++ sfx2/source/view/viewprn.cxx
@@ -874,6 +888,10 @@ void SfxViewShell::ExecPrint_Impl( SfxRequest &rReq )
                         aReq.AppendItem( SfxStringItem( SID_PRINTER_NAME, pDlgPrinter->GetName() ) );
                         aReq.Done();
                     }
+	                if ( nId == SID_SETUPPRINTER )
+	                {
+	                    rReq.AppendItem( SfxBoolItem( SID_DIALOG_RETURN, TRUE ) );
+	                }
 
                     // take the changes made in the dialog
                     pPrinter = SetPrinter_Impl( pDlgPrinter );
@@ -894,6 +912,10 @@ void SfxViewShell::ExecPrint_Impl( SfxRequest &rReq )
                     rReq.Ignore();
                     if ( SID_PRINTDOC == nId )
                         rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+	                if ( nId == SID_SETUPPRINTER )
+	                {
+	                    rReq.AppendItem( SfxBoolItem( SID_DIALOG_RETURN, FALSE ) );
+			}
                 }
             }
         }
diff --git svtools/inc/bindablecontrolhelper.hxx svtools/inc/bindablecontrolhelper.hxx
new file mode 100644
index 0000000..e9cd3e6
--- /dev/null
+++ svtools/inc/bindablecontrolhelper.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SVTOOLS_INC_BINDABLECONTROL_HXX
+#define SVTOOLS_INC_BINDABLECONTROL_HXX
+
+#include "svtools/svtdllapi.h"
+
+#include <com/sun/star/frame/XModel.hpp>
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+    //====================================================================
+    //= GraphicAccess
+    //====================================================================
+    /** helper class for obtaining streams (which also can be used with the ImageProducer)
+        from a resource
+    */
+    class BindableControlHelper
+    {
+    private:
+        BindableControlHelper();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  void ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif // DBA14_SVTOOLS_INC_IMAGERESOURCEACCESS_HXX
+
diff --git svtools/inc/filterutils.hxx svtools/inc/filterutils.hxx
new file mode 100644
index 0000000..a05025f
--- /dev/null
+++ svtools/inc/filterutils.hxx
@@ -0,0 +1,22 @@
+#ifndef SVTOOLS_INC_FILTERUTILS_HXX
+#define SVTOOLS_INC_FILTERUTILS_HXX
+
+#include "svtools/svtdllapi.h"
+#include <com/sun/star/uno/RuntimeException.hpp>
+namespace svt
+{
+    class BinFilterUtils
+    {
+    private:
+        BinFilterUtils();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif 
diff --git svtools/source/misc/bindablecontrolhelper.cxx svtools/source/misc/bindablecontrolhelper.cxx
new file mode 100644
index 0000000..ba842f0
--- /dev/null
+++ svtools/source/misc/bindablecontrolhelper.cxx
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "bindablecontrolhelper.hxx"
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+#ifndef C2U
+#define C2U(cChar)	rtl::OUString::createFromAscii(cChar)
+#endif
+
+    using namespace ::com::sun::star;
+
+bool lcl_isNamedRange( const rtl::OUString& sAddress, const uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
+
+
+void
+BindableControlHelper::ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    else if ( xBindable.is() ) // reset it
+        xBindable->setValueBinding( uno::Reference< form::binding::XValueBinding >() );
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+    else if (  xListEntrySink.is() ) // reset
+         xListEntrySink->setListEntrySource( uno::Reference< form::binding::XListEntrySource >()  );
+
+}
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
diff --git svtools/source/misc/filterutils.cxx svtools/source/misc/filterutils.cxx
new file mode 100644
index 0000000..91a6ca4
--- /dev/null
+++ svtools/source/misc/filterutils.cxx
@@ -0,0 +1,56 @@
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "filterutils.hxx"
+#include <rtl/ustrbuf.hxx>
+
+namespace svt
+{
+//........................................................................
+
+    using namespace ::com::sun::star;
+
+    rtl::OUString lcl_createStringFromArray( const char* pcCharArr, sal_uInt32 nBufSize, bool bIsCompressed )
+    {
+        rtl::OUStringBuffer aBuffer;
+        if( bIsCompressed )
+        {
+            // buffer contains compressed Unicode, not encoded bytestring
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
+        }
+        else
+        {
+            // buffer contains Little-Endian Unicode
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
+            {
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
+                cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
+                aBuffer.setCharAt( nChar, cChar );
+            }
+        }
+        return aBuffer.makeStringAndClear();
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, false );
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, true );
+    }    
+//........................................................................
+} // namespace svt
+//........................................................................
+
diff --git svtools/source/misc/makefile.mk svtools/source/misc/makefile.mk
index 32781db..cd14b3b 100755
--- svtools/source/misc/makefile.mk
+++ svtools/source/misc/makefile.mk
@@ -75,6 +75,8 @@ SLOFILES=\
     $(SLO)$/transfer.obj            \
     $(SLO)$/transfer2.obj           \
     $(SLO)$/unitconv.obj           \
+    $(SLO)$/bindablecontrolhelper.obj   \
+    $(SLO)$/filterutils.obj   \
     $(SLO)$/wallitem.obj           \
     $(SLO)$/xwindowitem.obj
 
diff --git svx/source/form/fmscriptingenv.cxx svx/source/form/fmscriptingenv.cxx
index 74d9585..c14d2f1 100644
--- svx/source/form/fmscriptingenv.cxx
+++ svx/source/form/fmscriptingenv.cxx
@@ -36,6 +36,8 @@
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XInterfaceMethodTypeDescription.hpp>
 #include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/awt/XControl.hpp>
 /** === end UNO includes === **/
 #include <tools/diagnose_ex.h>
 #include <cppuhelper/implbase1.hxx>
@@ -71,6 +73,9 @@ namespace svxform
     using ::com::sun::star::uno::Exception;
     using ::com::sun::star::uno::Sequence;
     using ::com::sun::star::uno::XInterface;
+    using ::com::sun::star::lang::EventObject;
+    using ::com::sun::star::awt::XControl;
+    using ::com::sun::star::beans::XPropertySet;
     /** === end UNO using === **/
 
     class FormScriptingEnvironment;
@@ -413,8 +418,19 @@ namespace svxform
         {
             Sequence< sal_Int16 > aOutArgsIndex;
             Sequence< Any > aOutArgs;
-
-            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs );
+            EventObject aEvent;
+            Any aCaller;
+            if ( ( _rArguments.getLength() > 0 ) && ( _rArguments[ 0 ] >>= aEvent ) )
+            {
+                try
+                {
+                    Reference< XControl > xControl( aEvent.Source, UNO_QUERY_THROW );
+                    Reference< XPropertySet > xProps( xControl->getModel(), UNO_QUERY_THROW );
+                    aCaller = xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) );
+                }
+                catch( Exception& ) {}
+            }
+            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs, true, aCaller.hasValue() ? &aCaller : 0 );
         }
 
         //................................................................
diff --git svx/source/form/makefile.mk svx/source/form/makefile.mk
index d6dc1bd..276df21 100644
--- svx/source/form/makefile.mk
+++ svx/source/form/makefile.mk
@@ -41,6 +41,10 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Files --------------------------------------------------------
 
 .IF "$(ENABLE_VBA)"=="YES"
+	CDEFS+=-DENABLE_VBA
+.ENDIF
+
+.IF "$(ENABLE_VBA)"=="YES"
     CDEFS+=-DENABLE_VBA
 .ENDIF
 
--- sw/inc/doc.hxx	2010-08-21 18:03:57.000000000 +0100
+++ sw/inc/doc.hxx	2010-08-21 18:13:06.000000000 +0100
@@ -79,9 +79,7 @@ class SwList;
 #include "comphelper/implementationreference.hxx"
 #include <com/sun/star/chart2/data/XDataProvider.hpp>
 #include <com/sun/star/linguistic2/XProofreadingIterator.hpp>
-#ifdef FUTURE_VBA
 #include <com/sun/star/script/vba/XVBAEventProcessor.hpp>
-#endif
 
 #include <hash_map>
 #include <stringhash.hxx>
@@ -408,9 +406,8 @@ class SW_DLLPUBLIC SwDoc :
 
     // table of forbidden characters of this document
     vos::ORef<SvxForbiddenCharactersTable>	xForbiddenCharsTable;
-#ifdef FUTURE_VBA
     com::sun::star::uno::Reference< com::sun::star::script::vba::XVBAEventProcessor > mxVbaEvents;
-#endif
+    com::sun::star::uno::Reference<com::sun::star::container::XNameContainer> m_xTemplateToProjectCache;
     // --> OD 2007-10-26 #i83479#
 public:
     struct lessThanNodeNum
@@ -2146,9 +2142,9 @@ public:
     {
         return n32DummyCompatabilityOptions2;
     }
-#ifdef FUTURE_VBA
     com::sun::star::uno::Reference< com::sun::star::script::vba::XVBAEventProcessor > GetVbaEventProcessor();
-#endif
+    void SetVBATemplateToProjectCache( com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xCache ) { m_xTemplateToProjectCache = xCache; };
+        com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > GetVBATemplateToProjectCache() { return m_xTemplateToProjectCache; };
     ::sfx2::IXmlIdRegistry& GetXmlIdRegistry();
     ::sw::MetaFieldManager & GetMetaFieldManager();
     SfxObjectShell* CreateCopy(bool bCallInitNew) const;
diff --git sw/inc/docsh.hxx sw/inc/docsh.hxx
index 3840d59..6c2fd87 100644
--- sw/inc/docsh.hxx
+++ sw/inc/docsh.hxx
@@ -83,6 +83,7 @@ class SW_DLLPUBLIC SwDocShell: public SfxObjectShell, public SfxListener
     comphelper::EmbeddedObjectContainer*    pOLEChildList;
     sal_Int16               nUpdateDocMode; // contains the com::sun::star::document::UpdateDocMode
     bool                    bInUpdateFontList; //prevent nested calls of UpdateFontList
+    bool                    bIsATemplate; //prevent nested calls of UpdateFontList
     // Methoden fuer den Zugriff aufs Doc
     SW_DLLPRIVATE void					AddLink();
     SW_DLLPRIVATE void					RemoveLink();
@@ -301,6 +302,8 @@ public:
                                 GetController();
 
     SfxInPlaceClient* GetIPClient( const ::svt::EmbeddedObjectRef& xObjRef );
+    SW_DLLPRIVATE sal_Bool IsTemplate() { return bIsATemplate; }
+    SW_DLLPRIVATE void SetIsTemplate( bool bValue ) { bIsATemplate = bValue; }
 
     virtual const ::sfx2::IXmlIdRegistry* GetXmlIdRegistry() const;
 
diff --git sw/inc/unocoll.hxx sw/inc/unocoll.hxx
index bf6ba28..805b68c 100644
--- sw/inc/unocoll.hxx
+++ sw/inc/unocoll.hxx
@@ -195,8 +195,12 @@ class SwUnoCollection
 #define SW_SERVICE_TYPE_FIELDMARK                       107
 #define SW_SERVICE_TYPE_FORMFIELDMARK                   108
 #define SW_SERVICE_TYPE_META                            109
+#define SW_SERVICE_VBAOBJECTPROVIDER                    110
+#define SW_SERVICE_VBACODENAMEPROVIDER                  111
+#define SW_SERVICE_VBAPROJECTNAMEPROVIDER               112
+#define SW_SERVICE_VBAGLOBALS                           113
 
-#define SW_SERVICE_LAST                 SW_SERVICE_TYPE_META
+#define SW_SERVICE_LAST                 SW_SERVICE_VBAGLOBALS
 
 #define SW_SERVICE_INVALID			USHRT_MAX
 
diff --git sw/inc/unoprnms.hxx sw/inc/unoprnms.hxx
index 374753b..2dfc961 100644
--- sw/inc/unoprnms.hxx
+++ sw/inc/unoprnms.hxx
@@ -805,8 +805,10 @@ enum SwPropNameIds
 /* 0737 */  UNO_NAME_DESCRIPTION,
 // <--
 /* 0738 */  UNO_NAME_META,       // #i91565#
-/* 0739 */  UNO_NAME_NESTED_TEXT_CONTENT, // #i109601#
-/* 0740 */  SW_PROPNAME_END
+/* 0739 */  UNO_NAME_IS_TEMPLATE,
+/* 0740 */  UNO_NAME_VBA_DOCOBJ,
+/* 0741 */  UNO_NAME_NESTED_TEXT_CONTENT, // #i109601#
+/* 0742 */  SW_PROPNAME_END
 };
 
 
diff --git sw/inc/unotbl.hxx sw/inc/unotbl.hxx
index ab6f6c6..7aa83d8 100644
--- sw/inc/unotbl.hxx
+++ sw/inc/unotbl.hxx
@@ -337,7 +337,7 @@ public:
     SwXTextTable(SwFrmFmt& rFrmFmt);
 
 
-    static const ::com::sun::star::uno::Sequence< sal_Int8 > & getUnoTunnelId();
+	SW_DLLPUBLIC static const ::com::sun::star::uno::Sequence< sal_Int8 > & getUnoTunnelId();
 
     //XUnoTunnel
     virtual sal_Int64 SAL_CALL getSomething( const ::com::sun::star::uno::Sequence< sal_Int8 >& aIdentifier ) throw(::com::sun::star::uno::RuntimeException);
diff --git sw/source/core/doc/doc.cxx sw/source/core/doc/doc.cxx
index a414c8f..acb6532 100644
--- sw/source/core/doc/doc.cxx
+++ sw/source/core/doc/doc.cxx
@@ -119,9 +119,7 @@
 
 #include <osl/diagnose.h>
 #include <osl/interlck.h>
-#ifdef FUTURE_VBA
 #include <vbahelper/vbaaccesshelper.hxx>
-#endif
 
 /* @@@MAINTAINABILITY-HORROR@@@
    Probably unwanted dependency on SwDocShell
@@ -2724,7 +2722,6 @@ void SwDoc::ChkCondColls()
      }
 }
 
-#ifdef FUTURE_VBA
 uno::Reference< script::vba::XVBAEventProcessor >
 SwDoc::GetVbaEventProcessor()
 {
@@ -2743,7 +2740,6 @@ SwDoc::GetVbaEventProcessor()
     }
     return mxVbaEvents;
 }
-#endif
 
 void SwDoc::setExternalData(::sw::tExternalDataType eType,
                             ::sw::tExternalDataPointer pPayload)
diff --git sw/source/core/unocore/unocoll.cxx sw/source/core/unocore/unocoll.cxx
index 03df3e1..9e71620 100644
--- sw/source/core/unocore/unocoll.cxx
+++ sw/source/core/unocore/unocoll.cxx
@@ -79,7 +79,16 @@
 #include <unorefmark.hxx>
 #include <unometa.hxx>
 #include "docsh.hxx"
-
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/vba/XVBAModuleInfo.hpp>
+#include <vbahelper/vbaaccesshelper.hxx>
+#include <basic/basmgr.hxx>
+#include <comphelper/processfactory.hxx>
 
 using ::rtl::OUString;
 using namespace ::com::sun::star;
@@ -89,6 +98,184 @@ using namespace ::com::sun::star::text;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::lang;
 
+class SwVbaCodeNameProvider : public ::cppu::WeakImplHelper1< document::XCodeNameQuery >
+{
+    SwDocShell* mpDocShell;
+    rtl::OUString msThisDocumentCodeName;
+public:
+    SwVbaCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+        // XCodeNameQuery
+    rtl::OUString SAL_CALL getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+    {
+        // Initialise the code name
+        if ( msThisDocumentCodeName.getLength() == 0 )
+        {
+            try
+            {
+                uno::Reference< beans::XPropertySet > xProps( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< container::XNameAccess > xLibContainer( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BasicLibraries") ) ), uno::UNO_QUERY_THROW );
+		rtl::OUString sProjectName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) );
+                if ( mpDocShell->GetBasicManager()->GetName().Len() )
+                    sProjectName =  mpDocShell->GetBasicManager()->GetName();
+    
+                uno::Reference< container::XNameAccess > xLib( xLibContainer->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+                uno::Sequence< rtl::OUString > sModuleNames = xLib->getElementNames();
+                uno::Reference< script::vba::XVBAModuleInfo > xVBAModuleInfo( xLib, uno::UNO_QUERY );
+
+                for ( sal_Int32 i=0; i < sModuleNames.getLength(); ++i )
+                {
+                    script::ModuleInfo mInfo;
+                 
+                    if ( xVBAModuleInfo->hasModuleInfo( sModuleNames[ i ] ) &&  xVBAModuleInfo->getModuleInfo( sModuleNames[ i ] ).ModuleType == script::ModuleType::DOCUMENT )
+                    {
+                        msThisDocumentCodeName = sModuleNames[ i ];
+                        break;
+                    } 
+                }
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+        rtl::OUString sCodeName;
+        if ( mpDocShell )
+        {
+            OSL_TRACE( "*** In ScVbaCodeNameProvider::getCodeNameForObject");
+            // need to find the page ( and index )  for this control
+            uno::Reference< drawing::XDrawPageSupplier > xSupplier( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+            sal_Int32 nLen = xIndex->getCount();
+            bool bMatched = false;
+            uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+                try
+                {
+                    uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex, uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                    // get the www-standard container
+                    uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                    sal_Int32 nCntrls = xFormControls->getCount();
+                    for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                    {
+                        uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                        bMatched = ( xControl == xIf );
+                        if ( bMatched )
+                        {
+                            sCodeName = msThisDocumentCodeName;
+                            break;
+                        }
+                    }
+                }
+                catch( uno::Exception& ) {}
+        }
+        // Probably should throw here ( if !bMatched )
+        return sCodeName;
+    }
+};
+
+typedef std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash > StringHashMap;
+class SwVbaProjectNameProvider : public ::cppu::WeakImplHelper1< container::XNameContainer >
+{
+    SwDocShell* mpDocShell;
+    StringHashMap mTemplateToProject; 
+public:
+    SwVbaProjectNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        return ( mTemplateToProject.find( aName ) != mTemplateToProject.end() );
+    }
+    virtual ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        return uno::makeAny( mTemplateToProject.find( aName )->second );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aElements( mTemplateToProject.size() );
+        StringHashMap::iterator it_end = mTemplateToProject.end();
+        sal_Int32 index = 0;
+        for ( StringHashMap::iterator it = mTemplateToProject.begin(); it != it_end; ++it, ++index )
+            aElements[ index ] = it->first;
+        return aElements;
+    }
+
+    virtual void SAL_CALL insertByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::ElementExistException, com::sun::star::lang::WrappedTargetException )
+    {
+        
+        rtl::OUString sProjectName;
+        aElement >>= sProjectName;
+        OSL_TRACE("** Template cache inserting template name %s with project %s"
+            , rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr()
+            , rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mTemplateToProject[ aName ] = sProjectName;
+    }
+
+    virtual void SAL_CALL removeByName( const rtl::OUString& Name ) throw ( com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( Name ) )
+            throw container::NoSuchElementException();
+        mTemplateToProject.erase( Name );
+    }
+    virtual void SAL_CALL replaceByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        insertByName( aName, aElement ); // insert will overwrite
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        return ::getCppuType((const rtl::OUString*)0); 
+    }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) 
+    { 
+        
+        return ( mTemplateToProject.size() > 0 );
+    }
+
+};
+
+class SwVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    SwDocShell* mpDocShell;
+public:
+    SwVbaObjectForCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        // #FIXME #TODO is the code name for ThisDocument read anywhere?
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        // #FIXME #TODO we really need to be checking against the codename for 
+        // ThisDocument 
+        if ( aName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisDocument" ) ) ) )
+            return sal_True;
+        return sal_False;
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+             throw container::NoSuchElementException();
+	uno::Sequence< uno::Any > aArgs( 2 );
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( mpDocShell->GetModel() );
+        uno::Reference< uno::XInterface > xDocObj = ooo::vba::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.word.Document" , aArgs );
+        OSL_TRACE("Creating Object ( ooo.vba.word.Document ) 0x%x", xDocObj.get() );
+        return  uno::makeAny( xDocObj );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aNames;
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
+
 /******************************************************************************
  *
  ******************************************************************************/
@@ -211,6 +398,10 @@ const ProvNamesId_Type __FAR_DATA aProvNamesId[] =
     { "com.sun.star.text.Fieldmark",                          SW_SERVICE_TYPE_FIELDMARK },
     { "com.sun.star.text.FormFieldmark",                      SW_SERVICE_TYPE_FORMFIELDMARK },
     { "com.sun.star.text.InContentMetadata",                  SW_SERVICE_TYPE_META },
+    { "ooo.vba.VBAObjectModuleObjectProvider",                SW_SERVICE_VBAOBJECTPROVIDER },
+    { "ooo.vba.VBACodeNameProvider",                          SW_SERVICE_VBACODENAMEPROVIDER },
+    { "ooo.vba.VBAProjectNameProvider",                       SW_SERVICE_VBAPROJECTNAMEPROVIDER },
+    { "ooo.vba.VBAGlobals",                       SW_SERVICE_VBAGLOBALS },
 
     // case-correct versions of the service names (see #i67811)
     { CSS_TEXT_TEXTFIELD_DATE_TIME,                   SW_SERVICE_FIELDTYPE_DATETIME },
@@ -391,6 +582,50 @@ uno::Reference< uno::XInterface >   SwXServiceProvider::MakeInstance(sal_uInt16
             xRet =  (cppu::OWeakObject*)pFieldmark;
         }
         break;
+		case  SW_SERVICE_VBAOBJECTPROVIDER :
+		{
+			SwVbaObjectForCodeNameProvider* pObjProv = new SwVbaObjectForCodeNameProvider( pDoc->GetDocShell() );
+			xRet =  (cppu::OWeakObject*)pObjProv;
+		}
+		break;
+		case  SW_SERVICE_VBACODENAMEPROVIDER :
+		{
+			if ( pDoc->GetDocShell()  && ooo::vba::isAlienWordDoc( *pDoc->GetDocShell() ) )
+			{
+				SwVbaCodeNameProvider* pObjProv = new SwVbaCodeNameProvider( pDoc->GetDocShell() );
+				xRet =  (cppu::OWeakObject*)pObjProv;
+			}
+		}
+		break;
+		case  SW_SERVICE_VBAPROJECTNAMEPROVIDER :
+		{
+                        uno::Reference< container::XNameContainer > xProjProv = pDoc->GetVBATemplateToProjectCache();
+                        if ( !xProjProv.is() && pDoc->GetDocShell()  && ooo::vba::isAlienWordDoc( *pDoc->GetDocShell() ) )
+                        {
+			    xProjProv = new SwVbaProjectNameProvider( pDoc->GetDocShell() );
+                            pDoc->SetVBATemplateToProjectCache( xProjProv );
+                        }
+			//xRet =  (cppu::OWeakObject*)xProjProv;
+			xRet = xProjProv;
+		}
+		break;
+        case  SW_SERVICE_VBAGLOBALS :
+        {
+            if ( pDoc )
+            {
+                uno::Any aGlobs;
+                if ( !pDoc->GetDocShell()->GetBasicManager()->GetGlobalUNOConstant( "VBAGlobals", aGlobs ) )
+                {
+                    uno::Sequence< uno::Any > aArgs(1);
+                    aArgs[ 0 ] <<= pDoc->GetDocShell()->GetModel();
+                    aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( ::rtl::OUString::createFromAscii( "ooo.vba.word.Globals"), aArgs );
+                    pDoc->GetDocShell()->GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+                }
+                aGlobs >>= xRet;
+            }
+        }
+        break;
+
         case  SW_SERVICE_TYPE_FOOTNOTE :
             xRet =  (cppu::OWeakObject*)new SwXFootnote(sal_False);
         break;
diff --git sw/source/core/unocore/unomap.cxx sw/source/core/unocore/unomap.cxx
index f5aee26..f4df212 100644
--- sw/source/core/unocore/unomap.cxx
+++ sw/source/core/unocore/unomap.cxx
@@ -1580,11 +1580,13 @@ const SfxItemPropertyMapEntry* SwUnoPropertyMapProvider::GetPropertyMapEntries(s
                     { SW_PROP_NMID(UNO_NAME_CHAR_LOCALE), RES_CHRATR_LANGUAGE ,   CPPU_E2T(CPPUTYPE_LOCALE), PropertyAttribute::MAYBEVOID,  MID_LANG_LOCALE },
                     { SW_PROP_NMID(UNO_NAME_CHARACTER_COUNT), WID_DOC_CHAR_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_DIALOG_LIBRARIES), WID_DOC_DIALOG_LIBRARIES,  CPPU_E2T(CPPUTYPE_REFLIBCONTAINER), PropertyAttribute::READONLY, 0},
+                    { SW_PROP_NMID(UNO_NAME_VBA_DOCOBJ), WID_DOC_VBA_DOCOBJ,  CPPU_E2T(CPPUTYPE_PROPERTYVALUE), PropertyAttribute::READONLY, 0},
                     { SW_PROP_NMID(UNO_NAME_INDEX_AUTO_MARK_FILE_U_R_L), WID_DOC_AUTO_MARK_URL, CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_PARAGRAPH_COUNT), WID_DOC_PARA_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_RECORD_CHANGES), WID_DOC_CHANGES_RECORD,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_SHOW_CHANGES), WID_DOC_CHANGES_SHOW,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_WORD_COUNT), WID_DOC_WORD_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
+					{ SW_PROP_NMID(UNO_NAME_IS_TEMPLATE), WID_DOC_ISTEMPLATEID,			CPPU_E2T(CPPUTYPE_BOOLEAN),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_WORD_SEPARATOR), WID_DOC_WORD_SEPARATOR,		CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_HIDE_FIELD_TIPS), WID_DOC_HIDE_TIPS, 			CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_REDLINE_DISPLAY_TYPE), WID_DOC_REDLINE_DISPLAY, 	CPPU_E2T(CPPUTYPE_INT16),	PROPERTY_NONE,   0},
diff --git sw/source/core/unocore/unoprnms.cxx sw/source/core/unocore/unoprnms.cxx
index 228b489..6a98b97 100644
--- sw/source/core/unocore/unoprnms.cxx
+++ sw/source/core/unocore/unoprnms.cxx
@@ -778,7 +778,10 @@ const SwPropNameTab aPropNameTab = {
 /* 0736 UNO_NAME_OUTLINE_LEVEL */       {MAP_CHAR_LEN("OutlineLevel")},//#outline level,add<-zhaojianwei Outlinelevel
 /* 0737 UNO_NAME_DESCRIPTION */         {MAP_CHAR_LEN("Description")},
 /* 0738 UNO_NAME_META */        {MAP_CHAR_LEN("InContentMetadata")},
-/* 0739 UNO_NAME_NESTED_TEXT_CONTENT */ {MAP_CHAR_LEN("NestedTextContent")},
+/* 0739 UNO_NAME_IS_TEMPLATE */       {MAP_CHAR_LEN("IsTemplate")},
+/* 0740 UNO_NAME_VBA_DOCOBJ */       {MAP_CHAR_LEN("ThisVBADocObj")},
+
+/* 0741 UNO_NAME_NESTED_TEXT_CONTENT */ {MAP_CHAR_LEN("NestedTextContent")},
 };
 
 const SwPropNameLen& SwGetPropName( USHORT nId )
diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index a1d1242..80f8278 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -67,6 +67,7 @@ EXCEPTIONSFILES = \
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
+        $(SLO)$/ww8toolbar.obj \
         $(SLO)$/WW8FibData.obj \
         $(SLO)$/rtfexportfilter.obj \
         $(SLO)$/rtfimportfilter.obj \
@@ -101,6 +102,7 @@ SLOFILES =	\
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
+        $(SLO)$/ww8toolbar.obj \
         $(SLO)$/WW8FibData.obj \
         $(SLO)$/rtfexportfilter.obj \
         $(SLO)$/rtfimportfilter.obj \
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index 04341ab..c71f885 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -128,11 +128,19 @@
 #include <svl/itemiter.hxx>  //SfxItemIter
 
 #include <stdio.h>
+#include <comphelper/processfactory.hxx>
+#include <basic/basmgr.hxx>
+
+#include "ww8toolbar.hxx"
+#include <osl/file.hxx>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif
+#include <unotools/localfilehelper.hxx>
+#include <comphelper/configurationhelper.hxx>
 
 #include "WW8Sttbf.hxx"
 #include "WW8FibData.hxx"
@@ -144,6 +152,87 @@ using namespace sw::util;
 using namespace sw::types;
 using namespace nsHdFtFlags;
 
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/container/XNameReplace.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <filter/msfilter/msvbahelper.hxx>
+#include <unotools/pathoptions.hxx>
+#include <com/sun/star/ucb/XSimpleFileAccess.hpp>
+
+class Sttb : TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    SBBItem() : cchData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+
+    std::vector< SBBItem > dataItems;
+
+    Sttb(const Sttb&);
+    Sttb& operator = ( const Sttb&);
+public:
+    Sttb();
+    ~Sttb();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    rtl::OUString getStringAtIndex( sal_uInt32 );
+};
+
+Sttb::Sttb() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+{
+}
+
+Sttb::~Sttb()
+{
+}
+
+bool Sttb::Read( SvStream* pS )
+{
+    OSL_TRACE("Sttb::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            SBBItem aItem;
+            *pS >> aItem.cchData;
+            aItem.data = readUnicodeString( pS, aItem.cchData );
+            dataItems.push_back( aItem );
+        }
+    }
+    return true;
+}
+
+void Sttb::Print( FILE* fp )
+{
+    fprintf( fp, "[ 0x%x ] Sttb - dump\n", nOffSet);
+    fprintf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    fprintf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            fprintf(fp,"   string dataItem[ %d(0x%x) ] has name %s\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+
+}
+
+rtl::OUString 
+Sttb::getStringAtIndex( sal_uInt32 index )
+{
+    rtl::OUString aRet;
+    if ( index < dataItems.size() )
+        aRet = dataItems[ index ].data;
+    return aRet;
+}
 
 SwMSDffManager::SwMSDffManager( SwWW8ImplReader& rRdr )
     : SvxMSDffManager(*rRdr.pTableStream, rRdr.GetBaseURL(), rRdr.pWwFib->fcDggInfo,
@@ -3783,11 +3872,168 @@ void SwWW8ImplReader::ReadDocInfo()
         DBG_ASSERT(xDocProps.is(), "DocumentProperties is null");
 
         if (xDocProps.is()) {
+            if ( pWwFib->fDot )
+            {
+                rtl::OUString sTemplateURL;
+                SfxMedium* pMedium = mpDocShell->GetMedium();
+                if ( pMedium )
+                {
+                    rtl::OUString aName = pMedium->GetName();
+                    INetURLObject aURL( aName );
+                    sTemplateURL = aURL.GetMainURL(INetURLObject::DECODE_TO_IURI);
+                    if ( sTemplateURL.getLength() > 0 )
+                        xDocProps->setTemplateURL( sTemplateURL );
+                }
+            }
+            else // not a template
+            {
+                long nCur = pTableStream->Tell();
+                Sttb aSttb;
+                pTableStream->Seek( pWwFib->fcSttbfAssoc ); // point at tgc record
+                if (!aSttb.Read( pTableStream ) )
+                    OSL_TRACE("** Read of SttbAssoc data failed!!!! ");
+                pTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+                aSttb.Print( stderr );
+#endif
+                String sPath = aSttb.getStringAtIndex( 0x1 );
+                String aURL;
+                // attempt to convert to url ( won't work for obvious reasons on  linux 
+                if ( sPath.Len() )
+	        	::utl::LocalFileHelper::ConvertPhysicalNameToURL( sPath, aURL );
+                if ( aURL.Len() )
+                    xDocProps->setTemplateURL( aURL );
+                else
+                    xDocProps->setTemplateURL( sPath );
+                
+            }
             sfx2::LoadOlePropertySet(xDocProps, pStg);
         }
     }
 }
 
+void lcl_createTemplateToProjectEntry( const uno::Reference< container::XNameContainer >& xPrjNameCache, const rtl::OUString& sTemplatePathOrURL, const rtl::OUString& sVBAProjName )
+{
+    if ( xPrjNameCache.is() )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sTemplatePathOrURL );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+            aURL = sTemplatePathOrURL;
+        else
+        {
+            osl::FileBase::getFileURLFromSystemPath( sTemplatePathOrURL, aURL );
+            aObj.SetURL( aURL );
+        }
+        try
+        {
+            rtl::OUString templateNameWithExt = aObj.GetLastName();
+            rtl::OUString templateName;
+            sal_Int32 nIndex =  templateNameWithExt.lastIndexOf( '.' );
+            //xPrjNameCache->insertByName( templateNameWithExt, uno::makeAny( sVBAProjName ) );    
+            if ( nIndex != -1 )
+            {
+                templateName = templateNameWithExt.copy( 0, nIndex );
+                xPrjNameCache->insertByName( templateName, uno::makeAny( sVBAProjName ) );    
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+}
+
+class WW8Customizations
+{
+    SvStream* mpTableStream;
+    WW8Fib mWw8Fib;
+public:
+    WW8Customizations( SvStream*, WW8Fib& );
+    bool  Import( SwDocShell* pShell );
+};
+
+WW8Customizations::WW8Customizations( SvStream* pTableStream, WW8Fib& rFib ) : mpTableStream(pTableStream), mWw8Fib( rFib )
+{
+}
+
+bool WW8Customizations::Import( SwDocShell* pShell ) 
+{
+    if ( mWw8Fib.lcbCmds == 0 )
+        return false;
+    Tcg aTCG;
+    long nCur = mpTableStream->Tell();
+    mpTableStream->Seek( mWw8Fib.fcCmds ); // point at tgc record
+    bool bReadResult = aTCG.Read( mpTableStream );
+    mpTableStream->Seek( nCur ); // return to previous position, is that necessary?
+    if ( !bReadResult )
+    {
+        OSL_TRACE("** Read of Customization data failed!!!! ");
+        return false;
+    }
+#if DEBUG
+    aTCG.Print( stderr );
+#endif
+    return aTCG.ImportCustomToolBar( *pShell );
+}
+
+bool SwWW8ImplReader::ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const uno::Reference< container::XNameContainer >& xPrjNameCache )
+{
+    SvtPathOptions aPathOpt;
+    String aAddinPath = aPathOpt.GetAddinPath();
+    uno::Sequence< rtl::OUString > sGlobalTemplates;
+
+    // first get the autoload addins in the directory STARTUP
+    uno::Reference< ucb::XSimpleFileAccess > xSFA( ::comphelper::getProcessServiceFactory()->createInstance( rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), uno::UNO_QUERY_THROW );
+
+    if( xSFA->isFolder( aAddinPath ) )
+        sGlobalTemplates = xSFA->getFolderContents( aAddinPath, sal_False );
+
+    sal_Int32 nEntries = sGlobalTemplates.getLength();
+    bool bRes = true;
+    const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+    for ( sal_Int32 i=0; i<nEntries; ++i )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sGlobalTemplates[ i ] );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+                aURL = sGlobalTemplates[ i ];
+        else
+                osl::FileBase::getFileURLFromSystemPath( sGlobalTemplates[ i ], aURL );        
+        if ( !aURL.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) || ( sCreatedFrom.getLength() && sCreatedFrom.equals( aURL ) ) )
+            continue; // don't try and read the same document as ourselves
+
+        SotStorageRef rRoot = new SotStorage( aURL, STREAM_STD_READWRITE, STORAGE_TRANSACTED ); 
+
+        // Read Macro Projects
+        SvxImportMSVBasic aVBasic(*mpDocShell, *rRoot,
+            pVBAFlags->IsLoadWordBasicCode(),
+            pVBAFlags->IsLoadWordBasicStorage() );
+
+
+        String s1(CREATE_CONST_ASC("Macros"));
+        String s2(CREATE_CONST_ASC("VBA"));
+        aVBasic.Import( s1, s2, !pVBAFlags->IsLoadWordBasicExecutable() );
+        lcl_createTemplateToProjectEntry( xPrjNameCache, aURL, aVBasic.GetVBAProjectName() );
+        // Read toolbars & menus
+        SvStorageStreamRef refMainStream = rRoot->OpenSotStream( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("WordDocument") ) );
+        refMainStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+        WW8Fib aWwFib( *refMainStream, 8 );       
+        SvStorageStreamRef xTableStream = rRoot->OpenSotStream(String::CreateFromAscii( aWwFib.fWhichTblStm ? SL::a1Table : SL::a0Table), STREAM_STD_READ);
+
+        if (xTableStream.Is() && SVSTREAM_OK == xTableStream->GetError())
+        {
+            xTableStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+            WW8Customizations aGblCustomisations( xTableStream, aWwFib ); 
+            aGblCustomisations.Import( mpDocShell );
+        }
+    }
+    return bRes;
+}
+
 ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
 {
     ULONG nErrRet = 0;
@@ -4071,7 +4317,59 @@ ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
     }
     else //ordinary case
     {
+        if (mbNewDoc && pStg && !pGloss) /*meaningless for a glossary, cmc*/
+        {
+            mpDocShell->SetIsTemplate( pWwFib->fDot ); // point at tgc record
+            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+            maTracer.EnterEnvironment(sw::log::eMacros);
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    
+            rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
+            uno::Reference< container::XNameContainer > xPrjNameCache;
+            uno::Reference< lang::XMultiServiceFactory> xSF(mpDocShell->GetModel(), uno::UNO_QUERY);
+            if ( xSF.is() )
+                xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
+
+            // Read Global templates 
+            ReadGlobalTemplateSettings( sCreatedFrom, xPrjNameCache );
+#endif 
+            // Create and insert Word vba Globals
+            uno::Any aGlobs;
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[ 0 ] <<= mpDocShell->GetModel();
+            aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( ::rtl::OUString::createFromAscii( "ooo.vba.word.Globals"), aArgs );
+            mpDocShell->GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+            
+            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
+                            pVBAFlags->IsLoadWordBasicCode(),
+                            pVBAFlags->IsLoadWordBasicStorage() );
+            String s1(CREATE_CONST_ASC("Macros"));
+            String s2(CREATE_CONST_ASC("VBA"));
+            int nRet = aVBasic.Import( s1, s2, !pVBAFlags->IsLoadWordBasicExecutable() );
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            lcl_createTemplateToProjectEntry( xPrjNameCache, sCreatedFrom, aVBasic.GetVBAProjectName() );
+            WW8Customizations aCustomisations( pTableStream, *pWwFib ); 
+            aCustomisations.Import( mpDocShell );
+#endif 
+            if( 2 & nRet )
+            {
+                maTracer.Log(sw::log::eContainsVisualBasic);
+                rDoc.SetContainsMSVBasic(true);
+            }
+
+            StoreMacroCmds();
+
+            maTracer.LeaveEnvironment(sw::log::eMacros);
+        }
         ReadText(0, pWwFib->ccpText, MAN_MAINTEXT);
+
     }
 
     ::SetProgressState(nProgress, mpDocShell);    // Update
@@ -4145,26 +4443,6 @@ ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
             eMode |= nsRedlineMode_t::REDLINE_ON;
         if( pWDop->fRMView )
             eMode |= nsRedlineMode_t::REDLINE_SHOW_DELETE;
-        if (pStg && !pGloss) /*meaningless for a glossary, cmc*/
-        {
-            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
-            maTracer.EnterEnvironment(sw::log::eMacros);
-            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
-                            pVBAFlags->IsLoadWordBasicCode(),
-                            pVBAFlags->IsLoadWordBasicStorage() );
-            String s1(CREATE_CONST_ASC("Macros"));
-            String s2(CREATE_CONST_ASC("VBA"));
-            int nRet = aVBasic.Import( s1, s2 );
-            if( 2 & nRet )
-            {
-                maTracer.Log(sw::log::eContainsVisualBasic);
-                rDoc.SetContainsMSVBasic(true);
-            }
-
-            StoreMacroCmds();
-
-            maTracer.LeaveEnvironment(sw::log::eMacros);
-        }
     }
 
     maInsertedTables.DelAndMakeTblFrms();
diff --git sw/source/filter/ww8/ww8par.hxx sw/source/filter/ww8/ww8par.hxx
index a2b92ee..95a072f 100644
--- sw/source/filter/ww8/ww8par.hxx
+++ sw/source/filter/ww8/ww8par.hxx
@@ -1417,7 +1417,7 @@ private:
     // determine object attribute "Layout in Table Cell"
     bool IsObjectLayoutInTableCell( const UINT32 nLayoutInTableCell ) const;
     // <--
-
+    bool ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xPrjNameMap );
     //No copying
     SwWW8ImplReader(const SwWW8ImplReader &);
     SwWW8ImplReader& operator=(const SwWW8ImplReader&);
diff --git sw/source/filter/ww8/ww8toolbar.cxx sw/source/filter/ww8/ww8toolbar.cxx
new file mode 100644
index 0000000..e9fb6a3
--- /dev/null
+++ sw/source/filter/ww8/ww8toolbar.cxx
@@ -0,0 +1,1302 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+// no. of visual data elements in a CTB ( fixed ) 
+const short nVisualData = 5;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOWordCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOWordCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOWordCommandConvertor::MSOWordCommandConvertor()
+{
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+Customization* CTBWrapper::GetCustomizaton( sal_Int16 index )
+{
+    if ( index < 0 || index >= static_cast<sal_Int16>( rCustomizations.size() ) )
+        return NULL;
+    return &rCustomizations[ index ]; 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        if ( it->GetCustomizationData() && it->GetCustomizationData()->GetName().equals( sTBName ) )
+        {
+            pCTB = it->GetCustomizationData();
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::Read( SvStream* pS )
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    long nExpectedPos =  pS->Tell() + cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        int nStart = pS->Tell();
+
+        int bytesRead = 0;
+        int bytesToRead = cbDTBC - bytesRead; 
+        // cbDTBC specifies the size ( in bytes ) taken by an array ( of unspecified size )
+        // of TBC records ( TBC records have dynamic length, so we need to check our position
+        // after each read )
+        do
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rtbdc.push_back( aTBC );
+            bytesToRead = cbDTBC - ( pS->Tell() - nStart ); 
+        } while ( bytesToRead > 0 );
+    }
+    if ( static_cast< long >( pS->Tell() ) != nExpectedPos )
+    {
+        // Strange error condition, shouldn't happen ( but does in at least
+        // one test document ) In the case where it happens the TBC & 
+        // TBCHeader records seem blank??? ( and incorrect )
+        OSL_ENSURE( pS->Tell() == nExpectedPos, "### Error: Expected pos not equal to actual pos after reading rtbdc");
+        OSL_TRACE("\tPos now is 0x%x should be 0x%x", pS->Tell(), nExpectedPos );
+        // seek to correct position after rtbdc
+        pS->Seek( nExpectedPos );
+    }
+    if ( cCust )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            Customization aCust( this );
+            if ( !aCust.Read( pS ) )
+                return false;
+            rCustomizations.push_back( aCust );
+        } 
+    } 
+    std::vector< sal_Int16 >::iterator it_end = dropDownMenuIndices.end();
+    for ( std::vector< sal_Int16 >::iterator it = dropDownMenuIndices.begin(); it != it_end; ++it )
+    {
+        rCustomizations[ *it ].bIsDroppedMenuTB = true;
+    }
+    return true;
+}
+
+TBC* CTBWrapper::GetTBCAtOffset( sal_uInt32 nStreamOffset )
+{
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it )
+    {
+        if ( (*it).GetOffset() == nStreamOffset )
+            return &(*it);
+    }
+    return NULL;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] CTBWrapper - dump\n", nOffSet );
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        indent_printf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        indent_printf(fp,"    reserved1(0x%x)\n",ch);
+        indent_printf(fp,"    reserved2(0x%x)\n",reserved2);
+        indent_printf(fp,"    reserved3(0x%x)\n",reserved3);
+        indent_printf(fp,"    reserved4(0x%x)\n",reserved4);
+        indent_printf(fp,"    reserved5(0x%x)\n",reserved5);
+        indent_printf(fp,"Quiting dump");
+        return;
+    }
+    indent_printf(fp,"  size of TBDelta structures 0x%x\n", cbTBD );
+    indent_printf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    indent_printf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+
+    sal_Int32 index = 0;
+
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping rtbdc[%d]\n", static_cast< int >( index ));
+        Indent b;
+        it->Print( fp );
+    }
+
+    index = 0;
+
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+        Indent c;
+        it->Print(fp);
+    }
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) );
+        helper.setMSOCommandMap( new MSOWordCommandConvertor() );
+
+        if ( !(*it).ImportCustomToolBar( *this, helper ) )
+            return false;
+    }
+    return false;
+}
+
+Customization::Customization( CTBWrapper* wrapper ) : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, pWrapper( wrapper )
+, bIsDroppedMenuTB( false )
+{
+}
+
+Customization::~Customization()
+{
+}
+
+bool Customization::Read( SvStream *pS)
+{
+    OSL_TRACE("Custimization::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD )
+    {
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+        {
+            TBDelta aTBDelta;
+            if (!aTBDelta.Read( pS ) )
+                return false;
+            customizationDataTBDelta.push_back( aTBDelta );
+            // Only set the drop down for menu's associated with standard toolbar
+            if ( aTBDelta.ControlDropsToolBar() && tbidForTBD == 0x25 )
+                pWrapper->InsertDropIndex( aTBDelta.CustomizationIndex() );
+        }
+    }
+    else
+    {
+        customizationDataCTB.reset( new CTB() );
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] Customization -- dump \n", nOffSet );
+    indent_printf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    indent_printf( fp,"  reserved1 0x%x \n", reserved1);
+    indent_printf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+    {
+        const char* pToolBar = NULL;
+        switch ( tbidForTBD )
+        {
+            case 0x9:
+                pToolBar = "Standard";
+                break;
+            case 0x25:
+                pToolBar = "Builtin-Menu";
+                break;
+            default:
+                pToolBar = "Unknown toolbar";
+                break;
+        }
+        
+        indent_printf( fp,"  TBDelta(s) are associated with %s toolbar.\n", pToolBar);
+        std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin();
+        for ( sal_Int32 index = 0; index < ctbds; ++it,++index )
+            it->Print( fp );
+    }
+    
+}
+
+bool Customization::ImportMenu( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( tbidForTBD == 0x25 )  // we can handle in a limited way additions the built-in menu bar
+    {
+        for ( std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin(); it != customizationDataTBDelta.end(); ++it )
+        {
+            // for each new menu ( control that drops a toolbar )
+            // import a toolbar
+            if ( it->ControlIsInserted() && it->ControlDropsToolBar() )
+            {
+                Customization* pCust = pWrapper->GetCustomizaton( it->CustomizationIndex() );
+                if ( pCust )
+                {
+                    // currently only support built-in menu
+                    rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+
+                    sMenuBar = sMenuBar.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("menubar") ) );
+                    // Get menu name
+                    TBC* pTBC = pWrapper->GetTBCAtOffset( it->TBCStreamOffset() );
+                    if ( !pTBC )
+                        return false;
+                    rtl::OUString sMenuName = pTBC->GetCustomText();
+                    sMenuName = sMenuName.replace('&','~');
+
+                    // see if the document has already setting for the menubar
+                
+                    uno::Reference< container::XIndexContainer > xIndexContainer;
+                    bool bHasSettings = false;
+                    if ( helper.getCfgManager()->hasSettings( sMenuBar ) )
+                    {
+                        xIndexContainer.set( helper.getCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        bHasSettings = true;
+                    }
+                    else
+                    {
+                        if ( helper.getAppCfgManager()->hasSettings( sMenuBar ) )
+                            xIndexContainer.set( helper.getAppCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        else 
+                            xIndexContainer.set( helper.getAppCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+                    }
+               
+                    uno::Reference< lang::XSingleComponentFactory > xSCF( xIndexContainer, uno::UNO_QUERY_THROW );
+                    uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                    uno::Reference< uno::XComponentContext > xContext(  xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+                    // create the popup menu
+                    uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+                    aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                    aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + sMenuName );
+                    aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+                    aPopupMenu[1].Value <<= sMenuName;
+                    aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+                    aPopupMenu[2].Value <<= sal_Int32( 0 );
+                    aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    uno::Reference< container::XIndexContainer > xMenuContainer( xSCF->createInstanceWithContext( xContext ), uno::UNO_QUERY_THROW );
+                    aPopupMenu[3].Value <<= xMenuContainer;
+                    if ( pCust->customizationDataCTB.get() && !pCust->customizationDataCTB->ImportMenuTB( rWrapper, xMenuContainer, helper ) )
+                        return false;
+                    OSL_TRACE("** there are %d menu items on the bar, inserting after that", xIndexContainer->getCount() );
+                    xIndexContainer->insertByIndex( xIndexContainer->getCount(), uno::makeAny( aPopupMenu ) );
+
+                    if ( bHasSettings )
+                        helper.getCfgManager()->replaceSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+                    else
+                        helper.getCfgManager()->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+                }
+            }
+        }
+        return true;
+    }
+    return true;
+}
+
+bool Customization::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( GetTBIDForTB() == 0x25 )
+        return ImportMenu( rWrapper, helper );
+    if ( !customizationDataCTB.get() )
+        return false;
+    if ( !customizationDataCTB->IsMenuToolbar() )
+    {
+        if ( !customizationDataCTB->ImportCustomToolBar( rWrapper, helper ) )
+            return false;
+    }
+    return true;
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::ControlIsModified()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x2 );
+}
+
+bool TBDelta::ControlIsInserted()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlIsChanged()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlDropsToolBar()
+{
+    return !( CiTBDE & 0x8000 );
+}
+
+sal_Int32 TBDelta::TBCStreamOffset()
+{
+    return fc;
+}
+
+sal_Int16 TBDelta::CustomizationIndex()
+{
+    sal_Int16 nIndex = CiTBDE;
+    nIndex = nIndex >> 1;
+    nIndex &= 0x1ff; // only 13 bits are relevant
+    return nIndex;
+}
+
+bool TBDelta::Read(SvStream *pS)
+{
+    OSL_TRACE("TBDelta::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    *pS >> CiTBDE >> cbTBC;
+    return true;
+}
+
+void TBDelta::Print( FILE* fp )
+{
+    // Like most of the debug output, it's raw and little ( no )
+    // interpretation of the data is output ( e.g. flag values etc. )
+    indent_printf( fp, "[ 0x%x ] TBDelta -- dump\n", nOffSet );
+    indent_printf( fp, " doprfatendFlags 0x%x\n",doprfatendFlags );
+    
+    indent_printf( fp, " ibts 0x%x\n",ibts );
+    indent_printf( fp, " cidNext 0x%x\n", static_cast< unsigned int >( cidNext ) );
+    indent_printf( fp, " cid 0x%x\n", static_cast< unsigned int >( cid ) );
+    indent_printf( fp, " fc 0x%x\n", static_cast< unsigned int >( fc ) );
+    indent_printf( fp, " CiTBDE 0x%x\n",CiTBDE );
+    indent_printf( fp, " cbTBC 0x%x\n", cbTBC );
+    if ( ControlDropsToolBar() )
+    {
+        indent_printf( fp, " this delta is associated with a control that drops a menu toolbar\n", cbTBC );
+        indent_printf( fp, " the menu toolbar drops the toolbar defined at index[%d] in the rCustomizations array of the CTBWRAPPER that contains this TBDelta\n", CustomizationIndex() );
+    }
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+{
+}
+
+CTB::~CTB()
+{
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+
+bool CTB::Read( SvStream *pS)
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    if ( !tb.Read( pS ) )
+        return false;
+    for ( short index = 0; index < nVisualData; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rTBC.push_back( aTBC );
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] CTB - dump\n", nOffSet );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    for ( short counter = 0; counter < nVisualData; ++counter )
+    {
+        indent_printf( fp, "  TBVisualData [%d]\n", counter);
+        Indent b;
+        rVisualData[ counter ].Print( fp );
+    } 
+    indent_printf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            indent_printf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            // createToolBar item for control
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+    
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1 // don't think this is necessary
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif
+        bRes = true;
+    }
+    catch( uno::Exception& e )
+    {
+        OSL_TRACE("***** For some reason we have an exception %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+        bRes = false;
+    }
+    return bRes;
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xIndexContainer, CustomToolBarImportHelper& rHelper )
+{
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+    {
+        // createToolBar item for control
+        if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, rHelper, true ) )
+            return false;
+    }
+    return true;
+}
+
+TBC::TBC()
+{
+}
+
+TBC::~TBC()
+{
+}
+
+bool TBC::Read( SvStream *pS )
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.getTcID() != 0x1 && tbch.getTcID() != 0x1051 )
+    {
+        cid.reset( new sal_uInt32 );
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.getTct() != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBC -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid.get() )
+        indent_printf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        indent_printf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+bool
+TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar )
+{
+    // cmtFci       0x1 Command based on a built-in command. See CidFci.
+    // cmtMacro     0x2 Macro command. See CidMacro.
+    // cmtAllocated 0x3 Allocated command. See CidAllocated.
+    // cmtNil       0x7 No command. See Cid.
+    bool bBuiltin = false;
+    sal_uInt16 cmdId = 0;
+    if  ( cid.get() )
+    {
+        sal_uInt16 arg2 = ( *( cid.get() ) & 0xFFFF );
+
+        sal_uInt8 cmt = ( arg2 & 0x7 );
+        arg2 = ( arg2 >> 3 );
+
+        switch ( cmt )
+        {
+            case 1:
+                OSL_TRACE("cmt is cmtFci builtin command 0x%x", arg2);
+                bBuiltin = true;
+                cmdId = arg2;
+                break;
+            case 2:
+                OSL_TRACE("cmt is cmtMacro macro 0x%x", arg2);
+                break;
+            case 3:
+                OSL_TRACE("cmt is cmtAllocated [???] 0x%x", arg2);
+                break;
+            case 7:
+                OSL_TRACE("cmt is cmNill no-phing 0x%x", arg2);
+                break;
+            default:
+                OSL_TRACE("illegal 0x%x", cmt);
+                break;
+        }
+    }
+
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+        }
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuBar ) )
+            return false;
+
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            OSL_TRACE("** control has a menu, name of toolbar with menu items is %s", rtl::OUStringToOString( pMenu->Name(), RTL_TEXTENCODING_UTF8 ).getStr() );
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                if ( !pCustTB->ImportMenuTB( rWrapper,xMenuDesc, helper ) )
+                    return false;     
+                if ( !bIsMenuBar )
+                {
+                    if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                        return false;
+                }
+                else
+                {
+                    beans::PropertyValue aProp;
+                    aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    aProp.Value <<= xMenuDesc;
+                    props.push_back( aProp );
+                }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );       
+        }
+ 
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+rtl::OUString 
+TBC::GetCustomText()
+{
+    rtl::OUString sCustomText;
+    if ( tbcd.get() )
+        sCustomText = tbcd->getGeneralInfo().CustomText();
+    return sCustomText;
+   
+    
+}
+
+bool 
+Xst::Read( SvStream* pS )
+{
+    OSL_TRACE("Xst::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] Xst -- dump\n", nOffSet );
+    indent_printf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    Indent a(true);
+    indent_printf(fp, "[ 0x%x ] Tcg - dump %d\n", nOffSet, nTcgVer);
+    indent_printf(fp,"  nTcgVer %d\n", nTcgVer);
+    if ( tcg.get() )
+        tcg->Print( fp );
+}
+
+bool Tcg::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    if ( tcg.get() )
+        return tcg->ImportCustomToolBar( rDocSh );
+    return false;
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SvStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    // Find the CTBWrapper
+    for ( std::vector< Tcg255SubStruct* >::const_iterator it = rgtcgData.begin(); it != rgtcgData.end(); ++it )
+    {
+        if ( (*it)->id() == 0x12 )
+        {
+            // not so great, shouldn't really have to do a horror casting    
+            CTBWrapper* pCTBWrapper =  dynamic_cast< CTBWrapper* > ( *it );
+            if ( pCTBWrapper )
+            {
+                if ( !pCTBWrapper->ImportCustomToolBar( rDocSh ) )
+                    return false;
+            }
+        }
+    }
+    return true;
+}
+
+
+bool Tcg255::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] Tcg255 - dump\n", nOffSet );
+    indent_printf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        Indent b;
+        indent_printf(fp, "  [%d] Tcg255SubStruct \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255SubStruct::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SvStream *pS)
+{
+    OSL_TRACE("PffMcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfMcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SvStream *pS)
+{
+    OSL_TRACE("PffAcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfAcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SvStream *pS)
+{
+    OSL_TRACE("PlfKme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfKme ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SvStream *pS) 
+{
+    OSL_TRACE("TcgSttbf::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TcgSttbf - dump\n", nOffSet );
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SvStream* pS )
+{
+    OSL_TRACE("TcgSttbfCore::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TcgSttbfCore - dump\n");
+    indent_printf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    indent_printf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    indent_printf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            indent_printf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SvStream *pS)
+{
+    OSL_TRACE("MacroNames::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] MacroNames ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SvStream *pS)
+{
+    OSL_TRACE("MacroName::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MacroName - dump");
+    indent_printf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SvStream *pS)
+{
+    OSL_TRACE("Xstz::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] Xstz -- dump\n", nOffSet );
+    indent_printf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    indent_printf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SvStream *pS)
+{
+    OSL_TRACE("Kme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> kt >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    Indent a;
+    
+   indent_printf( fp, "[ 0x%x ] Kme - dump\n", nOffSet );
+   indent_printf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   indent_printf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   indent_printf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   indent_printf( fp, " kt 0x%x \n", kt );
+   indent_printf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SvStream *pS)
+{
+    OSL_TRACE("Acd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] ACD - dump\n", nOffSet );
+    // #TODO flesh out interpretation of these values
+    indent_printf( fp,"  ibst 0x%x\n", ibst);
+    indent_printf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SvStream *pS)
+{
+    OSL_TRACE("MCD::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MCD - dump\n", nOffSet );
+    indent_printf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+    indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+    indent_printf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+    indent_printf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+    indent_printf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+    indent_printf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+    indent_printf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+    indent_printf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+    indent_printf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
diff --git sw/source/filter/ww8/ww8toolbar.hxx sw/source/filter/ww8/ww8toolbar.hxx
new file mode 100644
index 0000000..a8b3342
--- /dev/null
+++ sw/source/filter/ww8/ww8toolbar.hxx
@@ -0,0 +1,347 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <filter/msfilter/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SvStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class CTBWrapper;
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr< sal_uInt32 > cid; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper&, bool );
+    rtl::OUString GetCustomText();
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    std::vector< TBC > rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+};
+
+class TBDelta : public TBBase
+{
+    sal_uInt8 doprfatendFlags;
+
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt16 CiTBDE; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ControlIsModified();
+    bool ControlIsInserted();
+    bool ControlIsChanged();
+    bool ControlDropsToolBar();
+    sal_Int32 TBCStreamOffset();
+    sal_Int16 CustomizationIndex();
+    
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() const { return ch; }
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper;
+class Customization : public TBBase
+{
+friend class CTBWrapper;
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+    CTBWrapper* pWrapper;
+    boost::shared_ptr< CTB > customizationDataCTB;
+    std::vector< TBDelta > customizationDataTBDelta; 
+    bool bIsDroppedMenuTB; 
+    bool ImportMenu( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+public:    
+    Customization( CTBWrapper* rapper );
+    ~Customization();
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenu( CTBWrapper&, CustomToolBarImportHelper& );
+    void Print( FILE* );
+    sal_Int32 GetTBIDForTB(){ return tbidForTBD; }
+    CTB*  GetCustomizationData() { return customizationDataCTB.get(); };
+};
+
+class SfxObjectShell; 
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    std::vector< TBC > rtbdc; // 
+    std::vector< Customization > rCustomizations; // array of Customizations
+    std::vector< sal_Int16 > dropDownMenuIndices; // array of indexes of Customization toolbars that are dropped by a menu
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    void InsertDropIndex( sal_Int32 aIndex ) { dropDownMenuIndices.push_back( aIndex ); }
+    TBC* GetTBCAtOffset( sal_uInt32 nStreamOffset );
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+
+    Customization* GetCustomizaton( sal_Int16 index );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macros name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SvStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SvStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    void Print( FILE* );
+};
+
+#endif
diff --git sw/source/ui/app/docsh.cxx sw/source/ui/app/docsh.cxx
index 5a1b860..190c301 100755
--- sw/source/ui/app/docsh.cxx
+++ sw/source/ui/app/docsh.cxx
@@ -491,13 +491,6 @@ sal_Bool SwDocShell::SaveAs( SfxMedium& rMedium )
             xDocSh->DoClose();
         }
 
-        if( pDoc->ContainsMSVBasic() )
-        {
-            if( SvtFilterOptions::Get()->IsLoadWordBasicStorage() )
-                nVBWarning = GetSaveWarningOfMSVBAStorage( (SfxObjectShell&) *this );
-            pDoc->SetContainsMSVBasic( FALSE );
-        }
-
         // TabellenBox Edit beenden!
         if( pWrtShell )
             pWrtShell->EndAllTblBoxEdit();
diff --git sw/source/ui/app/docsh2.cxx sw/source/ui/app/docsh2.cxx
index b0ae693..fa9765e 100644
--- sw/source/ui/app/docsh2.cxx
+++ sw/source/ui/app/docsh2.cxx
@@ -119,10 +119,8 @@
 #include <com/sun/star/ui/dialogs/ListboxControlActions.hpp>
 #include <com/sun/star/ui/dialogs/CommonFilePickerElementIds.hpp>
 #include "com/sun/star/ui/dialogs/TemplateDescription.hpp"
-#ifdef FUTURE_VBA
 #include <com/sun/star/script/vba/XVBAEventProcessor.hpp>
 #include <com/sun/star/script/vba/VBAEventId.hpp>
-#endif
 #include <editeng/acorrcfg.hxx>
 #include <SwStyleNameMapper.hxx>
 
@@ -190,7 +188,6 @@ void SwDocShell::DoFlushDocInfo()
     }
 }
 
-#ifdef FUTURE_VBA
 void lcl_processCompatibleSfxHint( const uno::Reference< script::vba::XVBAEventProcessor >& xVbaEvents, const SfxHint& rHint )
 {
     using namespace com::sun::star::script::vba::VBAEventId;
@@ -209,7 +206,6 @@ void lcl_processCompatibleSfxHint( const uno::Reference< script::vba::XVBAEventP
         }
     }
 }
-#endif
 
 /*--------------------------------------------------------------------
     Beschreibung: 	Benachrichtigung bei geaenderter DocInfo
@@ -224,11 +220,9 @@ void SwDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
         return ;
     }
 
-#ifdef FUTURE_VBA
     uno::Reference< script::vba::XVBAEventProcessor > xVbaEvents = pDoc->GetVbaEventProcessor();
     if( xVbaEvents.is() )
         lcl_processCompatibleSfxHint( xVbaEvents, rHint );
-#endif
 
     USHORT nAction = 0;
     if( rHint.ISA(SfxSimpleHint) )
@@ -311,7 +305,6 @@ USHORT SwDocShell::PrepareClose( BOOL bUI, BOOL bForBrowsing )
     if( TRUE == nRet ) //Unbedingt auf TRUE abfragen! (RET_NEWTASK)
         EndListening( *this );
 
-#ifdef FUTURE_VBA
     if( pDoc && IsInPrepareClose() )
     {
         uno::Reference< script::vba::XVBAEventProcessor > xVbaEvents = pDoc->GetVbaEventProcessor();
@@ -322,7 +315,6 @@ USHORT SwDocShell::PrepareClose( BOOL bUI, BOOL bForBrowsing )
             xVbaEvents->processVbaEvent( DOCUMENT_CLOSE, aArgs );
         }    
     }    
-#endif
     return nRet;
 }
 
@@ -1531,6 +1523,34 @@ void SwDocShell::Execute(SfxRequest& rReq)
     }
 }
 
+ // #FIXME - align with NEW event stuff ( if possible )
+#if 0
+void lcl_processCompatibleSfxHint( const uno::Reference< document::XVbaEventsHelper >& xVbaEventsHelper, const SfxHint& rHint )
+{
+    if ( rHint.ISA( SfxEventHint ) )
+    {
+        uno::Sequence< uno::Any > aArgs;
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch( nEventId )
+        {
+            case SFX_EVENT_CREATEDOC:
+            {
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_DOCUMENT_NEW, aArgs );
+                break;
+            }
+            case SFX_EVENT_OPENDOC:
+            {
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_DOCUMENT_OPEN, aArgs );
+                break;
+            }
+            default:
+            {
+                //do nothing
+            }
+        }
+    }
+}
+#endif
 
 /*--------------------------------------------------------------------
     Beschreibung:
@@ -1587,6 +1604,12 @@ void SwDocShell::FillClass( SvGlobalName * pClassName,
         *pClipFormat	= bTemplate ? SOT_FORMATSTR_ID_STARWRITER_8_TEMPLATE : SOT_FORMATSTR_ID_STARWRITER_8;
         *pLongUserName = SW_RESSTR(STR_WRITER_DOCUMENT_FULLTYPE);
     }
+// #FIXME check with new Event handling
+#if 0 
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper = pDoc->GetVbaEventsHelper();
+    if( xVbaEventsHelper.is() )
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
+#endif
 
     *pUserName = SW_RESSTR(STR_HUMAN_SWDOC_NAME);
 }
diff --git sw/source/ui/uno/unotxdoc.cxx sw/source/ui/uno/unotxdoc.cxx
index e3f1322..94a850b 100644
--- sw/source/ui/uno/unotxdoc.cxx
+++ sw/source/ui/uno/unotxdoc.cxx
@@ -178,6 +178,7 @@ using ::osl::FileBase;
 #define SW_CREATE_MARKER_TABLE          0x06
 #define SW_CREATE_DRAW_DEFAULTS         0x07
 
+#include <comphelper/processfactory.hxx> 
 
 /******************************************************************************
  *
@@ -256,6 +257,12 @@ sal_Int64 SAL_CALL SwXTextDocument::getSomething( const Sequence< sal_Int8 >& rI
     {
             return sal::static_int_cast< sal_Int64 >( reinterpret_cast< sal_IntPtr >( this ));
     }
+    if( rId.getLength() == 16
+        && 0 == rtl_compareMemory( SfxObjectShell::getUnoTunnelId().getConstArray(),
+										rId.getConstArray(), 16 ) )
+    {
+        return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(pDocShell ));
+    }
 
     sal_Int64 nRet = SfxBaseModel::getSomething( rId );
     if ( nRet )
@@ -404,6 +411,9 @@ SwXTextDocument::SwXTextDocument(SwDocShell* pShell) :
     m_pPrintUIOptions( NULL ),
     m_pRenderData( NULL )
 {
+    uno::Reference< document::XDocumentProperties > xWriterProps( ::comphelper::getProcessServiceFactory()->createInstance( DEFINE_CONST_UNICODE("com.sun.star.writer.DocumentProperties") ), uno::UNO_QUERY_THROW);
+
+    SfxBaseModel::setDocumentProperties( xWriterProps );
 }
 /*-- 18.12.98 11:53:00---------------------------------------------------
 
@@ -2173,6 +2183,9 @@ Any SwXTextDocument::getPropertyValue(const OUString& rPropertyName)
     Any aAny;
     switch(pEntry->nWID)
     {
+		case WID_DOC_ISTEMPLATEID    :
+			aAny <<= pDocShell->IsTemplate();
+			break;
         case  WID_DOC_CHAR_COUNT     :
         case  WID_DOC_PARA_COUNT     :
         case  WID_DOC_WORD_COUNT     :
@@ -2281,6 +2294,14 @@ Any SwXTextDocument::getPropertyValue(const OUString& rPropertyName)
         case WID_DOC_DIALOG_LIBRARIES:
             aAny <<= pDocShell->GetDialogContainer();
         break;
+        case WID_DOC_VBA_DOCOBJ:
+        {
+            beans::PropertyValue aProp;
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWordDoc") );
+            aProp.Value <<= pDocShell->GetModel();
+            aAny <<= aProp;
+        }
+        break;
         case WID_DOC_RUNTIME_UID:
             aAny <<= getRuntimeUID();
         break;
@@ -3189,6 +3210,7 @@ uno::Sequence< lang::Locale > SAL_CALL SwXTextDocument::getDocumentLanguages(
 {
     ::vos::OGuard aGuard(Application::GetSolarMutex());
 
+
     // possible canonical values for nScriptTypes
     // any bit wise combination is allowed
     const sal_Int16 nLatin   = 0x001;
diff --git sw/source/ui/vba/makefile.mk sw/source/ui/vba/makefile.mk
index b6d0d79..b0fb0f4 100644
--- sw/source/ui/vba/makefile.mk
+++ sw/source/ui/vba/makefile.mk
@@ -82,6 +82,7 @@ SLOFILES= \
                 $(SLO)$/vbaborders.obj \
                 $(SLO)$/vbadocuments.obj \
                 $(SLO)$/vbaheaderfooter.obj \
+				$(SLO)$/vbaheadersfooters.obj \
                 $(SLO)$/vbaheaderfooterhelper.obj \
                 $(SLO)$/vbaaddin.obj \
                 $(SLO)$/vbaaddins.obj \
@@ -91,6 +92,29 @@ SLOFILES= \
                 $(SLO)$/vbapagesetup.obj \
                 $(SLO)$/vbasection.obj \
                 $(SLO)$/vbasections.obj \
+				$(SLO)$/vbarow.obj \
+				$(SLO)$/vbarows.obj \
+				$(SLO)$/vbacolumn.obj \
+				$(SLO)$/vbacolumns.obj \
+				$(SLO)$/vbatablehelper.obj \
+				$(SLO)$/vbacell.obj \
+				$(SLO)$/vbacells.obj \
+				$(SLO)$/vbatabstop.obj \
+				$(SLO)$/vbatabstops.obj \
+				$(SLO)$/vbatableofcontents.obj \
+				$(SLO)$/vbatablesofcontents.obj \
+				$(SLO)$/vbalistgallery.obj \
+				$(SLO)$/vbalistgalleries.obj \
+				$(SLO)$/vbalisthelper.obj \
+				$(SLO)$/vbalisttemplate.obj \
+				$(SLO)$/vbalisttemplates.obj \
+				$(SLO)$/vbalistlevel.obj \
+				$(SLO)$/vbalistlevels.obj \
+				$(SLO)$/vbalistformat.obj \
+				$(SLO)$/vbarevision.obj \
+				$(SLO)$/vbarevisions.obj \
+				$(SLO)$/vbaframe.obj \
+				$(SLO)$/vbaframes.obj \
                 $(SLO)$/vbaeventshelper.obj \
 
 # --- Targets ------------------------------------------------------
diff --git sw/source/ui/vba/service.cxx sw/source/ui/vba/service.cxx
index 8200e32..a80a69a 100644
--- sw/source/ui/vba/service.cxx
+++ sw/source/ui/vba/service.cxx
@@ -57,6 +57,11 @@ namespace vbaeventshelper
 extern sdecl::ServiceDecl const serviceDecl;
 }
 
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
 extern "C"
 {
     void SAL_CALL component_getImplementationEnvironment( 
diff --git sw/source/ui/vba/vbaapplication.cxx sw/source/ui/vba/vbaapplication.cxx
index fd815b2..4ce05bc 100644
--- sw/source/ui/vba/vbaapplication.cxx
+++ sw/source/ui/vba/vbaapplication.cxx
@@ -40,6 +40,7 @@
 #include <editeng/acorrcfg.hxx>
 #include "wordvbahelper.hxx"
 #include <docsh.hxx>
+#include "vbalistgalleries.hxx"
 
 using namespace ::ooo;
 using namespace ::ooo::vba;
@@ -151,6 +152,16 @@ SwVbaApplication::Dialogs( const uno::Any& index ) throw (uno::RuntimeException)
     return uno::makeAny( xCol );
 }
 
+uno::Any SAL_CALL
+SwVbaApplication::ListGalleries( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextDocument > xTextDoc( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaListGalleries( this, mxContext, xTextDoc ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
 sal_Bool SAL_CALL SwVbaApplication::getDisplayAutoCompleteTips() throw (css::uno::RuntimeException)
 {
     return SvxAutoCorrCfg::Get()->IsAutoTextTip();
diff --git sw/source/ui/vba/vbaapplication.hxx sw/source/ui/vba/vbaapplication.hxx
index 66f9bca..2f4d912 100644
--- sw/source/ui/vba/vbaapplication.hxx
+++ sw/source/ui/vba/vbaapplication.hxx
@@ -60,6 +60,7 @@ public:
     virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL ListGalleries( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual sal_Bool SAL_CALL getDisplayAutoCompleteTips() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setDisplayAutoCompleteTips( sal_Bool _displayAutoCompleteTips ) throw (css::uno::RuntimeException);
     virtual sal_Int32 SAL_CALL getEnableCancelKey() throw (css::uno::RuntimeException);
diff --git sw/source/ui/vba/vbaautotextentry.cxx sw/source/ui/vba/vbaautotextentry.cxx
index 5d098a2..8c92627 100644
--- sw/source/ui/vba/vbaautotextentry.cxx
+++ sw/source/ui/vba/vbaautotextentry.cxx
@@ -26,7 +26,9 @@
  ************************************************************************/
 #include "vbaautotextentry.hxx"
 #include <vbahelper/vbahelper.hxx>
+#include <com/sun/star/text/XParagraphCursor.hpp>
 #include <tools/diagnose_ex.h>
+#include "wordvbahelper.hxx"
 #include "vbarange.hxx"
 
 using namespace ::ooo::vba;
@@ -41,7 +43,7 @@ SwVbaAutoTextEntry::~SwVbaAutoTextEntry()
 {
 }
 
-uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::Reference< word::XRange >& _where, const uno::Any& /*_richtext*/ ) throw ( uno::RuntimeException )
+uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::Reference< word::XRange >& _where, const uno::Any& _richtext ) throw ( uno::RuntimeException )
 {
     SwVbaRange* pWhere = dynamic_cast<SwVbaRange*>( _where.get() );
     if( pWhere )
@@ -55,8 +57,28 @@ uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::R
         uno::Reference< text::XTextCursor > xTC = xText->createTextCursorByRange( xTextRange->getStart() );
         xTC->goRight( 1, sal_True );
         xTC->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
+        // remove the blank paragraph if it is a rich text
+        sal_Bool bRich = sal_False;
+        _richtext >>= bRich;
+        if( bRich )
+        {
+            // check if it is a blank paragraph
+            uno::Reference< text::XParagraphCursor > xParaCursor( xTC, uno::UNO_QUERY_THROW );
+            if( xParaCursor->isStartOfParagraph() && xParaCursor->isEndOfParagraph() )
+            {
+                //remove the blank paragraph
+                uno::Reference< frame::XModel > xModel( getCurrentWordDoc( mxContext ), uno::UNO_QUERY_THROW );
+                uno::Reference< text::XTextViewCursor > xTVCursor = word::getXTextViewCursor( xModel );
+                uno::Reference< text::XTextRange > xCurrentRange( xTC->getEnd(), uno::UNO_QUERY_THROW );
+                xTVCursor->gotoRange( xCurrentRange, sal_False );
+                rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Delete"));
+                dispatchRequests( xModel,url );
+                xTVCursor->gotoRange( xEndMarker->getEnd(), sal_False );
+            }
+        }
         xEndMarker->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
-        xTC->gotoRange( xEndMarker, sal_True );
+        //xTC->gotoRange( xEndMarker, sal_True );
+        xTC = xText->createTextCursorByRange( xEndMarker->getEnd() );
         pWhere->setXTextCursor( xTC );
     }
     return uno::Reference< word::XRange >( pWhere );
@@ -95,8 +117,9 @@ SwVbaAutoTextEntries::getElementType() throw (uno::RuntimeException)
 uno::Reference< container::XEnumeration >
 SwVbaAutoTextEntries::createEnumeration() throw (uno::RuntimeException)
 {
-    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
-    return xEnumerationAccess->createEnumeration();
+    //uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    //return xEnumerationAccess->createEnumeration();
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 }
 
 uno::Any
diff --git sw/source/ui/vba/vbabookmark.cxx sw/source/ui/vba/vbabookmark.cxx
index bb67fac..f5ff0fe 100644
--- sw/source/ui/vba/vbabookmark.cxx
+++ sw/source/ui/vba/vbabookmark.cxx
@@ -29,9 +29,12 @@
 #include <tools/diagnose_ex.h>
 #include <com/sun/star/text/XTextDocument.hpp>
 #include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
 #include "vbarange.hxx"
+#include "wordvbahelper.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -65,8 +68,8 @@ void SAL_CALL SwVbaBookmark::Delete() throw ( uno::RuntimeException )
 void SAL_CALL SwVbaBookmark::Select() throw ( uno::RuntimeException )
 {
     checkVality();
-    uno::Reference< text::XTextViewCursorSupplier > xViewCursorSupplier( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    xViewCursorSupplier->getViewCursor()->gotoRange( mxBookmark->getAnchor(),sal_False );
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( mxBookmark ) );
 }
 
 rtl::OUString SAL_CALL SwVbaBookmark::getName() throw ( uno::RuntimeException )
diff --git sw/source/ui/vba/vbabookmarks.cxx sw/source/ui/vba/vbabookmarks.cxx
index bccfeef..841b7e7 100644
--- sw/source/ui/vba/vbabookmarks.cxx
+++ sw/source/ui/vba/vbabookmarks.cxx
@@ -118,8 +118,7 @@ SwVbaBookmarks::SwVbaBookmarks( const uno::Reference< XHelperInterface >& xParen
     mxBookmarksSupplier.set( mxModel, uno::UNO_QUERY_THROW );
     uno::Reference< text::XTextDocument > xDocument( mxModel, uno::UNO_QUERY_THROW );
     // use view cursor to insert bookmark, or it will fail if insert bookmark in table
-    // mxText = xDocument->getText();
-    mxText = word::getXTextViewCursor( mxModel )->getText();
+    //mxText = word::getXTextViewCursor( mxModel )->getText();
 }
 // XEnumerationAccess
 uno::Type
@@ -145,16 +144,16 @@ SwVbaBookmarks::createCollectionObject( const css::uno::Any& aSource )
 void SwVbaBookmarks::removeBookmarkByName( const rtl::OUString& rName ) throw (uno::RuntimeException)
 {
     uno::Reference< text::XTextContent > xBookmark( m_xNameAccess->getByName( rName ), uno::UNO_QUERY_THROW );
-    mxText->removeTextContent( xBookmark );
+    word::getXTextViewCursor( mxModel )->getText()->removeTextContent( xBookmark );
 }
 
-void SwVbaBookmarks::addBookmarkByName( const rtl::OUString& rName, const uno::Reference< text::XTextRange >& rTextRange ) throw (uno::RuntimeException)
+void SwVbaBookmarks::addBookmarkByName( const uno::Reference< frame::XModel >& xModel, const rtl::OUString& rName, const uno::Reference< text::XTextRange >& rTextRange ) throw (uno::RuntimeException)
 {
-    uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< lang::XMultiServiceFactory > xDocMSF( xModel, uno::UNO_QUERY_THROW );
     uno::Reference< text::XTextContent > xBookmark( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Bookmark")) ), uno::UNO_QUERY_THROW );
     uno::Reference< container::XNamed > xNamed( xBookmark, uno::UNO_QUERY_THROW );
     xNamed->setName( rName );
-    mxText->insertTextContent( rTextRange, xBookmark, sal_False );
+    rTextRange->getText()->insertTextContent( rTextRange, xBookmark, sal_False );
 }
 
 uno::Any SAL_CALL
@@ -180,7 +179,7 @@ SwVbaBookmarks::Add( const rtl::OUString& rName, const uno::Any& rRange ) throw
     if( m_xNameAccess->hasByName( aName ) )
         removeBookmarkByName( aName );
     
-    addBookmarkByName( aName, xTextRange );
+    addBookmarkByName( mxModel, aName, xTextRange );
 
     return uno::makeAny( uno::Reference< word::XBookmark >( new SwVbaBookmark( getParent(), mxContext, mxModel, aName ) ) );
 }
diff --git sw/source/ui/vba/vbabookmarks.hxx sw/source/ui/vba/vbabookmarks.hxx
index 5efef7a..29e26b9 100644
--- sw/source/ui/vba/vbabookmarks.hxx
+++ sw/source/ui/vba/vbabookmarks.hxx
@@ -47,12 +47,12 @@ private:
 
 private:
     void removeBookmarkByName( const rtl::OUString& rName ) throw (css::uno::RuntimeException);
-    void addBookmarkByName( const rtl::OUString& rName, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw (css::uno::RuntimeException);
 
 public:
     SwVbaBookmarks( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xBookmarks, const css::uno::Reference< css::frame::XModel >& xModel );
     virtual ~SwVbaBookmarks() {}
 
+    static void addBookmarkByName( const css::uno::Reference< css::frame::XModel >& xModel, const rtl::OUString& rName, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw (css::uno::RuntimeException);
     // XEnumerationAccess
     virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
diff --git sw/source/ui/vba/vbaborders.cxx sw/source/ui/vba/vbaborders.cxx
index 634ab63..1cd2b0d 100644
--- sw/source/ui/vba/vbaborders.cxx
+++ sw/source/ui/vba/vbaborders.cxx
@@ -348,14 +348,19 @@ SwVbaBorders::getItemByIntIndex( const sal_Int32 nIndex )  throw (uno::RuntimeEx
 
 sal_Bool SAL_CALL SwVbaBorders::getShadow() throw (uno::RuntimeException)
 {
+    /*
     table::ShadowFormat aShadowFormat;
     m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShadowFormat") ) ) >>= aShadowFormat;
     return ( aShadowFormat.Location != table::ShadowLocation_NONE );
+    */
+    // always return False for table border in MS Word
+    return sal_False;
 }
 
 void SAL_CALL SwVbaBorders::setShadow( sal_Bool /*_shadow*/ ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    // not support in Table border in Word
+    // TODO: 
 }
 
 rtl::OUString& 
diff --git sw/source/ui/vba/vbacell.cxx sw/source/ui/vba/vbacell.cxx
new file mode 100644
index 0000000..8b05bf7
--- /dev/null
+++ sw/source/ui/vba/vbacell.cxx
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacell.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbatable.hxx"
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+#include "vbarow.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaCell::SwVbaCell( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nColumn, sal_Int32 nRow ) throw ( uno::RuntimeException ) :
+    SwVbaCell_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnColumn( nColumn ), mnRow( nRow )
+{
+}
+
+SwVbaCell::~SwVbaCell()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaCell::getWidth() throw (css::uno::RuntimeException)
+{
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    return aTableHelper.GetColWidth( mnColumn, mnRow, sal_True );
+}
+
+void SAL_CALL SwVbaCell::setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException)
+{
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    aTableHelper.SetColWidth( _width, mnColumn, mnRow, sal_True );
+}
+
+uno::Any SAL_CALL SwVbaCell::getHeight() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    return xRow->getHeight();
+}
+
+void SAL_CALL SwVbaCell::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    xRow->setHeight( _height );
+}
+
+::sal_Int32 SAL_CALL SwVbaCell::getHeightRule() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    return xRow->getHeightRule();
+}
+
+void SAL_CALL SwVbaCell::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    xRow->setHeightRule( _heightrule );
+}
+
+void SAL_CALL SwVbaCell::SetWidth( float width, sal_Int32 /*rulestyle*/ ) throw (css::uno::RuntimeException)
+{
+    // FIXME: handle the argument: rulestyle
+    setWidth( width );
+}
+
+void SAL_CALL SwVbaCell::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    // FIXME: handle the argument: heightrule 
+    setHeightRule( heightrule );
+    setHeight( uno::makeAny( height ) );
+}
+
+rtl::OUString& 
+SwVbaCell::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCell") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaCell::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Cell" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbacell.hxx sw/source/ui/vba/vbacell.hxx
new file mode 100644
index 0000000..1350288
--- /dev/null
+++ sw/source/ui/vba/vbacell.hxx
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CELL_HXX
+#define SW_VBA_CELL_HXX
+
+#include <ooo/vba/word/XCell.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XCell > SwVbaCell_BASE;
+
+class SwVbaCell : public SwVbaCell_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnColumn;
+    sal_Int32 mnRow;
+
+public:
+	SwVbaCell( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nColumn, sal_Int32 nRow ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCell();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_CELL_HXX */
diff --git sw/source/ui/vba/vbacells.cxx sw/source/ui/vba/vbacells.cxx
new file mode 100644
index 0000000..919306b
--- /dev/null
+++ sw/source/ui/vba/vbacells.cxx
@@ -0,0 +1,223 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacells.hxx"
+#include "vbacell.hxx"
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+#include "vbarow.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > CellCollectionHelper_Base;
+
+class CellsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	CellsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class CellCollectionHelper : public CellCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnLeft;
+    sal_Int32 mnTop;
+    sal_Int32 mnRight;
+    sal_Int32 mnBottom;
+
+public:
+	CellCollectionHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw ( css::uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), mnLeft( nLeft ), mnTop( nTop ), mnRight( nRight ), mnBottom( nBottom )
+    {
+    }
+	virtual ~CellCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return ( mnRight - mnLeft + 1 ) * ( mnBottom - mnTop + 1 );
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw css::lang::IndexOutOfBoundsException();
+        
+        for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+        {
+            for( sal_Int32 col = mnLeft; col <= mnRight; col++ )
+            {
+                if( Index == ( ( row - mnTop ) * ( mnRight - mnLeft + 1 ) + ( col - mnLeft ) ) )
+                    return uno::makeAny( uno::Reference< word::XCell >( new SwVbaCell( mxParent, mxContext, mxTextTable, col, row ) ) );
+            }
+        }
+        throw css::lang::IndexOutOfBoundsException();
+        
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XCell::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new CellsEnumWrapper( this );
+    }
+};
+
+SwVbaCells::SwVbaCells( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw (uno::RuntimeException) : SwVbaCells_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new CellCollectionHelper( xParent, xContext, xTextTable, nLeft, nTop, nRight, nBottom ) ) ), mxTextTable( xTextTable ), mnLeft( nLeft ), mnTop( nTop ), mnRight( nRight ), mnBottom( nBottom )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaCells::getWidth() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+    return xCell->getWidth();
+}
+
+void SAL_CALL SwVbaCells::setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    while( nIndex < m_xIndexAccess->getCount() )
+    {
+        uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( nIndex++ ), uno::UNO_QUERY_THROW );
+        xCell->setWidth( _width );
+    }
+}
+
+uno::Any SAL_CALL SwVbaCells::getHeight() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnTop ) );
+    return xRow->getHeight();
+}
+
+void SAL_CALL SwVbaCells::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->setHeight( _height );
+    }    
+}
+
+::sal_Int32 SAL_CALL SwVbaCells::getHeightRule() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnTop ) );
+    return xRow->getHeightRule();
+}
+
+void SAL_CALL SwVbaCells::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->setHeightRule( _heightrule );
+    }    
+}
+
+void SAL_CALL SwVbaCells::SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    while( nIndex < m_xIndexAccess->getCount() )
+    {
+        uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( nIndex++ ), uno::UNO_QUERY_THROW );
+        xCell->SetWidth( width, rulestyle );
+    }
+}
+
+void SAL_CALL SwVbaCells::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->SetHeight( height, heightrule );
+    }    
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaCells::getElementType() throw (uno::RuntimeException)
+{
+	return word::XCell::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaCells::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaCells::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaCells::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCells") );
+	return sImplName;
+} 
+
+uno::Sequence<rtl::OUString> 
+SwVbaCells::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Cells") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbacells.hxx sw/source/ui/vba/vbacells.hxx
new file mode 100644
index 0000000..3468b29
--- /dev/null
+++ sw/source/ui/vba/vbacells.hxx
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CELLS_HXX
+#define SW_VBA_CELLS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XCells.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XCells > SwVbaCells_BASE;
+
+class SwVbaCells : public SwVbaCells_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnLeft;
+    sal_Int32 mnTop;
+    sal_Int32 mnRight;
+    sal_Int32 mnBottom;
+
+public:
+	SwVbaCells( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCells() {}
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaCells_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_CELLS_HXX */
diff --git sw/source/ui/vba/vbacheckbox.cxx sw/source/ui/vba/vbacheckbox.cxx
new file mode 100644
index 0000000..307f7a2
--- /dev/null
+++ sw/source/ui/vba/vbacheckbox.cxx
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacheckbox.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <ecmaflds.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaCheckBox::SwVbaCheckBox( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& rModel, const uno::Reference< text::XFormField >& xFormField ) throw ( uno::RuntimeException ) : SwVbaCheckBox_BASE( rParent, rContext ), mxModel( rModel ), mxFormField( xFormField )
+{
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( !sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        throw uno::RuntimeException( rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("It is not a CheckBox")), uno::Reference< uno::XInterface >() );
+    }
+}
+
+SwVbaCheckBox::~SwVbaCheckBox()
+{
+}
+
+sal_Bool SAL_CALL SwVbaCheckBox::getValue() throw ( uno::RuntimeException )
+{
+    sal_Bool bValue = sal_False;
+    sal_Int32 nCount = mxFormField->getParamCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        if( mxFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX_CHECKED ) )
+        {
+            if( mxFormField->getParamValue(i).equalsIgnoreAsciiCaseAscii("on") )
+                bValue = sal_True;
+            else
+                bValue = sal_False;
+            break;    
+        }
+    }
+    return bValue;
+}
+
+void SAL_CALL SwVbaCheckBox::setValue( sal_Bool value ) throw ( uno::RuntimeException )
+{
+    rtl::OUString sValue = rtl::OUString::createFromAscii( value ? "on" : "off" );
+    mxFormField->addParam( rtl::OUString::createFromAscii( ECMA_FORMCHECKBOX_CHECKED ), sValue, sal_True );
+}
+
+rtl::OUString& 
+SwVbaCheckBox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCheckBox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaCheckBox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.CheckBox" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbacheckbox.hxx sw/source/ui/vba/vbacheckbox.hxx
new file mode 100644
index 0000000..7b12ed5
--- /dev/null
+++ sw/source/ui/vba/vbacheckbox.hxx
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CHECKBOX_HXX
+#define SW_VBA_CHECKBOX_HXX
+
+#include <ooo/vba/word/XCheckBox.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XFormField.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XCheckBox > SwVbaCheckBox_BASE;
+
+class SwVbaCheckBox : public SwVbaCheckBox_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XFormField > mxFormField;
+
+public:
+	SwVbaCheckBox( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XFormField >& xFormField ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCheckBox();
+
+    // Methods
+    sal_Bool SAL_CALL getValue() throw ( css::uno::RuntimeException );
+    void SAL_CALL setValue( sal_Bool value ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_CHECKBOX_HXX */
diff --git sw/source/ui/vba/vbacolumn.cxx sw/source/ui/vba/vbacolumn.cxx
new file mode 100644
index 0000000..3dd4eb1
--- /dev/null
+++ sw/source/ui/vba/vbacolumn.cxx
@@ -0,0 +1,201 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacolumn.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbatable.hxx"
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+#define RELATIVE_TABLE_WIDTH 10000
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaColumn::SwVbaColumn( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( uno::RuntimeException ) :
+    SwVbaColumn_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnIndex( nIndex )
+{
+    mxTableColumns = mxTextTable->getColumns();
+}
+
+SwVbaColumn::~SwVbaColumn()
+{
+}
+
+void SwVbaColumn::calculateAbsoluteColumnWidth( sal_Int32 nTableWidth, const css::uno::Sequence< css::text::TableColumnSeparator >& aSeparators, double* pAbsWidth )
+{
+    const text::TableColumnSeparator* pArray = aSeparators.getConstArray();
+    sal_Int32 nSepCount = aSeparators.getLength();
+    for( sal_Int32 i = 0; i <= nSepCount; i++ )
+    {
+        sal_Int32 nRelColWidth = 0;
+        if( i == 0 )
+        {
+            if( nSepCount != 0 )
+            {
+                nRelColWidth = pArray[0].Position;
+            }
+            else
+            {
+                nRelColWidth = RELATIVE_TABLE_WIDTH;
+            }
+        }
+        else
+        {
+            if( i == nSepCount )
+            {
+                nRelColWidth = RELATIVE_TABLE_WIDTH - pArray[i-1].Position;
+            }
+            else
+            {
+                nRelColWidth = pArray[i].Position - pArray[i-1].Position;
+            }
+        }
+        pAbsWidth[i] = ( (double)nRelColWidth / RELATIVE_TABLE_WIDTH ) * (double) nTableWidth;
+    }
+}
+
+void SwVbaColumn::calculateRelativeColumnWidth( const double* pAbsWidth, double* pRelWidth, sal_Int32 nCount )
+{
+    double tableWidth = 0.0;
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        tableWidth += pAbsWidth[i];
+    }
+
+    pRelWidth[ nCount - 1 ] = tableWidth;
+    for( sal_Int32 i = 0; i < nCount - 1; i++ )
+    {
+        if( i == 0 )
+        {
+            pRelWidth[i] = ( pAbsWidth[i] * RELATIVE_TABLE_WIDTH ) / tableWidth;
+        }
+        else
+        {
+            pRelWidth[i] = pRelWidth[i-1] + ( pAbsWidth[i] * RELATIVE_TABLE_WIDTH ) / tableWidth;
+        }
+    }
+}
+
+sal_Int32 SAL_CALL
+SwVbaColumn::getWidth( ) throw ( css::uno::RuntimeException )
+{
+   /* uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Sequence< text::TableColumnSeparator > aSeparators;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ) ) >>= aSeparators;
+    sal_Int32 nTableWidth = SwVbaTable::getTableWidth( xTableProps );
+    sal_Int32 nColCont = aSeparators.getLength() + 1;
+    double dAbsColWidth[ nColCont ];
+    calculateAbsoluteColumnWidth( nTableWidth, aSeparators, dAbsColWidth );
+    return Millimeter::getInPoints( (sal_Int32)( dAbsColWidth[ mnIndex ] ) );
+   */ 
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    return aTableHelper.GetColWidth( mnIndex );
+}
+
+void SAL_CALL
+SwVbaColumn::setWidth( sal_Int32 _width ) throw ( css::uno::RuntimeException )
+{
+/*    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Sequence< text::TableColumnSeparator > aSeparators;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ) ) >>= aSeparators;
+    sal_Int32 nTableWidth = SwVbaTable::getTableWidth( xTableProps );
+    sal_Int32 nColCont = aSeparators.getLength() + 1;
+    double dAbsColWidth[ nColCont ];
+    calculateAbsoluteColumnWidth( nTableWidth, aSeparators, dAbsColWidth );
+    dAbsColWidth[ mnIndex ] = Millimeter::getInHundredthsOfOneMillimeter( _width );
+    double tableWidth = 0.0;
+    for( sal_Int32 i = 0; i < nColCont; i++ )
+    {
+        tableWidth += dAbsColWidth[i];
+    }
+    
+    double dRelColWidth[ nColCont ];
+    calculateRelativeColumnWidth( dAbsColWidth, dRelColWidth, nColCont);
+
+    text::TableColumnSeparator* pArray = aSeparators.getArray();
+    for( sal_Int32 i = 0; i < nColCont - 1; i++ )
+    {
+        pArray[i].Position = (sal_Int16)(dRelColWidth[i]);
+    }
+
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ), uno::makeAny( aSeparators ) );
+    SwVbaTable::setTableWidth( xTableProps, (sal_Int32)( tableWidth ) );
+    */
+
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    aTableHelper.SetColWidth( _width, mnIndex );
+}
+
+void SAL_CALL
+SwVbaColumn::Select( ) throw ( uno::RuntimeException )
+{
+    SelectColumn( getCurrentWordDoc(mxContext), mxTextTable, mnIndex, mnIndex );
+}
+
+void SwVbaColumn::SelectColumn( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nStartColumn, sal_Int32 nEndColumn ) throw ( uno::RuntimeException )
+{
+    rtl::OUStringBuffer aRangeName;
+    rtl::OUString sStartCol = SwVbaTableHelper::getColumnStr( nStartColumn );
+    aRangeName.append(sStartCol).append(sal_Int32( 1 ) );
+    rtl::OUString sEndCol = SwVbaTableHelper::getColumnStr( nEndColumn );
+    sal_Int32 nRowCount = xTextTable->getRows()->getCount();
+    aRangeName.appendAscii(":").append( sEndCol ).append( sal_Int32( nRowCount ) );
+
+    uno::Reference< table::XCellRange > xCellRange( xTextTable, uno::UNO_QUERY_THROW );
+    rtl::OUString sSelRange = aRangeName.makeStringAndClear();
+    uno::Reference< table::XCellRange > xSelRange = xCellRange->getCellRangeByName( sSelRange );
+
+    uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelection->select( uno::makeAny( xSelRange ) );
+}
+
+rtl::OUString& 
+SwVbaColumn::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaColumn") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaColumn::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Column" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbacolumn.hxx sw/source/ui/vba/vbacolumn.hxx
new file mode 100644
index 0000000..6d67bdd
--- /dev/null
+++ sw/source/ui/vba/vbacolumn.hxx
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_COLUMN_HXX
+#define SW_VBA_COLUMN_HXX
+
+#include <ooo/vba/word/XColumn.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/TableColumnSeparator.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XColumn > SwVbaColumn_BASE;
+
+class SwVbaColumn : public SwVbaColumn_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableColumns > mxTableColumns;
+    sal_Int32 mnIndex;
+
+private:
+    void calculateAbsoluteColumnWidth( sal_Int32 nTableWidth, const css::uno::Sequence< css::text::TableColumnSeparator >& aSeparators, double* pAbsWidth );
+    void calculateRelativeColumnWidth( const double* pAbsWidth, double* pRelWidth, sal_Int32 nCount );
+
+public:
+	SwVbaColumn( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaColumn();
+
+    // Methods
+    virtual sal_Int32 SAL_CALL getWidth() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    static void SelectColumn( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nStartColumn, sal_Int32 nEndColumn ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_COLUMN_HXX */
diff --git sw/source/ui/vba/vbacolumns.cxx sw/source/ui/vba/vbacolumns.cxx
new file mode 100644
index 0000000..90cd7fb
--- /dev/null
+++ sw/source/ui/vba/vbacolumns.cxx
@@ -0,0 +1,160 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacolumns.hxx"
+#include "vbacolumn.hxx"
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <ooo/vba/word/WdRulerStyle.hpp>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ColumnsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::WeakReference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< text::XTextTable > mxTextTable;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+	sal_Int32 nIndex;
+
+public:
+	ColumnsEnumWrapper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< text::XTextTable >& xTextTable ) : mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), nIndex( 0 ) 
+    {
+        mxIndexAccess.set( mxTextTable->getColumns(), uno::UNO_QUERY );
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return uno::makeAny( uno::Reference< word::XColumn > ( new SwVbaColumn( mxParent, mxContext, mxTextTable, nIndex++ ) ) );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaColumns::SwVbaColumns( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableColumns >& xTableColumns ) throw (uno::RuntimeException) : SwVbaColumns_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableColumns, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableColumns( xTableColumns ) 
+{
+    mnStartColumnIndex = 0;
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    mnEndColumnIndex = aTableHelper.getTabColumnsMaxCount( ) - 1;
+}
+
+SwVbaColumns::SwVbaColumns( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableColumns >& xTableColumns, sal_Int32 nStartCol, sal_Int32 nEndCol ) throw (uno::RuntimeException) : SwVbaColumns_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableColumns, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableColumns( xTableColumns ), mnStartColumnIndex( nStartCol ), mnEndColumnIndex( nEndCol ) 
+{
+    if( mnEndColumnIndex < mnStartColumnIndex )
+        throw uno::RuntimeException();
+}
+
+uno::Reference< word::XColumn > SwVbaColumns::getColumnAtIndex( sal_Int32 index ) throw (uno::RuntimeException)
+{
+    return uno::Reference< word::XColumn >( new SwVbaColumn( this, mxContext, mxTextTable, index ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaColumns::getWidth() throw (uno::RuntimeException)
+{
+    return getColumnAtIndex( mnStartColumnIndex )->getWidth();
+}
+
+void SAL_CALL SwVbaColumns::setWidth( ::sal_Int32 _width ) throw (uno::RuntimeException)
+{
+    for( sal_Int32 index = mnStartColumnIndex; index <= mnEndColumnIndex; index++ )
+    {
+        getColumnAtIndex( index )->setWidth( _width );
+    }
+}
+
+void SAL_CALL SwVbaColumns::Select(  ) throw (uno::RuntimeException)
+{
+    SwVbaColumn::SelectColumn( getCurrentWordDoc(mxContext), mxTextTable, mnStartColumnIndex, mnEndColumnIndex );
+}
+
+::sal_Int32 SAL_CALL SwVbaColumns::getCount() throw (uno::RuntimeException)
+{
+    return ( mnEndColumnIndex - mnStartColumnIndex + 1 );
+}
+
+uno::Any SAL_CALL SwVbaColumns::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex <= 0 || nIndex > getCount() )
+        {
+            throw  lang::IndexOutOfBoundsException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        }
+        return uno::makeAny( uno::Reference< word::XColumn >( new SwVbaColumn( this, mxContext, mxTextTable, nIndex - 1 ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaColumns::getElementType() throw (uno::RuntimeException)
+{
+	return word::XColumn::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaColumns::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ColumnsEnumWrapper( this, mxContext, mxTextTable );
+}
+
+uno::Any
+SwVbaColumns::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaColumns::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaColumns") );
+	return sImplName;
+} 
+
+uno::Sequence<rtl::OUString> 
+SwVbaColumns::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Columns") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbacolumns.hxx sw/source/ui/vba/vbacolumns.hxx
new file mode 100644
index 0000000..3fd2b4a
--- /dev/null
+++ sw/source/ui/vba/vbacolumns.hxx
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_COLUMNS_HXX
+#define SW_VBA_COLUMNS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XColumns.hpp>
+#include <ooo/vba/word/XColumn.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XColumns > SwVbaColumns_BASE;
+
+class SwVbaColumns : public SwVbaColumns_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableColumns > mxTableColumns;
+    sal_Int32 mnStartColumnIndex;
+    sal_Int32 mnEndColumnIndex;
+
+private:
+    css::uno::Reference< ooo::vba::word::XColumn > getColumnAtIndex( sal_Int32 index ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaColumns( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableColumns >& xTableColumns ) throw ( css::uno::RuntimeException );
+	SwVbaColumns( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableColumns >& xTableColumns, sal_Int32 nStartCol, sal_Int32 nEndCol ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaColumns() {}
+
+    virtual sal_Int32 SAL_CALL getWidth(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    //XCollection
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaColumns_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_COLUMNS_HXX */
diff --git sw/source/ui/vba/vbadocument.cxx sw/source/ui/vba/vbadocument.cxx
index 98692d5..71641e1 100644
--- sw/source/ui/vba/vbadocument.cxx
+++ sw/source/ui/vba/vbadocument.cxx
@@ -38,7 +38,9 @@
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
 #include <ooo/vba/XControlProvider.hpp>
+#include <ooo/vba/word/WdProtectionType.hpp>
 
 #include <vbahelper/helperdecl.hxx>
 #include <wordvbahelper.hxx>
@@ -50,7 +52,14 @@
 #include "vbafield.hxx"
 #include "vbapagesetup.hxx"
 #include "vbasections.hxx"
+#include "vbatablesofcontents.hxx"
 #include <vbahelper/vbashapes.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include "vbarevisions.hxx"
+#include "vbaframes.hxx"
+#include "vbaformfields.hxx"
+#include <osl/file.hxx>
+#include <tools/urlobj.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -220,6 +229,31 @@ SwVbaDocument::Sections( const uno::Any& index ) throw (uno::RuntimeException)
 }
 
 uno::Any SAL_CALL
+SwVbaDocument::TablesOfContents( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaTablesOfContents( this, mxContext, mxTextDocument ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+#ifdef FIELDPATCH
+uno::Any SAL_CALL
+SwVbaDocument::FormFields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaFormFields( this, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+#else
+uno::Any SAL_CALL
+SwVbaDocument::FormFields( const uno::Any& /*index*/ ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol;
+#endif
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
 SwVbaDocument::PageSetup( ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xPageProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
@@ -239,16 +273,34 @@ SwVbaDocument::getAttachedTemplate() throw (uno::RuntimeException)
     uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( getModel(), uno::UNO_QUERY_THROW );
     uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
     uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
-    rtl::OUString sTemplateName = xDocProps->getTemplateName();
+    rtl::OUString sTemplateUrl = xDocProps->getTemplateURL();
 
-    xTemplate = new SwVbaTemplate( this, mxContext, getModel(), sTemplateName );
+    xTemplate = new SwVbaTemplate( this, mxContext, getModel(), sTemplateUrl );
     return uno::makeAny( xTemplate );
 }
 
 void SAL_CALL 
-SwVbaDocument::setAttachedTemplate( const css::uno::Any& /*_attachedtemplate*/ ) throw (uno::RuntimeException)
+SwVbaDocument::setAttachedTemplate( const css::uno::Any& _attachedtemplate ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException();
+    rtl::OUString sTemplate;
+    if( !( _attachedtemplate >>= sTemplate ) )
+    {
+        throw uno::RuntimeException();
+    }
+    rtl::OUString aURL;
+    INetURLObject aObj;
+    aObj.SetURL( sTemplate );
+    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+    if ( bIsURL )
+        aURL = sTemplate;
+    else
+        osl::FileBase::getFileURLFromSystemPath( sTemplate, aURL );
+
+    uno::Reference< word::XTemplate > xTemplate;
+    uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( getModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    xDocProps->setTemplateURL( aURL );
 }
 
 uno::Any SAL_CALL 
@@ -267,6 +319,116 @@ void SAL_CALL SwVbaDocument::Activate() throw (uno::RuntimeException)
     VbaDocumentBase::Activate();
 }
 
+::sal_Int32 SAL_CALL SwVbaDocument::getProtectionType() throw (css::uno::RuntimeException)
+{
+    //TODO
+    return word::WdProtectionType::wdNoProtection;
+}
+
+void SAL_CALL SwVbaDocument::setProtectionType( ::sal_Int32 /*_protectiontype*/ ) throw (css::uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Bool SAL_CALL SwVbaDocument::getUpdateStylesOnOpen() throw (css::uno::RuntimeException)
+{
+    //TODO
+    return sal_False;
+}
+
+void SAL_CALL SwVbaDocument::setUpdateStylesOnOpen( ::sal_Bool /*_updatestylesonopen*/ ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Bool SAL_CALL SwVbaDocument::getAutoHyphenation() throw (uno::RuntimeException)
+{
+    // check this property only in default paragraph style
+    sal_Bool IsAutoHyphenation = sal_False;
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation")) ) >>= IsAutoHyphenation;
+    return IsAutoHyphenation;
+}
+
+void SAL_CALL SwVbaDocument::setAutoHyphenation( ::sal_Bool _autohyphenation ) throw (uno::RuntimeException)
+{
+    //TODO
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation")), uno::makeAny( _autohyphenation ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaDocument::getHyphenationZone() throw (uno::RuntimeException)
+{
+    //TODO
+    return 0;
+}
+
+void SAL_CALL SwVbaDocument::setHyphenationZone( ::sal_Int32 /*_hyphenationzone*/ ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Int32 SAL_CALL SwVbaDocument::getConsecutiveHyphensLimit() throw (uno::RuntimeException)
+{
+    //TODO
+    sal_Int16 nHyphensLimit = 0;
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaHyphenationMaxHyphens")) ) >>= nHyphensLimit;
+    return nHyphensLimit;
+}
+
+void SAL_CALL SwVbaDocument::setConsecutiveHyphensLimit( ::sal_Int32 _consecutivehyphenslimit ) throw (uno::RuntimeException)
+{
+    sal_Int16 nHyphensLimit = static_cast< sal_Int16 >( _consecutivehyphenslimit );
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaHyphenationMaxHyphens")), uno::makeAny( nHyphensLimit ) );
+}
+
+void SAL_CALL SwVbaDocument::Protect( ::sal_Int32 /*Type*/, const uno::Any& /*NOReset*/, const uno::Any& /*Password*/, const uno::Any& /*UseIRM*/, const uno::Any& /*EnforceStyleLock*/ ) throw (uno::RuntimeException)
+{
+    // Seems not support in Writer
+    // VbaDocumentBase::Protect( Password );
+}
+
+void SAL_CALL SwVbaDocument::PrintOut( const uno::Any& /*Background*/, const uno::Any& /*Append*/, const uno::Any& /*Range*/, const uno::Any& /*OutputFileName*/, const uno::Any& /*From*/, const uno::Any& /*To*/, const uno::Any& /*Item*/, const uno::Any& /*Copies*/, const uno::Any& /*Pages*/, const uno::Any& /*PageType*/, const uno::Any& /*PrintToFile*/, const uno::Any& /*Collate*/, const uno::Any& /*FileName*/, const uno::Any& /*ActivePrinterMacGX*/, const uno::Any& /*ManualDuplexPrint*/, const uno::Any& /*PrintZoomColumn*/, const uno::Any& /*PrintZoomRow*/, const uno::Any& /*PrintZoomPaperWidth*/, const uno::Any& /*PrintZoomPaperHeight*/ ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+void SAL_CALL SwVbaDocument::PrintPreview(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PrintPreview"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaDocument::ClosePrintPreview(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ClosePreview"));
+    dispatchRequests( mxModel,url );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Revisions( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRevisions( this, mxContext, getModel(), xRedlines ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Frames( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextFramesSupplier > xTextFramesSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xFrames( xTextFramesSupp->getTextFrames(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaFrames( this, mxContext, xFrames, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
 uno::Any
 SwVbaDocument::getControlShape( const ::rtl::OUString& sName )
 {
diff --git sw/source/ui/vba/vbadocument.hxx sw/source/ui/vba/vbadocument.hxx
index 4602e9a..4ca6801 100644
--- sw/source/ui/vba/vbadocument.hxx
+++ sw/source/ui/vba/vbadocument.hxx
@@ -65,6 +65,25 @@ public:
     virtual css::uno::Any SAL_CALL Sections( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL PageSetup() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL TablesOfContents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL FormFields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getProtectionType() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setProtectionType( ::sal_Int32 _protectiontype ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUpdateStylesOnOpen() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUpdateStylesOnOpen( ::sal_Bool _updatestylesonopen ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoHyphenation() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoHyphenation( ::sal_Bool _autohyphenation ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHyphenationZone() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHyphenationZone( ::sal_Int32 _hyphenationzone ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getConsecutiveHyphensLimit() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setConsecutiveHyphensLimit( ::sal_Int32 _consecutivehyphenslimit ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Protect( ::sal_Int32 Type, const css::uno::Any& NOReset, const css::uno::Any& Password, const css::uno::Any& UseIRM, const css::uno::Any& EnforceStyleLock ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL PrintOut( const css::uno::Any& Background, const css::uno::Any& Append, const css::uno::Any& Range, const css::uno::Any& OutputFileName, const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Item, const css::uno::Any& Copies, const css::uno::Any& Pages, const css::uno::Any& PageType, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& FileName, const css::uno::Any& ActivePrinterMacGX, const css::uno::Any& ManualDuplexPrint, const css::uno::Any& PrintZoomColumn, const css::uno::Any& PrintZoomRow, const css::uno::Any& PrintZoomPaperWidth, const css::uno::Any& PrintZoomPaperHeight ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL PrintPreview(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ClosePrintPreview(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Revisions( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Frames( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
     // XInvocation
     virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
diff --git sw/source/ui/vba/vbadocumentproperties.cxx sw/source/ui/vba/vbadocumentproperties.cxx
index 475ca93..0a3270c 100644
--- sw/source/ui/vba/vbadocumentproperties.cxx
+++ sw/source/ui/vba/vbadocumentproperties.cxx
@@ -203,16 +203,16 @@ public:
     
     static DocPropInfo createDocPropInfo( const rtl::OUString& sDesc, const rtl::OUString& sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
     {
-        return createDocPropInfo( rtl::OUStringToOString( sDesc, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( sPropName, RTL_TEXTENCODING_UTF8 ).getStr(), rHelper );
+        DocPropInfo aItem;
+        aItem.msMSODesc = sDesc;
+        aItem.msOOOPropName = sPropName;
+        aItem.mpPropGetSetHelper = rHelper;
+        return aItem;
     }
 
     static DocPropInfo createDocPropInfo( const sal_Char* sDesc, const sal_Char* sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
     {
-        DocPropInfo aItem;
-        aItem.msMSODesc = rtl::OUString::createFromAscii( sDesc );
-        aItem.msOOOPropName = rtl::OUString::createFromAscii( sPropName );
-        aItem.mpPropGetSetHelper = rHelper;
-        return aItem;
+        return createDocPropInfo( rtl::OUString::createFromAscii( sDesc ), rtl::OUString::createFromAscii( sPropName ), rHelper );
     }
     uno::Any getValue() 
     {
diff --git sw/source/ui/vba/vbafield.cxx sw/source/ui/vba/vbafield.cxx
index 8e9661d..60042e8 100644
--- sw/source/ui/vba/vbafield.cxx
+++ sw/source/ui/vba/vbafield.cxx
@@ -33,6 +33,7 @@
 #include <ooo/vba/word/WdFieldType.hpp>
 #include <com/sun/star/text/FilenameDisplayFormat.hpp>
 #include <com/sun/star/util/XRefreshable.hpp>
+#include <com/sun/star/util/XUpdatable.hpp>
 #include <swtypes.hxx>
 
 using namespace ::ooo::vba;
@@ -45,6 +46,17 @@ SwVbaField::SwVbaField(  const uno::Reference< ooo::vba::XHelperInterface >& rPa
     mxTextField.set( xTextField, uno::UNO_QUERY_THROW );
 }
 
+sal_Bool SAL_CALL SwVbaField::Update() throw (uno::RuntimeException)
+{
+    uno::Reference< util::XUpdatable > xUpdatable( mxTextField, uno::UNO_QUERY );
+    if( xUpdatable.is() )
+    {
+        xUpdatable->update();
+        return sal_True;
+    }
+    return sal_False;
+}
+
 // XHelperInterface
 rtl::OUString& 
 SwVbaField::getServiceImplName()
@@ -368,6 +380,7 @@ SwVbaFields::Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range,
     {
         _ReadFieldParams aReadParam(sText);
         sFieldName = aReadParam.GetFieldName();
+        OSL_TRACE("SwVbaFields::Add, the field name is %s ",rtl::OUStringToOString( sFieldName, RTL_TEXTENCODING_UTF8 ).getStr() );
     }
 
     uno::Reference< text::XTextContent > xTextField;
@@ -375,6 +388,10 @@ SwVbaFields::Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range,
     {
         xTextField.set( Create_Field_FileName( sText ), uno::UNO_QUERY_THROW );
     }
+    else if( nType == word::WdFieldType::wdFieldDocProperty || sFieldName.EqualsIgnoreCaseAscii("DOCPROPERTY") )
+    {
+        xTextField.set( Create_Field_DocProperty( sText ), uno::UNO_QUERY_THROW );
+    }    
     else
     {
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
@@ -419,6 +436,104 @@ uno::Reference< text::XTextField > SwVbaFields::Create_Field_FileName( const rtl
     return xTextField;
 }
 
+struct DocPropertyTable
+{
+    const char* sDocPropertyName;
+    const char* sFieldService;
+};
+
+static const DocPropertyTable aDocPropertyTables[] = 
+{ 
+    { "Author", "com.sun.star.text.textfield.docinfo.CreateAuthor" }, 
+    { "Bytes", NULL },
+    { "Category", NULL },
+    { "Characters",NULL },
+    { "CharactersWithSpaces", NULL },
+    { "Comments", "com.sun.star.text.textfield.docinfo.Description" },
+    { "Company", NULL },
+    { "CreateTime", "com.sun.star.text.textfield.docinfo.CreateDateTime" },
+    { "HyperlinkBase", NULL },
+    { "Keywords", "com.sun.star.text.textfield.docinfo.Keywords" },
+    { "LastPrinted", "com.sun.star.text.textfield.docinfo.PrintDateTime" },
+    { "LastSavedBy", "com.sun.star.text.textfield.docinfo.ChangeAuthor" },
+    { "LastSavedTime", "com.sun.star.text.textfield.docinfo.ChangeDateTime" },
+    { "Lines", NULL },
+    { "Manager", NULL },
+    { "NameofApplication", NULL },
+    { "ODMADocID", NULL },
+    { "Pages", "com.sun.star.text.textfield.PageCount" },
+    { "Paragraphs", "com.sun.star.text.textfield.ParagraphCount" },
+    { "RevisionNumber", "com.sun.star.text.textfield.docinfo.Revision" },
+    { "Security", NULL },
+    { "Subject", "com.sun.star.text.textfield.docinfo.Subject" },
+    { "Template", "com.sun.star.text.textfield.TemplateName" },
+    { "Title", "com.sun.star.text.textfield.docinfo.Title" },
+    { "TotalEditingTime", "com.sun.star.text.textfield.docinfo.EditTime" },
+    { "Words", "com.sun.star.text.textfield.WordCount" },
+    { NULL, NULL }
+};
+
+uno::Reference< text::XTextField > SwVbaFields::Create_Field_DocProperty( const rtl::OUString _text ) throw (uno::RuntimeException)
+{
+    String aDocProperty;
+    _ReadFieldParams aReadParam( _text );
+    long nRet;
+    while( -1 != ( nRet = aReadParam.SkipToNextToken() ))
+    {
+        switch( nRet )
+        {
+            case -2:
+                if( !aDocProperty.Len() )
+                    aDocProperty = aReadParam.GetResult();
+                break;
+            case '*':
+                //Skip over MERGEFORMAT
+                aReadParam.SkipToNextToken();
+                break;
+        }
+    }
+    aDocProperty.EraseAllChars('"');
+    OSL_TRACE("SwVbaFields::Create_Field_DocProperty, the document property name is %s ",rtl::OUStringToOString( aDocProperty, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( aDocProperty.Len() == 0 )
+    {
+        throw uno::RuntimeException();
+    }
+
+    sal_Bool bCustom = sal_True;
+    rtl::OUString sFieldService;
+    // find the build in document properties
+    for( const DocPropertyTable* pTable = aDocPropertyTables; pTable->sDocPropertyName != NULL; pTable++ )
+    {
+        if( aDocProperty.EqualsIgnoreCaseAscii( pTable->sDocPropertyName ) )
+        {
+            if( pTable->sFieldService != NULL )
+                sFieldService = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( pTable->sFieldService ) );
+            bCustom = sal_False;
+            break;
+        }
+    }
+
+    if( bCustom )
+    {
+        sFieldService = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.text.textfield.docinfo.Custom" ) );
+    }    
+    else if( sFieldService.getLength() == 0 )
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+
+    uno::Reference< text::XTextField > xTextField( mxMSF->createInstance( sFieldService ), uno::UNO_QUERY_THROW );
+
+    if( bCustom )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xTextField, uno::UNO_QUERY_THROW );
+        rtl::OUString sDocPropertyName( aDocProperty );
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ), uno::makeAny( sDocPropertyName ) );
+    }
+    
+    return xTextField;
+}
+
 uno::Reference< container::XEnumeration > SAL_CALL 
 SwVbaFields::createEnumeration() throw (uno::RuntimeException)
 {
diff --git sw/source/ui/vba/vbafield.hxx sw/source/ui/vba/vbafield.hxx
index f421179..99f9d7e 100644
--- sw/source/ui/vba/vbafield.hxx
+++ sw/source/ui/vba/vbafield.hxx
@@ -41,7 +41,8 @@ class SwVbaField : public SwVbaField_BASE
     css::uno::Reference< css::text::XTextField > mxTextField;
 public:
     SwVbaField( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const css::uno::Reference< css::text::XTextField >& xTextField) throw ( css::uno::RuntimeException);
-
+  
+    virtual sal_Bool SAL_CALL Update() throw ( css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
@@ -57,6 +58,7 @@ class SwVbaFields : public SwVbaFields_BASE
     css::uno::Reference< css::lang::XMultiServiceFactory > mxMSF;
 private:
     css::uno::Reference< css::text::XTextField > Create_Field_FileName( const rtl::OUString _text ) throw (css::uno::RuntimeException);
+    css::uno::Reference< css::text::XTextField > Create_Field_DocProperty( const rtl::OUString _text ) throw (css::uno::RuntimeException);
 
 public:
     SwVbaFields( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
diff --git sw/source/ui/vba/vbaformfield.cxx sw/source/ui/vba/vbaformfield.cxx
new file mode 100644
index 0000000..944ffbb
--- /dev/null
+++ sw/source/ui/vba/vbaformfield.cxx
@@ -0,0 +1,139 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaformfield.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <ecmaflds.hxx>
+#include "vbacheckbox.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaFormField::SwVbaFormField( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& rModel, const uno::Reference< text::XFormField >& xFormField ) throw ( uno::RuntimeException ) : SwVbaFormField_BASE( rParent, rContext ), mxModel( rModel ), mxFormField( xFormField )
+{
+}
+
+SwVbaFormField::~SwVbaFormField()
+{
+}
+
+rtl::OUString SAL_CALL SwVbaFormField::getResult() throw ( uno::RuntimeException )
+{
+    rtl::OUString sResult;
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMTEXT ) )
+    {
+        uno::Reference< text::XTextContent > xTextContent( mxFormField, uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xTextRange = xTextContent->getAnchor();
+        sResult = xTextRange->getString();
+    }
+    else if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        sal_Int32 nValue = 0;
+        sal_Int32 nCount = mxFormField->getParamCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            if( mxFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX_CHECKED ) )
+            {
+                if( mxFormField->getParamValue(i).equalsIgnoreAsciiCaseAscii("on") )
+                    nValue = 1;
+                else
+                    nValue = 0;
+                break;    
+            }
+
+        }
+        sResult = rtl::OUString::valueOf( nValue );
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+    return sResult;
+}
+
+void SAL_CALL SwVbaFormField::setResult( const rtl::OUString& result ) throw ( uno::RuntimeException )
+{
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMTEXT ) )
+    {
+        uno::Reference< text::XTextContent > xTextContent( mxFormField, uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xTextRange = xTextContent->getAnchor();
+        xTextRange->setString( result );
+    }
+    else if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        // do nothing
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+sal_Bool SAL_CALL SwVbaFormField::getEnabled() throw ( uno::RuntimeException )
+{
+    //allways return true
+    return sal_True;
+}
+
+void SAL_CALL SwVbaFormField::setEnabled( sal_Bool/* enabled */ ) throw ( uno::RuntimeException )
+{
+    // not support in Writer
+}
+
+uno::Any SAL_CALL SwVbaFormField::CheckBox() throw ( uno::RuntimeException )
+{
+    return uno::makeAny( uno::Reference< word::XCheckBox >( new SwVbaCheckBox( this, mxContext, mxModel, mxFormField ) ) );
+}
+
+rtl::OUString& 
+SwVbaFormField::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFormField") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaFormField::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.FormField" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbaformfield.hxx sw/source/ui/vba/vbaformfield.hxx
new file mode 100644
index 0000000..e3a2d7f
--- /dev/null
+++ sw/source/ui/vba/vbaformfield.hxx
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FORMFIELD_HXX
+#define SW_VBA_FORMFIELD_HXX
+
+#include <ooo/vba/word/XFormField.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XFormField.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XFormField > SwVbaFormField_BASE;
+
+class SwVbaFormField : public SwVbaFormField_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XFormField > mxFormField;
+
+public:
+	SwVbaFormField( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XFormField >& xFormField ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFormField();
+
+    // Methods
+    rtl::OUString SAL_CALL getResult() throw ( css::uno::RuntimeException );
+    void SAL_CALL setResult( const rtl::OUString& result ) throw ( css::uno::RuntimeException );
+    sal_Bool SAL_CALL getEnabled() throw ( css::uno::RuntimeException );
+    void SAL_CALL setEnabled( sal_Bool enabled ) throw ( css::uno::RuntimeException );
+    css::uno::Any SAL_CALL CheckBox() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_FORMFIELD_HXX */
diff --git sw/source/ui/vba/vbaformfields.cxx sw/source/ui/vba/vbaformfields.cxx
new file mode 100644
index 0000000..b56cff8
--- /dev/null
+++ sw/source/ui/vba/vbaformfields.cxx
@@ -0,0 +1,205 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaformfields.hxx"
+#include "vbaformfield.hxx"
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include "wordvbahelper.hxx"
+#include <cppuhelper/implbase3.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef std::vector< uno::Reference< text::XFormField > > XFormFieldVec;
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > FormFiledEnumeration_BASE;
+typedef ::cppu::WeakImplHelper3< container::XNameAccess, container::XIndexAccess, container::XEnumerationAccess > FormFieldCollectionHelper_BASE;
+
+rtl::OUString lcl_getFormFieldName( const uno::Reference< text::XFormField >& xFormField )
+{
+    rtl::OUString sName;
+    sal_Int32 nCount = xFormField->getParamCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        if( xFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( "Name" ) )
+        {
+            sName = xFormField->getParamValue(i);
+            OSL_TRACE("lcl_getFormFieldName: %s", rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            break;
+        }
+    }
+    return sName;
+}
+
+class FormFieldsEnumeration : public FormFiledEnumeration_BASE
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    XFormFieldVec mxFormFields;
+    XFormFieldVec::iterator cachePos;
+public:
+    FormFieldsEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const XFormFieldVec& xFormFiels ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ), mxFormFields( xFormFiels ), cachePos( mxFormFields.begin() )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return ( cachePos != mxFormFields.end() );
+    }
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+        uno::Reference< text::XFormField > xFormField( *cachePos++ );    
+		return uno::makeAny( uno::Reference< word::XFormField > ( new SwVbaFormField( mxParent, mxContext, mxModel, xFormField ) ) );
+	}
+
+};
+
+class FormFieldCollectionHelper : public FormFieldCollectionHelper_BASE
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    XFormFieldVec mxFormFields;
+    XFormFieldVec::iterator cachePos;
+public:
+    FormFieldCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( xModel,uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+        sal_Int32 nCount = xIndexAccess->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XFormField > xFormField( xIndexAccess->getByIndex( i ), uno::UNO_QUERY );
+            if( xFormField.is() )
+                mxFormFields.push_back( xFormField );
+        }
+        cachePos = mxFormFields.begin();
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  word::XFormField::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0 ; }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+        uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< word::XFormField >( new SwVbaFormField( mxParent, mxContext, mxModel, xFormField ) ) );
+    }
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+        uno::Sequence< rtl::OUString > sNames( mxFormFields.size() );
+        rtl::OUString* pString = sNames.getArray();
+        XFormFieldVec::iterator it = mxFormFields.begin();
+        XFormFieldVec::iterator it_end = mxFormFields.end();
+        for ( ; it != it_end; ++it, ++pString )
+        {
+            uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+            *pString =  lcl_getFormFieldName( xFormField );
+        }
+        return sNames;
+    }
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        cachePos = mxFormFields.begin();
+        XFormFieldVec::iterator it_end = mxFormFields.end();
+        for ( ; cachePos != it_end; ++cachePos )
+        {
+            //uno::Reference< container::XNamed > xName( *cachePos, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+            if ( aName.equalsIgnoreAsciiCase( lcl_getFormFieldName( xFormField )) )
+                break;
+        }
+        return ( cachePos != it_end );
+    }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxFormFields.size();
+    }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+        if ( Index < 0 || Index >= getCount() )
+            throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( uno::Reference< word::XFormField >( new SwVbaFormField( mxParent, mxContext, mxModel, mxFormFields[ Index ] ) ) );
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new FormFieldsEnumeration( mxParent, mxContext, mxModel, mxFormFields );
+    }
+};
+
+SwVbaFormFields::SwVbaFormFields( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ): SwVbaFormFields_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new FormFieldCollectionHelper( xParent, xContext, xModel ) ) ), mxModel( xModel ) 
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaFormFields::getElementType() throw (uno::RuntimeException)
+{
+	return word::XFormField::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaFormFields::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return xEnumAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaFormFields::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaFormFields::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFormFields") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaFormFields::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.FormFields") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbaformfields.hxx sw/source/ui/vba/vbaformfields.hxx
new file mode 100644
index 0000000..76ef6bb
--- /dev/null
+++ sw/source/ui/vba/vbaformfields.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FORMFIELDS_HXX
+#define SW_VBA_FORMFIELDS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XFormFields.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XFormFields > SwVbaFormFields_BASE;
+
+class SwVbaFormFields : public SwVbaFormFields_BASE
+{
+private:
+	css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaFormFields( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaFormFields() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaFormFields_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_FORMFIELDS_HXX */
diff --git sw/source/ui/vba/vbaframe.cxx sw/source/ui/vba/vbaframe.cxx
new file mode 100644
index 0000000..bec1aa6
--- /dev/null
+++ sw/source/ui/vba/vbaframe.cxx
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaframe.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaFrame::SwVbaFrame( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< frame::XModel >& rModel, const css::uno::Reference< text::XTextFrame >& xTextFrame ) throw ( css::uno::RuntimeException ) :
+    SwVbaFrame_BASE( rParent, rContext ), mxModel( rModel ), mxTextFrame( xTextFrame )
+{
+}
+
+SwVbaFrame::~SwVbaFrame()
+{
+}
+
+void SAL_CALL SwVbaFrame::Select() throw ( uno::RuntimeException )
+{
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( mxTextFrame ) );
+}
+
+rtl::OUString& 
+SwVbaFrame::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFrame") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaFrame::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Frame" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbaframe.hxx sw/source/ui/vba/vbaframe.hxx
new file mode 100644
index 0000000..a36ebf8
--- /dev/null
+++ sw/source/ui/vba/vbaframe.hxx
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FRAME_HXX
+#define SW_VBA_FRAME_HXX
+
+#include <ooo/vba/word/XFrame.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextFrame.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XFrame > SwVbaFrame_BASE;
+
+class SwVbaFrame : public SwVbaFrame_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextFrame > mxTextFrame;
+
+public:
+	SwVbaFrame( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XTextFrame >& xTextFrame ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFrame();
+
+   // Methods
+    virtual void SAL_CALL Select() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_FRAME_HXX */
diff --git sw/source/ui/vba/vbaframes.cxx sw/source/ui/vba/vbaframes.cxx
new file mode 100644
index 0000000..2c9fa92
--- /dev/null
+++ sw/source/ui/vba/vbaframes.cxx
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaframes.hxx"
+#include "vbaframe.hxx"
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include "wordvbahelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > FramesEnumeration_Base;
+class FramesEnumeration : public FramesEnumeration_Base 
+{
+private:
+	uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< container::XIndexAccess> mxIndexAccess;
+	uno::Reference< frame::XModel > mxModel;
+    sal_Int32 nCurrentPos;
+public:
+	FramesEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : mxParent( xParent ), mxContext( xContext), mxIndexAccess( xIndexAccess ), mxModel( xModel ), nCurrentPos(0)
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return ( nCurrentPos < mxIndexAccess->getCount() );
+    }
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+		uno::Reference< text::XTextFrame > xTextFrame( mxIndexAccess->getByIndex( nCurrentPos++ ), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< word::XFrame > ( new SwVbaFrame( mxParent, mxContext, mxModel, xTextFrame ) ) );
+	}
+
+};
+
+SwVbaFrames::SwVbaFrames( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xFrames, const uno::Reference< frame::XModel >& xModel ): SwVbaFrames_BASE( xParent, xContext, xFrames ), mxModel( xModel ) 
+{
+    mxFramesSupplier.set( mxModel, uno::UNO_QUERY_THROW );
+}
+// XEnumerationAccess
+uno::Type
+SwVbaFrames::getElementType() throw (uno::RuntimeException)
+{
+	return word::XFrame::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaFrames::createEnumeration() throw (uno::RuntimeException)
+{
+	return new FramesEnumeration( this, mxContext,m_xIndexAccess, mxModel );
+}
+
+uno::Any
+SwVbaFrames::createCollectionObject( const css::uno::Any& aSource )
+{
+	uno::Reference< text::XTextFrame > xTextFrame( aSource, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XFrame > ( new SwVbaFrame( this, mxContext, mxModel, xTextFrame ) ) );
+}
+
+rtl::OUString& 
+SwVbaFrames::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFrames") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaFrames::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Frames") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbaframes.hxx sw/source/ui/vba/vbaframes.hxx
new file mode 100644
index 0000000..0957820
--- /dev/null
+++ sw/source/ui/vba/vbaframes.hxx
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FRAMES_HXX
+#define SW_VBA_FRAMES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XFrames.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextFramesSupplier.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XFrames > SwVbaFrames_BASE;
+
+class SwVbaFrames : public SwVbaFrames_BASE
+{
+private:
+	css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextFramesSupplier > mxFramesSupplier;
+
+public:
+	SwVbaFrames( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xFrames, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaFrames() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaFrames_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+};    
+
+#endif /* SW_VBA_FRAMES_HXX */
diff --git sw/source/ui/vba/vbaglobals.cxx sw/source/ui/vba/vbaglobals.cxx
index 0770ea3..c801294 100644
--- sw/source/ui/vba/vbaglobals.cxx
+++ sw/source/ui/vba/vbaglobals.cxx
@@ -129,6 +129,12 @@ SwVbaGlobals::Dialogs( const uno::Any& index ) throw (uno::RuntimeException)
     return getApplication()->Dialogs( index );
 }
 
+uno::Any SAL_CALL
+SwVbaGlobals::ListGalleries( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    return getApplication()->ListGalleries( index );
+}
+
 uno::Reference<word::XSelection > SAL_CALL
 SwVbaGlobals::getSelection() throw (uno::RuntimeException)
 {
diff --git sw/source/ui/vba/vbaglobals.hxx sw/source/ui/vba/vbaglobals.hxx
index ad6ce95..1e7d587 100644
--- sw/source/ui/vba/vbaglobals.hxx
+++ sw/source/ui/vba/vbaglobals.hxx
@@ -69,6 +69,7 @@ public:
     virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL ListGalleries( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
     // XMultiServiceFactory
     virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getAvailableServiceNames(  ) throw (css::uno::RuntimeException);
diff --git sw/source/ui/vba/vbaheaderfooter.cxx sw/source/ui/vba/vbaheaderfooter.cxx
index ec3b0ce..6cdbfcb 100644
--- sw/source/ui/vba/vbaheaderfooter.cxx
+++ sw/source/ui/vba/vbaheaderfooter.cxx
@@ -81,6 +81,7 @@ uno::Reference< word::XRange > SAL_CALL SwVbaHeaderFooter::getRange() throw (uno
 uno::Any SAL_CALL
 SwVbaHeaderFooter::Shapes( const uno::Any& index ) throw (uno::RuntimeException)
 {
+    // #FIXME: only get the shapes in the current header/footer 
     uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
     //uno::Reference< drawing::XShapes > xShapes( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
     uno::Reference< container::XIndexAccess > xIndexAccess( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
diff --git sw/source/ui/vba/vbaheaderfooterhelper.cxx sw/source/ui/vba/vbaheaderfooterhelper.cxx
index d91f37a..36a921b 100644
--- sw/source/ui/vba/vbaheaderfooterhelper.cxx
+++ sw/source/ui/vba/vbaheaderfooterhelper.cxx
@@ -29,8 +29,12 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/frame/XController.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/IllegalArgumentException.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -38,41 +42,61 @@ using namespace ::ooo::vba;
 #define FIRST_PAGE 1;
 
 // Class HeaderFooterHelper 
+sal_Bool HeaderFooterHelper::isHeaderFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    return isHeaderFooter( word::getCurrentXText( xModel ) );
+}
 
-sal_Bool HeaderFooterHelper::isHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isHeaderFooter( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
 {
-    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
-    
-    sal_Bool isOn = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isOn;
-    if( !isOn )
-        return sal_False;
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xText, uno::UNO_QUERY_THROW );
+    rtl::OUString aImplName = xServiceInfo->getImplementationName();
+    if( aImplName.equalsAscii("SwXHeadFootText") )
+        return sal_True;
+    return sal_False;     
+}
 
-    sal_Bool isShared = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared"))) >>= isShared;
+sal_Bool HeaderFooterHelper::isHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    const uno::Reference< text::XText > xCurrentText = word::getCurrentXText( xModel );
+    if( !isHeaderFooter( xCurrentText ) )
+        return sal_False;
 
+    rtl::OUString aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared") );
     rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderText") );
+    uno::Reference< style::XStyle > xPageStyle = word::getCurrentPageStyle( xModel );
+    uno::Reference< beans::XPropertySet > xPageProps( xPageStyle, uno::UNO_QUERY_THROW );
+    sal_Bool isShared = sal_True;
+    xPageProps->getPropertyValue( aPropIsShared ) >>= isShared;
     if( !isShared )
     {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         if( 0 == xPageCursor->getPage() % 2 )
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextLeft") );
-        }
         else
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextRight") );
-        }
     }
-    
-    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
-    //FIXME: can not compare in this way?
-    return ( xText == xCurrentText );
+
+    uno::Reference< text::XText > xHeaderText( xPageProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRangeCompare > xTRC( xHeaderText, uno::UNO_QUERY_THROW ); 
+    uno::Reference< text::XTextRange > xTR1( xCurrentText, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTR2( xHeaderText, uno::UNO_QUERY_THROW );
+    try
+    {
+        if( xTRC->compareRegionStarts( xTR1, xTR2 ) == 0 )
+            return sal_True;
+    }
+    catch( lang::IllegalArgumentException& )
+    {
+        return sal_False;
+    }
+
+    return sal_False;    
 }
 
-sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
         uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         // FIXME: getPage allways returns 1
@@ -82,9 +106,9 @@ sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XMo
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
         uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
         sal_Bool isShared = sal_False;
@@ -98,40 +122,47 @@ sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XMo
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
-    
-    sal_Bool isOn = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn"))) >>= isOn;
-    if( !isOn )
+    const uno::Reference< text::XText > xCurrentText = word::getCurrentXText( xModel );
+    if( !isHeaderFooter( xCurrentText ) )
         return sal_False;
 
-    sal_Bool isShared = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared"))) >>= isShared;
-
+    rtl::OUString aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared") );
     rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterText") );
+    uno::Reference< style::XStyle > xPageStyle = word::getCurrentPageStyle( xModel );
+    uno::Reference< beans::XPropertySet > xPageProps( xPageStyle, uno::UNO_QUERY_THROW );
+    sal_Bool isShared = sal_True;
+    xPageProps->getPropertyValue( aPropIsShared ) >>= isShared;
     if( !isShared )
     {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         if( 0 == xPageCursor->getPage() % 2 )
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextLeft") );
-        }
         else
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextRight") );
-        }
     }
-    
-    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
 
-    return ( xText == xCurrentText );
+    uno::Reference< text::XText > xFooterText( xPageProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRangeCompare > xTRC( xFooterText, uno::UNO_QUERY_THROW ); 
+    uno::Reference< text::XTextRange > xTR1( xCurrentText, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTR2( xFooterText, uno::UNO_QUERY_THROW );
+    try
+    {
+        if( xTRC->compareRegionStarts( xTR1, xTR2 ) == 0 )
+            return sal_True;
+    }
+    catch( lang::IllegalArgumentException& )
+    {
+        return sal_False;
+    }
+
+    return sal_False;    
 }
 
-sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isFooter( xModel, xCurrentText ) )
+    if( isFooter( xModel ) )
     {
         uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         sal_Int32 nPage = xPageCursor->getPage();
@@ -140,9 +171,9 @@ sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XMo
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isFooter( xModel, xCurrentText ) )
+    if( isFooter( xModel ) )
     {
         uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
         sal_Bool isShared = sal_False;
@@ -158,18 +189,18 @@ sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XMo
 #ifdef TOMORROW
 sal_Bool HeaderFooterHelper::isPrimaryHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
-        return( !( isFirstPageHeader( xModel, xCurrentText ) && isEvenPagesHeader( xModel, xCurrentText ) ) );
+        return( !( isFirstPageHeader( xModel ) && isEvenPagesHeader( xModel ) ) );
     }
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isPrimaryFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isPrimaryFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
-        return( !( isFirstPageFooter( xModel, xCurrentText ) && isEvenPagesFooter( xModel, xCurrentText ) ) );
+        return( !( isFirstPageFooter( xModel ) && isEvenPagesFooter( xModel ) ) );
     }
     return sal_False;
 }
diff --git sw/source/ui/vba/vbaheaderfooterhelper.hxx sw/source/ui/vba/vbaheaderfooterhelper.hxx
index 0e5fd4c..dbcd53d 100644
--- sw/source/ui/vba/vbaheaderfooterhelper.hxx
+++ sw/source/ui/vba/vbaheaderfooterhelper.hxx
@@ -36,12 +36,16 @@
 class HeaderFooterHelper
 {
 public:
-    static sal_Bool isHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFirstPageHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isEvenPagesHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFirstPageFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isEvenPagesFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeaderFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeaderFooter( const css::uno::Reference< css::text::XText >& xText ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
 #ifdef TOMORROW
     static sal_Bool isPrimaryHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
     static sal_Bool isPrimaryFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
diff --git sw/source/ui/vba/vbaheadersfooters.cxx sw/source/ui/vba/vbaheadersfooters.cxx
new file mode 100644
index 0000000..295314a
--- /dev/null
+++ sw/source/ui/vba/vbaheadersfooters.cxx
@@ -0,0 +1,150 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaheadersfooters.hxx"
+#include "vbaheaderfooter.hxx"
+#include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// I assume there is only one headersfooters in Writer
+typedef ::cppu::WeakImplHelper1<container::XIndexAccess > HeadersFootersIndexAccess_Base;
+class HeadersFootersIndexAccess : public HeadersFootersIndexAccess_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    uno::Reference< beans::XPropertySet > mxPageStyleProps;
+    sal_Bool mbHeader;
+
+public:
+    HeadersFootersIndexAccess( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xPageStyleProps, sal_Bool bHeader ) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ), mxPageStyleProps( xPageStyleProps ), mbHeader( bHeader ) {}
+    ~HeadersFootersIndexAccess(){}
+
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        // first page, evenpages and primary page
+        return 3;
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if( Index < 1 || Index > 3 )
+            throw container::NoSuchElementException();
+        return uno::makeAny( uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( mxParent,  mxContext, mxModel, mxPageStyleProps, mbHeader, Index ) ) );    
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XHeaderFooter::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+};
+
+class HeadersFootersEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaHeadersFooters* pHeadersFooters;
+	sal_Int32 nIndex;
+public:
+	HeadersFootersEnumWrapper( SwVbaHeadersFooters* _pHeadersFooters ) : pHeadersFooters( _pHeadersFooters ), nIndex( 0 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < pHeadersFooters->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex < pHeadersFooters->getCount() )
+			return pHeadersFooters->Item( uno::makeAny( ++nIndex ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaHeadersFooters::SwVbaHeadersFooters( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xPageStyleProps, sal_Bool isHeader ): SwVbaHeadersFooters_BASE( xParent, xContext, new HeadersFootersIndexAccess( xParent, xContext, xModel, xPageStyleProps, isHeader ) ),  mxModel( xModel ), mxPageStyleProps( xPageStyleProps ), mbHeader( isHeader )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaHeadersFooters::getCount() throw (uno::RuntimeException)
+{
+    // wdHeaderFooterFirstPage, wdHeaderFooterPrimary and wdHeaderFooterEvenPages
+    return 3;
+}
+
+uno::Any SAL_CALL SwVbaHeadersFooters::Item( const uno::Any& Index1, const uno::Any& ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    Index1 >>= nIndex;
+    if( ( nIndex < 1 ) || ( nIndex > 3 ) )
+    {
+        throw container::NoSuchElementException();
+    }
+    return uno::makeAny( uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( this,  mxContext, mxModel, mxPageStyleProps, mbHeader, nIndex ) ) );    
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaHeadersFooters::getElementType() throw (uno::RuntimeException)
+{
+	return word::XHeaderFooter::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+
+SwVbaHeadersFooters::createEnumeration() throw (uno::RuntimeException)
+{
+    return new HeadersFootersEnumWrapper( this );
+}
+
+uno::Any
+SwVbaHeadersFooters::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaHeadersFooters::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaHeadersFooters") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaHeadersFooters::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.HeadersFooters") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbaheadersfooters.hxx sw/source/ui/vba/vbaheadersfooters.hxx
new file mode 100644
index 0000000..9bd7683
--- /dev/null
+++ sw/source/ui/vba/vbaheadersfooters.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_HEADERSFOOTERS_HXX
+#define SW_VBA_HEADERSFOOTERS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XHeadersFooters.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XHeadersFooters > SwVbaHeadersFooters_BASE;
+
+class SwVbaHeadersFooters : public SwVbaHeadersFooters_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxPageStyleProps;
+    sal_Bool mbHeader;
+
+public:
+	SwVbaHeadersFooters( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps, sal_Bool isHeader );
+	virtual ~SwVbaHeadersFooters() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& )throw (css::uno::RuntimeException);
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaHeadersFooters_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_HEADERSFOOTERS_HXX */
diff --git sw/source/ui/vba/vbalistformat.cxx sw/source/ui/vba/vbalistformat.cxx
new file mode 100644
index 0000000..05d9380
--- /dev/null
+++ sw/source/ui/vba/vbalistformat.cxx
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistformat.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdListApplyTo.hpp>
+#include <ooo/vba/word/WdDefaultListBehavior.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XEnumeration.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include "vbalisttemplate.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListFormat::SwVbaListFormat( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextRange >& xTextRange ) throw ( uno::RuntimeException ) : SwVbaListFormat_BASE( rParent, rContext ), mxTextRange( xTextRange )
+{
+}
+
+SwVbaListFormat::~SwVbaListFormat()
+{
+}
+
+void SAL_CALL SwVbaListFormat::ApplyListTemplate( const css::uno::Reference< word::XListTemplate >& ListTemplate, const css::uno::Any& ContinuePreviousList, const css::uno::Any& ApplyTo, const css::uno::Any& DefaultListBehavior ) throw (css::uno::RuntimeException)
+{
+    sal_Bool bContinuePreviousList = sal_True;
+    if( ContinuePreviousList.hasValue() )
+        ContinuePreviousList >>= bContinuePreviousList;
+    
+    // "applyto" must be current selection
+    sal_Int32 bApplyTo = word::WdListApplyTo::wdListApplyToSelection;
+    if( ApplyTo.hasValue() )
+        ApplyTo >>= bApplyTo;
+    if( bApplyTo != word::WdListApplyTo::wdListApplyToSelection )
+        throw uno::RuntimeException();
+
+    // default behaviour must be wdWord8ListBehavior
+    sal_Int32 nDefaultListBehavior = word::WdDefaultListBehavior::wdWord8ListBehavior;
+    if( DefaultListBehavior.hasValue() )
+        DefaultListBehavior >>= nDefaultListBehavior;
+    if( nDefaultListBehavior != word::WdDefaultListBehavior::wdWord8ListBehavior )
+        throw uno::RuntimeException();
+    
+    SwVbaListTemplate* pListTemplate = dynamic_cast< SwVbaListTemplate* >( ListTemplate.get() );
+
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( mxTextRange, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration > xEnum = xEnumAccess->createEnumeration();
+    sal_Bool isFirstElement = sal_True;
+    while( xEnum->hasMoreElements() )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xEnum->nextElement(), uno::UNO_QUERY_THROW );
+        if( isFirstElement )
+        {
+            sal_Bool isNumberingRestart = !bContinuePreviousList;
+            xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsNumberingRestart") ), uno::makeAny( isNumberingRestart ) );
+            if( isNumberingRestart )
+            {
+                sal_Int16 nStartValue = 1;
+                xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStartValue") ), uno::makeAny( nStartValue ) );
+            }
+            isFirstElement = sal_False;
+        }
+        else
+        {
+            xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsNumberingRestart") ), uno::makeAny( sal_False ) );
+        }
+        pListTemplate->applyListTemplate( xProps );
+    }
+}
+
+void SAL_CALL SwVbaListFormat::ConvertNumbersToText(  ) throw (css::uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+rtl::OUString& 
+SwVbaListFormat::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListFormat") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListFormat::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListFormat" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbalistformat.hxx sw/source/ui/vba/vbalistformat.hxx
new file mode 100644
index 0000000..184312a
--- /dev/null
+++ sw/source/ui/vba/vbalistformat.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTFORMAT_HXX
+#define SW_VBA_LISTFORMAT_HXX
+
+#include <ooo/vba/word/XListFormat.hpp>
+#include <ooo/vba/word/XListTemplate.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListFormat > SwVbaListFormat_BASE;
+
+class SwVbaListFormat : public SwVbaListFormat_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextRange > mxTextRange;
+
+public:
+	SwVbaListFormat( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListFormat();
+
+    // Methods
+    virtual void SAL_CALL ApplyListTemplate( const css::uno::Reference< ::ooo::vba::word::XListTemplate >& ListTemplate, const css::uno::Any& ContinuePreviousList, const css::uno::Any& ApplyTo, const css::uno::Any& DefaultListBehavior ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ConvertNumbersToText(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTFORMAT_HXX */
diff --git sw/source/ui/vba/vbalistgalleries.cxx sw/source/ui/vba/vbalistgalleries.cxx
new file mode 100644
index 0000000..ff09ae2
--- /dev/null
+++ sw/source/ui/vba/vbalistgalleries.cxx
@@ -0,0 +1,115 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistgalleries.hxx"
+#include "vbalistgallery.hxx"
+#include <ooo/vba/word/WdListGalleryType.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListGalleriesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListGalleries* pListGalleries;
+	sal_Int32 nIndex;
+public:
+	ListGalleriesEnumWrapper( SwVbaListGalleries* pGalleries ) : pListGalleries( pGalleries ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListGalleries->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListGalleries->getCount() )
+			return pListGalleries->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListGalleries::SwVbaListGalleries( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xTextDoc ) throw (uno::RuntimeException) : SwVbaListGalleries_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ),  mxTextDocument( xTextDoc )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListGalleries::getCount() throw (uno::RuntimeException)
+{
+    // 3 types of list( bullet, numbered and outline )
+    return 3;
+}
+
+uno::Any SAL_CALL SwVbaListGalleries::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex == word::WdListGalleryType::wdBulletGallery
+            || nIndex == word::WdListGalleryType::wdNumberGallery
+            || nIndex == word::WdListGalleryType::wdOutlineNumberGallery )
+            return uno::makeAny( uno::Reference< word::XListGallery >( new SwVbaListGallery( this, mxContext, mxTextDocument, nIndex ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListGalleries::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListGallery::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListGalleries::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListGalleriesEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListGalleries::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListGalleries::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListGalleries") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListGalleries::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListGalleries") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbalistgalleries.hxx sw/source/ui/vba/vbalistgalleries.hxx
new file mode 100644
index 0000000..36cd0ba
--- /dev/null
+++ sw/source/ui/vba/vbalistgalleries.hxx
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTGALLERIES_HXX
+#define SW_VBA_LISTGALLERIES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListGalleries.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XListGalleries > SwVbaListGalleries_BASE;
+
+class SwVbaListGalleries : public SwVbaListGalleries_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+
+public:
+	SwVbaListGalleries( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaListGalleries() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListGalleries_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTGALLERIES_HXX */
diff --git sw/source/ui/vba/vbalistgallery.cxx sw/source/ui/vba/vbalistgallery.cxx
new file mode 100644
index 0000000..6ac7e7c
--- /dev/null
+++ sw/source/ui/vba/vbalistgallery.cxx
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistgallery.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbalisttemplates.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListGallery::SwVbaListGallery( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw ( uno::RuntimeException ) : SwVbaListGallery_BASE( rParent, rContext ), mxTextDocument( xTextDoc ), mnType( nType )
+{
+}
+
+SwVbaListGallery::~SwVbaListGallery()
+{
+}
+
+uno::Any SAL_CALL
+SwVbaListGallery::ListTemplates( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaListTemplates( mxParent, mxContext, mxTextDocument, mnType ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+rtl::OUString& 
+SwVbaListGallery::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListGallery") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListGallery::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListGallery" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbalistgallery.hxx sw/source/ui/vba/vbalistgallery.hxx
new file mode 100644
index 0000000..0ece178
--- /dev/null
+++ sw/source/ui/vba/vbalistgallery.hxx
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTGALLERY_HXX
+#define SW_VBA_LISTGALLERY_HXX
+
+#include <ooo/vba/word/XListGallery.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListGallery > SwVbaListGallery_BASE;
+
+class SwVbaListGallery : public SwVbaListGallery_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    sal_Int32 mnType;
+
+public:
+	SwVbaListGallery( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListGallery();
+
+    // Methods
+    virtual css::uno::Any SAL_CALL ListTemplates( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTGALLERY_HXX */
diff --git sw/source/ui/vba/vbalisthelper.cxx sw/source/ui/vba/vbalisthelper.cxx
new file mode 100644
index 0000000..34cd6be
--- /dev/null
+++ sw/source/ui/vba/vbalisthelper.cxx
@@ -0,0 +1,707 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisthelper.hxx"
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdListGalleryType.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <com/sun/star/container/XIndexReplace.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const sal_Int32 LIST_LEVEL_COUNT = 9;
+
+static const char WORD_BULLET_GALLERY[] = "WdBullet";
+static const char WORD_NUMBER_GALLERY[] = "WdNumber";
+static const char WORD_OUTLINE_NUMBER_GALLERY[] = "WdOutlineNumber";
+
+static const char UNO_NAME_ADJUST[] = "Adjust";
+static const char UNO_NAME_PARENT_NUMBERING[] = "ParentNumbering";
+static const char UNO_NAME_PREFIX[] = "Prefix";
+static const char UNO_NAME_SUFFIX[] = "Suffix";
+static const char UNO_NAME_CHAR_STYLE_NAME[] = "CharStyleName";
+static const char UNO_NAME_START_WITH[] = "StartWith";
+static const char UNO_NAME_POSITION_AND_SPACE_MODE[] = "PositionAndSpaceMode";
+static const char UNO_NAME_LABEL_FOLLOWED_BY[] = "LabelFollowedBy";
+static const char UNO_NAME_LIST_TAB_STOP_POSITION[] = "ListtabStopPosition";
+static const char UNO_NAME_FIRST_LINE_INDENT[] = "FirstLineIndent";
+static const char UNO_NAME_INDENT_AT[] = "IndentAt";
+static const char UNO_NAME_NUMBERING_TYPE[] = "NumberingType";
+static const char UNO_NAME_BULLET_ID[] = "BulletId";
+static const char UNO_NAME_BULLET_CHAR[] = "BulletChar";
+static const char UNO_NAME_BULLET_FONT_NAME[] = "BulletFontName";
+static const char UNO_NAME_BULLET_FONT[] = "BulletFont";
+
+static const sal_Int16 CHAR_CLOSED_DOT = 8226;
+static const sal_Int16 CHAR_EMPTY_DOT = 111;
+static const sal_Int16 CHAR_SQUARE = 9632;
+static const sal_Int16 CHAR_STAR_SYMBOL = 10026;
+static const sal_Int16 CHAR_FOUR_DIAMONDS = 10070;
+static const sal_Int16 CHAR_DIAMOND = 10022;
+static const sal_Int16 CHAR_ARROW = 10146;
+static const sal_Int16 CHAR_CHECK_MARK = 10003;
+
+SwVbaListHelper::SwVbaListHelper( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw( css::uno::RuntimeException ) : mxTextDocument( xTextDoc ), mnGalleryType( nGalleryType ), mnTemplateType( nTemplateType )
+{
+    Init();
+}
+
+void SwVbaListHelper::Init() throw( css::uno::RuntimeException )
+{
+    // set the numbering style name
+    switch( mnGalleryType )
+    {
+        case word::WdListGalleryType::wdBulletGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_BULLET_GALLERY );
+            break;
+        }
+        case word::WdListGalleryType::wdNumberGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_NUMBER_GALLERY );
+            break;
+        }
+        case word::WdListGalleryType::wdOutlineNumberGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_OUTLINE_NUMBER_GALLERY );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    msStyleName += rtl::OUString::valueOf( mnTemplateType );
+
+    // get the numbering style 
+    uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+    mxStyleFamily.set( xStyleSupplier->getStyleFamilies()->getByName(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") ) ), uno::UNO_QUERY_THROW );
+    OSL_TRACE("SwVbaListHelper::Init: numbering style name: %s", rtl::OUStringToOString( msStyleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( mxStyleFamily->hasByName( msStyleName ) )
+    {
+        mxStyleProps.set( mxStyleFamily->getByName( msStyleName ), uno::UNO_QUERY_THROW );
+        mxNumberingRules.set( mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) ), uno::UNO_QUERY_THROW );
+    }    
+    else
+    {
+        // create new numbering style
+        uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxTextDocument, uno::UNO_QUERY_THROW );
+        mxStyleProps.set( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.NumberingStyle") ) ), uno::UNO_QUERY_THROW );
+        // insert this style into style family, or the property NumberingRules doesn't exist.
+        mxStyleFamily->insertByName( msStyleName, uno::makeAny( mxStyleProps ) );
+        mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) ) >>= mxNumberingRules;
+        //mxNumberingRules.set( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingRules") ) ), uno::UNO_QUERY_THROW );
+
+        CreateListTemplate();
+
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( mxNumberingRules ) );
+    }
+}
+
+void SwVbaListHelper::CreateListTemplate() throw( css::uno::RuntimeException )
+{
+    switch( mnGalleryType )
+    {
+        case word::WdListGalleryType::wdBulletGallery:
+        {
+            CreateBulletListTemplate();
+            break;
+        }
+        case word::WdListGalleryType::wdNumberGallery:
+        {
+            CreateNumberListTemplate();
+            break;
+        }
+        case word::WdListGalleryType::wdOutlineNumberGallery:
+        {
+            CreateOutlineNumberListTemplate();
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+}
+
+void SwVbaListHelper::CreateBulletListTemplate() throw( css::uno::RuntimeException )
+{
+    // there is only 1 level for each bullet list in MSWord
+    sal_Int32 nLevel = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    rtl::OUString sCharStyleName( RTL_CONSTASCII_USTRINGPARAM("Bullet Symbols") );
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_CHAR_STYLE_NAME ), uno::makeAny( sCharStyleName ) );
+    sal_Int16 nNumberingType = style::NumberingType::CHAR_SPECIAL;
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+
+    rtl::OUString aBulletChar;
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_CLOSED_DOT ) );
+            break;
+        }
+        case 2:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_EMPTY_DOT ) );
+            break;
+        }
+        case 3:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_SQUARE ) );
+            break;
+        }
+        case 4:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_STAR_SYMBOL ) );
+            break;
+        }
+        case 5:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_FOUR_DIAMONDS ) );
+            break;
+        }
+        case 6:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_ARROW ) );
+            break;
+        }
+        case 7:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_CHECK_MARK ) );
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_BULLET_CHAR ), uno::makeAny( aBulletChar ) );
+
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+}
+
+void SwVbaListHelper::CreateNumberListTemplate() throw( css::uno::RuntimeException )
+{
+    // there is only 1 level for each bullet list in MSWord
+    sal_Int32 nLevel = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sSuffix;
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 2:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+            break;
+        }
+        case 3:
+        {
+            nNumberingType = style::NumberingType::ROMAN_UPPER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 4:
+        {
+            nNumberingType = style::NumberingType::CHARS_UPPER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 5:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+            break;
+        }
+        case 6:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 7:
+        {
+            nNumberingType = style::NumberingType::ROMAN_LOWER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+}
+
+void SwVbaListHelper::CreateOutlineNumberListTemplate() throw( css::uno::RuntimeException )
+{
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            CreateOutlineNumberForType1();
+            break;
+        }
+        case 2:
+        {
+            CreateOutlineNumberForType2();
+            break;
+        }
+        case 3:
+        {
+            CreateOutlineNumberForType3();
+            break;
+        }
+        case 4:
+        {
+            CreateOutlineNumberForType4();
+            break;
+        }
+        case 5:
+        {
+            CreateOutlineNumberForType5();
+            break;
+        }
+        case 6:
+        {
+            CreateOutlineNumberForType6();
+            break;
+        }
+        case 7:
+        {
+            CreateOutlineNumberForType7();
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType1() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            case 1:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType2() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    sal_Int16 nParentNumbering = 0;
+    rtl::OUString sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        if( nLevel != 0 )
+        {
+            nParentNumbering = sal_Int16( nLevel - 1 );
+            setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+        }
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType3() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::CHAR_SPECIAL;
+    rtl::OUString sCharStyleName( RTL_CONSTASCII_USTRINGPARAM("Bullet Symbols") );
+    rtl::OUString aBulletChar;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_CHAR_STYLE_NAME ), uno::makeAny( sCharStyleName ) );
+        switch( nLevel )
+        {
+            case 0:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_FOUR_DIAMONDS ) );
+                break;
+            }
+            case 1:
+            case 5:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_ARROW ) );
+                break;
+            }
+            case 2:
+            case 6:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_SQUARE ) );
+                break;
+            }
+            case 3:
+            case 7:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_CLOSED_DOT ) );
+                break;
+            }
+            case 4:
+            case 8:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_DIAMOND ) );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_BULLET_CHAR ), uno::makeAny( aBulletChar ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType4() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            {
+                nNumberingType = style::NumberingType::ROMAN_UPPER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 1:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                sal_Int16 nParentNumbering = 0;
+                setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType5() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    sal_Int16 nParentNumbering = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        if( nLevel != 0 )
+        {
+            nParentNumbering = sal_Int16( nLevel - 1 );
+            setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+        }
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType6() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            {
+                nNumberingType = style::NumberingType::ROMAN_UPPER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 1:
+            {
+                nNumberingType = style::NumberingType::CHARS_UPPER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType7() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    rtl::OUString sPrefix = rtl::OUString::createFromAscii("Chapter ");
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+uno::Any SwVbaListHelper::getPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName ) throw( css::uno::RuntimeException )
+{
+    uno::Sequence< beans::PropertyValue > aPropertyValues;   
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    return getPropertyValue( aPropertyValues, sName );
+}
+
+void SwVbaListHelper::setPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName, const css::uno::Any& aValue ) throw( css::uno::RuntimeException )
+{
+    uno::Sequence< beans::PropertyValue > aPropertyValues;   
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    setOrAppendPropertyValue( aPropertyValues, sName, aValue );
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( mxNumberingRules ) );
+}
+
diff --git sw/source/ui/vba/vbalisthelper.hxx sw/source/ui/vba/vbalisthelper.hxx
new file mode 100644
index 0000000..0f5fa26
--- /dev/null
+++ sw/source/ui/vba/vbalisthelper.hxx
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTHELPER_HXX
+#define SW_VBA_LISTHELPER_HXX
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/container/XIndexReplace.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <boost/shared_ptr.hpp>
+
+
+class SwVbaListHelper;
+typedef ::boost::shared_ptr< SwVbaListHelper > SwVbaListHelperRef;
+
+class SwVbaListHelper
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::container::XIndexReplace > mxNumberingRules;
+    css::uno::Reference< css::container::XNameContainer > mxStyleFamily;
+    css::uno::Reference< css::beans::XPropertySet > mxStyleProps;
+    sal_Int32 mnGalleryType;
+    sal_Int32 mnTemplateType;
+    rtl::OUString msStyleName;
+
+    void Init() throw( css::uno::RuntimeException );
+    void CreateListTemplate() throw( css::uno::RuntimeException );
+    void CreateBulletListTemplate() throw( css::uno::RuntimeException );
+    void CreateNumberListTemplate() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberListTemplate() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType1() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType2() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType3() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType4() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType5() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType6() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType7() throw( css::uno::RuntimeException );
+
+public:
+    SwVbaListHelper( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw( css::uno::RuntimeException );
+
+    sal_Int32 getGalleryType() { return mnGalleryType; }
+    css::uno::Reference< css::container::XIndexReplace > getNumberingRules() { return mxNumberingRules; }
+    css::uno::Any getPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName ) throw( css::uno::RuntimeException );
+    void setPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName, const css::uno::Any& aValue ) throw( css::uno::RuntimeException );
+
+};
+
+#endif//SW_VBA_LISTHELPER_HXX
diff --git sw/source/ui/vba/vbalistlevel.cxx sw/source/ui/vba/vbalistlevel.cxx
new file mode 100644
index 0000000..7a769ac
--- /dev/null
+++ sw/source/ui/vba/vbalistlevel.cxx
@@ -0,0 +1,401 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistlevel.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <ooo/vba/word/WdListNumberStyle.hpp>
+#include <ooo/vba/word/WdTrailingCharacter.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <ooo/vba/word/WdListLevelAlignment.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListLevel::SwVbaListLevel( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper, sal_Int32 nLevel ) throw ( uno::RuntimeException ) : SwVbaListLevel_BASE( rParent, rContext ), pListHelper( pHelper ), mnLevel( nLevel )
+{
+}
+
+SwVbaListLevel::~SwVbaListLevel()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getAlignment() throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Adjust") ) ) >>= nAlignment;
+    switch( nAlignment )
+    {
+        case text::HoriOrientation::LEFT:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignLeft;
+            break;
+        }
+        case text::HoriOrientation::RIGHT:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignRight;
+            break;
+        }
+        case text::HoriOrientation::CENTER:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignCenter;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    return nAlignment;
+}
+
+void SAL_CALL SwVbaListLevel::setAlignment( ::sal_Int32 _alignment ) throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    switch( _alignment )
+    {
+        case word::WdListLevelAlignment::wdListLevelAlignLeft:
+        {
+            nAlignment = text::HoriOrientation::LEFT;
+            break;
+        }
+        case word::WdListLevelAlignment::wdListLevelAlignRight:
+        {
+            nAlignment = text::HoriOrientation::RIGHT;
+            break;
+        }
+        case word::WdListLevelAlignment::wdListLevelAlignCenter:
+        {
+            nAlignment = text::HoriOrientation::CENTER;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Adjust") ), uno::makeAny( nAlignment ) );
+}
+
+uno::Reference< ::ooo::vba::word::XFont > SAL_CALL SwVbaListLevel::getFont() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return uno::Reference< word::XFont >();
+}
+
+void SAL_CALL SwVbaListLevel::setFont( const uno::Reference< ::ooo::vba::word::XFont >& /*_font*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getIndex() throw (uno::RuntimeException)
+{
+    return mnLevel + 1;
+}
+
+::rtl::OUString SAL_CALL SwVbaListLevel::getLinkedStyle() throw (uno::RuntimeException)
+{
+    // TODO: 
+    return rtl::OUString();
+}
+
+void SAL_CALL SwVbaListLevel::setLinkedStyle( const ::rtl::OUString& /*_linkedstyle*/ ) throw (uno::RuntimeException)
+{
+    // TODO: 
+}
+
+::rtl::OUString SAL_CALL SwVbaListLevel::getNumberFormat() throw (uno::RuntimeException)
+{
+    // TODO::
+    return rtl::OUString();
+}
+
+void SAL_CALL SwVbaListLevel::setNumberFormat( const ::rtl::OUString& /*_numberformat*/ ) throw (uno::RuntimeException)
+{
+    // TODO::
+}
+
+float SAL_CALL SwVbaListLevel::getNumberPosition() throw (uno::RuntimeException)
+{
+    // indentAt + firstlineindent
+    sal_Int32 nIndentAt = 0;
+    sal_Int32 nFirstLineIndent = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ) ) >>= nFirstLineIndent;
+
+    sal_Int32 nResult = nIndentAt + nFirstLineIndent;
+
+    return static_cast< float >( Millimeter::getInPoints( nResult ) );
+}
+
+void SAL_CALL SwVbaListLevel::setNumberPosition( float _numberposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nNumberPosition = Millimeter::getInHundredthsOfOneMillimeter( _numberposition );
+
+    sal_Int32 nIndentAt = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+
+    sal_Int32 nFirstLineIndent = nNumberPosition - nIndentAt;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ), uno::makeAny( nFirstLineIndent ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getNumberStyle() throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingType = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingType") ) ) >>= nNumberingType;
+    switch( nNumberingType )
+    {
+        case style::NumberingType::CHAR_SPECIAL:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleBullet;
+            break;
+        }
+        case style::NumberingType::CHARS_UPPER_LETTER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleUppercaseLetter;
+            break;
+        }
+        case style::NumberingType::CHARS_LOWER_LETTER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleLowercaseLetter;
+            break;
+        }
+        case style::NumberingType::ROMAN_UPPER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleUppercaseRoman;
+            break;
+        }
+        case style::NumberingType::ROMAN_LOWER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleLowercaseRoman;
+            break;
+        }
+        case style::NumberingType::ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleArabic;
+            break;
+        }
+        case style::NumberingType::NUMBER_NONE:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleNone;
+            break;
+        }
+        case style::NumberingType::FULLWIDTH_ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleArabicFullWidth;
+            break;
+        }
+        case style::NumberingType::CIRCLE_NUMBER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleNumberInCircle;
+            break;
+        }
+        case style::NumberingType::CHARS_ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleCardinalText;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+        }
+    }
+    return nNumberingType;
+}
+
+void SAL_CALL SwVbaListLevel::setNumberStyle( ::sal_Int32 _numberstyle ) throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingType = 0;
+    switch( _numberstyle )
+    {
+        case word::WdListNumberStyle::wdListNumberStyleBullet:
+        {
+            nNumberingType = style::NumberingType::CHAR_SPECIAL;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleUppercaseLetter:
+        {
+            nNumberingType = style::NumberingType::CHARS_UPPER_LETTER_N;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleLowercaseLetter:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER_N;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleUppercaseRoman:
+        {
+            nNumberingType = style::NumberingType::ROMAN_UPPER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleLowercaseRoman:
+        {
+            nNumberingType = style::NumberingType::ROMAN_LOWER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleArabic:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleNone:
+        {
+            nNumberingType = style::NumberingType::NUMBER_NONE;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleArabicFullWidth:
+        {
+            nNumberingType = style::NumberingType::FULLWIDTH_ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleNumberInCircle:
+        {
+            nNumberingType = style::NumberingType::CIRCLE_NUMBER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleCardinalText:
+        {
+            nNumberingType = style::NumberingType::CHARS_ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleOrdinal:
+        case word::WdListNumberStyle::wdListNumberStyleOrdinalText:
+        case word::WdListNumberStyle::wdListNumberStyleKanji:
+        case word::WdListNumberStyle::wdListNumberStyleKanjiDigit:
+        case word::WdListNumberStyle::wdListNumberStyleAiueoHalfWidth:
+        case word::WdListNumberStyle::wdListNumberStyleIrohaHalfWidth:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+        }
+    }
+
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingType") ), uno::makeAny( nNumberingType ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getResetOnHigher() throw (uno::RuntimeException)
+{
+    //seems not support?
+    return 0;
+}
+
+void SAL_CALL SwVbaListLevel::setResetOnHigher( ::sal_Int32 /*_resetonhigher*/ ) throw (uno::RuntimeException)
+{
+    //seems not support?
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getStartAt() throw (uno::RuntimeException)
+{
+    sal_Int16 nStartWith = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("StartWith") ) ) >>= nStartWith;
+    return nStartWith;
+}
+
+void SAL_CALL SwVbaListLevel::setStartAt( ::sal_Int32 _startat ) throw (uno::RuntimeException)
+{
+    sal_Int16 nStartWith = (sal_Int16)_startat;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("StartWith") ), uno::makeAny( nStartWith ) );
+}
+
+float SAL_CALL SwVbaListLevel::getTabPosition() throw (uno::RuntimeException)
+{
+    sal_Int32 nTabPosition = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition") ) ) >>= nTabPosition;
+
+    return static_cast< float >( Millimeter::getInPoints( nTabPosition ) );
+}
+
+void SAL_CALL SwVbaListLevel::setTabPosition( float _tabposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nTabPosition = Millimeter::getInHundredthsOfOneMillimeter( _tabposition );
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition") ), uno::makeAny( nTabPosition ) );
+}
+
+float SAL_CALL SwVbaListLevel::getTextPosition() throw (uno::RuntimeException)
+{
+    // indentAt
+    sal_Int32 nIndentAt = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+
+    return static_cast< float >( Millimeter::getInPoints( nIndentAt ) );
+}
+
+void SAL_CALL SwVbaListLevel::setTextPosition( float _textposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndentAt = 0;
+    sal_Int32 nFirstLineIndent = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ) ) >>= nFirstLineIndent;
+
+    sal_Int32 nAlignedAt = nIndentAt + nFirstLineIndent;
+
+    nIndentAt = Millimeter::getInHundredthsOfOneMillimeter( _textposition );
+    nFirstLineIndent = nAlignedAt - nIndentAt;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ), uno::makeAny( nIndentAt ) );
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ), uno::makeAny( nFirstLineIndent ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getTrailingCharacter() throw (uno::RuntimeException)
+{
+    sal_Int16 nLabelFollowedBy= 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LabelFollowedBy") ) ) >>= nLabelFollowedBy;
+
+    return nLabelFollowedBy;
+}
+
+void SAL_CALL SwVbaListLevel::setTrailingCharacter( ::sal_Int32 _trailingcharacter ) throw (uno::RuntimeException)
+{
+    sal_Int16 nLabelFollowedBy = (sal_Int16)_trailingcharacter;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LabelFollowedBy") ), uno::makeAny( nLabelFollowedBy ) );
+}
+
+rtl::OUString& 
+SwVbaListLevel::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListLevel") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListLevel::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListLevel" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbalistlevel.hxx sw/source/ui/vba/vbalistlevel.hxx
new file mode 100644
index 0000000..4bcb147
--- /dev/null
+++ sw/source/ui/vba/vbalistlevel.hxx
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTLEVEL_HXX
+#define SW_VBA_LISTLEVEL_HXX
+
+#include <ooo/vba/word/XListLevel.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListLevel > SwVbaListLevel_BASE;
+
+class SwVbaListLevel : public SwVbaListLevel_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+    sal_Int32 mnLevel;
+
+public:
+	SwVbaListLevel( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper, sal_Int32 nLevel ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListLevel();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getAlignment() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAlignment( ::sal_Int32 _alignment ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFont( const css::uno::Reference< ::ooo::vba::word::XFont >& _font ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getIndex() throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getLinkedStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLinkedStyle( const ::rtl::OUString& _linkedstyle ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getNumberFormat() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberFormat( const ::rtl::OUString& _numberformat ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getNumberPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberPosition( float _numberposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getNumberStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberStyle( ::sal_Int32 _numberstyle ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getResetOnHigher() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setResetOnHigher( ::sal_Int32 _resetonhigher ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getStartAt() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStartAt( ::sal_Int32 _startat ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getTabPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTabPosition( float _tabposition ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getTextPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTextPosition( float _textposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getTrailingCharacter() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTrailingCharacter( ::sal_Int32 _trailingcharacter ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTLEVEL_HXX */
diff --git sw/source/ui/vba/vbalistlevels.cxx sw/source/ui/vba/vbalistlevels.cxx
new file mode 100644
index 0000000..019b6f5
--- /dev/null
+++ sw/source/ui/vba/vbalistlevels.cxx
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistlevels.hxx"
+#include "vbalistlevel.hxx"
+#include <ooo/vba/word/WdListGalleryType.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListLevelsEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListLevels* pListLevels;
+	sal_Int32 nIndex;
+public:
+	ListLevelsEnumWrapper( SwVbaListLevels* pLevels ) : pListLevels( pLevels ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListLevels->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListLevels->getCount() )
+			return pListLevels->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListLevels::SwVbaListLevels( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, SwVbaListHelperRef pHelper ) throw (uno::RuntimeException) : SwVbaListLevels_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ), pListHelper( pHelper ) 
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevels::getCount() throw (uno::RuntimeException)
+{
+    sal_Int32 nGalleryType = pListHelper->getGalleryType();
+    if( nGalleryType == word::WdListGalleryType::wdBulletGallery
+        || nGalleryType == word::WdListGalleryType::wdNumberGallery )
+        return 1;
+    else if( nGalleryType == word::WdListGalleryType::wdOutlineNumberGallery )
+        return 9;
+    return 0;    
+}
+
+uno::Any SAL_CALL SwVbaListLevels::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_False )
+        throw uno::RuntimeException();
+    if( nIndex <=0 || nIndex > getCount() )    
+        throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        
+    return uno::makeAny( uno::Reference< word::XListLevel >( new SwVbaListLevel( this, mxContext, pListHelper, nIndex - 1 ) ) );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListLevels::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListLevel::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListLevels::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListLevelsEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListLevels::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListLevels::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListLevels") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListLevels::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListLevels") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbalistlevels.hxx sw/source/ui/vba/vbalistlevels.hxx
new file mode 100644
index 0000000..c57da55
--- /dev/null
+++ sw/source/ui/vba/vbalistlevels.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTLEVELS_HXX
+#define SW_VBA_LISTLEVELS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListLevels.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbalisthelper.hxx"
+
+
+typedef CollTestImplHelper< ooo::vba::word::XListLevels > SwVbaListLevels_BASE;
+
+class SwVbaListLevels : public SwVbaListLevels_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+
+public:
+	SwVbaListLevels( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListLevels() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListLevels_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTLEVELS_HXX */
diff --git sw/source/ui/vba/vbalisttemplate.cxx sw/source/ui/vba/vbalisttemplate.cxx
new file mode 100644
index 0000000..1ad091e
--- /dev/null
+++ sw/source/ui/vba/vbalisttemplate.cxx
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisttemplate.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbalistlevels.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListTemplate::SwVbaListTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw ( uno::RuntimeException ) : SwVbaListTemplate_BASE( rParent, rContext )
+{
+    pListHelper.reset( new SwVbaListHelper( xTextDoc, nGalleryType, nTemplateType ) );
+}
+
+SwVbaListTemplate::~SwVbaListTemplate()
+{
+}
+
+uno::Any SAL_CALL
+SwVbaListTemplate::ListLevels( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaListLevels( mxParent, mxContext, pListHelper ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+void SwVbaListTemplate::applyListTemplate( uno::Reference< beans::XPropertySet >& xProps ) throw (uno::RuntimeException)
+{
+    uno::Reference< container::XIndexReplace > xNumberingRules = pListHelper->getNumberingRules();
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( xNumberingRules ) );
+}
+
+rtl::OUString& 
+SwVbaListTemplate::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListTemplate") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListTemplate::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListTemplate" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbalisttemplate.hxx sw/source/ui/vba/vbalisttemplate.hxx
new file mode 100644
index 0000000..733ef76
--- /dev/null
+++ sw/source/ui/vba/vbalisttemplate.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTTEMPLATE_HXX
+#define SW_VBA_LISTTEMPLATE_HXX
+
+#include <ooo/vba/word/XListTemplate.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListTemplate > SwVbaListTemplate_BASE;
+
+class SwVbaListTemplate : public SwVbaListTemplate_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+
+public:
+	SwVbaListTemplate( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListTemplate();
+
+    void applyListTemplate( css::uno::Reference< css::beans::XPropertySet >& xProps ) throw ( css::uno::RuntimeException );
+
+    // Methods
+    virtual css::uno::Any SAL_CALL ListLevels( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTTEMPLATE_HXX */
diff --git sw/source/ui/vba/vbalisttemplates.cxx sw/source/ui/vba/vbalisttemplates.cxx
new file mode 100644
index 0000000..ba560d3
--- /dev/null
+++ sw/source/ui/vba/vbalisttemplates.cxx
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisttemplates.hxx"
+#include "vbalisttemplate.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListTemplatesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListTemplates* pListTemplates;
+	sal_Int32 nIndex;
+public:
+	ListTemplatesEnumWrapper( SwVbaListTemplates* pTemplates ) : pListTemplates( pTemplates ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListTemplates->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListTemplates->getCount() )
+			return pListTemplates->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListTemplates::SwVbaListTemplates( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw (uno::RuntimeException) : SwVbaListTemplates_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ),  mxTextDocument( xTextDoc ), mnGalleryType( nType )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListTemplates::getCount() throw (uno::RuntimeException)
+{
+    // 3 types of list( bullet, numbered and outline )
+    return 7;
+}
+
+uno::Any SAL_CALL SwVbaListTemplates::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_False )
+        throw uno::RuntimeException();
+    if( nIndex <=0 || nIndex > getCount() )    
+        throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        
+    return uno::makeAny( uno::Reference< word::XListTemplate >( new SwVbaListTemplate( this, mxContext, mxTextDocument, mnGalleryType, nIndex ) ) );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListTemplates::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListTemplate::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListTemplates::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListTemplatesEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListTemplates::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListTemplates::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListTemplates") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListTemplates::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListTemplates") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbalisttemplates.hxx sw/source/ui/vba/vbalisttemplates.hxx
new file mode 100644
index 0000000..214d01b
--- /dev/null
+++ sw/source/ui/vba/vbalisttemplates.hxx
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTTEMPLATES_HXX
+#define SW_VBA_LISTTEMPLATES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListTemplates.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XListTemplates > SwVbaListTemplates_BASE;
+
+class SwVbaListTemplates : public SwVbaListTemplates_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    sal_Int32 mnGalleryType;
+
+public:
+	SwVbaListTemplates( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaListTemplates() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListTemplates_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTTEMPLATES_HXX */
diff --git sw/source/ui/vba/vbaparagraph.cxx sw/source/ui/vba/vbaparagraph.cxx
index 075ea6f..4e088a6 100644
--- sw/source/ui/vba/vbaparagraph.cxx
+++ sw/source/ui/vba/vbaparagraph.cxx
@@ -48,6 +48,20 @@ SwVbaParagraph::getRange( ) throw ( uno::RuntimeException )
     return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, mxTextDocument, mxTextRange->getStart(), mxTextRange->getEnd(), mxTextRange->getText(), sal_True ) );
 }
 
+uno::Any SAL_CALL
+SwVbaParagraph::getStyle( ) throw ( uno::RuntimeException )
+{
+    uno::Reference< word::XRange > xRange = getRange();
+    return xRange->getStyle();
+}
+
+void SAL_CALL
+SwVbaParagraph::setStyle( const uno::Any& style ) throw ( uno::RuntimeException )
+{
+    uno::Reference< word::XRange > xRange = getRange();
+    xRange->setStyle( style );
+}
+
 rtl::OUString& 
 SwVbaParagraph::getServiceImplName()
 {
diff --git sw/source/ui/vba/vbaparagraph.hxx sw/source/ui/vba/vbaparagraph.hxx
index 4c2cc44..ea994f9 100644
--- sw/source/ui/vba/vbaparagraph.hxx
+++ sw/source/ui/vba/vbaparagraph.hxx
@@ -50,6 +50,8 @@ public:
 
     // XParagraph
     virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL getRange() throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL getStyle() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setStyle( const css::uno::Any& style ) throw ( css::uno::RuntimeException );
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sw/source/ui/vba/vbaparagraphformat.cxx sw/source/ui/vba/vbaparagraphformat.cxx
index dbcadac..1285ca7 100644
--- sw/source/ui/vba/vbaparagraphformat.cxx
+++ sw/source/ui/vba/vbaparagraphformat.cxx
@@ -34,6 +34,7 @@
 #include <ooo/vba/word/WdOutlineLevel.hpp>
 #include <com/sun/star/style/ParagraphAdjust.hpp>
 #include <com/sun/star/style/BreakType.hpp>
+#include "vbatabstops.hxx"
 
 
 using namespace ::ooo::vba;
@@ -200,9 +201,12 @@ sal_Int32 SAL_CALL SwVbaParagraphFormat::getOutlineLevel() throw (uno::RuntimeEx
     return nLevel;
 }
 
-void SAL_CALL SwVbaParagraphFormat::setOutlineLevel( sal_Int32 /*_outlinelevel*/ ) throw (uno::RuntimeException)
+void SAL_CALL SwVbaParagraphFormat::setOutlineLevel( sal_Int32 _outlinelevel ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    if( _outlinelevel != getOutlineLevel() )
+    {
+        // TODO: in my test in msword, there is no effect for this function.
+    }
 }
 
 uno::Any SAL_CALL SwVbaParagraphFormat::getPageBreakBefore() throw (uno::RuntimeException)
@@ -296,7 +300,7 @@ void SAL_CALL SwVbaParagraphFormat::setRightIndent( float _rightindent ) throw (
 
 uno::Any SAL_CALL SwVbaParagraphFormat::getTabStops() throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return uno::makeAny( uno::Reference< word::XTabStops >( new SwVbaTabStops( this, mxContext, mxParaProps ) ) );
 }
 
 void SAL_CALL SwVbaParagraphFormat::setTabStops( const uno::Any& /*_tabstops*/ ) throw (uno::RuntimeException)
diff --git sw/source/ui/vba/vbarange.cxx sw/source/ui/vba/vbarange.cxx
index d6f719d..20c52ec 100644
--- sw/source/ui/vba/vbarange.cxx
+++ sw/source/ui/vba/vbarange.cxx
@@ -32,12 +32,21 @@
 #include <com/sun/star/style/BreakType.hpp>
 #include <com/sun/star/text/ControlCharacter.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
-#include "wordvbahelper.hxx"
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XWordCursor.hpp>
+#include <com/sun/star/text/XParagraphCursor.hpp>
+#include <ooo/vba/word/WdUnits.hpp>
+#include <ooo/vba/word/WdMovementType.hpp>
 #include "vbaparagraphformat.hxx"
 #include "vbastyle.hxx"
 #include "vbafont.hxx"
 #include "vbapalette.hxx"
 #include "vbapagesetup.hxx"
+#include "vbalistformat.hxx"
+#include "vbarevisions.hxx"
+#include "vbabookmarks.hxx"
+#include "vbasections.hxx"
+#include "vbafield.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -70,6 +79,8 @@ void SwVbaRange::initialize( const uno::Reference< text::XTextRange >& rStart, c
     }    
     
     mxTextCursor = SwVbaRangeHelper::initCursor( rStart, mxText );
+    if( !mxTextCursor.is() )
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Fails to create text cursor") ), uno::Reference< uno::XInterface >() );
     mxTextCursor->collapseToStart();
 
     if( rEnd.is() )
@@ -90,6 +101,67 @@ void SwVbaRange::setXTextRange( const uno::Reference< text::XTextRange >& xRange
     mxTextCursor->gotoRange( xRange->getStart(), sal_False );
     mxTextCursor->gotoRange( xRange->getEnd(), sal_True );
 }
+
+void
+SwVbaRange::Move( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+
+    sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdParagraph:
+        {
+            if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< text::XParagraphCursor > xParagraphCursor( mxTextCursor, uno::UNO_QUERY_THROW );
+            for( sal_Int32 i=0; i<nCount; i++ )
+            {
+                if( ( eDirection == word::MOVE_UP ) && ( xParagraphCursor->gotoPreviousParagraph( bExpand ) == sal_False ) )
+					break;
+                else if( ( eDirection == word::MOVE_DOWN ) && ( xParagraphCursor->gotoNextParagraph( bExpand ) == sal_False ) )
+					break;
+            }
+            break;
+        }
+        case word::WdUnits::wdWord:
+        {
+            if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< text::XWordCursor > xWordCursor( mxTextCursor, uno::UNO_QUERY_THROW );
+            for( sal_Int32 i=0; i<nCount; i++ )
+            {
+                if( (eDirection == word::MOVE_LEFT ) && ( xWordCursor->gotoPreviousWord( bExpand ) == sal_False ) )
+					break;
+				else if( ( eDirection == word::MOVE_RIGHT ) && ( xWordCursor->gotoNextWord( bExpand ) == sal_False ) )
+					break;
+            }
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
 #endif
 /**
 * The complexity in this method is because we need to workaround
@@ -128,17 +200,46 @@ SwVbaRange::getText() throw ( uno::RuntimeException )
 void SAL_CALL
 SwVbaRange::setText( const rtl::OUString& rText ) throw ( uno::RuntimeException )
 {
+    // Emulate the MSWord behavior, Don't delete the bookmark
+    // which contains no text string in current inserting position, 
+    rtl::OUString sName;
+    uno::Reference< text::XTextRange > xRange( mxTextCursor, uno::UNO_QUERY_THROW );
+    try
+    {
+        uno::Reference< text::XTextContent > xBookmark = SwVbaRangeHelper::findBookmarkByPosition( mxTextDocument, xRange->getStart() );
+        if( xBookmark.is() )
+        {
+            uno::Reference< container::XNamed > xNamed( xBookmark, uno::UNO_QUERY_THROW );
+            sName = xNamed->getName();
+        }
+    }
+    catch( uno::Exception& )
+    {
+        // do nothing
+    }
+    
     if( rText.indexOf( '\n' )  != -1 )
     {
         mxTextCursor->setString( rtl::OUString() );
         // process CR in strings
-        uno::Reference< text::XTextRange > xRange( mxTextCursor, uno::UNO_QUERY_THROW );
         SwVbaRangeHelper::insertString( xRange, mxText, rText, sal_True );
     }
     else
     {
         mxTextCursor->setString( rText );
     }
+
+    // insert the bookmark if the bookmark is deleted during setting text string
+    if( sName.getLength() )
+    {
+        uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNameAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+        if( !xNameAccess->hasByName( sName ) )
+        {
+            uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+            SwVbaBookmarks::addBookmarkByName( xModel, sName, xRange->getStart() );
+        }
+    }
 }
 
 // FIXME: test is not pass
@@ -229,11 +330,8 @@ SwVbaRange::setParagraphFormat( const uno::Reference< word::XParagraphFormat >&
     throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 }
 
-uno::Reference< word::XStyle > SAL_CALL
-SwVbaRange::getStyle() throw ( uno::RuntimeException )
+void SwVbaRange::GetStyleInfo(rtl::OUString& aStyleName, rtl::OUString& aStyleType ) throw ( uno::RuntimeException )
 {
-    rtl::OUString aStyleName;
-    rtl::OUString aStyleType;
     uno::Reference< beans::XPropertySet > xProp( mxTextCursor, uno::UNO_QUERY_THROW );
     if( ( xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharStyleName") ) ) >>= aStyleName ) && aStyleName.getLength() )
     {
@@ -247,14 +345,23 @@ SwVbaRange::getStyle() throw ( uno::RuntimeException )
     {
         DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
     }
+}
+
+uno::Any SAL_CALL
+SwVbaRange::getStyle() throw ( uno::RuntimeException )
+{
+    rtl::OUString aStyleName;
+    rtl::OUString aStyleType;
+    GetStyleInfo( aStyleName, aStyleType );
     uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxTextDocument, uno::UNO_QUERY_THROW);
     uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
     uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
-    return uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ); 
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xModel, xStyleProps ) ) );
 }
 
 void SAL_CALL
-SwVbaRange::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+SwVbaRange::setStyle( const uno::Any& rStyle ) throw ( uno::RuntimeException )
 {
     uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
     SwVbaStyle::setStyle( xParaProps, rStyle );
@@ -267,6 +374,12 @@ SwVbaRange::getFont() throw ( uno::RuntimeException )
     return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), uno::Reference< beans::XPropertySet >( getXTextRange(), uno::UNO_QUERY_THROW ) );
 }
 
+uno::Reference< word::XListFormat > SAL_CALL
+SwVbaRange::getListFormat() throw ( uno::RuntimeException )
+{
+    return uno::Reference< word::XListFormat >( new SwVbaListFormat( this, mxContext, getXTextRange() ) );
+}
+
 ::sal_Int32 SAL_CALL SwVbaRange::getLanguageID() throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
@@ -324,6 +437,50 @@ void SAL_CALL SwVbaRange::setEnd( ::sal_Int32 _end ) throw (uno::RuntimeExceptio
     mxTextCursor->gotoRange( xEnd, sal_True );
 }
 
+::sal_Bool SAL_CALL SwVbaRange::InRange( const uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (uno::RuntimeException)
+{
+    SwVbaRange* pRange = dynamic_cast< SwVbaRange* >( Range.get() );
+    if( !pRange )
+        throw uno::RuntimeException();
+    uno::Reference< text::XTextRange > xTextRange = pRange->getXTextRange();    
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextCursor->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( xTextRange, getXTextRange() ) >= 0 && xTRC->compareRegionEnds( xTextRange, getXTextRange() ) <= 0 )
+        return sal_True;
+    return sal_False;    
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Revisions( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange = getXTextRange();
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRevisions( mxParent, mxContext, xModel, xTextRange ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Sections( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange = getXTextRange();
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaSections( mxParent, mxContext, xModel, xTextRange ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Fields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    //FIXME: should be get the field in current range
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaFields( mxParent, mxContext, xModel ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
 rtl::OUString& 
 SwVbaRange::getServiceImplName()
 {
diff --git sw/source/ui/vba/vbarange.hxx sw/source/ui/vba/vbarange.hxx
index ca3a4ea..a23bf2d 100644
--- sw/source/ui/vba/vbarange.hxx
+++ sw/source/ui/vba/vbarange.hxx
@@ -35,6 +35,8 @@
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextDocument.hpp>
 #include <ooo/vba/word/XStyle.hpp>
+#include <ooo/vba/word/XListFormat.hpp>
+#include "wordvbahelper.hxx"
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRange > SwVbaRange_BASE;
 
@@ -48,6 +50,7 @@ private:
 
 private:
     void initialize( const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd ) throw (css::uno::RuntimeException);
+    void GetStyleInfo(rtl::OUString& aStyleName, rtl::OUString& aStyleType ) throw ( css::uno::RuntimeException );
 public:
     SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
     SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
@@ -61,16 +64,18 @@ public:
 #endif
     css::uno::Reference< css::text::XText > getXText() { return mxText; }
     void setXTextCursor( const css::uno::Reference< css::text::XTextCursor >& xTextCursor ) { mxTextCursor = xTextCursor; }
+    void Move( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend, ooo::vba::word::E_DIRECTION eDirection ) throw (css::uno::RuntimeException);
 
     // Attribute
     virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setText( const rtl::OUString& rText ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Any& _xStyle ) throw (css::uno::RuntimeException);
 
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XListFormat > SAL_CALL getListFormat() throw (css::uno::RuntimeException);
     // Methods
     virtual void SAL_CALL InsertBreak( const css::uno::Any& _breakType ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
@@ -84,6 +89,10 @@ public:
     virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL InRange( const css::uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Revisions( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Sections( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Fields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sw/source/ui/vba/vbarangehelper.cxx sw/source/ui/vba/vbarangehelper.cxx
index 337fd9d..1ec6d46 100644
--- sw/source/ui/vba/vbarangehelper.cxx
+++ sw/source/ui/vba/vbarangehelper.cxx
@@ -27,6 +27,7 @@
 #include "vbarangehelper.hxx"
 #include <com/sun/star/text/ControlCharacter.hpp>
 #include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -111,7 +112,7 @@ uno::Reference< text::XTextCursor > SwVbaRangeHelper::initCursor( const uno::Ref
         DebugHelper::exception(e);
     }
 
-    if( !bGotTextCursor )
+    if( !bGotTextCursor || !xTextCursor.is() )
     {
         try
         {
@@ -125,7 +126,7 @@ uno::Reference< text::XTextCursor > SwVbaRangeHelper::initCursor( const uno::Ref
         }
     }
 
-    if( !bGotTextCursor )
+    if( !bGotTextCursor || !xTextCursor.is() )
     {
         try
         {
@@ -169,3 +170,29 @@ sal_Int32 SwVbaRangeHelper::getPosition( const uno::Reference< text::XText >& rT
 
     return nPosition;
 }
+
+uno::Reference< text::XTextContent > SwVbaRangeHelper::findBookmarkByPosition( const uno::Reference< text::XTextDocument >& xTextDoc, const uno::Reference< text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException )
+{
+    uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( xTextDoc, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = 0; index < xIndexAccess->getCount(); index++ )
+    {
+        uno::Reference< text::XTextContent > xBookmark( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xBkAnchor = xBookmark->getAnchor();
+        uno::Reference< text::XTextRangeCompare > xCompare( xBkAnchor->getText(), uno::UNO_QUERY_THROW );
+        if( xCompare->compareRegionStarts( xBkAnchor->getStart(), xBkAnchor->getEnd() ) == 0 )
+        {
+            try
+            {
+                if( xCompare->compareRegionStarts( xTextRange, xBkAnchor->getStart() ) == 0 )
+                    return xBookmark;
+            }
+            catch( uno::Exception& )
+            {
+                continue;
+            }
+        }
+    }
+    return uno::Reference< text::XTextContent >();
+}
+
diff --git sw/source/ui/vba/vbarangehelper.hxx sw/source/ui/vba/vbarangehelper.hxx
index 530c7e1..bf27480 100644
--- sw/source/ui/vba/vbarangehelper.hxx
+++ sw/source/ui/vba/vbarangehelper.hxx
@@ -30,6 +30,8 @@
 #include <vbahelper/vbahelperinterface.hxx>
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
 
 class SwVbaRangeHelper
 {
@@ -38,6 +40,7 @@ public:
     static void insertString( css::uno::Reference< css::text::XTextRange >& rTextRange, css::uno::Reference< css::text::XText >& rText, const rtl::OUString& rStr, sal_Bool _bAbsorb ) throw ( css::uno::RuntimeException );
     static css::uno::Reference< css::text::XTextCursor > initCursor( const css::uno::Reference< css::text::XTextRange >& rTextRange, const css::uno::Reference< css::text::XText >& rText ) throw ( css::uno::RuntimeException );
     static sal_Int32 getPosition( const css::uno::Reference< css::text::XText >& rText, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw ( css::uno::RuntimeException );
+    static css::uno::Reference< css::text::XTextContent > findBookmarkByPosition( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
 
 };
 #endif /* SW_VBA_RANGEHELPER_HXX */
diff --git sw/source/ui/vba/vbareplacement.cxx sw/source/ui/vba/vbareplacement.cxx
index 2bd7dcf..097699b 100644
--- sw/source/ui/vba/vbareplacement.cxx
+++ sw/source/ui/vba/vbareplacement.cxx
@@ -50,6 +50,12 @@ void SAL_CALL SwVbaReplacement::setText( const ::rtl::OUString& _text ) throw (u
     mxPropertyReplace->setReplaceString( _text );
 }
 
+void SAL_CALL SwVbaReplacement::ClearFormatting( ) throw (uno::RuntimeException)
+{
+    uno::Sequence< beans::PropertyValue > aPropValues;
+    mxPropertyReplace->setReplaceAttributes( aPropValues );
+}
+
 rtl::OUString& 
 SwVbaReplacement::getServiceImplName()
 {
diff --git sw/source/ui/vba/vbareplacement.hxx sw/source/ui/vba/vbareplacement.hxx
index c0f66af..62e1143 100644
--- sw/source/ui/vba/vbareplacement.hxx
+++ sw/source/ui/vba/vbareplacement.hxx
@@ -47,6 +47,9 @@ public:
     virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
 
+    //Methods
+    virtual void SAL_CALL ClearFormatting() throw (css::uno::RuntimeException);
+
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git sw/source/ui/vba/vbarevision.cxx sw/source/ui/vba/vbarevision.cxx
new file mode 100644
index 0000000..0c48b1d
--- /dev/null
+++ sw/source/ui/vba/vbarevision.cxx
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarevision.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
+#include "wordvbahelper.hxx"
+#include <docsh.hxx>
+#include <doc.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaRevision::SwVbaRevision( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xRedlineProps ) throw ( uno::RuntimeException ) : SwVbaRevision_BASE( rParent, rContext ), mxModel( xModel ), mxRedlineProps( xRedlineProps )
+{
+}
+
+SwVbaRevision::~SwVbaRevision()
+{
+}
+
+sal_Int32 SwVbaRevision::GetPosition() throw (css::uno::RuntimeException)
+{
+    sal_Int32 nPos = -1;
+    uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+    sal_Int32 nCount = xRedlines->getCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xRedlines->getByIndex( i ), uno::UNO_QUERY_THROW );
+        if( xProps == mxRedlineProps )
+        {
+            nPos = i;
+            OSL_TRACE(" SwVbaRevision::SwVbaRevision, the redline position is %d, ", nPos );
+            break;
+        }
+    }
+    if( nPos == -1 )
+        throw uno::RuntimeException();
+    
+    return nPos;
+}
+
+void SAL_CALL
+SwVbaRevision::Accept() throw ( css::uno::RuntimeException )
+{
+    SwDoc* pDoc = word::getDocShell( mxModel )->GetDoc();
+    if( pDoc )
+        pDoc->AcceptRedline( GetPosition(), sal_True );
+}
+
+void SAL_CALL
+SwVbaRevision::Reject( ) throw ( css::uno::RuntimeException )
+{
+    SwDoc* pDoc = word::getDocShell( mxModel )->GetDoc();
+    if( pDoc )
+        pDoc->RejectRedline( GetPosition(), sal_True );
+}
+
+rtl::OUString& 
+SwVbaRevision::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRevision") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaRevision::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Revision" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbarevision.hxx sw/source/ui/vba/vbarevision.hxx
new file mode 100644
index 0000000..0384370
--- /dev/null
+++ sw/source/ui/vba/vbarevision.hxx
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_REVISION_HXX
+#define SW_VBA_REVISION_HXX
+
+#include <ooo/vba/word/XRevision.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRevision > SwVbaRevision_BASE;
+
+class SwVbaRevision : public SwVbaRevision_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxRedlineProps;
+
+private:
+    sal_Int32 GetPosition() throw (css::uno::RuntimeException);
+
+public:
+	SwVbaRevision( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xRedlineProps ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRevision();
+
+    // Methods
+    virtual void SAL_CALL Accept(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Reject(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_REVISION_HXX */
diff --git sw/source/ui/vba/vbarevisions.cxx sw/source/ui/vba/vbarevisions.cxx
new file mode 100644
index 0000000..eea1394
--- /dev/null
+++ sw/source/ui/vba/vbarevisions.cxx
@@ -0,0 +1,188 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarevisions.hxx"
+#include "vbarevision.hxx"
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > RevisionEnumeration_BASE;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > RevisionCollectionHelper_BASE;
+typedef std::vector< uno::Reference< beans::XPropertySet > > RevisionMap;
+
+class RedlinesEnumeration : public RevisionEnumeration_BASE
+{
+	RevisionMap mRevisionMap;
+	RevisionMap::iterator mIt;
+public:
+	RedlinesEnumeration( const RevisionMap& sMap ) : mRevisionMap( sMap ), mIt( mRevisionMap.begin() ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( mIt != mRevisionMap.end() );
+	}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		uno::Reference< beans::XPropertySet > xRevision( *mIt++ );
+		return uno::makeAny( xRevision ) ;
+	}
+};
+
+class RevisionCollectionHelper : public RevisionCollectionHelper_BASE
+{
+	RevisionMap mRevisionMap;
+public:
+RevisionCollectionHelper( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException);
+    
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  beans::XPropertySet::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return ( mRevisionMap.size() > 0 ); }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) { return mRevisionMap.size(); }	
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+		if ( Index < 0 || Index >= getCount() )
+			throw lang::IndexOutOfBoundsException();
+	
+		return uno::makeAny( mRevisionMap[ Index ] );
+
+	}
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new RedlinesEnumeration( mRevisionMap );
+	}
+};
+
+RevisionCollectionHelper::RevisionCollectionHelper( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException)
+    {
+        uno::Reference< text::XTextRangeCompare > xTRC( xTextRange->getText(), uno::UNO_QUERY_THROW );
+        uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+        sal_Int32 nCount = xRedlines->getCount();
+        for( sal_Int32 index = 0; index < nCount; index++ )
+        {
+            uno::Reference< text::XTextRange > xRedlineRange( xRedlines->getByIndex( index ), uno::UNO_QUERY_THROW );
+            if( xTRC->compareRegionStarts( xTextRange, xRedlineRange ) >= 0 && xTRC->compareRegionEnds( xTextRange, xRedlineRange ) <= 0 )
+            {
+                uno::Reference< beans::XPropertySet > xRedlineProps( xRedlineRange, uno::UNO_QUERY_THROW );
+                mRevisionMap.push_back( xRedlineProps );
+            }
+        }
+    }
+class RevisionsEnumeration : public EnumerationHelperImpl
+{
+	uno::Reference< frame::XModel > m_xModel;
+public:
+	RevisionsEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xParent, xContext, xEnumeration ), m_xModel( xModel ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< beans::XPropertySet > xRevision( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< word::XRevision > ( new SwVbaRevision( m_xParent, m_xContext, m_xModel, xRevision ) ) );
+	}
+
+};
+
+SwVbaRevisions::SwVbaRevisions( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ): SwVbaRevisions_BASE( xParent, xContext, new RevisionCollectionHelper( xModel, xTextRange ) ),  mxModel( xModel )
+{
+}
+
+SwVbaRevisions::SwVbaRevisions( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< container::XIndexAccess >& xIndexAccess ): SwVbaRevisions_BASE( xParent, xContext, xIndexAccess ),  mxModel( xModel )
+{
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaRevisions::getElementType() throw (uno::RuntimeException)
+{
+	return word::XRevision::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaRevisions::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return new RevisionsEnumeration( this, mxContext, xEnumAccess->createEnumeration(), mxModel );
+}
+
+uno::Any
+SwVbaRevisions::createCollectionObject( const css::uno::Any& aSource )
+{
+    uno::Reference< beans::XPropertySet > xRevision( aSource, uno::UNO_QUERY_THROW );
+	return uno::makeAny( uno::Reference< word::XRevision > ( new SwVbaRevision( this, mxContext, mxModel, xRevision ) ) );
+}
+
+void SAL_CALL SwVbaRevisions::AcceptAll(  ) throw (css::uno::RuntimeException)
+{
+    // First we need to put all the redline into a vector, because if the redline is accepted,
+    // it will auto delete in the document.
+    std::vector< uno::Reference< word::XRevision > > aRevisions;
+    uno::Reference< container::XEnumeration > xEnumeration = createEnumeration();
+    while( xEnumeration->hasMoreElements() )
+    {
+        uno::Reference< word::XRevision > xRevision( xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+        aRevisions.push_back( xRevision );
+    }
+
+    std::vector< uno::Reference< word::XRevision > >::iterator it = aRevisions.begin();
+    for( ; it != aRevisions.end(); it++ )
+    {
+        uno::Reference< word::XRevision > xRevision( *it );
+        xRevision->Accept();
+    }
+}
+
+void SAL_CALL SwVbaRevisions::RejectAll(  ) throw (css::uno::RuntimeException)
+{
+    throw uno::RuntimeException();
+}
+
+rtl::OUString& 
+SwVbaRevisions::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRevisions") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaRevisions::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Revisions") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbarevisions.hxx sw/source/ui/vba/vbarevisions.hxx
new file mode 100644
index 0000000..88db794
--- /dev/null
+++ sw/source/ui/vba/vbarevisions.hxx
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PANES_HXX
+#define SW_VBA_PANES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XRevisions.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+
+
+typedef CollTestImplHelper< ooo::vba::word::XRevisions > SwVbaRevisions_BASE;
+
+class SwVbaRevisions : public SwVbaRevisions_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaRevisions( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextRange >& xTextRange );
+
+	SwVbaRevisions( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+	virtual ~SwVbaRevisions() {}
+
+    // Methods
+    virtual void SAL_CALL AcceptAll(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL RejectAll(  ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaRevisions_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_PANES_HXX */
diff --git sw/source/ui/vba/vbarow.cxx sw/source/ui/vba/vbarow.cxx
new file mode 100644
index 0000000..2f4132b
--- /dev/null
+++ sw/source/ui/vba/vbarow.cxx
@@ -0,0 +1,136 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarow.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <ooo/vba/word/WdRowHeightRule.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaRow::SwVbaRow( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( uno::RuntimeException ) :
+    SwVbaRow_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnIndex( nIndex )
+{
+    mxTableRows = mxTextTable->getRows();
+    mxRowProps.set( mxTableRows->getByIndex( mnIndex ), uno::UNO_QUERY_THROW );
+}
+
+SwVbaRow::~SwVbaRow()
+{
+}
+
+uno::Any SAL_CALL SwVbaRow::getHeight() throw (css::uno::RuntimeException)
+{
+    if( getHeightRule() == word::WdRowHeightRule::wdRowHeightAuto )
+        return uno::makeAny( sal_Int32( word::WdConstants::wdUndefined ) );
+
+    sal_Int32 nHeight = 0;
+    mxRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ) ) >>= nHeight;
+    return uno::makeAny( (float)Millimeter::getInPoints( nHeight ) );
+}
+
+void SAL_CALL SwVbaRow::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    float height = 0;
+    _height >>= height;
+
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( height );
+    mxRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ), uno::makeAny( nHeight ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaRow::getHeightRule() throw (css::uno::RuntimeException)
+{
+    sal_Bool isAutoHeight = sal_False;
+    mxRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoHeight") ) ) >>= isAutoHeight;
+    return isAutoHeight ? word::WdRowHeightRule::wdRowHeightAuto : word::WdRowHeightRule::wdRowHeightExactly;
+}
+
+void SAL_CALL SwVbaRow::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    sal_Bool isAutoHeight = ( _heightrule == word::WdRowHeightRule::wdRowHeightAuto );
+    mxRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoHeight") ), uno::makeAny( isAutoHeight ) );
+}
+
+void SAL_CALL
+SwVbaRow::Select( ) throw ( uno::RuntimeException )
+{
+    SelectRow( getCurrentWordDoc(mxContext), mxTextTable, mnIndex, mnIndex );
+}
+
+void SwVbaRow::SelectRow( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nStartRow, sal_Int32 nEndRow ) throw ( uno::RuntimeException )
+{
+    rtl::OUStringBuffer aRangeName;
+    aRangeName.appendAscii("A").append(sal_Int32( nStartRow + 1 ) );
+    SwVbaTableHelper aTableHelper( xTextTable );
+    sal_Int32 nColCount = aTableHelper.getTabColumnsCount( nEndRow );
+    // FIXME: the column count > 26
+    //sal_Char cCol = 'A' + nColCount - 1;
+    rtl::OUString sCol = aTableHelper.getColumnStr( nColCount - 1);
+    aRangeName.appendAscii(":").append( sCol ).append( sal_Int32( nEndRow + 1 ) );
+
+    uno::Reference< table::XCellRange > xCellRange( xTextTable, uno::UNO_QUERY_THROW );
+    rtl::OUString sSelRange = aRangeName.makeStringAndClear();
+    uno::Reference< table::XCellRange > xSelRange = xCellRange->getCellRangeByName( sSelRange );
+
+    uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelection->select( uno::makeAny( xSelRange ) );
+}
+
+void SAL_CALL SwVbaRow::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    setHeightRule( heightrule );
+    setHeight( uno::makeAny( height ) );
+}
+
+rtl::OUString& 
+SwVbaRow::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRow") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaRow::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Row" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbarow.hxx sw/source/ui/vba/vbarow.hxx
new file mode 100644
index 0000000..cfbfb4d
--- /dev/null
+++ sw/source/ui/vba/vbarow.hxx
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ROW_HXX
+#define SW_VBA_ROW_HXX
+
+#include <ooo/vba/word/XRow.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRow > SwVbaRow_BASE;
+
+class SwVbaRow : public SwVbaRow_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableRows > mxTableRows;
+    css::uno::Reference< css::beans::XPropertySet > mxRowProps;
+    sal_Int32 mnIndex;
+
+public:
+	SwVbaRow( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRow();
+
+    // Attributes
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+    static void SelectRow( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nStartRow, sal_Int32 nEndRow ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_ROW_HXX */
diff --git sw/source/ui/vba/vbarows.cxx sw/source/ui/vba/vbarows.cxx
new file mode 100644
index 0000000..e2737a4
--- /dev/null
+++ sw/source/ui/vba/vbarows.cxx
@@ -0,0 +1,368 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarows.hxx"
+#include "vbarow.hxx"
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <ooo/vba/word/WdRowAlignment.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <ooo/vba/word/WdRulerStyle.hpp>
+#include "wordvbahelper.hxx"
+#include "vbacolumns.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class RowsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::WeakReference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< text::XTextTable > mxTextTable;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+	sal_Int32 nIndex;
+
+public:
+	RowsEnumWrapper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< text::XTextTable >& xTextTable ) : mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), nIndex( 0 ) 
+    {
+        mxIndexAccess.set( mxTextTable->getRows(), uno::UNO_QUERY );
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return uno::makeAny( uno::Reference< word::XRow > ( new SwVbaRow( mxParent, mxContext, mxTextTable, nIndex++ ) ) );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaRows::SwVbaRows( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableRows >& xTableRows ) throw (uno::RuntimeException) : SwVbaRows_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableRows, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableRows( xTableRows ) 
+{
+    mnStartRowIndex = 0;
+    mnEndRowIndex = m_xIndexAccess->getCount() - 1;
+}
+
+SwVbaRows::SwVbaRows( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableRows >& xTableRows, sal_Int32 nStarIndex, sal_Int32 nEndIndex ) throw (uno::RuntimeException) : SwVbaRows_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableRows, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableRows( xTableRows ), mnStartRowIndex( nStarIndex ), mnEndRowIndex( nEndIndex ) 
+{
+    if( mnEndRowIndex < mnStartRowIndex )
+        throw uno::RuntimeException();
+}
+
+/**
+ * get the alignment of the rows: SO format com.sun.star.text.HoriOrientation
+ * is mapped to WdRowAlignment in Word
+ * @return the alignment
+ */
+::sal_Int32 SAL_CALL SwVbaRows::getAlignment() throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrient") ) ) >>= nAlignment;
+    sal_Int32 nRet = 0;
+    switch( nAlignment )
+    {
+        case text::HoriOrientation::CENTER:
+        {
+           nRet = word::WdRowAlignment::wdAlignRowCenter;
+           break;
+        }
+        case text::HoriOrientation::RIGHT:
+        {
+            nRet = word::WdRowAlignment::wdAlignRowRight;
+            break;
+        }
+        default:
+        {
+            nRet = word::WdRowAlignment::wdAlignRowLeft;
+        }
+    }
+    return nRet;
+}
+
+void SAL_CALL SwVbaRows::setAlignment( ::sal_Int32 _alignment ) throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    switch( _alignment )
+    {
+        case word::WdRowAlignment::wdAlignRowCenter:
+        {
+            nAlignment = text::HoriOrientation::CENTER;
+            break;
+        }
+        case word::WdRowAlignment::wdAlignRowRight:
+        {
+            nAlignment = text::HoriOrientation::RIGHT;
+            break;
+        }
+        default:
+        {
+            nAlignment = text::HoriOrientation::LEFT;
+        }
+    }
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrient") ), uno::makeAny( nAlignment ) );
+}
+
+uno::Any SAL_CALL SwVbaRows::getAllowBreakAcrossPages() throw (uno::RuntimeException)
+{
+    sal_Bool bAllowBreak = sal_False;
+    uno::Reference< container::XIndexAccess > xRowsAccess( mxTableRows, uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = mnStartRowIndex; index <= mnEndRowIndex; ++index )
+    {
+        uno::Reference< beans::XPropertySet > xRowProps( xRowsAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        sal_Bool bSplit = sal_False;
+        xRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsSplitAllowed") ) ) >>= bSplit;
+        if( index == 0 )
+        {
+            bAllowBreak = bSplit;
+        }
+        if( bSplit != bAllowBreak )
+        {
+            sal_Int32 nRet = word::WdConstants::wdUndefined;
+            return uno::makeAny( nRet );
+        }
+    }
+    return uno::makeAny( bAllowBreak );
+}
+
+void SAL_CALL SwVbaRows::setAllowBreakAcrossPages( const uno::Any& _allowbreakacrosspages ) throw (uno::RuntimeException)
+{
+    sal_Bool bAllowBreak = sal_False;
+    _allowbreakacrosspages >>= bAllowBreak;
+    uno::Reference< container::XIndexAccess > xRowsAccess( mxTableRows, uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = mnStartRowIndex; index <= mnEndRowIndex; ++index )
+    {
+        uno::Reference< beans::XPropertySet > xRowProps( xRowsAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        xRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsSplitAllowed") ), uno::makeAny( bAllowBreak ) );
+    }    
+}
+
+float SAL_CALL SwVbaRows::getSpaceBetweenColumns() throw (uno::RuntimeException)
+{
+    // just get the first spacing of the first cell
+    uno::Reference< table::XCellRange > xCellRange( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xCellProps( xCellRange->getCellByPosition( 0, mnStartRowIndex ), uno::UNO_QUERY_THROW );
+    sal_Int32 nLeftBorderDistance = 0;
+    sal_Int32 nRightBorderDistance = 0;
+    xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftBorderDistance") ) ) >>= nLeftBorderDistance;
+    xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightBorderDistance") ) ) >>= nRightBorderDistance;
+    return static_cast< float >( Millimeter::getInPoints( nLeftBorderDistance + nRightBorderDistance ) );
+}
+
+void SAL_CALL SwVbaRows::setSpaceBetweenColumns( float _spacebetweencolumns ) throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = Millimeter::getInHundredthsOfOneMillimeter( _spacebetweencolumns ) / 2;
+    uno::Reference< container::XIndexAccess > xColumnAccess( mxTextTable->getColumns(), uno::UNO_QUERY_THROW );
+    uno::Reference< table::XCellRange > xCellRange( mxTextTable, uno::UNO_QUERY_THROW );
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    for( sal_Int32 row = mnStartRowIndex; row <= mnEndRowIndex; ++row )
+    {
+        sal_Int32 nColumns = aTableHelper.getTabColumnsCount( row );
+        for( sal_Int32 column = 0; column < nColumns; ++column )
+        {
+            uno::Reference< beans::XPropertySet > xCellProps( xCellRange->getCellByPosition( column, row ), uno::UNO_QUERY_THROW );
+            xCellProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftBorderDistance") ), uno::makeAny( nSpace ) );
+            xCellProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightBorderDistance") ), uno::makeAny( nSpace ) );
+        }
+    }
+}
+
+void SAL_CALL SwVbaRows::Delete(  ) throw (uno::RuntimeException)
+{
+    mxTableRows->removeByIndex( mnStartRowIndex, getCount() );
+}
+
+void SAL_CALL SwVbaRows::SetLeftIndent( float LeftIndent, ::sal_Int32 RulerStyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XColumns > xColumns( new SwVbaColumns( getParent(), mxContext, mxTextTable, mxTextTable->getColumns() ) );
+    sal_Int32 nIndent = (sal_Int32)( LeftIndent );
+    switch( RulerStyle )
+    {
+        case word::WdRulerStyle::wdAdjustFirstColumn:
+        {
+            setIndentWithAdjustFirstColumn( xColumns, nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustNone:
+        {
+            setIndentWithAdjustNone( nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustProportional:
+        {
+            setIndentWithAdjustProportional( xColumns, nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustSameWidth:
+        {
+            setIndentWithAdjustSameWidth( xColumns, nIndent );
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+        }
+    }
+}
+
+void SwVbaRows::setIndentWithAdjustNone( sal_Int32 indent ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nMargin = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ) ) >>= nMargin;
+    nMargin += indent;
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ), uno::makeAny( nMargin ) );
+}
+
+ void SwVbaRows::setIndentWithAdjustFirstColumn( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    sal_Int32 nIndex = 1;
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( nIndex ), uno::Any() ), uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = xColumn->getWidth();
+    nWidth -= indent;
+    xColumn->setWidth( nWidth );
+    setIndentWithAdjustNone( indent );
+ }
+
+ void SwVbaRows::setIndentWithAdjustProportional( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    // calculate the new width and get the proportion between old and new
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    sal_Int32 nNewWidth = nWidth - indent;
+    double propFactor = (double)nNewWidth/(double)nWidth;
+
+    // get all columns, calculate and set the new width of the columns
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    sal_Int32 nColCount = xCol->getCount();
+    for( sal_Int32 i = 0; i < nColCount; i++ )
+    {
+        uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( i ), uno::Any() ), uno::UNO_QUERY_THROW );
+        sal_Int32 nColWidth = xColumn->getWidth();
+        sal_Int32 nNewColWidth = ( sal_Int32 )( propFactor * nColWidth );
+        xColumn->setWidth( nNewColWidth );
+    }
+
+    // set the width and position of the table
+    setIndentWithAdjustNone( indent );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( nNewWidth ) );
+ }
+
+ void SwVbaRows::setIndentWithAdjustSameWidth( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    // calculate the new width and get the width of all columns
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    sal_Int32 nNewWidth = nWidth - indent;
+
+    // get all columns, calculate and set the new width of the columns
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    sal_Int32 nColCount = xCol->getCount();
+    sal_Int32 nNewColWidth = (sal_Int32)( double( nNewWidth )/nColCount );
+    for( sal_Int32 i = 0; i < nColCount; i++ )
+    {
+        uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( i ), uno::Any() ), uno::UNO_QUERY_THROW );
+        xColumn->setWidth( nNewColWidth );
+    }
+
+    // set the width and position of the table
+    setIndentWithAdjustNone( indent );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( nNewWidth ) );
+ }
+
+void SAL_CALL SwVbaRows::Select(  ) throw (uno::RuntimeException)
+{
+    SwVbaRow::SelectRow( getCurrentWordDoc(mxContext), mxTextTable, mnStartRowIndex, mnEndRowIndex ); 
+}
+
+::sal_Int32 SAL_CALL SwVbaRows::getCount() throw (uno::RuntimeException)
+{
+    return ( mnEndRowIndex - mnStartRowIndex + 1 );
+}
+
+uno::Any SAL_CALL SwVbaRows::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex <= 0 || nIndex > getCount() )
+        {
+            throw  lang::IndexOutOfBoundsException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        }
+        return uno::makeAny( uno::Reference< word::XRow >( new SwVbaRow( this, mxContext, mxTextTable, nIndex - 1 ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaRows::getElementType() throw (uno::RuntimeException)
+{
+	return word::XRow::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaRows::createEnumeration() throw (uno::RuntimeException)
+{
+    return new RowsEnumWrapper( this, mxContext, mxTextTable );
+}
+
+uno::Any
+SwVbaRows::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaRows::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRows") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaRows::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Rows") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbarows.hxx sw/source/ui/vba/vbarows.hxx
new file mode 100644
index 0000000..ccff1ef
--- /dev/null
+++ sw/source/ui/vba/vbarows.hxx
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ROWS_HXX
+#define SW_VBA_ROWS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XRows.hpp>
+#include <ooo/vba/word/XColumns.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XRows > SwVbaRows_BASE;
+
+class SwVbaRows : public SwVbaRows_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableRows > mxTableRows;
+    sal_Int32 mnStartRowIndex;
+    sal_Int32 mnEndRowIndex;
+
+private:
+    void setIndentWithAdjustNone( sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustFirstColumn( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustProportional( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustSameWidth( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaRows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableRows >& xTableRows ) throw ( css::uno::RuntimeException );
+	SwVbaRows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableRows >& xTableRows, sal_Int32 nStarIndex, sal_Int32 nEndIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRows() {}
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getAlignment() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAlignment( ::sal_Int32 _alignment ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getAllowBreakAcrossPages() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAllowBreakAcrossPages( const css::uno::Any& _allowbreakacrosspages ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getSpaceBetweenColumns() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSpaceBetweenColumns( float _spacebetweencolumns ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetLeftIndent( float LeftIndent, ::sal_Int32 RulerStyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    //XCollection
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaRows_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_ROWS_HXX */
diff --git sw/source/ui/vba/vbasection.cxx sw/source/ui/vba/vbasection.cxx
index 4df6f0b..fd747b3 100644
--- sw/source/ui/vba/vbasection.cxx
+++ sw/source/ui/vba/vbasection.cxx
@@ -28,6 +28,7 @@
 #include <vbahelper/vbahelper.hxx>
 #include <tools/diagnose_ex.h>
 #include "vbapagesetup.hxx"
+#include "vbaheadersfooters.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -50,14 +51,20 @@ void SAL_CALL SwVbaSection::setProtectedForForms( ::sal_Bool /*_protectedforform
 {
 }
 
-uno::Any SAL_CALL SwVbaSection::Headers(  ) throw (uno::RuntimeException)
+uno::Any SAL_CALL SwVbaSection::Headers( const uno::Any& index ) throw (uno::RuntimeException)
 {
-    return uno::Any();
+    uno::Reference< XCollection > xCol( new SwVbaHeadersFooters( this, mxContext, mxModel, mxPageProps, sal_True ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
 }
 
-uno::Any SAL_CALL SwVbaSection::Footers(  ) throw (uno::RuntimeException)
+uno::Any SAL_CALL SwVbaSection::Footers( const uno::Any& index ) throw (uno::RuntimeException)
 {
-    return uno::Any();
+    uno::Reference< XCollection > xCol( new SwVbaHeadersFooters( this, mxContext, mxModel, mxPageProps, sal_False ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
 }
 
 uno::Any SAL_CALL
diff --git sw/source/ui/vba/vbasection.hxx sw/source/ui/vba/vbasection.hxx
index 9dd4058..dc1984f 100644
--- sw/source/ui/vba/vbasection.hxx
+++ sw/source/ui/vba/vbasection.hxx
@@ -48,8 +48,8 @@ public:
     virtual void SAL_CALL setProtectedForForms( ::sal_Bool _protectedforforms ) throw (css::uno::RuntimeException);
 
     // Methods
-    virtual css::uno::Any SAL_CALL Headers(  ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Footers(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Headers( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Footers( const css::uno::Any& index ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL PageSetup(  ) throw (css::uno::RuntimeException);
 
     // XHelperInterface
diff --git sw/source/ui/vba/vbasections.cxx sw/source/ui/vba/vbasections.cxx
index 6a4ae0e..6e6ee9b 100644
--- sw/source/ui/vba/vbasections.cxx
+++ sw/source/ui/vba/vbasections.cxx
@@ -87,6 +87,15 @@ public:
         }
     }
 
+    SectionCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        // Hacky implementation of Range.Sections, only support 1 secction
+        uno::Reference< beans::XPropertySet > xRangeProps( xTextRange, uno::UNO_QUERY_THROW );
+        uno::Reference< style::XStyle > xStyle = word::getCurrentPageStyle( mxModel, xRangeProps );
+        uno::Reference< beans::XPropertySet > xPageProps( xStyle, uno::UNO_QUERY_THROW );
+        mxSections.push_back( xPageProps );
+    }
+
     ~SectionCollectionHelper(){}
 
     // XIndexAccess
@@ -134,6 +143,10 @@ SwVbaSections::SwVbaSections( const uno::Reference< XHelperInterface >& xParent,
 {
 }
 
+SwVbaSections::SwVbaSections( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ): SwVbaSections_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new SectionCollectionHelper( xParent, xContext, xModel, xTextRange ) ) ),  mxModel( xModel )
+{
+}
+
 uno::Any SAL_CALL
 SwVbaSections::PageSetup( ) throw (uno::RuntimeException)
 {
diff --git sw/source/ui/vba/vbasections.hxx sw/source/ui/vba/vbasections.hxx
index 9cb35cf..74812a3 100644
--- sw/source/ui/vba/vbasections.hxx
+++ sw/source/ui/vba/vbasections.hxx
@@ -31,6 +31,7 @@
 #include <ooo/vba/word/XSections.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <vbahelper/vbahelperinterface.hxx>
 
 typedef CollTestImplHelper< ooo::vba::word::XSections > SwVbaSections_BASE;
@@ -42,6 +43,7 @@ private:
 
 public:
     SwVbaSections( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	SwVbaSections( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextRange >& xTextRange );
     virtual ~SwVbaSections() {}
 
     // XEnumerationAccess
diff --git sw/source/ui/vba/vbaselection.cxx sw/source/ui/vba/vbaselection.cxx
index 17d4e2f..90c9e51 100644
--- sw/source/ui/vba/vbaselection.cxx
+++ sw/source/ui/vba/vbaselection.cxx
@@ -29,7 +29,6 @@
 #include <tools/diagnose_ex.h>
 #include "vbarange.hxx"
 #include "vbafind.hxx"
-#include "wordvbahelper.hxx"
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextTable.hpp>
 #include <com/sun/star/text/XTextTableCursor.hpp>
@@ -41,14 +40,19 @@
 #include <ooo/vba/word/WdGoToDirection.hpp>
 #include <ooo/vba/word/XBookmark.hpp>
 #include <ooo/vba/word/XApplication.hpp>
+#include <ooo/vba/word/WdCollapseDirection.hpp>
 #include <com/sun/star/text/XPageCursor.hpp>
 #include "unotbl.hxx"
 #include "unocoll.hxx"
 #include "vbatable.hxx"
 #include <com/sun/star/view/XSelectionSupplier.hpp>
 #include <com/sun/star/view/XViewCursor.hpp>
+#include <com/sun/star/view/XLineCursor.hpp>
+#include <com/sun/star/text/XWordCursor.hpp>
+#include <com/sun/star/text/XParagraphCursor.hpp>
 #include <ooo/vba/word/WdInformation.hpp>
 #include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+#include <ooo/vba/word/WdSeekView.hpp>
 #include "vbainformationhelper.hxx"
 #include "vbafield.hxx"
 #include "vbaheaderfooter.hxx"
@@ -56,6 +60,17 @@
 #include <vbahelper/vbashaperange.hxx>
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/text/ControlCharacter.hpp>
+#include "vbarows.hxx"
+#include "vbacolumns.hxx"
+#include "vbatablehelper.hxx"
+#include "vbacells.hxx"
+#include "vbaview.hxx"
+#include "vbaparagraph.hxx"
+#include "vbastyle.hxx"
+#include <docsh.hxx>
+#include <tblenum.hxx>
+#include <fesh.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -123,23 +138,25 @@ SwVbaSelection::HomeKey( const uno::Any& _unit, const uno::Any& _extend ) throw
     sal_Int32 nExtend = word::WdMovementType::wdMove;
     _unit >>= nUnit;
     _extend >>= nExtend;
+    sal_Bool bExtend = ( nExtend == word::WdMovementType::wdExtend ) ? sal_True : sal_False;
 
     switch( nUnit )
     {
         case word::WdUnits::wdStory:
         {
+			// go to the valid text first so that the current view cursor is valid to call gotoRange.
+			word::gotoSelectedObjectAnchor(mxModel);
             // go to the begin of the document
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfDoc"));
-            dispatchRequests( mxModel,url );
-            // If something is selected, it needs to go twice
-            dispatchRequests( mxModel,url );
+            uno::Reference< text::XText > xCurrentText = word::getCurrentXText( mxModel );
+            uno::Reference< text::XTextRange > xFirstRange = word::getFirstObjectPosition( xCurrentText );
+            mxTextViewCursor->gotoRange( xFirstRange, bExtend );
             break;
         }
         case word::WdUnits::wdLine:
         {
             // go to the begin of the Line
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfLine"));
-            dispatchRequests( mxModel,url );
+            uno::Reference< view::XLineCursor > xLineCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            xLineCursor->gotoStartOfLine( bExtend );
             break;
         }
         default:
@@ -157,23 +174,25 @@ SwVbaSelection::EndKey( const uno::Any& _unit, const uno::Any& _extend ) throw (
     sal_Int32 nExtend = word::WdMovementType::wdMove;
     _unit >>= nUnit;
     _extend >>= nExtend;
+    sal_Bool bExtend = ( nExtend == word::WdMovementType::wdExtend ) ? sal_True : sal_False;
 
     switch( nUnit )
     {
         case word::WdUnits::wdStory:
         {
-            // go to the end of the document
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfDoc"));
-            dispatchRequests( mxModel,url );
-            // If something is selected, it needs to go twice
-            dispatchRequests( mxModel,url );
+			// go to the valid text first so that the current view cursor is valid to call gotoRange.
+			word::gotoSelectedObjectAnchor(mxModel);
+            // go to the end of the document			
+            uno::Reference< text::XText > xCurrentText = word::getCurrentXText( mxModel );
+            uno::Reference< text::XTextRange > xEnd = xCurrentText->getEnd();
+            mxTextViewCursor->gotoRange( xEnd, bExtend );
             break;
         }
         case word::WdUnits::wdLine:
         {
             // go to the end of the Line
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfLine"));
-            dispatchRequests( mxModel,url );
+            uno::Reference< view::XLineCursor > xLineCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            xLineCursor->gotoEndOfLine( bExtend );
             break;
         }
         default:
@@ -185,14 +204,161 @@ SwVbaSelection::EndKey( const uno::Any& _unit, const uno::Any& _extend ) throw (
 }
 
 void SAL_CALL
-SwVbaSelection::Delete( const uno::Any& /*_unit*/, const uno::Any& /*_count*/ ) throw ( uno::RuntimeException )
+SwVbaSelection::Delete( const uno::Any& _unit, const uno::Any& _count ) throw ( uno::RuntimeException )
 {
-    // FIXME: handle the arguments: _unit and _count 
+    sal_Int32 nUnit = word::WdUnits::wdLine;
+    sal_Int32 nCount = 0;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _unit.hasValue() && ( nCount > 0 ) )
+    {
+        _unit >>= nUnit;
+        switch( nUnit )
+        {
+            case word::WdUnits::wdCharacter:
+            {
+                if( HasSelection() )
+                    nCount--;
+                mxTextViewCursor->goRight( nCount, sal_True );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }    
+        }
+    }
     rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Delete"));
     dispatchRequests( mxModel,url );
 }
 
-void SwVbaSelection::NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+void
+SwVbaSelection::Move( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+
+    sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdCell:
+        {
+            if(  nExtend == word::WdMovementType::wdExtend )
+            {
+                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+                return;
+            }
+            NextCell( nCount, eDirection );
+            break;
+        }
+        case word::WdUnits::wdLine:
+        {
+            if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            if( eDirection == word::MOVE_UP )
+                xViewCursor->goUp( nCount, bExpand );
+            else if( eDirection == word::MOVE_DOWN )
+                xViewCursor->goDown( nCount, bExpand );
+            break;
+        }
+        case word::WdUnits::wdCharacter:
+        {
+            if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            if( word::gotoSelectedObjectAnchor( mxModel ) )
+            {
+                nCount--;
+            }
+            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            if( eDirection == word::MOVE_LEFT )
+            {
+                // if current select is a cellrange or table, 
+                // the first count of move should move to the first selected cell.
+                uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+                if ( xTextTableCursor.is() )
+                {
+                    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+                    uno::Reference< text::XTextTable > xTextTable;
+                    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+                    if( xTextTable.is() )
+                    {
+                        uno::Reference< text::XTextRange > xRange( xTextTable->getCellByName( xTextTableCursor->getRangeName()), uno::UNO_QUERY_THROW );
+                        mxTextViewCursor->gotoRange( xRange->getStart(), bExpand );
+                        nCount--;
+                    }
+                }
+                xViewCursor->goLeft( nCount, bExpand );
+            }    
+            else if( eDirection == word::MOVE_RIGHT )
+                xViewCursor->goRight( nCount, bExpand );
+            break;
+        }
+        case word::WdUnits::wdWord:
+        case word::WdUnits::wdParagraph:
+        {
+			uno::Reference< text::XTextRange > xRange = GetSelectedRange();
+			uno::Reference< text::XText > xText = xRange->getText();
+			uno::Reference< text::XTextCursor > xTextCursor = xText->createTextCursorByRange( xRange );
+			if( nUnit == word::WdUnits::wdParagraph )
+			{
+				if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+				{
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+				}
+				uno::Reference< text::XParagraphCursor > xParagraphCursor( xTextCursor, uno::UNO_QUERY_THROW );
+				for( sal_Int32 i=0; i<nCount; i++ )
+				{
+					if( ( eDirection == word::MOVE_UP ) && ( xParagraphCursor->gotoPreviousParagraph( bExpand ) == sal_False ) )
+						break;
+					else if( ( eDirection == word::MOVE_DOWN ) && ( xParagraphCursor->gotoNextParagraph( bExpand ) == sal_False ) )
+						break;
+				}
+			}
+			else if( nUnit == word::WdUnits::wdWord )
+			{
+				if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+				{
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+				}
+				uno::Reference< text::XWordCursor > xWordCursor( xTextCursor, uno::UNO_QUERY_THROW );
+				for( sal_Int32 i=0; i<nCount; i++ )
+				{
+					if( (eDirection == word::MOVE_LEFT ) && ( xWordCursor->gotoPreviousWord( bExpand ) == sal_False ) )
+						break;
+					else if( ( eDirection == word::MOVE_RIGHT ) && ( xWordCursor->gotoNextWord( bExpand ) == sal_False ) )
+						break;
+				}
+			}
+			mxTextViewCursor->gotoRange( xTextCursor->getStart(), sal_False );
+			mxTextViewCursor->gotoRange( xTextCursor->getEnd(), sal_True );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
+
+void SwVbaSelection::NextCell( sal_Int32 nCount, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
 {
     uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
     uno::Reference< text::XTextTable > xTextTable;
@@ -211,22 +377,22 @@ void SwVbaSelection::NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw
     // move the table cursor 
     switch( eDirection )
     {
-        case MOVE_LEFT:
+        case word::MOVE_LEFT:
         {
             xTextTableCursor->goLeft( nCount, sal_False );
             break;
         }
-        case MOVE_RIGHT:
+        case word::MOVE_RIGHT:
         {
             xTextTableCursor->goRight( nCount, sal_False );
             break;
         }
-        case MOVE_UP:
+        case word::MOVE_UP:
         {
             xTextTableCursor->goUp( nCount, sal_False );
             break;
         }
-        case MOVE_DOWN:
+        case word::MOVE_DOWN:
         {
             xTextTableCursor->goDown( nCount, sal_False );
             break;
@@ -245,61 +411,29 @@ void SwVbaSelection::NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw
 void SAL_CALL
 SwVbaSelection::MoveRight( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
 
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
     
     if( nCount < 0 )
     {
-        // TODO: call MoveLeft;
         MoveLeft( _unit, uno::makeAny( -nCount ), _extend );
         return;
     }
-    
-    switch( nUnit )
-    {
-        case word::WdUnits::wdCell:
-        {
-            if(  nExtend == word::WdMovementType::wdExtend )
-            {
-                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
-                return;
-            }
-            NextCell( nCount, MOVE_RIGHT );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
-    }
 
+    Move( _unit, _count, _extend, word::MOVE_RIGHT );
 }
 
 void SAL_CALL
 SwVbaSelection::MoveLeft( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
-
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
@@ -310,67 +444,47 @@ SwVbaSelection::MoveLeft( const uno::Any& _unit, const uno::Any& _count, const u
         return;
     }
     
-    switch( nUnit )
-    {
-        case word::WdUnits::wdCell:
-        {
-            if(  nExtend == word::WdMovementType::wdExtend )
-            {
-                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
-                return;
-            }
-            NextCell( nCount, MOVE_LEFT );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
-    }
-
+    Move( _unit, _count, _extend, word::MOVE_LEFT );
 }
 
 void SAL_CALL
 SwVbaSelection::MoveDown( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
 
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
     
     if( nCount < 0 )
     {
-        // TODO: call MoveLeft;
-        //MoveUp( _unit, uno::makeAny( -nCount ), _extend );
+        MoveUp( _unit, uno::makeAny( -nCount ), _extend );
         return;
     }
     
-    switch( nUnit )
+    Move( _unit, _count, _extend, word::MOVE_DOWN );
+}
+
+void SAL_CALL
+SwVbaSelection::MoveUp( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nCount = 1;
+
+    if( _count.hasValue() )
+        _count >>= nCount;
+    
+    if( nCount == 0 )
+        return;
+    
+    if( nCount < 0 )
     {
-        case word::WdUnits::wdLine:
-        {
-            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
-            sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
-            xViewCursor->goDown( nCount, bExpand );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
+        MoveDown( _unit, uno::makeAny( -nCount ), _extend );
+        return;
     }
-
+    
+    Move( _unit, _count, _extend, word::MOVE_UP );
 }
 
 void SAL_CALL
@@ -422,16 +536,17 @@ SwVbaSelection::getFind() throw ( uno::RuntimeException )
     return uno::Reference< word::XFind >( new SwVbaFind( this, mxContext, mxModel, xTextRange ) );
 }
 
-uno::Reference< word::XStyle > SAL_CALL
+uno::Any SAL_CALL
 SwVbaSelection::getStyle() throw ( uno::RuntimeException )
 {
     return getRange()->getStyle();
 }
 
 void SAL_CALL
-SwVbaSelection::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+SwVbaSelection::setStyle( const uno::Any& rStyle ) throw ( uno::RuntimeException )
 {
-    return getRange()->setStyle( rStyle );
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    return SwVbaStyle::setStyle( xParaProps, rStyle );
 }
 
 uno::Reference< word::XFont > SAL_CALL
@@ -474,39 +589,79 @@ uno::Reference< word::XRange > SAL_CALL SwVbaSelection::GoTo( const uno::Any& _w
             sal_Int32 nWhich = 0;
             if( _which.hasValue() )
                 _which >>= nWhich;
-             sal_Int32 nPage = 0;
-             switch( nWhich )
-             {
-                case word::WdGoToDirection::wdGoToLast:
-                {
-                    nPage = nLastPage;
-                    break;
-                }
-                case word::WdGoToDirection::wdGoToNext:
-                {
-                    nPage = nCurrPage + 1;
-                    break;
-                }
-                case word::WdGoToDirection::wdGoToPrevious:
-                {
-                    nPage = nCurrPage - 1;
-                    break;
-                }
-                default:
-                {
-                    nPage = nCount;
-                }
-             }
-             if( nPage <= 0 )
-                nPage = 1;
-             if( nPage > nLastPage )
-                nPage = nLastPage;
-             xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
-             break;
+            sal_Int32 nPage = 0;
+            switch( nWhich )
+            {
+               case word::WdGoToDirection::wdGoToLast:
+               {
+                   nPage = nLastPage;
+                   break;
+               }
+               case word::WdGoToDirection::wdGoToNext:
+               {
+                   if( nCount !=0 )
+                       nPage = nCurrPage + nCount;
+                   else    
+                       nPage = nCurrPage + 1;
+                   break;
+               }
+               case word::WdGoToDirection::wdGoToPrevious:
+               {
+                   if( nCount !=0 )
+                       nPage = nCurrPage - nCount;
+                   else    
+                       nPage = nCurrPage - 1;
+                   break;
+               }
+               default:
+               {
+                   nPage = nCount;
+               }
+            }
+            if( _name.hasValue() )
+            {
+                rtl::OUString sName;
+                _name >>= sName;
+                sal_Int32 nName = sName.toInt32();
+                if( nName !=0 )
+                    nPage = nName;
+            }
+            if( nPage <= 0 )
+               nPage = 1;
+            if( nPage > nLastPage )
+               nPage = nLastPage;
+            xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
+            break;
         }
         case word::WdGoToItem::wdGoToSection:
         {
-            // TODO: implement Section object
+            uno::Reference< text::XPageCursor > xPageCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            sal_Int32 nCount = 0;
+            if( _count.hasValue() )
+                _count >>= nCount;
+            sal_Int32 nWhich = 0;
+            if( _which.hasValue() )
+                _which >>= nWhich;
+            sal_Int32 nPage = 0;    
+            switch( nWhich )
+            {
+               case word::WdGoToDirection::wdGoToAbsolute:
+               {
+                    // currently only support this type
+                    if( nCount == 1 )
+                        nPage = 1;
+                    break;
+               }
+               default:
+               {
+                    nPage = 0;
+               }
+            }   
+            if( nPage != 0 )
+                xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
+            else    
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;    
         }
         default:
             throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
@@ -546,6 +701,82 @@ uno::Any SAL_CALL SwVbaSelection::Information( sal_Int32 _type ) throw (uno::Run
             result = uno::makeAny( SwVbaInformationHelper::handleWdVerticalPositionRelativeToPage( mxModel, mxTextViewCursor ) );
             break;
         }
+        case word::WdInformation::wdWithInTable:
+        {
+            uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XTextTable > xTextTable;
+            xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+            if( xTextTable.is() )
+                result = uno::makeAny( sal_True );
+            else
+                result = uno::makeAny( sal_False );
+            break;
+        }
+        case word::WdInformation::wdHeaderFooterType:
+        {
+            uno::Reference< word::XView > xView( new SwVbaView( this, mxContext, mxModel ) );
+            sal_Int32 nView = xView->getSeekView();
+            sal_Int32 nHeaderFooterType = 0;
+            switch( nView )
+            {
+                case word::WdSeekView::wdSeekMainDocument:
+                {
+                    nHeaderFooterType = -1; // not in a header or footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekEvenPagesHeader:
+                {
+                    nHeaderFooterType = 0; // even page header
+                    break;
+                }
+                case word::WdSeekView::wdSeekPrimaryHeader:
+                {
+                    nHeaderFooterType = 1; // odd page header
+                    break;
+                }
+                case word::WdSeekView::wdSeekEvenPagesFooter:
+                {
+                    nHeaderFooterType = 2; // even page footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekPrimaryFooter:
+                {
+                    nHeaderFooterType = 3; // odd page footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekFirstPageHeader:
+                case word::WdSeekView::wdSeekFirstPageFooter:
+                {
+                    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+                    rtl::OUString aPageStyleName;
+                    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+                    sal_Bool bFirstPage = sal_False;
+                    if( aPageStyleName.equalsAscii( "First Page" ) )
+                        bFirstPage = sal_True;
+                    if( nView == word::WdSeekView::wdSeekFirstPageHeader )
+                    {
+                        if( bFirstPage )
+                            nHeaderFooterType = 4; 
+                        else
+                            nHeaderFooterType = 1;
+                    }        
+                    else        
+                    {
+                        if( bFirstPage )
+                            nHeaderFooterType = 5; 
+                        else
+                            nHeaderFooterType = 3;
+                    }        
+                    break;
+                }
+                default:
+                {
+                    nHeaderFooterType = -1;
+                }
+            }
+            result = uno::makeAny( nHeaderFooterType );
+            break;
+        }
         default:
             throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
     }
@@ -566,11 +797,6 @@ SwVbaSelection::Tables( const uno::Any& aIndex ) throw (uno::RuntimeException)
     // we can only support a selection that is a single table
     if ( !aIndex.hasValue() ) // currently we can't support multiple tables in a selection
        throw uno::RuntimeException(); 
-    // if the current selection is a XTextTableCursor and the index is 1 then we can service this request, otherwise we just have to throw
-    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
-
-    if ( !xTextTableCursor.is() )
-       throw uno::RuntimeException(); 
 
     sal_Int32 nIndex = 0;
     aIndex >>= nIndex;
@@ -579,6 +805,24 @@ SwVbaSelection::Tables( const uno::Any& aIndex ) throw (uno::RuntimeException)
 
     if ( nIndex != 1 )
        throw uno::RuntimeException(); 
+
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    if( xTextTable.is() )
+    {
+            uno::Reference< css::text::XTextDocument > xTextDoc( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< word::XTable > xVBATbl = new SwVbaTable( mxParent, mxContext, xTextDoc, xTextTable ); 
+            aRet <<= xVBATbl;
+            return aRet;
+    }
+
+    // if the current selection is a XTextTableCursor and the index is 1 then we can service this request, otherwise we just have to throw
+    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+
+    if ( !xTextTableCursor.is() )
+       throw uno::RuntimeException(); 
+
     SwXTextTableCursor* pTTCursor = dynamic_cast< SwXTextTableCursor* >( xTextTableCursor.get() );
     if ( pTTCursor )
     {
@@ -608,15 +852,14 @@ SwVbaSelection::Fields( const uno::Any& index ) throw (uno::RuntimeException)
 uno::Reference< word::XHeaderFooter > SAL_CALL
 SwVbaSelection::getHeaderFooter() throw ( uno::RuntimeException )
 {
-    uno::Reference< text::XText > xCurrentText = word::getXTextViewCursor( mxModel )->getText();
-    if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFooter( mxModel, xCurrentText ) )
+    if( HeaderFooterHelper::isHeaderFooter( mxModel ) )
     {
         uno::Reference< beans::XPropertySet > xPageStyleProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
         sal_Int32 nIndex = word::WdHeaderFooterIndex::wdHeaderFooterPrimary;
-        sal_Bool isHeader = HeaderFooterHelper::isHeader( mxModel, xCurrentText );
-        if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+        sal_Bool isHeader = HeaderFooterHelper::isHeader( mxModel );
+        if( HeaderFooterHelper::isEvenPagesHeader( mxModel ) || HeaderFooterHelper::isEvenPagesFooter( mxModel ) )
             nIndex = word::WdHeaderFooterIndex::wdHeaderFooterEvenPages;
-        else if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+        else if( HeaderFooterHelper::isFirstPageHeader( mxModel ) || HeaderFooterHelper::isFirstPageFooter( mxModel ) )
             nIndex = word::WdHeaderFooterIndex::wdHeaderFooterFirstPage;
         
         return uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( this, mxContext, mxModel, xPageStyleProps, isHeader, nIndex ) );
@@ -629,9 +872,13 @@ uno::Any SAL_CALL
 SwVbaSelection::ShapeRange( ) throw (uno::RuntimeException)
 {
     uno::Reference< drawing::XShapes > xShapes( mxModel->getCurrentSelection(), uno::UNO_QUERY );
-
     if ( !xShapes.is() )
-       throw uno::RuntimeException(); 
+    {
+        uno::Reference< drawing::XShape > xShape( mxModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
+        uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+        xShapes.set( xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.drawing.ShapeCollection" ) ), uno::UNO_QUERY_THROW );
+        xShapes->add( xShape );
+    }   
 
     uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
     uno::Reference< drawing::XDrawPage > xDrawPage = xDrawPageSupplier->getDrawPage();
@@ -658,6 +905,281 @@ void SAL_CALL SwVbaSelection::setEnd( ::sal_Int32 _end ) throw (uno::RuntimeExce
     getRange()->setEnd( _end );
 }
 
+void SAL_CALL SwVbaSelection::SelectRow() throw (uno::RuntimeException)
+{
+    uno::Reference< word::XRows > xRows( Rows( uno::Any() ), uno::UNO_QUERY_THROW );
+    xRows->Select();
+}
+
+void SAL_CALL SwVbaSelection::SelectColumn() throw (uno::RuntimeException)
+{
+    uno::Reference< word::XColumns > xColumns( Columns( uno::Any() ), uno::UNO_QUERY_THROW );
+    xColumns->Select();
+}
+
+uno::Any SAL_CALL SwVbaSelection::Rows( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    
+    sal_Int32 nStartRow = 0;
+    sal_Int32 nEndRow = 0;
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nStartRow = aTableHelper.getTabRowIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nEndRow = aTableHelper.getTabRowIndex( sBRName );
+    }
+    else
+    {
+        nEndRow = nStartRow;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaRows( this, mxContext, xTextTable, xTextTable->getRows(), nStartRow, nEndRow ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL SwVbaSelection::Columns( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    sal_Int32 nStartColumn = 0;
+    sal_Int32 nEndColumn = 0;
+
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nStartColumn = aTableHelper.getTabColIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nEndColumn = aTableHelper.getTabColIndex( sBRName );
+    }
+    else
+    {
+        nEndColumn = nStartColumn;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaColumns( this, mxContext, xTextTable, xTextTable->getColumns(), nStartColumn, nEndColumn ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Reference< text::XTextTable > SwVbaSelection::GetXTextTable() throw( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    return xTextTable;
+}
+
+sal_Bool SwVbaSelection::IsInTable() throw( uno::RuntimeException )
+{
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    if( xTextTable.is() )
+        return sal_True;
+    return sal_False;    
+}
+
+sal_Bool SwVbaSelection::HasSelection() throw( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xStart = mxTextViewCursor->getStart();
+    uno::Reference< text::XTextRange > xEnd = mxTextViewCursor->getEnd();
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextViewCursor->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( xStart, xEnd ) == 0 && xTRC->compareRegionEnds( xStart, xEnd ) == 0 )
+        return sal_False;
+    return sal_True;    
+}
+
+void SwVbaSelection::GetSelectedCellRange( rtl::OUString& sTLName, rtl::OUString& sBRName ) throw( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    if( !xTextTable.is() )
+        throw uno::RuntimeException( );
+
+    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( xTextTableCursor.is() )
+    {
+        String sRange( xTextTableCursor->getRangeName() );
+        if( sRange.GetTokenCount(':') > 0 )
+        {
+            sTLName = sRange.GetToken(0, ':');
+            sBRName = sRange.GetToken(1, ':');
+        }
+    }    
+    if( !sTLName.getLength() )
+    {
+        uno::Reference< table::XCell > xCell;
+        xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Cell") ) ) >>= xCell;
+        if( !xCell.is() )
+        {
+            throw uno::RuntimeException( );
+        }
+        uno::Reference< beans::XPropertySet > xCellProps( xCell, uno::UNO_QUERY_THROW );
+        xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CellName") ) ) >>= sTLName;
+    }
+}
+
+uno::Any SAL_CALL SwVbaSelection::Cells( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    sal_Int32 nLeft = 0;
+    sal_Int32 nTop = 0;
+    sal_Int32 nRight = 0;
+    sal_Int32 nBottom = 0;
+
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nLeft = aTableHelper.getTabColIndex( sTLName );
+    nTop = aTableHelper.getTabRowIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nRight = aTableHelper.getTabColIndex( sBRName );
+        nBottom = aTableHelper.getTabRowIndex( sBRName );
+    }
+    else
+    {
+        nRight = nLeft;
+        nBottom = nTop;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaCells( this, mxContext, xTextTable, nLeft, nTop, nRight, nBottom ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+void SAL_CALL SwVbaSelection::Copy(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Copy"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaSelection::CopyAsPicture(  ) throw (uno::RuntimeException)
+{
+    // seems not support in Writer
+    Copy();
+}
+
+void SAL_CALL SwVbaSelection::Paste(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Paste"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaSelection::Collapse( const uno::Any& Direction ) throw (uno::RuntimeException)
+{
+    if( word::gotoSelectedObjectAnchor( mxModel ) )
+        return;
+
+    sal_Int32 nDirection = word::WdCollapseDirection::wdCollapseStart;
+    if( Direction.hasValue() )
+        Direction >>= nDirection;
+    
+    uno::Reference< text::XTextViewCursor > xTextViewCursor = word::getXTextViewCursor( mxModel );
+    if( nDirection == word::WdCollapseDirection::wdCollapseStart )
+    {
+        // it is inaccurate if current seleciton is multipul cells, so it needs to go to start
+        uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getStart();
+        xTextViewCursor->gotoRange( xTextRange, sal_False );
+        xTextViewCursor->collapseToStart();
+    }
+    else if( nDirection == word::WdCollapseDirection::wdCollapseEnd )
+    {
+        uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getEnd();
+        xTextViewCursor->gotoRange( xTextRange, sal_False );
+        xTextViewCursor->collapseToEnd();
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+void SAL_CALL SwVbaSelection::WholeStory(  ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = word::getCurrentXText( mxModel );
+    // FIXME: for i#7747,if the first line is a table, it fails to select all the contents in the story.
+    // Temporary solution, insert an empty line before the table so that it could select all the contents.
+    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
+    if( xParaEnum->hasMoreElements() )
+    {
+        uno::Reference< text::XTextTable > xTextTable( xParaEnum->nextElement(), uno::UNO_QUERY );
+        if( xTextTable.is() )
+        {
+            // insert an empty line
+            uno::Reference< text::XTextRange > xFirstCellRange = word::getFirstObjectPosition( xText );
+            mxTextViewCursor->gotoRange( xFirstCellRange, sal_False );
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertPara"));
+            dispatchRequests( mxModel,url );
+        }
+    }
+    uno::Reference< text::XTextRange > xStart = xText->getStart();
+    uno::Reference< text::XTextRange > xEnd = xText->getEnd();
+    mxTextViewCursor->gotoRange( xStart, sal_False );
+    mxTextViewCursor->gotoRange( xEnd, sal_True );
+}
+
+::sal_Bool SAL_CALL SwVbaSelection::InRange( const uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (uno::RuntimeException)
+{
+    return getRange()->InRange( Range );
+}
+
+void SAL_CALL SwVbaSelection::SplitTable(  ) throw (uno::RuntimeException)
+{
+    if( !IsInTable() )
+        throw uno::RuntimeException();
+
+    SwDocShell* pDocShell = word::getDocShell( mxModel );
+    if( pDocShell )
+    {
+        SwFEShell* pFEShell = pDocShell->GetFEShell();
+        if( pFEShell )
+        {
+            pFEShell->SplitTable( HEADLINE_CNTNTCOPY );
+        }
+    }
+}
+
+uno::Any SAL_CALL
+SwVbaSelection::Paragraphs( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    // Hacky implementation due to missing api ( and lack of knowledge )
+    // we can only support a selection that is a single paragraph 
+    if ( !aIndex.hasValue() ) // currently we can't support multiple paragraphs in a selection
+       throw uno::RuntimeException(); 
+
+    sal_Int32 nIndex = 0;
+    aIndex >>= nIndex;
+
+    uno::Any aRet;
+
+    if ( nIndex != 1 )
+       throw uno::RuntimeException(); 
+
+    uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getStart();
+    uno::Reference< text::XText > xText = xTextRange->getText();
+    uno::Reference< text::XParagraphCursor > xParaCursor( xText->createTextCursor(), uno::UNO_QUERY_THROW );
+    xParaCursor->gotoStartOfParagraph( sal_False );
+    xParaCursor->gotoStartOfParagraph( sal_True );
+
+    uno::Reference< text::XTextDocument > xTextDoc( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xParaRange( xParaCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XParagraph > xParagraph = new SwVbaParagraph( mxParent, mxContext, xTextDoc, xParaRange );
+
+    aRet <<= xParagraph;
+    return aRet;
+}
+
 rtl::OUString& 
 SwVbaSelection::getServiceImplName()
 {
diff --git sw/source/ui/vba/vbaselection.hxx sw/source/ui/vba/vbaselection.hxx
index afbf79a..0b398cd 100644
--- sw/source/ui/vba/vbaselection.hxx
+++ sw/source/ui/vba/vbaselection.hxx
@@ -31,11 +31,13 @@
 #include <ooo/vba/word/XRange.hpp>
 #include <vbahelper/vbahelperinterface.hxx>
 #include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
 #include <ooo/vba/word/XParagraphFormat.hpp>
 #include <ooo/vba/word/XFind.hpp>
 #include <ooo/vba/word/XStyle.hpp>
 #include <ooo/vba/word/XFont.hpp>
 #include <ooo/vba/word/XHeaderFooter.hpp>
+#include "wordvbahelper.hxx"
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XSelection > SwVbaSelection_BASE;
 
@@ -46,17 +48,14 @@ private:
     css::uno::Reference< css::text::XTextViewCursor > mxTextViewCursor;
     css::uno::Reference< ooo::vba::word::XRange > mxRange;
 
-    enum E_DIRECTION
-    {
-        MOVE_LEFT = 1,
-        MOVE_RIGHT,
-        MOVE_UP,
-        MOVE_DOWN
-    };
-
 private:
-    void NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( css::uno::RuntimeException );
+    void Move( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend, ooo::vba::word::E_DIRECTION eDirection ) throw (css::uno::RuntimeException);
+    void NextCell( sal_Int32 nCount, ooo::vba::word::E_DIRECTION eDirection ) throw ( css::uno::RuntimeException );
     css::uno::Reference< css::text::XTextRange > GetSelectedRange() throw ( css::uno::RuntimeException );
+    void GetSelectedCellRange( rtl::OUString& sTLName, rtl::OUString& sBRName ) throw ( css::uno::RuntimeException );
+    css::uno::Reference< css::text::XTextTable > GetXTextTable() throw ( css::uno::RuntimeException );
+    sal_Bool IsInTable() throw ( css::uno::RuntimeException );
+    sal_Bool HasSelection() throw ( css::uno::RuntimeException );
 
 public:
     SwVbaSelection( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel ) throw ( css::uno::RuntimeException );
@@ -73,6 +72,7 @@ public:
     virtual void SAL_CALL MoveRight( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL MoveLeft( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL MoveDown( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL MoveUp( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL TypeParagraph() throw (css::uno::RuntimeException);
     virtual void SAL_CALL InsertParagraph() throw (css::uno::RuntimeException);
     virtual void SAL_CALL InsertParagraphBefore() throw (css::uno::RuntimeException);
@@ -80,8 +80,8 @@ public:
     virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFind > SAL_CALL getFind() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Any& _xStyle ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
     virtual void SAL_CALL TypeBackspace() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL GoTo( const css::uno::Any& _what, const css::uno::Any& _which, const css::uno::Any& _count, const css::uno::Any& _name ) throw (css::uno::RuntimeException);
@@ -97,6 +97,19 @@ public:
     virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SelectRow() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SelectColumn() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Rows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Columns( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Cells( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Copy(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL CopyAsPicture(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Paste(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Collapse( const css::uno::Any& Direction ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL WholeStory(  ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL InRange( const css::uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SplitTable(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Paragraphs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sw/source/ui/vba/vbastyle.cxx sw/source/ui/vba/vbastyle.cxx
index a8bb6be..984dbae 100644
--- sw/source/ui/vba/vbastyle.cxx
+++ sw/source/ui/vba/vbastyle.cxx
@@ -28,15 +28,18 @@
 #include "vbastyle.hxx"
 #include <ooo/vba/word/WdStyleType.hpp>
 #include <com/sun/star/lang/Locale.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
 #include <i18npool/mslangid.hxx>
 #include "vbafont.hxx"
 #include "vbapalette.hxx"
+#include "vbaparagraphformat.hxx"
+#include "vbastyles.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
 
-SwVbaStyle::SwVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& _xPropertySet ) throw ( script::BasicErrorException, uno::RuntimeException ) : SwVbaStyle_BASE( xParent, xContext ) , mxStyleProps( _xPropertySet )
+SwVbaStyle::SwVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel>& xModel, const uno::Reference< beans::XPropertySet >& _xPropertySet ) throw ( script::BasicErrorException, uno::RuntimeException ) : SwVbaStyle_BASE( xParent, xContext ) , mxModel( xModel ), mxStyleProps( _xPropertySet )
 {
     mxStyle.set( _xPropertySet, uno::UNO_QUERY_THROW );
 }
@@ -84,7 +87,7 @@ void SAL_CALL SwVbaStyle::setLanguageID( ::sal_Int32 _languageid ) throw (uno::R
         nType = word::WdStyleType::wdStyleTypeParagraph;
     else if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.CharacterStyle") ) ) )    
         nType = word::WdStyleType::wdStyleTypeCharacter;
-    else // if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingStyle") ) ) )    
+    else
         nType = word::WdStyleType::wdStyleTypeList;
     return nType;
 }
@@ -96,10 +99,31 @@ SwVbaStyle::getFont() throw ( uno::RuntimeException )
     return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), mxStyleProps );
 }
 
-void SwVbaStyle::setStyle( const uno::Reference< beans::XPropertySet >& xTCProps, const uno::Reference< ooo::vba::word::XStyle >& xStyle )throw (uno::RuntimeException)
+
+void SAL_CALL SwVbaStyle::LinkToListTemplate( const uno::Reference< word::XListTemplate >& /*ListTemplate*/, const uno::Any& /*ListLevelNumber*/ ) throw (uno::RuntimeException)
+{
+}
+
+void SwVbaStyle::setStyle( const uno::Reference< beans::XPropertySet >& xParaProps, const uno::Any& rStyle )throw (uno::RuntimeException)
 {
-    rtl::OUString aStyleType = getOOoStyleTypeFromMSWord( xStyle->getType() );
-    xTCProps->setPropertyValue( aStyleType, uno::makeAny( xStyle->getName() ) );
+    rtl::OUString sStyle;
+    uno::Reference< word::XStyle > xStyle;
+    if( rStyle >>= xStyle )
+    {
+        sStyle = xStyle->getName();
+    }
+    else
+    {
+        rStyle >>= sStyle;
+    }
+
+    if( sStyle.getLength() )
+    {
+        xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaStyleName") ), uno::makeAny( sStyle ) );
+        return;
+    }
+
+    throw uno::RuntimeException();
 }
 
 rtl::OUString SwVbaStyle::getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType )
@@ -129,6 +153,115 @@ rtl::OUString SwVbaStyle::getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType )
     return aStyleType;
 }
 
+::rtl::OUString SAL_CALL SwVbaStyle::getNameLocal() throw (uno::RuntimeException)
+{
+    rtl::OUString sNameLocal;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DisplayName") ) ) >>= sNameLocal;
+    return sNameLocal;
+}
+
+void SAL_CALL SwVbaStyle::setNameLocal( const ::rtl::OUString& _namelocal ) throw (uno::RuntimeException)
+{
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DisplayName") ), uno::makeAny( _namelocal ) );
+}
+
+uno::Reference< word::XParagraphFormat > SAL_CALL SwVbaStyle::getParagraphFormat() throw (uno::RuntimeException)
+{
+    if( word::WdStyleType::wdStyleTypeParagraph == getType() )
+    {
+        uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
+        return uno::Reference< word::XParagraphFormat >( new SwVbaParagraphFormat( this, mxContext, xTextDocument, mxStyleProps ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Reference< word::XParagraphFormat >();
+}
+
+::sal_Bool SAL_CALL SwVbaStyle::getAutomaticallyUpdate() throw (uno::RuntimeException)
+{
+    sal_Bool isAutoUpdate = sal_False;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoUpdate") ) ) >>= isAutoUpdate;
+    return isAutoUpdate;
+}
+
+void SAL_CALL SwVbaStyle::setAutomaticallyUpdate( ::sal_Bool _automaticallyupdate ) throw (uno::RuntimeException)
+{
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoUpdate") ), uno::makeAny( _automaticallyupdate ) );
+}
+
+uno::Any SAL_CALL SwVbaStyle::getBaseStyle() throw (uno::RuntimeException)
+{
+    // ParentStyle
+    rtl::OUString sBaseStyle;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParentStyle") ) ) >>= sBaseStyle;
+    if( sBaseStyle.getLength() > 0 )
+    {
+        uno::Reference< XCollection > xCol( new SwVbaStyles( this, mxContext, mxModel ) );
+        return xCol->Item( uno::makeAny( sBaseStyle ), uno::Any() );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Any();
+}
+
+void SAL_CALL SwVbaStyle::setBaseStyle( const uno::Any& _basestyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XStyle > xStyle;
+    _basestyle >>= xStyle;
+    if( xStyle.is() )
+    {
+        rtl::OUString sBaseStyle = xStyle->getName();
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParentStyle") ), uno::makeAny( sBaseStyle ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+uno::Any SAL_CALL SwVbaStyle::getNextParagraphStyle() throw (uno::RuntimeException)
+{
+    //FollowStyle
+    rtl::OUString sFollowStyle;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FollowStyle") ) ) >>= sFollowStyle;
+    if( sFollowStyle.getLength() > 0 )
+    {
+        uno::Reference< XCollection > xCol( new SwVbaStyles( this, mxContext, mxModel ) );
+        return xCol->Item( uno::makeAny( sFollowStyle ), uno::Any() );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Any();
+}
+
+void SAL_CALL SwVbaStyle::setNextParagraphStyle( const uno::Any& _nextparagraphstyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XStyle > xStyle;
+    _nextparagraphstyle >>= xStyle;
+    if( xStyle.is() )
+    {
+        rtl::OUString sFollowStyle = xStyle->getName();
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FollowStyle") ), uno::makeAny( sFollowStyle ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+::sal_Int32 SAL_CALL SwVbaStyle::getListLevelNumber() throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingLevel = 0;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingLevel") ) ) >>= nNumberingLevel;
+    return nNumberingLevel;
+}
+
 rtl::OUString&
 SwVbaStyle::getServiceImplName()
 {
diff --git sw/source/ui/vba/vbastyle.hxx sw/source/ui/vba/vbastyle.hxx
index bfa12e0..fdff04f 100644
--- sw/source/ui/vba/vbastyle.hxx
+++ sw/source/ui/vba/vbastyle.hxx
@@ -33,6 +33,7 @@
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/style/XStyle.hpp>
 #include <ooo/vba/word/XFont.hpp>
+#include <ooo/vba/word/XListTemplate.hpp>
 
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XStyle > SwVbaStyle_BASE;
@@ -40,13 +41,14 @@ typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XStyle > SwVbaStyle_BASE;
 class SwVbaStyle : public SwVbaStyle_BASE
 {
 private:
+	css::uno::Reference< css::frame::XModel > mxModel;
     css::uno::Reference< css::beans::XPropertySet > mxStyleProps;
     css::uno::Reference< css::style::XStyle > mxStyle;
 public:
-    SwVbaStyle( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& _xPropertySet ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
+	SwVbaStyle( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& _xPropertySet ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
     virtual ~SwVbaStyle(){}
 
-    static void setStyle( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, const css::uno::Reference< ooo::vba::word::XStyle >& xStyle ) throw (css::uno::RuntimeException);
+    static void setStyle( const css::uno::Reference< css::beans::XPropertySet >& xParaProps, const css::uno::Any& xStyle ) throw (css::uno::RuntimeException);
     static rtl::OUString getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType );
     static sal_Int32 getLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps ) throw (css::uno::RuntimeException);
     static void setLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, sal_Int32 _languageid ) throw (css::uno::RuntimeException);
@@ -58,6 +60,20 @@ public:
     virtual void SAL_CALL setLanguageID( ::sal_Int32 _languageid ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL LinkToListTemplate( const css::uno::Reference< ooo::vba::word::XListTemplate >& ListTemplate, const css::uno::Any& ListLevelNumber ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getNameLocal() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNameLocal( const ::rtl::OUString& _namelocal ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutomaticallyUpdate() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutomaticallyUpdate( ::sal_Bool _automaticallyupdate ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getBaseStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBaseStyle( const css::uno::Any& _basestyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getNextParagraphStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNextParagraphStyle( const css::uno::Any& _nextparagraphstyle ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getListLevelNumber() throw (css::uno::RuntimeException);
+
+    //XDefaultProperty
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return rtl::OUString::createFromAscii("Name"); }
 
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sw/source/ui/vba/vbastyles.cxx sw/source/ui/vba/vbastyles.cxx
index 58a88e2..99b4ef4 100644
--- sw/source/ui/vba/vbastyles.cxx
+++ sw/source/ui/vba/vbastyles.cxx
@@ -44,7 +44,7 @@ struct BuiltinStyleTable
     sal_Int32 wdStyleType;
 };
 
-const BuiltinStyleTable aBuiltinStyleTable[] =
+static const BuiltinStyleTable aBuiltinStyleTable[] =
 {
     { word::WdBuiltinStyle::wdStyleBlockQuotation, "", word::WdStyleType::wdStyleTypeParagraph },
     { word::WdBuiltinStyle::wdStyleBodyText, "Text body", word::WdStyleType::wdStyleTypeParagraph },
@@ -152,7 +152,20 @@ const BuiltinStyleTable aBuiltinStyleTable[] =
     { 0, 0, 0 }
 };
 
+struct MSOStyleNameTable
+{
+    const sal_Char* pMSOStyleName;
+    const sal_Char* pOOoStyleName;
+    const sal_Char* pOOoStyleType;
+};
+
+static const MSOStyleNameTable aMSOStyleNameTable[] =
+{
+    { "Normal", "Default", "ParagraphStyles" },
+    { 0, 0, 0 }
+};
 
+#ifdef FUTURE // seems this isn't used
 static uno::Sequence< rtl::OUString > getStyleTypes()
 {
     uno::Sequence< rtl::OUString > aRet(3);
@@ -162,41 +175,25 @@ static uno::Sequence< rtl::OUString > getStyleTypes()
     pArray[2] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") );
     return aRet;
 }
+#endif
 
 typedef ::cppu::WeakImplHelper1< container::XEnumeration > StyleEnumeration_BASE;
 typedef ::cppu::WeakImplHelper3< container::XNameAccess, container::XIndexAccess, container::XEnumerationAccess > StyleCollectionHelper_BASE;
-/*
-class StylesEnumeration : public StyleEnumeration_BASE
-{
-public:
-    StylesEnumeration( const SheetMap& sMap ) : mSheetMap( sMap ), mIt( mSheetMap.begin() ) {}
-    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
-    {
-        return ( mIt != mSheetMap.end() );
-    }
-    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-    {
-        if ( !hasMoreElements() )
-            throw container::NoSuchElementException();
-        uno::Reference< sheet::XSpreadsheet > xSheet( *mIt++ );
-        return uno::makeAny( xSheet ) ;
-    }
-};
-*/
+
 class StyleCollectionHelper : public StyleCollectionHelper_BASE
 {
 private:
     uno::Reference< frame::XModel > mxModel;
-    uno::Reference< container::XNameAccess > mxStyleFamilies;
-    uno::Reference< container::XNameContainer > mxCurrentStyleFamily;
+    uno::Reference< container::XNameAccess > mxParaStyles;
     uno::Any cachePos;
 public:
     StyleCollectionHelper( const uno::Reference< frame::XModel >& _xModel ) : mxModel( _xModel )
     {
+        // we only concern about the Paragraph styles
         uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( _xModel, uno::UNO_QUERY_THROW);
-        mxStyleFamilies = xStyleSupplier->getStyleFamilies();
+        uno::Reference< container::XNameAccess > xStyleFamilies = xStyleSupplier->getStyleFamilies();
+        mxParaStyles.set( xStyleFamilies->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") ) ), uno::UNO_QUERY_THROW  );
     }
-    uno::Reference< container::XNameContainer > getCurrentStyleFamily(){ return mxCurrentStyleFamily; }
     // XElementAccess
     virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  style::XStyle::static_type(0); }
     virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0; }
@@ -209,32 +206,42 @@ public:
     }
     virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
     {
-        uno::Sequence< rtl::OUString > sNames( getCount() );
-        rtl::OUString* pString = sNames.getArray();
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        sal_Int32 nCount = 0;
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        return mxParaStyles->getElementNames();
+    }
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+    {
+        // search in the MSOStyleName table first
+        for( const MSOStyleNameTable* pTable = aMSOStyleNameTable; pTable->pMSOStyleName != NULL; pTable++ )
         {
-            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            uno::Sequence< rtl::OUString > sElementNames = xNameAccess->getElementNames();
-            for( sal_Int32 j = 0; j < sElementNames.getLength(); j++ )
+            if( aName.equalsIgnoreAsciiCaseAscii( pTable->pMSOStyleName ) )
             {
-                pString[nCount++] = sElementNames[j];
+                //Found it
+                rtl::OUString sStyleName = rtl::OUString::createFromAscii( pTable->pOOoStyleName );
+                if( mxParaStyles->hasByName( sStyleName ) )
+                {
+                    cachePos = mxParaStyles->getByName( sStyleName );
+                    return sal_True;
+                }
+                return sal_False;
             }
         }
-        return sNames;
-    }
-    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
-    {
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+
+        if( mxParaStyles->hasByName( aName ) )
         {
-            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            if( xNameAccess->hasByName( aName ) )
+            cachePos = mxParaStyles->getByName( aName );
+            return sal_True;
+        }
+        else
+        {
+            uno::Sequence< rtl::OUString > sElementNames = mxParaStyles->getElementNames();
+            for( sal_Int32 j = 0; j < sElementNames.getLength(); j++ )
             {
-                cachePos = xNameAccess->getByName( aName );
-                mxCurrentStyleFamily.set( xNameAccess, uno::UNO_QUERY_THROW );
-                return sal_True;
+                rtl::OUString aStyleName = sElementNames[j];
+                if( aStyleName.equalsIgnoreAsciiCase( aName ) )
+                {
+                    cachePos = mxParaStyles->getByName( aStyleName );
+                    return sal_True;
+                }
             }
         }
         return sal_False;
@@ -243,41 +250,40 @@ public:
     // XIndexAccess
     virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
     { 
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        sal_Int32 nCount = 0;
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
-        {
-            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            nCount += xIndexAccess->getCount();
-        }
-        return nCount;
+        uno::Reference< container::XIndexAccess > xIndexAccess( mxParaStyles, uno::UNO_QUERY_THROW );
+        return xIndexAccess->getCount();
     }	
     virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
     {
         if ( Index < 0 || Index >= getCount() )
             throw lang::IndexOutOfBoundsException();
     
-        // FIXME: need to make a alphabetically sorted list of style names
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
-        {
-            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            sal_Int32 nCount = xIndexAccess->getCount();
-            if( Index >= nCount )
-                Index -= nCount;
-            else
-            {
-                mxCurrentStyleFamily.set( xIndexAccess, uno::UNO_QUERY_THROW );
-                return xIndexAccess->getByIndex( Index );
-            }
-        }
-        throw lang::IndexOutOfBoundsException();
+        uno::Reference< container::XIndexAccess > xIndexAccess( mxParaStyles, uno::UNO_QUERY_THROW );
+        return xIndexAccess->getByIndex( Index );
     }
     // XEnumerationAccess
     virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
     {
-        // FIXME:
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+	}
+};
+
+class StylesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaStyles* pStyles;
+	sal_Int32 nIndex;
+public:
+	StylesEnumWrapper( SwVbaStyles* _pStyles ) : pStyles( _pStyles ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pStyles->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pStyles->getCount() )
+			return pStyles->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
     }
 };
 
@@ -290,7 +296,7 @@ uno::Any
 SwVbaStyles::createCollectionObject(const uno::Any& aObject)
 {
     uno::Reference< beans::XPropertySet > xStyleProp( aObject, uno::UNO_QUERY_THROW );
-    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProp ) ) );
+    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, mxModel, xStyleProp ) ) );
 }
 
 uno::Type SAL_CALL 
@@ -302,7 +308,7 @@ SwVbaStyles::getElementType() throw (uno::RuntimeException)
 uno::Reference< container::XEnumeration > SAL_CALL 
 SwVbaStyles::createEnumeration() throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return new StylesEnumWrapper( this );
 }
 
 uno::Any SAL_CALL
@@ -319,7 +325,8 @@ SwVbaStyles::Item( const uno::Any& Index1, const uno::Any& Index2 ) throw (uno::
                 rtl::OUString aStyleName = rtl::OUString::createFromAscii( pTable->pOOoStyleName );
                 if( aStyleName.getLength() > 0 )
                 {
-                    rtl::OUString aStyleType = SwVbaStyle::getOOoStyleTypeFromMSWord( pTable->wdStyleType );
+                    //rtl::OUString aStyleType = SwVbaStyle::getOOoStyleTypeFromMSWord( pTable->wdStyleType );
+                    rtl::OUString aStyleType;
                     switch( pTable->wdStyleType )
                     {
                         case word::WdStyleType::wdStyleTypeParagraph:
@@ -335,7 +342,8 @@ SwVbaStyles::Item( const uno::Any& Index1, const uno::Any& Index2 ) throw (uno::
                         }
                         case word::WdStyleType::wdStyleTypeList:
                         {
-                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") );
+                            // should use Paragraph style and set the property "NumberingStyleName"
+                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") );
                             break;
                         }
                         default:
@@ -344,7 +352,12 @@ SwVbaStyles::Item( const uno::Any& Index1, const uno::Any& Index2 ) throw (uno::
                     uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxModel, uno::UNO_QUERY_THROW);
                     uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
                     uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
-                    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ) );
+                    // set the property "NumberingStyleName" if it is a listbullet
+                    if( pTable->wdStyleType == word::WdStyleType::wdStyleTypeList )
+                    {
+                        xStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyleName") ), uno::makeAny( aStyleName ) );
+                    }
+                    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, mxModel, xStyleProps ) ) );
                 }
                 else
                 {
diff --git sw/source/ui/vba/vbasystem.cxx sw/source/ui/vba/vbasystem.cxx
index 66e5d1f..ae42994 100644
--- sw/source/ui/vba/vbasystem.cxx
+++ sw/source/ui/vba/vbasystem.cxx
@@ -34,6 +34,13 @@
 #include <tools/urlobj.hxx>
 #include <tools/string.hxx>
 
+#ifdef WNT
+#include <tools/prewin.h>
+#include <windows.h>
+#include <tools/postwin.h>
+#include <tchar.h>
+#endif
+
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
@@ -47,13 +54,79 @@ void PrivateProfileStringListener::Initialize( const rtl::OUString& rFileName, c
     maGroupName = rGroupName;
     maKey = rKey;
 }
+#ifdef WNT
+void lcl_getRegKeyInfo( const ByteString& sKeyInfo, HKEY& hBaseKey, ByteString& sSubKey )
+{
+    sal_Int32 nBaseKeyIndex = sKeyInfo.Search('\\');
+    if( nBaseKeyIndex > 0 )
+    {
+        ByteString sBaseKey = sKeyInfo.Copy( 0, nBaseKeyIndex );
+        sSubKey = sKeyInfo.Copy( nBaseKeyIndex + 1 );        
+        if( sBaseKey.Equals("HKEY_CURRENT_USER") )
+        {
+            hBaseKey = HKEY_CURRENT_USER;
+        }
+        else if( sBaseKey.Equals("HKEY_LOCAL_MACHINE") )
+        {
+            hBaseKey = HKEY_LOCAL_MACHINE;
+        }
+        else if( sBaseKey.Equals("HKEY_CLASSES_ROOT") )
+        {
+            hBaseKey = HKEY_CLASSES_ROOT;
+        }
+        else if( sBaseKey.Equals("HKEY_USERS") )
+        {
+            hBaseKey = HKEY_USERS;
+        }
+        else if( sBaseKey.Equals("HKEY_CURRENT_CONFIG") )
+        {
+            hBaseKey = HKEY_CURRENT_CONFIG;
+        }
+    }
+}
+#endif
 
 uno::Any PrivateProfileStringListener::getValueEvent()
 {
     // get the private profile string
-    Config aCfg( maFileName );
-    aCfg.SetGroup( maGroupName );
-    rtl::OUString sValue = String( aCfg.ReadKey( maKey ), RTL_TEXTENCODING_DONTKNOW );
+    rtl::OUString sValue;
+    if(maFileName.getLength())
+    {
+        // get key/value from a file
+        Config aCfg( maFileName );
+        aCfg.SetGroup( maGroupName );
+        sValue = String( aCfg.ReadKey( maKey ), RTL_TEXTENCODING_DONTKNOW );
+    }
+    else
+    {
+        // get key/value from windows register
+#ifdef WNT
+        HKEY hBaseKey = NULL;
+        ByteString sSubKey;
+        sal_Int32 nBaseKeyIndex = maGroupName.Search('\\');
+        lcl_getRegKeyInfo( maGroupName, hBaseKey, sSubKey );
+        if( hBaseKey != NULL )
+        {
+            HKEY hKey = NULL;
+            LONG lResult;
+            LPCTSTR lpSubKey = TEXT( sSubKey.GetBuffer());
+            TCHAR szBuffer[1024];
+            DWORD cbData = sizeof( szBuffer );
+            lResult = RegOpenKeyEx( hBaseKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKey );
+            if( ERROR_SUCCESS == lResult )
+            {
+                LPCTSTR lpValueName = TEXT(maKey.GetBuffer());
+                lResult = RegQueryValueEx( hKey, lpValueName, NULL, NULL, (LPBYTE)szBuffer, &cbData );
+                RegCloseKey( hKey );
+                sValue = rtl::OUString::createFromAscii(szBuffer);
+            }
+        }
+        
+        return uno::makeAny( sValue );
+#endif
+        throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Only support on Windows")), uno::Reference< uno::XInterface >() );
+    }    
 
     return uno::makeAny( sValue );
 }
@@ -61,12 +134,44 @@ uno::Any PrivateProfileStringListener::getValueEvent()
 void PrivateProfileStringListener::setValueEvent( const css::uno::Any& value )
 {
     // set the private profile string
-    Config aCfg( maFileName );
-    aCfg.SetGroup( maGroupName );
-
     rtl::OUString aValue;
     value >>= aValue;
-    aCfg.WriteKey( maKey, ByteString( aValue.getStr(), RTL_TEXTENCODING_DONTKNOW ) );
+    if(maFileName.getLength())
+    {
+        // set value into a file
+        Config aCfg( maFileName );
+        aCfg.SetGroup( maGroupName );    
+        aCfg.WriteKey( maKey, ByteString( aValue.getStr(), RTL_TEXTENCODING_DONTKNOW ) );
+    }
+    else
+    {
+        //set value into windows register
+#ifdef WNT
+        HKEY hBaseKey = NULL;
+        ByteString sSubKey;
+        sal_Int32 nBaseKeyIndex = maGroupName.Search('\\');
+        lcl_getRegKeyInfo( maGroupName, hBaseKey, sSubKey );
+        if( hBaseKey != NULL )
+        {
+            HKEY hKey = NULL;
+            LONG lResult;
+            LPCTSTR lpSubKey = TEXT( sSubKey.GetBuffer());            
+            lResult = RegCreateKeyEx( hBaseKey, lpSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL );
+            if( ERROR_SUCCESS == lResult )
+            {
+                LPCTSTR szValue = TEXT( rtl::OUStringToOString( aValue, RTL_TEXTENCODING_UTF8 ).getStr() );
+                DWORD cbData = sizeof(TCHAR) * (_tcslen(szValue) + 1);
+                LPCTSTR lpValueName = TEXT(maKey.GetBuffer());                 
+                lResult = RegSetValueEx( hKey, lpValueName, NULL, REG_SZ, (LPBYTE)szValue, cbData );
+                RegCloseKey( hKey );
+            }
+        }
+        return;
+#endif
+        throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Not implemented")), uno::Reference< uno::XInterface >() );
+    }
+    
 }
 
 SwVbaSystem::SwVbaSystem( uno::Reference<uno::XComponentContext >& xContext ): SwVbaSystem_BASE( uno::Reference< XHelperInterface >(), xContext )
@@ -146,19 +251,19 @@ SwVbaSystem::setCursor( sal_Int32 _cursor ) throw (uno::RuntimeException)
 uno::Any SAL_CALL 
 SwVbaSystem::PrivateProfileString( const rtl::OUString& rFilename, const rtl::OUString& rSection, const rtl::OUString& rKey ) throw ( uno::RuntimeException )
 {
-    if( rFilename.getLength() == 0 )
-        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
-
     // FIXME: need to detect whether it is a relative file path
     // we need to detect if this is a URL, if not then assume its a file path
     rtl::OUString sFileUrl;
-    INetURLObject aObj;
-    aObj.SetURL( rFilename );
-    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
-    if ( bIsURL )
-        sFileUrl = rFilename;
-    else
-        osl::FileBase::getFileURLFromSystemPath( rFilename, sFileUrl);
+    if( rFilename.getLength() )
+    {
+        INetURLObject aObj;
+	    aObj.SetURL( rFilename );
+	    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+	    if ( bIsURL )
+		    sFileUrl = rFilename;
+	    else
+		    osl::FileBase::getFileURLFromSystemPath( rFilename, sFileUrl);
+    }    
 
     ByteString aGroupName = ByteString( rSection.getStr(), RTL_TEXTENCODING_DONTKNOW);
     ByteString aKey = ByteString( rKey.getStr(), RTL_TEXTENCODING_DONTKNOW);
diff --git sw/source/ui/vba/vbatable.cxx sw/source/ui/vba/vbatable.cxx
index 7598dfc..1ff9294 100644
--- sw/source/ui/vba/vbatable.cxx
+++ sw/source/ui/vba/vbatable.cxx
@@ -9,11 +9,13 @@
 #include <com/sun/star/container/XNamed.hpp>
 #include "vbaborders.hxx"
 #include "vbapalette.hxx"
+#include "vbarows.hxx"
+#include "vbacolumns.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-SwVbaTable::SwVbaTable(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const  uno::Reference< css::text::XTextTable >& xTextTable) throw ( uno::RuntimeException ) : SwVbaTable_BASE( rParent, rContext ), mxTextDocument( rDocument )
+SwVbaTable::SwVbaTable(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rDocument, const  uno::Reference< text::XTextTable >& xTextTable) throw ( uno::RuntimeException ) : SwVbaTable_BASE( rParent, rContext ), mxTextDocument( rDocument )
 {
     mxTextTable.set( xTextTable, uno::UNO_QUERY_THROW );
 }
@@ -75,6 +77,26 @@ SwVbaTable::Borders( const uno::Any& index ) throw (uno::RuntimeException)
     return uno::makeAny( xCol );
 }
 
+uno::Any SAL_CALL
+SwVbaTable::Rows( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< table::XTableRows > xTableRows( mxTextTable->getRows(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRows( this, mxContext, mxTextTable, xTableRows ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaTable::Columns( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< table::XTableColumns > xTableColumns( mxTextTable->getColumns(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaColumns( this, mxContext, mxTextTable, xTableColumns ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
 // XHelperInterface
 rtl::OUString& 
 SwVbaTable::getServiceImplName()
diff --git sw/source/ui/vba/vbatable.hxx sw/source/ui/vba/vbatable.hxx
index c28a3cd..1348c60 100644
--- sw/source/ui/vba/vbatable.hxx
+++ sw/source/ui/vba/vbatable.hxx
@@ -21,6 +21,9 @@ public:
     virtual css::uno::Reference< ::ooo::vba::word::XRange > SAL_CALL ConvertToText( const css::uno::Any& Separator, const css::uno::Any& NestedTables ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getName( ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Borders( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Rows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Columns( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
diff --git sw/source/ui/vba/vbatablehelper.cxx sw/source/ui/vba/vbatablehelper.cxx
new file mode 100644
index 0000000..c4c7413
--- /dev/null
+++ sw/source/ui/vba/vbatablehelper.cxx
@@ -0,0 +1,306 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatablehelper.hxx"
+#include <swtable.hxx>
+#include <unotbl.hxx>
+#include <docsh.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+#define UNO_TABLE_COLUMN_SUM    10000
+
+SwVbaTableHelper::SwVbaTableHelper( const uno::Reference< text::XTextTable >& xTextTable ) throw (uno::RuntimeException) : mxTextTable( xTextTable ), pDoc( NULL )
+{
+    pTable = GetSwTable( mxTextTable );
+}
+
+SwTable* SwVbaTableHelper::GetSwTable( const uno::Reference< text::XTextTable >& xTextTable ) throw (uno::RuntimeException)
+{
+	uno::Reference< lang::XUnoTunnel > xTunnel( xTextTable, uno::UNO_QUERY_THROW );
+    SwXTextTable* pXTextTable = reinterpret_cast< SwXTextTable * >( sal::static_int_cast< sal_IntPtr >(xTunnel->getSomething(SwXTextTable::getUnoTunnelId())));
+    if( !pXTextTable )
+        throw uno::RuntimeException();
+        
+    SwFrmFmt* pFrmFmt = pXTextTable->GetFrmFmt();
+    if( !pFrmFmt )
+        throw uno::RuntimeException();
+    
+    SwTable* pTable = SwTable::FindTable( pFrmFmt );
+    return pTable;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColumnsCount( sal_Int32 nRowIndex ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    if(!pTable->IsTblComplex())
+    {
+        SwTableLines& rLines = pTable->GetTabLines();
+        SwTableLine* pLine = rLines.GetObject( nRowIndex );
+        nRet = pLine->GetTabBoxes().Count();
+    }    
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColumnsMaxCount( ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    //sal_Int32 nRowCount = mxTextTable->getRows()->getCount();
+    sal_Int32 nRowCount = pTable->GetTabLines().Count();
+    for( sal_Int32 index = 0; index < nRowCount; index++ )
+    {
+        sal_Int32 nColCount = getTabColumnsCount( index );
+        if( nRet < nColCount )
+            nRet = nColCount;
+    }
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabRowIndex( const rtl::OUString& CellName ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    String sCellName(CellName);
+    SwTableBox* pBox = (SwTableBox*)pTable->GetTblBox( sCellName );
+    if( !pBox )
+        throw uno::RuntimeException();
+        
+    const SwTableLine* pLine = pBox->GetUpper();
+    const SwTableLines* pLines = pLine->GetUpper()
+                     ? &pLine->GetUpper()->GetTabLines() : &pTable->GetTabLines();
+    nRet = pLines->GetPos( pLine );
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColIndex( const rtl::OUString& CellName ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    String sCellName(CellName);
+    const SwTableBox* pBox = (SwTableBox*)pTable->GetTblBox( sCellName );
+    if( !pBox )
+        throw uno::RuntimeException();
+    const SwTableBoxes* pBoxes = &pBox->GetUpper()->GetTabBoxes();
+    nRet = pBoxes->GetPos( pBox );
+    return nRet;
+}
+
+rtl::OUString SwVbaTableHelper::getColumnStr( sal_Int32 nCol )
+{
+    const sal_Int32 coDiff = 52; // 'A'-'Z' 'a' - 'z'
+    sal_Int32 nCalc = 0;
+
+    String sRet;
+    do{
+        nCalc = nCol % coDiff;
+        if( nCalc >= 26 )
+            sRet.Insert( sal_Unicode('a' - 26 + nCalc ), 0 );
+        else    
+            sRet.Insert( sal_Unicode('A' + nCalc ), 0 );
+        
+        if( 0 == ( nCol = nCol - nCalc ) )
+            break;
+        nCol /= coDiff;
+        --nCol;
+    }while(1);
+    return sRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTableWidth( ) throw (uno::RuntimeException)
+{
+    sal_Int32 nWidth = 0;
+    sal_Bool isWidthRelatvie = sal_False; 
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsWidthRelative") ) ) >>= isWidthRelatvie;
+    if( isWidthRelatvie )
+    {
+        xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RelativeWidth") ) ) >>= nWidth;
+    }
+    else
+    {
+        xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    }
+    return nWidth;
+}
+
+void SwVbaTableHelper::setTableWidth( sal_Int32 _width ) throw (uno::RuntimeException)
+{
+    sal_Bool isWidthRelatvie = sal_False;
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsWidthRelative") ) ) >>= isWidthRelatvie;
+    if( isWidthRelatvie )
+    {
+        xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RelativeWidth") ), uno::makeAny( _width ));
+    }
+    else
+    {
+        xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( _width ) );
+    }
+}
+
+SwTableBox* SwVbaTableHelper::GetTabBox( sal_Int32 nCol, sal_Int32 nRow ) throw (css::uno::RuntimeException)
+{
+    SwTableLines& rLines = pTable->GetTabLines();
+    sal_Int32 nRowCount = rLines.Count();
+    if( nRowCount < nRow )
+        throw uno::RuntimeException();
+
+    SwTableBox* pStart = NULL;
+    SwTableLine* pLine = rLines.GetObject( nRow );
+    if( pLine->GetTabBoxes().Count() < nCol )
+        throw uno::RuntimeException();
+        
+    pStart = pLine->GetTabBoxes()[ nCol ];
+
+    if( !pStart )
+        throw uno::RuntimeException();
+    
+    return pStart;
+}
+
+void SwVbaTableHelper::InitTabCols( SwTabCols& rCols, const SwTableBox *pStart, BOOL /*bCurRowOnly*/ )
+{
+	rCols.SetLeftMin ( 0 );
+	rCols.SetLeft    ( 0 );
+	rCols.SetRight   ( UNO_TABLE_COLUMN_SUM );
+	rCols.SetRightMax( UNO_TABLE_COLUMN_SUM );
+
+    //if( !pDoc )
+   // {
+     //   pDoc = word::getDocShell( getCurrentDocument() )->GetDoc();
+   // }
+	pTable->GetTabCols( rCols, pStart, sal_False, sal_False );
+}
+
+sal_Int32 SwVbaTableHelper::GetColCount( SwTabCols& rCols ) const
+{
+	sal_Int32 nCount = 0;
+    for(sal_Int32 i = 0; i < rCols.Count(); i++ )
+		if(rCols.IsHidden(i))
+			nCount ++;
+	return rCols.Count() - nCount;
+}
+
+sal_Int32 SwVbaTableHelper::GetRightSeparator( SwTabCols& rCols, sal_Int32 nNum) const
+{
+	DBG_ASSERT( nNum < (sal_Int32)GetColCount( rCols ) ,"Index out of range");
+	sal_Int32 i = 0;
+	while( nNum >= 0 )
+	{
+        if( !rCols.IsHidden( static_cast< USHORT >(i)) )
+			nNum--;
+		i++;
+	}
+	return i - 1;
+}
+
+sal_Int32 SwVbaTableHelper::GetColWidth( sal_Int32 nCol, sal_Int32 nRow, sal_Bool bCurRowOnly ) throw (uno::RuntimeException)
+{
+    SwTableBox* pStart = GetTabBox( nCol, nRow );
+	SwTabCols aCols;
+    InitTabCols( aCols, pStart, bCurRowOnly );
+    sal_Int32 nWidth = GetColWidth( aCols, nCol );
+
+    sal_Int32 nTableWidth = getTableWidth( );
+    double dAbsWidth = ( (double)nWidth / UNO_TABLE_COLUMN_SUM ) * (double) nTableWidth;
+    return ( sal_Int32 )Millimeter::getInPoints( dAbsWidth );
+}
+
+sal_Int32 SwVbaTableHelper::GetColWidth( SwTabCols& rCols, sal_Int32 nNum ) throw (uno::RuntimeException)
+{
+	SwTwips nWidth = 0;
+
+	if( rCols.Count() > 0 )
+	{
+		if(rCols.Count() == GetColCount( rCols ))
+		{
+			nWidth = (SwTwips)((nNum == rCols.Count()) ?
+					rCols.GetRight() - rCols[nNum-1] :
+					nNum == 0 ? rCols[nNum] - rCols.GetLeft() :
+								rCols[nNum] - rCols[nNum-1]);
+		}
+		else
+		{
+			SwTwips nRValid = nNum < GetColCount( rCols ) ?
+							rCols[(USHORT)GetRightSeparator( rCols, nNum)]:
+									rCols.GetRight();
+			SwTwips nLValid = nNum ?
+							rCols[(USHORT)GetRightSeparator( rCols, nNum - 1)]:
+									rCols.GetLeft();
+			nWidth = nRValid - nLValid;
+		}
+	}
+	else
+		nWidth = rCols.GetRight();
+
+	return nWidth;
+}
+
+void SwVbaTableHelper::SetColWidth( sal_Int32 _width, sal_Int32 nCol, sal_Int32 nRow, sal_Bool bCurRowOnly ) throw (css::uno::RuntimeException)
+{
+    double dAbsWidth = Millimeter::getInHundredthsOfOneMillimeter( _width );
+    sal_Int32 nTableWidth = getTableWidth( );
+    sal_Int32 nNewWidth = (sal_Int32)( dAbsWidth/nTableWidth * UNO_TABLE_COLUMN_SUM );
+
+    SwTableBox* pStart = GetTabBox( nCol, nRow );
+	SwTabCols aOldCols;
+    InitTabCols( aOldCols, pStart, bCurRowOnly );
+
+	//BOOL bCurRowOnly = FALSE;
+	SwTwips nWidth = 0;
+
+    SwTabCols aCols( aOldCols );
+	if ( aCols.Count() > 0 )
+	{
+	//	if(aCols.Count() != GetColCount( aCols ))
+	//		bCurRowOnly = TRUE;
+		nWidth = GetColWidth( aCols, nCol);
+
+		int nDiff = (int)(nNewWidth - nWidth);
+		if( !nCol )
+            aCols[ static_cast< USHORT >(GetRightSeparator(aCols, 0)) ] += nDiff;
+		else if( nCol < GetColCount( aCols )  )
+		{
+			if(nDiff < GetColWidth( aCols, nCol + 1) - MINLAY)
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol)) ] += nDiff;
+			else
+			{
+				int nDiffLeft = nDiff - (int)GetColWidth( aCols, nCol + 1) + (int)MINLAY;
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol)) ] += (nDiff - nDiffLeft);
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol - 1)) ] -= nDiffLeft;
+			}
+		}
+		else
+            aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol-1)) ] -= nDiff;
+	}
+	else
+		aCols.SetRight( Min( (long)nNewWidth, aCols.GetRightMax()) );
+
+    //pDoc->SetTabCols(*pTable, aCols, aOldCols, pStartBox, bCurRowOnly );
+    pTable->SetTabCols(aCols, aOldCols, pStart, bCurRowOnly );
+}
diff --git sw/source/ui/vba/vbatablehelper.hxx sw/source/ui/vba/vbatablehelper.hxx
new file mode 100644
index 0000000..73425d4
--- /dev/null
+++ sw/source/ui/vba/vbatablehelper.hxx
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_WORD_VBA_TABLEHELPER_HXX
+#define SW_WORD_VBA_TABLEHELPER_HXX
+
+#include <com/sun/star/text/XTextTable.hpp>
+#include "wordvbahelper.hxx"
+#include <swtable.hxx>
+#include <tabcol.hxx>
+#include <doc.hxx>
+
+class SwVbaTableHelper 
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    SwTable* pTable;
+    SwDoc* pDoc;
+
+private:
+    SwTableBox* GetTabBox( sal_Int32 nCol, sal_Int32 nRow ) throw (css::uno::RuntimeException);
+	void    InitTabCols( SwTabCols& rCols, const SwTableBox *pStart, sal_Bool bCurRowOnly  = FALSE );
+    sal_Int32 GetRightSeparator( SwTabCols& rCols, sal_Int32 nNum) const;
+	sal_Int32 GetColCount( SwTabCols& rCols ) const;
+    sal_Int32 GetColWidth( SwTabCols& rCols, sal_Int32 nNum ) throw (css::uno::RuntimeException);
+    
+public:
+    SwVbaTableHelper( const css::uno::Reference< css::text::XTextTable >& xTextTable ) throw (css::uno::RuntimeException);
+    ~SwVbaTableHelper() {}
+    sal_Int32 getTabColumnsCount( sal_Int32 nRowIndex ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabColumnsMaxCount( ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabRowIndex( const rtl::OUString& sCellName ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabColIndex( const rtl::OUString& sCellName ) throw (css::uno::RuntimeException);
+    sal_Int32 getTableWidth( ) throw (css::uno::RuntimeException);
+    void  setTableWidth( sal_Int32 _width ) throw (css::uno::RuntimeException);
+
+    sal_Int32 GetColWidth( sal_Int32 nCol, sal_Int32 nRow = 0, sal_Bool bCurRowOnly  = FALSE ) throw (css::uno::RuntimeException);
+    void SetColWidth( sal_Int32 _width, sal_Int32 nCol, sal_Int32 nRow = 0, sal_Bool bCurRowOnly  = FALSE ) throw (css::uno::RuntimeException);
+
+    static SwTable* GetSwTable( const css::uno::Reference< css::text::XTextTable >& xTextTable ) throw (css::uno::RuntimeException);
+    static rtl::OUString getColumnStr( sal_Int32 nCol );
+};
+
+#endif
diff --git sw/source/ui/vba/vbatableofcontents.cxx sw/source/ui/vba/vbatableofcontents.cxx
new file mode 100644
index 0000000..1c37e96
--- /dev/null
+++ sw/source/ui/vba/vbatableofcontents.cxx
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatableofcontents.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdTabLeader.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTableOfContents::SwVbaTableOfContents( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xDoc, const uno::Reference< text::XDocumentIndex >& xDocumentIndex ) throw ( uno::RuntimeException ) :
+    SwVbaTableOfContents_BASE( rParent, rContext ), mxTextDocument( xDoc ), mxDocumentIndex( xDocumentIndex )
+{
+    mxTocProps.set( mxDocumentIndex, uno::UNO_QUERY_THROW );
+}
+
+
+SwVbaTableOfContents::~SwVbaTableOfContents()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaTableOfContents::getLowerHeadingLevel() throw (uno::RuntimeException)
+{
+    sal_Int16 nLevel = 0;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Level") ) ) >>= nLevel;
+    return nLevel;
+}
+
+void SAL_CALL SwVbaTableOfContents::setLowerHeadingLevel( ::sal_Int32 _lowerheadinglevel ) throw (uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Level") ), uno::makeAny( sal_Int8( _lowerheadinglevel ) ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaTableOfContents::getTabLeader() throw (uno::RuntimeException)
+{
+    // not support in Writer
+    return word::WdTabLeader::wdTabLeaderDots;
+}
+
+void SAL_CALL SwVbaTableOfContents::setTabLeader( ::sal_Int32 /*_tableader*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaTableOfContents::getUseFields() throw (css::uno::RuntimeException)
+{
+    sal_Bool bUseFields = sal_False;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromMarks") ) ) >>= bUseFields;
+    return bUseFields;
+}
+
+void SAL_CALL SwVbaTableOfContents::setUseFields( ::sal_Bool _useFields ) throw (css::uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromMarks") ), uno::makeAny( _useFields ) );
+}
+
+::sal_Bool SAL_CALL SwVbaTableOfContents::getUseOutlineLevels() throw (css::uno::RuntimeException)
+{
+    sal_Bool bUseOutlineLevels = sal_False;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromOutline") ) ) >>= bUseOutlineLevels;
+    return bUseOutlineLevels;
+}
+
+void SAL_CALL SwVbaTableOfContents::setUseOutlineLevels( ::sal_Bool _useOutlineLevels ) throw (css::uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromOutline") ), uno::makeAny( _useOutlineLevels ) );
+}
+
+void SAL_CALL SwVbaTableOfContents::Delete(  ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextContent > xTextContent( mxDocumentIndex, uno::UNO_QUERY_THROW );
+    mxTextDocument->getText()->removeTextContent( xTextContent );
+}
+
+void SAL_CALL SwVbaTableOfContents::Update(  ) throw (uno::RuntimeException)
+{
+    mxDocumentIndex->update();
+}
+
+rtl::OUString& 
+SwVbaTableOfContents::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTableOfContents") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaTableOfContents::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TableOfContents" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbatableofcontents.hxx sw/source/ui/vba/vbatableofcontents.hxx
new file mode 100644
index 0000000..8e9394a
--- /dev/null
+++ sw/source/ui/vba/vbatableofcontents.hxx
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABLEOFCONTENTS_HXX
+#define SW_VBA_TABLEOFCONTENTS_HXX
+
+#include <ooo/vba/word/XTableOfContents.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XDocumentIndex.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTableOfContents > SwVbaTableOfContents_BASE;
+
+class SwVbaTableOfContents : public SwVbaTableOfContents_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XDocumentIndex > mxDocumentIndex;
+    css::uno::Reference< css::beans::XPropertySet > mxTocProps;
+
+public:
+	SwVbaTableOfContents( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xDoc, const css::uno::Reference< css::text::XDocumentIndex >& xDocumentIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTableOfContents();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getLowerHeadingLevel() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLowerHeadingLevel( ::sal_Int32 _lowerheadinglevel ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getTabLeader() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTabLeader( ::sal_Int32 _tableader ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUseFields() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUseFields( ::sal_Bool _useFields ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUseOutlineLevels() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUseOutlineLevels( ::sal_Bool _useOutlineLevels ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Update(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_TABLEOFCONTENTS_HXX */
diff --git sw/source/ui/vba/vbatables.cxx sw/source/ui/vba/vbatables.cxx
index 53178d1..7423216 100644
--- sw/source/ui/vba/vbatables.cxx
+++ sw/source/ui/vba/vbatables.cxx
@@ -4,6 +4,9 @@
 #include <com/sun/star/text/XTextTable.hpp>
 #include <com/sun/star/text/XTextTablesSupplier.hpp>
 #include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
 #include <comphelper/componentcontext.hxx>
 
 using namespace ::ooo::vba;
@@ -26,7 +29,89 @@ uno::Any lcl_createTable( const uno::Reference< XHelperInterface >& xParent, con
     return uno::makeAny( xTable );
 }
 
+sal_Bool lcl_isInHeaderFooter( const uno::Reference< text::XTextTable >& xTable )
+{
+    uno::Reference< text::XTextContent > xTextContent( xTable, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XText > xText = xTextContent->getAnchor()->getText();
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xText, uno::UNO_QUERY_THROW );
+    rtl::OUString aImplName = xServiceInfo->getImplementationName();
+    if( aImplName.equalsAscii("SwXHeadFootText") )
+        return sal_True;
+    return sal_False;    
+}
+
 typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumBase;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XNameAccess > TableCollectionHelper_Base;
+typedef std::vector< uno::Reference< text::XTextTable > > XTextTableVec;
+
+class TableCollectionHelper : public TableCollectionHelper_Base
+{
+    XTextTableVec mxTables;
+    XTextTableVec::iterator cachePos;
+
+public:
+    TableCollectionHelper( const uno::Reference< frame::XModel >& xDocument )
+    {
+        // only count the tables in the body text, not in the header/footer
+        uno::Reference< container::XIndexAccess > xTables = lcl_getTables( xDocument );
+        sal_Int32 nCount = xTables->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XTextTable > xTable( xTables->getByIndex( i ) , uno::UNO_QUERY_THROW );
+            if( !lcl_isInHeaderFooter( xTable ) )
+                mxTables.push_back( xTable );
+        }
+        cachePos = mxTables.begin();
+    }
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxTables.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )
+            throw lang::IndexOutOfBoundsException();
+        uno::Reference< text::XTextTable > xTable( mxTables[ Index ], uno::UNO_QUERY_THROW );
+        return uno::makeAny( xTable );
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  text::XTextTable::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0 ; }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+        uno::Reference< text::XTextTable > xTable( *cachePos, uno::UNO_QUERY_THROW );
+        return uno::makeAny( xTable );
+    }
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+        uno::Sequence< rtl::OUString > sNames( mxTables.size() );
+        rtl::OUString* pString = sNames.getArray();
+        XTextTableVec::iterator it = mxTables.begin();
+        XTextTableVec::iterator it_end = mxTables.end();
+        for ( ; it != it_end; ++it, ++pString )
+        {
+            uno::Reference< container::XNamed > xName( *it, uno::UNO_QUERY_THROW );
+            *pString = xName->getName();
+        }
+        return sNames;
+    }
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        cachePos = mxTables.begin();
+        XTextTableVec::iterator it_end = mxTables.end();
+        for ( ; cachePos != it_end; ++cachePos )
+        {
+            uno::Reference< container::XNamed > xName( *cachePos, uno::UNO_QUERY_THROW );
+            if ( aName.equalsIgnoreAsciiCase( xName->getName() ) )
+                break;
+        }
+        return ( cachePos != it_end );
+    }
+};
 
 class TableEnumerationImpl : public EnumBase
 {
@@ -52,7 +137,7 @@ public:
     
 };
  
-SwVbaTables::SwVbaTables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument ) : SwVbaTables_BASE( xParent, xContext , lcl_getTables( xDocument ) ), mxDocument( xDocument )
+SwVbaTables::SwVbaTables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument ) : SwVbaTables_BASE( xParent, xContext , uno::Reference< container::XIndexAccess >( new TableCollectionHelper( xDocument ) ) ), mxDocument( xDocument )
 {
 }
 
@@ -85,6 +170,12 @@ SwVbaTables::Add( const uno::Reference< word::XRange >& Range, const uno::Any& N
     uno::Reference< text::XTextContent > xContext( xTable, uno::UNO_QUERY_THROW );     
     
     xText->insertTextContent( xTextRange, xContext, true );
+
+	// move the current cursor to the first table cell
+	uno::Reference< table::XCellRange > xCellRange( xTable, uno::UNO_QUERY_THROW );
+	uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	word::getXTextViewCursor( mxDocument )->gotoRange( xFirstCellText->getStart(), sal_False ); 
+    
     uno::Reference< word::XTable > xVBATable( new SwVbaTable( mxParent, mxContext,  pVbaRange->getDocument(), xTable ) );
     return xVBATable;
 }
diff --git sw/source/ui/vba/vbatablesofcontents.cxx sw/source/ui/vba/vbatablesofcontents.cxx
new file mode 100644
index 0000000..020f19c
--- /dev/null
+++ sw/source/ui/vba/vbatablesofcontents.cxx
@@ -0,0 +1,197 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatablesofcontents.hxx"
+#include "vbatableofcontents.hxx"
+#include "vbarange.hxx"
+#include <com/sun/star/text/XDocumentIndexesSupplier.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > TableOfContentsCollectionHelper_Base;
+typedef std::vector< uno::Reference< text::XDocumentIndex > > XTocVec;
+
+class TablesOfContentsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	TablesOfContentsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class TableOfContentsCollectionHelper : public TableOfContentsCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< text::XTextDocument > mxTextDocument;
+    XTocVec maToc;
+
+public:
+	TableOfContentsCollectionHelper( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xDoc ) throw ( uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxTextDocument( xDoc )
+    {
+        uno::Reference< text::XDocumentIndexesSupplier > xDocIndexSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xDocIndexes = xDocIndexSupp->getDocumentIndexes();
+        sal_Int32 nCount = xDocIndexes->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XDocumentIndex > xToc( xDocIndexes->getByIndex(i), uno::UNO_QUERY_THROW );
+            if( xToc->getServiceName().equalsAscii("com.sun.star.text.ContentIndex") )
+            {
+                maToc.push_back( xToc );
+            }
+        }
+    }
+
+	virtual ~TableOfContentsCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return maToc.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw lang::IndexOutOfBoundsException();
+        
+        uno::Reference< text::XDocumentIndex > xToc( maToc[Index], uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< word::XTableOfContents >( new SwVbaTableOfContents( mxParent, mxContext, mxTextDocument, xToc ) ) );
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XTableOfContents::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new TablesOfContentsEnumWrapper( this );
+    }
+};
+
+SwVbaTablesOfContents::SwVbaTablesOfContents( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xDoc ) throw (uno::RuntimeException) : SwVbaTablesOfContents_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new TableOfContentsCollectionHelper( xParent, xContext, xDoc ) ) ),  mxTextDocument( xDoc )
+{
+}
+
+uno::Reference< word::XTableOfContents > SAL_CALL 
+SwVbaTablesOfContents::Add( const uno::Reference< word::XRange >& Range, const uno::Any& /*UseHeadingStyles*/, const uno::Any& /*UpperHeadingLevel*/, const uno::Any& LowerHeadingLevel, const uno::Any& UseFields, const uno::Any& /*TableID*/, const uno::Any& /*RightAlignPageNumbers*/, const uno::Any& /*IncludePageNumbers*/, const uno::Any& /*AddedStyles*/, const uno::Any& /*UseHyperlinks*/, const uno::Any& /*HidePageNumbersInWeb*/, const uno::Any& /*UseOutlineLevels*/ ) throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XDocumentIndex > xDocumentIndex( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.ContentIndex")) ), uno::UNO_QUERY_THROW );
+
+    uno::Reference< beans::XPropertySet > xTocProps( xDocumentIndex, uno::UNO_QUERY_THROW );
+    sal_Bool isProtected = sal_False;
+    xTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsProtected") ), uno::makeAny( isProtected ) );
+
+    uno::Reference< word::XTableOfContents > xToc( new SwVbaTableOfContents( this, mxContext, mxTextDocument, xDocumentIndex ) );
+    
+    sal_Int32 nLowerHeadingLevel = 9;
+    if( LowerHeadingLevel.hasValue() )
+        LowerHeadingLevel >>= nLowerHeadingLevel;
+    xToc->setLowerHeadingLevel( nLowerHeadingLevel );
+
+    sal_Bool bUseFields = sal_False;
+    if( UseFields.hasValue() )
+        UseFields >>= bUseFields;
+    xToc->setUseFields( bUseFields );
+
+    sal_Bool bUseOutlineLevels = sal_True;
+    //if( UseOutlineLevels.hasValue() )
+    //    UseOutlineLevels >>= bUseOutlineLevels;
+    xToc->setUseOutlineLevels( bUseOutlineLevels );
+
+    SwVbaRange* pVbaRange = dynamic_cast<SwVbaRange*>( Range.get() );
+    if( !pVbaRange )
+        throw uno::RuntimeException();
+    
+    uno::Reference< text::XTextRange > xTextRange = pVbaRange->getXTextRange();
+    uno::Reference< text::XText > xText = pVbaRange->getXText();
+    uno::Reference< text::XTextContent > xTextContent( xDocumentIndex, uno::UNO_QUERY_THROW );
+    xText->insertTextContent( xTextRange, xTextContent, sal_False );
+    xToc->Update();
+
+    return xToc;
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaTablesOfContents::getElementType() throw (uno::RuntimeException)
+{
+	return word::XTableOfContents::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaTablesOfContents::createEnumeration() throw (uno::RuntimeException)
+{
+    return new TablesOfContentsEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaTablesOfContents::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaTablesOfContents::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTablesOfContents") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaTablesOfContents::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TablesOfContents") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbatablesofcontents.hxx sw/source/ui/vba/vbatablesofcontents.hxx
new file mode 100644
index 0000000..e193df7
--- /dev/null
+++ sw/source/ui/vba/vbatablesofcontents.hxx
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABLESOFCONTENTS_HXX
+#define SW_VBA_TABLESOFCONTENTS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XTablesOfContents.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <ooo/vba/word/XTableOfContents.hpp>
+#include <ooo/vba/word/XRange.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XTablesOfContents > SwVbaTablesOfContents_BASE;
+
+class SwVbaTablesOfContents : public SwVbaTablesOfContents_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+
+public:
+	SwVbaTablesOfContents( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xDoc ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTablesOfContents() {}
+
+    // Methods
+    virtual css::uno::Reference< ::ooo::vba::word::XTableOfContents > SAL_CALL Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range, const css::uno::Any& UseHeadingStyles, const css::uno::Any& UpperHeadingLevel, const css::uno::Any& LowerHeadingLevel, const css::uno::Any& UseFields, const css::uno::Any& TableID, const css::uno::Any& RightAlignPageNumbers, const css::uno::Any& IncludePageNumbers, const css::uno::Any& AddedStyles, const css::uno::Any& UseHyperlinks, const css::uno::Any& HidePageNumbersInWeb, const css::uno::Any& UseOutlineLevels ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaTablesOfContents_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_TABLESOFCONTENTS_HXX */
diff --git sw/source/ui/vba/vbatabstop.cxx sw/source/ui/vba/vbatabstop.cxx
new file mode 100644
index 0000000..259c508
--- /dev/null
+++ sw/source/ui/vba/vbatabstop.cxx
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatabstop.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTabStop::SwVbaTabStop( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< beans::XPropertySet >& xParaProps, const style::TabStop& aTabStop ) throw ( uno::RuntimeException ) : SwVbaTabStop_BASE( rParent, rContext ), mxParaProps( xParaProps ), maTabStop( aTabStop )
+{
+}
+
+SwVbaTabStop::~SwVbaTabStop()
+{
+}
+
+rtl::OUString& 
+SwVbaTabStop::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTabStop") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaTabStop::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TabStop" ) );
+	}
+	return aServiceNames;
+}
+
diff --git sw/source/ui/vba/vbatabstop.hxx sw/source/ui/vba/vbatabstop.hxx
new file mode 100644
index 0000000..77780c7
--- /dev/null
+++ sw/source/ui/vba/vbatabstop.hxx
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABSTOP_HXX
+#define SW_VBA_TABSTOP_HXX
+
+#include <ooo/vba/word/XTabStop.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/style/TabStop.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTabStop > SwVbaTabStop_BASE;
+
+class SwVbaTabStop : public SwVbaTabStop_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertySet > mxParaProps;
+    css::style::TabStop maTabStop;
+
+public:
+	SwVbaTabStop( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps, const css::style::TabStop& aTabStop ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTabStop();
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_TABSTOP_HXX */
diff --git sw/source/ui/vba/vbatabstops.cxx sw/source/ui/vba/vbatabstops.cxx
new file mode 100644
index 0000000..8d19875
--- /dev/null
+++ sw/source/ui/vba/vbatabstops.cxx
@@ -0,0 +1,280 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatabstops.hxx"
+#include "vbatabstop.hxx"
+#include <com/sun/star/style/TabAlign.hpp>
+#include <ooo/vba/word/WdTabLeader.hpp>
+#include <ooo/vba/word/WdTabAlignment.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+uno::Sequence< style::TabStop > lcl_getTabStops( const uno::Reference< beans::XPropertySet >& xParaProps ) throw (uno::RuntimeException)
+{
+    uno::Sequence< style::TabStop > aSeq;
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTabStops") ) ) >>= aSeq;
+    return aSeq;
+}
+
+void lcl_setTabStops( const uno::Reference< beans::XPropertySet >& xParaProps, const uno::Sequence< style::TabStop >& aSeq ) throw (uno::RuntimeException)
+{
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTabStops") ), uno::makeAny( aSeq ) );
+}
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > TabStopCollectionHelper_Base;
+
+class TabStopsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	TabStopsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class TabStopCollectionHelper : public TabStopCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< beans::XPropertySet > mxParaProps;
+    uno::Sequence< style::TabStop > maTabStops;
+
+public:
+	TabStopCollectionHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps ) throw ( css::uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxParaProps( xParaProps )
+    {
+        maTabStops = lcl_getTabStops( xParaProps );
+    }
+
+	virtual ~TabStopCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return maTabStops.getLength();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw css::lang::IndexOutOfBoundsException();
+        
+        const style::TabStop* pTabs = maTabStops.getConstArray();
+        return uno::makeAny( uno::Reference< word::XTabStop >( new SwVbaTabStop( mxParent, mxContext, mxParaProps, pTabs[ Index ] ) ) );
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XTabStop::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new TabStopsEnumWrapper( this );
+    }
+};
+
+SwVbaTabStops::SwVbaTabStops( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& xParaProps ) throw (uno::RuntimeException) : SwVbaTabStops_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new TabStopCollectionHelper( xParent, xContext, xParaProps ) ) ), mxParaProps( xParaProps ) 
+{
+}
+
+uno::Reference< word::XTabStop > SAL_CALL SwVbaTabStops::Add( float Position, const uno::Any& Alignment, const uno::Any& Leader ) throw (uno::RuntimeException)
+{
+    sal_Int32 nPosition = Millimeter::getInHundredthsOfOneMillimeter( Position );
+
+    style::TabAlign nAlign = style::TabAlign_LEFT;
+    if( Alignment.hasValue() )
+    {
+        sal_Int32 wdAlign = word::WdTabAlignment::wdAlignTabLeft;
+        Alignment >>= wdAlign;
+        switch( wdAlign )
+        {
+            case word::WdTabAlignment::wdAlignTabLeft:
+            {
+                nAlign = style::TabAlign_LEFT;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabRight:
+            {
+                nAlign = style::TabAlign_RIGHT;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabCenter:
+            {
+                nAlign = style::TabAlign_CENTER;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabDecimal:
+            {
+                nAlign = style::TabAlign_DECIMAL;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabBar:
+            case word::WdTabAlignment::wdAlignTabList:
+            {
+                DebugHelper::exception( SbERR_NOT_IMPLEMENTED, rtl::OUString() );
+                break;
+            }
+            default:
+            {
+                //left
+            }
+        }
+    }
+
+    sal_Char cLeader = ' '; // default is space
+    if( Leader.hasValue() )
+    {
+        sal_Int32 wdLeader = word::WdTabLeader::wdTabLeaderSpaces;
+        Leader >>= wdLeader;
+        switch( wdLeader )
+        {
+            case word::WdTabLeader::wdTabLeaderSpaces:
+            {
+                cLeader = ' ';
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderMiddleDot:
+            {
+                cLeader = 183;
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderDots:
+            {
+                cLeader = '.';
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderDashes:
+            case word::WdTabLeader::wdTabLeaderHeavy:
+            case word::WdTabLeader::wdTabLeaderLines:
+            {
+                cLeader = '_';
+                break;
+            }
+            default:
+            {
+                //left
+            }
+        }
+    }
+
+    sal_Char cDecimal = '.'; // default value
+
+    style::TabStop aTab;
+    aTab.Position = nPosition;
+    aTab.Alignment = nAlign;
+    aTab.DecimalChar = cDecimal;
+    aTab.FillChar = cLeader;
+
+    uno::Sequence< style::TabStop > aOldTabs = lcl_getTabStops( mxParaProps );
+    sal_Bool bOverWriter = sal_False;
+
+    sal_Int32 nTabs = aOldTabs.getLength();
+    uno::Sequence< style::TabStop > aNewTabs( nTabs + 1 );
+
+    style::TabStop* pOldTab = aOldTabs.getArray();
+    style::TabStop* pNewTab = aNewTabs.getArray();
+    pNewTab[0] = aTab;
+    for( sal_Int32 nIndex = 0; nIndex < nTabs && !bOverWriter; nIndex++ )
+    {
+        if( pOldTab[nIndex].Position == nPosition )
+        {
+            bOverWriter = sal_True;
+            pOldTab[nIndex] = aTab;
+            break;
+        }
+        pNewTab[ nIndex+1 ] = pOldTab[ nIndex ];
+    }
+    if( bOverWriter )
+        lcl_setTabStops( mxParaProps, aOldTabs );
+    else    
+        lcl_setTabStops( mxParaProps, aNewTabs );
+    
+    return uno::Reference< word::XTabStop >( new SwVbaTabStop( this, mxContext, mxParaProps, aTab ) );
+}
+
+void SAL_CALL SwVbaTabStops::ClearAll() throw (uno::RuntimeException)
+{
+    uno::Sequence< style::TabStop > aSeq;
+    lcl_setTabStops( mxParaProps, aSeq );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaTabStops::getElementType() throw (uno::RuntimeException)
+{
+	return word::XTabStop::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaTabStops::createEnumeration() throw (uno::RuntimeException)
+{
+    return new TabStopsEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaTabStops::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaTabStops::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTabStops") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaTabStops::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TabStops") );
+	}
+	return sNames;
+}
diff --git sw/source/ui/vba/vbatabstops.hxx sw/source/ui/vba/vbatabstops.hxx
new file mode 100644
index 0000000..913e12b
--- /dev/null
+++ sw/source/ui/vba/vbatabstops.hxx
@@ -0,0 +1,65 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABSTOPS_HXX
+#define SW_VBA_TABSTOPS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XTabStops.hpp>
+#include <ooo/vba/word/XTabStop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XTabStops > SwVbaTabStops_BASE;
+
+class SwVbaTabStops : public SwVbaTabStops_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertySet > mxParaProps;
+
+public:
+	SwVbaTabStops( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTabStops() {}
+
+    // Methods
+    virtual css::uno::Reference< ::ooo::vba::word::XTabStop > SAL_CALL Add( float Position, const css::uno::Any& Alignment, const css::uno::Any& Leader ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ClearAll(  ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaTabStops_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_TABSTOPS_HXX */
diff --git sw/source/ui/vba/vbatemplate.cxx sw/source/ui/vba/vbatemplate.cxx
index 71dc7ac..31b7ed7 100644
--- sw/source/ui/vba/vbatemplate.cxx
+++ sw/source/ui/vba/vbatemplate.cxx
@@ -30,12 +30,35 @@
 #include "vbaautotextentry.hxx"
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/text/XAutoTextContainer.hpp>
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-SwVbaTemplate::SwVbaTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rName )
-    : SwVbaTemplate_BASE( rParent, rContext ), mxModel( rModel ), msName( rName )
+String lcl_CheckGroupName( const String& rGroupName )
+{
+    String sRet;
+    //group name should contain only A-Z and a-z and spaces
+    for( xub_StrLen i = 0; i < rGroupName.Len(); i++ )
+    {
+        sal_Unicode cChar = rGroupName.GetChar(i);
+        if(	(cChar >= 'A' && cChar <= 'Z') ||
+            (cChar >= 'a' && cChar <= 'z') ||
+            (cChar >= '0' && cChar <= '9') ||
+            cChar == '_' || cChar == 0x20 )
+        {
+            sRet += cChar;
+        }
+    }
+    sRet.EraseLeadingChars();
+    sRet.EraseTrailingChars();
+	return sRet;
+}
+
+
+SwVbaTemplate::SwVbaTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rFullUrl )
+    : SwVbaTemplate_BASE( rParent, rContext ), mxModel( rModel ), msFullUrl( rFullUrl )
 {
 }
 
@@ -47,7 +70,27 @@ SwVbaTemplate::~SwVbaTemplate()
 rtl::OUString
 SwVbaTemplate::getName() throw ( css::uno::RuntimeException )
 {
-    return msName;
+    rtl::OUString sName;
+    if( msFullUrl.getLength() )
+    {
+        INetURLObject aURL( msFullUrl );
+        ::osl::File::getSystemPathFromFileURL( aURL.GetLastName(), sName );
+    }
+    return sName;
+}
+
+rtl::OUString
+SwVbaTemplate::getPath() throw ( css::uno::RuntimeException )
+{
+    rtl::OUString sPath;
+    if( msFullUrl.getLength() )
+    {
+        INetURLObject aURL( msFullUrl );
+        rtl::OUString sURL( aURL.GetMainURL( INetURLObject::DECODE_TO_IURI ) );
+        sURL = sURL.copy( 0, sURL.getLength() - aURL.GetLastName().getLength() - 1 );
+        ::osl::File::getSystemPathFromFileURL( sURL, sPath );
+    }
+    return sPath;
 }
 
 uno::Any SAL_CALL
@@ -58,17 +101,18 @@ SwVbaTemplate::AutoTextEntries( const uno::Any& index ) throw (uno::RuntimeExcep
 
     // the default template is "Normal.dot" in Word.
     rtl::OUString sGroup( RTL_CONSTASCII_USTRINGPARAM("Normal") );
-    sal_Int32 nIndex = msName.lastIndexOf( sal_Unicode('.') );
+    rtl::OUString sName = getName();
+    sal_Int32 nIndex = sName.lastIndexOf( sal_Unicode('.') );
     if( nIndex > 0 )
     {
-        sGroup = msName.copy( 0, msName.lastIndexOf( sal_Unicode('.') ) );
-       // OSL_TRACE("SwVbaTemplate::AutoTextEntries: %s", rtl::OUStringToOString( sGroup, RTL_TEXTENCODING_UTF8 ).getStr() );
+        sGroup = sName.copy( 0, sName.lastIndexOf( sal_Unicode('.') ) );
     }
-    
+	String sNewGroup = lcl_CheckGroupName( sGroup );
+
     uno::Reference< container::XIndexAccess > xGroup;
-    if( xAutoTextContainer->hasByName( sGroup ) )
+    if( xAutoTextContainer->hasByName( sNewGroup ) )
     {
-        xGroup.set( xAutoTextContainer->getByName( sGroup ), uno::UNO_QUERY_THROW );
+        xGroup.set( xAutoTextContainer->getByName( sNewGroup ), uno::UNO_QUERY_THROW );
     }
     else
     {
diff --git sw/source/ui/vba/vbatemplate.hxx sw/source/ui/vba/vbatemplate.hxx
index 4e33599..0abbc36 100644
--- sw/source/ui/vba/vbatemplate.hxx
+++ sw/source/ui/vba/vbatemplate.hxx
@@ -36,7 +36,7 @@ class SwVbaTemplate : public SwVbaTemplate_BASE
 {
 private:
     css::uno::Reference< css::frame::XModel > mxModel;
-    rtl::OUString msName;
+    rtl::OUString msFullUrl;
 public:
     SwVbaTemplate( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
         const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& );
@@ -44,6 +44,7 @@ public:
 
    // XTemplate
     virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL AutoTextEntries( const css::uno::Any& index ) throw (css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
diff --git sw/source/ui/vba/vbaview.cxx sw/source/ui/vba/vbaview.cxx
index 2cf6194..3dba711 100644
--- sw/source/ui/vba/vbaview.cxx
+++ sw/source/ui/vba/vbaview.cxx
@@ -92,20 +92,20 @@ SwVbaView::getSeekView() throw (css::uno::RuntimeException)
     }
     else if( aImplName.equalsAscii("SwXHeadFootText") )
     {
-        if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) )
+        if( HeaderFooterHelper::isHeader( mxModel ) )
         {
-            if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) )
+            if( HeaderFooterHelper::isFirstPageHeader( mxModel ) )
                 return word::WdSeekView::wdSeekFirstPageHeader;
-            else if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) )
+            else if( HeaderFooterHelper::isEvenPagesHeader( mxModel ) )
                 return word::WdSeekView::wdSeekEvenPagesHeader;
             else
                 return word::WdSeekView::wdSeekPrimaryHeader;
         }
         else
         {
-            if( HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+            if( HeaderFooterHelper::isFirstPageFooter( mxModel ) )
                 return word::WdSeekView::wdSeekFirstPageFooter;
-            else if( HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+            else if( HeaderFooterHelper::isEvenPagesFooter( mxModel ) )
                 return word::WdSeekView::wdSeekEvenPagesFooter;
             else
                 return word::WdSeekView::wdSeekPrimaryFooter;
@@ -132,6 +132,7 @@ SwVbaView::setSeekView( ::sal_Int32 _seekview ) throw (css::uno::RuntimeExceptio
     // if( _seekview == getSeekView() )
     //    return;
 
+    word::gotoSelectedObjectAnchor( mxModel );
     switch( _seekview )
     {
         case word::WdSeekView::wdSeekFirstPageFooter:
@@ -181,7 +182,7 @@ SwVbaView::setSeekView( ::sal_Int32 _seekview ) throw (css::uno::RuntimeExceptio
         {
             uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
             uno::Reference< text::XText > xText = xTextDocument->getText();
-            mxViewCursor->gotoRange( getFirstObjectPosition( xText ), sal_False );
+            mxViewCursor->gotoRange( word::getFirstObjectPosition( xText ), sal_False );
             break;
         }
     }
@@ -376,28 +377,7 @@ uno::Reference< text::XTextRange > SwVbaView::getHFTextRange( sal_Int32 nType )
     {
         DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
     }
-    uno::Reference< text::XTextRange > xTextRange = getFirstObjectPosition( xText );
-    return xTextRange;
-}
-
-uno::Reference< text::XTextRange > SwVbaView::getFirstObjectPosition( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
-{
-    // if the first object is table, get the position of first cell 
-    uno::Reference< text::XTextRange > xTextRange;
-    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
-    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
-    if( xParaEnum->hasMoreElements() )
-    {
-        uno::Reference< lang::XServiceInfo > xServiceInfo( xParaEnum->nextElement(), uno::UNO_QUERY_THROW );
-        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ) ) )
-        {
-            uno::Reference< table::XCellRange > xCellRange( xServiceInfo, uno::UNO_QUERY_THROW );
-            uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
-            xTextRange = xFirstCellText->getStart();
-        }
-    }
-    if( !xTextRange.is() )
-        xTextRange = xText->getStart();
+    uno::Reference< text::XTextRange > xTextRange = word::getFirstObjectPosition( xText );
     return xTextRange;
 }
 
diff --git sw/source/ui/vba/vbawindow.cxx sw/source/ui/vba/vbawindow.cxx
index dc5913a..687868d 100644
--- sw/source/ui/vba/vbawindow.cxx
+++ sw/source/ui/vba/vbawindow.cxx
@@ -25,12 +25,21 @@
  *
  ************************************************************************/
 #include <vbahelper/helperdecl.hxx>
+#include <ooo/vba/word/WdWindowState.hpp>
+#include <vcl/wrkwin.hxx>
+
 #include "vbawindow.hxx"
 #include "vbaglobals.hxx"
 #include "vbadocument.hxx"
 #include "vbaview.hxx"
 #include "vbapanes.hxx"
 #include "vbapane.hxx"
+#include "wordvbahelper.hxx"
+#include <view.hxx>
+// #FIXME where has SfxTopViewFrame gone
+#if 0 
+#include <sfx2/topfrm.hxx>
+#endif
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -73,6 +82,44 @@ void SAL_CALL SwVbaWindow::setView( const uno::Any& _view ) throw (uno::RuntimeE
 }
 
 uno::Any SAL_CALL 
+SwVbaWindow::getWindowState() throw (uno::RuntimeException)
+{	
+    sal_Int32 nwindowState = word::WdWindowState::wdWindowStateNormal;
+    SwView* pView = word::getView( m_xModel );
+    SfxViewFrame* pViewFrame = pView -> GetViewFrame();
+    WorkWindow* pWork = (WorkWindow*) pViewFrame->GetFrame().GetSystemWindow();
+    if ( pWork )
+    {
+        if ( pWork -> IsMaximized())
+            nwindowState = word::WdWindowState::wdWindowStateMaximize;
+        else if (pWork -> IsMinimized())
+            nwindowState = word::WdWindowState::wdWindowStateMinimize;
+    }
+    return uno::makeAny( nwindowState );
+}
+
+void SAL_CALL 
+SwVbaWindow::setWindowState( const uno::Any& _windowstate ) throw (uno::RuntimeException)
+{
+    sal_Int32 nwindowState = word::WdWindowState::wdWindowStateMaximize;
+    _windowstate >>= nwindowState;
+    SwView* pView = word::getView( m_xModel );
+    SfxViewFrame* pViewFrame = pView -> GetViewFrame();
+    WorkWindow* pWork = (WorkWindow*) pViewFrame->GetFrame().GetSystemWindow();
+    if ( pWork )
+    {
+        if ( nwindowState == word::WdWindowState::wdWindowStateMaximize )
+            pWork -> Maximize();
+        else if (nwindowState == word::WdWindowState::wdWindowStateMinimize)
+            pWork -> Minimize();
+        else if (nwindowState == word::WdWindowState::wdWindowStateNormal)
+            pWork -> Restore();
+        else
+            throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Invalid Parameter" ) ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+uno::Any SAL_CALL 
 SwVbaWindow::Panes( const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
     uno::Reference< XCollection > xPanes( new SwVbaPanes( this,  mxContext, m_xModel ) );
diff --git sw/source/ui/vba/vbawindow.hxx sw/source/ui/vba/vbawindow.hxx
index 1ef1ff9..a5e03e9 100644
--- sw/source/ui/vba/vbawindow.hxx
+++ sw/source/ui/vba/vbawindow.hxx
@@ -44,6 +44,8 @@ public:
     // Attributes
     virtual css::uno::Any SAL_CALL getView() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setView( const css::uno::Any& _view ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getWindowState() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWindowState( const css::uno::Any& _windowstate ) throw (css::uno::RuntimeException);
     // Methods
     virtual void SAL_CALL Activate(  ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Close( const css::uno::Any& SaveChanges, const css::uno::Any& RouteDocument ) throw (css::uno::RuntimeException);
diff --git sw/source/ui/vba/wordvbahelper.cxx sw/source/ui/vba/wordvbahelper.cxx
index e489b0b..281eb70 100644
--- sw/source/ui/vba/wordvbahelper.cxx
+++ sw/source/ui/vba/wordvbahelper.cxx
@@ -29,11 +29,16 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/frame/XController.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/lang/XUnoTunnel.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
 #include <unotxdoc.hxx>
 #include <doc.hxx>
+#include <view.hxx>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -71,8 +76,13 @@ uno::Reference< text::XTextViewCursor > getXTextViewCursor( const uno::Reference
 uno::Reference< style::XStyle > getCurrentPageStyle( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xCursorProps( getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+    return getCurrentPageStyle( xModel, xCursorProps );
+}
+
+uno::Reference< style::XStyle > getCurrentPageStyle( const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xProps ) throw (uno::RuntimeException)
+{
     rtl::OUString aPageStyleName;
-    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+    xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
     uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
     uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
     uno::Reference< container::XNameAccess > xPageStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles") ) ), uno::UNO_QUERY_THROW );
@@ -87,6 +97,92 @@ sal_Int32 getPageCount( const uno::Reference< frame::XModel>& xModel ) throw (un
     return pDocShell ? pDocShell->GetDoc()->GetPageCount() : 0;
 }
 
+uno::Reference< style::XStyle > getDefaultParagraphStyle( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xParaStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") ) ), uno::UNO_QUERY_THROW );
+    uno::Reference< style::XStyle > xStyle( xParaStyles->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) ), uno::UNO_QUERY_THROW );
+
+    return xStyle;
+}
+
+uno::Reference< text::XTextRange > getFirstObjectPosition( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
+{
+    // if the first object is table, get the position of first cell 
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
+    if( xParaEnum->hasMoreElements() )
+    {
+        uno::Reference< lang::XServiceInfo > xServiceInfo( xParaEnum->nextElement(), uno::UNO_QUERY_THROW );
+        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ) ) )
+        {
+            uno::Reference< table::XCellRange > xCellRange( xServiceInfo, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+            xTextRange = xFirstCellText->getStart();
+        }
+    }
+    if( !xTextRange.is() )
+        xTextRange = xText->getStart();
+    return xTextRange;
+}
+
+uno::Reference< text::XText > getCurrentXText( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< text::XTextContent > xTextContent( xModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( !xTextContent.is() )
+    {
+        uno::Reference< container::XIndexAccess > xIndexAccess( xModel->getCurrentSelection(), uno::UNO_QUERY );
+        if( xIndexAccess.is() )
+        {
+            xTextContent.set( xIndexAccess->getByIndex(0), uno::UNO_QUERY );
+        }
+    }    
+
+    if( xTextContent.is() )
+        xTextRange.set( xTextContent->getAnchor(), uno::UNO_QUERY );
+
+    if( !xTextRange.is() )    
+        xTextRange.set( getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW ); 
+        
+    uno::Reference< text::XText > xText;
+    try
+    {
+        xText.set( xTextRange->getText(), uno::UNO_QUERY );
+    }
+    catch( uno::RuntimeException& )
+    {
+        //catch exception "no text selection" 
+    }
+    uno::Reference< beans::XPropertySet > xVCProps( xTextRange, uno::UNO_QUERY_THROW );
+    while( xVCProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextContent )
+    {
+        xText = xTextContent->getAnchor()->getText();
+        xVCProps.set( xText->createTextCursor(), uno::UNO_QUERY_THROW );
+    }
+
+    if( !xText.is() )
+        throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "no text selection" ) ), uno::Reference< uno::XInterface >() );
+
+    return xText;
+}
+
+sal_Bool gotoSelectedObjectAnchor( const uno::Reference< frame::XModel>& xModel ) throw (uno::RuntimeException)
+{
+    sal_Bool isObjectSelected = sal_False;
+    uno::Reference< text::XTextContent > xTextContent( xModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( xTextContent.is() )
+    {
+        uno::Reference< text::XTextRange > xTextRange( xTextContent->getAnchor(), uno::UNO_QUERY_THROW );
+        uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+        xSelectSupp->select( uno::makeAny( xTextRange ) );
+        isObjectSelected = sal_True;
+    }
+    return isObjectSelected;
+}
+
 } // word
 } // 
 } //
diff --git sw/source/ui/vba/wordvbahelper.hxx sw/source/ui/vba/wordvbahelper.hxx
index 489cf25..47d718e 100644
--- sw/source/ui/vba/wordvbahelper.hxx
+++ sw/source/ui/vba/wordvbahelper.hxx
@@ -32,6 +32,8 @@
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XPageCursor.hpp>
 #include <com/sun/star/style/XStyle.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
 
 class SwDocShell;
 class SwView;
@@ -46,7 +48,20 @@ namespace ooo
         SwView* getView( const css::uno::Reference< css::frame::XModel>& xModel );
         css::uno::Reference< css::text::XTextViewCursor > getXTextViewCursor( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
         css::uno::Reference< css::style::XStyle > getCurrentPageStyle( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::style::XStyle > getCurrentPageStyle( const css::uno::Reference< css::frame::XModel>& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps ) throw (css::uno::RuntimeException);
         sal_Int32 getPageCount( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::style::XStyle > getDefaultParagraphStyle( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::text::XTextRange > getFirstObjectPosition( const css::uno::Reference< css::text::XText >& xText ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::text::XText > getCurrentXText( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+        sal_Bool gotoSelectedObjectAnchor( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+
+    enum E_DIRECTION
+    {
+        MOVE_LEFT = 1,
+        MOVE_RIGHT,
+        MOVE_UP,
+        MOVE_DOWN
+    };
 
 } // word
 } // vba
diff --git sw/util/makefile.mk sw/util/makefile.mk
index ce1419b..3993ad0 100644
--- sw/util/makefile.mk
+++ sw/util/makefile.mk
@@ -335,6 +335,7 @@ SHL4STDLIBS= \
     $(SALLIB) \
     $(ICUUCLIB) \
     $(BASICLIB)     \
+                $(MSFILTERLIB) \
     $(I18NUTILLIB)
 
 .IF "$(ENABLE_VBA)" == "YES"
@@ -369,6 +371,10 @@ SHL5STDLIBS= \
                 $(SVXCORELIB) \
                 $(MSFILTERLIB)

+.IF "$(GUI)"=="WNT"
+SHL5STDLIBS+=$(SHELLLIB)
+.ENDIF #WNT
+
 SHL5DEPN=$(SHL1TARGETN)
 SHL5LIBS=$(SLB)$/$(TARGET_VBA).lib
 .ENDIF # .IF "$(ENABLE_VBA)" == "YES"
diff --git toolkit/inc/toolkit/awt/vclxmenu.hxx toolkit/inc/toolkit/awt/vclxmenu.hxx
index 9fefbe9..88be605 100644
--- toolkit/inc/toolkit/awt/vclxmenu.hxx
+++ toolkit/inc/toolkit/awt/vclxmenu.hxx
@@ -45,6 +45,7 @@
 class Menu;
 class MenuBar;
 class VclSimpleEvent;
+class PopupMenu;
 
 DECLARE_LIST( PopupMenuRefList, ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu >* )
 
@@ -181,6 +182,7 @@ class TOOLKIT_DLLPUBLIC VCLXPopupMenu : public VCLXMenu
 {
 public:
         VCLXPopupMenu();
+		VCLXPopupMenu( PopupMenu* pPopMenu );
 };
 
 #endif // _TOOLKIT_AWT_VCLXMENU_HXX_
diff --git toolkit/inc/toolkit/awt/vclxwindows.hxx toolkit/inc/toolkit/awt/vclxwindows.hxx
index 8c286bd..b32f7ec 100644
--- toolkit/inc/toolkit/awt/vclxwindows.hxx
+++ toolkit/inc/toolkit/awt/vclxwindows.hxx
@@ -94,6 +94,7 @@
 #include <vcl/pointr.hxx>
 #include <vcl/image.hxx>
 
+#include <com/sun/star/document/XVbaMethodParameter.hpp>  //liuchen 2009-6-22, add the support of input/output parameters to VBA Dialog_QueryClose event
 class Button;
 class CheckBox;
 class RadioButton;
@@ -378,6 +379,7 @@ public:
 //	class VCLXDialog
 //	----------------------------------------------------
 class VCLXDialog :	public ::com::sun::star::awt::XDialog2,
+						public ::com::sun::star::document::XVbaMethodParameter, //liuchen 2009-6-22, add the support of input/output parameters to VBA UserForm_QueryClose event
                     public VCLXTopWindow
 {
 public:
@@ -415,6 +417,10 @@ public:
     // ::com::sun::star::awt::XVclWindowPeer
     void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
 
+	//liuchen 2009-6-23, support Excel VBA UserForm_QueryClose event
+	// ::com::sun::star::document::XVBAMethodParameter
+	void SAL_CALL setVbaMethodParameter( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+	::com::sun::star::uno::Any SAL_CALL getVbaMethodParameter( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException); 
 };
 
 //	----------------------------------------------------
diff --git toolkit/inc/toolkit/controls/dialogcontrol.hxx toolkit/inc/toolkit/controls/dialogcontrol.hxx
index 7b8e025..a1725f2 100644
--- toolkit/inc/toolkit/controls/dialogcontrol.hxx
+++ toolkit/inc/toolkit/controls/dialogcontrol.hxx
@@ -48,6 +48,8 @@
 #include <cppuhelper/propshlp.hxx>
 #include <cppuhelper/basemutex.hxx>
 #include <list>
+#include <map>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //	----------------------------------------------------
 //	class UnoControlDialogModel
@@ -88,7 +90,9 @@ private:
 
     AllGroups							maGroups;
     sal_Bool							mbGroupsUpToDate;
-
+        
+	::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
+	bool mbAdjustingGraphic;
 protected:	
     ::com::sun::star::uno::Any			ImplGetDefaultValue( sal_uInt16 nPropId ) const;
     ::cppu::IPropertyArrayHelper&		SAL_CALL getInfoHelper();
@@ -175,10 +179,20 @@ public:
 protected:
     void startControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
     void stopControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
+    // ::cppu::OPropertySetHelper
+	void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception);
 
     void implNotifyTabModelChange( const ::rtl::OUString& _rAccessor );
 
     void implUpdateGroupStructure();
+private:
+    void AddRadioButtonToGroup (
+            const ::com::sun::star::uno::Reference< XControlModel >& rControlModel,
+            const ::rtl::OUString& rPropertyName,
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups,
+            ModelGroup*& rpCurrentGroup );
+    void AddRadioButtonGroup (
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups );
 };
 
 //	----------------------------------------------------
diff --git toolkit/inc/toolkit/controls/unocontrols.hxx toolkit/inc/toolkit/controls/unocontrols.hxx
index 7f0e9cb..c3d1de0 100644
--- toolkit/inc/toolkit/controls/unocontrols.hxx
+++ toolkit/inc/toolkit/controls/unocontrols.hxx
@@ -223,7 +223,6 @@ private:
     bool                                                                                    mbAdjustingGraphic;
     
     ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
-    ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphic > getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL );
 
 protected:
     GraphicControlModel() : mbAdjustingImagePosition( false ), mbAdjustingGraphic( false ) { }
@@ -637,6 +636,44 @@ public:
 
 };
 
+class UnoMultiPageModel : public UnoControlModel
+{
+protected:
+	::com::sun::star::uno::Any 		ImplGetDefaultValue( sal_uInt16 nPropId ) const;
+	::cppu::IPropertyArrayHelper& 	SAL_CALL getInfoHelper();
+
+public:
+						UnoMultiPageModel();
+						UnoMultiPageModel( const UnoMultiPageModel& rModel ) : UnoControlModel( rModel ) {;}
+
+	UnoControlModel*	Clone() const { return new UnoMultiPageModel( *this ); }
+
+	// ::com::sun::star::io::XPersistObject
+    ::rtl::OUString SAL_CALL getServiceName() throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::beans::XMultiPropertySet
+    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageModel, UnoControlModel, szServiceName_UnoMultiPageModel )
+
+};
+//	----------------------------------------------------
+//	class UnoGroupBoxControl
+//	----------------------------------------------------
+class UnoMultiPageControl :	public UnoControlBase
+{
+public:
+						UnoMultiPageControl();
+	::rtl::OUString		GetComponentServiceName();
+
+    sal_Bool SAL_CALL isTransparent(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageControl, UnoControlBase, szServiceName_UnoMultiPageControl )
+
+};
+
 //  ----------------------------------------------------
 //  class UnoFixedTextControl
 //  ----------------------------------------------------
diff --git toolkit/inc/toolkit/helper/property.hxx toolkit/inc/toolkit/helper/property.hxx
index 2fb64b2..3c8e4a1 100644
--- toolkit/inc/toolkit/helper/property.hxx
+++ toolkit/inc/toolkit/helper/property.hxx
@@ -195,6 +195,7 @@ namespace rtl {
 #define BASEPROPERTY_GRID_SELECTIONMODE             144
 #define BASEPROPERTY_ENABLEVISIBLE                  145  // sal_Bool
 #define BASEPROPERTY_REFERENCE_DEVICE               146
+
 #define BASEPROPERTY_HIGHCONTRASTMODE               147
 #define BASEPROPERTY_GRID_EVEN_ROW_BACKGROUND       148
 #define BASEPROPERTY_GRID_HEADER_BACKGROUND         149
@@ -202,6 +203,8 @@ namespace rtl {
 #define BASEPROPERTY_GRID_ROW_BACKGROUND	        151
 #define BASEPROPERTY_MULTISELECTION_SIMPLEMODE      152
 #define BASEPROPERTY_ITEM_SEPARATOR_POS             153
+#define BASEPROPERTY_GROUPNAME                      154  // ::rtl::OUString
+#define BASEPROPERTY_VBAFORM                        155  // sal_Bool
 
 
 // Keine gebundenen Properties, werden immer aus der Property BASEPROPERTY_FONTDESCRIPTOR entnommen.
diff --git toolkit/inc/toolkit/helper/servicenames.hxx toolkit/inc/toolkit/helper/servicenames.hxx
index 91ece3a..374373b 100644
--- toolkit/inc/toolkit/helper/servicenames.hxx
+++ toolkit/inc/toolkit/helper/servicenames.hxx
@@ -37,6 +37,8 @@ extern const sal_Char __FAR_DATA szServiceName_PopupMenu[], szServiceName2_Popup
 extern const sal_Char __FAR_DATA szServiceName_MenuBar[], szServiceName2_MenuBar[];
 extern const sal_Char __FAR_DATA szServiceName_Pointer[], szServiceName2_Pointer[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainer[], szServiceName2_UnoControlContainer[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[], szServiceName2_UnoMultiPageControl[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[], szServiceName2_UnoMultiPageModel[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[], szServiceName2_UnoControlContainerModel[];
 extern const sal_Char __FAR_DATA szServiceName_TabController[], szServiceName2_TabController[];
 extern const sal_Char __FAR_DATA szServiceName_TabControllerModel[], szServiceName2_TabControllerModel[];
diff --git toolkit/source/awt/vclxmenu.cxx toolkit/source/awt/vclxmenu.cxx
index c6294c8..eb5cb3b 100644
--- toolkit/source/awt/vclxmenu.cxx
+++ toolkit/source/awt/vclxmenu.cxx
@@ -539,6 +539,14 @@ void VCLXMenu::setPopupMenu( sal_Int16 nItemId, const ::com::sun::star::uno::Ref
                 break;
             }
         }
+        // it seems the popup menu is not insert into maPopupMenueRefs
+        // if the popup men is not created by stardiv.Toolkit.VCLXPopupMenu
+        if( !aRef.is() )
+        {
+		    ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > * pNewRef = new ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > ;
+            *pNewRef = new VCLXPopupMenu( (PopupMenu*)pMenu );
+            aRef = *pNewRef;
+        }
     }
     return aRef;
 }
@@ -1101,3 +1109,8 @@ VCLXPopupMenu::VCLXPopupMenu()
     DBG_CTOR( VCLXPopupMenu, 0 );
     ImplCreateMenu( TRUE );
 }
+
+VCLXPopupMenu::VCLXPopupMenu( PopupMenu* pPopMenu ) : VCLXMenu( (Menu *)pPopMenu )
+{
+    DBG_CTOR( VCLXPopupMenu, 0 );
+}
diff --git toolkit/source/awt/vclxwindows.cxx toolkit/source/awt/vclxwindows.cxx
index 5c7c319..1e1aa1d 100644
--- toolkit/source/awt/vclxwindows.cxx
+++ toolkit/source/awt/vclxwindows.cxx
@@ -1082,6 +1082,7 @@ void VCLXRadioButton::ImplGetPropertyIds( std::list< sal_uInt16 > &rIds )
                      BASEPROPERTY_WRITING_MODE,
                      BASEPROPERTY_CONTEXT_WRITING_MODE,
                      BASEPROPERTY_REFERENCE_DEVICE,
+                     BASEPROPERTY_GROUPNAME,
                      0);
     VCLXGraphicControl::ImplGetPropertyIds( rIds );
 }
@@ -2303,6 +2304,7 @@ VCLXDialog::~VCLXDialog()
 ::com::sun::star::uno::Any VCLXDialog::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
 {
     ::com::sun::star::uno::Any aRet = ::cppu::queryInterface( rType,
+										SAL_STATIC_CAST( ::com::sun::star::document::XVbaMethodParameter*, this ), //liuchen 2009-6-23
                                         SAL_STATIC_CAST( ::com::sun::star::awt::XDialog2*, this ),
                                         SAL_STATIC_CAST( ::com::sun::star::awt::XDialog*, this ) );
     return (aRet.hasValue() ? aRet : VCLXTopWindow::queryInterface( rType ));
@@ -2310,6 +2312,7 @@ VCLXDialog::~VCLXDialog()
 
 // ::com::sun::star::lang::XTypeProvider
 IMPL_XTYPEPROVIDER_START( VCLXDialog )
+	getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::document::XVbaMethodParameter>* ) NULL ), //liuchen 2009-6-23
     getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDialog2>* ) NULL ),
     getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDialog>* ) NULL ),
     VCLXTopWindow::getTypes()
@@ -2412,6 +2415,40 @@ void SAL_CALL VCLXDialog::draw( sal_Int32 nX, sal_Int32 nY ) throw(::com::sun::s
     return aInfo;
 }
 
+//liuchen 2009-7-22
+// ::com::sun::star::document::XVbaMethodParameter
+void SAL_CALL VCLXDialog::setVbaMethodParameter(
+	const ::rtl::OUString& PropertyName,
+	const ::com::sun::star::uno::Any& Value )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	if (rtl::OUString::createFromAscii( "Cancel" ) == PropertyName)
+	{
+		::vos::OGuard aGuard( GetMutex() ); 
+		if ( GetWindow() )
+		{
+			sal_Int8 nCancel;
+			Value >>= nCancel;
+		
+			Dialog* pDlg = (Dialog*) GetWindow();
+			pDlg->SetCloseFlag(nCancel);
+		}
+	}
+}
+
+::com::sun::star::uno::Any SAL_CALL VCLXDialog::getVbaMethodParameter(
+	const ::rtl::OUString& PropertyName )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	::vos::OGuard aGuard( GetMutex() );
+
+	::com::sun::star::uno::Any aRet;	
+	return aRet;
+}
+//liuchen 2009-7-22
+
+
+
 
 void SAL_CALL VCLXDialog::setProperty(
     const ::rtl::OUString& PropertyName,
diff --git toolkit/source/controls/dialogcontrol.cxx toolkit/source/controls/dialogcontrol.cxx
index 7f23b49..1fe21d2 100644
--- toolkit/source/controls/dialogcontrol.cxx
+++ toolkit/source/controls/dialogcontrol.cxx
@@ -81,6 +81,7 @@ using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::script;
 using namespace toolkit;
 
 #define PROPERTY_RESOURCERESOLVER ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ResourceResolver" ))
@@ -91,6 +92,8 @@ using namespace toolkit;
 //HELPER
 ::rtl::OUString getPhysicalLocation( const ::com::sun::star::uno::Any& rbase, const ::com::sun::star::uno::Any& rUrl );
 
+uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL );
+
 struct LanguageDependentProp
 {
     const char* pPropName;
@@ -116,7 +119,7 @@ namespace
         }
         return s_aLanguageDependentProperties;
     }
-
+ 
     static uno::Reference< graphic::XGraphic > lcl_getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
@@ -143,6 +146,18 @@ namespace
         return xGraphic;
     }
 
+    static ::rtl::OUString lcl_GetStringProperty( const ::rtl::OUString& sProperty, const Reference< XPropertySet >& xSet )
+    {
+        ::rtl::OUString sValue;
+        Reference< XPropertySetInfo > xPSI;
+        if (xSet.is() && (xPSI = xSet->getPropertySetInfo()).is() && 
+                xPSI->hasPropertyByName( sProperty ) )
+        {
+            xSet->getPropertyValue( sProperty ) >>= sValue;
+        }
+        return sValue;
+    }
+
 }
 
 // ----------------------------------------------------------------------------
@@ -254,7 +269,7 @@ static const ::rtl::OUString& getStepPropertyName( )
 UnoControlDialogModel::UnoControlDialogModel()
     :maContainerListeners( *this )
     ,maChangeListeners ( GetMutex() )
-    ,mbGroupsUpToDate( sal_False )
+	,mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
     ImplRegisterProperty( BASEPROPERTY_BACKGROUNDCOLOR );
 //	ImplRegisterProperty( BASEPROPERTY_BORDER );
@@ -276,6 +291,8 @@ UnoControlDialogModel::UnoControlDialogModel()
     aBool <<= (sal_Bool) sal_True;
     ImplRegisterProperty( BASEPROPERTY_MOVEABLE, aBool );
     ImplRegisterProperty( BASEPROPERTY_CLOSEABLE, aBool );
+	aBool <<= (sal_Bool) sal_False;
+	ImplRegisterProperty( BASEPROPERTY_VBAFORM, aBool );
 }
 
 UnoControlDialogModel::UnoControlDialogModel( const UnoControlDialogModel& rModel )
@@ -283,7 +300,7 @@ UnoControlDialogModel::UnoControlDialogModel( const UnoControlDialogModel& rMode
     , UnoControlDialogModel_Base( rModel )
     , maContainerListeners( *this )
     , maChangeListeners ( GetMutex() )
-    , mbGroupsUpToDate( sal_False )
+	, mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
 }
 
@@ -314,6 +331,40 @@ Sequence< Type > UnoControlDialogModel::getTypes() throw(RuntimeException)
     return ::rtl::OUString::createFromAscii( szServiceName_UnoControlDialogModel );
 }
 
+void SAL_CALL UnoControlDialogModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception)
+{
+    UnoControlModel::setFastPropertyValue_NoBroadcast( nHandle, rValue );
+    try
+    {
+        switch ( nHandle )
+        {
+        case BASEPROPERTY_IMAGEURL:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_GRAPHIC ) )
+            {
+                mbAdjustingGraphic = true;
+                ::rtl::OUString sImageURL;
+                OSL_VERIFY( rValue >>= sImageURL );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+
+        case BASEPROPERTY_GRAPHIC:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_IMAGEURL ) )
+            {
+                mbAdjustingGraphic = true;
+                setPropertyValue( GetPropertyName( BASEPROPERTY_IMAGEURL ), uno::makeAny( ::rtl::OUString() ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+	}
+    }
+    catch( const ::com::sun::star::uno::Exception& )
+    {
+        OSL_ENSURE( sal_False, "UnoControlDialogModel::setFastPropertyValue_NoBroadcast: caught an exception while setting Graphic/ImageURL properties!" );
+    }
+}
+
 Any UnoControlDialogModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
 {
     Any aAny;
@@ -906,6 +957,63 @@ void UnoControlDialogModel::implNotifyTabModelChange( const ::rtl::OUString& _rA
     }
 }
 
+// ----------------------------------------------------------------------------
+void UnoControlDialogModel::AddRadioButtonGroup ( 
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups )
+{
+    if ( rNamedGroups.size() == 0 )
+        return;
+
+    size_t nGroups = maGroups.size();
+    maGroups.reserve( nGroups + rNamedGroups.size() );
+    ::std::map< ::rtl::OUString, ModelGroup >::const_iterator i = rNamedGroups.begin(), e = rNamedGroups.end();
+    for( ; i != e; ++i)
+    {
+            maGroups.push_back( i->second );
+    }
+
+    rNamedGroups.clear();
+}
+
+void UnoControlDialogModel::AddRadioButtonToGroup ( 
+        const Reference< XControlModel >& rControlModel,
+        const ::rtl::OUString& rPropertyName,
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups,
+        ModelGroup*& rpCurrentGroup )
+{
+    Reference< XPropertySet > xCurProps( rControlModel, UNO_QUERY );
+    ::rtl::OUString sGroup = lcl_GetStringProperty( rPropertyName, xCurProps );
+    const sal_Int32 nControlModelStep = lcl_getDialogStep( rControlModel );
+
+    if ( sGroup.getLength() == 0 )
+    {
+        // Create a new group if:
+        if ( maGroups.size() == 0 ||                // no groups
+                rpCurrentGroup == NULL ||           // previous group was closed
+                (nControlModelStep != 0 &&          // control step matches current group
+                 maGroups.back().size() > 0 &&      //  (group 0 == display everywhere)
+                 nControlModelStep != lcl_getDialogStep( maGroups.back().back() ) ) )
+        {
+            size_t nGroups = maGroups.size();
+            maGroups.resize( nGroups + 1 );
+        }
+        rpCurrentGroup = &maGroups.back();
+    }
+    else
+    {
+        // Different steps get different sets of named groups
+        if ( rNamedGroups.size() > 0 &&
+                rNamedGroups.begin()->second.size() > 0 )
+        {
+            const sal_Int32 nPrevStep = lcl_getDialogStep( rNamedGroups.begin()->second.front() );
+            if ( nControlModelStep != nPrevStep )
+                AddRadioButtonGroup( rNamedGroups );
+        }
+
+        rpCurrentGroup = &rNamedGroups[ sGroup ];
+    }
+    rpCurrentGroup->push_back( rControlModel );
+}
 
 // ----------------------------------------------------------------------------
 void UnoControlDialogModel::implUpdateGroupStructure()
@@ -930,10 +1038,13 @@ void UnoControlDialogModel::implUpdateGroupStructure()
 
     GroupingMachineState eState = eLookingForGroup;		// the current state of our machine
     Reference< XServiceInfo > xModelSI;					// for checking for a radion button
-    AllGroups::iterator aCurrentGroup = maGroups.end();	// the group which we're currently building
-    sal_Int32	nCurrentGroupStep = -1;					// the step which all controls of the current group belong to
+	ModelGroup* aCurrentGroup = NULL;                   // the group which we're currently building
     sal_Bool	bIsRadioButton;							// is it a radio button?
 
+    const ::rtl::OUString GROUP_NAME( RTL_CONSTASCII_USTRINGPARAM( "GroupName" ) );
+
+    ::std::map< ::rtl::OUString, ModelGroup > aNamedGroups;
+
 #if OSL_DEBUG_LEVEL > 1
     ::std::vector< ::rtl::OUString > aCurrentGroupLabels;
 #endif
@@ -954,14 +1065,8 @@ void UnoControlDialogModel::implUpdateGroupStructure()
                 // the current model is a radio button
                 // -> we found the beginning of a new group
                 // create the place for this group
-                size_t nGroups = maGroups.size();
-                maGroups.resize( nGroups + 1 );
-                aCurrentGroup = maGroups.begin() + nGroups;
-                // and add the (only, til now) member
-                aCurrentGroup->push_back( *pControlModels );
-
-                // get the step which all controls of this group now have to belong to
-                nCurrentGroupStep = lcl_getDialogStep( *pControlModels );
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
+
                 // new state: looking for further members
                 eState = eExpandingGroup;
 
@@ -979,7 +1084,7 @@ void UnoControlDialogModel::implUpdateGroupStructure()
             {
                 if ( !bIsRadioButton )
                 {	// no radio button -> the group is done
-                    aCurrentGroup = maGroups.end();
+					aCurrentGroup = NULL;
                     eState = eLookingForGroup;
 #if OSL_DEBUG_LEVEL > 1
                     aCurrentGroupLabels.clear();
@@ -987,47 +1092,8 @@ void UnoControlDialogModel::implUpdateGroupStructure()
                     continue;
                 }
 
-                // it is a radio button - is it on the proper page?
-                const sal_Int32 nThisModelStep = lcl_getDialogStep( *pControlModels );
-                if	(	( nThisModelStep == nCurrentGroupStep )	// the current button is on the same dialog page
-                    ||	( 0 == nThisModelStep )					// the current button appears on all pages
-                    )
-                {
-                    // -> it belongs to the same group
-                    aCurrentGroup->push_back( *pControlModels );
-                    // state still is eExpandingGroup - we're looking for further elements
-                    eState = eExpandingGroup;
-
-#if OSL_DEBUG_LEVEL > 1
-                    Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
-                    ::rtl::OUString sLabel;
-                    if ( xModelProps.is() && xModelProps->getPropertySetInfo().is() && xModelProps->getPropertySetInfo()->hasPropertyByName( ::rtl::OUString::createFromAscii( "Label" ) ) )
-                        xModelProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Label" ) ) >>= sLabel;
-                    aCurrentGroupLabels.push_back( sLabel );
-#endif
-                    continue;
-                }
-
-                // it's a radio button, but on a different page
-                // -> we open a new group for it
-
-                // close the old group
-                aCurrentGroup = maGroups.end();
-#if OSL_DEBUG_LEVEL > 1
-                aCurrentGroupLabels.clear();
-#endif
-
-                // open a new group
-                size_t nGroups = maGroups.size();
-                maGroups.resize( nGroups + 1 );
-                aCurrentGroup = maGroups.begin() + nGroups;
-                // and add the (only, til now) member
-                aCurrentGroup->push_back( *pControlModels );
-
-                nCurrentGroupStep = nThisModelStep;
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
 
-                // state is the same: we still are looking for further elements of the current group
-                eState = eExpandingGroup;
 #if OSL_DEBUG_LEVEL > 1
                 Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
                 ::rtl::OUString sLabel;
@@ -1040,6 +1106,7 @@ void UnoControlDialogModel::implUpdateGroupStructure()
         }
     }
 
+    AddRadioButtonGroup( aNamedGroups );
     mbGroupsUpToDate = sal_True;
 }
 
@@ -1420,17 +1487,32 @@ void UnoDialogControl::ImplSetPosSize( Reference< XControl >& rxCtrl )
     xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Width" ) ) ) >>= nWidth;
     xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) >>= nHeight;
 
-    // Currentley we are simply using MAP_APPFONT
+	// Currentley we are simply using MAP_APPFONT ( for normal Dialogs )
+	// and MAP_100TH_MM for imported Userforms
+	MapMode aMode( MAP_APPFONT );
+	sal_Bool bVBAForm = sal_False;
+	Reference< XPropertySet > xDlgModelProps( getModel(), UNO_QUERY );
+	if ( xDlgModelProps.is() )
+	{
+		try
+		{
+			xDlgModelProps->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAForm" ) ) ) >>= bVBAForm;
+		}
+		catch( Exception& )
+		{
+		}
+	} 
+	if ( bVBAForm )
+		aMode = MapMode( MAP_100TH_MM );
     OutputDevice*pOutDev = Application::GetDefaultDevice();
-    DBG_ASSERT( pOutDev, "Missing Default Device!" );
     if ( pOutDev )
     {
         ::Size aTmp( nX, nY );
-        aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
         nX = aTmp.Width();
         nY = aTmp.Height();
         aTmp = ::Size( nWidth, nHeight );
-        aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
         nWidth = aTmp.Width();
         nHeight = aTmp.Height();
     }
@@ -1649,17 +1731,16 @@ void UnoDialogControl::PrepareWindowDescriptor( ::com::sun::star::awt::WindowDes
     // can lead to overwrites we have to set the graphic property
     // before the propertiesChangeEvents are sent!
     ::rtl::OUString aImageURL;
-    Reference< graphic::XGraphic > xGraphic;
     if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
         ( aImageURL.getLength() > 0 ))
     {
-        ::rtl::OUString absoluteUrl =
+        aImageURL = 
             getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                  ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-        xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
-        ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
     }
+    if ( aImageURL.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+        ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
 }
 
 void UnoDialogControl::elementInserted( const ContainerEvent& Event ) throw(RuntimeException)
@@ -1891,18 +1972,16 @@ void UnoDialogControl::ImplModelPropertiesChanged( const Sequence< PropertyChang
         if ( bOwnModel && rEvt.PropertyName.equalsAsciiL( "ImageURL", 8 ))
         {
             ::rtl::OUString aImageURL;
-            Reference< graphic::XGraphic > xGraphic;
             if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
                 ( aImageURL.getLength() > 0 ))
             {
-                ::rtl::OUString absoluteUrl =
+                aImageURL =
                     getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                          ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-                xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
             }
 
-            ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
+            ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
             break;
         }
     }
@@ -2103,6 +2182,9 @@ throw (RuntimeException)
 
 ::rtl::OUString getPhysicalLocation( const ::com::sun::star::uno::Any& rbase, const ::com::sun::star::uno::Any& rUrl )
 {
+
+        ::rtl::OUString ret;
+
     ::rtl::OUString baseLocation;
     ::rtl::OUString url;
 
@@ -2112,9 +2194,16 @@ throw (RuntimeException)
     ::rtl::OUString absoluteURL( url );
     if ( url.getLength() > 0 )
     {
-        INetURLObject urlObj(baseLocation);
-        urlObj.removeSegment();
-        baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
+		// Don't adjust GraphicObject url(s)
+		if ( url.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+		{
+			INetURLObject urlObj(baseLocation);
+			urlObj.removeSegment();
+			baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
+			::osl::FileBase::getAbsoluteFileURL( baseLocation, url, ret );
+		}
+		else
+			ret = url;
 
         const INetURLObject protocolCheck( url );
         const INetProtocol protocol = protocolCheck.GetProtocol();
diff --git toolkit/source/controls/unocontrolmodel.cxx toolkit/source/controls/unocontrolmodel.cxx
index 7e6346b..9335711 100644
--- toolkit/source/controls/unocontrolmodel.cxx
+++ toolkit/source/controls/unocontrolmodel.cxx
@@ -349,6 +349,7 @@ sal_Bool UnoControlModel::ImplHasProperty( sal_uInt16 nPropId ) const
             case BASEPROPERTY_ENABLEVISIBLE:
             case BASEPROPERTY_DECORATION:           aDefault <<= (sal_Bool) sal_True; break;
 
+            case BASEPROPERTY_GROUPNAME:
             case BASEPROPERTY_HELPTEXT:
             case BASEPROPERTY_HELPURL:
             case BASEPROPERTY_IMAGEURL:
diff --git toolkit/source/controls/unocontrols.cxx toolkit/source/controls/unocontrols.cxx
index db87a58..1edb424 100644
--- toolkit/source/controls/unocontrols.cxx
+++ toolkit/source/controls/unocontrols.cxx
@@ -526,7 +526,7 @@ uno::Any GraphicControlModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
 
     return UnoControlModel::ImplGetDefaultValue( nPropId );
 }
-    uno::Reference< graphic::XGraphic > GraphicControlModel::getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
+    uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
 
@@ -536,10 +536,10 @@ uno::Any GraphicControlModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
             rtl::OUString sID = _rURL.copy( sizeof( UNO_NAME_GRAPHOBJ_URLPREFIX ) - 1 );
             // get the DefaultContext
             ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
-            mxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
+            rxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
         }
         else // linked
-            mxGrfObj = NULL; // release the GraphicObject
+            rxGrfObj = NULL; // release the GraphicObject
 
         if ( !_rURL.getLength() )
             return xGraphic;
@@ -580,7 +580,7 @@ void SAL_CALL GraphicControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 n
                 mbAdjustingGraphic = true;
                 ::rtl::OUString sImageURL;
                 OSL_VERIFY( rValue >>= sImageURL );
-                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( sImageURL ) ) );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
                 mbAdjustingGraphic = false;
             }
             break;
@@ -1718,6 +1718,75 @@ sal_Bool UnoGroupBoxControl::isTransparent() throw(uno::RuntimeException)
     return sal_True;
 }
 
+// MultiPage
+
+UnoMultiPageModel::UnoMultiPageModel()
+{
+	ImplRegisterProperty( BASEPROPERTY_DEFAULTCONTROL );
+	ImplRegisterProperty( BASEPROPERTY_ENABLED );
+	ImplRegisterProperty( BASEPROPERTY_FONTDESCRIPTOR );
+	ImplRegisterProperty( BASEPROPERTY_HELPTEXT );
+	ImplRegisterProperty( BASEPROPERTY_HELPURL );
+	ImplRegisterProperty( BASEPROPERTY_LABEL );
+	ImplRegisterProperty( BASEPROPERTY_PRINTABLE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE_MAX );
+}
+
+::rtl::OUString UnoMultiPageModel::getServiceName() throw(::com::sun::star::uno::RuntimeException)
+{
+	return ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageModel );
+}
+
+uno::Any UnoMultiPageModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
+{
+	if ( nPropId == BASEPROPERTY_DEFAULTCONTROL )
+	{
+		uno::Any aAny;
+		aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoControlGroupBox );
+		//aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageControl );
+		return aAny;
+	}
+	return UnoControlModel::ImplGetDefaultValue( nPropId );
+}
+
+::cppu::IPropertyArrayHelper& UnoMultiPageModel::getInfoHelper()
+{
+	static UnoPropertyArrayHelper* pHelper = NULL;
+	if ( !pHelper )
+	{
+		uno::Sequence<sal_Int32>	aIDs = ImplGetPropertyIds();
+		pHelper = new UnoPropertyArrayHelper( aIDs );
+	}
+	return *pHelper;
+}
+
+// beans::XMultiPropertySet
+uno::Reference< beans::XPropertySetInfo > UnoMultiPageModel::getPropertySetInfo(  ) throw(uno::RuntimeException)
+{
+	static uno::Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+	return xInfo;
+}
+
+//	----------------------------------------------------
+//	class MultiPageControl
+//	----------------------------------------------------
+UnoMultiPageControl::UnoMultiPageControl()
+{
+	maComponentInfos.nWidth = 100;
+	maComponentInfos.nHeight = 100;
+}
+
+::rtl::OUString UnoMultiPageControl::GetComponentServiceName()
+{
+	return ::rtl::OUString::createFromAscii( "multipage" );
+}
+
+sal_Bool UnoMultiPageControl::isTransparent() throw(uno::RuntimeException)
+{
+	return sal_True;
+}
+
 // =====================================================================================================================
 // = UnoControlListBoxModel_Data
 // =====================================================================================================================
diff --git toolkit/source/helper/property.cxx toolkit/source/helper/property.cxx
index b6d47ff..3b937d7 100644
--- toolkit/source/helper/property.cxx
+++ toolkit/source/helper/property.cxx
@@ -182,6 +182,7 @@ ImplPropertyInfo* ImplGetPropertyInfos( sal_uInt16& rElementCount )
             DECL_PROP_3     ( "FormatsSupplier",        FORMATSSUPPLIER,    Reference< ::com::sun::star::util::XNumberFormatsSupplier >, BOUND, MAYBEVOID, TRANSIENT ),
 
             DECL_PROP_2     ( "Graphic",                GRAPHIC,            Reference< ::com::sun::star::graphic::XGraphic >, BOUND, TRANSIENT ),
+            DECL_PROP_2     ( "GroupName",              GROUPNAME,          ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpText",               HELPTEXT,           ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpURL",                HELPURL,            ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HideInactiveSelection",  HIDEINACTIVESELECTION, bool,            BOUND, MAYBEDEFAULT ),
@@ -284,6 +285,7 @@ ImplPropertyInfo* ImplGetPropertyInfos( sal_uInt16& rElementCount )
             DECL_PROP_3     ( "SelectionModel",		    GRID_SELECTIONMODE,     ::com::sun::star::view::SelectionType,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,           BOUND, MAYBEDEFAULT ),
             DECL_PROP_3     ( "ReferenceDevice",        REFERENCE_DEVICE,       Reference< XDevice >,BOUND, MAYBEDEFAULT, TRANSIENT ),
+            DECL_PROP_2     ( "VBAForm",                VBAFORM,                sal_Bool,           BOUND, MAYBEDEFAULT ),
             DECL_PROP_3     ( "EvenRowBackgroundColor", GRID_EVEN_ROW_BACKGROUND, sal_Int32,      BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "HeaderBackgroundColor",  GRID_HEADER_BACKGROUND,  sal_Int32,      BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "GridLineColor",          GRID_LINE_COLOR,         sal_Int32,      BOUND, MAYBEDEFAULT, MAYBEVOID ),
diff --git toolkit/source/helper/registerservices.cxx toolkit/source/helper/registerservices.cxx
index 424f9b2..bcaa925 100644
--- toolkit/source/helper/registerservices.cxx
+++ toolkit/source/helper/registerservices.cxx
@@ -165,6 +165,7 @@ IMPL_CREATEINSTANCE( UnoControlTimeFieldModel )
 IMPL_CREATEINSTANCE( UnoControlProgressBarModel )
 IMPL_CREATEINSTANCE( UnoControlScrollBarModel )
 IMPL_CREATEINSTANCE( UnoSpinButtonModel )
+IMPL_CREATEINSTANCE( UnoMultiPageModel )
 IMPL_CREATEINSTANCE( UnoControlFixedLineModel )
 IMPL_CREATEINSTANCE( UnoCurrencyFieldControl )
 IMPL_CREATEINSTANCE( UnoDateFieldControl )
@@ -184,6 +185,7 @@ IMPL_CREATEINSTANCE( UnoTimeFieldControl )
 IMPL_CREATEINSTANCE( UnoProgressBarControl )
 IMPL_CREATEINSTANCE( UnoScrollBarControl )
 IMPL_CREATEINSTANCE( UnoSpinButtonControl )
+IMPL_CREATEINSTANCE( UnoMultiPageControl )
 IMPL_CREATEINSTANCE( UnoFixedLineControl )
 IMPL_CREATEINSTANCE( VCLXMenuBar )
 IMPL_CREATEINSTANCE( VCLXPointer )
@@ -276,6 +278,8 @@ TOOLKIT_DLLPUBLIC sal_Bool SAL_CALL component_writeInfo( void* _pServiceManager,
         registerServices( xRegistryKey, "UnoControlScrollBarModel", szServiceName_UnoControlScrollBarModel, szServiceName2_UnoControlScrollBarModel );
         registerServices( xRegistryKey, "UnoSpinButtonModel", szServiceName_UnoSpinButtonModel );
         registerServices( xRegistryKey, "UnoSpinButtonControl", szServiceName_UnoSpinButtonControl );
+        registerServices( xRegistryKey, "UnoMultiPageModel", szServiceName_UnoMultiPageModel );
+        registerServices( xRegistryKey, "UnoMultiPageControl", szServiceName_UnoMultiPageControl );
         registerServices( xRegistryKey, "UnoFixedLineControl", szServiceName_UnoControlFixedLine, szServiceName2_UnoControlFixedLine );
         registerServices( xRegistryKey, "UnoControlFixedLineModel", szServiceName_UnoControlFixedLineModel, szServiceName2_UnoControlFixedLineModel );
         registerServices( xRegistryKey, "VCLXPrinterServer", szServiceName_PrinterServer, szServiceName2_PrinterServer );
@@ -366,6 +370,8 @@ TOOLKIT_DLLPUBLIC void* SAL_CALL component_getFactory( const sal_Char* sImplemen
         CHECKANDCREATEFACTORY( VCLXPrinterServer, szServiceName_PrinterServer, szServiceName2_PrinterServer )
         CHECKANDCREATEFACTORY( UnoRoadmapControl, szServiceName_UnoControlRoadmap, szServiceName2_UnoControlRoadmap )
         CHECKANDCREATEFACTORY( UnoControlRoadmapModel, szServiceName_UnoControlRoadmapModel, szServiceName2_UnoControlRoadmapModel )
+        CHECKANDCREATEFACTORY( UnoMultiPageModel, szServiceName_UnoMultiPageModel, NULL )
+        CHECKANDCREATEFACTORY( UnoMultiPageControl, szServiceName_UnoMultiPageControl, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonModel, szServiceName_UnoSpinButtonModel, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonControl, szServiceName_UnoSpinButtonControl, NULL )
         CHECKANDCREATEFACTORY( TreeControl, szServiceName_TreeControl, NULL )
diff --git toolkit/source/helper/servicenames.cxx toolkit/source/helper/servicenames.cxx
index 184f4be..06cb4a3 100644
--- toolkit/source/helper/servicenames.cxx
+++ toolkit/source/helper/servicenames.cxx
@@ -37,6 +37,8 @@ const sal_Char __FAR_DATA szServiceName_PopupMenu[] = "stardiv.vcl.PopupMenu", s
 const sal_Char __FAR_DATA szServiceName_MenuBar[] = "stardiv.vcl.MenuBar", szServiceName2_MenuBar[] = "com.sun.star.awt.MenuBar";
 const sal_Char __FAR_DATA szServiceName_Pointer[] = "stardiv.vcl.Pointer", szServiceName2_Pointer[] = "com.sun.star.awt.Pointer";
 const sal_Char __FAR_DATA szServiceName_UnoControlContainer[] = "stardiv.vcl.control.ControlContainer", szServiceName2_UnoControlContainer[] = "com.sun.star.awt.UnoControlContainer";
+
+
 const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[] = "stardiv.vcl.controlmodel.ControlContainer", szServiceName2_UnoControlContainerModel[] = "com.sun.star.awt.UnoControlContainerModel";
 const sal_Char __FAR_DATA szServiceName_TabController[] = "stardiv.vcl.control.TabController", szServiceName2_TabController[] = "com.sun.star.awt.TabController";
 const sal_Char __FAR_DATA szServiceName_TabControllerModel[] = "stardiv.vcl.controlmodel.TabController", szServiceName2_TabControllerModel[] = "com.sun.star.awt.TabControllerModel";
@@ -88,6 +90,8 @@ const sal_Char __FAR_DATA szServiceName_UnoControlRoadmap[] = "stardiv.vcl.contr
 const sal_Char __FAR_DATA szServiceName_UnoControlRoadmapModel[] = "stardiv.vcl.controlmodel.Roadmap", szServiceName2_UnoControlRoadmapModel[] = "com.sun.star.awt.UnoControlRoadmapModel";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonControl[] = "com.sun.star.awt.UnoControlSpinButton";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonModel[] = "com.sun.star.awt.UnoControlSpinButtonModel";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[] = "com.sun.star.awt.UnoControlMultiPage";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[] = "com.sun.star.awt.UnoMultiPageModel";
 const sal_Char __FAR_DATA szServiceName_TreeControl[] = "com.sun.star.awt.tree.TreeControl";
 const sal_Char __FAR_DATA szServiceName_TreeControlModel[] = "com.sun.star.awt.tree.TreeControlModel";
 const sal_Char __FAR_DATA szServiceName_MutableTreeDataModel[] = "com.sun.star.awt.tree.MutableTreeDataModel";
diff --git udkapi/com/sun/star/script/XAutomationInvocation.idl udkapi/com/sun/star/script/XAutomationInvocation.idl
new file mode 100644
index 0000000..9dcf61b
--- /dev/null
+++ udkapi/com/sun/star/script/XAutomationInvocation.idl
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XInvocation2.idl,v $
+ * $Revision: 1.10 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XAutomationInvocation_idl__ 
+#define __com_sun_star_script_XAutomationInvocation_idl__
+ 
+#ifndef __com_sun_star_script_XInvocation_idl__ 
+#include <com/sun/star/script/XInvocation.idl> 
+#endif 
+ 
+ 
+ module com {  module sun {  module star {  module script {  
+ 
+interface XAutomationInvocation: com::sun::star::script::XInvocation
+{ 
+    any invokeGetProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+    any invokePutProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+ 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
diff --git udkapi/com/sun/star/script/XErrorQuery.idl udkapi/com/sun/star/script/XErrorQuery.idl
new file mode 100644
index 0000000..9a1860e
--- /dev/null
+++ udkapi/com/sun/star/script/XErrorQuery.idl
@@ -0,0 +1,25 @@
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#define __com_sun_star_script_XErrorQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+
+interface XErrorQuery : ::com::sun::star::uno::XInterface
+{
+  //-----------------------------------------------------------------------
+  /**
+    Returns whether this object has an error
+
+    @return
+    <atom>boolean</atom> indicating an error or not
+  */
+  boolean hasError();
+
+};
+
+};  };  };  };
+#endif
diff --git udkapi/com/sun/star/script/makefile.mk udkapi/com/sun/star/script/makefile.mk
index 32aa58f..e6f49a9 100644
--- udkapi/com/sun/star/script/makefile.mk
+++ udkapi/com/sun/star/script/makefile.mk
@@ -81,6 +81,8 @@ IDLFILES=\
     XScriptEventsAttacher.idl\
     XDefaultMethod.idl\
     XDefaultProperty.idl\
+	XAutomationInvocation.idl\
+    XErrorQuery.idl\
 
 # ------------------------------------------------------------------
 
diff --git unotools/inc/unotools/fltrcfg.hxx unotools/inc/unotools/fltrcfg.hxx
index 26a1b22..2c948bc 100644
--- unotools/inc/unotools/fltrcfg.hxx
+++ unotools/inc/unotools/fltrcfg.hxx
@@ -48,6 +48,8 @@ public:
 
     void SetLoadWordBasicCode( sal_Bool bFlag );
     sal_Bool IsLoadWordBasicCode() const;
+    void SetLoadWordBasicExecutable( sal_Bool bFlag );
+    sal_Bool IsLoadWordBasicExecutable() const;
     void SetLoadWordBasicStorage( sal_Bool bFlag );
     sal_Bool IsLoadWordBasicStorage() const;
 
diff --git unotools/source/config/fltrcfg.cxx unotools/source/config/fltrcfg.cxx
index 4707b4a..8bf8307 100644
--- unotools/source/config/fltrcfg.cxx
+++ unotools/source/config/fltrcfg.cxx
@@ -61,6 +61,7 @@ using namespace com::sun::star::uno;
 #define FILTERCFG_ENABLE_EXCEL_PREVIEW  0x40000
 #define FILTERCFG_ENABLE_WORD_PREVIEW   0x80000
 #define FILTERCFG_USE_ENHANCED_FIELDS	0x100000
+#define FILTERCFG_WORD_WBCTBL			0x200000
 
 static SvtFilterOptions* pOptions=0;
 
@@ -150,6 +151,52 @@ void	SvtAppFilterOptions_Impl::Load()
 }
 
 // -----------------------------------------------------------------------
+class SvtWriterFilterOptions_Impl : public SvtAppFilterOptions_Impl
+{
+    sal_Bool				bLoadExecutable;
+public:
+    SvtWriterFilterOptions_Impl(const OUString& rRoot) :
+        SvtAppFilterOptions_Impl(rRoot),
+        bLoadExecutable(sal_False)
+    {}
+    virtual void			Commit();
+    void					Load();
+
+    sal_Bool				IsLoadExecutable() const {return bLoadExecutable;}
+    void					SetLoadExecutable(sal_Bool bSet)
+                            {
+                                if(bSet != bLoadExecutable)
+                                    SetModified();
+                                bLoadExecutable = bSet;
+                            }
+};
+
+void SvtWriterFilterOptions_Impl::Commit()
+{
+    SvtAppFilterOptions_Impl::Commit();
+
+    Sequence<OUString> aNames(1);
+    aNames[0] = C2U("Executable");
+    Sequence<Any> aValues(1);
+    aValues[0] <<= bLoadExecutable;
+
+    PutProperties(aNames, aValues);
+}
+
+void SvtWriterFilterOptions_Impl::Load()
+{
+    SvtAppFilterOptions_Impl::Load();
+
+    Sequence<OUString> aNames(1);
+    aNames[0] = C2U("Executable");
+
+    Sequence<Any> aValues = GetProperties(aNames);
+    const Any* pValues = aValues.getConstArray();
+    if(pValues[0].hasValue())
+        bLoadExecutable = *(sal_Bool*)pValues[0].getValue();
+}
+
+// -----------------------------------------------------------------------
 class SvtCalcFilterOptions_Impl : public SvtAppFilterOptions_Impl
 {
     sal_Bool				bLoadExecutable;
@@ -201,7 +248,7 @@ void SvtCalcFilterOptions_Impl::Load()
 struct SvtFilterOptions_Impl
 {
     ULONG nFlags;
-    SvtAppFilterOptions_Impl aWriterCfg;
+    SvtWriterFilterOptions_Impl	aWriterCfg;
     SvtCalcFilterOptions_Impl aCalcCfg;
     SvtAppFilterOptions_Impl aImpressCfg;
 
@@ -246,6 +293,7 @@ void SvtFilterOptions_Impl::SetFlag( ULONG nFlag, BOOL bSet )
     {
         case FILTERCFG_WORD_CODE:		aWriterCfg.SetLoad(bSet);break;
         case FILTERCFG_WORD_STORAGE:	aWriterCfg.SetSave(bSet);break;
+        case FILTERCFG_WORD_WBCTBL:	aWriterCfg.SetLoadExecutable(bSet);break;
         case FILTERCFG_EXCEL_CODE:		aCalcCfg.SetLoad(bSet);break;
         case FILTERCFG_EXCEL_STORAGE:	aCalcCfg.SetSave(bSet);break;
         case FILTERCFG_EXCEL_EXECTBL:	aCalcCfg.SetLoadExecutable(bSet);break;
@@ -268,6 +316,7 @@ BOOL SvtFilterOptions_Impl::IsFlag( ULONG nFlag ) const
     {
         case FILTERCFG_WORD_CODE 		: bRet = aWriterCfg.IsLoad();break;
         case FILTERCFG_WORD_STORAGE   	: bRet = aWriterCfg.IsSave();break;
+        case FILTERCFG_WORD_WBCTBL		: bRet = aWriterCfg.IsLoadExecutable();break;
         case FILTERCFG_EXCEL_CODE 	    : bRet = aCalcCfg.IsLoad();break;
         case FILTERCFG_EXCEL_STORAGE    : bRet = aCalcCfg.IsSave();break;
         case FILTERCFG_EXCEL_EXECTBL	: bRet = aCalcCfg.IsLoadExecutable();break;
@@ -410,6 +459,17 @@ BOOL SvtFilterOptions::IsLoadWordBasicCode() const
     return pImp->IsFlag( FILTERCFG_WORD_CODE );
 }
 
+void SvtFilterOptions::SetLoadWordBasicExecutable( BOOL bFlag )
+{
+    pImp->SetFlag( FILTERCFG_WORD_WBCTBL, bFlag );
+    SetModified();
+}
+
+BOOL SvtFilterOptions::IsLoadWordBasicExecutable() const
+{
+    return pImp->IsFlag( FILTERCFG_WORD_WBCTBL );
+}
+
 void SvtFilterOptions::SetLoadWordBasicStorage( BOOL bFlag )
 {
     pImp->SetFlag( FILTERCFG_WORD_STORAGE, bFlag );
diff --git vbahelper/inc/vbahelper/vbaaccesshelper.hxx vbahelper/inc/vbahelper/vbaaccesshelper.hxx
index cfbe9e7..29c90f2 100644
--- vbahelper/inc/vbahelper/vbaaccesshelper.hxx
+++ vbahelper/inc/vbahelper/vbaaccesshelper.hxx
@@ -71,7 +71,9 @@ namespace ooo
             return bRes;
         }
         VBAHELPER_DLLPUBLIC inline bool isAlienExcelDoc( SfxObjectShell& rDocShell ) { return isAlienDoc( rDocShell, "application/vnd.ms-excel" ); }
-        VBAHELPER_DLLPUBLIC inline bool isAlienWordDoc( SfxObjectShell& rDocShell ) { return isAlienDoc( rDocShell, "application/vnd.ms-word" ); }
+        //VBAHELPER_DLLPUBLIC inline bool isAlienWordDoc( SfxObjectShell& rDocShell ) { return isAlienDoc( rDocShell, "application/vnd.ms-word" ); }
+        // word seems to return an erroneous mime type :-/ "application/msword"  not consistent with the excel one
+        VBAHELPER_DLLPUBLIC inline bool isAlienWordDoc( SfxObjectShell& rDocShell ) { return isAlienDoc( rDocShell, "application/msword" ); }
 
     } // openoffice
 } // org
diff --git vbahelper/inc/vbahelper/vbaapplicationbase.hxx vbahelper/inc/vbahelper/vbaapplicationbase.hxx
index 4ba494f..d1ef76c 100644
--- vbahelper/inc/vbahelper/vbaapplicationbase.hxx
+++ vbahelper/inc/vbahelper/vbaapplicationbase.hxx
@@ -62,7 +62,7 @@ public:
     virtual css::uno::Any SAL_CALL getVBE() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getVBProjects() throw (css::uno::RuntimeException);
 
-    virtual void SAL_CALL Run( const ::rtl::OUString& MacroName, const css::uno::Any& varg1, const css::uno::Any& varg2, const css::uno::Any& varg3, const css::uno::Any& varg4, const css::uno::Any& varg5, const css::uno::Any& varg6, const css::uno::Any& varg7, const css::uno::Any& varg8, const css::uno::Any& varg9, const css::uno::Any& varg10, const css::uno::Any& varg11, const css::uno::Any& varg12, const css::uno::Any& varg13, const css::uno::Any& varg14, const css::uno::Any& varg15, const css::uno::Any& varg16, const css::uno::Any& varg17, const css::uno::Any& varg18, const css::uno::Any& varg19, const css::uno::Any& varg20, const css::uno::Any& varg21, const css::uno::Any& varg22, const css::uno::Any& varg23, const css::uno::Any& varg24, const css::uno::Any& varg25, const css::uno::Any& varg26, const css::uno::Any& varg27, const css::uno::Any& varg28, const css::uno::Any& varg29, const css::uno::Any& varg30 ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Run( const ::rtl::OUString& MacroName, const css::uno::Any& varg1, const css::uno::Any& varg2, const css::uno::Any& varg3, const css::uno::Any& varg4, const css::uno::Any& varg5, const css::uno::Any& varg6, const css::uno::Any& varg7, const css::uno::Any& varg8, const css::uno::Any& varg9, const css::uno::Any& varg10, const css::uno::Any& varg11, const css::uno::Any& varg12, const css::uno::Any& varg13, const css::uno::Any& varg14, const css::uno::Any& varg15, const css::uno::Any& varg16, const css::uno::Any& varg17, const css::uno::Any& varg18, const css::uno::Any& varg19, const css::uno::Any& varg20, const css::uno::Any& varg21, const css::uno::Any& varg22, const css::uno::Any& varg23, const css::uno::Any& varg24, const css::uno::Any& varg25, const css::uno::Any& varg26, const css::uno::Any& varg27, const css::uno::Any& varg28, const css::uno::Any& varg29, const css::uno::Any& varg30 ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL OnTime( const css::uno::Any& aEarliestTime, const ::rtl::OUString& aFunction, const css::uno::Any& aLatestTime, const css::uno::Any& aSchedule ) throw (css::uno::RuntimeException);
     virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Undo() throw (css::uno::RuntimeException);
diff --git vbahelper/inc/vbahelper/vbacollectionimpl.hxx vbahelper/inc/vbahelper/vbacollectionimpl.hxx
index 27ffa25..590b551 100644
--- vbahelper/inc/vbahelper/vbacollectionimpl.hxx
+++ vbahelper/inc/vbahelper/vbacollectionimpl.hxx
@@ -243,12 +243,25 @@ typedef InheritedHelperInterfaceImpl< Ifc1 > BaseColBase;
 protected:
     css::uno::Reference< css::container::XIndexAccess > m_xIndexAccess;
     css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
+    sal_Bool mbIgnoreCase;
 
     virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException)
     {
         if ( !m_xNameAccess.is() )
             throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase string index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
-    
+
+        if( mbIgnoreCase )
+        {
+            css::uno::Sequence< rtl::OUString > sElementNames = m_xNameAccess->getElementNames();
+            for( sal_Int32 i = 0; i < sElementNames.getLength(); i++ )
+            {
+                rtl::OUString aName = sElementNames[i];
+                if( aName.equalsIgnoreAsciiCase( sIndex ) )
+                {
+                    return createCollectionObject( m_xNameAccess->getByName( aName ) );
+                }
+            }
+        }
         return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
     }		
 
@@ -275,7 +288,7 @@ protected:
     }
 
 public:
-    ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ){ m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
+    ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, sal_Bool bIgnoreCase = sal_False ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ), mbIgnoreCase( bIgnoreCase ) { m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
     //XCollection
     virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException)
     {
@@ -340,7 +353,7 @@ class VBAHELPER_DLLPUBLIC CollTestImplHelper :  public ScVbaCollectionBase< ::cp
 typedef ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc >  > ImplBase1;
 
 public:
-    CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess ) {}
+    CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, sal_Bool bIgnoreCase = sal_False ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess, bIgnoreCase ) {}
 };
 
 
diff --git vbahelper/inc/vbahelper/vbadialogbase.hxx vbahelper/inc/vbahelper/vbadialogbase.hxx
index 70bd565..f7fc1ad 100644
--- vbahelper/inc/vbahelper/vbadialogbase.hxx
+++ vbahelper/inc/vbahelper/vbadialogbase.hxx
@@ -44,7 +44,7 @@ public:
     virtual ~VbaDialogBase() {}
 
     // Methods
-    virtual void SAL_CALL Show() throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL Show() throw (css::uno::RuntimeException);
     virtual rtl::OUString mapIndexToName( sal_Int32 nIndex ) = 0;
 };
 
diff --git vbahelper/inc/vbahelper/vbadocumentbase.hxx vbahelper/inc/vbahelper/vbadocumentbase.hxx
index b68eb06..ecde17d 100644
--- vbahelper/inc/vbahelper/vbadocumentbase.hxx
+++ vbahelper/inc/vbahelper/vbadocumentbase.hxx
@@ -58,7 +58,7 @@ public:
     virtual void SAL_CALL Close( const css::uno::Any &bSaveChanges,
                                  const css::uno::Any &aFileName,
                                  const css::uno::Any &bRouteWorkbook ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Unprotect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Save() throw (css::uno::RuntimeException);
     virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
diff --git vbahelper/inc/vbahelper/vbahelper.hxx vbahelper/inc/vbahelper/vbahelper.hxx
index 5383608..8c3aa6a 100644
--- vbahelper/inc/vbahelper/vbahelper.hxx
+++ vbahelper/inc/vbahelper/vbahelper.hxx
@@ -35,6 +35,10 @@
 #include <com/sun/star/lang/IllegalArgumentException.hpp>
 #include <com/sun/star/awt/XControl.hpp>
 #include <com/sun/star/awt/XDevice.hpp>
+#include <com/sun/star/frame/XDispatchResultListener.hpp>
+#include <com/sun/star/frame/DispatchResultEvent.hpp>
+#include <com/sun/star/frame/DispatchResultState.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
 #include <com/sun/star/awt/XUnitConversion.hpp>
 #include <basic/basmgr.hxx>
 #include <basic/sberrors.hxx>
@@ -77,7 +81,7 @@ namespace ooo
         VBAHELPER_DLLPUBLIC css::uno::Reference< css::script::XTypeConverter > getTypeConverter( const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException);
 
         VBAHELPER_DLLPUBLIC void dispatchRequests( const css::uno::Reference< css::frame::XModel>& xModel, const rtl::OUString& aUrl );
-        VBAHELPER_DLLPUBLIC void dispatchRequests( const css::uno::Reference< css::frame::XModel>& xModel, const rtl::OUString& aUrl, const css::uno::Sequence< css::beans::PropertyValue >& sProps );
+	 VBAHELPER_DLLPUBLIC void dispatchRequests (const css::uno::Reference< css::frame::XModel>& xModel, const rtl::OUString & aUrl, const css::uno::Sequence< css::beans::PropertyValue >& sProps, const css::uno::Reference< css::frame::XDispatchResultListener >& rListener = css::uno::Reference< css::frame::XDispatchResultListener >(), const sal_Bool bSilent = sal_True );
         VBAHELPER_DLLPUBLIC void dispatchExecute(SfxViewShell* pView, USHORT nSlot, SfxCallMode nCall = SFX_CALLMODE_SYNCHRON );
         VBAHELPER_DLLPUBLIC sal_Int32 OORGBToXLRGB( sal_Int32 );
         VBAHELPER_DLLPUBLIC sal_Int32 XLRGBToOORGB( sal_Int32 );
@@ -102,6 +106,7 @@ namespace ooo
         VBAHELPER_DLLPUBLIC void setDefaultPropByIntrospection( const css::uno::Any& aObj, const css::uno::Any& aValue  ) throw ( css::uno::RuntimeException );
         VBAHELPER_DLLPUBLIC css::uno::Any getPropertyValue( const css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName );
         VBAHELPER_DLLPUBLIC sal_Bool setPropertyValue( css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName, const css::uno::Any& aValue );
+        VBAHELPER_DLLPUBLIC void setOrAppendPropertyValue( css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName, const css::uno::Any& aValue );
 
 class VBAHELPER_DLLPUBLIC Millimeter
 {
@@ -225,6 +230,25 @@ public:
 
     static void exception( css::uno::Exception& ex ) throw( css::script::BasicErrorException );
 };
+
+class VBAHELPER_DLLPUBLIC VBADispatchListener : public cppu::WeakImplHelper1< css::frame::XDispatchResultListener >
+{
+private:
+	css::uno::Any m_Result;
+	sal_Bool m_State;
+
+public:
+	VBADispatchListener();
+	~VBADispatchListener();
+
+	css::uno::Any getResult() { return m_Result; }
+	sal_Bool getState() { return m_State; }
+
+	// XDispatchResultListener
+	virtual void SAL_CALL dispatchFinished( const css::frame::DispatchResultEvent& aEvent ) throw ( css::uno::RuntimeException );
+	virtual void SAL_CALL disposing( const css::lang::EventObject& aEvent ) throw ( css::uno::RuntimeException );
+};
+
     } // openoffice
 } // org
 
diff --git vbahelper/inc/vbahelper/vbashape.hxx vbahelper/inc/vbahelper/vbashape.hxx
index 8fc2590..bb39d6b 100644
--- vbahelper/inc/vbahelper/vbashape.hxx
+++ vbahelper/inc/vbahelper/vbashape.hxx
@@ -109,6 +109,7 @@ public:
     // Replace??
     virtual void SAL_CALL Select( const css::uno::Any& Replace ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL ShapeRange( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL Copy(  ) throw (css::uno::RuntimeException);
     // XEventListener
     virtual void SAL_CALL disposing( const css::lang::EventObject& rEventObject ) throw( css::uno::RuntimeException );
 };
diff --git vbahelper/inc/vbahelper/vbashaperange.hxx vbahelper/inc/vbahelper/vbashaperange.hxx
index d1bc1e5..97d9f42 100644
--- vbahelper/inc/vbahelper/vbashaperange.hxx
+++ vbahelper/inc/vbahelper/vbashaperange.hxx
@@ -56,6 +56,8 @@ public:
     virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException) ;
     virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
     virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
     virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
@@ -76,6 +78,7 @@ public:
     virtual void SAL_CALL setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL SAL_CALL TextFrame(  ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL SAL_CALL WrapFormat(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ZOrder( sal_Int32 ZOrderCmd ) throw (css::uno::RuntimeException);
     //XEnumerationAccess
     virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException); 
diff --git vbahelper/prj/d.lst vbahelper/prj/d.lst
index 2d20ab1..92b01be 100644
--- vbahelper/prj/d.lst
+++ vbahelper/prj/d.lst
@@ -27,3 +27,4 @@ mkdir: %_DEST%\inc%_EXT%\basic
 ..\inc\vbahelper\vbashaperange.hxx %_DEST%\inc%_EXT%\vbahelper\vbashaperange.hxx
 ..\inc\vbahelper\vbapagesetupbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbapagesetupbase.hxx
 ..\inc\vbahelper\vbaeventshelperbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbaeventshelperbase.hxx
+..\inc\vbahelper\vbaeventshelperbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbaeventshelperbase.hxx
diff --git vbahelper/source/msforms/makefile.mk vbahelper/source/msforms/makefile.mk
index 5fce646..30ce221 100644
--- vbahelper/source/msforms/makefile.mk
+++ vbahelper/source/msforms/makefile.mk
@@ -34,13 +34,10 @@ VISIBILITY_HIDDEN=TRUE
 
 # --- Settings -----------------------------------------------------
 
-.IF "$(ENABLE_VBA)" == "NO"
-dummy:
-    @echo "Nothing to build"
-.ENDIF
-
 .INCLUDE :  settings.mk
 
+CDEFS+=-DVBA_OOBUILD_HACK
+
 SLOFILES=\
     $(SLO)$/vbacontrol.obj \
     $(SLO)$/vbacontrols.obj \
diff --git vbahelper/source/msforms/vbacheckbox.cxx vbahelper/source/msforms/vbacheckbox.cxx
index 15175f0..16f5d16 100644
--- vbahelper/source/msforms/vbacheckbox.cxx
+++ vbahelper/source/msforms/vbacheckbox.cxx
@@ -70,6 +70,8 @@ void SAL_CALL
 ScVbaCheckbox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeException)
 {
     sal_Int16 nValue = 0;
+    sal_Int16 nOldValue = 0;
+    m_xProps->getPropertyValue( STATE ) >>= nOldValue;
     sal_Bool bValue = false;
     if( _value >>= nValue )
     {
@@ -82,6 +84,8 @@ ScVbaCheckbox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeExcept
             nValue = 1;
     }
     m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
+    if ( nValue != nOldValue )
+        fireClickEvent();
 }
 rtl::OUString& 
 ScVbaCheckbox::getServiceImplName()
diff --git vbahelper/source/msforms/vbacheckbox.hxx vbahelper/source/msforms/vbacheckbox.hxx
index d3922d8..b99850b 100644
--- vbahelper/source/msforms/vbacheckbox.hxx
+++ vbahelper/source/msforms/vbacheckbox.hxx
@@ -27,12 +27,12 @@
 #ifndef SC_VBA_CHECKBOX_HXX
 #define SC_VBA_CHECKBOX_HXX
 #include <cppuhelper/implbase2.hxx>
-#include <ooo/vba/msforms/XRadioButton.hpp>
+#include <ooo/vba/msforms/XCheckBox.hpp>
 
 #include "vbacontrol.hxx"
 #include <vbahelper/vbahelper.hxx>
 
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > CheckBoxImpl_BASE;
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XCheckBox, css::script::XDefaultProperty > CheckBoxImpl_BASE;
 
 class ScVbaCheckbox : public CheckBoxImpl_BASE
 {
diff --git vbahelper/source/msforms/vbacombobox.cxx vbahelper/source/msforms/vbacombobox.cxx
index 4dfbf29..5c05894 100644
--- vbahelper/source/msforms/vbacombobox.cxx
+++ vbahelper/source/msforms/vbacombobox.cxx
@@ -26,6 +26,9 @@
  ************************************************************************/
 #include "vbacombobox.hxx"
 #include <vector>
+#include <filter/msfilter/msvbahelper.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
 
 using namespace com::sun::star;
 using namespace ooo::vba;
@@ -63,12 +66,18 @@ ScVbaComboBox::setListIndex( const uno::Any& _value ) throw (uno::RuntimeExcepti
     sal_Int16 nIndex = 0;
     if( _value >>= nIndex )
     {
+        sal_Int32 nOldIndex = -1;
+        getListIndex() >>= nOldIndex;
         uno::Sequence< rtl::OUString > sItems;
         m_xProps->getPropertyValue( ITEMS ) >>= sItems;
         if( ( nIndex >= 0 ) && ( sItems.getLength() > nIndex ) )
         {
             rtl::OUString sText = sItems[ nIndex ];
             m_xProps->setPropertyValue( TEXT, uno::makeAny( sText ) );
+
+            // fire the _Change event
+            if( nOldIndex != nIndex )
+                fireClickEvent();
         }
     }
 }
@@ -103,7 +112,38 @@ ScVbaComboBox::getListIndex() throw (uno::RuntimeException)
 void SAL_CALL 
 ScVbaComboBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
 {
-    m_xProps->setPropertyValue( sSourceName, _value );
+	rtl::OUString sOldValue, sNewValue;
+	getValue() >>= sOldValue;
+
+	uno::Any aConverted = _value;
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+	try
+	{
+		aConverted = xConverter.is() ? xConverter->convertTo( _value, getCppuType( static_cast< const rtl::OUString* >(0) ) ) : aConverted;
+	}
+	catch( const uno::Exception& /*ex*/ )
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Invalid value" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	m_xProps->setPropertyValue( sSourceName, aConverted );
+
+	aConverted >>= sNewValue;
+	if ( sNewValue != sOldValue )
+	{
+		// If the new value is in current list, we should fire click event, otherwise fire the change event.
+		sal_Int32 nListIndex = -1;
+		getListIndex() >>= nListIndex;
+		sal_Bool bIsInList = ( nListIndex >= 0 );
+		if ( bIsInList )
+		{
+			fireClickEvent();
+		}
+		else
+		{
+			fireChangeEvent();
+		}
+	}
 }
 
 // see Value
diff --git vbahelper/source/msforms/vbacontrol.cxx vbahelper/source/msforms/vbacontrol.cxx
index 7485073..046bcb0 100644
--- vbahelper/source/msforms/vbacontrol.cxx
+++ vbahelper/source/msforms/vbacontrol.cxx
@@ -28,6 +28,7 @@
 #include <com/sun/star/awt/XControlModel.hpp>
 #include <com/sun/star/awt/XControl.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
+#include <com/sun/star/awt/XActionListener.hpp>
 #include <com/sun/star/lang/XEventListener.hpp>
 #include <com/sun/star/drawing/XShape.hpp>
 #include <com/sun/star/drawing/XControlShape.hpp>
@@ -39,6 +40,9 @@
 #include <com/sun/star/form/binding/XListEntrySink.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/form/XChangeListener.hpp>
 #include <ooo/vba/XControlProvider.hpp>
 #ifdef VBA_OOBUILD_HACK
 #include <svtools/bindablecontrolhelper.hxx>
@@ -127,7 +131,7 @@ ScVbaControlListener::disposing( const lang::EventObject& ) throw( uno::RuntimeE
 
 //ScVbaControl
 
-ScVbaControl::ScVbaControl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< ::uno::XInterface >& xControl,  const css::uno::Reference< css::frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ControlImpl_BASE( xParent, xContext ),  m_xControl( xControl ), m_xModel( xModel )
+ScVbaControl::ScVbaControl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< ::uno::XInterface >& xControl,  const css::uno::Reference< css::frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ControlImpl_BASE( xParent, xContext ),  bIsDialog(false), m_xControl( xControl ), m_xModel( xModel )
 {
     //add listener
     m_xEventListener.set( new ScVbaControlListener( this ) );
@@ -139,9 +143,18 @@ ScVbaControl::ScVbaControl( const uno::Reference< XHelperInterface >& xParent, c
     uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY ) ;
     uno::Reference< awt::XControl> xUserFormControl( m_xControl, uno::UNO_QUERY ) ;
     if ( xControlShape.is() ) // form control
+    {
         m_xProps.set( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+        rtl::OUString sDefaultControl;
+        m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DefaultControl") ) ) >>= sDefaultControl;
+        uno::Reference< lang::XMultiComponentFactory > xMFac( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+        m_xEmptyFormControl.set( xMFac->createInstanceWithContext( sDefaultControl, mxContext ), uno::UNO_QUERY_THROW );
+    }
     else if ( xUserFormControl.is() ) // userform control
+    {
         m_xProps.set( xUserFormControl->getModel(), uno::UNO_QUERY_THROW );
+        bIsDialog = true;
+    }
 }
 
 ScVbaControl::~ScVbaControl()
@@ -398,6 +411,85 @@ void SAL_CALL ScVbaControl::setTag( const ::rtl::OUString& aTag )
     m_aControlTag = aTag;
 }
 
+::sal_Int32 SAL_CALL ScVbaControl::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	sal_Int32 nForeColor = -1;
+	m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "TextColor" ) ) ) >>= nForeColor; 
+	return OORGBToXLRGB( nForeColor );
+}
+
+void SAL_CALL ScVbaControl::setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException)
+{	
+	 m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "TextColor" ) ), uno::makeAny( XLRGBToOORGB( _forecolor ) ) );
+}
+
+void ScVbaControl::fireEvent( script::ScriptEvent& evt )
+{
+    uno::Reference<lang::XMultiComponentFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< script::XScriptListener > xScriptListener( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.EventListener" ) ), mxContext ), uno::UNO_QUERY_THROW );
+
+    uno::Reference< beans::XPropertySet > xProps( xScriptListener, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) ), uno::makeAny( m_xModel ) );
+
+    // handling for sheet control
+    uno::Reference< msforms::XControl > xThisControl( this );
+    try
+    {
+        evt.Arguments.realloc( 1 );
+        lang::EventObject aEvt;
+    
+        uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY ) ;
+       uno::Reference< awt::XControl > xControl( m_xControl, uno::UNO_QUERY ) ;
+
+        if ( xControlShape.is() )
+        {
+            evt.Source = xControlShape;
+            aEvt.Source = m_xEmptyFormControl;
+            // Set up proper scriptcode
+            uno::Reference< lang::XMultiServiceFactory > xDocFac(  m_xModel, uno::UNO_QUERY_THROW );
+            uno::Reference< document::XCodeNameQuery > xNameQuery(  xDocFac->createInstance( rtl::OUString::createFromAscii( "ooo.vba.VBACodeNameProvider" ) ), uno::UNO_QUERY_THROW );
+            uno::Reference< uno::XInterface > xIf( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+            evt.ScriptCode = xNameQuery->getCodeNameForObject( xIf );
+            evt.Arguments[ 0 ] = uno::makeAny( aEvt );
+            xScriptListener->firing( evt );
+        }
+        else 
+        {
+            if ( xControl.is() ) // normal control ( from dialog/userform )
+            {
+                // #FIXME We should probably store a reference to the 
+                // parent dialog/userform here ( other wise the name of
+                // dialog could be changed and we won't be aware of it.
+                // ( OTOH this is probably an unlikely scenario )
+                evt.Source = xThisControl;
+                aEvt.Source = xControl;
+                evt.ScriptCode = m_sLibraryAndCodeName;
+                evt.Arguments[ 0 ] = uno::makeAny( aEvt );
+                xScriptListener->firing( evt );
+            }
+        }
+    }
+    catch( uno::Exception& e )
+    {
+    }
+}
+void ScVbaControl::fireChangeEvent()
+{
+    script::ScriptEvent evt;
+    evt.ScriptType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAInterop") );
+    evt.ListenerType = form::XChangeListener::static_type(0);
+    evt.MethodName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("changed") );
+    fireEvent( evt ); 
+}
+
+void ScVbaControl::fireClickEvent()
+{
+    script::ScriptEvent evt;
+    evt.ScriptType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAInterop") );
+    evt.ListenerType = awt::XActionListener::static_type(0);
+    evt.MethodName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("actionPerformed") );
+    fireEvent( evt ); 
+}
 
 //ScVbaControlFactory
 
@@ -423,16 +515,25 @@ ScVbaControl* ScVbaControlFactory::createControl(const uno::Reference< drawing::
     const static rtl::OUString sClassId( RTL_CONSTASCII_USTRINGPARAM("ClassId") );
     xProps->getPropertyValue( sClassId ) >>= nClassId;
     uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
-    switch( nClassId )
+    sal_Bool bToggle = sal_False;  //liuchen 2009-8-11,  
+	switch( nClassId )
     {
         case form::FormComponentType::COMBOBOX:
             return new ScVbaComboBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::COMMANDBUTTON:
-            return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::FIXEDTEXT:
+			//liuchen 2009-8-11
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toggle") ) ) >>= bToggle;
+			if ( bToggle )
+				return new ScVbaToggleButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			else
+				return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			//liuchen 2009-8-11
+		case form::FormComponentType::FIXEDTEXT:
             return new ScVbaLabel( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::TEXTFIELD:
             return new ScVbaTextBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::CHECKBOX:
+            return new ScVbaCheckbox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::RADIOBUTTON:
             return new ScVbaRadioButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::LISTBOX:
diff --git vbahelper/source/msforms/vbacontrol.hxx vbahelper/source/msforms/vbacontrol.hxx
index d2631c7..8878102 100644
--- vbahelper/source/msforms/vbacontrol.hxx
+++ vbahelper/source/msforms/vbacontrol.hxx
@@ -34,6 +34,7 @@
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/awt/XControl.hpp>
 #include <com/sun/star/awt/XWindowPeer.hpp>
+#include <com/sun/star/script/ScriptEvent.hpp>
 #include <ooo/vba/msforms/XControl.hpp>
 
 #include <vbahelper/vbahelper.hxx>
@@ -47,17 +48,23 @@ class ScVbaControl : public ControlImpl_BASE
 {
 private:
     com::sun::star::uno::Reference< com::sun::star::lang::XEventListener > m_xEventListener;
+    com::sun::star::uno::Reference< com::sun::star::awt::XControl > m_xEmptyFormControl;
 protected:
     // awt control has nothing similar to Tag property of Mso controls,
     // whether it is necessary is another question
     ::rtl::OUString m_aControlTag;
 
+    bool bIsDialog;
+    rtl::OUString m_sLibraryAndCodeName;
     std::auto_ptr< ov::AbstractGeometryAttributes > mpGeometryHelper;
     css::uno::Reference< css::beans::XPropertySet > m_xProps;
     css::uno::Reference< css::uno::XInterface > m_xControl;
     css::uno::Reference< css::frame::XModel > m_xModel;
 
     virtual css::uno::Reference< css::awt::XWindowPeer > getWindowPeer() throw (css::uno::RuntimeException);
+    void fireChangeEvent();
+    void fireClickEvent();
+    void fireEvent( css::script::ScriptEvent& evt );
 public:
     ScVbaControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, 
                     const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pHelper );
@@ -65,6 +72,10 @@ public:
     // This class will own the helper, so make sure it is allocated from 
     // the heap
     void setGeometryHelper( ov::AbstractGeometryAttributes* pHelper );
+    // sets the name of the associated library ( used for UserForm controls )
+    void setLibraryAndCodeName( const rtl::OUString& sLibCodeName ) { m_sLibraryAndCodeName = sLibCodeName; }
+    rtl::OUString getLibraryAndCodeName() { return m_sLibraryAndCodeName; }
+
     // XControl
     virtual sal_Bool SAL_CALL getEnabled() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnabled( sal_Bool _enabled ) throw (css::uno::RuntimeException);
@@ -94,6 +105,8 @@ public:
     virtual void SAL_CALL setTag( const ::rtl::OUString& aTag ) throw (css::uno::RuntimeException);
     //remove resouce because ooo.vba.excel.XControl is a wrapper of com.sun.star.drawing.XControlShape
     virtual void removeResouce() throw( css::uno::RuntimeException );
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git vbahelper/source/msforms/vbaframe.cxx vbahelper/source/msforms/vbaframe.cxx
index 3c202f1..79e0b00 100644
--- vbahelper/source/msforms/vbaframe.cxx
+++ vbahelper/source/msforms/vbaframe.cxx
@@ -64,6 +64,30 @@ ScVbaFrame::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::Run
     _value >>= sCaption;
     setCaption( sCaption ); 
 }
+//liuchen 2009-7-6 
+::sal_Int32 SAL_CALL ScVbaFrame::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	return 0;
+}
+
+void SAL_CALL ScVbaFrame::setForeColor( ::sal_Int32 /*_forecolor*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	return;
+}
+//liuchen 2009-7-6 end
+
+rtl::OUString SAL_CALL 
+ScVbaFrame::getAccelerator() throw (css::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+	return rtl::OUString();
+}
+
+void SAL_CALL 
+ScVbaFrame::setAccelerator( const rtl::OUString& /*_accelerator*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+}
 
 rtl::OUString& 
 ScVbaFrame::getServiceImplName()
diff --git vbahelper/source/msforms/vbaframe.hxx vbahelper/source/msforms/vbaframe.hxx
index c55a41b..f5d49aa 100644
--- vbahelper/source/msforms/vbaframe.hxx
+++ vbahelper/source/msforms/vbaframe.hxx
@@ -43,6 +43,12 @@ public:
     virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	//liuchen 2009-7-6 
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
+	//liuchen 2009-7-6 end
+	virtual rtl::OUString SAL_CALL getAccelerator() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAccelerator( const rtl::OUString& _accelerator ) throw (css::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git vbahelper/source/msforms/vbalabel.cxx vbahelper/source/msforms/vbalabel.cxx
index 5fb6ebe..d50f2e3 100644
--- vbahelper/source/msforms/vbalabel.cxx
+++ vbahelper/source/msforms/vbalabel.cxx
@@ -64,6 +64,18 @@ ScVbaLabel::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::Run
     setCaption( sCaption ); 
 }
 
+rtl::OUString SAL_CALL 
+ScVbaLabel::getAccelerator() throw (css::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+	return rtl::OUString();
+}
+
+void SAL_CALL 
+ScVbaLabel::setAccelerator( const rtl::OUString& /*_accelerator*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+}
 
 rtl::OUString& 
 ScVbaLabel::getServiceImplName()
diff --git vbahelper/source/msforms/vbalabel.hxx vbahelper/source/msforms/vbalabel.hxx
index fd6b1c1..ff7822f 100644
--- vbahelper/source/msforms/vbalabel.hxx
+++ vbahelper/source/msforms/vbalabel.hxx
@@ -44,6 +44,8 @@ public:
     virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	virtual rtl::OUString SAL_CALL getAccelerator() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAccelerator( const rtl::OUString& _accelerator ) throw (css::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
diff --git vbahelper/source/msforms/vbalistbox.cxx vbahelper/source/msforms/vbalistbox.cxx
index 8538fc2..437a95b 100644
--- vbahelper/source/msforms/vbalistbox.cxx
+++ vbahelper/source/msforms/vbalistbox.cxx
@@ -108,9 +108,13 @@ ScVbaListBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
                     "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
 
     uno::Sequence< sal_Int16 > nSelectedIndices(1);
+    uno::Sequence< sal_Int16 > nOldSelectedIndices;
+    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= nOldSelectedIndices;
     nSelectedIndices[ 0 ] = nValue;
     m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nSelectedIndices ) ); 
-    m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) ); 
+    if ( nSelectedIndices != nOldSelectedIndices )
+        fireClickEvent();
+	//m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) );   //liuchen 2009-8-12 solve the problem that ListBox.Text and ListBox.Value cannot be set
 }
 
 ::rtl::OUString SAL_CALL 
@@ -127,20 +131,22 @@ ScVbaListBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeExcepti
     setValue( uno::makeAny( _text ) ); // seems the same
 }
 
-sal_Bool SAL_CALL 
+sal_Int32 SAL_CALL 
 ScVbaListBox::getMultiSelect() throw (css::uno::RuntimeException)
 {
     sal_Bool bMultiSelect = sal_False;
     m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ) ) >>= bMultiSelect;
-    return bMultiSelect;
+    return bMultiSelect ? 1 : 0 ;
 }
 
 void SAL_CALL 
-ScVbaListBox::setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException)
+ScVbaListBox::setMultiSelect( sal_Int32 _multiselect ) throw (css::uno::RuntimeException)
 {
-    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( _multiselect ) );
+	sal_Bool bMultiSelect = _multiselect == 1 ? 1 : 0;
+    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( bMultiSelect ) );
 }
 
+
 css::uno::Any SAL_CALL 
 ScVbaListBox::Selected( sal_Int32 index ) throw (css::uno::RuntimeException)
 {
@@ -205,6 +211,7 @@ ScVbaListBox::setValueEvent( const uno::Any& value )
                 }
                 nList.realloc( nLength - 1 );
                 //m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
+                fireClickEvent();
         m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nList ) );
                 return;
             }
@@ -223,6 +230,7 @@ ScVbaListBox::setValueEvent( const uno::Any& value )
             nList[0] = nIndex;
         }
         //m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
+        fireClickEvent();
         m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nList ) );
     }
 }
diff --git vbahelper/source/msforms/vbalistbox.hxx vbahelper/source/msforms/vbalistbox.hxx
index 01c53d1..d540102 100644
--- vbahelper/source/msforms/vbalistbox.hxx
+++ vbahelper/source/msforms/vbalistbox.hxx
@@ -58,8 +58,8 @@ public:
     virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);  //liuchen 2009-7-31
+    virtual void SAL_CALL setMultiSelect( ::sal_Int32 _multiselect ) throw (css::uno::RuntimeException); //liuchen 2009-7-31
     virtual css::uno::Any SAL_CALL Selected( ::sal_Int32 index ) throw (css::uno::RuntimeException);
 
     // Methods
diff --git vbahelper/source/msforms/vbalistcontrolhelper.cxx vbahelper/source/msforms/vbalistcontrolhelper.cxx
index 36683ae..977fdde 100644
--- vbahelper/source/msforms/vbalistcontrolhelper.cxx
+++ vbahelper/source/msforms/vbalistcontrolhelper.cxx
@@ -1,11 +1,69 @@
 #include <vbalistcontrolhelper.hxx>
 #include <vector>
+#include <vbahelper/vbapropvalue.hxx>
 
 using namespace com::sun::star;
 using namespace ooo::vba;
 
 const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
 
+class ListPropListener : public PropListener
+{
+private:
+    uno::Reference< beans::XPropertySet > m_xProps;
+    uno::Any m_pvargIndex; 
+    uno::Any m_pvarColumn;
+
+public:
+    ListPropListener( const uno::Reference< beans::XPropertySet >& xProps, const uno::Any& pvargIndex, const uno::Any& pvarColumn );
+    virtual void setValueEvent( const css::uno::Any& value );
+    virtual css::uno::Any getValueEvent();
+};
+
+ListPropListener::ListPropListener( const uno::Reference< beans::XPropertySet >& xProps, const uno::Any& pvargIndex, const uno::Any& pvarColumn ) : m_xProps( xProps ), m_pvargIndex( pvargIndex ), m_pvarColumn( pvarColumn )
+{
+}
+
+void ListPropListener::setValueEvent( const uno::Any& value )
+{
+    if( m_pvargIndex.hasValue() || m_pvarColumn.hasValue() )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                "Bad argument" ), uno::Reference< uno::XInterface >() );       
+
+    m_xProps->setPropertyValue( ITEMS, value );
+}
+
+uno::Any ListPropListener::getValueEvent()
+{
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
+    uno::Any aRet;
+    if ( m_pvargIndex.hasValue() )
+    {
+        sal_Int16 nIndex = -1;
+        m_pvargIndex >>= nIndex;
+        if( nIndex < 0 || nIndex >= nLength )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
+        aRet <<= sList[ nIndex ];
+    }
+    else if ( m_pvarColumn.hasValue() ) // pvarColumn on its own would be bad
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
+    else // List() ( e.g. no args )
+    {
+        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
+        for ( sal_Int32 i = 0; i < nLength; ++i )
+        {
+            sReturnArray[ i ].realloc( 10 );
+            sReturnArray[ i ][ 0 ] = sList[ i ];
+        }        
+        aRet = uno::makeAny( sReturnArray );
+    }
+    return aRet;
+}
+
 void SAL_CALL 
 ListControlHelper::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
 {
@@ -116,31 +174,5 @@ ListControlHelper::getListCount() throw (uno::RuntimeException)
 uno::Any SAL_CALL 
 ListControlHelper::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
 {
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
-    uno::Any aRet;
-    if ( pvargIndex.hasValue() )
-    {
-        sal_Int16 nIndex = -1;
-        pvargIndex >>= nIndex;
-        if( nIndex < 0 || nIndex >= nLength )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
-        aRet <<= sList[ nIndex ];
-    }
-    else if ( pvarColumn.hasValue() ) // pvarColumn on its own would be bad
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
-    else // List() ( e.g. no args )
-    {
-        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
-        for ( sal_Int32 i = 0; i < nLength; ++i )
-        {
-            sReturnArray[ i ].realloc( 10 );
-            sReturnArray[ i ][ 0 ] = sList[ i ];
-        }        
-        aRet = uno::makeAny( sReturnArray );
-    }
-    return aRet;
+    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( new ListPropListener( m_xProps, pvargIndex, pvarColumn ) ) ) );
 }
diff --git vbahelper/source/msforms/vbamultipage.cxx vbahelper/source/msforms/vbamultipage.cxx
index 4cdf220..8b3592c 100644
--- vbahelper/source/msforms/vbamultipage.cxx
+++ vbahelper/source/msforms/vbamultipage.cxx
@@ -88,8 +88,12 @@ void SAL_CALL
 ScVbaMultiPage::setValue( const sal_Int32 _value ) throw (::com::sun::star::uno::RuntimeException)
 {
     // track change in dialog ( dialog value is 1 based, 0 is a special value )
+    sal_Int32 nVal = _value; // will be _value + 1 when cws container_controls is integrated
+    sal_Int32 nOldVal = getValue();
     m_xProps->setPropertyValue( SVALUE, uno::makeAny( _value ) );
     mxDialogProps->setPropertyValue( SSTEP, uno::makeAny( _value + 1) );
+    if ( nVal != nOldVal )
+        fireChangeEvent();
 }
 
 
diff --git vbahelper/source/msforms/vbaradiobutton.cxx vbahelper/source/msforms/vbaradiobutton.cxx
index 3853f38..f8d6e21 100644
--- vbahelper/source/msforms/vbaradiobutton.cxx
+++ vbahelper/source/msforms/vbaradiobutton.cxx
@@ -70,6 +70,9 @@ void SAL_CALL
 ScVbaRadioButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
 {
     sal_Int16 nValue = 0;
+    sal_Int16 nOldValue = 0;
+    m_xProps->getPropertyValue( STATE ) >>= nOldValue;
+
     sal_Bool bValue = sal_False;
     if( _value >>= nValue )
     {
@@ -82,6 +85,15 @@ ScVbaRadioButton::setValue( const uno::Any& _value ) throw (uno::RuntimeExceptio
             nValue = 1;
     }
     m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
+    if ( nValue != nOldValue )
+    {
+        fireChangeEvent();
+        // In Excel, only when the radio button is checked, the click event is fired.
+        if ( nValue != 0 )
+        {
+            fireClickEvent();
+        }
+    }
 }
 
 rtl::OUString& 
diff --git vbahelper/source/msforms/vbatextbox.cxx vbahelper/source/msforms/vbatextbox.cxx
index 730f24c..be6e348 100644
--- vbahelper/source/msforms/vbatextbox.cxx
+++ vbahelper/source/msforms/vbatextbox.cxx
@@ -67,13 +67,20 @@ ScVbaTextBox::getText() throw (css::uno::RuntimeException)
 void SAL_CALL 
 ScVbaTextBox::setText( const rtl::OUString& _text ) throw (css::uno::RuntimeException)
 {
+    rtl::OUString sOldText = getText();
+
     if ( !mbDialog )
     {
-    uno::Reference< text::XTextRange > xTextRange( m_xProps, uno::UNO_QUERY_THROW );
-    xTextRange->setString( _text );
-}
+        uno::Reference< text::XTextRange > xTextRange( m_xProps, uno::UNO_QUERY_THROW );
+        xTextRange->setString( _text );
+    }
     else
         m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Text") ), uno::makeAny( _text ) ); 
+
+    if ( _text != sOldText )
+    {
+        fireChangeEvent();
+    }
 }
 
 sal_Int32 SAL_CALL 
@@ -90,7 +97,8 @@ ScVbaTextBox::getMaxLength() throw (css::uno::RuntimeException)
 void SAL_CALL 
 ScVbaTextBox::setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException)
 {
-    uno::Any aValue( _maxlength );
+	sal_Int16 _maxlength16 = static_cast<sal_Int16> (_maxlength); //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
+    uno::Any aValue( _maxlength16 );                              //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
     m_xProps->setPropertyValue
             (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ), aValue);
 }
diff --git vbahelper/source/msforms/vbatogglebutton.cxx vbahelper/source/msforms/vbatogglebutton.cxx
index d16fab9..f5abb73 100644
--- vbahelper/source/msforms/vbatogglebutton.cxx
+++ vbahelper/source/msforms/vbatogglebutton.cxx
@@ -68,16 +68,33 @@ ScVbaToggleButton::getValue() throw (uno::RuntimeException)
      return uno::makeAny( nState ? sal_Int16( -1 ) : sal_Int16( 0 ) );
 }
 
+//liuchen 2009-7-23, resolve the defect that ToggleButton.Value cannot be set correctly
 void SAL_CALL 
 ScVbaToggleButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
 {
     sal_Int16 nState = 0;
-    _value >>= nState;
+	if (_value.getValueTypeClass() == uno::TypeClass_BOOLEAN)
+	{
+		sal_Bool bValue;
+		_value >>= bValue;
+		nState = static_cast< sal_Int16 >(bValue);
+	}
+	else if (_value.getValueTypeClass() == uno::TypeClass_BYTE)
+	{
+		sal_Int8 nValue;
+		_value >>= nValue;
+		nState = ( nValue == 1) ? 1 : 0;
+	}
+	else
+	{
+		_value >>= nState;
         OSL_TRACE( "nState - %d", nState );
-    nState = ( nState == -1 ) ?  1 : 0;
+		nState = ( nState == -1 ) ?  1 : 0;
         OSL_TRACE( "nState - %d", nState );
+	}
     m_xProps->setPropertyValue( STATE, uno::makeAny(  nState ) );
 }
+//liuchen 2009-7-23
 
 rtl::OUString& 
 ScVbaToggleButton::getServiceImplName()
diff --git vbahelper/source/msforms/vbauserform.cxx vbahelper/source/msforms/vbauserform.cxx
index 12422bc..5218610 100644
--- vbahelper/source/msforms/vbauserform.cxx
+++ vbahelper/source/msforms/vbauserform.cxx
@@ -53,6 +53,8 @@ ScVbaUserForm::ScVbaUserForm( uno::Sequence< uno::Any > const& aArgs, uno::Refer
     uno::Reference< awt::XControl > xControl( m_xDialog, uno::UNO_QUERY_THROW );
     m_xProps.set( xControl->getModel(), uno::UNO_QUERY_THROW );
     setGeometryHelper( new UserFormGeometryHelper( xContext, xControl ) );
+    if ( aArgs.getLength() >= 4 )
+        aArgs[ 3 ] >>= m_sLibName;
 }
 
 ScVbaUserForm::~ScVbaUserForm()
@@ -181,9 +181,11 @@ ScVbaUserForm::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::Un
         uno::Reference< awt::XControlContainer > xContainer( m_xDialog, uno::UNO_QUERY_THROW );
         uno::Reference< awt::XControl > xControl = xContainer->getControl( aPropertyName );
         ScVbaControlFactory aFac( mxContext, xControl, m_xModel );
-            uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( xDialogControl->getModel() ) );
-            ScVbaControl* pControl  = dynamic_cast< ScVbaControl* >( xVBAControl.get() );
-            pControl->setGeometryHelper( new UserFormGeometryHelper( mxContext, xControl ) );
+        uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( xDialogControl->getModel() ) );
+        ScVbaControl* pControl  = dynamic_cast< ScVbaControl* >( xVBAControl.get() );
+        pControl->setGeometryHelper( new UserFormGeometryHelper( mxContext, xControl ) );
+        if ( m_sLibName.getLength() )
+            pControl->setLibraryAndCodeName( m_sLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "." ) ) ).concat( getName() ) );
         aResult = uno::makeAny( xVBAControl );
     }
 
diff --git vbahelper/source/msforms/vbauserform.hxx vbahelper/source/msforms/vbauserform.hxx
index 463a3cb..fc55bb3 100644
--- vbahelper/source/msforms/vbauserform.hxx
+++ vbahelper/source/msforms/vbauserform.hxx
@@ -43,6 +43,7 @@ class ScVbaUserForm : public ScVbaUserForm_BASE
 private:
     css::uno::Reference< css::awt::XDialog > m_xDialog;
     bool mbDispose;
+    rtl::OUString m_sLibName;
 protected:
 public:
     ScVbaUserForm( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext ) throw ( css::lang::IllegalArgumentException );
diff --git vbahelper/source/vbahelper/makefile.mk vbahelper/source/vbahelper/makefile.mk
index 22ed40a..31fefa8 100644
--- vbahelper/source/vbahelper/makefile.mk
+++ vbahelper/source/vbahelper/makefile.mk
@@ -33,11 +33,6 @@ ENABLE_EXCEPTIONS := TRUE
 VISIBILITY_HIDDEN=TRUE
 # --- Settings -----------------------------------------------------
 
-.IF "$(ENABLE_VBA)" == "NO"
-dummy:
-    @echo "Nothing to build"
-.ENDIF
-
 .INCLUDE :  settings.mk
 
 SLOFILES=\
diff --git vbahelper/source/vbahelper/vbaapplicationbase.cxx vbahelper/source/vbahelper/vbaapplicationbase.cxx
index 57e3038..bb12c44 100644
--- vbahelper/source/vbahelper/vbaapplicationbase.cxx
+++ vbahelper/source/vbahelper/vbaapplicationbase.cxx
@@ -200,6 +200,8 @@ void SAL_CALL
 VbaApplicationBase::setScreenUpdating(sal_Bool bUpdate) throw (uno::RuntimeException)
 {
     uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	if( bUpdate != xModel->hasControllersLocked() )
+		return;
     if (bUpdate)
         xModel->unlockControllers();
     else
@@ -293,7 +295,7 @@ VbaApplicationBase::getVersion() throw (uno::RuntimeException)
     return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(OFFICEVERSION));
 }
 
-void SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const uno::Any& varg1, const uno::Any& varg2, const uno::Any& varg3, const uno::Any& varg4, const uno::Any& varg5, const uno::Any& varg6, const uno::Any& varg7, const uno::Any& varg8, const uno::Any& varg9, const uno::Any& varg10, const uno::Any& varg11, const uno::Any& varg12, const uno::Any& varg13, const uno::Any& varg14, const uno::Any& varg15, const uno::Any& varg16, const uno::Any& varg17, const uno::Any& varg18, const uno::Any& varg19, const uno::Any& varg20, const uno::Any& varg21, const uno::Any& varg22, const uno::Any& varg23, const uno::Any& varg24, const uno::Any& varg25, const uno::Any& varg26, const uno::Any& varg27, const uno::Any& varg28, const uno::Any& varg29, const uno::Any& varg30 ) throw (uno::RuntimeException)
+uno::Any SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const uno::Any& varg1, const uno::Any& varg2, const uno::Any& varg3, const uno::Any& varg4, const uno::Any& varg5, const uno::Any& varg6, const uno::Any& varg7, const uno::Any& varg8, const uno::Any& varg9, const uno::Any& varg10, const uno::Any& varg11, const uno::Any& varg12, const uno::Any& varg13, const uno::Any& varg14, const uno::Any& varg15, const uno::Any& varg16, const uno::Any& varg17, const uno::Any& varg18, const uno::Any& varg19, const uno::Any& varg20, const uno::Any& varg21, const uno::Any& varg22, const uno::Any& varg23, const uno::Any& varg24, const uno::Any& varg25, const uno::Any& varg26, const uno::Any& varg27, const uno::Any& varg28, const uno::Any& varg29, const uno::Any& varg30 ) throw (uno::RuntimeException)
 {
     ::rtl::OUString sSeparator = ::rtl::OUString::createFromAscii("/");
     ::rtl::OUString sMacroSeparator = ::rtl::OUString::createFromAscii("!");
@@ -342,7 +344,8 @@ void SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const u
     }
 
     
-    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( aMacroDocumentModel ), sMacro_only_Name );
+    // search the global tempalte
+    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( aMacroDocumentModel ), sMacro_only_Name, sal_True );
     if( aMacroInfo.IsResolved() )
     {
         // handle the arguments
@@ -370,6 +373,8 @@ void SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const u
         uno::Any aRet;
         uno::Any aDummyCaller;
         executeMacro( aMacroInfo.MacroDocContext(), aMacroInfo.ResolvedMacro(), aArgs, aRet, aDummyCaller );
+
+        return aRet;
     }
     else
     {
diff --git vbahelper/source/vbahelper/vbadialogbase.cxx vbahelper/source/vbahelper/vbadialogbase.cxx
index ec7ecae..472b2b4 100644
--- vbahelper/source/vbahelper/vbadialogbase.cxx
+++ vbahelper/source/vbahelper/vbadialogbase.cxx
@@ -30,11 +30,10 @@
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-// fails silently
-void
-VbaDialogBase::Show() throw(uno::RuntimeException)
+sal_Bool SAL_CALL VbaDialogBase::Show() throw ( uno::RuntimeException )
 {
     rtl::OUString aURL;
+	sal_Bool bSuccess = sal_False;
     if ( m_xModel.is() )
     {
         aURL = mapIndexToName( mnIndex );
@@ -42,7 +41,26 @@ VbaDialogBase::Show() throw(uno::RuntimeException)
             throw uno::RuntimeException(
                 ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Unable to open the specified dialog " ) ),
                 uno::Reference< XInterface > () );
-        dispatchRequests( m_xModel, aURL );
-    }
-}	
 
+		uno::Sequence< beans::PropertyValue > dispatchProps(0);
+		if ( aURL.equalsAscii(".uno:PrinterSetup") )
+		{
+			dispatchProps.realloc(1);
+			dispatchProps[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADialogResultRequest" ) );
+			dispatchProps[0].Value <<= (sal_Bool) sal_True;
+		}
+
+		VBADispatchListener *pNotificationListener = new VBADispatchListener();
+		uno::Reference< frame::XDispatchResultListener > rListener = pNotificationListener;
+		dispatchRequests( m_xModel, aURL, dispatchProps, rListener, sal_False );
+
+		bSuccess = pNotificationListener->getState();
+		uno::Any aResult = pNotificationListener->getResult();
+		if ( bSuccess )
+		{
+			if ( aResult.getValueTypeClass() == uno::TypeClass_BOOLEAN )
+				aResult >>= bSuccess;
+		}
+    }
+	return bSuccess;
+}
diff --git vbahelper/source/vbahelper/vbadocumentbase.cxx vbahelper/source/vbahelper/vbadocumentbase.cxx
index 0eba699..49692e1 100644
--- vbahelper/source/vbahelper/vbadocumentbase.cxx
+++ vbahelper/source/vbahelper/vbadocumentbase.cxx
@@ -33,6 +33,7 @@
 #include <com/sun/star/util/XCloseable.hpp>
 #include <com/sun/star/frame/XStorable.hpp>
 #include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XTitle.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp> //Michael E. Bohn
 #include <com/sun/star/beans/XPropertySet.hpp>
 
@@ -68,13 +69,8 @@ VbaDocumentBase::getName() throw (uno::RuntimeException)
     }
     else
     {
-        const static rtl::OUString sTitle( RTL_CONSTASCII_USTRINGPARAM("Title" ) );
-        // process "UntitledX - $(PRODUCTNAME)"
-        uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-        uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
-        xProps->getPropertyValue(sTitle ) >>= sName;
-        sal_Int32 pos = 0;
-        sName = sName.getToken(0,' ',pos);	
+		uno::Reference< frame::XTitle > xTitle( getModel(), uno::UNO_QUERY_THROW );
+		sName = xTitle->getTitle();
     }
     return sName;
 }
@@ -130,12 +126,20 @@ VbaDocumentBase::Close( const uno::Any &rSaveArg, const uno::Any &rFileArg,
     uno::Reference< util::XCloseable > xCloseable( getModel(), uno::UNO_QUERY );
 
     if( xCloseable.is() )
+	{
         // use close(boolean DeliverOwnership)
     
         // The boolean parameter DeliverOwnership tells objects vetoing the close process that they may
         // assume ownership if they object the closure by throwing a CloseVetoException
         // Here we give up ownership. To be on the safe side, catch possible veto exception anyway.
-        xCloseable->close(sal_True);
+		try{
+			xCloseable->close(sal_True);
+		}
+		catch( util::CloseVetoException )
+		{
+			//close is cancelled, nothing to do
+		}
+	}
     // If close is not supported by this model - try to dispose it.
     // But if the model disagree with a reset request for the modify state
     // we shouldn't do so. Otherwhise some strange things can happen.
@@ -143,7 +147,16 @@ VbaDocumentBase::Close( const uno::Any &rSaveArg, const uno::Any &rFileArg,
     {
         uno::Reference< lang::XComponent > xDisposable ( getModel(), uno::UNO_QUERY );
         if ( xDisposable.is() )
-            xDisposable->dispose();
+        {
+            // To be on the safe side, catch possible veto exception anyway.
+            try
+            {
+			    xDisposable->dispose();
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }    
     }
 }
 
diff --git vbahelper/source/vbahelper/vbadocumentsbase.cxx vbahelper/source/vbahelper/vbadocumentsbase.cxx
index 61cdb52..d3eb535 100644
--- vbahelper/source/vbahelper/vbadocumentsbase.cxx
+++ vbahelper/source/vbahelper/vbadocumentsbase.cxx
@@ -34,6 +34,7 @@
 #include <com/sun/star/lang/XComponent.hpp>
 #include <com/sun/star/frame/XModel.hpp>
 #include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XTitle.hpp>
 #include <com/sun/star/frame/FrameSearchFlag.hpp>
 #include <com/sun/star/util/XModifiable.hpp>
 #include <com/sun/star/frame/XStorable.hpp>
@@ -143,8 +144,18 @@ public:
             {
                 uno::Reference< frame::XModel > xModel( xServiceInfo, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
                 m_documents.push_back( xModel );
-                INetURLObject aURL( xModel->getURL() );
-                namesToIndices[ aURL.GetLastName() ] = nIndex++;
+                rtl::OUString sName = xModel->getURL();
+                if( sName.getLength() )
+                {
+				    INetURLObject aURL( xModel->getURL() );
+				    namesToIndices[ aURL.GetLastName() ] = nIndex++;
+                }    
+                else
+                {
+                    uno::Reference< frame::XTitle > xTitle( xModel, uno::UNO_QUERY_THROW );
+                    sName = xTitle->getTitle();
+                    namesToIndices[ sName ] = nIndex++;
+                }
             }
         }
             
diff --git vbahelper/source/vbahelper/vbahelper.cxx vbahelper/source/vbahelper/vbahelper.cxx
index 86d8e47..b3c904e 100644
--- vbahelper/source/vbahelper/vbahelper.cxx
+++ vbahelper/source/vbahelper/vbahelper.cxx
@@ -32,6 +32,7 @@
 #include <com/sun/star/frame/XDesktop.hpp>
 #include <com/sun/star/frame/XController.hpp>
 #include <com/sun/star/frame/XModel2.hpp>
+#include <com/sun/star/frame/XNotifyingDispatch.hpp>
 #include <com/sun/star/script/XDefaultProperty.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/lang/XMultiComponentFactory.hpp>
@@ -311,7 +312,7 @@ void dispatchExecute(SfxViewShell* pViewShell, USHORT nSlot, SfxCallMode nCall)
 }
     
 void
-dispatchRequests( const uno::Reference< frame::XModel>& xModel, const rtl::OUString& aUrl, const uno::Sequence< beans::PropertyValue >& sProps )
+dispatchRequests (const uno::Reference< frame::XModel>& xModel, const rtl::OUString & aUrl, const uno::Sequence< beans::PropertyValue >& sProps, const uno::Reference< frame::XDispatchResultListener >& rListener, const sal_Bool bSilent )
 {
     util::URL url;
     url.Complete = aUrl;
@@ -343,6 +344,7 @@ dispatchRequests( const uno::Reference< frame::XModel>& xModel, const rtl::OUStr
     }
 
     uno::Reference<frame::XDispatch> xDispatcher = xDispatchProvider->queryDispatch(url,emptyString,0);
+	uno::Reference< frame::XNotifyingDispatch > xNotifyingDispatcher( xDispatcher, uno::UNO_QUERY );
 
     uno::Sequence<beans::PropertyValue> dispatchProps(1);
 
@@ -358,11 +360,20 @@ dispatchRequests( const uno::Reference< frame::XModel>& xModel, const rtl::OUStr
             *pDest = *pSrc;
     }
 
-    (*pDest).Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Silent" ));
-    (*pDest).Value <<= (sal_Bool)sal_True;
+	if ( bSilent )
+	{
+		(*pDest).Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Silent" ));
+		(*pDest).Value <<= (sal_Bool)sal_True;
+	}
 
-    if (xDispatcher.is())
+	if ( !rListener.is() && xDispatcher.is() )
+	{
         xDispatcher->dispatch( url, dispatchProps );
+	}
+	else if ( rListener.is() && xNotifyingDispatcher.is() )
+	{
+		xNotifyingDispatcher->dispatchWithNotification( url, dispatchProps, rListener );
+	}
 }
 
 void
@@ -962,6 +973,18 @@ sal_Bool setPropertyValue( uno::Sequence< beans::PropertyValue >& aProp, const r
     return sal_False;
 }
 
+void setOrAppendPropertyValue( uno::Sequence< beans::PropertyValue >& aProp, const rtl::OUString& aName, const uno::Any& aValue )
+{
+   if( setPropertyValue( aProp, aName, aValue ) )
+    return;
+  
+  // append the property
+  sal_Int32 nLength = aProp.getLength();
+  aProp.realloc( nLength + 1 );
+  aProp[ nLength ].Name = aName;
+  aProp[ nLength ].Value = aValue;
+}
+
 // ====UserFormGeomentryHelper====
 //---------------------------------------------
 UserFormGeometryHelper::UserFormGeometryHelper( const uno::Reference< uno::XComponentContext >& /*xContext*/, const uno::Reference< awt::XControl >& xControl )
@@ -1424,6 +1447,28 @@ void UserFormGeometryHelper::setHeight( double nHeight )
             return xIf;
         }
 
+	// Listener for XNotifyingDispatch
+	VBADispatchListener::VBADispatchListener() : m_State( sal_False )
+	{
+	}
+
+	// Listener for XNotifyingDispatch
+	VBADispatchListener::~VBADispatchListener()
+	{
+	}
+
+	// Listener for XNotifyingDispatch
+	void SAL_CALL VBADispatchListener::dispatchFinished( const frame::DispatchResultEvent& aEvent ) throw ( uno::RuntimeException )
+	{
+		m_Result = aEvent.Result;
+		m_State = ( aEvent.State == frame::DispatchResultState::SUCCESS ) ? sal_True : sal_False;
+	}
+
+	// Listener for XNotifyingDispatch
+	void SAL_CALL VBADispatchListener::disposing( const lang::EventObject& /*aEvent*/ ) throw( uno::RuntimeException )
+	{
+	}
+
         SfxObjectShell* getSfxObjShell( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
         {
             SfxObjectShell* pFoundShell = NULL;
diff --git vbahelper/source/vbahelper/vbapictureformat.cxx vbahelper/source/vbahelper/vbapictureformat.cxx
index bcdf83a..71fe406 100644
--- vbahelper/source/vbahelper/vbapictureformat.cxx
+++ vbahelper/source/vbahelper/vbapictureformat.cxx
@@ -112,13 +112,14 @@ ScVbaPictureFormat::IncrementContrast( double increment ) throw (uno::RuntimeExc
 {
     double nContrast = getContrast();
     nContrast += increment;
-    if( increment < 0 )
+	//VBA, minz@cn.ibm.com.
+    if( nContrast < 0 )
     {
-        increment = 0.0;
+        nContrast = 0.0;
     }
-    if( increment > 1 )
+    if( nContrast > 1 )
     {
-        increment = 1.0;
+        nContrast = 1.0;
     }
     setContrast( nContrast );
 }
diff --git vbahelper/source/vbahelper/vbashape.cxx vbahelper/source/vbahelper/vbashape.cxx
index e0ec739..f95ede4 100644
--- vbahelper/source/vbahelper/vbashape.cxx
+++ vbahelper/source/vbahelper/vbashape.cxx
@@ -35,6 +35,7 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/text/TextContentAnchorType.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
 #include <ooo/vba/word/WdRelativeHorizontalPosition.hpp>
 #include <ooo/vba/word/WdRelativeVerticalPosition.hpp>
 
@@ -219,25 +220,66 @@ ScVbaShape::setWidth( double _width ) throw (uno::RuntimeException)
 double SAL_CALL 
 ScVbaShape::getLeft() throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->getLeft();
+    double left = 0;
+    try
+    {
+        left = m_pShapeHelper->getLeft();
+    }
+    catch( uno::Exception& )
+    {
+        // fail to get position by using XShape::getPosition()
+        sal_Int32 nLeft = 0;
+        m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientPosition") ) ) >>= nLeft;
+        left = Millimeter::getInPoints( nLeft );
+    }
+    return left;
 }
 
 void SAL_CALL 
 ScVbaShape::setLeft( double _left ) throw (uno::RuntimeException)
 {
-    m_pShapeHelper->setLeft( _left );
+    try
+    {
+        m_pShapeHelper->setLeft( _left );
+    }
+    catch( uno::Exception& )
+    {
+        sal_Int32 nLeft = 0;
+        nLeft = Millimeter::getInHundredthsOfOneMillimeter( _left );
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "HoriOrientPosition" ), uno::makeAny( nLeft ) );
+    }
 }
 
 double SAL_CALL 
 ScVbaShape::getTop() throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->getTop();
+    double top = 0;
+    try
+    {
+        top = m_pShapeHelper->getTop();
+    }
+    catch( uno::Exception& )
+    {
+        sal_Int32 nTop = 0;
+        m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientPosition") ) ) >>= nTop;
+        top = Millimeter::getInPoints( nTop );
+    }    
+    return top;
 }
 
 void SAL_CALL 
 ScVbaShape::setTop( double _top ) throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->setTop( _top );
+    try
+    {
+        m_pShapeHelper->setTop( _top );
+    }    
+    catch( uno::Exception& )
+    {
+        sal_Int32 nTop = 0;
+        nTop = Millimeter::getInHundredthsOfOneMillimeter( _top );
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "VertOrientPosition" ), uno::makeAny( nTop ) );
+    }
 }
 
 sal_Bool SAL_CALL 
@@ -474,6 +516,17 @@ ScVbaShape::ShapeRange( const uno::Any& index ) throw ( uno::RuntimeException )
     return uno::makeAny( xShapeRange );
 }
 
+void SAL_CALL ScVbaShape::Copy() throw (uno::RuntimeException)
+{
+	if ( m_xModel.is() )
+	{
+		Select( uno::Any() );
+		// Copy this Shape.
+		rtl::OUString sUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Copy") );
+		dispatchRequests( m_xModel, sUrl );
+	}
+}
+
 sal_Bool SAL_CALL 
 ScVbaShape::getLockAspectRatio() throw (uno::RuntimeException)
 {
@@ -504,35 +557,34 @@ sal_Int32 SAL_CALL
 ScVbaShape::getRelativeHorizontalPosition() throw (uno::RuntimeException)
 {
     sal_Int32 nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
-    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    sal_Int16 nType = text::RelOrientation::PAGE_LEFT;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientRelation") ) ) >>= nType;
     
-    switch( eType )
+    switch( nType )
     {
-        case text::TextContentAnchorType_AT_PARAGRAPH:
+        case text::RelOrientation::FRAME:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn;
             break;
         }
-        case text::TextContentAnchorType_AT_PAGE:
+        case text::RelOrientation::PAGE_FRAME:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage;
             break;
         }
-        case text::TextContentAnchorType_AT_CHARACTER:
+        case text::RelOrientation::CHAR:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter;
             break;
         }
-        case text::TextContentAnchorType_AT_FRAME:
-        case text::TextContentAnchorType_AS_CHARACTER:
+        case text::RelOrientation::PAGE_PRINT_AREA:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
             break;
         }
         default:
         {
-            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
+            throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Shape::RelativeHorizontalPosition: not implemented" ) ), uno::Reference< uno::XInterface >() );
         }
     }
     return nRelativeHorizontalPosition;
@@ -541,23 +593,27 @@ ScVbaShape::getRelativeHorizontalPosition() throw (uno::RuntimeException)
 void SAL_CALL 
 ScVbaShape::setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (uno::RuntimeException)
 {
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
     switch( _relativehorizontalposition )
     {
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter:
         {
-            eType = text::TextContentAnchorType_AT_CHARACTER;
+            nType = text::RelOrientation::CHAR;
             break;
         }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn:
+        {
+            nType = text::RelOrientation::PAGE_FRAME;
+            break;
+        }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin:
         {
-            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            nType = text::RelOrientation::PAGE_PRINT_AREA;
             break;
         }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage:
         {
-            eType = text::TextContentAnchorType_AT_PAGE;
+            nType = text::RelOrientation::PAGE_FRAME;
             break;
         }
         default:
@@ -565,42 +621,41 @@ ScVbaShape::setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalpositi
             DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
         }
     }
-    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientRelation") ), uno::makeAny( nType ) );
 }
 
 sal_Int32 SAL_CALL 
 ScVbaShape::getRelativeVerticalPosition() throw (uno::RuntimeException)
 {
     sal_Int32 nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
-    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientRelation") ) ) >>= nType;
     
-    switch( eType )
+    switch( nType )
     {
-        case text::TextContentAnchorType_AT_PARAGRAPH:
+        case text::RelOrientation::FRAME:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph;
             break;
         }
-        case text::TextContentAnchorType_AT_PAGE:
+        case text::RelOrientation::PAGE_FRAME:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage;
             break;
         }
-        case text::TextContentAnchorType_AT_CHARACTER:
+        case text::RelOrientation::TEXT_LINE:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine;
             break;
         }
-        case text::TextContentAnchorType_AT_FRAME:
-        case text::TextContentAnchorType_AS_CHARACTER:
+        case text::RelOrientation::PAGE_PRINT_AREA:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
             break;
         }
         default:
         {
-            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
+            throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Shape::RelativeVerticalPosition: not implemented" ) ), uno::Reference< uno::XInterface >() );
         }
     }
     return nRelativeVerticalPosition;
@@ -609,23 +664,27 @@ ScVbaShape::getRelativeVerticalPosition() throw (uno::RuntimeException)
 void SAL_CALL 
 ScVbaShape::setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (uno::RuntimeException)
 {
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
     switch( _relativeverticalposition )
     {
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine:
         {
-            eType = text::TextContentAnchorType_AT_CHARACTER;
+            nType = text::RelOrientation::TEXT_LINE;
             break;
         }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph:
+        {
+            nType = text::RelOrientation::FRAME;
+            break;
+        }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin:
         {
-            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            nType = text::RelOrientation::PAGE_PRINT_AREA;
             break;
         }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage:
         {
-            eType = text::TextContentAnchorType_AT_PAGE;
+            nType = text::RelOrientation::PAGE_FRAME;
             break;
         }
         default:
@@ -633,7 +692,7 @@ ScVbaShape::setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition )
             DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
         }
     }
-    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientRelation") ), uno::makeAny( nType ) );
 }
 
 uno::Any SAL_CALL 
diff --git vbahelper/source/vbahelper/vbashaperange.cxx vbahelper/source/vbahelper/vbashaperange.cxx
index f6dc8ad..cfdf185 100644
--- vbahelper/source/vbahelper/vbashaperange.cxx
+++ vbahelper/source/vbahelper/vbashaperange.cxx
@@ -122,6 +122,27 @@ ScVbaShapeRange::IncrementTop( double Increment ) throw (uno::RuntimeException)
     {
         uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
         xShape->IncrementTop( Increment );
+	}
+}
+
+rtl::OUString SAL_CALL ScVbaShapeRange::getName() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getName( );
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setName( _name );
     }
 }
 
@@ -337,6 +358,16 @@ uno::Any SAL_CALL ScVbaShapeRange::WrapFormat(  ) throw (css::uno::RuntimeExcept
     throw uno::RuntimeException();
 }
 
+void SAL_CALL ScVbaShapeRange::ZOrder( sal_Int32 ZOrderCmd ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->ZOrder( ZOrderCmd );
+	}
+}
+
 uno::Type SAL_CALL
 ScVbaShapeRange::getElementType() throw (uno::RuntimeException)
 {
diff --git vbahelper/source/vbahelper/vbashapes.cxx vbahelper/source/vbahelper/vbashapes.cxx
index f64b4aa..1b77ef8 100644
--- vbahelper/source/vbahelper/vbashapes.cxx
+++ vbahelper/source/vbahelper/vbashapes.cxx
@@ -86,7 +86,7 @@ void ScVbaShapes::initBaseCollection()
     m_xNameAccess.set( xShapes, uno::UNO_QUERY );
 }
 
-ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const uno::Reference< frame::XModel>& xModel ): ScVbaShapes_BASE( xParent, xContext, xShapes ), m_nNewShapeCount(0), m_xModel( xModel )
+ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const uno::Reference< frame::XModel>& xModel ): ScVbaShapes_BASE( xParent, xContext, xShapes, sal_True ), m_nNewShapeCount(0), m_xModel( xModel )
 {
     m_xShapes.set( xShapes, uno::UNO_QUERY_THROW );
     m_xDrawPage.set( xShapes, uno::UNO_QUERY_THROW ); 
diff --git vbahelper/util/makefile.mk vbahelper/util/makefile.mk
index dda4be0..33c4900 100644
--- vbahelper/util/makefile.mk
+++ vbahelper/util/makefile.mk
@@ -95,6 +95,7 @@ SHL2STDLIBS= \
         $(VCLLIB) \
         $(TKLIB) \
                 $(BASICLIB) \
+		$(SVXMSFILTERLIB) \
 
 SHL2DEPN=$(SHL1TARGETN)
 SHL2LIBS=$(SLB)$/$(TARGET_MSFORMS).lib
diff --git vcl/inc/vcl/bitmap.hxx vcl/inc/vcl/bitmap.hxx
index 435e4c6..d3f2282 100644
--- vcl/inc/vcl/bitmap.hxx
+++ vcl/inc/vcl/bitmap.hxx
@@ -267,9 +267,9 @@ public:
     SAL_DLLPRIVATE void                 ImplSetImpBitmap( ImpBitmap* pImpBmp );
     SAL_DLLPRIVATE void                 ImplAssignWithSize( const Bitmap& rBitmap );
 
-    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bMSOFormat=FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBFileHeader( SvStream& rIStm, ULONG& rOffset );
-    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, BOOL bMSOFormat = FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBPalette( SvStream& rIStm, BitmapWriteAccess& rAcc, BOOL bQuad );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBBits( SvStream& rIStm, DIBInfoHeader& rHeader, BitmapWriteAccess& rAcc, sal_Bool bTopDown );
     SAL_DLLPRIVATE BOOL                 ImplWriteDIB( SvStream& rOStm, BitmapReadAccess& rAcc, BOOL bCompressed ) const;
@@ -764,7 +764,7 @@ public:
 
 public:
 
-    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE );
+    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE, BOOL bMSOFormat = FALSE );
     BOOL                    Write( SvStream& rOStm, BOOL bCompressed = TRUE, BOOL bFileHeader = TRUE ) const;
 
     friend VCL_DLLPUBLIC SvStream&        operator>>( SvStream& rIStm, Bitmap& rBitmap );
diff --git vcl/inc/vcl/bitmapex.hxx vcl/inc/vcl/bitmapex.hxx
index a7185da..29dfe13 100644
--- vcl/inc/vcl/bitmapex.hxx
+++ vcl/inc/vcl/bitmapex.hxx
@@ -395,6 +395,7 @@ public:
 
     friend VCL_DLLPUBLIC SvStream&	operator<<( SvStream& rOStm, const BitmapEx& rBitmapEx );
     friend VCL_DLLPUBLIC SvStream&	operator>>( SvStream& rIStm, BitmapEx& rBitmapEx );
+	static BitmapEx AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize);
 };
 
 #endif // _SV_BITMAPEX_HXX
diff --git vcl/inc/vcl/dialog.hxx vcl/inc/vcl/dialog.hxx
index 1032908..f771333 100644
--- vcl/inc/vcl/dialog.hxx
+++ vcl/inc/vcl/dialog.hxx
@@ -53,6 +53,7 @@ private:
     BOOL			mbOldSaveBack;
     BOOL			mbInClose;
     BOOL			mbModalMode;
+	sal_Int8		mnCancelClose;  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
 
     SAL_DLLPRIVATE void    ImplInitDialogData();
     SAL_DLLPRIVATE void    ImplInitSettings();
@@ -91,6 +92,9 @@ public:
     virtual short	Execute();
     BOOL			IsInExecute() const { return mbInExecute; }
 
+	sal_Int8		GetCloseFlag() const { return mnCancelClose; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	void			SetCloseFlag( sal_Int8 nCancel ) { mnCancelClose = nCancel; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+
     ////////////////////////////////////////
     // Dialog::Execute replacement API
 public:
diff --git vcl/source/control/combobox.cxx vcl/source/control/combobox.cxx
index 4dbc78a..c96c1d6 100644
--- vcl/source/control/combobox.cxx
+++ vcl/source/control/combobox.cxx
@@ -468,8 +468,11 @@ IMPL_LINK( ComboBox, ImplSelectHdl, void*, EMPTYARG )
         mpSubEdit->SetModifyFlag();
         mbSyntheticModify = TRUE;
         Modify();
-        mbSyntheticModify = FALSE;
-        Select();
+		mbSyntheticModify = FALSE;		
+		if (ImplGetWindowImpl() != NULL) //liuchen 2009-7-28, resolve the problem that soffice get crashed if in ComboBox_Change event a Worksheets("SheetX").Activate sentence needs to be executed 
+		{
+			Select();
+		}
     }
 
     return 0;
diff --git vcl/source/gdi/bitmap2.cxx vcl/source/gdi/bitmap2.cxx
index d982d64..50c7bad 100644
--- vcl/source/gdi/bitmap2.cxx
+++ vcl/source/gdi/bitmap2.cxx
@@ -46,6 +46,8 @@
 
 #define DIBCOREHEADERSIZE			( 12UL )
 #define DIBINFOHEADERSIZE			( sizeof( DIBInfoHeader ) )
+#define BITMAPINFOHEADER                        0x28
+
 #define SETPIXEL4( pBuf, nX, cChar )( (pBuf)[ (nX) >> 1 ] |= ( (nX) & 1 ) ? ( cChar ): (cChar) << 4 );
 
 // ----------------------
@@ -129,7 +131,7 @@ SvStream& operator<<( SvStream& rOStm, const Bitmap& rBitmap )
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader )
+BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader, BOOL bIsMSOFormat )
 {
     const USHORT	nOldFormat = rIStm.GetNumberFormatInt();
     const ULONG 	nOldPos = rIStm.Tell();
@@ -144,7 +146,7 @@ BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader )
             bRet = ImplReadDIB( rIStm, *this, nOffset );
     }
     else
-        bRet = ImplReadDIB( rIStm, *this, nOffset );
+		bRet = ImplReadDIB( rIStm, *this, nOffset, bIsMSOFormat );
 
     if( !bRet )
     {
@@ -161,14 +163,14 @@ BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader )
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset )
+BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bIsMSOFormat )
 {
     DIBInfoHeader	aHeader;
     const ULONG 	nStmPos = rIStm.Tell();
     BOOL			bRet = FALSE;
     sal_Bool		bTopDown = sal_False;
 
-    if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
+	if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown, bIsMSOFormat ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
     {
         const USHORT nBitCount( discretizeBitcount(aHeader.nBitCount) );
 
@@ -299,20 +301,36 @@ BOOL Bitmap::ImplReadDIBFileHeader( SvStream& rIStm, ULONG& rOffset )
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown )
+BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, sal_Bool bIsMSOFormat )
 {
     // BITMAPINFOHEADER or BITMAPCOREHEADER
     rIStm >> rHeader.nSize;
 
     // BITMAPCOREHEADER
+	sal_Int16 nTmp16 = 0;
+	sal_uInt8 nTmp8 = 0;
     if ( rHeader.nSize == DIBCOREHEADERSIZE )
     {
-        sal_Int16 nTmp16;
 
         rIStm >> nTmp16; rHeader.nWidth = nTmp16;
         rIStm >> nTmp16; rHeader.nHeight = nTmp16;
         rIStm >> rHeader.nPlanes;
         rIStm >> rHeader.nBitCount;
+	}
+	else if ( bIsMSOFormat && ( rHeader.nSize == BITMAPINFOHEADER ) )
+	{
+		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
+		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
+		rIStm >> nTmp8; rHeader.nPlanes = nTmp8;
+		rIStm >> nTmp8; rHeader.nBitCount = nTmp8;
+		rIStm >> nTmp16; rHeader.nSizeImage = nTmp16;
+		rIStm >> nTmp16; rHeader.nCompression = nTmp16;
+		if ( !rHeader.nSizeImage ) // uncompressed?
+			rHeader.nSizeImage = ((rHeader.nWidth * rHeader.nBitCount + 31) & ~31) / 8 * rHeader.nHeight;
+		rIStm >> rHeader.nXPelsPerMeter;
+		rIStm >> rHeader.nYPelsPerMeter;
+		rIStm >> rHeader.nColsUsed;
+		rIStm >> rHeader.nColsImportant;
     }
     else
     {
diff --git vcl/source/gdi/bitmapex.cxx vcl/source/gdi/bitmapex.cxx
index cfa9e4c..1997455 100644
--- vcl/source/gdi/bitmapex.cxx
+++ vcl/source/gdi/bitmapex.cxx
@@ -45,6 +45,7 @@
 #endif
 #include <vcl/svapp.hxx>
 #include <vcl/bmpacc.hxx>
+#include <vcl/virdev.hxx>
 
 // ------------
 // - BitmapEx -
@@ -757,6 +758,61 @@ void BitmapEx::Draw( OutputDevice* pOutDev,
     pOutDev->DrawBitmapEx( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, *this );
 }
 
+BitmapEx BitmapEx:: AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize)
+{
+	Point aEmptyPoint(0,0);
+	sal_Int32 imgNewWidth = 0;
+	sal_Int32 imgNewHeight = 0;
+	double imgposX = 0;
+	double imgposY = 0;
+    BitmapEx  aRet = aBitmap;
+	double imgOldWidth = aRet.GetSizePixel().Width();
+	double imgOldHeight =aRet.GetSizePixel().Height();
+
+    Size aScaledSize;
+    if (imgOldWidth >= aStandardSize || imgOldHeight >= aStandardSize)
+	{
+		if (imgOldWidth >= imgOldHeight)
+		{
+			imgNewWidth = aStandardSize;
+			imgNewHeight = sal_Int32(imgOldHeight / (imgOldWidth / aStandardSize) + 0.5);
+			imgposX = 0;
+			imgposY = (aStandardSize - (imgOldHeight / (imgOldWidth / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+		else
+		{
+			imgNewHeight = aStandardSize;
+			imgNewWidth = sal_Int32(imgOldWidth / (imgOldHeight / aStandardSize) + 0.5);
+			imgposY = 0;
+			imgposX = (aStandardSize - (imgOldWidth / (imgOldHeight / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+
+		aScaledSize = Size( imgNewWidth, imgNewHeight );
+        aRet.Scale( aScaledSize, BMP_SCALE_INTERPOLATE );
+	}
+	else
+	{
+		imgposX = (aStandardSize - imgOldWidth) / 2 + 0.5;
+		imgposY = (aStandardSize - imgOldHeight) / 2 + 0.5;
+	}
+
+    Size aBmpSize = aRet.GetSizePixel();
+    Size aStdSize( aStandardSize, aStandardSize );
+    Rectangle aRect(aEmptyPoint, aStdSize );
+
+    VirtualDevice aVirDevice( *Application::GetDefaultDevice(), 0, 1 );
+	aVirDevice.SetOutputSizePixel( aStdSize );
+	aVirDevice.SetFillColor( COL_TRANSPARENT );
+    aVirDevice.SetLineColor( COL_TRANSPARENT );
+
+    //draw a rect into virDevice
+	aVirDevice.DrawRect( aRect );
+	Point aPointPixel( (long)imgposX, (long)imgposY );
+	aVirDevice.DrawBitmapEx( aPointPixel, aRet );
+	aRet = aVirDevice.GetBitmapEx( aEmptyPoint, aStdSize );
+
+	return aRet;
+}
 // ------------------------------------------------------------------
 
 sal_uInt8 BitmapEx::GetTransparency(sal_Int32 nX, sal_Int32 nY) const
diff --git vcl/source/window/dialog.cxx vcl/source/window/dialog.cxx
index 86b7e85..1e493ce 100644
--- vcl/source/window/dialog.cxx
+++ vcl/source/window/dialog.cxx
@@ -559,7 +559,14 @@ BOOL Dialog::Close()
 {
     ImplDelData aDelData;
     ImplAddDel( &aDelData );
-    ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );
+	//liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	mnCancelClose = 0;
+	ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );	
+	if (mnCancelClose == 1)
+	{
+		return FALSE;
+	}
+	//liuchen 2009-7-22
     if ( aDelData.IsDelete() )
         return FALSE;
     ImplRemoveDel( &aDelData );
diff --git vcl/source/window/toolbox2.cxx vcl/source/window/toolbox2.cxx
index 9f15df6..9fb1d55 100644
--- vcl/source/window/toolbox2.cxx
+++ vcl/source/window/toolbox2.cxx
@@ -56,6 +56,8 @@ using namespace rtl;
 
 #define TB_SEP_SIZE 			8
 
+ButtonType determineButtonType( ImplToolItem* pItem, ButtonType defaultType );
+
 // -----------------------------------------------------------------------
 
 ImplToolBoxPrivateData::ImplToolBoxPrivateData() :
diff --git xmloff/inc/xmlnmspe.hxx xmloff/inc/xmlnmspe.hxx
index 1451cde..33de6ea 100644
--- xmloff/inc/xmlnmspe.hxx
+++ xmloff/inc/xmlnmspe.hxx
@@ -104,6 +104,7 @@ XML_OLD_NAMESPACE( META,	6U )
 
 // experimental namespaces
 XML_NAMESPACE( FIELD,			100U )
+XML_NAMESPACE( FORMX,           101U )      // form interop extensions
 
 
 #endif	//  _XMLOFF_XMLNMSPE_HXX
diff --git xmloff/inc/xmloff/shapeexport.hxx xmloff/inc/xmloff/shapeexport.hxx
index 9f28c27..43cabbe 100644
--- xmloff/inc/xmloff/shapeexport.hxx
+++ xmloff/inc/xmloff/shapeexport.hxx
@@ -199,11 +199,6 @@ private:
     const rtl::OUString							msStartShape;
     const rtl::OUString							msEndShape;
     const rtl::OUString							msOnClick;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    const rtl::OUString							msOnAction;
-    const rtl::OUString							msAction;
-    const rtl::OUString							msURL;
-#endif
     const rtl::OUString							msEventType;
     const rtl::OUString							msPresentation;
     const rtl::OUString							msMacroName;
diff --git xmloff/inc/xmloff/xmltoken.hxx xmloff/inc/xmloff/xmltoken.hxx
index 3ea86c2..f174cbf 100644
--- xmloff/inc/xmloff/xmltoken.hxx
+++ xmloff/inc/xmloff/xmltoken.hxx
@@ -145,9 +145,13 @@ namespace xmloff { namespace token {
         XML_NP_OFFICE_EXT,
         XML_N_OFFICE_EXT,
 
+        // jonp: 2008-09-24 Excel Interop
+        XML_NP_FORMX,
+        XML_N_FORMX,
+
         XML_NP_TABLE_EXT,
         XML_N_TABLE_EXT,
-
+        
         XML_NP_DRAW_EXT,
         XML_N_DRAW_EXT,
 
diff --git xmloff/source/core/xmlexp.cxx xmloff/source/core/xmlexp.cxx
index 9b1ddcb..e8a2c22 100644
--- xmloff/source/core/xmlexp.cxx
+++ xmloff/source/core/xmlexp.cxx
@@ -409,6 +409,7 @@ void SvXMLExport::_InitCtor()
         mpNamespaceMap->Add( GetXMLToken(XML_NP_XSD), GetXMLToken(XML_N_XSD), XML_NAMESPACE_XSD );
         mpNamespaceMap->Add( GetXMLToken(XML_NP_XSI), GetXMLToken(XML_N_XSI), XML_NAMESPACE_XSI );
         mpNamespaceMap->Add( GetXMLToken(XML_NP_FIELD), GetXMLToken(XML_N_FIELD), XML_NAMESPACE_FIELD );
+		mpNamespaceMap->Add( GetXMLToken(XML_NP_FORMX), GetXMLToken(XML_N_FORMX), XML_NAMESPACE_FORMX );
     }
     // RDFa: needed for content and header/footer styles
     if( (getExportFlags() & (EXPORT_STYLES|EXPORT_AUTOSTYLES|EXPORT_MASTERSTYLES|EXPORT_CONTENT) ) != 0 )
diff --git xmloff/source/core/xmlimp.cxx xmloff/source/core/xmlimp.cxx
index ba559a0..e6105d8 100644
--- xmloff/source/core/xmlimp.cxx
+++ xmloff/source/core/xmlimp.cxx
@@ -115,6 +115,7 @@ sal_Char __READONLY_DATA sXML_np__script[] = "_script";
 sal_Char __READONLY_DATA sXML_np__config[] = "_config";
 sal_Char __READONLY_DATA sXML_np__db[] = "_db";
 sal_Char __READONLY_DATA sXML_np__xforms[] = "_xforms";
+sal_Char __READONLY_DATA sXML_np__formx[] = "_formx";
 sal_Char __READONLY_DATA sXML_np__xsd[] = "_xsd";
 sal_Char __READONLY_DATA sXML_np__xsi[] = "_xsi";
 sal_Char __READONLY_DATA sXML_np__field[] = "_field";
@@ -309,6 +310,9 @@ void SvXMLImport::_InitCtor()
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xforms) ),
                             GetXMLToken(XML_N_XFORMS_1_0),
                             XML_NAMESPACE_XFORMS );
+        mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__formx) ),
+                            GetXMLToken( XML_N_FORMX ),
+                            XML_NAMESPACE_FORMX );
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xsd) ),
                             GetXMLToken(XML_N_XSD),
                             XML_NAMESPACE_XSD );
diff --git xmloff/source/core/xmltoken.cxx xmloff/source/core/xmltoken.cxx
index ba3840e..bc02a51 100644
--- xmloff/source/core/xmltoken.cxx
+++ xmloff/source/core/xmltoken.cxx
@@ -153,6 +153,9 @@ namespace xmloff { namespace token {
         TOKEN( "officeooo", XML_NP_OFFICE_EXT ),
         TOKEN( "http://openoffice.org/2009/office", XML_N_OFFICE_EXT ),
 
+        // jonp: 2008-09-24 Excel Interop
+        TOKEN( "formx",                           XML_NP_FORMX ),
+        TOKEN( "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0", XML_N_FORMX ),
         TOKEN( "tableooo", XML_NP_TABLE_EXT ),
         TOKEN( "http://openoffice.org/2009/table", XML_N_TABLE_EXT ),
 
diff --git xmloff/source/draw/eventimp.cxx xmloff/source/draw/eventimp.cxx
index dcc9ff4..732fc07 100644
--- xmloff/source/draw/eventimp.cxx
+++ xmloff/source/draw/eventimp.cxx
@@ -101,9 +101,6 @@ public:
 
     sal_Bool mbValid;
     sal_Bool mbScript;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    sal_Bool mbActionEvent;
-#endif
     ClickAction meClickAction;
     XMLEffect meEffect;
     XMLEffectDirection meDirection;
@@ -115,9 +112,6 @@ public:
     OUString msMacroName;
     OUString msBookmark;
     OUString msLanguage;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    OUString msHyperURL;
-#endif
 };
 
 ///////////////////////////////////////////////////////////////////////
@@ -176,18 +170,11 @@ TYPEINIT1( SdXMLEventContext, SvXMLImportContext );
 
 SdXMLEventContext::SdXMLEventContext( SvXMLImport& rImp,  sal_uInt16 nPrfx, const OUString& rLocalName,  const Reference< XAttributeList >& xAttrList, const Reference< XShape >& rxShape )
 :	SvXMLImportContext(rImp, nPrfx, rLocalName),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    mxShape( rxShape ), mbScript( sal_False ), mbActionEvent( sal_False ), meClickAction( ClickAction_NONE ),
-#else
     mxShape( rxShape ), mbScript( sal_False ), meClickAction( ClickAction_NONE ),
-#endif
     meEffect( EK_none ), meDirection( ED_none ), mnStartScale( 100 ),
     meSpeed( AnimationSpeed_MEDIUM ), mnVerb(0), mbPlayFull( sal_False )
 {
     static const OUString sXMLClickName( RTL_CONSTASCII_USTRINGPARAM( "click" ) );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    static const OUString sXMLActionName( RTL_CONSTASCII_USTRINGPARAM( "action" ) );
-#endif
 
     if( nPrfx == XML_NAMESPACE_PRESENTATION && IsXMLToken( rLocalName, XML_EVENT_LISTENER ) )
     {
@@ -258,12 +245,7 @@ SdXMLEventContext::SdXMLEventContext( SvXMLImport& rImp,  sal_uInt16 nPrfx, cons
                 sEventName = sValue;
                 sal_uInt16 nScriptPrefix =
                     GetImport().GetNamespaceMap().GetKeyByAttrName( sValue, &sEventName );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                mbValid = XML_NAMESPACE_DOM == nScriptPrefix && ( sEventName == sXMLClickName || sEventName == sXMLActionName );
-                mbActionEvent = mbValid && (sEventName == sXMLActionName);
-#else
                 mbValid = XML_NAMESPACE_DOM == nScriptPrefix && sEventName == sXMLClickName;
-#endif
             }
             else if( IsXMLToken( aAttrLocalName, XML_LANGUAGE ) )
             {
@@ -292,12 +274,6 @@ SdXMLEventContext::SdXMLEventContext( SvXMLImport& rImp,  sal_uInt16 nPrfx, cons
                 {
                     msMacroName = sValue;
                 }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                else if ( mbActionEvent )
-                {
-                    msHyperURL = sValue;
-                }
-#endif
                 else
                 {
                     const rtl::OUString &rTmp =
@@ -343,26 +319,6 @@ void SdXMLEventContext::EndElement()
         OUString sAPIEventName;
         uno::Sequence< beans::PropertyValue > aProperties;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        if( mbActionEvent )
-        {
-            sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) );
-            aProperties.realloc( 2 );
-            beans::PropertyValue* pProperty = aProperties.getArray();
-
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) );
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-            ++pProperty;
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= msHyperURL;
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-        }
-        else
-#endif
-        {
             sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) );
 
             if( mbScript )
@@ -547,8 +503,6 @@ void SdXMLEventContext::EndElement()
                     break;
                 }
             }
-        }
-
         xEvents->replaceByName( sAPIEventName, uno::Any( aProperties ) );
 
     } while(0);
diff --git xmloff/source/draw/shapeexport.cxx xmloff/source/draw/shapeexport.cxx
index 76353ba..7dc8ce6 100644
--- xmloff/source/draw/shapeexport.cxx
+++ xmloff/source/draw/shapeexport.cxx
@@ -90,11 +90,6 @@ XMLShapeExport::XMLShapeExport(SvXMLExport& rExp,
     msStartShape( RTL_CONSTASCII_USTRINGPARAM("StartShape") ),
     msEndShape( RTL_CONSTASCII_USTRINGPARAM("EndShape") ),
     msOnClick( RTL_CONSTASCII_USTRINGPARAM("OnClick") ),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    msOnAction( RTL_CONSTASCII_USTRINGPARAM("OnAction") ),
-    msAction( RTL_CONSTASCII_USTRINGPARAM("Action") ),
-    msURL( RTL_CONSTASCII_USTRINGPARAM("URL") ),
-#endif
     msEventType( RTL_CONSTASCII_USTRINGPARAM("EventType") ),
     msPresentation( RTL_CONSTASCII_USTRINGPARAM("Presentation") ),
     msMacroName( RTL_CONSTASCII_USTRINGPARAM("MacroName") ),
diff --git xmloff/source/draw/shapeexport2.cxx xmloff/source/draw/shapeexport2.cxx
index be5d6e2..0ac32d3 100644
--- xmloff/source/draw/shapeexport2.cxx
+++ xmloff/source/draw/shapeexport2.cxx
@@ -293,9 +293,6 @@ const sal_Int32 FOUND_CLICKEVENTTYPE    = 0x00000080;
 const sal_Int32 FOUND_MACRO             = 0x00000100;
 const sal_Int32 FOUND_LIBRARY           = 0x00000200;
 const sal_Int32 FOUND_ACTIONEVENTTYPE   = 0x00000400;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-const sal_Int32 FOUND_URL               = 0x00000800;
-#endif
 
 } // namespace
 
@@ -385,33 +382,6 @@ void XMLShapeExport::ImpExportEvents( const uno::Reference< drawing::XShape >& x
         }
     }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    // extract properties from "OnAction" event -------------------------------
-
-    OUString aActionEventType;
-    OUString aHyperURL;
-
-    uno::Sequence< beans::PropertyValue > aActionProperties;
-    if( xEvents->hasByName( msOnAction ) && (xEvents->getByName( msOnAction ) >>= aActionProperties) )
-    {
-        const beans::PropertyValue* pProperty = aActionProperties.getConstArray();
-        const beans::PropertyValue* pPropertyEnd = pProperty + aActionProperties.getLength();
-        for( ; pProperty != pPropertyEnd; ++pProperty )
-        {
-            if( ( ( nFound & FOUND_ACTIONEVENTTYPE ) == 0 ) && pProperty->Name == msEventType )
-            {
-                if( pProperty->Value >>= aActionEventType )
-                    nFound |= FOUND_ACTIONEVENTTYPE;
-            }
-            else if( ( ( nFound & FOUND_URL ) == 0 ) && ( pProperty->Name == msURL  ) )
-            {
-                if( pProperty->Value >>= aHyperURL )
-                    nFound |= FOUND_URL;
-            }
-        }
-    }
-#endif
-
     // create the XML elements
 
     if( aClickEventType == msPresentation )
@@ -563,15 +533,9 @@ void XMLShapeExport::ImpExportEvents( const uno::Reference< drawing::XShape >& x
             SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
         }
     }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    else if( aClickEventType == msScript || aActionEventType == msAction )
-    {
-        if( nFound & ( FOUND_MACRO | FOUND_URL ) )
-#else
     else if( aClickEventType == msScript )
     {
         if( nFound & FOUND_MACRO )
-#endif
         {
             SvXMLElementExport aEventsElemt(mrExport, XML_NAMESPACE_OFFICE, XML_EVENT_LISTENERS, sal_True, sal_True);
             if ( nFound & FOUND_MACRO )
@@ -586,18 +550,6 @@ void XMLShapeExport::ImpExportEvents( const uno::Reference< drawing::XShape >& x
 
                 SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( nFound & FOUND_URL )
-            {
-                OUString aEventQName(
-                    mrExport.GetNamespaceMap().GetQNameByKey(
-                            XML_NAMESPACE_DOM, OUString( RTL_CONSTASCII_USTRINGPARAM( "action" ) ) ) );
-                mrExport.AddAttribute( XML_NAMESPACE_SCRIPT, XML_EVENT_NAME, aEventQName );
-                mrExport.AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, aHyperURL );
-
-                SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_PRESENTATION, XML_EVENT_LISTENER, sal_True, sal_True);
-            }
-#endif
         }
     }
 }
diff --git xmloff/source/draw/ximpshap.cxx xmloff/source/draw/ximpshap.cxx
index 82285ba..77f1bae 100644
--- xmloff/source/draw/ximpshap.cxx
+++ xmloff/source/draw/ximpshap.cxx
@@ -374,9 +374,15 @@ void SdXMLShapeContext::EndElement()
 
     if( msHyperlink.getLength() != 0 ) try
     {
+		uno::Reference< beans::XPropertySet > xProp( mxShape, uno::UNO_QUERY );
+
+		rtl::OUString sLink( RTL_CONSTASCII_USTRINGPARAM( "Hyperlink" ) );
+		if ( xProp.is() && xProp->getPropertySetInfo()->hasPropertyByName( sLink ) )
+			xProp->setPropertyValue( sLink, uno::Any( msHyperlink ) );
+        Reference< XEventsSupplier > xEventsSupplier( mxShape, UNO_QUERY_THROW );
+        Reference< XNameReplace > xEvents( xEventsSupplier->getEvents(), UNO_QUERY_THROW );
         const OUString sBookmark( RTL_CONSTASCII_USTRINGPARAM( "Bookmark" ) );
 
-        Reference< XEventsSupplier > xEventsSupplier( mxShape, UNO_QUERY );
         if( xEventsSupplier.is() )
         {
             const OUString sEventType( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) );
@@ -3306,9 +3312,16 @@ SvXMLImportContext *SdXMLFrameShapeContext::CreateChildContext( USHORT nPrefix,
 
     if( !mxImplContext.Is() )
     {
-        pContext = GetImport().GetShapeImport()->CreateFrameChildContext(
+
+		SvXMLShapeContext* pShapeContext= GetImport().GetShapeImport()->CreateFrameChildContext(
                         GetImport(), nPrefix, rLocalName, xAttrList, mxShapes, mxAttrList );
 
+		pContext = pShapeContext;
+
+		// propagate the hyperlink to child context
+		if ( msHyperlink.getLength() > 0 )
+			pShapeContext->setHyperlink( msHyperlink );
+ 
         mxImplContext = pContext;
         mbSupportsReplacement = IsXMLToken( rLocalName, XML_OBJECT ) ||
                                 IsXMLToken( rLocalName, XML_OBJECT_OLE );
diff --git xmloff/source/forms/elementexport.cxx xmloff/source/forms/elementexport.cxx
index d3f39ec..7814c30 100644
--- xmloff/source/forms/elementexport.cxx
+++ xmloff/source/forms/elementexport.cxx
@@ -1107,6 +1107,39 @@ namespace xmloff
         }
 
         // ----------------------------------
+		// the string properties
+		{
+			static sal_Int32 nStringPropertyAttributeIds[] =
+			{	// attribute flags
+				SCA_GROUP_NAME
+			};
+			static const ::rtl::OUString* pStringPropertyNames[] =
+			{	// property names
+				&PROPERTY_GROUP_NAME
+			};
+
+			sal_Int32 nIdCount = sizeof( nStringPropertyAttributeIds ) / sizeof( nStringPropertyAttributeIds[0] );
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof( pStringPropertyNames ) / sizeof( pStringPropertyNames[0] );
+			OSL_ENSURE( ( nIdCount == nNameCount ),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (2)!" );
+		#endif
+			for ( i = 0; i < nIdCount; ++i )
+				if ( nStringPropertyAttributeIds[i] & m_nIncludeSpecial )
+				{
+					exportStringPropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( nStringPropertyAttributeIds[i] ),
+						OAttributeMetaData::getSpecialAttributeName( nStringPropertyAttributeIds[i] ),
+						*( pStringPropertyNames[i] )
+					);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~nStringPropertyAttributeIds[i];
+			#endif
+				}
+		}
+
+		// ----------------------------------
         if ((SCA_MIN_VALUE | SCA_MAX_VALUE) & m_nIncludeSpecial)
         {
             // need to export the min value and the max value as attributes
@@ -1564,6 +1597,8 @@ namespace xmloff
                 }
                 if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_IMAGE_POSITION ) )
                     m_nIncludeSpecial |= SCA_IMAGE_POSITION;
+                if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_GROUP_NAME ) )
+                    m_nIncludeSpecial |= SCA_GROUP_NAME;
                 m_nIncludeDatabase = DA_DATA_FIELD | DA_INPUT_REQUIRED;
                 m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE;
                 break;
diff --git xmloff/source/forms/formattributes.cxx xmloff/source/forms/formattributes.cxx
index 430b257..de11567 100644
--- xmloff/source/forms/formattributes.cxx
+++ xmloff/source/forms/formattributes.cxx
@@ -192,6 +192,7 @@ namespace xmloff
             case SCA_MAX_VALUE:				return "max-value";
             case SCA_MIN_VALUE:				return "min-value";
             case SCA_VALIDATION:			return "validation";
+            case SCA_GROUP_NAME:            return "group-name";
             case SCA_MULTI_LINE:			return "multi-line";
             case SCA_AUTOMATIC_COMPLETION:	return "auto-complete";
             case SCA_MULTIPLE: 				return "multiple";
@@ -212,9 +213,12 @@ namespace xmloff
     }
 
     //---------------------------------------------------------------------
-    sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 /*_nId*/)
+	sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 _nId)
     {
-        // nothing special here
+        switch( _nId )
+        {
+            case SCA_GROUP_NAME:            return XML_NAMESPACE_FORMX;
+        }
         return XML_NAMESPACE_FORM;
     }
 
diff --git xmloff/source/forms/formattributes.hxx xmloff/source/forms/formattributes.hxx
index f2e7bb7..a406a6e 100644
--- xmloff/source/forms/formattributes.hxx
+++ xmloff/source/forms/formattributes.hxx
@@ -123,6 +123,7 @@ namespace xmloff
     #define SCA_MAX_VALUE				0x00000002
     #define SCA_MIN_VALUE				0x00000004
     #define SCA_VALIDATION				0x00000008
+    #define SCA_GROUP_NAME              0x00000010
     #define SCA_MULTI_LINE				0x00000020
     #define SCA_AUTOMATIC_COMPLETION	0x00000080
     #define SCA_MULTIPLE				0x00000100
diff --git xmloff/source/forms/layerimport.cxx xmloff/source/forms/layerimport.cxx
index 5fe178f..3c29834 100644
--- xmloff/source/forms/layerimport.cxx
+++ xmloff/source/forms/layerimport.cxx
@@ -95,6 +95,8 @@ OFormLayerXMLImport_Impl::OFormLayerXMLImport_Impl(SvXMLImport& _rImporter)
     m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_NAME), PROPERTY_NAME);
     m_aAttributeMetaData.addStringProperty(
+			OAttributeMetaData::getSpecialAttributeName(SCA_GROUP_NAME), PROPERTY_GROUP_NAME);
+		m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_IMAGE_DATA), PROPERTY_IMAGEURL);
     m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL), PROPERTY_LABEL);
diff --git xmloff/source/forms/strings.hxx xmloff/source/forms/strings.hxx
index 83d4262..8b7b6ef 100644
--- xmloff/source/forms/strings.hxx
+++ xmloff/source/forms/strings.hxx
@@ -205,6 +205,7 @@ namespace xmloff
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_POSITION,     "ImagePosition");
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_ALIGN,        "ImageAlign");
     XMLFORM_CONSTASCII_STRING( PROPERTY_SCALE_IMAGE,        "ScaleImage");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_GROUP_NAME,         "GroupName");
 
     XMLFORM_CONSTASCII_STRING( PROPERTY_BOUND_CELL,		    "BoundCell");
     XMLFORM_CONSTASCII_STRING( PROPERTY_LIST_CELL_RANGE,    "CellRange");
diff --git xmlscript/inc/xmlscript/xmldlg_imexp.hxx xmlscript/inc/xmlscript/xmldlg_imexp.hxx
index 2fe6f35..987a8c3 100644
--- xmlscript/inc/xmlscript/xmldlg_imexp.hxx
+++ xmlscript/inc/xmlscript/xmldlg_imexp.hxx
@@ -27,6 +27,8 @@
 #ifndef _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 #define _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 
+#include <com/sun/star/frame/XModel.hpp>
+
 #ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HXX_
 #include <com/sun/star/container/XNameContainer.hpp>
 #endif
@@ -51,7 +53,9 @@ void SAL_CALL exportDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::xml::sax::XExtendedDocumentHandler > const & xOut,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::container::XNameContainer > const & xDialogModel )
+    ::com::sun::star::container::XNameContainer > const & xDialogModel, 
+	::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -60,7 +64,9 @@ SAL_CALL importDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 // additional functions for convenience
@@ -71,7 +77,9 @@ SAL_CALL exportDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -81,7 +89,9 @@ void SAL_CALL importDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 }
diff --git xmlscript/source/xmldlg_imexp/exp_share.hxx xmlscript/source/xmldlg_imexp/exp_share.hxx
index 9ea565f..d06ffee 100644
--- xmlscript/source/xmldlg_imexp/exp_share.hxx
+++ xmlscript/source/xmldlg_imexp/exp_share.hxx
@@ -171,15 +171,17 @@ public:
     //
     void readDialogModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
+    void readMultiPageModel( StyleBag * all_styles )
+        SAL_THROW( (css::uno::Exception) );
     void readButtonModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readEditModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readCheckBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readRadioButtonModel( StyleBag * all_styles )
+    void readRadioButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
-    void readComboBoxModel( StyleBag * all_styles )
+    void readComboBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readCurrencyFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -193,9 +195,9 @@ public:
         SAL_THROW( (css::uno::Exception) );
     void readGroupBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readImageControlModel( StyleBag * all_styles )
+    void readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument  )
         SAL_THROW( (css::uno::Exception) );
-    void readListBoxModel( StyleBag * all_styles )
+    void readListBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readNumericFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -209,7 +211,9 @@ public:
         SAL_THROW( (css::uno::Exception) );
     void readProgressBarModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readScrollBarModel( StyleBag * all_styles )
+    void readScrollBarModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
+        SAL_THROW( (css::uno::Exception) );
+    void readSpinButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readFixedHyperLinkModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
diff --git xmlscript/source/xmldlg_imexp/imp_share.hxx xmlscript/source/xmldlg_imexp/imp_share.hxx
index ce9e43f..0bc9756 100644
--- xmlscript/source/xmldlg_imexp/imp_share.hxx
+++ xmlscript/source/xmldlg_imexp/imp_share.hxx
@@ -42,6 +42,7 @@
 #include <com/sun/star/awt/FontEmphasisMark.hpp>
 #include <com/sun/star/awt/FontRelief.hpp>
 #include <com/sun/star/xml/input/XRoot.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 #include <vector>
 
 
@@ -128,6 +129,8 @@ struct DialogImport
     
     css::uno::Reference< css::container::XNameContainer > _xDialogModel;
     css::uno::Reference< css::lang::XMultiServiceFactory > _xDialogModelFactory;
+    css::uno::Reference< css::frame::XModel > _xDoc;
+    css::uno::Reference< css::script::XLibraryContainer > _xScriptLibraryContainer;
 
     sal_Int32 XMLNS_DIALOGS_UID, XMLNS_SCRIPT_UID;
     
@@ -161,16 +164,20 @@ public:
     inline DialogImport(
         css::uno::Reference<css::uno::XComponentContext> const & xContext,
         css::uno::Reference<css::container::XNameContainer>
-        const & xDialogModel )
+        const & xDialogModel,
+        css::uno::Reference<css::frame::XModel> const & xDoc )
         SAL_THROW( () )
         : _xContext( xContext )
         , _xDialogModel( xDialogModel )
-        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW )
+        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW ), _xDoc( xDoc )
         { OSL_ASSERT( _xDialogModel.is() && _xDialogModelFactory.is() &&
                       _xContext.is() ); }
     virtual ~DialogImport()
         SAL_THROW( () );
     
+    inline css::uno::Reference< css::frame::XModel > getDocOwner() { return _xDoc; }
+
+	css::uno::Reference< css::script::XLibraryContainer > getScriptLibraryContainer();
     // XRoot
     virtual void SAL_CALL startDocument(
         css::uno::Reference< css::xml::input::XNamespaceMapping >
@@ -996,6 +1003,49 @@ public:
 };
 
 //==============================================================================
+class SpinButtonElement
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline SpinButtonElement(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
+//==============================================================================
+class MultiPage
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline MultiPage(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
 class ProgressBarElement
     : public ControlElement
 {
diff --git xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx
index 0a5d74a..abfa771 100644
--- xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx
+++ xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx
@@ -41,6 +41,7 @@
 using namespace ::rtl;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 
 namespace xmlscript
 {
@@ -70,7 +71,8 @@ Reference< io::XInputStream > InputStreamProvider::createInputStream()
 //==================================================================================================
 Reference< io::XInputStreamProvider > SAL_CALL exportDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -95,7 +97,7 @@ Reference< io::XInputStreamProvider > SAL_CALL exportDialogModel(
     
     Reference< io::XActiveDataSource > xSource( xHandler, UNO_QUERY );
     xSource->setOutputStream( createOutputStream( &aBytes ) );
-    exportDialogModel( xHandler, xDialogModel );
+	exportDialogModel( xHandler, xDialogModel, xDocument );
     
     return new InputStreamProvider( aBytes );
 }
@@ -104,7 +106,8 @@ Reference< io::XInputStreamProvider > SAL_CALL exportDialogModel(
 void SAL_CALL importDialogModel(
     Reference< io::XInputStream > xInput,
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -126,7 +129,7 @@ void SAL_CALL importDialogModel(
     }
     
     // error handler, entity resolver omitted for this helper function
-    xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext ) );
+	xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext, xDocument ) );
     
     xml::sax::InputSource source;
     source.aInputStream = xInput;
diff --git xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx
index 2449c09..1c67f19 100644
--- xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx
+++ xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx
@@ -29,7 +29,16 @@
 #include "precompiled_xmlscript.hxx"
 #include "exp_share.hxx"
 
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 
 
 using namespace ::com::sun::star;
@@ -39,6 +48,66 @@ using ::rtl::OUString;
 namespace xmlscript
 {
 
+void lclExportBindableAndListSourceBits( Reference< frame::XModel > const & xDocument, const Reference< beans::XPropertySet >& _xProps, ElementDescriptor& rModel )
+{
+    Reference< lang::XMultiServiceFactory > xFac;
+    if ( xDocument.is() )
+        xFac.set( xDocument, uno::UNO_QUERY );
+
+    Reference< form::binding::XBindableValue > xBinding( _xProps, UNO_QUERY );
+
+    if ( xFac.is() && xBinding.is() )
+    {
+        try
+        {
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );  
+        Reference< beans::XPropertySet > xBindable( xBinding->getValueBinding(), UNO_QUERY );
+            if ( xBindable.is() )
+            {
+                table::CellAddress aAddress; 
+                xBindable->getPropertyValue( OUSTR("BoundCell") ) >>= aAddress; 
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                rtl::OUString sAddress;
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                if ( sAddress.getLength() > 0 )
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":linked-cell"), sAddress );
+                
+                OSL_TRACE( "*** Bindable value %s", rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+               
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+    Reference< form::binding::XListEntrySink > xEntrySink( _xProps, UNO_QUERY );
+    if ( xEntrySink.is() )
+    {
+        Reference< beans::XPropertySet > xListSource( xEntrySink->getListEntrySource(), UNO_QUERY );
+        if ( xListSource.is() )
+        {
+            try
+            {
+                Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );  
+
+                table::CellRangeAddress aAddress; 
+                xListSource->getPropertyValue( OUSTR( "CellRange" ) ) >>= aAddress;
+
+                rtl::OUString sAddress;
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                OSL_TRACE("**** cell range source list %s",
+                    rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+                if ( sAddress.getLength() > 0 );
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":source-cell-range"), sAddress );
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+    }
+
+}
 static inline bool readBorderProps(
     ElementDescriptor * element, Style & style )
 {
@@ -65,6 +134,42 @@ static inline bool readFontProps( ElementDescriptor * element, Style & style )
 }
 
 //__________________________________________________________________________________________________
+void ElementDescriptor::readMultiPageModel( StyleBag * all_styles )
+{
+    // collect styles
+    Style aStyle( 0x2 | 0x8 | 0x20 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextColor") ) ) >>= aStyle._textColor)
+        aStyle._set |= 0x2;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextLineColor") ) ) >>= aStyle._textLineColor)
+        aStyle._set |= 0x20;
+    if (readFontProps( this, aStyle ))
+        aStyle._set |= 0x8;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+
+    // collect elements
+    readDefaults();
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value-max") ) );
+
+    OUString aTitle;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("Label") ) ) >>= aTitle)
+    {
+        ElementDescriptor * title = new ElementDescriptor(
+            _xProps, _xPropState,
+            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":title") ) );
+        title->addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ),
+                             aTitle );
+        addSubElement( title );
+    }
+
+    readEvents();
+}
 void ElementDescriptor::readButtonModel( StyleBag * all_styles )
     SAL_THROW( (Exception) )
 {
@@ -206,7 +311,7 @@ void ElementDescriptor::readCheckBoxModel( StyleBag * all_styles )
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readComboBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readComboBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -247,7 +352,8 @@ void ElementDescriptor::readComboBoxModel( StyleBag * all_styles )
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxlength") ) );
     readShortAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("LineCount") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
-
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -273,7 +379,7 @@ void ElementDescriptor::readComboBoxModel( StyleBag * all_styles )
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readListBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readListBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -308,7 +414,7 @@ void ElementDescriptor::readListBoxModel( StyleBag * all_styles )
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
     readAlignAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );
-
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -348,7 +454,7 @@ void ElementDescriptor::readListBoxModel( StyleBag * all_styles )
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles )
+void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -385,6 +491,8 @@ void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles )
                            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":image-position") ) );
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multiline") ) );
+    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":group-name") ) );
 
     sal_Int16 nState = 0;
     if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ) ) >>= nState)
@@ -404,6 +512,7 @@ void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles )
             break;
         }
     }
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
@@ -576,7 +685,7 @@ void ElementDescriptor::readEditModel( StyleBag * all_styles )
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readImageControlModel( StyleBag * all_styles )
+void ElementDescriptor::readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -595,8 +704,31 @@ void ElementDescriptor::readImageControlModel( StyleBag * all_styles )
     readDefaults();
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scale-image") ) );
-    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":src") ) );
+    rtl::OUString sURL;
+    _xProps->getPropertyValue( OUSTR("ImageURL") ) >>= sURL;
+    
+    if ( sURL.indexOf( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.GraphicObject:"  ) ) ) == 0 )
+    {
+        Reference< document::XStorageBasedDocument > xDocStorage( xDocument, UNO_QUERY );
+
+        if ( xDocStorage.is() )
+        {
+            uno::Sequence< Any > aArgs( 1 );
+            aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+            ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+            uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+            aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicExportHelper" ), aArgs, xGraphicResolver );
+            if ( xGraphicResolver.is() )
+            {
+                sURL = xGraphicResolver->resolveGraphicObjectURL( sURL );
+            }
+        }     
+    }
+    if ( sURL.getLength() > 0 )
+    {
+        addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":src"), sURL );
+    }
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
     readEvents();
@@ -1073,7 +1205,7 @@ void ElementDescriptor::readProgressBarModel( StyleBag * all_styles )
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readScrollBarModel( StyleBag * all_styles )
+void ElementDescriptor::readScrollBarModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -1111,6 +1243,47 @@ void ElementDescriptor::readScrollBarModel( StyleBag * all_styles )
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":live-scroll") ) );
     readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
                      OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
+    readEvents();
+}
+//__________________________________________________________________________________________________
+void ElementDescriptor::readSpinButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
+    SAL_THROW( (Exception) )
+{
+    // collect styles
+    Style aStyle( 0x1 | 0x4 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("BackgroundColor") ) ) >>= aStyle._backgroundColor)
+        aStyle._set |= 0x1;
+    if (readBorderProps( this, aStyle ))
+        aStyle._set |= 0x4;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+    
+    // collect elements
+    readDefaults();
+    readOrientationAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                         OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );  
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":increment") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":curval") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxval") ) );
+    readLongAttr( OUSTR("SpinValueMin"),
+                  OUSTR(XMLNS_DIALOGS_PREFIX ":minval") );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Repeat") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":repeat") ) );
+    readLongAttr( OUSTR("RepeatDelay"), OUSTR(XMLNS_DIALOGS_PREFIX ":repeat-delay") );
+    readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
+    readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
diff --git xmlscript/source/xmldlg_imexp/xmldlg_export.cxx xmlscript/source/xmldlg_imexp/xmldlg_export.cxx
index 2898ac1..47b1d2f 100644
--- xmlscript/source/xmldlg_imexp/xmldlg_export.cxx
+++ xmlscript/source/xmldlg_imexp/xmldlg_export.cxx
@@ -1325,7 +1325,8 @@ void StyleBag::dump( Reference< xml::sax::XExtendedDocumentHandler > const & xOu
 //==================================================================================================
 void SAL_CALL exportDialogModel(
     Reference< xml::sax::XExtendedDocumentHandler > const & xOut,
-    Reference< container::XNameContainer > const & xDialogModel )
+    Reference< container::XNameContainer > const & xDialogModel,
+    Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     StyleBag all_styles;
@@ -1373,7 +1374,7 @@ void SAL_CALL exportDialogModel(
                 xProps, xPropState,
                 OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":radio") ) );
             xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-            pElem->readRadioButtonModel( &all_styles );
+            pElem->readRadioButtonModel( &all_styles, xDocument  );
             pRadioGroup->addSubElement( xElem );
         }
         else // no radio
@@ -1402,7 +1403,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":combobox") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readComboBoxModel( &all_styles );
+                pElem->readComboBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) ) )
             {
@@ -1410,7 +1411,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":menulist") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readListBoxModel( &all_styles );
+                pElem->readListBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) ) )
             {
@@ -1420,6 +1421,14 @@ void SAL_CALL exportDialogModel(
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
                 pElem->readGroupBoxModel( &all_styles );
             }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multipage") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readMultiPageModel( &all_styles );
+            }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFixedTextModel") ) ) )
             {
                 pElem = new ElementDescriptor(
@@ -1451,7 +1460,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":img") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readImageControlModel( &all_styles );
+                pElem->readImageControlModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFileControlModel") ) ) )
             {
@@ -1531,7 +1540,15 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scrollbar") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readScrollBarModel( &all_styles );
+                pElem->readScrollBarModel( &all_styles, xDocument );
+            }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlSpinButtonModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":spinbutton") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readSpinButtonModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlProgressBarModel") ) ) )
             {
diff --git xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx
index 1c43cc8..37a561f 100644
--- xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx
+++ xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx
@@ -28,17 +28,195 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_xmlscript.hxx"
 #include "imp_share.hxx"
-
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyState.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <com/sun/star/script/vba/XVBACompatibility.hpp>
 
-
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using ::rtl::OUString;
 
 namespace xmlscript
 {
+Reference< xml::input::XElement > MultiPage::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+rtl::OUString _label = rtl::OUString::createFromAscii("foo");
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement(
+            nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("title") ))
+	{
+		getStringAttr( &_label,
+                       OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                       xAttributes,
+                       _pImport->XMLNS_DIALOGS_UID );
+		
+		return new ElementBase(
+            _pImport->XMLNS_DIALOGS_UID,
+            rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
+
+void MultiPage::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) );
+//		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) );
+	Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		pStyle->importTextColorStyle( xControlModel );
+		pStyle->importTextLineColorStyle( xControlModel );
+		pStyle->importFontStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( 0, 0, _xAttributes ); // inherited from BulletinBoardElement
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value-max") ),
+                            _xAttributes );
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+// #FIXME cut'n'pasted from xmloff/source/core/xmlimp.cxx:1251 
+// of course we need to find a common home for this helper
+
+bool IsPackageURL( const ::rtl::OUString& rURL )
+{
+    // Some quick tests: Some may rely on the package structure!
+    sal_Int32 nLen = rURL.getLength();
+    if( (nLen > 0 && '/' == rURL[0]) )
+        // RFC2396 net_path or abs_path
+        return false;
+    else if( nLen > 1 && '.' == rURL[0] )
+    {
+        if( '.' == rURL[1] )
+            // ../: We are never going up one level, so we know
+            // it's not an external URI
+            return false;
+        else if( '/' == rURL[1] )
+            // we are remaining on a level, so it's an package URI
+            return true;
+    }
+
+    // Now check for a RFC2396 schema
+    sal_Int32 nPos = 1;
+    while( nPos < nLen )
+    {
+        switch( rURL[nPos] )
+        {
+            case '/':
+                // a relative path segement
+                return true;
+            case ':':
+                // a schema
+                return false;
+            default:
+                break;
+                // we don't care about any other characters
+        }
+        ++nPos;
+    }
+
+    return true;
+}
+
+void importBindableAndListRangeBits( DialogImport* _pImport, const rtl::OUString sLinkedCell, const rtl::OUString & sCellRange, ControlImportContext& ctx )
+{
+    Reference< lang::XMultiServiceFactory > xFac( _pImport->getDocOwner(), UNO_QUERY );
+    if ( xFac.is() && ( sLinkedCell.getLength() ||  sCellRange.getLength() ) )
+    {
+        // Set up Celllink
+        if ( sLinkedCell.getLength() )
+        {
+            Reference< form::binding::XBindableValue > xBindable( ctx.getControlModel(), uno::UNO_QUERY );
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+            if ( xBindable.is() && xConvertor.is() )
+            {
+                table::CellAddress aAddress;
+                xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sLinkedCell ) );
+                xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+                beans::NamedValue aArg1;
+                aArg1.Name = OUSTR("BoundCell");
+                aArg1.Value <<= aAddress;
+           
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[ 0 ]  <<= aArg1;
+           
+                uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+                xBindable->setValueBinding( xBinding );
+ 
+            }
+        }
+        // Set up CelllRange
+        if ( sCellRange.getLength() )
+        {
+           Reference< form::binding::XListEntrySink  > xListEntrySink( ctx.getControlModel(), uno::UNO_QUERY );
+           Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+           if ( xListEntrySink.is() && xConvertor.is() )
+           {
+               table::CellRangeAddress aAddress;
+               xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sCellRange ) );
+               xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+               beans::NamedValue aArg1;
+               aArg1.Name = OUSTR("CellRange");
+               aArg1.Value <<= aAddress;
+           
+               uno::Sequence< uno::Any > aArgs(1);
+               aArgs[ 0 ]  <<= aArg1;
+           
+               uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+               xListEntrySink->setListEntrySource( xSource );
+ 
+           }
+       }
+   }
+}
+
+sal_Bool isVBACompatibilityMode( DialogImport* _pImport )
+{
+	sal_Bool bVBAMode = sal_False;
+	Reference< script::vba::XVBACompatibility > xVBACompat( _pImport->getScriptLibraryContainer(), UNO_QUERY );
+	if( xVBACompat.is() )
+	{
+		bVBAMode = xVBACompat->getVBACompatibilityMode();
+	}
+	return bVBAMode;
+}
 
 // progessmeter
 //__________________________________________________________________________________________________
@@ -119,10 +297,24 @@ Reference< xml::input::XElement > ScrollBarElement::startChildElement(
 void ScrollBarElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+	OUString sService( OUSTR("com.sun.star.awt.UnoControlScrollBarModel") );
+	// we should probably limit this to vba mode also ( leave for now )
+	if ( isVBACompatibilityMode( _pImport ) )
+		sService = OUSTR("com.sun.star.form.component.ScrollBar");
+
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlScrollBarModel") ) );
-    
+		sService );	
+
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
     if (xStyle.is())
     {
@@ -165,6 +357,92 @@ void ScrollBarElement::endElement()
                                OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
                                _xAttributes );
     
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+//##################################################################################################
+
+// spinbutton
+//__________________________________________________________________________________________________
+Reference< xml::input::XElement > SpinButtonElement::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement( nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
+void SpinButtonElement::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.form.component.SpinButton") ) );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+        pStyle->importBackgroundColorStyle( xControlModel );
+		pStyle->importBorderStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( _nBasePosX, _nBasePosY, _xAttributes );
+	ctx.importOrientationProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                                   OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
+                                   _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("increment") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("curval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("maxval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("SpinValueMin"), OUSTR("minval"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("Repeat"), OUSTR("repeat"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("RepeatDelay"), OUSTR("repeat-delay"),
+                            _xAttributes );
+    ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
+                               _xAttributes );
+    ctx.importHexLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
+                               _xAttributes );
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+    
     ctx.importEvents( _events );
     // avoid ring-reference:
     // vector< event elements > holding event elements holding this (via _pParent)
@@ -1003,9 +1281,37 @@ void ImageControlElement::endElement()
     ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
                                OUString( RTL_CONSTASCII_USTRINGPARAM("scale-image") ),
                                _xAttributes );
-    ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-                              OUString( RTL_CONSTASCII_USTRINGPARAM("src") ),
-                              _xAttributes );
+    rtl::OUString sURL = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "src" ) );
+    Reference< document::XStorageBasedDocument > xDocStorage( _pImport->getDocOwner(), UNO_QUERY );
+
+    if ( xDocStorage.is() && IsPackageURL( sURL ) )
+    {
+        uno::Sequence< Any > aArgs( 1 );
+        aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+        ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+        uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+        aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicImportHelper" ), aArgs, xGraphicResolver );
+
+        if ( xGraphicResolver.is() )
+        {
+            rtl::OUString aTmp( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.Package:" ) );
+            aTmp += sURL;
+            sURL = xGraphicResolver->resolveGraphicObjectURL( aTmp );
+            Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+            // we must set the url while the graphic object ( held by the resolver is in scope )
+            if ( xProps.is() )
+                xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+        }
+    }
+    
+    else if ( sURL.getLength() > 0 )
+    {
+        Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+        if ( xProps.is() )
+            xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+    }
+
     ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                                OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
                                _xAttributes );
@@ -1338,10 +1644,24 @@ void TitledBoxElement::endElement()
         Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
         Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatibilityMode( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
+
         
         ControlImportContext ctx(
             _pImport, getControlId( xAttributes ),
-            OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
         Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
         
         Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1377,6 +1697,9 @@ void TitledBoxElement::endElement()
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
         
         sal_Int16 nVal = 0;
         sal_Bool bChecked = sal_False;
@@ -1390,7 +1713,7 @@ void TitledBoxElement::endElement()
         }
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
                                          makeAny( nVal ) );
-        
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
         ctx.importEvents( *radioEvents );
@@ -1466,10 +1789,23 @@ void RadioGroupElement::endElement()
         Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
         Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatibilityMode( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
         
         ControlImportContext ctx(
             _pImport, getControlId( xAttributes ),
-            OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
         Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
         
         Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1505,6 +1841,9 @@ void RadioGroupElement::endElement()
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
         sal_Int16 nVal = 0;
         sal_Bool bChecked = sal_False;
         if (getBoolAttr( &bChecked,
@@ -1518,6 +1857,7 @@ void RadioGroupElement::endElement()
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
                                          makeAny( nVal ) );
         
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
         ctx.importEvents( *radioEvents );
@@ -1638,9 +1978,26 @@ Reference< xml::input::XElement > MenuListElement::startChildElement(
 void MenuListElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sLinkedCell;
+        OUString sCellRange;
+        OUString sListBoxService( OUSTR("com.sun.star.awt.UnoControlListBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatibilityMode( _pImport ) )
+            sListBoxService = OUSTR("com.sun.star.form.component.ListBox");
+
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		//OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		sListBoxService );
     Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
     
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1673,13 +2030,16 @@ void MenuListElement::endElement()
     ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
-    
+        // import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
     if (_popup.is())
     {
         MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
-        xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
+        if (  !sCellRange.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
                                          makeAny( p->getItemValues() ) );
-        xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
+        if (  !sLinkedCell.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
                                          makeAny( p->getSelectedItems() ) );
     }
     ctx.importEvents( _events );
@@ -1725,9 +2085,26 @@ Reference< xml::input::XElement > ComboBoxElement::startChildElement(
 void ComboBoxElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sService( OUSTR("com.sun.star.awt.UnoControlComboBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatibilityMode( _pImport ) )
+            sService = OUSTR("com.sun.star.form.component.ComboBox");
+
+        OUString sLinkedCell;
+        OUString sCellRange;
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
+
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlComboBoxModel") ) );
+		sService );
     Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
     
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1769,8 +2146,10 @@ void ComboBoxElement::endElement()
     ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
+	// import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
     
-    if (_popup.is())
+	if (_popup.is() && !sCellRange.getLength() )
     {
         MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
@@ -2096,10 +2475,19 @@ Reference< xml::input::XElement > BulletinBoardElement::startChildElement(
     {
         return new ScrollBarElement( rLocalName, xAttributes, this, _pImport );
     }
+	// spinbutton
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("spinbutton") ) && isVBACompatibilityMode( _pImport ) )
+	{
+		return new SpinButtonElement( rLocalName, xAttributes, this, _pImport );
+	}
     // progressmeter
     else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("progressmeter") ))
     {
         return new ProgressBarElement( rLocalName, xAttributes, this, _pImport );
+	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("multipage") ))
+	{
+		return new MultiPage( rLocalName, xAttributes, this, _pImport );
     }
     // bulletinboard
     else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("bulletinboard") ))
diff --git xmlscript/source/xmldlg_imexp/xmldlg_import.cxx xmlscript/source/xmldlg_imexp/xmldlg_import.cxx
index f3c0e55..0f03070 100644
--- xmlscript/source/xmldlg_imexp/xmldlg_import.cxx
+++ xmlscript/source/xmldlg_imexp/xmldlg_import.cxx
@@ -57,9 +57,13 @@
 #include <com/sun/star/script/ScriptEventDescriptor.hpp>
 
 #include <com/sun/star/view/SelectionType.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/script/DocumentScriptLibraryContainer.hpp>
+#include <com/sun/star/script/vba/XVBACompatibility.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 using ::rtl::OUString;
 
 namespace xmlscript
@@ -1888,18 +1892,42 @@ Reference< xml::input::XElement > DialogImport::getStyle(
     }
     return 0;
 }
+//__________________________________________________________________________________________________
+Reference< script::XLibraryContainer > DialogImport::getScriptLibraryContainer()
+{
+	if( !_xScriptLibraryContainer.is() )
+	{
+		try
+		{
+			Reference< beans::XPropertySet > xProps( _xDoc, UNO_QUERY );
+			if( xProps.is() )
+				_xScriptLibraryContainer.set( xProps->getPropertyValue( OUSTR("BasicLibraries") ), UNO_QUERY );
+		}
+		catch( const Exception& )
+		{
+		}
+	}
+
+	return _xScriptLibraryContainer;
+}
 
 //##################################################################################################
 
 //==================================================================================================
 Reference< xml::sax::XDocumentHandler > SAL_CALL importDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
+    DialogImport* pImport = new DialogImport( xContext, xDialogModel, xDocument );
+    uno::Reference< script::vba::XVBACompatibility > xVBAModeSource( pImport->getScriptLibraryContainer(), uno::UNO_QUERY );
+    
+    uno::Reference< beans::XPropertySet > xDlgProps( xDialogModel, uno::UNO_QUERY );
+    if ( xVBAModeSource.is() && xDlgProps.is() && xVBAModeSource->getVBACompatibilityMode() )
+        xDlgProps->setPropertyValue( OUSTR("VBAForm"), uno::makeAny( sal_True ) );
     return ::xmlscript::createDocumentHandler(
-        static_cast< xml::input::XRoot * >(
-            new DialogImport( xContext, xDialogModel ) ) );
+        static_cast< xml::input::XRoot * >( pImport ) );
 }
 
 }
diff --git xmlscript/util/makefile.mk xmlscript/util/makefile.mk
index 3ccf63d..7a391cd 100644
--- xmlscript/util/makefile.mk
+++ xmlscript/util/makefile.mk
@@ -54,6 +54,7 @@ SHL1LIBS= \
         $(LIB1TARGET)
 
 SHL1STDLIBS= \
+		$(COMPHELPERLIB)                \
         $(CPPUHELPERLIB)		\
         $(CPPULIB) 			\
         $(SALLIB)
