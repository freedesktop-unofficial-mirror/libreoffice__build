--- basctl/inc/basidesh.hrc.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/inc/basidesh.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -184,6 +184,10 @@
 #define	RID_STR_DLGIMP_MISMATCH_OMIT	( RID_BASICIDE_START + 115 )
 #define	RID_STR_DLGIMP_MISMATCH_TITLE	( RID_BASICIDE_START + 116 )
 #define	RID_STR_DLGIMP_MISMATCH_TEXT	( RID_BASICIDE_START + 117 )
+#define RID_STR_DOCUMENT_OBJECTS        ( RID_BASICIDE_START + 118 )
+#define RID_STR_USERFORMS               ( RID_BASICIDE_START + 119 )
+#define RID_STR_NORMAL_MODULES          ( RID_BASICIDE_START + 120 )
+#define RID_STR_CLASS_MODULES           ( RID_BASICIDE_START + 121 )
 
 #endif	// _SVX_NOIDERESIDS
 
--- basctl/source/basicide/baside2.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/basicide/baside2.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -49,6 +49,7 @@
 #include <com/sun/star/script/XLibraryContainer2.hpp>
 #endif
 #include <com/sun/star/document/MacroExecMode.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 #include <toolkit/helper/vclunohelper.hxx>
 #include <sfx2/docfile.hxx>
 #include <basic/basrdll.hxx>
@@ -110,6 +111,8 @@ DBG_NAME( ModulWindow )
 
 TYPEINIT1( ModulWindow , IDEBaseWindow );
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName );
+
 void lcl_PrintHeader( Printer* pPrinter, USHORT nPages, USHORT nCurPage, const String& rTitle )
 {
     short nLeftMargin 	= LMARGPRN;
@@ -331,6 +334,8 @@ BOOL ModulWindow::BasicExecute()
             DBG_ASSERT( xModule.Is(), "Kein Modul!" );
             AddStatus( BASWIN_RUNNINGBASIC );
             USHORT nStart, nEnd, nCurMethodStart = 0;
+			TextSelection aSel = GetEditView()->GetSelection();
+			nCurMethodStart = ( aSel.GetStart().GetPara() + 1 );
             SbMethod* pMethod = 0;
             // erstes Macro, sonst blind "Main" (ExtSearch?)
             for ( USHORT nMacro = 0; nMacro < xModule->GetMethods()->Count(); nMacro++ )
@@ -338,16 +343,16 @@ BOOL ModulWindow::BasicExecute()
                 SbMethod* pM = (SbMethod*)xModule->GetMethods()->Get( nMacro );
                 DBG_ASSERT( pM, "Method?" );
                 pM->GetLineRange( nStart, nEnd );
-                if ( !pMethod || ( nStart < nCurMethodStart ) )
+				if (  nCurMethodStart >= nStart && nCurMethodStart <= nEnd ) 
                 {
                     pMethod = pM;
-                    nCurMethodStart = nStart;
+					break;
                 }
             }
             if ( !pMethod )
-                pMethod = (SbMethod*)xModule->Find( String( RTL_CONSTASCII_USTRINGPARAM( "Main" ) ), SbxCLASS_METHOD );
+				return ( BasicIDE::ChooseMacro( uno::Reference< frame::XModel >(), FALSE, rtl::OUString() ).getLength() > 0 ) ? TRUE : FALSE;
 
-            if ( pMethod )
+			else
             {
                 pMethod->SetDebugFlags( aStatus.nBasicFlags );
                 BasicDLL::SetDebugMode( TRUE );
@@ -1359,7 +1364,39 @@ BasicEntryDescriptor ModulWindow::Create
     ScriptDocument aDocument( GetDocument() );
     String aLibName( GetLibName() );
     LibraryLocation eLocation = aDocument.getLibraryLocation( aLibName );
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, GetName(), OBJ_TYPE_MODULE );
+    String aModName( GetName() );
+    String aLibSubName;
+    if( xBasic.Is() && xBasic->isVBAEnabled() && xModule.Is() )
+    {
+        switch( xModule->GetModuleType() )
+        {
+            case script::ModuleType::Document:
+            {
+                aLibSubName = String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) );
+                uno::Reference< container::XNameContainer > xLib = aDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
+                if( xLib.is() )
+                {
+                    String sObjName;
+                    lcl_getObjectName( xLib, aModName, sObjName );
+                    if( sObjName.Len() )
+                    {
+                        aModName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+                    }
+                }
+                break;
+            }    
+            case script::ModuleType::Form:
+                aLibSubName = String( IDEResId( RID_STR_USERFORMS ) );
+                break;
+            case script::ModuleType::Normal:
+                aLibSubName = String( IDEResId( RID_STR_NORMAL_MODULES ) );
+                break;
+            case script::ModuleType::Class:
+                aLibSubName = String( IDEResId( RID_STR_CLASS_MODULES ) );
+                break;
+        }
+    }
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aModName, OBJ_TYPE_MODULE );
 }
 
 void ModulWindow::SetReadOnly( BOOL b )
--- basctl/source/basicide/baside3.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/basicide/baside3.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -85,6 +85,7 @@
 #include <com/sun/star/resource/XStringResourceResolver.hpp>
 #include <com/sun/star/resource/StringResourceWithLocation.hpp>
 #include <com/sun/star/task/XInteractionHandler.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 using namespace comphelper;
 using namespace	::com::sun::star;
@@ -115,8 +116,16 @@ DialogWindow::DialogWindow( Window* pPar
 {
     InitSettings( TRUE, TRUE, TRUE );
 
-    pEditor = new DlgEditor();
+	pEditor = new DlgEditor( rDocument.getDocument() );
     pEditor->SetWindow( this );
+	// set vba mode on DialogModel ( allows it to work in 100thmm instead of MAP_APPFONT )
+	if ( rDocument.getDocument().is() )
+	{
+		uno::Reference< script::XVBACompat > xDocVBAMode( rDocument.getLibraryContainer( E_SCRIPTS ), uno::UNO_QUERY );
+		uno::Reference< script::XVBACompat > xDialogModelVBAMode( xDialogModel, uno::UNO_QUERY );
+		if ( xDocVBAMode.is()  &&  xDialogModelVBAMode.is() )
+			xDialogModelVBAMode->setVBACompatModeOn( xDocVBAMode->getVBACompatModeOn() );
+	}
     pEditor->SetDialog( xDialogModel );
 
     // Undo einrichten
@@ -731,7 +740,7 @@ BOOL DialogWindow::SaveDialog()
         Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
         OSL_ASSERT( xProps.is() );
         OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-        Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().getDocument() );
         Reference< XInputStream > xInput( xISP->createInputStream() );
 
         Reference< XSimpleFileAccess > xSFI( xMSF->createInstance
@@ -1013,7 +1022,7 @@ BOOL implImportDialog( Window* pWin, con
             Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
             OSL_ASSERT( xProps.is() );
             OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+            ::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.getDocument() );
 
             String aXmlDlgName;
             Reference< beans::XPropertySet > xDialogModelPropSet( xDialogModel, UNO_QUERY );
@@ -1239,7 +1248,7 @@ BOOL implImportDialog( Window* pWin, con
                 }
             }
 
-            Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+            Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDocument.getDocument() );
             bool bSuccess = rDocument.insertDialog( aLibName, aNewDlgName, xISP );
             if( bSuccess )
             {
@@ -1300,8 +1309,9 @@ BasicEntryDescriptor DialogWindow::Creat
 {
     ScriptDocument aDocument( GetDocument() );
     String aLibName( GetLibName() );
+    String aLibSubName;
     LibraryLocation eLocation = aDocument.getLibraryLocation( aLibName );
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, GetName(), OBJ_TYPE_DIALOG );
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, GetName(), OBJ_TYPE_DIALOG );
 }
 
 void DialogWindow::SetReadOnly( BOOL b )
@@ -1348,7 +1358,7 @@ void DialogWindow::StoreData()
                     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+					Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().getDocument() );
                     xLib->replaceByName( ::rtl::OUString( GetName() ), makeAny( xISP ) );
                 }
             }
--- basctl/source/basicide/basides1.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/basides1.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -1201,10 +1201,16 @@ IDEBaseWindow* BasicIDEShell::FindWindow
                 // return any non-suspended window
                 return pWin;
             }
-            else if ( pWin->IsDocument( rDocument ) && pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
+            else if ( pWin->IsDocument( rDocument ) )
+            {
+                OSL_TRACE("FindWindow pWin->GetLibName() %s rLibName %s",
+			rtl::OUStringToOString( pWin->GetLibName(), RTL_TEXTENCODING_UTF8 ).getStr(),
+			rtl::OUStringToOString( rLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( ModulWindow ) %d && nType %d = BASICIDE_TYPE_MODULE %d", pWin->IsA( TYPE( ModulWindow ) ), nType, BASICIDE_TYPE_MODULE );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( DialogWindow ) %d && nType %d = BASICIDE_TYPE_DIALOG %d", pWin->IsA( TYPE( DialogWindow ) ), nType, BASICIDE_TYPE_DIALOG );
+		if (  pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
                       ( ( pWin->IsA( TYPE( ModulWindow ) )  && nType == BASICIDE_TYPE_MODULE ) ||
                         ( pWin->IsA( TYPE( DialogWindow ) ) && nType == BASICIDE_TYPE_DIALOG ) ) )
-            {
                 return pWin;
             }
         }
--- basctl/source/basicide/basides2.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/basides2.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -55,11 +55,38 @@
 #include <tools/diagnose_ex.h>
 #include <sfx2/sfxdefs.hxx>
 #include <sfx2/signaturestate.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 namespace css = ::com::sun::star;
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName )
+{
+    try
+    {
+		uno::Any aElement( rLib->getByName( rModName ) );
+		script::ModuleInfo aModuleInfo;
+		if( aElement >>= aModuleInfo )
+		{
+			uno::Any aObject( aModuleInfo.ModuleObject );
+			uno::Reference< lang::XServiceInfo > xServiceInfo( aObject, uno::UNO_QUERY );
+			if( xServiceInfo.is() && xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Worksheet" ) ) )
+			{
+				uno::Reference< container::XNamed > xNamed( aObject, uno::UNO_QUERY );
+				if( xNamed.is() )
+					rObjName = xNamed->getName();
+			}
+		}
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
 IMPL_LINK_INLINE_START( BasicIDEShell, ObjectDialogCancelHdl, ObjectCatalog *, EMPTYARG )
 {
     ShowObjectDialog( FALSE, TRUE );
@@ -232,7 +259,7 @@ ModulWindow* BasicIDEShell::CreateBasWin
     if ( !aLibName.Len() )
         aLibName = String::CreateFromAscii( "Standard" );
 
-    rDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
+    uno::Reference< container::XNameContainer > xLib = rDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
 
     if ( !aModName.Len() )
         aModName = rDocument.createObjectName( E_SCRIPTS, aLibName );
@@ -251,9 +278,12 @@ ModulWindow* BasicIDEShell::CreateBasWin
 
         if ( bSuccess )
         {
-            // new module window
-            pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
-            nKey = InsertWindowInTable( pWin );
+			pWin = FindBasWin( rDocument, aLibName, aModName, FALSE, TRUE );
+            if( !pWin )
+			{    // new module window
+			    pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
+			    nKey = InsertWindowInTable( pWin );
+            }
         }
     }
     else
@@ -268,7 +298,21 @@ ModulWindow* BasicIDEShell::CreateBasWin
         }
         DBG_ASSERT( nKey, "CreateBasWin: Kein Key- Fenster nicht gefunden!" );
     }
-    pTabBar->InsertPage( (USHORT)nKey, aModName );
+    if( nKey )
+	{
+		if( xLib.is() )
+		{
+			// display a nice friendly name in the ObjectModule tab,
+			// combining the objectname and module name, e.g. Sheet1 ( Financials )
+			String sObjName;
+			lcl_getObjectName( xLib, rModName, sObjName );
+			if( sObjName.Len() )
+			{
+				aModName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+			}
+		}
+		pTabBar->InsertPage( (USHORT)nKey, aModName );
+	}	
     pTabBar->Sort();
     pWin->GrabScrollBars( &aHScrollBar, &aVScrollBar );
     if ( !pCurWin )
--- basctl/source/basicide/basides3.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/basicide/basides3.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -99,7 +99,7 @@ DialogWindow* BasicIDEShell::CreateDlgWi
                 Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                 OSL_ASSERT( xProps.is() );
                 OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+				::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.getDocument() );
                 LocalizationMgr::setStringResourceAtDialog( rDocument, rLibName, aDlgName, xDialogModel );
 
                 // new dialog window
--- basctl/source/basicide/basidesh.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/basidesh.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -80,6 +80,9 @@
 #include <com/sun/star/script/XLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/container/XContainerListener.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 
 #include <svx/xmlsecctrl.hxx>
 
@@ -87,6 +90,71 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
+static const rtl::OUString sStandardLibName(  rtl::OUString::createFromAscii("Standard") );
+
+typedef ::cppu::WeakImplHelper1< container::XContainerListener > ContainerListenerBASE;
+
+class ContainerListenerImpl : public ContainerListenerBASE
+{
+    BasicIDEShell* mpShell;
+public:
+
+    ContainerListenerImpl( BasicIDEShell* pShell ) : mpShell( pShell ) {}
+
+    ~ContainerListenerImpl() 
+    {
+    }
+
+    void addContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument() && xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+                xContainer->addContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+    void removeContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument(), xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+               xContainer->removeContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& ) throw( uno::RuntimeException ) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& Event ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell && ( Event.Accessor >>= sModuleName ) )
+            mpShell->FindBasWin( mpShell->m_aCurDocument, sStandardLibName, sModuleName, TRUE, FALSE );
+    }
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& ) throw( com::sun::star::uno::RuntimeException ) { }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& Event ) throw( com::sun::star::uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell  && ( Event.Accessor >>= sModuleName ) )
+        {
+            IDEBaseWindow* pWin = mpShell->FindWindow( mpShell->m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+            if( pWin )
+                mpShell->RemoveWindow( pWin, FALSE, TRUE );
+        }
+    }
+
+};
 
 TYPEINIT1( BasicIDEShell, SfxViewShell );
 
@@ -124,6 +192,7 @@ BasicIDEShell::BasicIDEShell( SfxViewFra
         m_bAppBasicModified( FALSE ),
         m_aNotifier( *this )
 {
+    m_xLibListener = new ContainerListenerImpl( this );
     Init();
     GnBasicIDEShellCount++;
 }
@@ -215,6 +284,12 @@ __EXPORT BasicIDEShell::~BasicIDEShell()
     delete pTabBar;
     delete pObjectCatalog;
     DestroyModulWindowLayout();
+
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        // Destroy all ContainerListeners for Basic Container.
+        if ( pListener )
+            pListener->removeContainerListener( m_aCurDocument );
+    
     // MI: Das gab einen GPF im SDT beim Schliessen da dann der ViewFrame die
     // ObjSh loslaesst. Es wusste auch keiner mehr wozu das gut war.
     // GetViewFrame()->GetObjectShell()->Broadcast( SfxSimpleHint( SFX_HINT_DYING ) );
@@ -921,7 +996,15 @@ void BasicIDEShell::SetCurLib( const Scr
 {
     if ( !bCheck || ( rDocument != m_aCurDocument || aLibName != m_aCurLibName ) )
     {
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        if ( pListener )
+        	pListener->removeContainerListener( m_aCurDocument );
+
         m_aCurDocument = rDocument;
+
+        if ( pListener )
+            pListener->addContainerListener( m_aCurDocument );
+
         m_aCurLibName = aLibName;
         if ( bUpdateWindows )
             UpdateWindows();
--- basctl/source/basicide/basidesh.src.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/basicide/basidesh.src	2010-03-03 16:59:34.000000000 +0100
@@ -639,6 +639,22 @@ String RID_STR_TRANSLATION_DEFAULT
 {
     Text [ en-US ] = "[Default Language]" ;
 };
+String RID_STR_DOCUMENT_OBJECTS
+{
+    Text [ en-US ] = "Document Objects" ;
+};
+String RID_STR_USERFORMS
+{
+    Text [ en-US ] = "Forms" ;
+};
+String RID_STR_NORMAL_MODULES
+{
+    Text [ en-US ] = "Modules" ;
+};
+String RID_STR_CLASS_MODULES
+{
+    Text [ en-US ] = "Class Modules" ;
+};
 
 
 String RID_STR_DLGIMP_CLASH_RENAME
--- basctl/source/basicide/bastype2.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/bastype2.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -53,10 +53,25 @@
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <comphelper/processfactory.hxx>
 #include <comphelper/componentcontext.hxx>
+#include <map>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName );
+
+sal_Int32 lcl_getModuleType(  const uno::Reference< container::XNameContainer >& rLib, const String& rModName )
+{
+    sal_Int32 nType = com::sun::star::script::ModuleType::Normal;
+    uno::Any aElement( rLib->getByName( rModName ) );
+    script::ModuleInfo aModuleInfo;
+    if( aElement >>= aModuleInfo )
+        nType = aModuleInfo.ModuleType;
+    return nType;    
+}
 
 BasicEntry::~BasicEntry()
 {
@@ -91,20 +106,22 @@ BasicEntryDescriptor::BasicEntryDescript
 {
 }
 
-BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, BasicEntryType eType )
+BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, BasicEntryType eType )
     :m_aDocument( rDocument )
     ,m_eLocation( eLocation )
     ,m_aLibName( rLibName )
+    ,m_aLibSubName( rLibSubName )
     ,m_aName( rName )
     ,m_eType( eType )
 {
     OSL_ENSURE( m_aDocument.isValid(), "BasicEntryDescriptor::BasicEntryDescriptor: invalid document!" );
 }
 
-BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, const String& rMethodName, BasicEntryType eType )
+BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, const String& rMethodName, BasicEntryType eType )
     :m_aDocument( rDocument )
     ,m_eLocation( eLocation )
     ,m_aLibName( rLibName )
+    ,m_aLibSubName( rLibSubName )
     ,m_aName( rName )
     ,m_aMethodName( rMethodName )
     ,m_eType( eType )
@@ -120,6 +137,7 @@ BasicEntryDescriptor::BasicEntryDescript
     :m_aDocument( rDesc.m_aDocument )
     ,m_eLocation( rDesc.m_eLocation )
     ,m_aLibName( rDesc.m_aLibName )
+    ,m_aLibSubName( rDesc.m_aLibSubName )
     ,m_aName( rDesc.m_aName )
     ,m_aMethodName( rDesc.m_aMethodName )
     ,m_eType( rDesc.m_eType )
@@ -131,6 +149,7 @@ BasicEntryDescriptor& BasicEntryDescript
     m_aDocument = rDesc.m_aDocument;
     m_eLocation = rDesc.m_eLocation;
     m_aLibName = rDesc.m_aLibName;
+    m_aLibSubName = rDesc.m_aLibSubName;
     m_aName = rDesc.m_aName;
     m_aMethodName = rDesc.m_aMethodName;
     m_eType = rDesc.m_eType;
@@ -143,6 +162,7 @@ bool BasicEntryDescriptor::operator==( c
     return m_aDocument == rDesc.m_aDocument &&
            m_eLocation == rDesc.m_eLocation &&
            m_aLibName == rDesc.m_aLibName &&
+           m_aLibSubName == rDesc.m_aLibSubName &&
            m_aName == rDesc.m_aName &&
            m_aMethodName == rDesc.m_aMethodName &&
            m_eType == rDesc.m_eType;
@@ -286,50 +306,58 @@ void BasicTreeListBox::ImpCreateLibSubEn
         if ( xModLibContainer.is() && xModLibContainer->hasByName( aOULibName ) && xModLibContainer->isLibraryLoaded( aOULibName ) )
         {
             try
-            {
-                // get a sorted list of module names
-                Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
-                sal_Int32 nModCount = aModNames.getLength();
-                const ::rtl::OUString* pModNames = aModNames.getConstArray();
-
-                for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
+		 	{
+                BasicManager* pBasMgr = rDocument.getBasicManager();
+                StarBASIC* pBasic = pBasMgr ? pBasMgr->GetLib( rLibName ) : 0;
+                sal_Bool bVBAEnabled = pBasic ? pBasic->isVBAEnabled(): sal_False;
+                if( bVBAEnabled )
+                    ImpCreateLibSubEntriesInVBAMode( pLibRootEntry, rDocument, rLibName );
+                else
                 {
-                    String aModName = pModNames[ i ];
-                    SvLBoxEntry* pModuleEntry = FindEntry( pLibRootEntry, aModName, OBJ_TYPE_MODULE );
-                    if ( !pModuleEntry )
-                        pModuleEntry = AddEntry(
-                            aModName,
-                            Image( IDEResId( RID_IMG_MODULE ) ),
-                            Image( IDEResId( RID_IMG_MODULE_HC ) ),
-                            pLibRootEntry, false,
-                            std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
-
-                    // methods
-                    if ( nMode & BROWSEMODE_SUBS )
-                    {
-                        Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
-                        sal_Int32 nCount = aNames.getLength();
-                        const ::rtl::OUString* pNames = aNames.getConstArray();
-
-                        for ( sal_Int32 j = 0 ; j < nCount ; j++ )
-                        {
-                            String aName = pNames[ j ];
-                            SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
-                            if ( !pEntry )
-                                pEntry = AddEntry(
-                                    aName,
-                                    Image( IDEResId( RID_IMG_MACRO ) ),
-                                    Image( IDEResId( RID_IMG_MACRO_HC ) ),
-                                    pModuleEntry, false,
-                                    std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
+                    // get a sorted list of module names
+                    Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
+                    sal_Int32 nModCount = aModNames.getLength();
+		            const ::rtl::OUString* pModNames = aModNames.getConstArray();
+
+                    for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
+		 			{
+                        String aModName = pModNames[ i ];
+                        SvLBoxEntry* pModuleEntry = FindEntry( pLibRootEntry, aModName, OBJ_TYPE_MODULE );
+                        if ( !pModuleEntry )
+                            pModuleEntry = AddEntry(
+                                aModName,
+                                Image( IDEResId( RID_IMG_MODULE ) ),
+                                Image( IDEResId( RID_IMG_MODULE_HC ) ),
+                                pLibRootEntry, false,
+                                std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
+
+		 				// methods
+		 				if ( nMode & BROWSEMODE_SUBS )
+		 				{
+                            Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
+		 					sal_Int32 nCount = aNames.getLength();
+		 					const ::rtl::OUString* pNames = aNames.getConstArray();
+
+		 					for ( sal_Int32 j = 0 ; j < nCount ; j++ )
+		 					{
+		 						String aName = pNames[ j ];
+		 						SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
+                                if ( !pEntry )
+                                    pEntry = AddEntry(
+                                        aName,
+                                        Image( IDEResId( RID_IMG_MACRO ) ),
+                                        Image( IDEResId( RID_IMG_MACRO_HC ) ),
+                                        pModuleEntry, false,
+                                        std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
+		 					}
                         }
-                    }
+		 			}
                 }
             }
-            catch ( const container::NoSuchElementException& )
-            {
+		 	catch ( const container::NoSuchElementException& )
+		 	{
                 DBG_UNHANDLED_EXCEPTION();
-            }
+		 	}
         }   
     }
 
@@ -368,6 +396,139 @@ void BasicTreeListBox::ImpCreateLibSubEn
     }
 }
 
+void BasicTreeListBox::ImpCreateLibSubEntriesInVBAMode( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName )
+{
+    ::std::map< BasicEntryType, ::rtl::OUString > aEntryMap;
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_DOCUMENT_OBJECTS, String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_USERFORMS,  String( IDEResId( RID_STR_USERFORMS ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_NORMAL_MODULES, String( IDEResId( RID_STR_NORMAL_MODULES ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_CLASS_MODULES,  String( IDEResId( RID_STR_CLASS_MODULES ) ) ) );
+
+    ::std::map< BasicEntryType, ::rtl::OUString >::iterator iter;
+    for( iter = aEntryMap.begin(); iter != aEntryMap.end(); ++iter )
+    {
+        BasicEntryType eType = iter->first;
+        ::rtl::OUString aEntryName = iter->second;
+        SvLBoxEntry* pLibSubRootEntry = FindEntry( pLibRootEntry, aEntryName, eType );
+        if( pLibSubRootEntry )
+        {
+            SetEntryBitmaps( pLibSubRootEntry, Image( IDEResId( RID_IMG_MODLIB ) ), Image( IDEResId( RID_IMG_MODLIB_HC ) ) );
+            if ( IsExpanded( pLibSubRootEntry ) )
+			    ImpCreateLibSubSubEntriesInVBAMode( pLibSubRootEntry, rDocument, rLibName );
+        }
+        else
+        {
+            pLibSubRootEntry = AddEntry(
+                aEntryName,
+                Image( IDEResId( RID_IMG_MODLIB ) ),
+                Image( IDEResId( RID_IMG_MODLIB_HC ) ),
+                pLibRootEntry, true,
+                std::auto_ptr< BasicEntry >( new BasicEntry( eType ) ) );
+        }
+    }
+}
+
+void BasicTreeListBox::ImpCreateLibSubSubEntriesInVBAMode( SvLBoxEntry* pLibSubRootEntry, const ScriptDocument& rDocument, const String& rLibName )
+{
+    uno::Reference< container::XNameContainer > xLib = rDocument.getOrCreateLibrary( E_SCRIPTS, rLibName );
+    if( !xLib.is() )
+        return;
+
+    try
+	{
+        // get a sorted list of module names
+        Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
+        sal_Int32 nModCount = aModNames.getLength();
+    	const ::rtl::OUString* pModNames = aModNames.getConstArray();
+
+        BasicEntryDescriptor aDesc( GetEntryDescriptor( pLibSubRootEntry ) );
+        BasicEntryType eCurrentType( aDesc.GetType() );
+
+        for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
+		{
+            String aModName = pModNames[ i ];
+            BasicEntryType eType = OBJ_TYPE_UNKNOWN;
+            switch( lcl_getModuleType( xLib, aModName ) )
+            {
+                case script::ModuleType::Document:
+                    eType = OBJ_TYPE_DOCUMENT_OBJECTS;
+                    break;
+                case script::ModuleType::Form:
+                    eType = OBJ_TYPE_USERFORMS;
+                    break;
+                case script::ModuleType::Normal:
+                    eType = OBJ_TYPE_NORMAL_MODULES;
+                    break;
+                case script::ModuleType::Class:
+                    eType = OBJ_TYPE_CLASS_MODULES;
+                    break;
+            }
+            if( eType != eCurrentType )
+                continue;
+
+			// display a nice friendly name in the ObjectModule tab,
+           	// combining the objectname and module name, e.g. Sheet1 ( Financials )
+            String aEntryName( aModName );
+            if( eType == OBJ_TYPE_DOCUMENT_OBJECTS )
+            {
+	       	    String sObjName;
+            	lcl_getObjectName( xLib, aModName, sObjName );
+		    	if( sObjName.Len() )
+        	   	{
+		        	aEntryName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+            	}
+            }
+            SvLBoxEntry* pModuleEntry = FindEntry( pLibSubRootEntry, aEntryName, OBJ_TYPE_MODULE );
+            if ( !pModuleEntry )
+                pModuleEntry = AddEntry(
+                    aEntryName,
+                    Image( IDEResId( RID_IMG_MODULE ) ),
+                    Image( IDEResId( RID_IMG_MODULE_HC ) ),
+                    pLibSubRootEntry, false,
+                    std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
+
+			// methods
+			if ( nMode & BROWSEMODE_SUBS )
+			{
+                Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
+				sal_Int32 nCount = aNames.getLength();
+				const ::rtl::OUString* pNames = aNames.getConstArray();
+
+				for ( sal_Int32 j = 0 ; j < nCount ; j++ )
+				{
+					String aName = pNames[ j ];
+					SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
+                    if ( !pEntry )
+                        pEntry = AddEntry(
+                            aName,
+                            Image( IDEResId( RID_IMG_MACRO ) ),
+                            Image( IDEResId( RID_IMG_MACRO_HC ) ),
+                            pModuleEntry, false,
+                            std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
+    			}
+            }
+	    }
+    }
+    catch ( const container::NoSuchElementException& )
+	{
+        DBG_UNHANDLED_EXCEPTION();
+    }
+}
+
+SvLBoxEntry* BasicTreeListBox::ImpFindEntry( SvLBoxEntry* pParent, const String& rText )
+{
+	ULONG nRootPos = 0;
+	SvLBoxEntry* pEntry = pParent ? FirstChild( pParent ) : GetEntry( nRootPos );
+	while ( pEntry )
+	{
+		if (  GetEntryText( pEntry ) == rText ) 
+			return pEntry;
+
+		pEntry = pParent ? NextSibling( pEntry ) : GetEntry( ++nRootPos );
+	}
+	return 0;
+}
+
 void BasicTreeListBox::onDocumentCreated( const ScriptDocument& /*_rDocument*/ )
 {
     UpdateEntries();
@@ -480,10 +641,11 @@ long BasicTreeListBox::ExpandingHdl()
         if ( aDocument.isAlive() )
         {
             String aLibName( aDesc.GetLibName() );
+            String aLibSubName( aDesc.GetLibSubName() );
             String aName( aDesc.GetName() );
             String aMethodName( aDesc.GetMethodName() );
 
-            if ( aLibName.Len() && !aName.Len() && !aMethodName.Len() )
+            if ( aLibName.Len() && !aLibSubName.Len() && !aName.Len() && !aMethodName.Len() )
             {
                 // check password, if library is password protected and not verified
                 ::rtl::OUString aOULibName( aLibName );
@@ -636,7 +798,7 @@ void BasicTreeListBox::SetCurrentEntry(
         aDesc = BasicEntryDescriptor(
             ScriptDocument::getApplicationScriptDocument(),
             LIBRARY_LOCATION_USER, String::CreateFromAscii( "Standard" ), 
-            String::CreateFromAscii( "." ), OBJ_TYPE_UNKNOWN );
+            String(), String::CreateFromAscii( "." ), OBJ_TYPE_UNKNOWN );
     }
     ScriptDocument aDocument( aDesc.GetDocument() );
     OSL_ENSURE( aDocument.isValid(), "BasicTreeListBox::SetCurrentEntry: invalid document!" );
@@ -653,14 +815,24 @@ void BasicTreeListBox::SetCurrentEntry(
             if ( pLibEntry )
             {
                 pCurEntry = pLibEntry;
+                String aLibSubName( aDesc.GetLibSubName() );
+                if( aLibSubName.Len() )
+                {
+                    Expand( pLibEntry );
+                    SvLBoxEntry* pLibSubEntry = ImpFindEntry( pLibEntry, aLibSubName );
+                    if( pLibSubEntry )
+                    {
+                        pCurEntry = pLibSubEntry;
+                    }
+                }
                 String aName( aDesc.GetName() );
                 if ( aName.Len() )
                 {
-                    Expand( pLibEntry );
+                    Expand( pCurEntry );
                     BasicEntryType eType = OBJ_TYPE_MODULE;
                     if ( aDesc.GetType() == OBJ_TYPE_DIALOG )
                         eType = OBJ_TYPE_DIALOG;
-                    SvLBoxEntry* pEntry = FindEntry( pLibEntry, aName, eType );
+                    SvLBoxEntry* pEntry = FindEntry( pCurEntry, aName, eType );
                     if ( pEntry )
                     {
                         pCurEntry = pEntry;
--- basctl/source/basicide/bastype2.hxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/bastype2.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -42,7 +42,7 @@
 #include <sbxitem.hxx>
 #include "basobj.hxx"
 
-enum BasicEntryType { OBJ_TYPE_UNKNOWN, OBJ_TYPE_DOCUMENT, OBJ_TYPE_LIBRARY, OBJ_TYPE_MODULE, OBJ_TYPE_DIALOG, OBJ_TYPE_METHOD };
+enum BasicEntryType { OBJ_TYPE_UNKNOWN, OBJ_TYPE_DOCUMENT, OBJ_TYPE_LIBRARY, OBJ_TYPE_MODULE, OBJ_TYPE_DIALOG, OBJ_TYPE_METHOD, OBJ_TYPE_DOCUMENT_OBJECTS, OBJ_TYPE_USERFORMS, OBJ_TYPE_NORMAL_MODULES, OBJ_TYPE_CLASS_MODULES };
 
 #define BROWSEMODE_MODULES		0x01
 #define BROWSEMODE_SUBS			0x02
@@ -101,14 +101,15 @@ class BasicEntryDescriptor
     ScriptDocument          m_aDocument;
     LibraryLocation         m_eLocation;
     String                  m_aLibName;
+    String                  m_aLibSubName;  // for vba entry:  Document Objects, Class Modules, Forms and Normal Modules
     String                  m_aName;
     String                  m_aMethodName;
     BasicEntryType          m_eType;
 
 public:
                             BasicEntryDescriptor();
-                            BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, BasicEntryType eType );
-                            BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, const String& rMethodName, BasicEntryType eType );
+	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, BasicEntryType eType );
+	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, const String& rMethodName, BasicEntryType eType );
     virtual                 ~BasicEntryDescriptor();
 
                             BasicEntryDescriptor( const BasicEntryDescriptor& rDesc );
@@ -125,6 +126,9 @@ public:
     const String&           GetLibName() const { return m_aLibName; }
     void                    SetLibName( const String& aLibName ) { m_aLibName = aLibName; }
 
+    const String&           GetLibSubName() const { return m_aLibSubName; }
+    void                    SetLibSubName( const String& aLibSubName ) { m_aLibSubName = aLibSubName; }
+
     const String&           GetName() const { return m_aName; }
     void                    SetName( const String& aName ) { m_aName = aName; }
 
@@ -164,6 +168,9 @@ protected:
 
     void                    ImpCreateLibEntries( SvLBoxEntry* pShellRootEntry, const ScriptDocument& rDocument, LibraryLocation eLocation );
     void 					ImpCreateLibSubEntries( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+	void 					ImpCreateLibSubEntriesInVBAMode( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+	void 					ImpCreateLibSubSubEntriesInVBAMode( SvLBoxEntry* pLibSubRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+    SvLBoxEntry*            ImpFindEntry( SvLBoxEntry* pParent, const String& rText );
 
     // DocumentEventListener
     virtual void onDocumentCreated( const ScriptDocument& _rDocument );
--- basctl/source/basicide/bastype3.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/bastype3.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -134,6 +134,14 @@ void __EXPORT BasicTreeListBox::Requesti
             }
         }
     }
+    else if ( eType == OBJ_TYPE_DOCUMENT_OBJECTS 
+            || eType == OBJ_TYPE_USERFORMS
+            || eType == OBJ_TYPE_NORMAL_MODULES
+            || eType == OBJ_TYPE_CLASS_MODULES )
+    {
+        String aLibName( aDesc.GetLibName() );
+        ImpCreateLibSubSubEntriesInVBAMode( pEntry, aDocument, aLibName );
+    }
     else {
         DBG_ERROR( "BasicTreeListBox::RequestingChilds: Unknown Type!" );
     }
@@ -204,6 +212,7 @@ SbxVariable* BasicTreeListBox::FindVaria
     }
 
     SbxVariable* pVar = 0;
+    bool bDocumentObjects = false;
     if ( aEntries.Count() )
     {
         for ( USHORT n = 0; n < aEntries.Count(); n++ )
@@ -226,6 +235,12 @@ SbxVariable* BasicTreeListBox::FindVaria
                 case OBJ_TYPE_MODULE:
                 {
                     DBG_ASSERT( pVar && pVar->IsA( TYPE(StarBASIC) ), "FindVariable: Ungueltiges Basic" );
+                    // extract the module name from the string like "Sheet1 (Example1)"
+                    if( bDocumentObjects )
+                    {
+                        sal_uInt16 nIndex = 0;
+                        aName = aName.GetToken( 0, ' ', nIndex );
+                    }
                     pVar = ((StarBASIC*)pVar)->FindModule( aName );
                 }
                 break;
@@ -240,6 +255,15 @@ SbxVariable* BasicTreeListBox::FindVaria
                     // sbx dialogs removed
                 }
                 break;
+                case OBJ_TYPE_DOCUMENT_OBJECTS:
+                    bDocumentObjects = true;
+                case OBJ_TYPE_USERFORMS:
+                case OBJ_TYPE_NORMAL_MODULES:
+                case OBJ_TYPE_CLASS_MODULES:
+                {
+                    // skip, to find the child entry.
+                    continue;
+                }
                 default:
                 {
                     DBG_ERROR( "FindVariable: Unbekannter Typ!" );
@@ -260,12 +284,13 @@ BasicEntryDescriptor BasicTreeListBox::G
     ScriptDocument aDocument( ScriptDocument::getApplicationScriptDocument() );
     LibraryLocation eLocation = LIBRARY_LOCATION_UNKNOWN;
     String aLibName;
+	String aLibSubName;
     String aName;
     String aMethodName;
     BasicEntryType eType = OBJ_TYPE_UNKNOWN;
 
     if ( !pEntry )
-        return BasicEntryDescriptor( aDocument, eLocation, aLibName, aName, aMethodName, eType );
+        return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aName, aMethodName, eType );
 
     EntryArray aEntries;
 
@@ -332,6 +357,15 @@ BasicEntryDescriptor BasicTreeListBox::G
                     eType = pBE->GetType();
                 }
                 break;
+                case OBJ_TYPE_DOCUMENT_OBJECTS:
+                case OBJ_TYPE_USERFORMS:
+                case OBJ_TYPE_NORMAL_MODULES:
+                case OBJ_TYPE_CLASS_MODULES:
+				{
+					aLibSubName = GetEntryText( pLE );
+					eType = pBE->GetType();
+				}
+				break;
                 default:
                 {
                     DBG_ERROR( "GetEntryDescriptor: Unbekannter Typ!" );
@@ -345,7 +379,7 @@ BasicEntryDescriptor BasicTreeListBox::G
         }
     }
 
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aName, aMethodName, eType );
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aName, aMethodName, eType );
 }
 
 USHORT BasicTreeListBox::ConvertType( BasicEntryType eType )
@@ -427,6 +461,14 @@ bool BasicTreeListBox::IsValidEntry( SvL
             bIsValid = BasicIDE::HasMethod( aDocument, aLibName, aName, aMethodName );
         }
         break;
+        case OBJ_TYPE_DOCUMENT_OBJECTS:
+        case OBJ_TYPE_USERFORMS:
+        case OBJ_TYPE_NORMAL_MODULES:
+        case OBJ_TYPE_CLASS_MODULES:
+        {
+            bIsValid = true;
+        }
+        break;
         default: ;
     }
 
--- basctl/source/basicide/bastypes.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/basicide/bastypes.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -60,6 +60,7 @@
 #include <com/sun/star/script/XLibraryContainer2.hpp>
 #endif
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
@@ -594,8 +595,30 @@ void __EXPORT BasicIDETabBar::Command( c
                 aPopup.EnableItem( SID_BASICIDE_RENAMECURRENT, FALSE );
                 aPopup.RemoveDisabledEntries();
             }
+			
+			// disable to delete or remove object modules in IDE
+			BasicManager* pBasMgr = aDocument.getBasicManager();
+			if ( pBasMgr )
+			{
+				StarBASIC* pBasic = pBasMgr->GetLib( aOULibName );
+				if( pBasic )
+				{
+					IDEWindowTable& aIDEWindowTable = pIDEShell->GetIDEWindowTable();
+					IDEBaseWindow* pWin = aIDEWindowTable.Get( GetCurPageId() );
+					if( pWin && pWin->ISA( ModulWindow ) )
+					{
+						SbModule* pActiveModule = (SbModule*)pBasic->FindModule( pWin->GetName() );
+						if( pActiveModule && ( pActiveModule->GetModuleType() == script::ModuleType::Document ) )
+						{
+							aPopup.EnableItem( SID_BASICIDE_DELETECURRENT, FALSE );
+							aPopup.EnableItem( SID_BASICIDE_RENAMECURRENT, FALSE );
+						}
+					}
+				}
+			}
         }
 
+
         SfxViewFrame* pViewFrame = pIDEShell ? pIDEShell->GetViewFrame() : NULL;
         SfxDispatcher* pDispatcher = pViewFrame ? pViewFrame->GetDispatcher() : NULL;
         if ( pDispatcher )
--- basctl/source/basicide/macrodlg.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/macrodlg.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -385,7 +385,15 @@ SbMethod* MacroChooser::CreateMacro()
         SbModule* pModule = 0;
         String aModName( aDesc.GetName() );
         if ( aModName.Len() )
+        {
+            // extract the module name from the string like "Sheet1 (Example1)"
+            if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+            {
+                sal_uInt16 nIndex = 0;
+                aModName = aModName.GetToken( 0, ' ', nIndex );
+            }
             pModule = pBasic->FindModule( aModName );
+        }    
         else if ( pBasic->GetModules()->Count() )
             pModule = (SbModule*)pBasic->GetModules()->Get( 0 );
 
@@ -713,6 +721,12 @@ IMPL_LINK( MacroChooser, ButtonHdl, Butt
         BasicManager* pBasMgr = aDocument.getBasicManager();
         String aLib( aDesc.GetLibName() );
         String aMod( aDesc.GetName() );
+        // extract the module name from the string like "Sheet1 (Example1)"
+        if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+        {
+            sal_uInt16 nIndex = 0;
+            aMod = aMod.GetToken( 0, ' ', nIndex );
+        }
         String aSub( aDesc.GetMethodName() );
         SfxMacroInfoItem aInfoItem( SID_BASICIDE_ARG_MACROINFO, pBasMgr, aLib, aMod, aSub, String() );
         if ( pButton == &aEditButton )
--- basctl/source/basicide/moduldlg.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/moduldlg.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -87,7 +87,7 @@ BOOL __EXPORT ExtBasicTreeListBox::Editi
     if ( pEntry )
     {
         USHORT nDepth = GetModel()->GetDepth( pEntry );
-        if ( nDepth == 2 )
+        if ( nDepth >= 2 )
         {
             BasicEntryDescriptor aDesc( GetEntryDescriptor( pEntry ) );
             ScriptDocument aDocument( aDesc.GetDocument() );
@@ -165,7 +165,7 @@ DragDropMode __EXPORT ExtBasicTreeListBo
     if ( pEntry )
     {
         USHORT nDepth = GetModel()->GetDepth( pEntry );
-        if ( nDepth == 2 )
+        if ( nDepth >= 2 )
         {
             nMode_ = SV_DRAGDROP_CTRL_COPY;
             BasicEntryDescriptor aDesc( GetEntryDescriptor( pEntry ) );
@@ -213,7 +213,7 @@ BOOL __EXPORT ExtBasicTreeListBox::Notif
 
     // don't drop on a library, which is not loaded, readonly or password protected
     // or which already has a module/dialog with this name
-    if ( bValid && ( nDepth == 1 || nDepth == 2 ) )
+    if ( bValid && ( nDepth > 0 ) )
     {
         // get source module/dialog name
         BasicEntryDescriptor aSourceDesc( GetEntryDescriptor( pSelected ) );
@@ -315,7 +315,7 @@ void BasicIDEShell::CopyDialogResources(
     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-    ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+	::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rSourceDoc.getDocument() );
 
     if( xDialogModel.is() )
     {
@@ -332,7 +332,7 @@ void BasicIDEShell::CopyDialogResources(
         {
             LocalizationMgr::setResourceIDsForDialog( xDialogModel, xDestMgr );
         }
-        io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDestDoc.getDocument() );
     }
 }
 
@@ -351,7 +351,7 @@ BOOL __EXPORT ExtBasicTreeListBox::Notif
         rpNewParent = pTarget;
         rNewChildPos = 0;
     }
-    else if ( nDepth == 2 )
+	else if ( nDepth >= 2 )
     {
         // Target = Modul/Dialog => Modul/Dialog unter das uebergeordnete Basic haengen...
         rpNewParent = GetParent( pTarget );
@@ -626,20 +626,31 @@ void ObjectPage::CheckButtons()
 {
     // enable/disable edit button
     SvLBoxEntry* pCurEntry = aBasicBox.GetCurEntry();
+    BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
+    ScriptDocument aDocument( aDesc.GetDocument() );
+    ::rtl::OUString aOULibName( aDesc.GetLibName() );
+    String aLibSubName( aDesc.GetLibSubName() );
+    BasicManager* pBasMgr = aDocument.getBasicManager();
+    StarBASIC* pBasic = pBasMgr ? pBasMgr->GetLib( aOULibName ) : 0;
+    sal_Bool bVBAEnabled = pBasic ? pBasic->isVBAEnabled(): sal_False;
+    USHORT nMode = aBasicBox.GetMode();
+
     USHORT nDepth = pCurEntry ? aBasicBox.GetModel()->GetDepth( pCurEntry ) : 0;
-    if ( nDepth == 2 )
-        aEditButton.Enable();
+	if ( nDepth >= 2 )
+    {
+        if( bVBAEnabled && ( nMode & BROWSEMODE_MODULES ) && ( nDepth == 2 ) )
+            aEditButton.Disable();
+        else
+		    aEditButton.Enable();
+    }    
     else
         aEditButton.Disable();
 
     // enable/disable new module/dialog buttons
-    BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
     LibraryLocation eLocation( aDesc.GetLocation() );
     BOOL bReadOnly = FALSE;
-    if ( nDepth == 1 || nDepth == 2 )
+    if ( nDepth > 0 )
     {
-        ScriptDocument aDocument( aDesc.GetDocument() );
-        ::rtl::OUString aOULibName( aDesc.GetLibName() );
         Reference< script::XLibraryContainer2 > xModLibContainer( aDocument.getLibraryContainer( E_SCRIPTS ), UNO_QUERY );
         Reference< script::XLibraryContainer2 > xDlgLibContainer( aDocument.getLibraryContainer( E_DIALOGS ), UNO_QUERY );
         if ( ( xModLibContainer.is() && xModLibContainer->hasByName( aOULibName ) && xModLibContainer->isLibraryReadOnly( aOULibName ) ) ||
@@ -660,8 +671,13 @@ void ObjectPage::CheckButtons()
     }
 
     // enable/disable delete button
-    if ( nDepth == 2 && !bReadOnly && eLocation != LIBRARY_LOCATION_SHARE )
-        aDelButton.Enable();
+    if ( nDepth >= 2 && !bReadOnly && eLocation != LIBRARY_LOCATION_SHARE )
+    {
+        if( bVBAEnabled && ( nMode & BROWSEMODE_MODULES ) && ( ( nDepth == 2 ) || aLibSubName.Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) ) )
+            aDelButton.Disable();
+        else
+            aDelButton.Enable();
+    }
     else
         aDelButton.Disable();
 }
@@ -688,13 +704,20 @@ IMPL_LINK( ObjectPage, ButtonHdl, Button
         SfxDispatcher* pDispatcher = pViewFrame ? pViewFrame->GetDispatcher() : NULL;
         SvLBoxEntry* pCurEntry = aBasicBox.GetCurEntry();
         DBG_ASSERT( pCurEntry, "Entry?!" );
-        if ( aBasicBox.GetModel()->GetDepth( pCurEntry ) == 2 )
+		if ( aBasicBox.GetModel()->GetDepth( pCurEntry ) >= 2 )
         {
             BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
             if ( pDispatcher )
             {
+                String aModName( aDesc.GetName() );
+                // extract the module name from the string like "Sheet1 (Example1)"
+                if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+                {
+                    sal_uInt16 nIndex = 0;
+                    aModName = aModName.GetToken( 0, ' ', nIndex );
+                }
                 SbxItem aSbxItem( SID_BASICIDE_ARG_SBX, aDesc.GetDocument(), aDesc.GetLibName(), 
-                                  aDesc.GetName(), aBasicBox.ConvertType( aDesc.GetType() ) );
+                                  aModName, aBasicBox.ConvertType( aDesc.GetType() ) );
                 pDispatcher->Execute( SID_BASICIDE_SHOWSBX, SFX_CALLMODE_SYNCHRON, &aSbxItem, 0L );
             }
         }
@@ -976,14 +999,14 @@ SbModule* createModImpl( Window* pWin, c
         try
         {
             ::rtl::OUString sModuleCode;
+            // the module has existed
+            if( rDocument.hasModule( aLibName, aModName ) )
+                return NULL;
             rDocument.createModule( aLibName, aModName, bMain, sModuleCode );
             BasicManager* pBasMgr = rDocument.getBasicManager();
-            if ( pBasMgr )
-            {
-                StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
-                if ( pBasic )
-                    pModule = pBasic->FindModule( aModName );
-            }
+            StarBASIC* pBasic = pBasMgr? pBasMgr->GetLib( aLibName ) : 0;
+            if ( pBasic )
+                pModule = pBasic->FindModule( aModName );
             SbxItem aSbxItem( SID_BASICIDE_ARG_SBX, rDocument, aLibName, aModName, BASICIDE_TYPE_MODULE );					
             BasicIDEShell* pIDEShell = IDE_DLL()->GetShell();
             SfxViewFrame* pViewFrame = pIDEShell ? pIDEShell->GetViewFrame() : NULL;
@@ -1005,14 +1028,27 @@ SbModule* createModImpl( Window* pWin, c
                 {
                     if ( !rBasicBox.IsExpanded( pLibEntry ) )
                         rBasicBox.Expand( pLibEntry );
-                    SvLBoxEntry* pEntry = rBasicBox.FindEntry( pLibEntry, aModName, OBJ_TYPE_MODULE );
+                    SvLBoxEntry* pSubRootEntry = pLibEntry;
+                    if( pBasic && pBasic->isVBAEnabled() )
+                    {
+                        // add the new module in the "Modules" entry
+                        SvLBoxEntry* pLibSubEntry = rBasicBox.FindEntry( pLibEntry, String( IDEResId( RID_STR_NORMAL_MODULES ) ) , OBJ_TYPE_NORMAL_MODULES );
+                        if( pLibSubEntry )
+                        {
+                            if( !rBasicBox.IsExpanded( pLibSubEntry ) )
+                                rBasicBox.Expand( pLibSubEntry );
+                            pSubRootEntry = pLibSubEntry;    
+                        }
+                    }
+                    
+                    SvLBoxEntry* pEntry = rBasicBox.FindEntry( pSubRootEntry, aModName, OBJ_TYPE_MODULE );
                     if ( !pEntry )
                     {
                         pEntry = rBasicBox.AddEntry(
                             aModName,
                             Image( IDEResId( RID_IMG_MODULE ) ),
                             Image( IDEResId( RID_IMG_MODULE_HC ) ),
-                            pLibEntry, false,
+                            pSubRootEntry, false,
                             std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
                         DBG_ASSERT( pEntry, "InsertEntry fehlgeschlagen!" );
                     }
--- basctl/source/basicide/scriptdocument.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/basicide/scriptdocument.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -56,6 +56,7 @@
 #include <com/sun/star/frame/XModel2.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <sfx2/objsh.hxx>
@@ -142,6 +143,7 @@ namespace basctl
     using ::com::sun::star::uno::RuntimeException;
     using ::com::sun::star::document::XEventBroadcaster;
     using ::com::sun::star::document::XEmbeddedScripts;
+    using ::com::sun::star::script::ModuleInfo;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
     namespace FrameSearchFlag = ::com::sun::star::frame::FrameSearchFlag;
@@ -661,7 +663,7 @@ namespace basctl
                 if ( !_rxExistingDialogModel.is() )
                 {
                     Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
-                    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext() );
+    			    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext(), getDocument() );
                 }
 
                 // set new name as property
@@ -669,11 +671,20 @@ namespace basctl
                 xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rNewName ) );
 
                 // export dialog model
-                xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+			    xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), getDocument() );
                 aElement <<= xISP;
             }
 
             // insert element by new name in container
+            if ( _eType == E_SCRIPTS )
+            {
+                ModuleInfo sModuleInfo;
+                if ( aElement >>= sModuleInfo )
+                {
+                    sModuleInfo.ModuleName = _rNewName;
+                    aElement <<= sModuleInfo;
+                }
+            }
             xLib->insertByName( _rNewName, aElement );
             return true;
         }
@@ -738,8 +749,16 @@ namespace basctl
             Reference< XNameContainer > xLib( getOrCreateLibrary( E_SCRIPTS, _rLibName ), UNO_QUERY_THROW );
             if ( !xLib->hasByName( _rModName ) )
                 return false;
-
-            xLib->replaceByName( _rModName, makeAny( _rModuleCode ) );
+            ModuleInfo mInfo;
+            Any aMod;
+            if ( xLib->getByName( _rModName ) >>= mInfo )
+            {
+                mInfo.ModuleSource = _rModuleCode;
+                aMod <<= mInfo;
+            }
+            else
+                aMod <<= _rModuleCode;
+            xLib->replaceByName( _rModName, aMod );
             return true;
         }
         catch( const Exception& )
@@ -772,7 +791,7 @@ namespace basctl
             xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rDialogName ) );
 
             // export dialog model
-            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), getDocument() );
 
             // insert dialog into library
             xLib->insertByName( _rDialogName, makeAny( _out_rDialogProvider ) );
@@ -1392,7 +1411,15 @@ namespace basctl
         Any aCode;
         if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
             return false;
-        OSL_VERIFY( aCode >>= _out_rModuleSource );
+        ModuleInfo sModuleInfo;
+        if ( aCode >>= sModuleInfo )
+        {
+            _out_rModuleSource = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            OSL_VERIFY( aCode >>= _out_rModuleSource );
+        }
         return true;
     }
 
--- basctl/source/dlged/dlged.cxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/dlged/dlged.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -208,7 +208,7 @@ BOOL DlgEditor::RemarkDialog()
 
 //----------------------------------------------------------------------------
 
-DlgEditor::DlgEditor()
+DlgEditor::DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel )
     :pHScroll(NULL)
     ,pVScroll(NULL)
     ,pDlgEdModel(NULL)
@@ -230,6 +230,7 @@ DlgEditor::DlgEditor()
     ,bCreateOK(TRUE)
     ,bDialogModelChanged(FALSE)
     ,mnPaintGuard(0)
+	,m_xDocument( xModel )
 {
     pDlgEdModel = new DlgEdModel();
     pDlgEdModel->GetItemPool().FreezeIdRanges();
@@ -838,7 +839,7 @@ void DlgEditor::Copy()
     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
     Reference< XInputStream > xStream( xISP->createInputStream() );
     Sequence< sal_Int8 > DialogModelBytes;
     implCopyStreamToByteSequence( xStream, DialogModelBytes );
@@ -871,7 +872,7 @@ void DlgEditor::Copy()
             uno::Reference< resource::XStringResourceManager >
                 xStringResourceManager( xStringResourcePersistence, uno::UNO_QUERY );
             LocalizationMgr::resetResourceForDialog( xClipDialogModel, xStringResourceManager );
-            Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+			Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
             Reference< XInputStream > xStream2( xISP2->createInputStream() );
             Sequence< sal_Int8 > NoResourceDialogModelBytes;
             implCopyStreamToByteSequence( xStream2, NoResourceDialogModelBytes );
@@ -1017,7 +1018,7 @@ void DlgEditor::Paste()
                     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                    ::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext );
+					::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext, m_xDocument );
                 }
 
                 // get control models from clipboard dialog model
--- basctl/source/dlged/dlgedobj.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/dlged/dlgedobj.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -77,6 +77,22 @@ TYPEINIT1(DlgEdObj, SdrUnoObj);
 DBG_NAME(DlgEdObj);
 
 //----------------------------------------------------------------------------
+MapMode lcl_getMapModeForForm( DlgEdForm* pForm )
+{
+	MapMode aMode( MAP_APPFONT ); //Default
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps( pForm ? pForm->GetUnoControlModel() : NULL, uno::UNO_QUERY_THROW );
+		sal_Bool bVBAForm = sal_False;
+		xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBAForm;	
+		if ( bVBAForm )
+			aMode = MapMode( MAP_100TH_MM );
+	}
+	catch ( Exception& )
+	{
+	}
+	return aMode;
+}
 
 DlgEdObj::DlgEdObj()
           :SdrUnoObj(String(), sal_False)
@@ -197,8 +213,9 @@ bool DlgEdObj::TransformSdrToControlCoor
     }
     
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -245,10 +262,10 @@ bool DlgEdObj::TransformSdrToFormCoordin
         aSize.Width() -= aDeviceInfo.LeftInset + aDeviceInfo.RightInset;
         aSize.Height() -= aDeviceInfo.TopInset + aDeviceInfo.BottomInset;
     }
-
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -290,9 +307,10 @@ bool DlgEdObj::TransformControlToSdrCoor
     DBG_ASSERT( pDevice, "DlgEdObj::TransformControlToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
-    aFormPos = pDevice->LogicToPixel( aFormPos, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+    aFormPos = pDevice->LogicToPixel( aFormPos, aConvMode );
 
     // add form position
     aPos.Width() += aFormPos.Width();
@@ -336,14 +354,16 @@ bool DlgEdObj::TransformFormToSdrCoordin
     DBG_ASSERT( pDevice, "DlgEdObj::TransformFormToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
 
     // take window borders into account
     DlgEdForm* pForm = NULL;
     if ( !lcl_getDlgEdForm( this, pForm ) )
         return false;
 
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+
     // take window borders into account
     Reference< beans::XPropertySet > xPSetForm( pForm->GetUnoControlModel(), UNO_QUERY );
     DBG_ASSERT( xPSetForm.is(), "DlgEdObj::TransformFormToSdrCoordinates: no form property set!" );
--- basctl/source/inc/basidesh.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ basctl/source/inc/basidesh.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -49,6 +49,7 @@
 #include <com/sun/star/io/XInputStreamProvider.hpp>
 #endif
 
+#include <com/sun/star/container/XContainerListener.hpp>
 
 //----------------------------------------------------------------------------
 
@@ -108,6 +109,8 @@ friend bool BasicIDE::RemoveDialog( cons
     BOOL                m_bAppBasicModified;
     ::basctl::DocumentEventNotifier
                         m_aNotifier;
+friend class ContainerListenerImpl;
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XContainerListener > m_xLibListener;
 
 #if _SOLAR__PRIVATE
     void				Init();
--- basctl/source/inc/dlged.hxx.old	2009-10-07 15:07:22.000000000 +0200
+++ basctl/source/inc/dlged.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -35,6 +35,7 @@
 #include <com/sun/star/awt/XControlContainer.hpp>
 #include <com/sun/star/datatransfer/DataFlavor.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/frame/XModel.hpp>
 #include <tools/link.hxx>
 #include <tools/gen.hxx> 
 #include <vcl/timer.hxx>
@@ -129,9 +130,11 @@ protected:
     BOOL				bDialogModelChanged;
     Timer               aMarkTimer;
     long				mnPaintGuard;
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > m_xDocument;
 
+	DlgEditor(); // not implemented
 public:
-    DlgEditor();
+	DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel );
     ~DlgEditor();
 
     void			SetWindow( Window* pWindow );
--- basic/inc/basic/basmgr.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/inc/basic/basmgr.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -239,7 +239,7 @@ public:
             takes the names of modules whose size exceeds the legacy limit
     */
     bool            LegacyPsswdBinaryLimitExceeded( ::com::sun::star::uno::Sequence< rtl::OUString >& _out_rModuleNames );
-
+    bool HasExeCode( const String& );
 private:
     BOOL		    IsReference( USHORT nLib );
 
--- basic/inc/basic/sberrors.hxx.old	2009-10-08 16:17:52.000000000 +0200
+++ basic/inc/basic/sberrors.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -290,6 +290,8 @@ typedef ULONG SbError;
 #define	ERRCODE_BASIC_LOOP_NOT_INIT			((LAST_SBX_ERROR_ID+109UL) | ERRCODE_AREA_SBX | \
                                             ERRCODE_CLASS_COMPILER)				// For loop not initialized
 
+#define	ERRCODE_BASIC_COMPAT				((LAST_SBX_ERROR_ID+103UL)| ERRCODE_AREA_SBX | ERRCODE_CLASS_RUNTIME)
+
 // Map old codes to new codes
 #define	SbERR_SYNTAX						ERRCODE_BASIC_SYNTAX
 #define	SbERR_NO_GOSUB						ERRCODE_BASIC_NO_GOSUB
@@ -413,6 +415,7 @@ typedef ULONG SbError;
 #define	SbERR_PROG_TOO_LARGE                ERRCODE_BASIC_PROG_TOO_LARGE
 #define	SbERR_NO_STRINGS_ARRAYS             ERRCODE_BASIC_NO_STRINGS_ARRAYS
 #define	SbERR_BASIC_EXCEPTION               ERRCODE_BASIC_EXCEPTION
+#define	SbERR_BASIC_COMPAT                  ERRCODE_BASIC_COMPAT
 #define	SbERR_BASIC_ARRAY_FIX				ERRCODE_BASIC_ARRAY_FIX
 #define	SbERR_BASIC_STRING_OVERFLOW			ERRCODE_BASIC_STRING_OVERFLOW
 #define	SbERR_BASIC_EXPR_TOO_COMPLEX		ERRCODE_BASIC_EXPR_TOO_COMPLEX
--- basic/inc/basic/sbmeth.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/inc/basic/sbmeth.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -49,6 +49,7 @@ class SbMethod : public SbxMethod
     friend class SbIfaceMapperMethod;
 
     SbMethodImpl* mpSbMethodImpl;			// Impl data
+	SbxVariable* mCaller;                   // caller
     SbModule* pMod;
     USHORT    nDebugFlags;
     USHORT	  nLine1, nLine2;
@@ -75,7 +76,7 @@ public:
     void 	  GetLineRange( USHORT&, USHORT& );
 
     // Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
-    virtual ErrCode Call( SbxValue* pRet = NULL );
+	virtual ErrCode Call( SbxValue* pRet = NULL,  SbxVariable* pCaller = NULL );
     virtual void Broadcast( ULONG nHintId );
 };
 
--- basic/inc/basic/sbmod.hxx.old	2009-10-08 16:17:52.000000000 +0200
+++ basic/inc/basic/sbmod.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -37,7 +37,8 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
-
+#include <com/sun/star/script/ModuleType.hpp>
+#include <vector>
 class SbMethod;
 class SbProperty;
 class SbiRuntime;
@@ -59,6 +60,9 @@ class SbModule : public SbxObject
     friend class	SbClassModuleObject;
 
     SbModuleImpl*	mpSbModuleImpl;		// Impl data
+	std::vector< String > mModuleVariableNames;
+	SbModule();
+	SbModule(const SbModule&);
 
 protected:
     ::rtl::OUString     aOUSource;
@@ -66,6 +70,10 @@ protected:
     SbiImage*           pImage;        // the Image
     SbiBreakpoints*     pBreaks;       // Breakpoints
     SbClassData*        pClassData;
+	bool mbVBACompat;
+	INT32 mnType; 
+	SbxObjectRef pDocObject; // an impl object ( used by Document Modules )
+	bool 	bIsProxyModule;
 
     void			StartDefinitions();
     SbMethod*		GetMethod( const String&, SbxDataType );
@@ -90,7 +98,7 @@ protected:
 public:
     SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASICMOD,2);
     TYPEINFO();
-                    SbModule( const String& );
+					SbModule( const String&, bool bCompat = false );
     virtual void	SetParent( SbxObject* );
     virtual void 	Clear();
 
@@ -126,6 +134,14 @@ public:
     BOOL LoadBinaryData( SvStream& );
     BOOL ExceedsLegacyModuleSize();
     void fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg = NULL ) const;
+        bool HasExeCode();
+        bool IsVBACompat();
+        void SetVBACompat( bool bCompat );
+        INT32 GetModuleType() { return mnType; }
+        void SetModuleType( INT32 nType ) { mnType = nType; }
+	bool GetIsProxyModule() { return bIsProxyModule; }
+        void AddVarName( const String& aName );
+        void RemoveVars();
 };
 
 #ifndef __SB_SBMODULEREF_HXX
--- basic/inc/basic/sbobjmod.hxx.old	2010-03-03 16:59:34.000000000 +0100
+++ basic/inc/basic/sbobjmod.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,96 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+
+namespace css = ::com::sun::star;
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+    SbObjModule( const SbObjModule& );
+    SbObjModule();
+public:
+    TYPEINFO();
+    SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    SbxVariable* GetObject();
+    void SetUnoObject( const com::sun::star::uno::Any& aObj )throw ( com::sun::star::uno::RuntimeException ) ;
+};
+
+class SbUserFormModule : public SbObjModule
+{
+    css::uno::Reference<css::lang::XEventListener> m_DialogListener;
+    css::uno::Reference<css::awt::XDialog> m_xDialog;
+    css::uno::Reference<css::frame::XModel> m_xModel;
+    String sFormName;
+    bool mbInit;
+    SbUserFormModule( const SbUserFormModule& );
+    SbUserFormModule();
+
+protected:
+    virtual void InitObject();
+public:
+    TYPEINFO();
+    SbUserFormModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVBACompat );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    void ResetApiObj();
+    void Unload();
+    void load();
+    void triggerMethod( const String& );
+    void triggerMethod( const String&, css::uno::Sequence< css::uno::Any >&  );
+    void triggerActivateEvent();
+    void triggerDeActivateEvent();
+    void triggerInitializeEvent();
+    void triggerTerminateEvent();
+};
+
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
--- basic/inc/basic/sbstar.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/inc/basic/sbstar.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -40,6 +40,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // completed module
 class SbiInstance;                  // runtime instance
@@ -72,6 +73,7 @@ class StarBASIC : public SbxObject
     BOOL			bNoRtl;                 // if TRUE: do not search RTL
     BOOL			bBreak;                 // if TRUE: Break, otherwise Step
     BOOL			bDocBasic;
+	BOOL			bVBAEnabled;
     BasicLibInfo*	pLibInfo;			// Info block for basic manager
     SbLanguageMode	eLanguageMode;		// LanguageMode of the basic object
 	BOOL			bQuit;
@@ -119,7 +121,8 @@ public:
 
     // Compiler-Interface
     SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const com::sun::star::script::ModuleInfo& mInfo );
     BOOL			Compile( SbModule* );
     BOOL 			Disassemble( SbModule*, String& rText );
     static void 	Stop();
@@ -192,6 +195,8 @@ public:
                     ( const String& rName, USHORT& rStatus );
     static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
     static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
     // #60175 TRUE: SFX-Resource is not displayed on basic errors
     static void StaticSuppressSfxResource( BOOL bSuppress );
--- basic/inc/basic/sbuno.hxx.old	2009-10-08 16:17:52.000000000 +0200
+++ basic/inc/basic/sbuno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -41,6 +41,7 @@ SbxObjectRef GetSbUnoObject( const Strin
 
 // Force creation of all properties for debugging
 void createAllObjectProperties( SbxObject* pObj );
+void SetSbUnoObjectDfltPropName( SbxObject* pObj );
 
 ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 
--- basic/prj/build.lst.old	2009-10-08 16:17:52.000000000 +0200
+++ basic/prj/build.lst	2010-03-03 16:59:34.000000000 +0100
@@ -1,4 +1,4 @@
-sb	basic	:    l10n offuh svtools xmlscript framework NULL
+sb	basic	:    l10n offuh svtools xmlscript framework oovbaapi NULL
 sb	basic									usr1	-	all	sb_mkout NULL
 sb	basic\inc								nmake	-	all	sb_inc NULL
 sb	basic\source\app						nmake	-	all	sb_app sb_class sb_inc NULL
--- basic/prj/d.lst.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/prj/d.lst	2010-03-03 16:59:34.000000000 +0100
@@ -7,6 +7,8 @@ mkdir: %COMMON_DEST%\res%_EXT%
 ..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
 ..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
 ..\%__SRC%\slb\sb.lib %_DEST%\lib%_EXT%\xsb.lib
+..\%__SRC%\lib\vbahelp*.* %_DEST%\lib%_EXT%\vba*.*
+
 ..\%__SRC%\srs\classes.srs %_DEST%\res%_EXT%\basic.srs
 ..\%COMMON_OUTDIR%\srs\classes_srs.hid %COMMON_DEST%\res%_EXT%\basic_srs.hid
 ..\%__SRC%\bin\sb?????.dll %_DEST%\bin%_EXT%\sb?????.dll
@@ -56,4 +58,8 @@ mkdir: %_DEST%\inc%_EXT%\basic
 ..\inc\basic\sbxmstrm.hxx %_DEST%\inc%_EXT%\basic\sbxmstrm.hxx
 
 ..\inc\basic\basicmanagerrepository.hxx %_DEST%\inc%_EXT%\basic\basicmanagerrepository.hxx
+..\inc\basic\vbacollectionimpl.hxx %_DEST%\inc%_EXT%\basic\vbacollectionimpl.hxx
+..\inc\basic\vbahelper.hxx %_DEST%\inc%_EXT%\basic\vbahelper.hxx
+..\inc\basic\helperdecl.hxx %_DEST%\inc%_EXT%\basic\helperdecl.hxx
+..\inc\basic\vbahelperinterface.hxx %_DEST%\inc%_EXT%\basic\vbahelperinterface.hxx
 ..\inc\modsizeexceeded.hxx %_DEST%\inc%_EXT%\basic\modsizeexceeded.hxx
--- basic/source/basmgr/basmgr.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/source/basmgr/basmgr.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -44,6 +44,7 @@
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
 #include <basic/sbmod.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include <basic/sbuno.hxx>
 #include <basic/basmgr.hxx>
@@ -68,6 +69,8 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -244,9 +247,18 @@ void BasMgrContainerListenerImpl::addLib
         {
             ::rtl::OUString aModuleName = pNames[ j ];
             Any aElement = xLibNameAccess->getByName( aModuleName );
-            ::rtl::OUString aMod;
-            aElement >>= aMod;
-            pLib->MakeModule32( aModuleName, aMod );
+            ModuleInfo mInfo;
+            if ( aElement >>= mInfo )
+            {
+                OSL_TRACE("#addLibraryModulesImpl - aMod");
+                pLib->MakeModule32( mInfo );
+            }
+            else
+            {
+			    ::rtl::OUString aMod;
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
         }
     }
 
@@ -283,8 +295,6 @@ void SAL_CALL BasMgrContainerListenerImp
     }
     else
     {
-        ::rtl::OUString aMod;
-        Event.Element >>= aMod;
 
         StarBASIC* pLib = mpMgr->GetLib( maLibName );
         DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -293,7 +303,17 @@ void SAL_CALL BasMgrContainerListenerImp
             SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-                pLib->MakeModule32( aName, aMod );
+                ModuleInfo mInfo;
+                if( Event.Element >>= mInfo )
+                {
+                    pLib->MakeModule32( mInfo );
+                }
+                else
+                {
+        		    ::rtl::OUString aMod;
+        		    Event.Element >>= aMod;
+			        pLib->MakeModule32( aName, aMod );
+                }
                 pLib->SetModified( FALSE );
             }
         }
@@ -317,15 +337,35 @@ void SAL_CALL BasMgrContainerListenerImp
     DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
 
     StarBASIC* pLib = mpMgr->GetLib( maLibName );
+    
     if( pLib )
     {
-        SbModule* pMod = pLib->FindModule( aName );
+	    SbModule* pMod = pLib->FindModule( aName );
         ::rtl::OUString aMod;
-        Event.Element >>= aMod;
+        ModuleInfo mInfo;
+        if( Event.Element >>= mInfo )
+			aMod = mInfo.ModuleSource;
+        else 
+            Event.Element >>= aMod;
         if( pMod )
+		{
             pMod->SetSource32( aMod );
+			if ( mInfo.ModuleType == ModuleType::Document )
+			{
+				SbObjModule* pObjModule = dynamic_cast< SbObjModule* >( pMod );
+				if ( pObjModule )	
+					pObjModule->SetUnoObject( makeAny( mInfo.ModuleObject ) );
+			}
+		}
         else
-            pLib->MakeModule32( aName, aMod );
+			// Probably we should have an assert for
+			// unknow module type, e.g. either we are using
+			// the ModuleInfo structure ( vba ) for *all* modules
+			// or not ( normal )
+			if ( mInfo.ModuleType == ModuleType::Unknown )
+				pLib->MakeModule32( aName, aMod );
+			else
+				pLib->MakeModule32( mInfo );
 
         pLib->SetModified( FALSE );
     }
@@ -1122,6 +1162,25 @@ void BasicManager::LegacyDeleteBasicMana
     _rpManager = NULL;
 }
 
+
+bool BasicManager::HasExeCode( const String& sLib )
+{
+	StarBASIC* pLib = GetLib(sLib);	
+	if ( pLib )
+	{
+		SbxArray* pMods = pLib->GetModules();
+		USHORT nMods = pMods ? pMods->Count() : 0;
+		for( USHORT i = 0; i < nMods; i++ )
+		{
+			SbModule* p = (SbModule*) pMods->Get( i );
+			if ( p )
+				if ( p->HasExeCode() )
+					return true;
+		}
+	}
+	return false;
+}
+
 void BasicManager::Init()
 {
     DBG_CHKTHIS( BasicManager, 0 );
--- basic/source/classes/errobject.cxx.old	2010-03-03 16:59:34.000000000 +0100
+++ basic/source/classes/errobject.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,181 @@
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+#include "errobject.hxx"
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include "sbintern.hxx"
+#include "runtime.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo;
+
+typedef ::cppu::WeakImplHelper2< vba::XErrObject, script::XDefaultProperty > ErrObjectImpl_BASE;
+
+class ErrObject : public ErrObjectImpl_BASE
+{	
+	rtl::OUString m_sHelpFile;
+	rtl::OUString m_sSource;
+        rtl::OUString m_sDescription; 
+	sal_Int32 m_nNumber;
+	sal_Int32 m_nHelpContext;
+	
+public:
+	ErrObject();
+	~ErrObject();
+	// Attributes
+	virtual ::sal_Int32 SAL_CALL getNumber() throw (uno::RuntimeException);
+	virtual void SAL_CALL setNumber( ::sal_Int32 _number ) throw (uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getHelpContext() throw (uno::RuntimeException);
+	virtual void SAL_CALL setHelpContext( ::sal_Int32 _helpcontext ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getHelpFile() throw (uno::RuntimeException);
+	virtual void SAL_CALL setHelpFile( const ::rtl::OUString& _helpfile ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getDescription() throw (uno::RuntimeException);
+	virtual void SAL_CALL setDescription( const ::rtl::OUString& _description ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getSource() throw (uno::RuntimeException);
+	virtual void SAL_CALL setSource( const ::rtl::OUString& _source ) throw (uno::RuntimeException);
+	
+	// Methods
+	virtual void SAL_CALL Clear(  ) throw (uno::RuntimeException);
+	virtual void SAL_CALL Raise( const uno::Any& Number, const uno::Any& Source, const uno::Any& Description, const uno::Any& HelpFile, const uno::Any& HelpContext ) throw (uno::RuntimeException);
+	// XDefaultProperty	
+	virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (uno::RuntimeException);
+};
+
+
+ErrObject::~ErrObject()
+{
+}
+
+ErrObject::ErrObject() : m_nNumber(0), m_nHelpContext(0)
+{
+}
+
+sal_Int32 SAL_CALL
+ErrObject::getNumber() throw (uno::RuntimeException)
+{
+	return m_nNumber;
+}
+
+void SAL_CALL 
+ErrObject::setNumber( ::sal_Int32 _number ) throw (uno::RuntimeException)
+{
+	m_nNumber = _number;
+
+	
+}
+
+::sal_Int32 SAL_CALL 
+ErrObject::getHelpContext() throw (uno::RuntimeException)
+{
+	return m_nHelpContext;
+}
+void SAL_CALL 
+ErrObject::setHelpContext( ::sal_Int32 _helpcontext ) throw (uno::RuntimeException)
+{
+	m_nHelpContext = _helpcontext;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getHelpFile() throw (uno::RuntimeException)
+{
+	return m_sHelpFile;
+}
+
+void SAL_CALL 
+ErrObject::setHelpFile( const ::rtl::OUString& _helpfile ) throw (uno::RuntimeException)
+{
+	m_sHelpFile = _helpfile;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getDescription() throw (uno::RuntimeException)
+{
+	return m_sDescription;
+}
+
+void SAL_CALL 
+ErrObject::setDescription( const ::rtl::OUString& _description ) throw (uno::RuntimeException)
+{
+	m_sDescription = _description;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getSource() throw (uno::RuntimeException)
+{
+	return m_sSource;
+}
+
+void SAL_CALL 
+ErrObject::setSource( const ::rtl::OUString& _source ) throw (uno::RuntimeException)
+{
+	m_sSource = _source;
+}
+	
+// Methods
+void SAL_CALL 
+ErrObject::Clear(  ) throw (uno::RuntimeException)
+{
+	m_sHelpFile = rtl::OUString();
+	m_sSource = m_sHelpFile;
+	m_sDescription = m_sSource;
+	m_nNumber = 0;	
+	m_nHelpContext = 0;	
+}
+
+void SAL_CALL 
+ErrObject::Raise( const uno::Any& Number, const uno::Any& Source, const uno::Any& Description, const uno::Any& HelpFile, const uno::Any& HelpContext ) throw (uno::RuntimeException)
+{
+	if ( !Number.hasValue() )
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("Missing Required Paramater"), uno::Reference< uno::XInterface >() );
+	Description >>= m_sDescription;
+	Source >>= m_sSource;
+	HelpFile >>= m_sHelpFile;
+	HelpContext >>= m_nHelpContext;
+	Number >>= m_nNumber;
+	if ( m_nNumber )
+	{
+		SbError n = StarBASIC::GetSfxFromVBError( m_nNumber );
+		if ( !n )
+			n = m_nNumber; // force orig number, probably should have a specific table of vb ( localized ) errors
+		pINST->Error( n, m_sDescription );
+	}
+}
+
+// XDefaultProperty	
+::rtl::OUString SAL_CALL 
+ErrObject::getDefaultPropertyName(  ) throw (uno::RuntimeException)
+{
+	static rtl::OUString sDfltPropName( RTL_CONSTASCII_USTRINGPARAM("Number") );
+	return sDfltPropName;
+}
+
+// SbxErrObject
+SbxErrObject::SbxErrObject( const String& rName, const Any& rUnoObj ): SbUnoObject( rName, rUnoObj )
+{
+	OSL_TRACE("SbxErrObject::SbxErrObject ctor");
+	rUnoObj >>= m_xErr;
+	if ( m_xErr.is() )
+		SetDfltProperty( uno::Reference< script::XDefaultProperty >( m_xErr, uno::UNO_QUERY_THROW )->getDefaultPropertyName() ) ;
+}
+
+SbxErrObject::~SbxErrObject()
+{
+	OSL_TRACE("SbxErrObject::~SbxErrObject dtor");
+}
+
+uno::Reference< vba::XErrObject > 
+SbxErrObject::getUnoErrObject()
+{
+	SbxVariable* pVar = getErrObject();
+	SbxErrObject* pGlobErr = static_cast< SbxErrObject* >(  pVar );
+	return pGlobErr->m_xErr;	
+}
+
+SbxVariableRef
+SbxErrObject::getErrObject()
+{
+	static SbxVariableRef pGlobErr = new SbxErrObject( String(  RTL_CONSTASCII_USTRINGPARAM("Err")), uno::makeAny( uno::Reference< vba::XErrObject >( new ErrObject() ) ) );
+	return pGlobErr;
+}
+
--- basic/source/classes/eventatt.cxx.old	2009-12-17 14:34:39.000000000 +0100
+++ basic/source/classes/eventatt.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -58,7 +58,10 @@
 #include <com/sun/star/awt/XDialogProvider.hpp>
 
 #include <com/sun/star/frame/XModel.hpp>
-
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <basic/basicmanagerrepository.hxx>
+#include <basic/basmgr.hxx>
 //==================================================================================================
 
 #include <xmlscript/xmldlg_imexp.hxx>
@@ -453,6 +456,43 @@ Any implFindDialogLibForDialog( const An
     return aRetDlgLibAny;
 }
 
+Any implFindDialogLibForDialogBasic( const Any& aAnyISP, SbxObject* pBasic, StarBASIC*& pFoundBasic )
+{
+	Any aDlgLibAny;
+	// Find dialog library for dialog, direct access is not possible here
+    StarBASIC* pStartedBasic = (StarBASIC*)pBasic;
+	SbxObject* pParentBasic = pStartedBasic ? pStartedBasic->GetParent() : NULL;
+	SbxObject* pParentParentBasic = pParentBasic ? pParentBasic->GetParent() : NULL;
+
+	SbxObject* pSearchBasic1 = NULL;
+	SbxObject* pSearchBasic2 = NULL;
+	if( pParentParentBasic )
+	{
+		pSearchBasic1 = pParentBasic;
+		pSearchBasic2 = pParentParentBasic;
+	}
+	else
+	{
+		pSearchBasic1 = pStartedBasic;
+		pSearchBasic2 = pParentBasic;
+	}
+	if( pSearchBasic1 )
+	{
+		aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic1 );
+
+		if ( aDlgLibAny.hasValue() )
+			pFoundBasic = (StarBASIC*)pSearchBasic1;
+
+		else if( pSearchBasic2 )
+		{
+			aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic2 );
+			if ( aDlgLibAny.hasValue() )
+				pFoundBasic = (StarBASIC*)pSearchBasic2;
+		}
+	}
+	return aDlgLibAny;
+}
+
 static ::rtl::OUString aDecorationPropName =
     ::rtl::OUString::createFromAscii( "Decoration" );
 static ::rtl::OUString aTitlePropName =
@@ -532,39 +572,51 @@ void RTL_Impl_CreateUnoDialog( StarBASIC
         {}
     }
 
-    // Find dialog library for dialog, direct access is not possible here
-    StarBASIC* pStartedBasic = pINST->GetBasic();
-    SbxObject* pParentBasic = pStartedBasic ? pStartedBasic->GetParent() : NULL;
-    SbxObject* pParentParentBasic = pParentBasic ? pParentBasic->GetParent() : NULL;
-
-    SbxObject* pSearchBasic1 = NULL;
-    SbxObject* pSearchBasic2 = NULL;
-    if( pParentParentBasic )
-    {
-        pSearchBasic1 = pParentBasic;
-        pSearchBasic2 = pParentParentBasic;
-    }
-    else
-    {
-        pSearchBasic1 = pStartedBasic;
-        pSearchBasic2 = pParentBasic;
-    }
-
     Any aDlgLibAny;
-    if( pSearchBasic1 )
-    {
-        aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic1 );
-        if( pSearchBasic2 && aDlgLibAny.getValueType().getTypeClass() == TypeClass_VOID )
-            aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic2 );
-    }
-
-
+	bool bDocDialog = false;
+	StarBASIC* pFoundBasic = NULL;
     OSL_TRACE("About to try get a hold of ThisComponent");
-    Reference< frame::XModel > xModel = getModelFromBasic( pStartedBasic ) ;
-    Reference< XScriptListener > xScriptListener = new BasicScriptListener_Impl( pStartedBasic, xModel );
+    Reference< frame::XModel > xModel = getModelFromBasic( pINST->GetBasic() ) ;
+		aDlgLibAny = implFindDialogLibForDialogBasic( aAnyISP, pINST->GetBasic(), pFoundBasic );
+		// If we found the dialog then it belongs to the Search basic
+		if ( !pFoundBasic )
+		{
+			Reference< frame::XDesktop > xDesktop( xMSF->createInstance
+		( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.frame.Desktop" ) ) ),
+			UNO_QUERY );
+			Reference< container::XEnumeration > xModels;
+			if ( xDesktop.is() )
+			{
+				Reference< container::XEnumerationAccess > xComponents( xDesktop->getComponents(), UNO_QUERY );
+				if ( xComponents.is() )
+					xModels.set( xComponents->createEnumeration(), UNO_QUERY );
+				if ( xModels.is() )
+				{
+					while ( xModels->hasMoreElements() )
+					{
+						Reference< frame::XModel > xNextModel( xModels->nextElement(), UNO_QUERY );
+						if ( xNextModel.is() )
+						{
+							BasicManager* pMgr = basic::BasicManagerRepository::getDocumentBasicManager( xNextModel );	
+							if ( pMgr )
+								aDlgLibAny = implFindDialogLibForDialogBasic( aAnyISP, pMgr->GetLib(0), pFoundBasic );
+							if ( aDlgLibAny.hasValue() )
+							{
+								bDocDialog = true;
+								xModel = xNextModel;
+								break;
+							} 
+						}
+					}
+				}
+			}
+		}
+	if ( pFoundBasic )
+		bDocDialog = pFoundBasic->IsDocBasic();
+       Reference< XScriptListener > xScriptListener = new BasicScriptListener_Impl( pINST->GetBasic(), xModel );
 
     Sequence< Any > aArgs( 4 );
-    aArgs[ 0 ] <<= xModel;
+	aArgs[ 0 ] <<= bDocDialog ? xModel : uno::Reference< uno::XInterface >();
     aArgs[ 1 ] <<= xInput;
     aArgs[ 2 ] = aDlgLibAny;
     aArgs[ 3 ] <<= xScriptListener;
--- basic/source/classes/makefile.mk.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/classes/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -41,18 +41,28 @@ ENABLE_EXCEPTIONS=TRUE
 
 .INCLUDE :  settings.mk
 
+ALLTAR .SEQUENTIAL : \
+        $(MISC)$/$(TARGET).don \
+        $(MISC)$/$(TARGET).slo
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
+$(MISC)$/$(TARGET).slo : $(SLOTARGET)
+        echo $@
+
 # --- Allgemein -----------------------------------------------------------
 
-COMMON_SLOFILES=	\
+SLOFILES=	\
     $(SLO)$/sb.obj       \
     $(SLO)$/sbxmod.obj	\
     $(SLO)$/image.obj	\
     $(SLO)$/sbintern.obj	\
     $(SLO)$/sbunoobj.obj	\
     $(SLO)$/propacc.obj	\
-    $(SLO)$/disas.obj
-
-SLOFILES=	$(COMMON_SLOFILES)	\
+	$(SLO)$/disas.obj \
+	$(SLO)$/errobject.obj \
     $(SLO)$/eventatt.obj
 
 OBJFILES=	\
--- basic/source/classes/sb.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/source/classes/sb.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -52,12 +52,17 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
 #include <basrid.hxx>
 #include <vos/mutex.hxx>
 
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+using namespace ::com::sun::star::script;
+
 // #pragma SW_SEGMENT_CLASS( SBASIC, SBASIC_CODE )
 
 SV_IMPL_VARARR(SbTextPortions,SbTextPortion)
@@ -218,6 +223,7 @@ const SFX_VB_ErrorItem __FAR_DATA SFX_VB
     { 1004, SbERR_METHOD_FAILED },
     { 1005, SbERR_SETPROP_FAILED },
     { 1006, SbERR_GETPROP_FAILED },
+	{ 1007, SbERR_BASIC_COMPAT },
     { 0xFFFF, 0xFFFFFFFFL }		// End mark
 };
 
@@ -263,6 +269,8 @@ SbxObject* SbiFactory::CreateObject( con
     else
     if( rClass.EqualsIgnoreCaseAscii( "Collection" ) )
     {
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
         String aCollectionName( RTL_CONSTASCII_USTRINGPARAM("Collection") );
         return new BasicCollection( aCollectionName );
     }
@@ -488,6 +496,7 @@ SbClassModuleObject::SbClassModuleObject
             }
         }
     }
+	SetModuleType( com::sun::star::script::ModuleType::Class );
 }
 
 SbClassModuleObject::~SbClassModuleObject()
@@ -503,72 +512,7 @@ SbClassModuleObject::~SbClassModuleObjec
 void SbClassModuleObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
                            const SfxHint& rHint, const TypeId& rHintType )
 {
-    bool bDone = false;
-
-    const SbxHint* pHint = PTR_CAST(SbxHint,&rHint);
-    if( pHint )
-    {
-        SbxVariable* pVar = pHint->GetVar();
-        SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
-        if( pProcProperty )
-        {
-            bDone = true;
-
-            if( pHint->GetId() == SBX_HINT_DATAWANTED )
-            {
-                String aProcName;
-                aProcName.AppendAscii( "Property Get " );
-                aProcName += pProcProperty->GetName();
-
-                SbxVariable* pMeth = Find( aProcName, SbxCLASS_METHOD );
-                if( pMeth )
-                {
-                    SbxValues aVals;
-                    aVals.eType = SbxVARIANT;
-                    pMeth->Get( aVals );
-                    pVar->Put( aVals );
-                }
-            }
-            else if( pHint->GetId() == SBX_HINT_DATACHANGED )
-            {
-                SbxVariable* pMeth = NULL;
-
-                bool bSet = pProcProperty->isSet();
-                if( bSet )
-                {
-                    pProcProperty->setSet( false );
-
-                    String aProcName;
-                    aProcName.AppendAscii( "Property Set " );
-                    aProcName += pProcProperty->GetName();
-                    pMeth = Find( aProcName, SbxCLASS_METHOD );
-                }
-                if( !pMeth )	// Let
-                {
-                    String aProcName;
-                    aProcName.AppendAscii( "Property Let " );
-                    aProcName += pProcProperty->GetName();
-                    pMeth = Find( aProcName, SbxCLASS_METHOD );
-                }
-
-                if( pMeth )
-                {
-                    // Setup parameters
-                    SbxArrayRef xArray = new SbxArray;
-                    xArray->Put( pMeth, 0 );	// Method as parameter 0
-                    xArray->Put( pVar, 1 );
-                    pMeth->SetParameters( xArray );
-
-                    SbxValues aVals;
-                    pMeth->Get( aVals );
-                    pMeth->SetParameters( NULL );
-                }
-            }
-        }
-    }
-
-    if( !bDone )
-        SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
+	SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
 }
 
 SbxVariable* SbClassModuleObject::Find( const XubString& rName, SbxClassType t )
@@ -685,6 +629,7 @@ StarBASIC::StarBASIC( StarBASIC* p, BOOL
     SetParent( p );
     pLibInfo = NULL;
     bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
     pModules = new SbxArray;
 
     if( !GetSbData()->nInst++ )
@@ -785,8 +730,37 @@ SbModule* StarBASIC::MakeModule( const S
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-    SbModule* p = new SbModule( rName );
-    p->SetSource32( rSrc );
+    ModuleInfo mInfo;
+    mInfo.ModuleSource = rSrc;
+    mInfo.ModuleType = ModuleType::Normal;
+    mInfo.ModuleName = rName;
+    return MakeModule32(  mInfo );
+}
+SbModule* StarBASIC::MakeModule32( const ModuleInfo& mInfo )
+{
+    
+    OSL_TRACE("create module %s type mInfo %d", rtl::OUStringToOString( mInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr(), mInfo.ModuleType );
+    SbModule* p = NULL;
+    switch ( mInfo.ModuleType )
+    {
+        case ModuleType::Document:
+            // In theory we should be able to create Object modules
+            // in ordinary basic ( in vba mode thought these are create
+            // by the application/basic and not by the user )
+            p = new SbObjModule( mInfo, isVBAEnabled() );
+            break;
+        case ModuleType::Class:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+			p->SetModuleType( com::sun::star::script::ModuleType::Class );	
+	    break;
+        case ModuleType::Form:
+            p = new SbUserFormModule( mInfo, isVBAEnabled() );
+	    break;
+        default:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+            
+    }
+	p->SetSource32( mInfo.ModuleSource );
     p->SetParent( this );
     pModules->Insert( p, pModules->Count() );
     SetModified( TRUE );
@@ -961,6 +935,11 @@ SbxVariable* StarBASIC::Find( const Stri
                 }
                 pNamed = p;
             }
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
+			INT32 nType = p->GetModuleType();
+			if ( nType == com::sun::star::script::ModuleType::Document || nType == com::sun::star::script::ModuleType::Form )
+				continue;
             // otherwise check if the element is available
             // unset GBLSEARCH-Flag (due to Rekursion)
             USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
--- basic/source/classes/sb.src.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/classes/sb.src	2010-03-03 16:59:34.000000000 +0100
@@ -591,6 +591,12 @@ Resource RID_BASIC_START
     {
         Text [ en-US ] = "For loop not initialized." ;
     };
+	String ERRCODE_BASIC_COMPAT & ERRCODE_RES_MASK
+	{
+		Text [ de ] = "$(ARG1)." ;
+		Text [ en-US ] = "$(ARG1)." ;
+		Text [ x-comment ] = " ";
+	};
 };
  // Hinweis: IDS_SBERR_TERMINATED = IDS_SBERR_START+2000.
 String IDS_SBERR_TERMINATED
--- basic/source/classes/sbunoobj.cxx.old	2010-01-21 01:00:49.000000000 +0100
+++ basic/source/classes/sbunoobj.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -63,6 +63,7 @@
 #include <com/sun/star/script/XInvocationAdapterFactory.hpp>
 #include <com/sun/star/script/XTypeConverter.hpp>
 #include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XIdlArray.hpp>
@@ -73,7 +74,7 @@
 #include <com/sun/star/bridge/oleautomation/Date.hpp>
 #include <com/sun/star/bridge/oleautomation/Decimal.hpp>
 #include <com/sun/star/bridge/oleautomation/Currency.hpp>
-
+#include <com/sun/star/script/XAutomationInvocation.hpp>
 
 using com::sun::star::uno::Reference;
 using namespace com::sun::star::uno;
@@ -141,20 +142,38 @@ bool SbUnoObject::getDefaultPropName( Sb
 SbxVariable* getDefaultProp( SbxVariable* pRef )
 {
     SbxVariable* pDefaultProp = NULL;
-    SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
-    if ( !pObj )
-    {
-        SbxBase* pObjVarObj = pRef->GetObject();
-        pObj = PTR_CAST(SbxObject,pObjVarObj);
-    }
-    if ( pObj && pObj->ISA(SbUnoObject) )
-    {
-        SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
-        pDefaultProp = pUnoObj->GetDfltProperty();
+	if ( pRef->GetType() == SbxOBJECT )
+	{
+  		SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
+		if ( !pObj )
+		{
+			SbxBase* pObjVarObj = pRef->GetObject();
+			pObj = PTR_CAST(SbxObject,pObjVarObj);
+		}
+		if ( pObj && pObj->ISA(SbUnoObject) )
+		{
+			SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
+			pDefaultProp = pUnoObj->GetDfltProperty();
+		}
     }
     return pDefaultProp;
 }
 
+void SetSbUnoObjectDfltPropName( SbxObject* pObj )
+{
+	SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*) pObj);
+	if ( pUnoObj )
+	{
+		String sDfltPropName;
+		
+		if ( SbUnoObject::getDefaultPropName( pUnoObj, sDfltPropName ) )
+		{
+			OSL_TRACE("SetSbUnoObjectDfltPropName setting dflt prop for %s", rtl::OUStringToOString( pObj->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+			pUnoObj->SetDfltProperty( sDfltPropName );
+		}
+	}
+}
+
 Reference< XComponentContext > getComponentContext_Impl( void )
 {
     static Reference< XComponentContext > xContext;
@@ -750,11 +769,11 @@ void unoToSbxValue( SbxVariable* pVar, c
             // SbUnoObject instanzieren
             String aName;
             SbUnoObject* pSbUnoObject = new SbUnoObject( aName, aValue );
-            //If this is called externally e.g. from the scripting 
-            //framework then there is no 'active' runtime the default property will not be set up
-            //only a vba object will have XDefaultProp set anyway so... this
-            //test seems a bit of overkill
-            //if ( SbiRuntime::isVBAEnabled() )
+			//If this is called externally e.g. from the scripting 
+			//framework then there is no 'active' runtime the default property will not be set up
+			//only a vba object will have XDefaultProp set anyway so... this
+			//test seems a bit of overkill
+			//if ( SbiRuntime::isVBAEnabled() )
             {
                 String sDfltPropName;
 
@@ -1489,6 +1508,103 @@ Any sbxToUnoValue( SbxVariable* pVar, co
     return aRetVal;
 }
 
+void processAutomationParams( SbxArray* pParams, Sequence< Any >& args, bool bOLEAutomation, UINT32 nParamCount )
+{
+	AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
+	if( bOLEAutomation )
+		pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
+
+	args.realloc( nParamCount );
+	Any* pAnyArgs = args.getArray();
+	bool bBlockConversionToSmallestType = pINST->IsCompatibility();
+	UINT32 i = 0;	
+	if( pArgNamesArray )
+	{
+		Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
+		::rtl::OUString* pNames = rNameSeq.getArray();
+		Any aValAny;
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			USHORT iSbx = (USHORT)(i+1);
+	
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
+			bBlockConversionToSmallestType );
+	
+			::rtl::OUString aParamName = pNames[iSbx];
+			if( aParamName.getLength() )
+			{
+				oleautomation::NamedArgument aNamedArgument;
+				aNamedArgument.Name = aParamName;
+				aNamedArgument.Value = aValAny;
+				pAnyArgs[i] <<= aNamedArgument;
+			}
+			else
+			{
+				pAnyArgs[i] = aValAny;
+			}
+		}
+	}
+	else
+	{
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
+			bBlockConversionToSmallestType );
+		}
+	}
+
+}
+enum INVOKETYPE
+{
+   GetProp = 0, 
+   SetProp, 
+   Func
+};
+Any invokeAutomationMethod( const String& Name, Sequence< Any >& args, SbxArray* pParams, UINT32 nParamCount, Reference< XInvocation >& rxInvocation, INVOKETYPE invokeType = Func )
+{
+	Sequence< INT16 > OutParamIndex;
+	Sequence< Any > OutParam;
+    
+	Any aRetAny;
+	switch( invokeType )
+	{
+		case Func:
+			aRetAny = rxInvocation->invoke( Name, args, OutParamIndex, OutParam );
+			break;
+		case GetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY_THROW );
+				aRetAny = xAutoInv->invokeGetProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		case SetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY_THROW );
+				aRetAny = xAutoInv->invokePutProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		default:
+			break; // should introduce an error here
+	
+	}
+	const INT16* pIndices = OutParamIndex.getConstArray();
+	UINT32 nLen = OutParamIndex.getLength();
+	if( nLen )
+	{
+		const Any* pNewValues = OutParam.getConstArray();
+		for( UINT32 j = 0 ; j < nLen ; j++ )
+		{
+			INT16 iTarget = pIndices[ j ];
+			if( iTarget >= (INT16)nParamCount )
+				break;
+			unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
+		}
+	}
+    return aRetAny;
+}
+
 // Dbg-Hilfsmethode zum Auslesen der in einem Object implementierten Interfaces
 String Impl_GetInterfaceInfo( const Reference< XInterface >& x, const Reference< XIdlClass >& xClass, USHORT nRekLevel )
 {
@@ -1603,6 +1719,23 @@ bool checkUnoObjectType( SbUnoObject* pU
                 break;
             }
             ::rtl::OUString sClassName = xClass->getName();
+			if ( sClassName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.bridge.oleautomation.XAutomationObject" ) ) ) )
+			{
+				// there is a hack in the extensions/source/ole/oleobj.cxx  to return the typename of the automation object, lets check if it
+				// matches
+				Reference< XInvocation > xInv( aToInspectObj, UNO_QUERY );
+				if ( xInv.is() )
+				{
+					rtl::OUString sTypeName;
+					xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sTypeName;
+					if ( sTypeName.getLength() == 0 || sTypeName.equals(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") ) ) )
+						// can't check type, leave it pass
+						result = true;	
+					else
+						result = sTypeName.equals( aClass );
+				}
+				break; // finished checking automation object
+			}
             OSL_TRACE("Checking if object implements %s",
                 OUStringToOString( defaultNameSpace + aClass,
                     RTL_TEXTENCODING_UTF8 ).getStr() );
@@ -1972,11 +2105,26 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadca
                 {
                     try
                     {
-                        // Wert holen
-                        Any aRetAny = mxInvocation->getValue( pProp->GetName() );
+						UINT32 nParamCount = pParams ? ((UINT32)pParams->Count() - 1) : 0;
+						sal_Bool bCanBeConsideredAMethod = mxInvocation->hasMethod( pProp->GetName() );
+						Any aRetAny;
+					   	if ( bCanBeConsideredAMethod && nParamCount )
+						{
+							// Automation properties have methods, so.. we need to invoke this through
+							// XInvocation
+							Sequence<Any> args;
+							processAutomationParams( pParams, args, true, nParamCount );
+							aRetAny = invokeAutomationMethod( pProp->GetName(), args, pParams, nParamCount, mxInvocation, GetProp );
+						}	
+						else
+							// Wert holen
+							aRetAny = mxInvocation->getValue( pProp->GetName() );
 
                         // Wert von Uno nach Sbx uebernehmen
                         unoToSbxValue( pVar, aRetAny );
+						if( pParams && bCanBeConsideredAMethod )
+							pVar->SetParameters( NULL );
+
                     }
                     catch( const Exception& )
                     {
@@ -2101,52 +2249,7 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadca
                 else if( bInvocation && pParams && mxInvocation.is() )
                 {
                     bool bOLEAutomation = true;
-                    // TODO: bOLEAutomation = xOLEAutomation.is()
-
-                    AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
-                    if( bOLEAutomation )
-                        pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
-
-                    args.realloc( nParamCount );
-                    Any* pAnyArgs = args.getArray();
-                    bool bBlockConversionToSmallestType = pINST->IsCompatibility();
-                    if( pArgNamesArray )
-                    {
-                        Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
-                        ::rtl::OUString* pNames = rNameSeq.getArray();
-
-                        Any aValAny;
-                        for( i = 0 ; i < nParamCount ; i++ )
-                        {
-                            USHORT iSbx = (USHORT)(i+1);
-
-                            // ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-                            aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
-                                                        bBlockConversionToSmallestType );
-
-                            ::rtl::OUString aParamName = pNames[iSbx];
-                            if( aParamName.getLength() )
-                            {
-                                oleautomation::NamedArgument aNamedArgument;
-                                aNamedArgument.Name = aParamName;
-                                aNamedArgument.Value = aValAny;
-                                pAnyArgs[i] <<= aNamedArgument;
-                            }
-                            else
-                            {
-                                pAnyArgs[i] = aValAny;
-                            }
-                        }
-                    }
-                    else
-                    {
-                        for( i = 0 ; i < nParamCount ; i++ )
-                        {
-                            // ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-                            pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
-                                                            bBlockConversionToSmallestType );
-                        }
-                    }
+					processAutomationParams( pParams, args, bOLEAutomation, nParamCount );
                 }
 
                 // Methode callen
@@ -2181,26 +2284,8 @@ void SbUnoObject::SFX_NOTIFY( SfxBroadca
                     }
                     else if( bInvocation && mxInvocation.is() )
                     {
-                        Sequence< INT16 > OutParamIndex;
-                        Sequence< Any > OutParam;
-                        Any aRetAny = mxInvocation->invoke( pMeth->GetName(), args, OutParamIndex, OutParam );
-
-                        // Wert von Uno nach Sbx uebernehmen
+						Any aRetAny = invokeAutomationMethod( pMeth->GetName(), args, pParams, nParamCount, mxInvocation );
                         unoToSbxValue( pVar, aRetAny );
-
-                        const INT16* pIndices = OutParamIndex.getConstArray();
-                        UINT32 nLen = OutParamIndex.getLength();
-                        if( nLen )
-                        {
-                            const Any* pNewValues = OutParam.getConstArray();
-                            for( UINT32 j = 0 ; j < nLen ; j++ )
-                            {
-                                INT16 iTarget = pIndices[ j ];
-                                if( iTarget >= (INT16)nParamCount )
-                                    break;
-                                unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
-                            }
-                        }
                     }
 
                     // #55460, Parameter hier weghauen, da das in unoToSbxValue()
@@ -3129,11 +3214,16 @@ getTypeDescriptorEnumeration( const ::rt
 
 typedef std::hash_map< ::rtl::OUString, Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
 
-SbxVariable* getVBAConstant( const String& rName )
+VBAConstantHelper&
+VBAConstantHelper::instance()
+{
+    static VBAConstantHelper aHelper;
+    return aHelper;
+}
+
+void
+VBAConstantHelper::init()
 {
-    SbxVariable* pConst = NULL;
-    static VBAConstantsHash aConstCache;
-    static bool isInited = false;
     if ( !isInited )
     {
         Sequence< TypeClass > types(1);
@@ -3141,39 +3231,77 @@ SbxVariable* getVBAConstant( const Strin
         Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( defaultNameSpace, types, TypeDescriptionSearchDepth_INFINITE  );
 
         if ( !xEnum.is() )
-            return NULL;
+            return; //NULL;
 
         while ( xEnum->hasMoreElements() )
         {
             Reference< XConstantsTypeDescription > xConstants( xEnum->nextElement(), UNO_QUERY );
             if ( xConstants.is() )
             {
+                // store constant group name 
+                ::rtl::OUString sFullName = xConstants->getName();
+                sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
+                ::rtl::OUString sLeafName( sFullName );
+                if ( indexLastDot > -1 )
+                    sLeafName = sFullName.copy( indexLastDot + 1);
+                aConstCache.push_back( sLeafName ); // assume constant group names are unique
                 Sequence< Reference< XConstantTypeDescription > > aConsts = xConstants->getConstants();
                 Reference< XConstantTypeDescription >* pSrc = aConsts.getArray();
                 sal_Int32 nLen = aConsts.getLength();
                 for ( sal_Int32 index =0;  index<nLen; ++pSrc, ++index )
                 {
+                    // store constant member name
                     Reference< XConstantTypeDescription >& rXConst =
                         *pSrc;
-                    ::rtl::OUString sFullName = rXConst->getName();
-                    sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
-                    ::rtl::OUString sLeafName;
+                    sFullName = rXConst->getName();
+                    indexLastDot = sFullName.lastIndexOf('.');
+                    sLeafName = sFullName;
                     if ( indexLastDot > -1 )
                         sLeafName = sFullName.copy( indexLastDot + 1);
-                    aConstCache[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
+                    aConstHash[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
                 }
             }
         }
         isInited = true;
     }
+}
+
+bool
+VBAConstantHelper::isVBAConstantType( const String& rName )
+{
+    init();
+    bool bConstant = false;
+    ::rtl::OUString sKey( rName );
+    VBAConstantsVector::const_iterator it = aConstCache.begin();
+
+    for( ; it != aConstCache.end(); it++ )
+    {
+        if( sKey.equalsIgnoreAsciiCase( *it ) )
+        {
+            bConstant = true;
+            break;
+        }
+    }
+    return bConstant; 
+}
+
+SbxVariable* 
+VBAConstantHelper::getVBAConstant( const String& rName )
+{
+    SbxVariable* pConst = NULL;
+    init();
+
     ::rtl::OUString sKey( rName );
-    VBAConstantsHash::const_iterator it = aConstCache.find( sKey.toAsciiLowerCase() );
-    if ( it != aConstCache.end() )
+
+    VBAConstantsHash::const_iterator it = aConstHash.find( sKey.toAsciiLowerCase() );
+
+    if ( it != aConstHash.end() )
     {
         pConst = new SbxVariable( SbxVARIANT );
         pConst->SetName( rName );
         unoToSbxValue( pConst, it->second );
     }
+
     return pConst;
 }
 
--- basic/source/classes/sbxmod.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/source/classes/sbxmod.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -55,6 +55,8 @@
 
 #include <basic/basrdll.hxx>
 #include <vos/mutex.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 
 // for the bsearch
@@ -75,6 +77,21 @@
 #include <vcl/svapp.hxx>
  using namespace ::com::sun::star; 
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/awt/XDialogProvider.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <comphelper/anytostring.hxx>
+#include <com/sun/star/document/XVbaMethodParameter.hpp> //liuchen 2009-7-21
+extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any& aValue ); //liuchen 2009-7-21
+extern ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );  //liuchen 2009-7-21
+
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <vcl/svapp.hxx>
+using namespace ::com::sun::star; 
 
 TYPEINIT1(SbModule,SbxObject)
 TYPEINIT1(SbMethod,SbxMethod)
@@ -82,6 +99,8 @@ TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
+TYPEINIT1(SbUserFormModule,SbObjModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -119,7 +138,6 @@ IMPL_LINK( AsyncQuitHandler, OnAsyncQuit
     return 0L;
 }
 
-#if 0
 bool UnlockControllerHack( StarBASIC* pBasic )
 {
     bool bRes = false;
@@ -145,18 +163,19 @@ bool UnlockControllerHack( StarBASIC* pB
     }
     return bRes;
 }
-#endif
+
 /////////////////////////////////////////////////////////////////////////////
 
 // Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
 // Elemente von anderen Modulen aus gefunden werden koennen.
 
-SbModule::SbModule( const String& rName )
+SbModule::SbModule( const String& rName, bool bVBACompat )
          : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-           pImage( NULL ), pBreaks( NULL ), pClassData( NULL )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( bVBACompat ),  pDocObject( NULL ), bIsProxyModule( false )
 {
     SetName( rName );
     SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	SetModuleType( com::sun::star::script::ModuleType::Normal );
 }
 
 SbModule::~SbModule()
@@ -331,7 +350,10 @@ void SbModule::Clear()
 
 SbxVariable* SbModule::Find( const XubString& rName, SbxClassType t )
 {
+	// make sure a search in an uninstatiated class module will fail
     SbxVariable* pRes = SbxObject::Find( rName, t );
+	if ( bIsProxyModule )
+		return NULL;
     if( !pRes && pImage )
     {
         SbiInstance* pInst = pINST;
@@ -393,6 +415,64 @@ void SbModule::SFX_NOTIFY( SfxBroadcaste
         SbxVariable* pVar = pHint->GetVar();
         SbProperty* pProp = PTR_CAST(SbProperty,pVar);
         SbMethod* pMeth = PTR_CAST(SbMethod,pVar);
+		SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
+		if( pProcProperty )
+		{
+			if( pHint->GetId() == SBX_HINT_DATAWANTED )
+			{
+				String aProcName;
+				aProcName.AppendAscii( "Property Get " );
+				aProcName += pProcProperty->GetName();
+
+				SbxVariable* pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				if( pPropMeth )
+				{
+					// Setup parameters
+					pPropMeth->SetParameters( pVar->GetParameters() );
+
+					SbxValues aVals;
+					aVals.eType = SbxVARIANT;
+					pPropMeth->Get( aVals );
+					pVar->Put( aVals );
+				}
+			}
+			else if( pHint->GetId() == SBX_HINT_DATACHANGED )
+			{
+				SbxVariable* pPropMeth = NULL;
+
+				bool bSet = pProcProperty->isSet();
+				if( bSet )
+				{
+					pProcProperty->setSet( false );
+
+					String aProcName;
+					aProcName.AppendAscii( "Property Set " );
+					aProcName += pProcProperty->GetName();
+					pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+				if( !pPropMeth )	// Let
+				{
+					String aProcName;
+					aProcName.AppendAscii( "Property Let " );
+					aProcName += pProcProperty->GetName();
+					pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+
+				if( pPropMeth )
+				{
+					// Setup parameters
+					SbxArrayRef xArray = new SbxArray;
+					xArray->Put( pPropMeth, 0 );	// Method as parameter 0
+					xArray->Put( pVar, 1 );
+					pPropMeth->SetParameters( xArray );
+
+					SbxValues aVals;
+					pPropMeth->Get( aVals );
+					pPropMeth->SetParameters( NULL );
+				}
+			}
+		}
+
         if( pProp )
         {
             if( pProp->GetModule() != this )
@@ -433,6 +513,7 @@ void SbModule::SetSource32( const ::rtl:
     aOUSource = r;
     StartDefinitions();
     SbiTokenizer aTok( r );
+        aTok.SetCompatible( IsVBACompat() );
     while( !aTok.IsEof() )
     {
         SbiToken eEndTok = NIL;
@@ -457,13 +538,6 @@ void SbModule::SetSource32( const ::rtl:
                 {
                     eEndTok = ENDPROPERTY; break;
                 }
-                if( eCurTok == OPTION )
-                {
-                    eCurTok = aTok.Next();
-                    if( eCurTok == COMPATIBLE
-                    || ( ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 ) ) )
-                        aTok.SetCompatible( true );
-                }
             }
             eLastTok = eCurTok;
         }
@@ -592,7 +666,7 @@ void ClearUnoObjectsInRTL_Impl( StarBASI
 {
     // #67781 Rueckgabewerte der Uno-Methoden loeschen
     clearUnoMethods();
-    clearUnoServiceCtors();
+	clearUnoServiceCtors();
 
     ClearUnoObjectsInRTL_Impl_Rek( pBasic );
 
@@ -603,16 +677,26 @@ void ClearUnoObjectsInRTL_Impl( StarBASI
     if( ((StarBASIC*)p) != pBasic )
         ClearUnoObjectsInRTL_Impl_Rek( (StarBASIC*)p );
 }
+bool SbModule::IsVBACompat()
+{
+	return mbVBACompat;
+}
 
+void SbModule::SetVBACompat( bool bCompat )
+{
+	mbVBACompat = bCompat;
+}
 // Ausfuehren eines BASIC-Unterprogramms
 USHORT SbModule::Run( SbMethod* pMeth )
 {
+	OSL_TRACE("About to run %s, vba compatmode is %d", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), mbVBACompat );
     static USHORT nMaxCallLevel = 0;
     static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
     static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
 
     USHORT nRes = 0;
     BOOL bDelInst = BOOL( pINST == NULL );
+        bool bQuit = false;
     StarBASICRef xBasic;
     if( bDelInst )
     {
@@ -698,10 +782,10 @@ USHORT SbModule::Run( SbMethod* pMeth )
             if( pRt->pNext )
                 pRt->pNext->block();
             pINST->pRun = pRt;
-            if ( SbiRuntime ::isVBAEnabled() )
+			if ( mbVBACompat )
                         {
                 pINST->EnableCompatibility( TRUE );
-                pRt->SetVBAEnabled( true );
+				//pRt->SetVBAEnabled( true ); // can we get rid of this
                         }
             while( pRt->Step() ) {}
             if( pRt->pNext )
@@ -733,6 +817,15 @@ USHORT SbModule::Run( SbMethod* pMeth )
 
             delete pRt;
             pMOD = pOldMod;
+			if ( pINST->nCallLvl == 0 && IsVBACompat() )
+			{
+				// VBA always ensure screenupdating is enabled after completing
+				StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
+				if ( pBasic && pBasic->IsDocBasic() )
+				{
+					UnlockControllerHack( pBasic );
+				}
+			}
             if( bDelInst )
             {
                 // #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -760,10 +853,8 @@ USHORT SbModule::Run( SbMethod* pMeth )
 
 	// VBA always ensure screenupdating is enabled after completing
 	StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
-#if 0
 	if ( pBasic && pBasic->IsDocBasic() && !pINST )
 		UnlockControllerHack( pBasic );
-#endif
     if( bDelInst )
     {
         // #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -774,6 +865,8 @@ USHORT SbModule::Run( SbMethod* pMeth )
         pINST = NULL;
     }
 	if ( pBasic && pBasic->IsDocBasic() && pBasic->IsQuitApplication() && !pINST )
+            bQuit = true;
+        if ( bQuit )
 	{
 		Application::PostUserEvent( LINK( &AsyncQuitHandler::instance(), AsyncQuitHandler, OnAsyncQuit ), NULL );
 	}
@@ -817,6 +910,33 @@ void SbModule::RunInit()
 }
 
 // Mit private/dim deklarierte Variablen loeschen
+
+void SbModule::AddVarName( const String& aName ) 
+{ 
+	// see if the name is added allready
+	std::vector< String >::iterator it_end = mModuleVariableNames.end();
+	for ( std::vector< String >::iterator it = mModuleVariableNames.begin(); it != it_end; ++it )
+	{
+		if ( aName == *it )
+			return;	
+	}
+	mModuleVariableNames.push_back( aName ); 
+}
+
+void SbModule::RemoveVars()
+{
+    std::vector< String >::iterator it_end = mModuleVariableNames.end();
+    for ( std::vector< String >::iterator it = mModuleVariableNames.begin(); it != it_end; ++it )
+    {
+	// We don't want a Find being called in a derived class ( e.g. 
+	// SbUserform because it could trigger say an initialise event  
+	// which would cause basic to be re-run in the middle of the init ( and remember RemoveVars is called from compile and we don't want code to run as part of the compile )
+	SbxVariableRef p = SbModule::Find( *it, SbxCLASS_PROPERTY );
+	if( p.Is() )
+		Remove (p);
+    }
+}
+
 void SbModule::ClearPrivateVars()
 {
     for( USHORT i = 0 ; i < pProps->Count() ; i++ )
@@ -1197,6 +1317,48 @@ BOOL SbModule::ExceedsLegacyModuleSize()
     return false;
 }
 
+class ErrorHdlResetter
+{
+    Link    mErrHandler;
+    bool mbError;
+    public:
+    ErrorHdlResetter() : mbError( false )
+    {
+        // save error handler 
+        mErrHandler = StarBASIC::GetGlobalErrorHdl();
+        // set new error handler
+        StarBASIC::SetGlobalErrorHdl( LINK( this, ErrorHdlResetter, BasicErrorHdl ) );
+    }
+    ~ErrorHdlResetter()
+    {
+        // restore error handler 
+        StarBASIC::SetGlobalErrorHdl(mErrHandler);
+    }
+    DECL_LINK( BasicErrorHdl, StarBASIC * );
+    bool HasError() { return mbError; }
+};
+IMPL_LINK( ErrorHdlResetter, BasicErrorHdl, StarBASIC *, /*pBasic*/)
+{
+    mbError = true;
+    return 0;        
+}
+
+bool SbModule::HasExeCode()
+{
+
+        ErrorHdlResetter aGblErrHdl;
+	// And empty Image always has the Global Chain set up
+        static const unsigned char pEmptyImage[] = { 0x45, 0x0 , 0x0, 0x0, 0x0 };
+        // lets be stricter for the moment than VBA
+
+	bool bRes = false;
+	if ( !IsCompiled() )
+		Compile();
+	if ( pImage && !( pImage->GetCodeSize() == 5 && ( memcmp( pImage->GetCode(), pEmptyImage, pImage->GetCodeSize() ) == 0 ) )
+        || aGblErrHdl.HasError() )
+		bRes = true;
+	return bRes;
+}
 
 // Store only image, no source
 BOOL SbModule::StoreBinaryData( SvStream& rStrm )
@@ -1246,7 +1408,6 @@ BOOL SbModule::LoadBinaryData( SvStream&
     return bRet;
 }
 
-
 BOOL SbModule::LoadCompleted()
 {
     SbxArray* p = GetMethods();
@@ -1314,6 +1475,7 @@ SbMethod::SbMethod( const String& r, Sbx
     nLine1		 =
     nLine2		 = 0;
     refStatics = new SbxArray;
+    mCaller          = 0;
     // AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
     SetFlag( SBX_NO_MODIFY );
 }
@@ -1328,6 +1490,7 @@ SbMethod::SbMethod( const SbMethod& r )
     nLine1		 = r.nLine1;
     nLine2		 = r.nLine2;
         refStatics = r.refStatics; 
+ 	mCaller          = r.mCaller; 
     SetFlag( SBX_NO_MODIFY );
 }
 
@@ -1396,8 +1559,13 @@ SbxInfo* SbMethod::GetInfo()
 // Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
 // #34191# Mit speziellem RefCounting, damit das Basic nicht durch CloseDocument()
 // abgeschossen werden kann. Rueckgabewert wird als String geliefert.
-ErrCode SbMethod::Call( SbxValue* pRet )
+ErrCode SbMethod::Call( SbxValue* pRet, SbxVariable* pCaller )
 {
+	if ( pCaller )
+	{
+ 		OSL_TRACE("SbMethod::Call Have been passed a caller 0x%x", pCaller );
+		mCaller = pCaller;
+	}
     // RefCount vom Modul hochzaehlen
     SbModule* pMod_ = (SbModule*)GetParent();
     pMod_->AddRef();
@@ -1425,7 +1593,7 @@ ErrCode SbMethod::Call( SbxValue* pRet )
     // Objekte freigeben
     pMod_->ReleaseRef();
     pBasic->ReleaseRef();
-
+	mCaller = 0;
     return nErr;
 }
 
@@ -1486,6 +1654,385 @@ SbJScriptMethod::~SbJScriptMethod()
 
 
 /////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible )
+    : SbModule( mInfo.ModuleName, bIsVbaCompatible )
+{
+    SetModuleType( mInfo.ModuleType );
+    if ( mInfo.ModuleType == script::ModuleType::Form )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Form" ) );
+    }
+    else if ( mInfo.ModuleObject.is() )
+        SetUnoObject( uno::makeAny( mInfo.ModuleObject ) );
+}
+void
+SbObjModule::SetUnoObject( const uno::Any& aObj ) throw ( uno::RuntimeException )
+{
+    SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxVariable*)pDocObject);
+    if ( pUnoObj && pUnoObj->getUnoAny() == aObj ) // object is equal, nothing to do
+        return;
+    pDocObject = new SbUnoObject( GetName(), uno::makeAny( aObj ) );
+            
+    com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObj, com::sun::star::uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Worksheet" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
+    }
+    else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Workbook" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
+    }
+}
+
+SbxVariable*
+SbObjModule::GetObject() 
+{
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    //OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+        pVar = pDocObject->Find( rName, t );
+    if ( !pVar )
+        pVar = SbModule::Find( rName, t );
+    return pVar;
+}
+
+typedef ::cppu::WeakImplHelper1< awt::XTopWindowListener > EventListener_BASE;
+
+class FormObjEventListenerImpl : public EventListener_BASE
+{
+    SbUserFormModule* mpUserForm;
+    uno::Reference< lang::XComponent > mxComponent;
+    bool mbDisposed;
+    sal_Bool mbOpened;
+    sal_Bool mbActivated;
+    sal_Bool mbShowing;
+    FormObjEventListenerImpl(); // not defined
+    FormObjEventListenerImpl(const FormObjEventListenerImpl&); // not defined
+public:
+    FormObjEventListenerImpl( SbUserFormModule* pUserForm, const uno::Reference< lang::XComponent >& xComponent ) : mpUserForm( pUserForm ), mxComponent( xComponent) , mbDisposed( false ), mbOpened( sal_False ), mbActivated( sal_False ), mbShowing( sal_False )
+    {
+        if ( mxComponent.is() );
+        {
+	    uno::Reference< awt::XTopWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+            //uno::Reference< awt::XWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+            OSL_TRACE("*********** Registering the listener");
+            xList->addTopWindowListener( this );
+        }
+    }
+
+    ~FormObjEventListenerImpl()
+    {
+        removeListener();
+    }
+    sal_Bool isShowing() { return mbShowing; }
+    void removeListener()
+    {
+        try
+        {
+            if ( mxComponent.is() && !mbDisposed )
+            {
+                uno::Reference< awt::XTopWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+                OSL_TRACE("*********** Removing the listener");
+            	xList->removeTopWindowListener( this );
+                mxComponent = NULL;
+            }
+        }
+        catch( uno::Exception& ) {}
+    } 
+    virtual void SAL_CALL windowOpened( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+        {
+            mbOpened = sal_True;
+            mbShowing = sal_True;
+            if ( mbActivated )
+            {
+                mbOpened = mbActivated = sal_False;
+                mpUserForm->triggerActivateEvent();
+            }
+        }
+    }
+	
+    //liuchen 2009-7-21, support Excel VBA Form_QueryClose event
+    virtual void SAL_CALL windowClosing( const lang::EventObject& e ) throw (uno::RuntimeException)
+    {    
+		uno::Reference< awt::XDialog > xDialog( e.Source, uno::UNO_QUERY );
+		if ( xDialog.is() )
+		{
+			uno::Reference< awt::XControl > xControl( xDialog, uno::UNO_QUERY );
+			if ( xControl->getPeer().is() )
+			{
+				uno::Reference< document::XVbaMethodParameter > xVbaMethodParameter( xControl->getPeer(), uno::UNO_QUERY );
+				if ( xVbaMethodParameter.is() )
+				{	
+					sal_Int8 nCancel = 0;
+					sal_Int8 nCloseMode = 0;
+
+					Sequence< Any > aParams;
+					aParams.realloc(2);
+					aParams[0] <<= nCancel;
+					aParams[1] <<= nCloseMode;
+
+					mpUserForm->triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ),
+												aParams);
+					xVbaMethodParameter->setVbaMethodParameter( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Cancel")), aParams[0]);
+					return;
+	
+				}			
+			}		
+		}
+    	
+    	mpUserForm->triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ) );
+    }
+	//liuchen 2009-7-21
+	
+    virtual void SAL_CALL windowClosed( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException) { mbOpened = sal_False; mbShowing = sal_False; }
+    virtual void SAL_CALL windowMinimized( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException) {}
+    virtual void SAL_CALL windowNormalized( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException){}
+    virtual void SAL_CALL windowActivated( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+        {
+            mbActivated = sal_True;
+            if ( mbOpened )
+            {
+                mbOpened = mbActivated = sal_False;
+                mpUserForm->triggerActivateEvent();
+            }
+        }
+    }
+   
+    virtual void SAL_CALL windowDeactivated( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+            mpUserForm->triggerDeActivateEvent();
+    }
+
+
+    virtual void SAL_CALL disposing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+    {
+        OSL_TRACE("** Userform/Dialog disposing");
+        mbDisposed = true;
+        uno::Any aSource;
+        aSource <<= Source;   
+        mxComponent = NULL;
+        if ( mpUserForm )
+            mpUserForm->ResetApiObj();
+    }
+};
+
+SbUserFormModule::SbUserFormModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsCompat )
+    :SbObjModule( mInfo, bIsCompat ), mbInit( false )
+{
+        m_xModel.set( mInfo.ModuleObject, uno::UNO_QUERY_THROW );
+}
+
+void SbUserFormModule::ResetApiObj()
+{
+        if (  m_xDialog.is() ) // probably someone close the dialog window
+	{
+            triggerTerminateEvent();
+        }
+        pDocObject = NULL;
+	m_xDialog = NULL;
+}
+
+void SbUserFormModule::triggerMethod( const String& aMethodToRun )
+{
+	Sequence< Any > aArguments;
+	triggerMethod( aMethodToRun, aArguments );
+}
+void SbUserFormModule::triggerMethod( const String& aMethodToRun, Sequence< Any >& aArguments)
+{
+	OSL_TRACE("*** trigger %s ***", rtl::OUStringToOString( aMethodToRun, RTL_TEXTENCODING_UTF8 ).getStr() );
+	// Search method
+	SbxVariable* pMeth = SbObjModule::Find( aMethodToRun, SbxCLASS_METHOD );
+	if( pMeth )
+	{		
+                 //liuchen 2009-7-21, support Excel VBA UserForm_QueryClose event with parameters
+		if ( aArguments.getLength() > 0 )   // Setup parameters
+		{
+			SbxArrayRef xArray = new SbxArray;
+			xArray->Put( pMeth, 0 );	// Method as parameter 0
+
+			for ( sal_Int32 i = 0; i < aArguments.getLength(); ++i )
+			{
+				SbxVariableRef xSbxVar = new SbxVariable( SbxVARIANT );
+                unoToSbxValue( static_cast< SbxVariable* >( xSbxVar ), aArguments[i] );
+                xArray->Put( xSbxVar, static_cast< USHORT >( i ) + 1 );
+
+				// Enable passing by ref
+				if ( xSbxVar->GetType() != SbxVARIANT )
+					xSbxVar->SetFlag( SBX_FIXED );
+			}
+			pMeth->SetParameters( xArray );
+
+			SbxValues aVals;
+			pMeth->Get( aVals );
+			
+			for ( sal_Int32 i = 0; i < aArguments.getLength(); ++i )
+			{
+				aArguments[i] = sbxToUnoValue( xArray->Get( static_cast< USHORT >(i) + 1) );
+			}		
+			pMeth->SetParameters( NULL );
+		}
+		else
+//liuchen 2009-7-21
+		{
+			SbxValues aVals;
+			pMeth->Get( aVals );
+		}
+	}
+}
+
+void SbUserFormModule::triggerActivateEvent( void )
+{
+        OSL_TRACE("**** entering SbUserFormModule::triggerActivate");
+	triggerMethod( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm_activate") ) );
+        OSL_TRACE("**** leaving SbUserFormModule::triggerActivate");
+}
+
+void SbUserFormModule::triggerDeActivateEvent( void )
+{
+        OSL_TRACE("**** SbUserFormModule::triggerDeActivate");
+	triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_DeActivate") ) );
+}
+
+void SbUserFormModule::triggerInitializeEvent( void )
+
+{
+	if ( mbInit )
+		return;
+        OSL_TRACE("**** SbUserFormModule::triggerInitializeEvent");
+	static String aInitMethodName( RTL_CONSTASCII_USTRINGPARAM("Userform_Initialize") );
+	triggerMethod( aInitMethodName );
+	mbInit = true;
+}
+
+void SbUserFormModule::triggerTerminateEvent( void )
+{
+        OSL_TRACE("**** SbUserFormModule::triggerTerminateEvent");
+	static String aTermMethodName( RTL_CONSTASCII_USTRINGPARAM("Userform_Terminate") );
+	triggerMethod( aTermMethodName );
+	mbInit=false;
+}
+
+void SbUserFormModule::load()
+{
+    OSL_TRACE("** load() ");
+    // forces a load
+    if ( !pDocObject )
+        InitObject();
+}
+
+//liuchen 2009-7-21 change to accmordate VBA's beheavior
+void SbUserFormModule::Unload()
+{
+    OSL_TRACE("** Unload() ");
+
+	sal_Int8 nCancel = 0;
+	sal_Int8 nCloseMode = 1;
+
+	Sequence< Any > aParams;
+	aParams.realloc(2);
+	aParams[0] <<= nCancel;
+	aParams[1] <<= nCloseMode;
+
+	triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ), aParams);
+
+	aParams[0] >>= nCancel;
+	if (nCancel == 1)
+	{
+		return;
+	}
+	
+    if ( m_xDialog.is() )
+    {
+		triggerTerminateEvent();
+    }
+	// Search method
+	SbxVariable* pMeth = SbObjModule::Find( String( RTL_CONSTASCII_USTRINGPARAM( "UnloadObject" ) ), SbxCLASS_METHOD );
+	if( pMeth )
+	{
+		OSL_TRACE("Attempting too run the UnloadObjectMethod");
+                m_xDialog = NULL; //release ref to the uno object
+		SbxValues aVals;
+               FormObjEventListenerImpl* pFormListener = dynamic_cast< FormObjEventListenerImpl* >( m_DialogListener.get() );
+		bool bWaitForDispose = true; // assume dialog is showing
+                if ( pFormListener ) 
+		{
+			bWaitForDispose = pFormListener->isShowing();
+			OSL_TRACE("Showing %d", bWaitForDispose );
+		}
+		pMeth->Get( aVals);
+                if ( !bWaitForDispose )
+                {
+                    // we've either already got a dispose or we'er never going to get one 
+		    ResetApiObj();
+                } // else wait for dispose
+		OSL_TRACE("UnloadObject completed ( we hope )");
+	}
+}
+//liuchen
+
+void SbUserFormModule::InitObject()
+{
+    try
+    {
+
+        String aHook( RTL_CONSTASCII_USTRINGPARAM( "VBAGlobals" ) );
+        SbUnoObject* pGlobs = (SbUnoObject*)GetParent()->Find( aHook, SbxCLASS_DONTCARE ); 
+        if ( m_xModel.is() && pGlobs )
+        {
+            
+            uno::Reference< lang::XMultiServiceFactory > xVBAFactory( pGlobs->getUnoAny(), uno::UNO_QUERY_THROW );
+            uno::Reference< lang::XMultiServiceFactory > xFactory = comphelper::getProcessServiceFactory();
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[ 0 ] <<= m_xModel;
+            rtl::OUString sDialogUrl( RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.script:" ) );
+            rtl::OUString sProjectName( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+            if ( this->GetParent()->GetName().Len() )
+                sProjectName = this->GetParent()->GetName(); 
+            sDialogUrl = sDialogUrl.concat( sProjectName ).concat( rtl::OUString( '.') ).concat( GetName() ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("?location=document") ) ); 
+
+            uno::Reference< awt::XDialogProvider > xProvider( xFactory->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.DialogProvider")), aArgs  ), uno::UNO_QUERY_THROW );
+            m_xDialog = xProvider->createDialog( sDialogUrl );
+
+            // create vba api object
+            aArgs.realloc( 3 );
+            aArgs[ 0 ] = uno::Any();
+            aArgs[ 1 ] <<= m_xDialog;
+            aArgs[ 2 ] <<= m_xModel;
+            pDocObject = new SbUnoObject( GetName(), uno::makeAny( xVBAFactory->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.UserForm")), aArgs  ) ) );
+            uno::Reference< lang::XComponent > xComponent( aArgs[ 1 ], uno::UNO_QUERY_THROW );
+            // remove old listener if it exists
+            FormObjEventListenerImpl* pFormListener = dynamic_cast< FormObjEventListenerImpl* >( m_DialogListener.get() );
+            if ( pFormListener )
+                pFormListener->removeListener();
+            m_DialogListener = new FormObjEventListenerImpl( this, xComponent );
+
+            triggerInitializeEvent();
+        } 
+    }
+    catch( uno::Exception& e )
+    {
+    }
+
+}
+
+SbxVariable*
+SbUserFormModule::Find( const XubString& rName, SbxClassType t )
+{
+    if ( !pDocObject && !GetSbData()->bRunInit && pINST )
+        InitObject();
+    return SbObjModule::Find( rName, t );
+}
+/////////////////////////////////////////////////////////////////////////
 
 SbProperty::SbProperty( const String& r, SbxDataType t, SbModule* p )
         : SbxProperty( r, t ), pMod( p )
--- basic/source/comp/codegen.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/comp/codegen.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -130,12 +130,12 @@ void SbiCodeGen::Save()
     // OPTION EXPLICIT-Flag uebernehmen
     if( pParser->bExplicit )
         p->SetFlag( SBIMG_EXPLICIT );
-    if( pParser->IsVBASupportOn() )
-        p->SetFlag( SBIMG_VBASUPPORT );
     
     int nIfaceCount = 0;
-    if( pParser->bClassModule )
+	if( rMod.mnType == com::sun::star::script::ModuleType::Class )
     {
+                OSL_TRACE("COdeGen::save() classmodule processing");
+		rMod.bIsProxyModule = true;
         p->SetFlag( SBIMG_CLASSMODULE );
         pCLASSFAC->AddClassModule( &rMod );
 
@@ -158,6 +158,10 @@ void SbiCodeGen::Save()
     else
     {
         pCLASSFAC->RemoveClassModule( &rMod );
+		// Only a ClassModule can revert to Normal
+                if ( rMod.mnType == com::sun::star::script::ModuleType::Class )
+			rMod.mnType = com::sun::star::script::ModuleType::Normal;
+		rMod.bIsProxyModule = false;
     }
     if( pParser->bText )
         p->SetFlag( SBIMG_COMPARETEXT );
@@ -240,6 +244,8 @@ void SbiCodeGen::Save()
                     if( nPass == 1 )
                         aPropName = aPropName.Copy( aIfaceName.Len() + 1 );
                     SbProcedureProperty* pProcedureProperty = NULL;
+                                        OSL_TRACE("*** getProcedureProperty for thing %s",
+						rtl::OUStringToOString( aPropName,RTL_TEXTENCODING_UTF8 ).getStr() );
                     pProcedureProperty = rMod.GetProcedureProperty( aPropName, ePropType );
                 }
                 if( nPass == 1 )
--- basic/source/comp/dim.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/comp/dim.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -32,6 +32,8 @@
 #include "precompiled_basic.hxx"
 #include <basic/sbx.hxx>
 #include "sbcomp.hxx"
+#include "sbunoobj.hxx"
+
 
 // Deklaration einer Variablen
 // Bei Fehlern wird bis zum Komma oder Newline geparst.
@@ -40,7 +42,10 @@
 
 SbiSymDef* SbiParser::VarDecl( SbiDimList** ppDim, BOOL bStatic, BOOL bConst )
 {
-    if( !TestSymbol() ) return NULL;
+	// Some keywords can be dim as varibles like " Sub Test( Name as String )"
+	eCurTok = Peek();
+	BOOL bKwdOk = IsVBASupportOn() ? BOOL( (eCurTok == NAME) || (eCurTok == LINE) || (eCurTok == TEXT) ): FALSE;
+	if( !TestSymbol( bKwdOk ) ) return NULL;
     SbxDataType t = eScanType;
     SbiSymDef* pDef = bConst ? new SbiConstDef( aSym ) : new SbiSymDef( aSym );
     SbiDimList* pDim = NULL;
@@ -144,7 +149,7 @@ void SbiParser::TypeDecl( SbiSymDef& rDe
                             }
                         }
                     }
-                    else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) )
+					else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) || ( IsVBASupportOn() && VBAConstantHelper::instance().isVBAConstantType( aCompleteName ) ) )
                     {
                         eType = SbxLONG;
                         break;
@@ -222,6 +227,12 @@ void SbiParser::DefVar( SbiOpcode eOp, B
             Next();
             DefStatic( bPrivate );
         }
+		else if( eCurTok == DECLARE )
+                {
+			Next();
+                        DefDeclare( bPrivate ); 
+                        return;
+                }
         else if( eCurTok == SUB || eCurTok == FUNCTION || eCurTok == PROPERTY )
         {
             // End global chain if necessary (not done in 
@@ -241,12 +252,12 @@ void SbiParser::DefVar( SbiOpcode eOp, B
             DefEnum( bPrivate );
             return;
         }
-        else if( eCurTok == DECLARE )
-        {
-            Next();
-            DefDeclare( bPrivate ); 
-            return;
-        }
+		else if( eCurTok == DECLARE )
+		{
+			Next();
+			DefDeclare( bPrivate ); 
+			return;
+		}
     }
 
 #ifdef SHARED
@@ -401,7 +412,10 @@ void SbiParser::DefVar( SbiOpcode eOp, B
                 aExpr.Gen();
                 SbiOpcode eOp_ = pDef->IsNew() ? _CREATE : _TCREATE;
                 aGen.Gen( eOp_, pDef->GetId(), pDef->GetTypeId() );
-                aGen.Gen( _SET );
+				if ( bVBASupportOn )
+					aGen.Gen( _VBASET );
+				else	
+					aGen.Gen( _SET );
             }
         }
         else
@@ -585,42 +599,42 @@ void SbiParser::DefType( BOOL bPrivate )
             else
             {
                 SbxProperty *pTypeElem = new SbxProperty (pElem->GetName(),pElem->GetType());
-                if( pDim )
-                {
-                    SbxDimArray* pArray = new SbxDimArray( pElem->GetType() );	
-                    if ( pDim->GetSize() )
-                    {
-                        // Dimension the target array
-
-                        for ( short i=0; i<pDim->GetSize();++i )
-                        {
-                            INT32 ub = -1;
-                            INT32 lb = nBase;
-                            SbiExprNode* pNode =  pDim->Get(i)->GetExprNode();
-                            ub = pNode->GetNumber();
-                            if ( !pDim->Get( i )->IsBased() ) // each dim is low/up
-                            {
-                                if (  ++i >= pDim->GetSize() ) // trouble
-                                    StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
-                                pNode =  pDim->Get(i)->GetExprNode();
-                                lb = ub;
-                                ub = pNode->GetNumber();
-                            }
-                            else if ( !bCompatible )
-                                ub += nBase;
-                            pArray->AddDim32( lb, ub );      
-                        }
-                        pArray->setHasFixedSize( true );
-                    }
-                    else
-                        pArray->unoAddDim( 0, -1 ); // variant array
-                    USHORT nSavFlags = pTypeElem->GetFlags();
-                    // need to reset the FIXED flag 
-                    // when calling PutObject ( because the type will not match Object ) 	
-                    pTypeElem->ResetFlag( SBX_FIXED );
-                    pTypeElem->PutObject( pArray );
-                    pTypeElem->SetFlags( nSavFlags );
-                }
+				if( pDim )
+				{
+					SbxDimArray* pArray = new SbxDimArray( pElem->GetType() );	
+					if ( pDim->GetSize() )
+					{
+						// Dimension the target array
+
+						for ( short i=0; i<pDim->GetSize();++i )
+						{
+							INT32 ub = -1;
+							INT32 lb = nBase;
+							SbiExprNode* pNode =  pDim->Get(i)->GetExprNode();
+							ub = pNode->GetNumber();
+							if ( !pDim->Get( i )->IsBased() ) // each dim is low/up
+							{
+								if (  ++i >= pDim->GetSize() ) // trouble
+									StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+								pNode =  pDim->Get(i)->GetExprNode();
+								lb = ub;
+								ub = pNode->GetNumber();
+							}
+							else if ( !bCompatible )
+								ub += nBase;
+							pArray->AddDim32( lb, ub );      
+						}
+						pArray->setHasFixedSize( true );
+					}
+					else
+						pArray->unoAddDim( 0, -1 ); // variant array
+					USHORT nSavFlags = pTypeElem->GetFlags();
+					// need to reset the FIXED flag 
+					// when calling PutObject ( because the type will not match Object ) 	
+					pTypeElem->ResetFlag( SBX_FIXED );
+					pTypeElem->PutObject( pArray );
+					pTypeElem->SetFlags( nSavFlags );
+				}
                 delete pDim;
                 pTypeMembers->Insert( pTypeElem, pTypeMembers->Count() );
             }
@@ -778,7 +792,7 @@ void SbiParser::DefEnum( BOOL bPrivate )
 SbiProcDef* SbiParser::ProcDecl( BOOL bDecl )
 {
     BOOL bFunc = BOOL( eCurTok == FUNCTION );
-    BOOL bProp = BOOL( eCurTok == GET || eCurTok == SET || eCurTok == LET );
+	BOOL bProp = BOOL( eCurTok == GET || eCurTok == SET || eCurTok == LET );
     if( !TestSymbol() ) return NULL;
     String aName( aSym );
     SbxDataType eType = eScanType;
@@ -899,7 +913,7 @@ SbiProcDef* SbiParser::ProcDecl( BOOL bD
 //	if( pDef->GetType() == SbxOBJECT )
 //		pDef->SetType( SbxVARIANT ),
 //		Error( SbERR_SYNTAX );
-    if( pDef->GetType() == SbxVARIANT && !( bFunc || bProp ) )
+	if( pDef->GetType() == SbxVARIANT && !( bFunc || bProp ) )
         pDef->SetType( SbxEMPTY );
     return pDef;
 }
@@ -908,11 +922,11 @@ SbiProcDef* SbiParser::ProcDecl( BOOL bD
 
 void SbiParser::Declare()
 {
-    DefDeclare( FALSE );
-}
-
-void SbiParser::DefDeclare( BOOL bPrivate )
-{
+	DefDeclare( FALSE );
+}
+
+void SbiParser::DefDeclare( BOOL bPrivate )
+{
     Next();
     if( eCurTok != SUB && eCurTok != FUNCTION )
       Error( SbERR_UNEXPECTED, eCurTok );
@@ -941,12 +955,30 @@ void SbiParser::DefDeclare( BOOL bPrivat
             else
                 aPublics.Add( pDef );
 
-            if ( pDef )
-                pDef->SetPublic( !bPrivate );
+			if ( pDef )
+				pDef->SetPublic( !bPrivate );
         }
     }
 }
 
+void SbiParser::Attribute()
+{
+	// TODO: Need to implement the method as an attributed object.
+	while( Next() != EQ )
+	{
+		String aSym( GetSym() );
+		if( Next() != DOT) 
+			break;
+	}
+	
+	if( eCurTok != EQ )
+		Error( SbERR_SYNTAX );
+	else
+		SbiExpression aValue( this );
+
+	// Don't generate any code - just discard it.
+}
+
 // Aufruf einer SUB oder FUNCTION
 
 void SbiParser::Call()
--- basic/source/comp/exprtree.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/comp/exprtree.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -378,8 +378,12 @@ SbiExprNode* SbiExpression::Term( void )
         // Typ SbxOBJECT sein
         if( pDef->GetType() != SbxOBJECT && pDef->GetType() != SbxVARIANT )
         {
-            pParser->Error( SbERR_BAD_DECLARATION, aSym );
-            bError = TRUE;
+			// defer error until runtime if in vba mode
+			if ( !pParser->IsVBASupportOn() )
+                        {
+				pParser->Error( SbERR_BAD_DECLARATION, aSym );
+				bError = TRUE;
+			}
         }
         if( !bError )
             pNd->aVar.pNext = ObjTerm( *pDef );
@@ -570,7 +574,11 @@ SbiExprNode* SbiExpression::Unary()
             eTok = NEG;
         case NOT:
             pParser->Next();
-            pNd = new SbiExprNode( pParser, Unary(), eTok, NULL );
+            // process something like "Do While Not "foo"="" "
+            if( pParser->IsVBASupportOn() )
+                pNd = new SbiExprNode( pParser, Like(), eTok, NULL );
+            else    
+                pNd = new SbiExprNode( pParser, Unary(), eTok, NULL );
             break;
         case PLUS:
             pParser->Next();
@@ -716,7 +724,7 @@ SbiExprNode* SbiExpression::Like()
             pNd = new SbiExprNode( pParser, pNd, eTok, Comp() ), nCount++;
         }
         // Mehrere Operatoren hintereinander gehen nicht
-        if( nCount > 1 )
+		if( nCount > 1 && !pParser->IsVBASupportOn() )
         {
             pParser->Error( SbERR_SYNTAX );
             bError = TRUE;
--- basic/source/comp/parser.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/comp/parser.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -51,6 +51,7 @@ struct SbiStatement {
 #define	N	FALSE
 
 static SbiStatement StmntTable [] = {
+{ ATTRIBUTE, &SbiParser::Attribute, Y, Y, }, // ATTRIBUTE
 { CALL,		&SbiParser::Call,   	N, Y, }, // CALL
 { CLOSE,	&SbiParser::Close,		N, Y, }, // CLOSE
 { _CONST_,	&SbiParser::Dim, 		Y, Y, }, // CONST
@@ -137,13 +138,15 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
     pProc    = NULL;
     pStack   = NULL;
     pWithVar = NULL;
+	pCurStat = NULL;
     nBase	 = 0;
     bText	 =
     bGblDefs =
     bNewGblDefs =
     bSingleLineIf =
     bExplicit = FALSE;
-    bClassModule = FALSE;
+	bClassModule = ( pm->GetModuleType() == com::sun::star::script::ModuleType::Class );
+	OSL_TRACE("Parser - %s, bClassModule %d", rtl::OUStringToOString( pm->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), bClassModule );
     pPool	 = &aPublics;
     for( short i = 0; i < 26; i++ )
         eDefTypes[ i ] = SbxVARIANT;    // Kein expliziter Defaulttyp
@@ -156,6 +159,10 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 
     rTypeArray = new SbxArray; // Array fuer Benutzerdefinierte Typen
     rEnumArray = new SbxArray; // Array for Enum types
+	bVBASupportOn = pm->IsVBACompat();
+	if ( bVBASupportOn )
+		EnableCompatibility();
+
 }
 
 
@@ -302,6 +309,26 @@ void SbiParser::TestEoln()
     }
 }
 
+// If some keywords e.g. Name have been dim as a variable, 
+// they should be treated as symbol
+BOOL SbiParser::IsSymbol( SbiToken t )
+{
+	// FIXME: if "name" is a argument in a subroutine like "Sub Test( name as String )".
+	if( IsVBASupportOn() && ( t == NAME || t == LINE || t == TEXT ))
+	{
+		if( pCurStat && ( pCurStat->eTok == DIM || pCurStat->eTok == PUBLIC ||
+		  pCurStat->eTok == PRIVATE || pCurStat->eTok == GLOBAL	))
+		{
+			return TRUE;
+		}
+    	if( pPool->Find(aSym) )
+    	{
+        	return TRUE;
+    	}
+	}	
+    return FALSE;
+}
+
 // Parsing eines Statement-Blocks
 // Das Parsing laeuft bis zum Ende-Token.
 
@@ -378,6 +405,18 @@ BOOL SbiParser::Parse()
         Next(); return TRUE;
     }
 
+        // In vba it's possible to do Error.foobar ( even if it results in
+	// a runtime error
+        if ( eCurTok == _ERROR_ && IsVBASupportOn() ) // we probably need to define a subset of keywords where this madness applies e.g. if ( IsVBASupportOn() && SymbolCanBeRedined( eCurTok ) )
+        {
+            SbiTokenizer tokens( *(SbiTokenizer*)this );
+            tokens.Next();
+            if ( tokens.Peek()  == DOT )
+            {
+                eCurTok = SYMBOL;
+		ePush = eCurTok;
+            }
+	}
     // Kommt ein Symbol, ist es entweder eine Variable( LET )
     // oder eine SUB-Prozedur( CALL ohne Klammern )
     // DOT fuer Zuweisungen im WITH-Block: .A=5
@@ -425,7 +464,9 @@ BOOL SbiParser::Parse()
                 if( ( p->bSubr && (eCurTok != STATIC || Peek() == SUB || Peek() == FUNCTION ) ) ||
                         eCurTok == SUB || eCurTok == FUNCTION )
                     aGen.Statement();
+				pCurStat = p;	
                 (this->*( p->Func ) )();
+				pCurStat = NULL;
                 SbxError nSbxErr = SbxBase::GetError();
                 if( nSbxErr )
                     SbxBase::ResetError(), Error( (SbError)nSbxErr );
@@ -754,8 +795,9 @@ void SbiParser::Option()
 
         case CLASSMODULE:
             bClassModule = TRUE; 
+			aGen.GetModule().SetModuleType( com::sun::star::script::ModuleType::Class );
             break;
-        case VBASUPPORT:
+		case VBASUPPORT: // Option VBASupport used to override the module mode ( in fact this must reset the mode
             if( Next() == NUMBER )
             {
                 if ( nVal == 1 || nVal == 0 )
@@ -763,6 +805,10 @@ void SbiParser::Option()
                     bVBASupportOn = ( nVal == 1 );
                     if ( bVBASupportOn )
                         EnableCompatibility();
+					// if the module setting is different
+					// reset it to what the Option tells us
+					if ( bVBASupportOn != aGen.GetModule().IsVBACompat() )
+						aGen.GetModule().SetVBACompat( bVBASupportOn );
                     break;
                 }
             }
--- basic/source/comp/sbcomp.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/comp/sbcomp.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -134,6 +134,7 @@ BOOL SbModule::Compile()
     if( bRet )
     {
         pBasic->ClearAllModuleVars();
+		RemoveVars(); // remove 'this' Modules variables
         // clear all method statics
         for( USHORT i = 0; i < pMethods->Count(); i++ )
         {
--- basic/source/comp/token.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/comp/token.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -61,6 +61,7 @@ static TokenTable aTokTable_Basic [] = {
     { ANY,		"Any" },
     { APPEND,	"Append" },
     { AS,		"As" },
+	{ ATTRIBUTE,"Attribute" },
     { BASE,		"Base" },
     { BINARY,	"Binary" },
     { TBOOLEAN,	"Boolean" },
@@ -593,6 +594,13 @@ special:
         }
         return eCurTok;
     }
+
+	// check whether the keyword has been dim as a variable
+	if( IsSymbol( tp->t ) )
+	{
+		return eCurTok = SYMBOL;
+	}
+	
     // Sind Datentypen Keywords?
     // Nur nach AS, sonst sind es Symbole!
     // Es gibt ja ERROR(), DATA(), STRING() etc.
--- basic/source/inc/codegen.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/codegen.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -56,6 +56,7 @@ public:
     void GenStmnt();			// evtl. Statement-Opcode erzeugen
     UINT32 GetPC();
     UINT32 GetOffset()				{ return GetPC() + 1; }
+    SbModule& GetModule() { return rMod; } 
     void Save();
 
     // #29955 for-Schleifen-Ebene pflegen
--- basic/source/inc/dlgcont.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/dlgcont.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -96,7 +96,9 @@ public:
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Service
     static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static();
     static ::rtl::OUString getImplementationName_static();
--- basic/source/inc/errobject.hxx.old	2010-03-03 16:59:34.000000000 +0100
+++ basic/source/inc/errobject.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,16 @@
+#ifndef ERROBJECT_HXX
+#define ERROBJECT_HXX
+#include "sbunoobj.hxx"
+#include <ooo/vba/XErrObject.hpp>
+
+
+class SbxErrObject : public SbUnoObject
+{
+	com::sun::star::uno::Reference< ooo::vba::XErrObject > m_xErr;
+	SbxErrObject( const String& aName_, const com::sun::star::uno::Any& aUnoObj_ );
+	~SbxErrObject();
+public:
+	static SbxVariableRef getErrObject();
+	static com::sun::star::uno::Reference< ooo::vba::XErrObject > getUnoErrObject();
+};
+#endif
--- basic/source/inc/image.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/image.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -109,6 +109,5 @@ public:
 #define	SBIMG_COMPARETEXT	0x0002	// OPTION COMPARE TEXT ist aktiv
 #define	SBIMG_INITCODE		0x0004	// Init-Code vorhanden
 #define	SBIMG_CLASSMODULE	0x0008	// OPTION ClassModule is active
-#define	SBIMG_VBASUPPORT	0x0020	// OPTION VBASupport is 1
 
 #endif
--- basic/source/inc/namecont.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/namecont.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -38,6 +38,7 @@
 #include <com/sun/star/script/XStorageBasedLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/script/XLibraryContainerExport.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/container/XContainer.hpp>
 #include <com/sun/star/ucb/XSimpleFileAccess.hpp>
@@ -61,19 +62,24 @@
 
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/compbase6.hxx>
+#include <cppuhelper/compbase7.hxx>
+#include <cppuhelper/compbase8.hxx>
 #include <cppuhelper/interfacecontainer.hxx>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 class BasicManager;
 
 namespace basic
 {
 
-typedef ::cppu::WeakComponentImplHelper6< 
+typedef ::cppu::WeakComponentImplHelper8< 
     ::com::sun::star::lang::XInitialization,
     ::com::sun::star::script::XStorageBasedLibraryContainer,
     ::com::sun::star::script::XLibraryContainerPassword,
     ::com::sun::star::script::XLibraryContainerExport,
     ::com::sun::star::container::XContainer,
+    ::com::sun::star::script::XLibraryQueryExecutable,
+	::com::sun::star::script::XVBACompat,
     ::com::sun::star::lang::XServiceInfo > LibraryContainerHelper;
 
 typedef ::cppu::WeakImplHelper2< ::com::sun::star::container::XNameContainer,
@@ -496,6 +502,10 @@ public:
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException) = 0;
+
+	// Methods XVBACompat
+	virtual ::sal_Bool SAL_CALL getVBACompatModeOn() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 class LibraryContainerMethodGuard
--- basic/source/inc/parser.hxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/inc/parser.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -40,6 +40,7 @@
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
+struct SbiStatement;
 
 class SbiParser : public SbiTokenizer
 {
@@ -53,6 +54,7 @@ class SbiParser : public SbiTokenizer
     BOOL		bGblDefs; 			// TRUE globale Definitionen allgemein
     BOOL		bNewGblDefs; 		// TRUE globale Definitionen vor Sub
     BOOL		bSingleLineIf; 		// TRUE einzeiliges if-Statement
+	SbiStatement* pCurStat;
 
     SbiSymDef*  VarDecl( SbiDimList**,BOOL,BOOL );// Variablen-Deklaration
     SbiProcDef* ProcDecl(BOOL bDecl);// Prozedur-Deklaration
@@ -66,7 +68,7 @@ class SbiParser : public SbiTokenizer
     void StmntBlock( SbiToken ); 	// Statement-Block abarbeiten
     void DefType( BOOL bPrivate );	// Parse type declaration
     void DefEnum( BOOL bPrivate );	// Parse enum declaration
-    void DefDeclare( BOOL bPrivate );
+	void DefDeclare( BOOL bPrivate );
     void EnableCompatibility();	
 public:
     SbxArrayRef	  rTypeArray;		// das Type-Array
@@ -101,6 +103,7 @@ public:
     BOOL TestSymbol( BOOL=FALSE );	// Symbol?
     BOOL TestComma();				// Komma oder EOLN?
     void TestEoln();				// EOLN?
+	virtual BOOL IsSymbol( SbiToken t ); // Process something like DIM Name as String
 
     void Symbol();					// Let oder Call
     void ErrorStmnt(); 				// ERROR n
@@ -109,6 +112,7 @@ public:
     void BadSyntax();				// Falsches SbiToken
     void NoIf();					// ELSE/ELSE IF ohne IF
     void Assign();					// LET
+	void Attribute();				// Attribute
     void Call();					// CALL
     void Close();					// CLOSE
     void Declare();					// DECLARE
--- basic/source/inc/runtime.hxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/inc/runtime.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -206,7 +206,6 @@ class SbiInstance
     BOOL			bCompatibility; // Flag: TRUE = VBA runtime compatibility mode
 
     ComponentVector_t ComponentVector;
-
 public:
     SbiRuntime*  pRun;        		// Call-Stack
     SbiInstance* pNext;             // Instanzen-Chain
@@ -293,7 +292,9 @@ class SbiRuntime
     SbxArrayRef   refExprStk;       // expression stack
     SbxArrayRef   refCaseStk;       // CASE expression stack
     SbxArrayRef   refRedimpArray;   // Array saved to use for REDIM PRESERVE
+	SbxVariableRef   refRedim;   // Array saved to use for REDIM
     SbxVariableRef xDummyVar;		// Ersatz fuer nicht gefundene Variablen
+	SbxVariable* mpExtCaller;		// Caller ( external - e.g. button name, shape, range object etc. - only in vba mode )
     SbiArgvStack*  pArgvStk;		// ARGV-Stack
     SbiGosubStack* pGosubStk;		// GOSUB stack
     SbiForStack*   pForStk;			// FOR/NEXT-Stack
@@ -436,7 +437,7 @@ class SbiRuntime
     void StepFIND_CM( UINT32, UINT32 );
     void StepFIND_STATIC( UINT32, UINT32 );
 public:
-    void          SetVBAEnabled( bool bEnabled ) { bVBAEnabled = bEnabled; };
+	void          SetVBAEnabled( bool bEnabled );           
     USHORT		GetImageFlag( USHORT n ) const;
     USHORT		GetBase();
     xub_StrLen  nLine,nCol1,nCol2;	// aktuelle Zeile, Spaltenbereich
@@ -461,6 +462,7 @@ public:
     SbMethod* GetCaller();
     SbxArray* GetLocals();
     SbxArray* GetParams();
+	SbxVariable* GetExternalCaller(){ return mpExtCaller; }
 
     SbxBase* FindElementExtern( const String& rName );
     static bool isVBAEnabled();
--- basic/source/inc/sbunoobj.hxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/inc/sbunoobj.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -45,6 +45,7 @@
 #include <com/sun/star/reflection/XIdlClass.hpp>
 #include <com/sun/star/reflection/XServiceTypeDescription2.hpp> 
 #include <rtl/ustring.hxx>
+#include <hash_map>
 
 class SbUnoObject: public SbxObject
 {
@@ -305,6 +306,26 @@ public:
     virtual void Clear();
 };
 
+typedef std::hash_map< ::rtl::OUString, ::com::sun::star::uno::Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
+
+typedef std::vector< rtl::OUString > VBAConstantsVector;
+
+class VBAConstantHelper
+{
+private:
+
+    VBAConstantsVector aConstCache;
+    VBAConstantsHash aConstHash;
+    bool isInited;
+    VBAConstantHelper():isInited( false ) {}
+    VBAConstantHelper(const VBAConstantHelper&);
+    void init();
+public:    
+    static VBAConstantHelper& instance(); 
+    SbxVariable* getVBAConstant( const String& rName );
+    bool isVBAConstantType( const String& rName );
+};
+
 #endif
 
 
--- basic/source/inc/scriptcont.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/scriptcont.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -120,7 +120,9 @@ public:
         throw (::com::sun::star::lang::IllegalArgumentException, 
                ::com::sun::star::container::NoSuchElementException, 
                ::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Methods XServiceInfo
     virtual ::rtl::OUString SAL_CALL getImplementationName( )
         throw (::com::sun::star::uno::RuntimeException);
--- basic/source/inc/token.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/inc/token.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -75,7 +75,7 @@ enum SbiToken {
     IF, _IN_, INPUT,
     LET, LINE, LINEINPUT, LOCAL, LOOP, LPRINT, LSET,
     NAME, NEW, NEXT,
-    ON, OPEN, OPTION, IMPLEMENTS,
+	ON, OPEN, OPTION, ATTRIBUTE, IMPLEMENTS,
     PRINT, PRIVATE, PROPERTY, PUBLIC,
     REDIM, REM, RESUME, RETURN, RSET,
     SELECT, SET, SHARED, STATIC, STEP, STOP, SUB,
@@ -162,6 +162,10 @@ public:
         { return BOOL( t >= FIRSTKWD && t <= LASTKWD ); }
     static BOOL IsExtra( SbiToken t )
         { return BOOL( t >= FIRSTEXTRA ); }
+
+    // process somthing like dim Name as String
+	virtual BOOL IsSymbol( SbiToken )
+        { return FALSE; }
 };
 
 
--- basic/source/runtime/methods.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/runtime/methods.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -51,6 +51,7 @@
 #include <unotools/ucbstreamhelper.hxx>
 #include <tools/wldcrd.hxx>
 #include <i18npool/lang.h>
+#include <rtl/string.hxx>
 
 #include "runtime.hxx"
 #include "sbunoobj.hxx"
@@ -77,13 +78,16 @@
 #include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XSeekable.hpp>
-
+#include <com/sun/star/script/XErrorQuery.hpp>
+#include <ooo/vba/XHelperInterface.hpp>
+#include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 using namespace comphelper;
 using namespace osl;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::ucb;
 using namespace com::sun::star::io;
+using namespace com::sun::star::script;
 
 #endif /* _USE_UNO */
 
@@ -105,6 +109,8 @@ using namespace com::sun::star::io;
 #include <stdlib.h>
 #include <ctype.h>
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 #if defined (WIN) || defined (WNT) || defined (OS2)
 #include <direct.h>   // _getdcwd get current work directory, _chdrive
 #endif
@@ -123,6 +129,10 @@ using namespace com::sun::star::io;
 #include <io.h>
 #endif
 
+using namespace rtl;
+
+#include <basic/sbobjmod.hxx>
+
 static void FilterWhiteSpace( String& rStr )
 {
     rStr.EraseAllChars( ' ' );
@@ -837,6 +847,15 @@ RTLFUNC(SendKeys) // JSM
     StarBASIC::Error(SbERR_NOT_IMPLEMENTED);
 }
 
+// Stub, basic already yields by default
+RTLFUNC(DoEvents)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+	rPar.Get(0)->PutInteger( 0 );
+}
+
 RTLFUNC(Exp)
 {
     (void)pBasic;
@@ -919,6 +938,26 @@ RTLFUNC(Hex)
     }
 }
 
+RTLFUNC(FuncCaller)
+{
+    (void)pBasic;
+    (void)bWrite;
+    if ( SbiRuntime::isVBAEnabled() &&  pINST && pINST->pRun )
+    {
+        if ( pINST->pRun->GetExternalCaller() )
+            *rPar.Get(0) =  *pINST->pRun->GetExternalCaller();
+        else
+        {
+            SbxVariableRef pVar = new SbxVariable(SbxVARIANT);
+            *rPar.Get(0) = *pVar;
+        }
+    }
+    else
+    {
+        StarBASIC::Error( SbERR_NOT_IMPLEMENTED );
+    }
+
+}
 // InStr( [start],string,string,[compare] )
 
 RTLFUNC(InStr)
@@ -1786,9 +1825,9 @@ INT16 implGetDateYear( double aDate )
 
 BOOL implDateSerial( INT16 nYear, INT16 nMonth, INT16 nDay, double& rdRet )
 {
-    if ( nYear < 30 && SbiRuntime::isVBAEnabled() )
+	if ( nYear < 30 && SbiRuntime::isVBAEnabled() )
         nYear += 2000;
-    else if ( nYear < 100 )
+	else if ( nYear < 100 )
         nYear += 1900;
     Date aCurDate( nDay, nMonth, nYear );
     if ((nYear < 100 || nYear > 9999) )  
@@ -2390,7 +2429,18 @@ RTLFUNC(IsEmpty)
     if ( rPar.Count() < 2 )
         StarBASIC::Error( SbERR_BAD_ARGUMENT );
     else
-        rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	{
+		SbxVariable* pVar = NULL;
+		if( SbiRuntime::isVBAEnabled() )
+			pVar = getDefaultProp( rPar.Get(1) );
+		if ( pVar )
+		{
+			pVar->Broadcast( SBX_HINT_DATAWANTED );
+			rPar.Get( 0 )->PutBool( pVar->IsEmpty() );
+		}
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	}
 }
 
 RTLFUNC(IsError)
@@ -2401,7 +2451,22 @@ RTLFUNC(IsError)
     if ( rPar.Count() < 2 )
         StarBASIC::Error( SbERR_BAD_ARGUMENT );
     else
-        rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	{
+		SbxVariable* pVar =rPar.Get( 1 );
+		SbUnoObject* pObj = PTR_CAST(SbUnoObject,pVar );
+                if ( !pObj )
+                { 
+                    if ( SbxBase* pBaseObj = pVar->GetObject() )
+                        pObj = PTR_CAST(SbUnoObject, pBaseObj );
+                }
+		Reference< XErrorQuery > xError;
+		if ( pObj )
+			xError.set( pObj->getUnoAny(), UNO_QUERY );
+		if ( xError.is() )
+			rPar.Get( 0 )->PutBool( xError->hasError() );
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	}
 }
 
 RTLFUNC(IsNull)
@@ -3606,6 +3671,65 @@ String getBasicTypeName( SbxDataType eTy
     return aRetStr;
 }
 
+String getObjectTypeName( SbxVariable* pVar )
+{
+    rtl::OUString sRet( RTL_CONSTASCII_USTRINGPARAM("Object") );
+    if ( pVar )
+    {
+        SbxBase* pObj = pVar->GetObject();
+        if( !pObj )
+           sRet = String( RTL_CONSTASCII_USTRINGPARAM("Nothing") );
+        else
+        {
+            SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,pVar );
+            if ( !pUnoObj )
+            { 
+                if ( SbxBase* pBaseObj = pVar->GetObject() )
+                    pUnoObj = PTR_CAST(SbUnoObject, pBaseObj );
+            }
+            if ( pUnoObj )
+            { 
+                Any aObj = pUnoObj->getUnoAny();
+                // For upstreaming unless we start to build oovbaapi by default
+                // we need to get detect the vba-ness of the object in some
+                // other way        
+                // note: Automation objects do not support XServiceInfo
+                Reference< XServiceInfo > xServInfo( aObj, UNO_QUERY );
+                if ( xServInfo.is() )
+                {
+                    // is this a VBA object ?
+                    Reference< ooo::vba::XHelperInterface > xVBA( aObj, UNO_QUERY );
+                    Sequence< rtl::OUString > sServices = xServInfo->getSupportedServiceNames();
+                    if ( sServices.getLength() )
+                        sRet = sServices[ 0 ];
+                }
+                else
+                {
+                    Reference< com::sun::star::bridge::oleautomation::XAutomationObject > xAutoMation( aObj, UNO_QUERY );
+                    if ( xAutoMation.is() )
+                    {
+                        Reference< XInvocation > xInv( aObj, UNO_QUERY );
+                        if ( xInv.is() )
+                        {
+                            try
+                            {
+                                xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sRet;
+                            }
+                            catch( Exception& )
+                            {
+                            }
+                        }
+                    }
+                }
+                sal_Int32 nDot = sRet.lastIndexOf( '.' );
+                if ( nDot != -1 && nDot < sRet.getLength() )
+                       sRet = sRet.copy( nDot + 1 );
+            }
+        }
+    }         
+    return sRet;
+}
+
 RTLFUNC(TypeName)
 {
     (void)pBasic;
@@ -3617,7 +3741,12 @@ RTLFUNC(TypeName)
     {
         SbxDataType eType = rPar.Get(1)->GetType();
         BOOL bIsArray = ( ( eType & SbxARRAY ) != 0 );
-        String aRetStr = getBasicTypeName( eType );
+
+        String aRetStr;
+        if ( SbiRuntime::isVBAEnabled() && eType == SbxOBJECT )
+            aRetStr = getObjectTypeName( rPar.Get(1) );
+        else
+            aRetStr = getBasicTypeName( eType );
         if( bIsArray )
             aRetStr.AppendAscii( "()" );
         rPar.Get(0)->PutString( aRetStr );
@@ -4109,7 +4238,12 @@ RTLFUNC(Load)
 
     // Diesen Call einfach an das Object weiterreichen
     SbxBase* pObj = (SbxObject*)rPar.Get(1)->GetObject();
-    if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	if( pObj && pObj->IsA( TYPE( SbUserFormModule ) ) )
+	{
+		SbUserFormModule* pFormModule = ( SbUserFormModule* )pObj;
+		pFormModule->load();
+	}
+	else if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
     {
         SbxVariable* pVar = ((SbxObject*)pObj)->
             Find( String( RTL_CONSTASCII_USTRINGPARAM("Load") ), SbxCLASS_METHOD );
@@ -4132,7 +4266,12 @@ RTLFUNC(Unload)
 
     // Diesen Call einfach an das Object weitereichen
     SbxBase* pObj = (SbxObject*)rPar.Get(1)->GetObject();
-    if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	if( pObj && pObj->IsA( TYPE( SbUserFormModule ) ) )
+	{
+		SbUserFormModule* pFormModule = ( SbUserFormModule* )pObj;
+		pFormModule->Unload();
+	}
+	else if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
     {
         SbxVariable* pVar = ((SbxObject*)pObj)->
             Find( String( RTL_CONSTASCII_USTRINGPARAM("Unload") ), SbxCLASS_METHOD );
--- basic/source/runtime/methods1.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/runtime/methods1.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -44,6 +44,7 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#include <basic/sbstar.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/fsys.hxx>
 #include <tools/urlobj.hxx>
@@ -64,6 +65,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -80,11 +82,15 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/i18n/XCalendar.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
 
 using namespace comphelper;
+using namespace com::sun::star::sheet;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::i18n;
 
+void unoToSbxValue( SbxVariable* pVar, const Any& aValue );
+Any sbxToUnoValue( SbxVariable* pVar, const Type& rType, com::sun::star::beans::Property* pUnoProperty = NULL );
 
 static Reference< XCalendar > getLocaleCalendar( void )
 {
@@ -2509,6 +2515,546 @@ RTLFUNC(Round)
     rPar.Get(0)->PutDouble( dRes );
 }
 
+void CallFunctionAccessFunction( const Sequence< Any >& aArgs, const rtl::OUString& sFuncName, SbxVariable* pRet )
+{
+    static Reference< XFunctionAccess > xFunc;
+    Any aRes;
+    try
+    {
+        if ( !xFunc.is() )
+        {
+            Reference< XMultiServiceFactory > xFactory( getProcessServiceFactory() );
+            if( xFactory.is() )
+            {
+                xFunc.set( xFactory->createInstance(::rtl::OUString::createFromAscii( "com.sun.star.sheet.FunctionAccess")), UNO_QUERY_THROW); 
+            }
+        }
+        Any aRet = xFunc->callFunction( sFuncName, aArgs );
+     
+        unoToSbxValue( pRet, aRet );
+
+    }
+    catch( Exception& )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+    }
+}
+
+RTLFUNC(SYD)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 4 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    aParams[ 3 ] <<= makeAny( rPar.Get(4)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SYD") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(SLN)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SLN") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Pmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Pmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetDouble();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    Any aValues = sbxToUnoValue( rPar.Get(2),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 1 ] <<= aValues;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPer)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double pmt = rPar.Get(2)->GetDouble();
+    double pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPer") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(MIRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("MIRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    // set default values for Optional args
+    double guess = 0.1;    
+    // guess
+    if ( nArgCount >= 2 )
+    {
+        if( rPar.Get(2)->GetType() != SbxEMPTY )
+            guess = rPar.Get(2)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetInteger();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(FV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double pv = 0;    
+    double type = 0;    
+    
+    // pv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            pv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(DDB)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double cost = rPar.Get(1)->GetDouble();
+    double salvage = rPar.Get(2)->GetDouble();
+    double life = rPar.Get(3)->GetDouble();
+    double period = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double factor = 2;    
+    
+    // factor
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            factor = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= cost;
+    aParams[ 1 ] <<= salvage;
+    aParams[ 2 ] <<= life;
+    aParams[ 3 ] <<= period;
+    aParams[ 4 ] <<= factor;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DDB") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Rate)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double nper = 0;    
+    double pmt = 0;    
+    double pv = 0;
+
+    nper = rPar.Get(1)->GetDouble();
+    pmt = rPar.Get(2)->GetDouble();
+    pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    double guess = 0.1;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    // guess
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= nper;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    aParams[ 5 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Rate") ), rPar.Get( 0 ) );
+}
+
 RTLFUNC(StrReverse)
 {
     (void)pBasic;
@@ -2597,14 +3143,14 @@ RTLFUNC(Me)
 
     SbModule* pActiveModule = pINST->GetActiveModule();
     SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
+    SbxVariableRef refVar = rPar.Get(0);
     if( pClassModuleObject == NULL )
     {
-        StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod )
+            refVar->PutObject( pMod );
     }
     else
-    {
-        SbxVariableRef refVar = rPar.Get(0);
         refVar->PutObject( pClassModuleObject );
-    }
 }
 
--- basic/source/runtime/rtlproto.hxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/runtime/rtlproto.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -167,28 +167,41 @@ extern RTLFUNC(Kill); // JSM
 extern RTLFUNC(MkDir); // JSM
 extern RTLFUNC(RmDir); // JSM
 extern RTLFUNC(SendKeys); // JSM
+extern RTLFUNC(DDB);
+extern RTLFUNC(DoEvents);
 extern RTLFUNC(DimArray);
 extern RTLFUNC(Dir);
 extern RTLFUNC(Exp);
 extern RTLFUNC(FileLen);
 extern RTLFUNC(Fix);
+extern RTLFUNC(FV);
 extern RTLFUNC(Hex);
 extern RTLFUNC(Input);
 extern RTLFUNC(InStr);
 extern RTLFUNC(InStrRev);
 extern RTLFUNC(Int);
+extern RTLFUNC(IPmt);
+extern RTLFUNC(IRR);
 extern RTLFUNC(Join);
 extern RTLFUNC(LCase);
 extern RTLFUNC(Left);
 extern RTLFUNC(Log);
 extern RTLFUNC(LTrim);
 extern RTLFUNC(Mid);
+extern RTLFUNC(MIRR);
+extern RTLFUNC(NPer);
+extern RTLFUNC(NPV);
 extern RTLFUNC(Oct);
+extern RTLFUNC(Pmt);
+extern RTLFUNC(PPmt);
+extern RTLFUNC(PV);
+extern RTLFUNC(Rate);
 extern RTLFUNC(Replace);
 extern RTLFUNC(Right);
 extern RTLFUNC(RTrim);
 extern RTLFUNC(RTL);
 extern RTLFUNC(Sgn);
+extern RTLFUNC(SLN);
 extern RTLFUNC(Space);
 extern RTLFUNC(Split);
 extern RTLFUNC(Sqr);
@@ -196,6 +209,7 @@ extern RTLFUNC(Str);
 extern RTLFUNC(StrComp);
 extern RTLFUNC(String);
 extern RTLFUNC(StrReverse);
+extern RTLFUNC(SYD);
 extern RTLFUNC(Tan);
 extern RTLFUNC(UCase);
 extern RTLFUNC(Val);
@@ -298,6 +312,7 @@ extern RTLFUNC(Switch);
 extern RTLFUNC(Wait);
 //i#64882# add new WaitUntil
 extern RTLFUNC(WaitUntil);
+extern RTLFUNC(FuncCaller);
 
 extern RTLFUNC(GetGUIVersion);
 extern RTLFUNC(Choose);
--- basic/source/runtime/runtime.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/runtime/runtime.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -46,13 +46,17 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include "sbunoobj.hxx"
+#include "errobject.hxx"
+
+SbxVariable* getDefaultProp( SbxVariable* pRef );
 
 bool SbiRuntime::isVBAEnabled()
 {
     bool result = false;
     SbiInstance* pInst = pINST;
     if ( pInst && pINST->pRun )
-        result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		//result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		result = pInst->pRun->bVBAEnabled;
     return result; 
 }
 
@@ -63,6 +67,24 @@ void StarBASIC::StaticEnableReschedule(
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    if ( bDocBasic )
+    {
+        bVBAEnabled = bEnabled;
+    }
+}
+
+BOOL StarBASIC::isVBAEnabled()
+{
+    if ( bDocBasic )
+    { 
+        if( SbiRuntime::isVBAEnabled() )
+            return TRUE;
+        return bVBAEnabled;
+    }
+    return FALSE;
+}
 
 
 struct SbiArgvStack {					// Argv stack:
@@ -495,7 +517,7 @@ SbxArray* SbiInstance::GetLocals( SbMeth
 
 SbiRuntime::SbiRuntime( SbModule* pm, SbMethod* pe, UINT32 nStart )
          : rBasic( *(StarBASIC*)pm->pParent ), pInst( pINST ), 
-           pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), m_nLastTime(0)
+		   pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), mpExtCaller(0), m_nLastTime(0)
 {
     nFlags	  = pe ? pe->GetDebugFlags() : 0;
     pIosys	  = pInst->pIosys;
@@ -523,6 +545,7 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
     nForLvl   = 0;
     nOps	  = 0;
     refExprStk = new SbxArray;
+	SetVBAEnabled( pMod->IsVBACompat() );
 #if defined GCC
     SetParameters( pe ? pe->GetParameters() : (class SbxArray *)NULL );
 #else
@@ -530,7 +553,6 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 #endif
     pRefSaveList = NULL;
     pItemStoreList = NULL;
-    bVBAEnabled = isVBAEnabled();
 }
 
 SbiRuntime::~SbiRuntime()
@@ -549,6 +571,18 @@ SbiRuntime::~SbiRuntime()
     }
 }
 
+void SbiRuntime::SetVBAEnabled(bool bEnabled )
+{
+	bVBAEnabled = bEnabled; 
+	if ( bVBAEnabled )
+	{
+		if ( pMeth )
+			mpExtCaller = pMeth->mCaller;
+	}
+	else
+		mpExtCaller = 0;
+}
+
 // Aufbau der Parameterliste. Alle ByRef-Parameter werden direkt
 // uebernommen; von ByVal-Parametern werden Kopien angelegt. Falls
 // ein bestimmter Datentyp verlangt wird, wird konvertiert.
@@ -797,7 +831,38 @@ BOOL SbiRuntime::Step()
 void SbiRuntime::Error( SbError n )
 {
     if( n )
+	{
         nError = n;
+		if ( isVBAEnabled() )
+		{
+			String aMsg = pInst->GetErrorMsg();
+			// If a message is defined use that ( in preference to
+			// the defined one for the error ) NB #TODO
+			// if there is an error defined it more than likely
+			// is not the one you want ( some are the same though )
+			// we really need a new vba compatible error list
+			if ( !aMsg.Len() )
+			{
+				StarBASIC::MakeErrorText( n, aMsg );	
+				aMsg =  StarBASIC::GetErrorText();
+				if ( !aMsg.Len() ) // no message for err no.
+					// need localized resource here
+					aMsg = String( RTL_CONSTASCII_USTRINGPARAM("Internal Object Error:") );
+			}
+			// no num? most likely then it *is* really a vba err
+			SbxErrObject::getUnoErrObject()->setNumber( ( StarBASIC::GetVBErrorCode( n ) == 0 ) ? n : StarBASIC::GetVBErrorCode( n ) );
+			SbxErrObject::getUnoErrObject()->setDescription( aMsg );
+
+			// prepend an error number to the message.
+			String aTmp = '\'';
+                        aTmp += String::CreateFromInt32( SbxErrObject::getUnoErrObject()->getNumber() );
+                        aTmp += String( RTL_CONSTASCII_USTRINGPARAM("\'\n") );
+                        aTmp += aMsg;
+
+			pInst->aErrorMsg = aTmp;
+			nError = SbERR_BASIC_COMPAT;
+		}
+	}
 }
 
 void SbiRuntime::Error( SbError _errCode, const String& _details )
@@ -917,7 +982,25 @@ SbxVariable* SbiRuntime::GetTOS( short n
 void SbiRuntime::TOSMakeTemp()
 {
     SbxVariable* p = refExprStk->Get( nExprLvl - 1 );
-    if( p->GetRefCount() != 1 )
+	if ( p->GetType() == SbxEMPTY )
+		p->Broadcast( SBX_HINT_DATAWANTED );
+
+	SbxVariable* pDflt = NULL;
+	if ( bVBAEnabled &&  ( p->GetType() == SbxOBJECT || p->GetType() == SbxVARIANT  ) && ( pDflt = getDefaultProp( p ) ) )
+	{
+		pDflt->Broadcast( SBX_HINT_DATAWANTED );
+		// replacing new p on stack causes object pointed by 
+		// pDft->pParent to be deleted, when p2->Compute() is
+		// called below pParent is accessed ( but its deleted )
+		// so set it to NULL now
+		pDflt->SetParent( NULL );  
+		p = new SbxVariable( *pDflt );
+		p->SetFlag( SBX_READWRITE );
+		refExprStk->Put( p, nExprLvl - 1 );
+//		return;
+	}
+
+	else if( p->GetRefCount() != 1 )
     {
         SbxVariable* pNew = new SbxVariable( *p );
         pNew->SetFlag( SBX_READWRITE );
@@ -926,7 +1009,6 @@ void SbiRuntime::TOSMakeTemp()
 }
 
 // Der GOSUB-Stack nimmt Returnadressen fuer GOSUBs auf
-
 void SbiRuntime::PushGosub( const BYTE* pc )
 {
     if( ++nGosubLvl > MAXRECURSION )
--- basic/source/runtime/stdobj.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/runtime/stdobj.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -36,6 +36,7 @@
 #include <basic/sbstdobj.hxx>
 #include "rtlproto.hxx"
 #include "sbintern.hxx"
+#include "errobject.hxx"
 
 // Das nArgs-Feld eines Tabelleneintrags ist wie folgt verschluesselt:
 // Zur Zeit wird davon ausgegangen, dass Properties keine Parameter
@@ -72,6 +73,45 @@ struct Methods {
     USHORT		nHash;		// Hashcode
 };
 
+struct StringHashCode
+{
+    size_t operator()( const String& rStr ) const
+    {
+        return rtl_ustr_hashCode_WithLength( rStr.GetBuffer(), rStr.Len() );
+    }
+};
+
+class VBABlacklist
+{
+friend class VBABlackListQuery;
+    std::hash_map< String, bool, StringHashCode > mBlackList;
+    VBABlacklist()
+    {
+        const char* list[] = { "Red" };
+        sal_Int32 nSize = sizeof( list ) / sizeof( list[ 0 ] );
+        for ( sal_Int32 index = 0; index < nSize; ++index )
+        {
+            mBlackList[ String::CreateFromAscii( list[ index ] ).ToLowerAscii() ] = true;
+        }
+    } 
+public:
+    bool isBlackListed( const String& sName )
+    {
+        String sNameLower( sName );
+        sNameLower.ToLowerAscii();
+        return ( mBlackList.find( sNameLower ) != mBlackList.end() );
+    }
+};
+
+class VBABlackListQuery
+{
+public:
+    static bool isBlackListed( const String& sName )
+    {
+        static VBABlacklist blackList;
+        return blackList.isBlackListed( sName );
+    }
+};
 static Methods aMethods[] = {
 
 { "AboutStarBasic", SbxNULL,      1 | _FUNCTION, RTLNAME(AboutStarBasic),0  },
@@ -174,7 +214,12 @@ static Methods aMethods[] = {
   { "expression",   SbxVARIANT, 0,NULL,0 },
 { "CVErr",          SbxVARIANT,   1 | _FUNCTION, RTLNAME(CVErr),0           },
   { "expression",   SbxVARIANT, 0,NULL,0 },
-
+{ "DDB",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(DDB),0       },
+  { "Cost",       SbxDOUBLE,  0, NULL,0 },
+  { "Salvage",       SbxDOUBLE,  0, NULL,0 },
+  { "Life",       SbxDOUBLE,  0, NULL,0 },
+  { "Period",       SbxDOUBLE,  0, NULL,0 },
+  { "Factor",     SbxVARIANT,  _OPT, NULL,0 },
 { "Date",           SbxDATE,          _LFUNCTION,RTLNAME(Date),0            },
 { "DateAdd",        SbxDATE,	  3 | _FUNCTION, RTLNAME(DateAdd),0         },
   { "Interval",     SbxSTRING, 0,NULL,0 },
@@ -272,6 +317,12 @@ static Methods aMethods[] = {
 { "FreeLibrary",    SbxNULL,      1 | _FUNCTION, RTLNAME(FreeLibrary),0     },
   { "Modulename",   SbxSTRING, 0,NULL,0 },
 
+{ "FV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(FV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
 { "Get",            SbxNULL,   3 | _FUNCTION, RTLNAME(Get),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
@@ -332,6 +383,16 @@ static Methods aMethods[] = {
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
 { "Int",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Int),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "IPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(IPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "IRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(IRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "Guess",       SbxVARIANT,  _OPT, NULL,0 },
 { "IsArray",        SbxBOOL,      1 | _FUNCTION, RTLNAME(IsArray),0         },
   { "Variant",      SbxVARIANT, 0,NULL,0 },
 { "IsDate",         SbxBOOL,      1 | _FUNCTION, RTLNAME(IsDate),0          },
@@ -400,6 +461,10 @@ static Methods aMethods[] = {
   { "Length",       SbxLONG,          _OPT, NULL,0 },
 { "Minute",         SbxINTEGER,   1 | _FUNCTION, RTLNAME(Minute),0          },
   { "Date",         SbxDATE, 0,NULL,0 },
+{ "MIRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(MIRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "FinanceRate",       SbxDOUBLE,  0, NULL,0 },
+  { "ReinvestRate",       SbxDOUBLE,  0, NULL,0 },
 { "MkDir",          SbxNULL,      1 | _FUNCTION, RTLNAME(MkDir),0           },
   { "pathname",     SbxSTRING, 0,NULL,0 },
 { "Month",          SbxINTEGER,   1 | _FUNCTION, RTLNAME(Month),0           },
@@ -416,6 +481,15 @@ static Methods aMethods[] = {
 
 { "Nothing",        SbxOBJECT,        _CPROP,    RTLNAME(Nothing),0         },
 { "Now",            SbxDATE,          _FUNCTION, RTLNAME(Now),0             },
+{ "NPer",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(NPer),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "NPV",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(NPV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
 { "Null",			SbxNULL,          _CPROP,    RTLNAME(Null),0			},
 
 { "Oct",            SbxSTRING,    1 | _FUNCTION, RTLNAME(Oct),0             },
@@ -427,16 +501,46 @@ static Methods aMethods[] = {
   { "stop",  	    SbxLONG, 	0,NULL,0 },
   { "interval",     SbxLONG, 	0,NULL,0 },
 { "Pi",				SbxDOUBLE,		  _CPROP,    RTLNAME(PI),0		      	},
+
+{ "Pmt",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(Pmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
+{ "PPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(PPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "Put",            SbxNULL,   3 | _FUNCTION, RTLNAME(Put),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
   { "variablename",	SbxVARIANT, 0,NULL,0 },
 
+{ "PV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(PV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "QBColor",		SbxLONG,	  1 | _FUNCTION, RTLNAME(QBColor),0			},
   { "number",		SbxINTEGER, 0,NULL,0 },
 
 { "Randomize",      SbxNULL,      1 | _FUNCTION, RTLNAME(Randomize),0       },
   { "Number",       SbxDOUBLE,        _OPT, NULL,0 },
+{ "Rate",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(Rate),0       },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",       SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Guess",    SbxVARIANT,  _OPT, NULL,0 },
 { "Red",        SbxINTEGER,   1 | _FUNCTION, RTLNAME(Red),0                 },
   { "RGB-Value",     SbxLONG, 0,NULL,0 },
 { "Reset",          SbxNULL,      0 | _FUNCTION, RTLNAME(Reset),0           },
@@ -477,6 +581,7 @@ static Methods aMethods[] = {
 { "SendKeys",       SbxNULL,      2 | _FUNCTION, RTLNAME(SendKeys),0        },
   { "String",       SbxSTRING, 0,NULL,0 },
   { "Wait",         SbxBOOL,          _OPT, NULL,0 },
+{ "DoEvents",       SbxINTEGER,      0 | _FUNCTION, RTLNAME(DoEvents),0        },
 { "SetAttr",        SbxNULL,      2 | _FUNCTION, RTLNAME(SetAttr),0         },
   { "File"  ,       SbxSTRING, 0,NULL,0 },
   { "Attributes",   SbxINTEGER, 0,NULL,0 },
@@ -490,6 +595,15 @@ static Methods aMethods[] = {
   { "WindowStyle",  SbxINTEGER,       _OPT, NULL,0 },
 { "Sin",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Sin),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "SLN",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SLN),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Double",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+{ "SYD",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SYD),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Salvage",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+  { "Period",       SbxDOUBLE, 0,NULL,0 },
 { "Space",          SbxSTRING,      1 | _FUNCTION, RTLNAME(Space),0         },
   { "string",       SbxLONG, 0,NULL,0 },
 { "Spc",          	SbxSTRING,      1 | _FUNCTION, RTLNAME(Spc),0           },
@@ -604,6 +718,7 @@ static Methods aMethods[] = {
 
 { "Wait",        	SbxNULL,      1 | _FUNCTION, RTLNAME(Wait),0            },
   { "Milliseconds", SbxLONG, 0,NULL,0 },
+{ "FuncCaller",          SbxVARIANT,      _FUNCTION, RTLNAME(FuncCaller),0      },
 //#i64882#
 { "WaitUntil",          SbxNULL,      1 | _FUNCTION, RTLNAME(WaitUntil),0      },
   { "Date", SbxDOUBLE, 0,NULL,0 },
@@ -655,6 +770,11 @@ SbiStdObject::~SbiStdObject()
 
 SbxVariable* SbiStdObject::Find( const String& rName, SbxClassType t )
 {
+	// #TODO #FIXME hack for substituting ooo-basic Err with vba-ish
+	// ErrObject object
+	static String sErr( RTL_CONSTASCII_USTRINGPARAM("Err") );
+	if (  rName.EqualsIgnoreCaseAscii( sErr ) ) 
+		return SbxErrObject::getErrObject();
     // Bereits eingetragen?
     SbxVariable* pVar = SbxObject::Find( rName, t );
     if( !pVar )
@@ -678,13 +798,15 @@ SbxVariable* SbiStdObject::Find( const S
              && ( p->nHash == nHash_ )
              && ( rName.EqualsIgnoreCaseAscii( p->pName ) ) )
             {
+                SbiInstance* pInst = pINST;
                 bFound = TRUE;
                 if( p->nArgs & _COMPTMASK )
                 {
-                    SbiInstance* pInst = pINST;
                     if( !pInst || !pInst->IsCompatibility() )
                         bFound = FALSE;
                 }
+                if ( pInst && pInst->IsCompatibility() && VBABlackListQuery::isBlackListed( rName ) )
+                            bFound = FALSE;
                 break;
             }
             nIndex += ( p->nArgs & _ARGSMASK ) + 1;
--- basic/source/runtime/step0.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/runtime/step0.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -33,6 +33,7 @@
 #include <vcl/msgbox.hxx>
 #include <tools/fsys.hxx>
 
+#include "errobject.hxx"
 #include "runtime.hxx"
 #include "sbintern.hxx"
 #include "iosys.hxx"
@@ -47,6 +48,11 @@
 
 #include <algorithm>
 
+// for a patch forward declaring these methods below makes sense
+// but, #FIXME lets really just move the methods to the top
+void lcl_clearImpl( SbxVariableRef& refVar, SbxDataType& eType );
+void lcl_eraseImpl( SbxVariableRef& refVar, bool bVBAEnabled );
+
 SbxVariable* getDefaultProp( SbxVariable* pRef );
 
 void SbiRuntime::StepNOP()
@@ -58,34 +64,6 @@ void SbiRuntime::StepArith( SbxOperator
     TOSMakeTemp();
     SbxVariable* p2 = GetTOS();
 
-
-    // This could & should be moved to the MakeTempTOS() method in runtime.cxx
-    // In the code which this is cut'npaste from there is a check for a ref
-    // count != 1 based on which the copy of the SbxVariable is done.
-    // see orig code in MakeTempTOS ( and I'm not sure what the significance,
-    // of that is )
-    // here we alway seem to have a refcount of 1. Also it seems that
-    // MakeTempTOS is called for other operation, so I hold off for now
-    // until I have a better idea
-    if ( bVBAEnabled
-        && ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
-    )
-    {
-        SbxVariable* pDflt = getDefaultProp( p2 );
-        if ( pDflt )
-        {
-            pDflt->Broadcast( SBX_HINT_DATAWANTED );
-            // replacing new p2 on stack causes object pointed by 
-            // pDft->pParent to be deleted, when p2->Compute() is
-            // called below pParent is accessed ( but its deleted )
-            // so set it to NULL now
-            pDflt->SetParent( NULL );  
-            p2 = new SbxVariable( *pDflt );
-            p2->SetFlag( SBX_READWRITE );
-            refExprStk->Put( p2, nExprLvl - 1 );
-        }
-    }
-
     p2->ResetFlag( SBX_FIXED );
     p2->Compute( eOp, *p1 );
 
@@ -108,19 +86,24 @@ void SbiRuntime::StepCompare( SbxOperato
     // values ( and type ) set as appropriate
     SbxDataType p1Type = p1->GetType(); 
     SbxDataType p2Type = p2->GetType(); 
+	if ( p1Type == SbxEMPTY )
+	{
+		p1->Broadcast( SBX_HINT_DATAWANTED );
+		p1Type = p1->GetType(); 
+	}
+	if ( p2Type == SbxEMPTY )
+	{
+		p2->Broadcast( SBX_HINT_DATAWANTED );
+		p2Type = p2->GetType(); 
+	}
     if ( p1Type == p2Type )
     {
-        if ( p1Type == SbxEMPTY )
-        {
-            p1->Broadcast( SBX_HINT_DATAWANTED );
-            p2->Broadcast( SBX_HINT_DATAWANTED );
-        }
         // if both sides are an object and have default props
         // then we need to use the default props
         // we don't need to worry if only one side ( lhs, rhs ) is an 
         // object ( object side will get coerced to correct type in 
         // Compare )
-        else if ( p1Type ==  SbxOBJECT )
+		if ( p1Type ==  SbxOBJECT )
         {
             SbxVariable* pDflt = getDefaultProp( p1 );
             if ( pDflt )
@@ -140,8 +123,21 @@ void SbiRuntime::StepCompare( SbxOperato
 #ifndef WIN
     static SbxVariable* pTRUE = NULL;
     static SbxVariable* pFALSE = NULL;
-
-    if( p2->Compare( eOp, *p1 ) )
+	static SbxVariable* pNULL = NULL;
+	// why do this on non-windows ?
+	// why do this at all ?
+	// I dumbly follow the pattern :-/
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
+	{
+		if( !pNULL )
+		{
+			pNULL = new SbxVariable;
+			pNULL->PutNull();
+			pNULL->AddRef();
+		}
+		PushVar( pNULL );
+	}
+	else if( p2->Compare( eOp, *p1 ) )
     {
         if( !pTRUE )
         {
@@ -162,9 +158,14 @@ void SbiRuntime::StepCompare( SbxOperato
         PushVar( pFALSE );
     }
 #else
-    BOOL bRes = p2->Compare( eOp, *p1 );
     SbxVariable* pRes = new SbxVariable;
-    pRes->PutBool( bRes );
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
+		pRes->PutNull();
+	else
+	{
+		BOOL bRes = p2->Compare( eOp, *p1 );
+		pRes->PutBool( bRes );
+	}
     PushVar( pRes );
 #endif
 }
@@ -641,6 +642,17 @@ void SbiRuntime::StepDIM()
 // #56204 DIM-Funktionalitaet in Hilfsmethode auslagern (step0.cxx)
 void SbiRuntime::DimImpl( SbxVariableRef refVar )
 {
+	// If refDim then this DIM statement is terminating a ReDIM and
+	// previous StepERASE_CLEAR for an array, the following actions have 
+	// been delayed from ( StepERASE_CLEAR ) 'till here
+	if ( refRedim ) 
+	{
+		if ( !refRedimpArray ) // only erase the array not ReDim Preserve
+			lcl_eraseImpl( refVar, bVBAEnabled );
+		SbxDataType eType = refVar->GetType();
+		lcl_clearImpl( refVar, eType );
+		refRedim = NULL;
+	}
     SbxArray* pDims = refVar->GetParameters();
     // Muss eine gerade Anzahl Argumente haben
     // Man denke daran, dass Arg[0] nicht zaehlt!
@@ -806,6 +818,7 @@ void SbiRuntime::StepREDIMP()
 void SbiRuntime::StepREDIMP_ERASE()
 {
     SbxVariableRef refVar = PopVar();
+	refRedim = refVar;
     SbxDataType eType = refVar->GetType();
     if( eType & SbxARRAY )
     {
@@ -816,12 +829,6 @@ void SbiRuntime::StepREDIMP_ERASE()
             refRedimpArray = pDimArray;
         }
 
-        // As in ERASE
-        USHORT nSavFlags = refVar->GetFlags();
-        refVar->ResetFlag( SBX_FIXED );
-        refVar->SetType( SbxDataType(eType & 0x0FFF) );
-        refVar->SetFlags( nSavFlags );
-        refVar->Clear();
     }
     else
     if( refVar->IsFixed() )
@@ -894,10 +901,7 @@ void SbiRuntime::StepERASE()
 
 void SbiRuntime::StepERASE_CLEAR()
 {
-    SbxVariableRef refVar = PopVar();
-    lcl_eraseImpl( refVar, bVBAEnabled );
-    SbxDataType eType = refVar->GetType();
-    lcl_clearImpl( refVar, eType );
+	refRedim = PopVar();
 }
 
 void SbiRuntime::StepARRAYACCESS()
@@ -1119,6 +1123,7 @@ void SbiRuntime::StepSTDERROR()
     pInst->nErr = 0L;
     pInst->nErl = 0;
     nError = 0L;
+	SbxErrObject::getUnoErrObject()->Clear();
 }
 
 void SbiRuntime::StepNOERROR()
@@ -1127,6 +1132,7 @@ void SbiRuntime::StepNOERROR()
     pInst->nErr = 0L;
     pInst->nErl = 0;
     nError = 0L;
+	SbxErrObject::getUnoErrObject()->Clear();
     bError = FALSE;
 }
 
@@ -1135,6 +1141,9 @@ void SbiRuntime::StepNOERROR()
 void SbiRuntime::StepLEAVE()
 {
     bRun = FALSE;
+        // If VBA and we are leaving an ErrorHandler then clear the error ( it's been processed )
+	if ( bInError && pError )
+	    SbxErrObject::getUnoErrObject()->Clear();
 }
 
 void SbiRuntime::StepCHANNEL()	  	// TOS = Kanalnummer
@@ -1268,6 +1277,6 @@ void SbiRuntime::StepERROR()
     SbxVariableRef refCode = PopVar();
     USHORT n = refCode->GetUShort();
     SbError error = StarBASIC::GetSfxFromVBError( n );
-    Error( error );
+	pInst->Error( error );
 }
 
--- basic/source/runtime/step1.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/runtime/step1.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -38,6 +38,7 @@
 #include "iosys.hxx"
 #include "image.hxx"
 #include "sbunoobj.hxx"
+#include "errobject.hxx"
 
 bool checkUnoObjectType( SbUnoObject* refVal, 
     const String& aClass );
@@ -94,6 +95,15 @@ void SbiRuntime::StepARGN( UINT32 nOp1 )
     {
         String aAlias( pImg->GetString( static_cast<short>( nOp1 ) ) );
         SbxVariableRef pVal = PopVar();
+		if( bVBAEnabled && ( pVal->ISA(SbxMethod) || pVal->ISA(SbUnoProperty) || pVal->ISA(SbProcedureProperty) ) )
+		{
+			// named variables ( that are Any especially properties ) can be empty at this point and need a broadcast
+			if ( pVal->GetType() == SbxEMPTY )
+				pVal->Broadcast( SBX_HINT_DATAWANTED );
+			// Methoden und Properties evaluieren!
+			SbxVariable* pRes = new SbxVariable( *pVal );
+			pVal = pRes;
+		}
         refArgv->Put( pVal, nArgc );
         refArgv->PutAlias( aAlias, nArgc++ );
     }
@@ -183,7 +193,9 @@ void SbiRuntime::StepJUMPT( UINT32 nOp1
 void SbiRuntime::StepJUMPF( UINT32 nOp1 )
 {
     SbxVariableRef p = PopVar();
-    if( !p->GetBool() )
+	// In a test e.g. If Null then 	
+        // will evaluate Null will act as if False
+	if( ( bVBAEnabled && p->IsNull() ) || !p->GetBool() )
         StepJUMP( nOp1 );
 }
 
@@ -363,6 +375,7 @@ void SbiRuntime::StepERRHDL( UINT32 nOp1
     pInst->nErr = 0;
     pInst->nErl = 0;
     nError = 0;
+	SbxErrObject::getUnoErrObject()->Clear();
 }
 
 // Resume nach Fehlern (+0=statement, 1=next or Label)
@@ -383,6 +396,8 @@ void SbiRuntime::StepRESUME( UINT32 nOp1
     }
     else
         pCode = pErrStmnt;
+	if ( pError ) // current in error handler ( and got a Resume Next statment )
+		SbxErrObject::getUnoErrObject()->Clear();
 
     if( nOp1 > 1 )
         StepJUMP( nOp1 );
--- basic/source/runtime/step2.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ basic/source/runtime/step2.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -144,7 +144,7 @@ SbxVariable* SbiRuntime::FindElement
                     if ( pElem )
                         bSetName = false; // don't overwrite uno name
                     else
-                        pElem = getVBAConstant( aName );
+                        pElem = VBAConstantHelper::instance().getVBAConstant( aName );
                 }
                 // #72382 VORSICHT! Liefert jetzt wegen unbekannten
                 // Modulen IMMER ein Ergebnis!
@@ -266,8 +266,10 @@ SbxVariable* SbiRuntime::FindElement
             pElem = pNew;
         }
         // Index-Access bei UnoObjekten beruecksichtigen
-        /*
-        else if( pElem->ISA(SbUnoProperty) )
+		// definitely we want this for VBA where properties are often 
+		// collections ( which need index access ), but lets only do 
+		// this if we actually have params following
+		else if( bVBAEnabled && pElem->ISA(SbUnoProperty) && pElem->GetParameters() )
         {
             // pElem auf eine Ref zuweisen, um ggf. eine Temp-Var zu loeschen
             SbxVariableRef refTemp = pElem;
@@ -277,7 +279,6 @@ SbxVariable* SbiRuntime::FindElement
             pElem->SetParameters( NULL ); // sonst bleibt Ref auf sich selbst
             pElem = pNew;
         }
-        */
     }
     return CheckArray( pElem );
 }
@@ -380,7 +381,8 @@ void SbiRuntime::SetupArgs( SbxVariable*
                 bool bError_ = true;
 
                 SbUnoMethod* pUnoMethod = PTR_CAST(SbUnoMethod,p);
-                if( pUnoMethod )
+				SbUnoProperty* pUnoProperty = PTR_CAST(SbUnoProperty,p);
+				if( pUnoMethod || pUnoProperty )
                 {
                     SbUnoObject* pParentUnoObj = PTR_CAST( SbUnoObject,p->GetParent() );
                     if( pParentUnoObj )
@@ -458,7 +460,7 @@ SbxVariable* SbiRuntime::CheckArray( Sbx
 {
     // Falls wir ein Array haben, wollen wir bitte das Array-Element!
     SbxArray* pPar;
-    if( pElem->GetType() & SbxARRAY )
+	if( ( pElem->GetType() & SbxARRAY ) && (SbxVariable*)refRedim != pElem )
     {
         SbxBase* pElemObj = pElem->GetObject();
         SbxDimArray* pDimArray = PTR_CAST(SbxDimArray,pElemObj);
@@ -723,6 +725,8 @@ void SbiRuntime::StepPARAM( UINT32 nOp1,
         SaveRef( q );
         *q = *p;
         p = q;
+		if ( i ) 
+                	refParams->Put( p, i );
     }
     SetupArgs( p, nOp1 );
     PushVar( CheckArray( p ) );
@@ -1135,16 +1139,26 @@ void SbiRuntime::StepGLOBAL( UINT32 nOp1
     if( pImg->GetFlag( SBIMG_CLASSMODULE ) )
         StepPUBLIC_Impl( nOp1, nOp2, true );
 
+        SbxObject* pStorage = &rBasic;
     String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+	// Store module scope variables at module scope 
+	// in non vba mode these are stored at the library level :/
+	// not sure if this really should not be enabled for ALL basic
+	if ( SbiRuntime::isVBAEnabled() ) 
+        {
+            pStorage = pMod;
+            pMod->AddVarName( aName );
+        }
+
     SbxDataType t = (SbxDataType) nOp2;
-    BOOL bFlag = rBasic.IsSet( SBX_NO_MODIFY );
+	BOOL bFlag = pStorage->IsSet( SBX_NO_MODIFY );
     rBasic.SetFlag( SBX_NO_MODIFY );
-    SbxVariableRef p = rBasic.Find( aName, SbxCLASS_PROPERTY );
+	SbxVariableRef p = pStorage->Find( aName, SbxCLASS_PROPERTY );
     if( p.Is() )
-        rBasic.Remove (p);
-    p = rBasic.Make( aName, SbxCLASS_PROPERTY, t );
+		pStorage->Remove (p);
+	p = pStorage->Make( aName, SbxCLASS_PROPERTY, t );
     if( !bFlag )
-        rBasic.ResetFlag( SBX_NO_MODIFY );
+		pStorage->ResetFlag( SBX_NO_MODIFY );
     if( p )
     {
         p->SetFlag( SBX_DONTSTORE );
--- basic/source/sbx/sbxvalue.cxx.old	2009-10-08 16:17:53.000000000 +0200
+++ basic/source/sbx/sbxvalue.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -1147,8 +1147,8 @@ BOOL SbxValue::Compute( SbxOperator eOp,
     {
         SbxValues aL, aR;
         bool bDecimal = false;
-        if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING ) || 
-             ( eThisType != SbxSTRING && eOpType == SbxSTRING ) ) &&
+		if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING && eOpType != SbxEMPTY ) || 
+			 ( eThisType != SbxSTRING && eThisType != SbxEMPTY && eOpType == SbxSTRING ) ) &&
              ( eOp == SbxMUL || eOp == SbxDIV || eOp == SbxPLUS || eOp == SbxMINUS ) )
         {
             goto Lbl_OpIsDouble;
@@ -1195,6 +1195,8 @@ BOOL SbxValue::Compute( SbxOperator eOp,
                     aL.eType = aR.eType = GetType();
 //				else if( GetType() == SbxDouble || GetType() == SbxSingle )
 //					aL.eType = aR.eType = SbxLONG64;
+				else if ( bVBAInterop && eOpType == SbxBOOL )
+					aL.eType = aR.eType = SbxBOOL;
                 else
                     aL.eType = aR.eType = SbxLONG;
             }
@@ -1281,7 +1283,12 @@ BOOL SbxValue::Compute( SbxOperator eOp,
                         break;
                     case SbxNOT:
                         if( aL.eType != SbxLONG && aL.eType != SbxULONG )
-                            aL.nLong64 = ~aL.nLong64;
+						{
+							if ( aL.eType != SbxBOOL )
+								aL.nLong64 = ~aL.nLong64;
+							else
+								aL.nLong = ~aL.nLong;
+						}
                         else
                             aL.nLong = ~aL.nLong;
                         break;
@@ -1573,9 +1580,9 @@ BOOL SbxValue::Compare( SbxOperator eOp,
         {
             aL.eType = aR.eType = SbxDOUBLE;
             //if( Get( aL ) && rOp.Get( aR ) )
-            bool bGetL = Get( aL );
-            bool bGetR = rOp.Get( aR );
-            if( bGetL && bGetR )
+			bool bGetL = Get( aL );
+			bool bGetR = rOp.Get( aR );
+			if( bGetL && bGetR )
               switch( eOp )
             {
                 case SbxEQ:
@@ -1593,17 +1600,17 @@ BOOL SbxValue::Compare( SbxOperator eOp,
                 default:
                     SetError( SbxERR_NOTIMP );
             }
-            // at least one value was got
-            // if this is VBA then a conversion error for one
-            // side will yield a false result of an equality test
-            else if ( bGetR || bGetL )
-            {
-                if ( bVBAInterop && eOp == SbxEQ && GetError() == SbxERR_CONVERSION )
-                {
-                    ResetError();
-                    bRes = FALSE;
-                }
-            }
+			// at least one value was got
+			// if this is VBA then a conversion error for one
+			// side will yield a false result of an equality test
+			else if ( bGetR || bGetL )
+			{
+				if ( bVBAInterop && eOp == SbxEQ && GetError() == SbxERR_CONVERSION )
+				{
+					ResetError();
+					bRes = FALSE;
+				}
+			}
         }
     }
     if( eOld != SbxERR_OK )
--- basic/source/uno/dlgcont.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/uno/dlgcont.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -322,7 +322,7 @@ Any SAL_CALL SfxDialogLibraryContainer::
     
     try {
         // start parsing 
-        xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext ) );
+		xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext, mxOwnerDocument ) );
         xParser->parseStream( source );
     }
     catch( Exception& )
@@ -336,7 +336,7 @@ Any SAL_CALL SfxDialogLibraryContainer::
 
     // Create InputStream, TODO: Implement own InputStreamProvider
     // to avoid creating the DialogModel here!
-    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, mxOwnerDocument );
     aRetAny <<= xISP;
     return aRetAny;
 }
@@ -484,7 +484,11 @@ void SfxDialogLibraryContainer::onNewRoo
     }
 }
 
-
+sal_Bool SAL_CALL
+SfxDialogLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	return sal_False; // dialog library has no executable code
+}
 //============================================================================
 // Service
 
--- basic/source/uno/namecont.cxx.old	2010-01-21 01:00:49.000000000 +0100
+++ basic/source/uno/namecont.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -76,6 +76,9 @@
 #include <cppuhelper/exc_hlp.hxx>
 #include <basic/sbmod.hxx>
 
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 namespace basic
 {
@@ -155,7 +158,7 @@ void NameContainer::replaceByName( const
     throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
 {
     Type aAnyType = aElement.getValueType();
-    if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
         throw IllegalArgumentException();
 
     NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -197,7 +200,7 @@ void NameContainer::insertByName( const
     throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
     Type aAnyType = aElement.getValueType();
-    if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
         throw IllegalArgumentException();
 
     NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -2729,6 +2732,39 @@ OUString SfxLibraryContainer::expand_url
     }
 }
 
+::sal_Bool SAL_CALL SfxLibraryContainer::getVBACompatModeOn() throw (RuntimeException)
+{
+	sal_Bool bVBACompat = sal_False;
+	BasicManager* pBasMgr = getBasicManager();
+	if( pBasMgr )
+	{
+		// get the standard library
+		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
+                if ( pBasMgr->GetName().Len() )
+                    aLibName = pBasMgr->GetName();
+
+		StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
+		if( pBasic )
+			bVBACompat = pBasic->isVBAEnabled();
+	}
+
+	return bVBACompat;
+}
+
+void SAL_CALL SfxLibraryContainer::setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (RuntimeException)
+{
+	BasicManager* pBasMgr = getBasicManager();
+	if( pBasMgr )
+	{
+		// get the standard library
+		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+		StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
+		if( pBasic )
+			pBasic->SetVBAEnabled( _vbacompatmodeon );
+	}
+}
+
 // Methods XServiceInfo
 ::sal_Bool SAL_CALL SfxLibraryContainer::supportsService( const ::rtl::OUString& _rServiceName )
     throw (RuntimeException)
--- basic/source/uno/scriptcont.cxx.old	2009-10-07 15:06:56.000000000 +0200
+++ basic/source/uno/scriptcont.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -67,7 +67,8 @@
 #include <xmlscript/xmlmod_imexp.hxx>
 #include <cppuhelper/factory.hxx>
 #include <com/sun/star/util/VetoException.hpp>
-
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
+#include <cppuhelper/implbase1.hxx>
 namespace basic
 {
 
@@ -138,7 +139,6 @@ sal_Bool SfxScriptLibraryContainer::hasL
     return pImplLib->mbPasswordProtected;
 }
 
-
 // Ctor for service
 SfxScriptLibraryContainer::SfxScriptLibraryContainer( void )
     :maScriptLanguage( RTL_CONSTASCII_USTRINGPARAM( "StarBasic" ) )
@@ -214,7 +214,12 @@ void SAL_CALL SfxScriptLibraryContainer:
     xmlscript::ModuleDescriptor aMod;
     aMod.aName = aElementName;
     aMod.aLanguage = maScriptLanguage;
-    aElement >>= aMod.aCode;
+	// make sure we export source
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		aMod.aCode = mInfo.ModuleSource;
+	else
+		aElement >>= aMod.aCode;
     xmlscript::exportScriptModule( xHandler, aMod );
 }
 
@@ -1050,6 +1055,17 @@ void SfxScriptLibraryContainer::onNewRoo
 {
 }
 
+sal_Bool SAL_CALL
+SfxScriptLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	BasicManager* pBasicMgr = getBasicManager();
+    	OSL_ENSURE( pBasicMgr, "we need a basicmanager, really we do" );
+	if ( pBasicMgr )
+		return pBasicMgr->HasExeCode( Library ); // need to change this to take name
+	// default to it has code if we can't decide
+	return sal_True;
+}
+
 //============================================================================
 // Service
 void createRegistryInfo_SfxScriptLibraryContainer()
@@ -1160,7 +1176,11 @@ void SfxScriptLibrary::storeResourcesToS
 bool SfxScriptLibrary::containsValidModule( const Any& aElement )
 {
     OUString sModuleText;
-    aElement >>= sModuleText;
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		sModuleText = mInfo.ModuleSource;
+	else
+		aElement >>= sModuleText;
     return ( sModuleText.getLength() > 0 );
 }
 
--- comphelper/inc/comphelper/evtmethodhelper.hxx.old	2010-03-03 16:59:34.000000000 +0100
+++ comphelper/inc/comphelper/evtmethodhelper.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,41 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.hxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef COMPHELPER_EVENTMEHODHELPER_HXX
+#define COMPHELPER_EVENMETHODHELPER_HXX
+#include <comphelper/sequence.hxx>
+//........................................................................
+namespace comphelper
+{
+	COMPHELPER_DLLPUBLIC ::com::sun::star::uno::Sequence< ::rtl::OUString> getEventMethodsForType(const ::com::sun::star::uno::Type& type);
+//........................................................................
+
+}	// namespace comphelper
+//........................................................................
+#endif // COMPHELPER_EVENTMEHODHELPER_HXX
--- comphelper/source/misc/evtmethodhelper.cxx.old	2010-03-03 16:59:34.000000000 +0100
+++ comphelper/source/misc/evtmethodhelper.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.cxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_comphelper.hxx"
+#include "comphelper/evtmethodhelper.hxx"
+#include "cppuhelper/typeprovider.hxx"
+
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Type;
+
+namespace comphelper
+{
+
+	Sequence< ::rtl::OUString> getEventMethodsForType(const Type& type)
+	{
+		typelib_InterfaceTypeDescription *pType=0;
+		type.getDescription( (typelib_TypeDescription**)&pType);
+	
+		if(!pType)
+			return Sequence< ::rtl::OUString>();
+	    
+		Sequence< ::rtl::OUString> aNames(pType->nMembers);
+		::rtl::OUString* pNames = aNames.getArray();
+		for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
+		{
+			// the decription reference
+			typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
+			// the description for the reference
+			typelib_TypeDescription* pMemberDescription = NULL;
+			typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
+			if (pMemberDescription)
+			{
+				typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
+				reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
+				*pNames = pRealMemberDescription->pMemberName;
+			}
+		}
+		typelib_typedescription_release( (typelib_TypeDescription *)pType );
+		return aNames;
+	}
+
+}
+
+
+
+
+
+
+
--- comphelper/source/misc/makefile.mk.old	2009-10-08 16:17:47.000000000 +0200
+++ comphelper/source/misc/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -60,6 +60,7 @@ SLOFILES=   \
             $(SLO)$/docpasswordhelper.obj \
             $(SLO)$/docpasswordrequest.obj \
             $(SLO)$/documentinfo.obj \
+	    $(SLO)$/evtmethodhelper.obj \
             $(SLO)$/documentiologring.obj \
             $(SLO)$/evtlistenerhlp.obj \
             $(SLO)$/ihwrapnofilter.obj \
--- dbaccess/source/ext/macromigration/migrationengine.cxx.old	2009-10-08 16:17:07.000000000 +0200
+++ dbaccess/source/ext/macromigration/migrationengine.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -1838,7 +1838,7 @@ namespace dbmm
             Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
 
             Reference< XNameContainer > xDialogModel( m_aContext.createComponent( "com.sun.star.awt.UnoControlDialogModel" ), UNO_QUERY_THROW );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext() );
+            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
 
             // adjust the events of the dialog
             impl_adjustDialogElementEvents_throw( xDialogModel );
@@ -1853,7 +1853,7 @@ namespace dbmm
             }
 
             // export dialog model
-            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext() );
+            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
             _inout_rDialogLibraryElement <<= xISP;
         }
         catch( const Exception& )
--- extensions/inc/extensio.hrc.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/inc/extensio.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -459,9 +459,10 @@
 #define HID_PROP_NOLABEL                        (HID_FORMS_START + 340)
 #define HID_PROP_WRITING_MODE                   (HID_FORMS_START + 341)
 #define HID_PROP_ANCHOR_TYPE                    (HID_FORMS_START + 343)
+#define HID_PROP_GROUP_NAME                     (HID_FORMS_START + 344)
     // please adjust HID_LAST_FORMS_ID if you add new ids here!
 
-#define HID_LAST_FORMS_ID   HID_PROP_ANCHOR_TYPE
+#define HID_LAST_FORMS_ID   HID_PROP_GROUP_NAME
 
 #if HID_LAST_FORMS_ID > HID_FORMS_END
     #error id overflow
--- extensions/source/ole/oleobjw.cxx.old	2009-10-07 15:07:23.000000000 +0200
+++ extensions/source/ole/oleobjw.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -72,6 +72,7 @@ using namespace boost;
 using namespace osl;
 using namespace rtl;
 using namespace cppu;
+using namespace com::sun::star::script;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::bridge;
 using namespace com::sun::star::bridge::oleautomation;
@@ -111,7 +112,7 @@ IUnknownWrapper_Impl::IUnknownWrapper_Im
                                            sal_uInt8 unoWrapperClass, sal_uInt8 comWrapperClass):
     UnoConversionUtilities<IUnknownWrapper_Impl>( xFactory, unoWrapperClass, comWrapperClass),
     m_pxIdlClass( NULL), m_eJScript( JScriptUndefined),
-    m_bComTlbIndexInit(false)
+    m_bComTlbIndexInit(false),  m_bHasDfltMethod(false), m_bHasDfltProperty(false)
 {
 }
 
@@ -150,17 +151,15 @@ IUnknownWrapper_Impl::~IUnknownWrapper_I
 Any IUnknownWrapper_Impl::queryInterface(const Type& t)
     throw (RuntimeException)
 {
-    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)))
-    {
-        if (m_spDispatch)
-            return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-                XInitialization, XAutomationObject>::queryInterface(t);
-        else
-            return Any();
-    }
+    if (t == getCppuType(static_cast<Reference<XDefaultMethod>*>( 0)) && !m_bHasDfltMethod )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XDefaultProperty>*>( 0)) && !m_bHasDfltProperty )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)) && !m_spDispatch)
+        return Any();
 
-    return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-        XInitialization, XAutomationObject>::queryInterface(t);
+    return WeakImplHelper6<XInvocation, XBridgeSupplier2,
+        XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>::queryInterface(t);
 }
 
 Reference<XIntrospectionAccess> SAL_CALL IUnknownWrapper_Impl::getIntrospection(void)
@@ -425,6 +424,46 @@ Any SAL_CALL IUnknownWrapper_Impl::getVa
     {
         o2u_attachCurrentThread();
         ITypeInfo * pInfo = getTypeInfo();
+        // I was going to implement an XServiceInfo interface to allow the type
+        // of the automation object to be exposed.. but it seems
+        // from looking at comments in the code that it is possible for a 
+        // this object to actually wrap an UNO object ( I guess if automation is
+        // used from MSO to create Openoffice objects ) Therefore, those objects
+        // will more than likely already have an XServiceInfo interface.
+        // Instead here I chose a name that should be illegal both in COM and
+        // UNO ( from an IDL point of view ) therefore I think this is a safe
+        // hack
+        if ( aPropertyName.equals( rtl::OUString::createFromAscii("$GetTypeName") )) 
+        {
+            if ( pInfo && m_sTypeName.getLength() == 0 )
+            {
+            	 m_sTypeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") );
+                CComBSTR sName;
+                
+                if ( SUCCEEDED( pInfo->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                {
+                    rtl::OUString sTmp( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                    if ( sTmp.indexOf('_')  == 0 )
+                       sTmp = sTmp.copy(1);
+                    // do we own the memory for pTypeLib, msdn doco is vague
+                    // I'll assume we do 
+                    CComPtr< ITypeLib > pTypeLib;
+                    unsigned int index;
+                    if ( SUCCEEDED(  pInfo->GetContainingTypeLib(  &pTypeLib.p, &index )) )
+                    {
+                        if ( SUCCEEDED( pTypeLib->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                        {
+                            rtl::OUString sLibName( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                            m_sTypeName = sLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sTmp );
+                            
+                        }
+                    }
+                }
+                
+            }
+            ret <<= m_sTypeName;
+            return ret;
+        }
         FuncDesc aDescGet(pInfo);
         FuncDesc aDescPut(pInfo);
         VarDesc aVarDesc(pInfo);
@@ -1157,6 +1196,47 @@ void SAL_CALL IUnknownWrapper_Impl::init
 
     aArguments[1] >>= m_bOriginalDispatch;    
     aArguments[2] >>= m_seqTypes;
+    try
+    {
+        ITypeInfo* pType= getTypeInfo();
+        // Get Default member
+        CComBSTR defaultMemberName;
+        if ( SUCCEEDED( pType->GetDocumentation(0, &defaultMemberName, 0, 0, 0 ) ) )
+        {
+            OUString usName(reinterpret_cast<const sal_Unicode*>(LPCOLESTR(defaultMemberName)));
+            FuncDesc aDescGet(pType);
+            FuncDesc aDescPut(pType);
+            VarDesc aVarDesc(pType);
+            // see if this is a property first ( more likely to be a property then a method )
+            getPropDesc( usName, & aDescGet, & aDescPut, & aVarDesc);
+
+            if ( !aDescGet && !aDescPut )
+            {
+                getFuncDesc( usName, &aDescGet );
+                if ( !aDescGet )
+                    // we're knackered
+                    throw RuntimeException();
+                
+            }
+            // now for some funny heuristics to make basic understand what to do
+            // a single aDescGet ( that doesn't take any params ) would be 
+            // a read only ( defaultmember ) property e.g. this object
+            // should implement XDefaultProperty
+            // a single aDescGet ( that *does* ) take params is basically a
+            // default method e.g. implement XDefaultMethod
+            
+            // a DescPut ( I guess we only really support a default param with '1' param ) as a setValue ( but I guess we can leave it through, the object will fail if we don't get it right anyway )
+            if ( aDescPut || ( aDescGet && aDescGet->cParams == 0 ) )
+                m_bHasDfltProperty = true;
+            if ( aDescGet->cParams > 0 )
+                m_bHasDfltMethod = true;
+            if ( m_bHasDfltProperty || m_bHasDfltMethod )
+                m_sDefaultMember = usName;
+        }
+    }
+    catch( Exception& )
+    {
+    } 
 }
 
 // UnoConversionUtilities --------------------------------------------------------------------------------
@@ -1408,6 +1488,9 @@ Any  IUnknownWrapper_Impl::invokeWithDis
         arDispidNamedArgs.reset(new DISPID[nSizeAr]);   
         HRESULT hr = getTypeInfo()->GetIDsOfNames(arNames, nSizeAr,
                                                   arDispidNamedArgs.get()); 
+        if ( hr == E_NOTIMPL )
+            hr = m_spDispatch->GetIDsOfNames(IID_NULL, arNames, nSizeAr, LOCALE_USER_DEFAULT, arDispidNamedArgs.get() );
+
         if (hr == S_OK)
         {
             // In a "property put" operation, the property value is a named param with the
--- extensions/source/ole/oleobjw.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/ole/oleobjw.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -53,11 +53,14 @@
 #endif
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
+#include <cppuhelper/implbase6.hxx>
 
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 #include <rtl/ustring.hxx>
 
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 
 #include <typelib/typedescription.hxx>
 #include "unoconversionutilities.hxx"
@@ -81,7 +84,8 @@ typedef hash_multimap<OUString, unsigned
 // This class wraps an IDispatch and maps XInvocation calls to IDispatch calls on the wrapped object.
 // If m_TypeDescription is set then this class represents an UNO interface implemented in a COM component.
 // The interface is not a real interface in terms of an abstract class but is realized through IDispatch.
-class IUnknownWrapper_Impl : public WeakImplHelper4<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject>,
+class IUnknownWrapper_Impl : public WeakImplHelper6<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>,
+
                              public UnoConversionUtilities<IUnknownWrapper_Impl>
 
 {
@@ -129,8 +133,10 @@ public:
     // XInitialization
     virtual void SAL_CALL initialize( const Sequence< Any >& aArguments )
         throw(Exception, RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
 protected:
-    
+    virtual ::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
+
     // ----------------------------------------------------------------------------
     virtual Any invokeWithDispIdUnoTlb(const OUString& sFunctionName,
                                        const Sequence< Any >& Params,
@@ -237,6 +243,7 @@ protected:
     Sequence<Type> m_seqTypes;
     CComPtr<IUnknown> m_spUnknown;
     CComPtr<IDispatch> m_spDispatch;
+        rtl::OUString m_sTypeName; // is "" ( not initialised ), "IDispatch" ( we have no idea ) or "SomeLibrary.SomeTypeName" if we managed to get a type
     /** This value is set dureing XInitialization::initialize. It indicates that the COM interface
     was transported as VT_DISPATCH in a VARIANT rather then a VT_UNKNOWN
     */
@@ -255,6 +262,9 @@ protected:
     bool m_bComTlbIndexInit;
     // Keeps the ITypeInfo obtained from IDispatch::GetTypeInfo
     CComPtr< ITypeInfo > m_spTypeInfo;
+    rtl::OUString m_sDefaultMember;
+    bool m_bHasDfltMethod;
+    bool m_bHasDfltProperty;
 };
 
 } // end namespace
--- extensions/source/propctrlr/defaultforminspection.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/defaultforminspection.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -154,7 +154,7 @@ namespace pcr
             { "com.sun.star.form.inspection.EventHandler", false },
 
             // a handler which introduces virtual properties for binding controls to spreadsheet cells
-            { "com.sun.star.form.inspection.CellBindingPropertyHandler", true },
+            { "com.sun.star.form.inspection.CellBindingPropertyHandler", false },
 
             // properties related to binding to an XForms DOM node
             { "com.sun.star.form.inspection.XMLFormsPropertyHandler", true },
--- extensions/source/propctrlr/eventhandler.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/eventhandler.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -66,6 +66,7 @@
 /** === end UNO includes === **/
 
 #include <comphelper/namedvaluecollection.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <comphelper/types.hxx>
 #include <cppuhelper/implbase1.hxx>
 #include <rtl/ref.hxx>
@@ -174,36 +175,6 @@ namespace pcr
     namespace
     {
         //....................................................................
-        Sequence< ::rtl::OUString > lcl_getListenerMethodsForType( const Type& type )
-        {
-            typelib_InterfaceTypeDescription *pType=0;
-            type.getDescription( (typelib_TypeDescription**)&pType);
-
-            if ( !pType )
-                return Sequence< ::rtl::OUString>();
-
-            Sequence< ::rtl::OUString > aNames( pType->nMembers );
-            ::rtl::OUString* pNames = aNames.getArray();
-            for ( sal_Int32 i = 0; i < pType->nMembers; ++i, ++pNames)
-            {
-                // the decription reference
-                typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-                // the description for the reference
-                typelib_TypeDescription* pMemberDescription = NULL;
-                typelib_typedescriptionreference_getDescription( &pMemberDescription, pMemberDescriptionReference );
-                if ( pMemberDescription )
-                {
-                    typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-                        reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-                    *pNames = pRealMemberDescription->pMemberName;
-                }
-            }
-
-            typelib_typedescription_release( (typelib_TypeDescription*)pType );
-            return aNames;
-        }
-
-        //....................................................................
         #define DESCRIBE_EVENT( asciinamespace, asciilistener, asciimethod, id_postfix ) \
             s_aKnownEvents.insert( EventMap::value_type( \
                 ::rtl::OUString::createFromAscii( asciimethod ), \
@@ -835,7 +806,7 @@ namespace pcr
                         continue;
 
                     // loop through all methods
-                    Sequence< ::rtl::OUString > aMethods( lcl_getListenerMethodsForType( *pListeners ) );
+                    Sequence< ::rtl::OUString > aMethods( comphelper::getEventMethodsForType( *pListeners ) );
 
                     const ::rtl::OUString* pMethods = aMethods.getConstArray();
                     sal_uInt32 methodCount = aMethods.getLength();
--- extensions/source/propctrlr/formmetadata.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/formmetadata.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -143,6 +143,7 @@ namespace pcr
         DEF_INFO_3( LABEL,             LABEL,              LABEL,             FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( CONTROLLABEL,      LABELCONTROL,       CONTROLLABEL,      FORM_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( WRITING_MODE,      WRITING_MODE,       WRITING_MODE,      FORM_VISIBLE, ENUM, COMPOSEABLE ),
+        DEF_INFO_3( GROUP_NAME,        GROUP_NAME,         GROUP_NAME,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( TEXT,              TEXT,               TEXT,              DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( MAXTEXTLEN,        MAXTEXTLEN,         MAXTEXTLEN,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( EDITMASK,          EDITMASK,           EDITMASK,          FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
--- extensions/source/propctrlr/formmetadata.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/formmetadata.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -166,6 +166,7 @@ namespace pcr
     #define PROPERTY_ID_ALLOWADDITIONS		 20
     #define PROPERTY_ID_ALLOWEDITS			 21
     #define PROPERTY_ID_ALLOWDELETIONS		 22
+	#define PROPERTY_ID_GROUP_NAME    		 23
     #define PROPERTY_ID_NAVIGATION			 24
     #define PROPERTY_ID_CYCLE				 25
     #define PROPERTY_ID_HIDDEN_VALUE		 26
--- extensions/source/propctrlr/formres.src.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/formres.src	2010-03-03 16:59:34.000000000 +0100
@@ -234,6 +234,10 @@ String RID_STR_NAME
 {
     Text [ en-US ] = "Name" ;
 };
+String RID_STR_GROUP_NAME
+{
+	Text [ en-US ] = "Group name" ;
+};
 String RID_STR_TABINDEX
 {
     Text [ en-US ] = "Tab order" ;
--- extensions/source/propctrlr/formresid.hrc.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/formresid.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -152,6 +152,7 @@
 #define RID_STR_CURSOR_TYPE					( RID_FORMBROWSER_START + 121 )
 #define RID_STR_ENABLE_VISIBLE              ( RID_FORMBROWSER_START + 122 )
 #define RID_STR_WHEEL_BEHAVIOR              ( RID_FORMBROWSER_START + 123 )
+#define RID_STR_GROUP_NAME                  ( RID_FORMBROWSER_START + 124 )
     // FREE
     // FREE
     // FREE
--- extensions/source/propctrlr/formstrings.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/source/propctrlr/formstrings.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -51,6 +51,7 @@ namespace pcr
     PCR_CONSTASCII_STRING( PROPERTY_WHEEL_BEHAVIOR,         "MouseWheelBehavior");
     PCR_CONSTASCII_STRING( PROPERTY_TAG,					"Tag");
     PCR_CONSTASCII_STRING( PROPERTY_NAME,					"Name");
+	PCR_CONSTASCII_STRING( PROPERTY_GROUP_NAME,             "GroupName");
     PCR_CONSTASCII_STRING( PROPERTY_VALUE,					"Value");
     PCR_CONSTASCII_STRING( PROPERTY_TEXT,					"Text");
     PCR_CONSTASCII_STRING( PROPERTY_NAVIGATION,				"NavigationBarMode");
--- extensions/util/hidother.src.old	2009-10-08 16:18:20.000000000 +0200
+++ extensions/util/hidother.src	2010-03-03 16:59:34.000000000 +0100
@@ -213,6 +213,7 @@ hidspecial HID_PROP_FOCUSONCLICK
 hidspecial HID_PROP_FONT                        { HelpId = HID_PROP_FONT; }
 hidspecial HID_PROP_FORMATKEY                   { HelpId = HID_PROP_FORMATKEY; }
 hidspecial HID_PROP_GROUPBOX                    { HelpId = HID_PROP_GROUPBOX; }
+hidspecial HID_PROP_GROUP_NAME                  { HelpId = HID_PROP_GROUP_NAME; }
 hidspecial HID_PROP_HEIGHT                      { HelpId = HID_PROP_HEIGHT; }
 hidspecial HID_PROP_HELPTEXT                    { HelpId = HID_PROP_HELPTEXT; }
 hidspecial HID_PROP_HELPURL                     { HelpId = HID_PROP_HELPURL; }
--- forms/source/component/FormComponent.cxx.old	2009-12-17 14:35:00.000000000 +0100
+++ forms/source/component/FormComponent.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -2753,8 +2753,8 @@ void SAL_CALL OBoundControlModel::setVal
     OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::setValueBinding: How did you reach this method?" );
         // the interface for this method should not have been exposed if we do not
         // support binding to external data
-
-    if ( !impl_approveValueBinding_nolock( _rxBinding ) )
+    // allow reset
+    if ( _rxBinding.is() && !impl_approveValueBinding_nolock( _rxBinding ) )
     {
         throw IncompatibleTypesException(
             FRM_RES_STRING( RID_STR_INCOMPATIBLE_TYPES ),
--- forms/source/component/GroupManager.cxx.old	2009-10-07 15:07:24.000000000 +0200
+++ forms/source/component/GroupManager.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -127,14 +127,13 @@ OGroupComp::OGroupComp(const Reference<X
     ,m_xControlModel(rxSet,UNO_QUERY)
     ,m_nPos( nInsertPos )
     ,m_nTabIndex(0)
+    ,m_aName( OGroupManager::GetGroupName( rxSet ) )
 {
     if (m_xComponent.is())
     {
         if (hasProperty( PROPERTY_TABINDEX, m_xComponent ) )
             // Indices kleiner 0 werden wie 0 behandelt
             m_nTabIndex = Max(getINT16(m_xComponent->getPropertyValue( PROPERTY_TABINDEX )) , sal_Int16(0));
-
-        m_xComponent->getPropertyValue( PROPERTY_NAME ) >>= m_aName;
     }
 }
 
@@ -321,7 +320,8 @@ void OGroupManager::removeFromGroupMap(c
         aFind->second.RemoveComponent( _xSet );
 
         // Wenn Anzahl der Gruppenelemente == 1 ist, Gruppe deaktivieren
-        if ( aFind->second.Count() == 1 )
+		sal_Int32 nCount = aFind->second.Count();
+		if ( nCount == 1 || nCount == 0 )
         {
             OActiveGroups::iterator aActiveFind = ::std::find(
                 m_aActiveGroupMap.begin(),
@@ -332,7 +332,7 @@ void OGroupManager::removeFromGroupMap(c
             {
                 // the group is active. Deactivate it if the remaining component
                 // is *no* radio button
-                if ( !isRadioButton( aFind->second.GetObject( 0 ) ) )
+                if ( nCount == 0 || !isRadioButton( aFind->second.GetObject( 0 ) ) )
                     m_aActiveGroupMap.erase( aActiveFind );
             }
         }
@@ -341,6 +341,8 @@ void OGroupManager::removeFromGroupMap(c
 
     // Bei Component als PropertyChangeListener abmelden
     _xSet->removePropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, _xSet))
+		_xSet->removePropertyChangeListener( PROPERTY_GROUP_NAME, this );
     if (hasProperty(PROPERTY_TABINDEX, _xSet))
         _xSet->removePropertyChangeListener( PROPERTY_TABINDEX, this );
 }
@@ -351,10 +353,23 @@ void SAL_CALL OGroupManager::propertyCha
 
     // Component aus Gruppe entfernen
     ::rtl::OUString		sGroupName;
-    if (evt.PropertyName == PROPERTY_NAME)
+	if (hasProperty( PROPERTY_GROUP_NAME, xSet ))
+		xSet->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+	if (evt.PropertyName == PROPERTY_NAME) {
+		if (sGroupName.getLength() > 0)
+			return; // group hasn't changed; ignore this name change.
+		// no GroupName; use Name as GroupNme
         evt.OldValue >>= sGroupName;
+	}
+	else if (evt.PropertyName == PROPERTY_GROUP_NAME) {
+		evt.OldValue >>= sGroupName;
+		if (sGroupName.getLength() == 0) {
+			// No prior GroupName; fallback to Nme
+			xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		}
+	}
     else
-        xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		sGroupName = GetGroupName( xSet );
 
     removeFromGroupMap(sGroupName,xSet);
 
@@ -437,8 +452,7 @@ void OGroupManager::InsertElement( const
     m_pCompGroup->InsertComponent( xSet );
 
     // Component in Gruppe aufnehmen
-    ::rtl::OUString sGroupName;
-    xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString sGroupName( GetGroupName( xSet ) );
 
     OGroupArr::iterator aFind = m_aGroupArr.find(sGroupName);
 
@@ -476,6 +490,8 @@ void OGroupManager::InsertElement( const
 
     // Bei Component als PropertyChangeListener anmelden
     xSet->addPropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, xSet))
+		xSet->addPropertyChangeListener( PROPERTY_GROUP_NAME, this );
 
     // Tabindex muss nicht jeder unterstuetzen
     if (hasProperty(PROPERTY_TABINDEX, xSet))
@@ -492,12 +508,26 @@ void OGroupManager::RemoveElement( const
         return;
 
     // Component aus Gruppe entfernen
-    ::rtl::OUString		sGroupName;
-    xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString		sGroupName( GetGroupName( xSet ) );
 
     removeFromGroupMap(sGroupName,xSet);
 }
 
+::rtl::OUString OGroupManager::GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent )
+{
+    if (!xComponent.is())
+        return ::rtl::OUString();
+    ::rtl::OUString sGroupName;
+    if (hasProperty( PROPERTY_GROUP_NAME, xComponent )) {
+        xComponent->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+        if (sGroupName.getLength() == 0)
+            xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    }
+    else
+        xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    return sGroupName;
+}
+
 //.........................................................................
 }	// namespace frm
 //.........................................................................
--- forms/source/component/GroupManager.hxx.old	2009-10-07 15:07:24.000000000 +0200
+++ forms/source/component/GroupManager.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -220,6 +220,8 @@ public:
     void getGroup(sal_Int32 nGroup, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup, ::rtl::OUString& Name);
     void getGroupByName(const ::rtl::OUString& Name, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup);
     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> > getControlModels();
+
+	static ::rtl::OUString GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent );
 };
 
 
--- forms/source/component/ListBox.cxx.old	2009-12-17 14:35:00.000000000 +0100
+++ forms/source/component/ListBox.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -1556,6 +1556,8 @@ namespace frm
     void SAL_CALL OListBoxControl::itemStateChanged(const ItemEvent& _rEvent) throw(RuntimeException)
     {
         // forward this to our listeners
+        Reference< XChild > xChild( getModel(), UNO_QUERY );
+        if ( xChild.is() && xChild->getParent().is() )
         {
             ::osl::MutexGuard aGuard( m_aMutex );
             if ( m_aItemListeners.getLength() )
@@ -1568,6 +1570,8 @@ namespace frm
                 m_pItemBroadcaster->addEvent( new ItemEventDescription( _rEvent ), this );
             }
         }
+        else
+            m_aItemListeners.notifyEach( &XItemListener::itemStateChanged, _rEvent );
 
         // and do the handling for the ChangeListeners
         ::osl::ClearableMutexGuard aGuard(m_aMutex);
--- forms/source/component/RadioButton.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ forms/source/component/RadioButton.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -31,6 +31,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_forms.hxx"
 #include "RadioButton.hxx"
+#include "GroupManager.hxx"
 #include "property.hxx"
 #ifndef _FRM_PROPERTY_HRC_
 #include "property.hrc"
@@ -122,6 +123,7 @@ ORadioButtonModel::ORadioButtonModel(con
     m_nClassId = FormComponentType::RADIOBUTTON;
     m_aLabelServiceName = FRM_SUN_COMPONENT_GROUPBOX;
     initValueProperty( PROPERTY_STATE, PROPERTY_ID_STATE );
+	startAggregatePropertyListening( PROPERTY_GROUP_NAME );
 }
 
 //------------------------------------------------------------------
@@ -169,7 +171,11 @@ StringSequence SAL_CALL	ORadioButtonMode
 void ORadioButtonModel::SetSiblingPropsTo(const ::rtl::OUString& rPropName, const Any& rValue)
 {
     // mein Name
-    ::rtl::OUString sMyName(m_aName);
+    ::rtl::OUString sMyGroup;
+    if (hasProperty(PROPERTY_GROUP_NAME, this))
+        this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sMyGroup;
+    if (sMyGroup.getLength() == 0)
+        sMyGroup = m_aName;
 
     // meine Siblings durchiterieren
     Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
@@ -177,8 +183,9 @@ void ORadioButtonModel::SetSiblingPropsT
     {
         Reference<XPropertySet> xMyProps;
         query_interface(static_cast<XWeak*>(this), xMyProps);
-        ::rtl::OUString	sCurrentName;
-        for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+		::rtl::OUString	sCurrentGroup;
+		sal_Int32 nNumSiblings = xIndexAccess->getCount();
+		for (sal_Int32 i=0; i<nNumSiblings; ++i)
         {
             Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
             if (!xSiblingProperties.is())
@@ -195,8 +202,8 @@ void ORadioButtonModel::SetSiblingPropsT
                 continue;
 
             // das 'zur selben Gruppe gehoeren' wird am Namen festgemacht
-            xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sCurrentName;
-            if (sCurrentName == sMyName)
+			sCurrentGroup = OGroupManager::GetGroupName( xSiblingProperties );
+			if (sCurrentGroup == sMyGroup)
                 xSiblingProperties->setPropertyValue(rPropName, rValue);
         }
     }
@@ -223,40 +230,7 @@ void ORadioButtonModel::setFastPropertyV
     // die andere Richtung : wenn sich mein Name aendert ...
     if (nHandle == PROPERTY_ID_NAME)
     {
-        // ... muss ich testen, ob ich Siblings mit dem selben Namen habe, damit ich deren ControlSource uebernehmen kann
-        Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
-        if (xIndexAccess.is())
-        {
-            ::rtl::OUString			sName;
-            ::rtl::OUString			sControlSource;
-
-            Reference<XPropertySet> xMyProps;
-            query_interface(static_cast<XWeak*>(this), xMyProps);
-            for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
-            {
-                Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
-                if (!xSiblingProperties.is())
-                    continue;
-
-                if (xMyProps == xSiblingProperties)
-                    // nur wenn ich nicht mich selber gefunden habe
-                    continue;
-
-                sal_Int16 nType = 0;
-                xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
-                if (nType != FormComponentType::RADIOBUTTON)
-                    // nur Radio-Buttons
-                    continue;
-
-                xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sName;
-                // Control, das zur gleichen Gruppe gehoert ?
-                if (rValue == sName)
-                {
-                    setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
-                    break;
-                }
-            }
-        }
+        setControlSource();
     }
 
     if (nHandle == PROPERTY_ID_DEFAULT_STATE)
@@ -274,6 +248,52 @@ void ORadioButtonModel::setFastPropertyV
     }
 }
 
+void ORadioButtonModel::setControlSource()
+{
+    Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
+    if (xIndexAccess.is())
+    {
+        ::rtl::OUString sName, sGroupName;
+
+        if (hasProperty(PROPERTY_GROUP_NAME, this))
+            this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sGroupName;
+        this->getPropertyValue(PROPERTY_NAME) >>= sName;
+
+        Reference<XPropertySet> xMyProps;
+        query_interface(static_cast<XWeak*>(this), xMyProps);
+        for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+        {
+            Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
+            if (!xSiblingProperties.is())
+                continue;
+
+            if (xMyProps == xSiblingProperties)
+                // nur wenn ich nicht mich selber gefunden habe
+                continue;
+
+            sal_Int16 nType = 0;
+            xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
+            if (nType != FormComponentType::RADIOBUTTON)
+                // nur Radio-Buttons
+                continue;
+
+            ::rtl::OUString sSiblingName, sSiblingGroupName;
+            if (hasProperty(PROPERTY_GROUP_NAME, xSiblingProperties))
+                xSiblingProperties->getPropertyValue(PROPERTY_GROUP_NAME) >>= sSiblingGroupName;
+            xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sSiblingName;
+
+            if ((sGroupName.getLength() == 0 && sSiblingGroupName.getLength() == 0 &&   // (no group name
+                 sName == sSiblingName) ||                                              //  names match) or
+                (sGroupName.getLength() != 0 && sSiblingGroupName.getLength() != 0 &&   // (have group name
+                 sGroupName == sSiblingGroupName))                                      //  they match)
+            {
+                setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
+                break;
+            }
+        }
+    }
+}
+
 //------------------------------------------------------------------------------
 void ORadioButtonModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
@@ -363,6 +383,13 @@ void ORadioButtonModel::_propertyChanged
             SetSiblingPropsTo( PROPERTY_STATE, aZero );
         }
     }
+    else if ( _rEvent.PropertyName.equals( PROPERTY_GROUP_NAME ) )
+    {
+        setControlSource();
+        // Can't call OReferenceValueComponent::_propertyChanged(), as it
+        // doesn't know what to do with the GroupName property.
+        return;
+    }
 
     OReferenceValueComponent::_propertyChanged( _rEvent );
 }
--- forms/source/component/RadioButton.hxx.old	2009-10-07 15:07:24.000000000 +0200
+++ forms/source/component/RadioButton.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -87,6 +87,8 @@ private:
             our mutex is aquired exactly once
     */
     void    setNewAggregateState( const ::com::sun::star::uno::Any& _rValue );
+
+    void setControlSource();
 };
 
 //==================================================================
--- forms/source/inc/InterfaceContainer.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ forms/source/inc/InterfaceContainer.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -275,6 +275,9 @@ protected:
     void implCheckIndex( const sal_Int32 _nIndex ) SAL_THROW( ( ::com::sun::star::lang::IndexOutOfBoundsException ) );
 
 private:
+	// hack for Vba Events
+	void fakeVbaEventsHack( sal_Int32 _nIndex );
+
     // the runtime event format has changed from version SO5.2 to OOo
     enum EventFormat
     {
--- forms/source/inc/frm_strings.hxx.old	2009-10-08 16:18:20.000000000 +0200
+++ forms/source/inc/frm_strings.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -100,6 +100,7 @@ namespace frm
     FORMS_CONSTASCII_STRING( PROPERTY_TABINDEX,                 "TabIndex" );
     FORMS_CONSTASCII_STRING( PROPERTY_TAG,                      "Tag" );
     FORMS_CONSTASCII_STRING( PROPERTY_NAME,                     "Name" );
+    FORMS_CONSTASCII_STRING( PROPERTY_GROUP_NAME,               "GroupName" );
     FORMS_CONSTASCII_STRING( PROPERTY_CLASSID,                  "ClassId" );
     FORMS_CONSTASCII_STRING( PROPERTY_FETCHSIZE,                "FetchSize" );
     FORMS_CONSTASCII_STRING( PROPERTY_VALUE,                    "Value" );
--- forms/source/inc/property.hrc.old	2009-10-08 16:18:20.000000000 +0200
+++ forms/source/inc/property.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -63,7 +63,7 @@ namespace frm
 #define PROPERTY_ID_INPUT_REQUIRED      (PROPERTY_ID_START + 19)
 #define PROPERTY_ID_WRITING_MODE        (PROPERTY_ID_START + 20)
 #define PROPERTY_ID_CONTEXT_WRITING_MODE    (PROPERTY_ID_START + 21)
-    // free
+#define PROPERTY_ID_GROUP_NAME          (PROPERTY_ID_START + 22)
     // free
     // free
     // free
--- forms/source/misc/InterfaceContainer.cxx.old	2009-10-08 16:18:20.000000000 +0200
+++ forms/source/misc/InterfaceContainer.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -31,42 +31,49 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_forms.hxx"
 
-#include "frm_resource.hrc"
-#include "frm_resource.hxx"
-#include "InterfaceContainer.hxx"
-#include "property.hrc"
-#include "services.hxx"
-
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/container/XNamed.hpp>
-#include <com/sun/star/io/WrongFormatException.hpp>
-#include <com/sun/star/io/XMarkableStream.hpp>
-#include <com/sun/star/lang/XComponent.hpp>
-#include <com/sun/star/util/XCloneable.hpp>
-
-#include <comphelper/container.hxx>
-#include <comphelper/enumhelper.hxx>
-#include <comphelper/eventattachermgr.hxx>
-#include <comphelper/property.hxx>
-#include <comphelper/sequence.hxx>
-#include <comphelper/types.hxx>
-#include <cppuhelper/exc_hlp.hxx>
-#include <cppuhelper/queryinterface.hxx>
-#include <rtl/logfile.hxx>
-#include <tools/debug.hxx>
-#include <tools/diagnose_ex.h>
+#include "frm_resource.hrc"
+#include "frm_resource.hxx"
+#include "InterfaceContainer.hxx"
+#include "property.hrc"
+#include "services.hxx"
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/io/WrongFormatException.hpp>
+#include <com/sun/star/io/XMarkableStream.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/util/XCloneable.hpp>
+
+#include <comphelper/container.hxx>
+#include <comphelper/enumhelper.hxx>
+#include <comphelper/eventattachermgr.hxx>
+#include <comphelper/property.hxx>
+#include <comphelper/sequence.hxx>
+#include <comphelper/types.hxx>
+#include <cppuhelper/exc_hlp.hxx>
+#include <cppuhelper/queryinterface.hxx>
+#include <rtl/logfile.hxx>
+#include <tools/debug.hxx>
+#include <tools/diagnose_ex.h>
 
-#include <algorithm>
-#include <memory>
+#include <algorithm>
+#include <memory>
 
 //.........................................................................
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <ooo/vba/XVBAToOOEventDescGen.hpp>
+#include <comphelper/processfactory.hxx>
+
 namespace frm
 {
 //.........................................................................
 
+using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::document;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::io;
@@ -82,6 +89,89 @@ namespace
     }
 }
 
+bool
+lcl_hasVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents  )
+{
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+			return true;
+	}
+	return false;
+}
+
+Sequence< ScriptEventDescriptor >
+lcl_stripVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents )
+{
+	Sequence< ScriptEventDescriptor > sStripped( sEvents.getLength() );
+	
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	sal_Int32 nCopied = 0;
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( !pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+		{
+			sStripped[ nCopied++ ] = *pDesc;
+		}
+	}
+	if ( nCopied )
+		sStripped.realloc( nCopied );
+	return sStripped;
+}
+
+void
+OInterfaceContainer::fakeVbaEventsHack(  sal_Int32 _nIndex )
+{
+	// we are dealing with form controls
+	try
+	{
+		Reference< XFormComponent > xForm( static_cast< XContainer* >(this), UNO_QUERY_THROW );
+		// grand-parent should be the model, no parent ? if not
+		// we'll ignore,  we'll get called back here  anyway )
+		Reference< XChild > xChild(  xForm->getParent(), UNO_QUERY_THROW );
+		Reference< XModel > xDocOwner( xChild->getParent(), UNO_QUERY );
+		OSL_TRACE(" Is DOC ????? %s", xDocOwner.is() ? "true" : "false" );
+		if ( xDocOwner.is() )
+		{
+			bool hasVBABindings = lcl_hasVbaEvents( m_xEventAttacher->getScriptEvents( _nIndex ) );  
+			if ( hasVBABindings )
+			{
+				OSL_TRACE("Has VBA bindings already, returning ");
+				return;
+			}
+			Reference< XMultiServiceFactory > xFac(  comphelper::getProcessServiceFactory(), UNO_QUERY );
+			Reference< XMultiServiceFactory > xDocFac(  xDocOwner, UNO_QUERY );
+			if ( xFac.is() && xDocFac.is() )
+			{
+				try
+				{
+					Reference< ooo::vba::XVBAToOOEventDescGen > xDescSupplier( xFac->createInstance( rtl::OUString::createFromAscii( "ooo.vba.VBAToOOEventDesc" ) ), UNO_QUERY_THROW );
+					Reference< XInterface > xIf( getByIndex( _nIndex ) , UNO_QUERY_THROW );
+					Reference< XCodeNameQuery > xNameQuery(  xDocFac->createInstance( rtl::OUString::createFromAscii( "ooo.vba.VBACodeNameProvider" ) ), UNO_QUERY_THROW );
+					rtl::OUString sCodeName;	
+					sCodeName = xNameQuery->getCodeNameForObject( xIf );
+					Reference< XPropertySet > xProps( xIf, UNO_QUERY );
+					rtl::OUString sServiceName;
+					xProps->getPropertyValue( rtl::OUString::createFromAscii("DefaultControl" ) ) >>= sServiceName;
+
+					Sequence< ScriptEventDescriptor > vbaEvents = xDescSupplier->getEventDescriptions( xFac->createInstance( sServiceName ), sCodeName );
+					// register the vba script events
+					if ( m_xEventAttacher.is() )
+						m_xEventAttacher->registerScriptEvents( _nIndex, vbaEvents );
+				}
+				catch( Exception& e ){ OSL_TRACE("lcl_fakevbaevents - Caught Exception trying to create control eventstuff "); }
+			}
+
+		}
+	}
+	catch( Exception& e )
+	{
+	}
+
+}
 //==================================================================
 //= ElementDescription
 //==================================================================
@@ -739,6 +829,7 @@ void OInterfaceContainer::approveNewElem
 void OInterfaceContainer::implInsert(sal_Int32 _nIndex, const Reference< XPropertySet >& _rxElement,
     sal_Bool _bEvents, ElementDescription* _pApprovalResult, sal_Bool _bFire ) throw( IllegalArgumentException )
 {
+        OSL_TRACE("OInterfaceContainer::implInsert( %d)", _nIndex );
     RTL_LOGFILE_CONTEXT( aLogger, "forms::OInterfaceContainer::implInsert" );
 
     ::osl::ClearableMutexGuard aGuard( m_rMutex );
@@ -788,6 +879,23 @@ void OInterfaceContainer::implInsert(sal
     {
         m_xEventAttacher->insertEntry(_nIndex);
         m_xEventAttacher->attach( _nIndex, pElementMetaData->xInterface, makeAny( _rxElement ) );
+		// insert fake events?
+		Reference< XEventAttacherManager > xMgr ( pElementMetaData->xInterface, UNO_QUERY );
+		if ( xMgr.is() )
+		{ 
+			OInterfaceContainer* pIfcMgr = dynamic_cast< OInterfaceContainer* >( xMgr.get() );
+			sal_Int32 nLen = pIfcMgr->getCount();
+			for ( sal_Int32 i = 0; (i < nLen) && pIfcMgr ; ++i )
+			{	
+				// add fake events to the control at index i
+				pIfcMgr->fakeVbaEventsHack( i );
+			}	
+		}
+		else
+		{
+			// add fake events to the control at index i
+			fakeVbaEventsHack(  _nIndex );	
+		}
     }
 
     // notify derived classes
@@ -1082,20 +1190,29 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvent( sal_Int32 nIndex, const ScriptEventDescriptor& aScriptEvent ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
         m_xEventAttacher->registerScriptEvent( nIndex, aScriptEvent );
+            fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvents( sal_Int32 nIndex, const Sequence< ScriptEventDescriptor >& aScriptEvents ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent(s) %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
         m_xEventAttacher->registerScriptEvents( nIndex, aScriptEvents );
+        fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::revokeScriptEvent( sal_Int32 nIndex, const ::rtl::OUString& aListenerType, const ::rtl::OUString& aEventMethod, const ::rtl::OUString& aRemoveListenerParam ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** revokeScriptEvent %d listenertype %s, eventMethod %s", nIndex, rtl::OUStringToOString( aListenerType, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( aEventMethod, RTL_TEXTENCODING_UTF8 ).getStr());
     if ( m_xEventAttacher.is() )
         m_xEventAttacher->revokeScriptEvent( nIndex, aListenerType, aEventMethod, aRemoveListenerParam );
 }
@@ -1124,9 +1241,16 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 Sequence< ScriptEventDescriptor > SAL_CALL OInterfaceContainer::getScriptEvents( sal_Int32 nIndex ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("getScriptEvents");
     Sequence< ScriptEventDescriptor > aReturn;
     if ( m_xEventAttacher.is() )
+    {
         aReturn = m_xEventAttacher->getScriptEvents( nIndex );
+            if ( lcl_hasVbaEvents( aReturn ) )
+            {
+                aReturn = lcl_stripVbaEvents( aReturn );
+            }
+    }
     return aReturn;
 }
 
--- forms/source/misc/makefile.mk.old	2009-10-07 15:07:24.000000000 +0200
+++ forms/source/misc/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -45,6 +45,7 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Types -------------------------------------
 
 INCPRE+=$(SOLARINCDIR)$/offuh
+INCPRE*=$(INCCOM)$/$(TARGET)
 
 # --- Files -------------------------------------
 
@@ -62,3 +63,12 @@ SLOFILES=	$(SLO)$/limitedformats.obj \
 
 .INCLUDE : target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
--- formula/inc/formula/FormulaCompiler.hxx.old	2010-03-03 16:59:13.000000000 +0100
+++ formula/inc/formula/FormulaCompiler.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -222,6 +222,8 @@ public:
     void            SetCompileForFAP( BOOL bVal )
                         { bCompileForFAP = bVal; bIgnoreErrors = bVal; }
 
+    static bool IsOpCodeVolatile( OpCode eOp );
+
     static BOOL DeQuote( String& rStr );
 
     static const String&    GetNativeSymbol( OpCode eOp );
--- formula/source/core/api/FormulaCompiler.cxx.old	2010-03-03 16:59:13.000000000 +0100
+++ formula/source/core/api/FormulaCompiler.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -744,6 +744,30 @@ OpCode FormulaCompiler::GetEnglishOpCode
     return bFound ? (*iLook).second : OpCode(ocNone);
 }
 
+bool FormulaCompiler::IsOpCodeVolatile( OpCode eOp )
+{
+    switch (eOp)
+    {
+        // no parameters:
+        case ocRandom:
+        case ocGetActDate:
+        case ocGetActTime:
+        // one parameter:
+        case ocFormula:
+        case ocInfo:
+        // more than one parameters:
+            // ocIndirect/ocIndirectXL otherwise would have to do
+            // StopListening and StartListening on a reference for every
+            // interpreted value.
+        case ocIndirect:
+        case ocIndirectXL:
+            // ocOffset results in indirect references.
+        case ocOffset:
+            return true;
+    }
+    return false;
+}
+
 // Remove quotes, escaped quotes are unescaped.
 BOOL FormulaCompiler::DeQuote( String& rStr )
 {
@@ -960,44 +984,32 @@ void FormulaCompiler::Factor()
     {
         if( nNumFmt == NUMBERFORMAT_UNDEFINED )
             nNumFmt = lcl_GetRetFormat( eOp );
-        // Functions that have to be always recalculated
-        switch( eOp )
+
+        if ( IsOpCodeVolatile(eOp) )
+            pArr->SetRecalcModeAlways();
+        else
         {
-            // no parameters:
-            case ocRandom:
-            case ocGetActDate:
-            case ocGetActTime:
-            // one parameter:
-            case ocFormula:
-            case ocInfo:
-            // more than one parameters:
-                // ocIndirect/ocIndirectXL otherwise would have to do
-                // StopListening and StartListening on a reference for every
-                // interpreted value.
-            case ocIndirect:
-            case ocIndirectXL:
-                // ocOffset results in indirect references.
-            case ocOffset:
-                pArr->SetRecalcModeAlways();
-            break;
-                // Functions recalculated on every document load.
-                // Don't use SetRecalcModeOnLoad() which would override
-                // ModeAlways.
-            case ocConvert :
-                pArr->AddRecalcMode( RECALCMODE_ONLOAD );
-            break;
-                // If the referred cell is moved the value changes.
-            case ocColumn :
-            case ocRow :
-                // ocCell needs recalc on move for some possible type values.
-            case ocCell :
-                pArr->SetRecalcModeOnRefMove();
-            break;
-            case ocHyperLink :
-                pArr->SetHyperLink(TRUE);
-            break;
-            default:
-                ;   // nothing
+            switch( eOp )
+            {
+                    // Functions recalculated on every document load.
+                    // Don't use SetRecalcModeOnLoad() which would override
+                    // ModeAlways.
+                case ocConvert :
+                    pArr->AddRecalcMode( RECALCMODE_ONLOAD );
+                break;
+                    // If the referred cell is moved the value changes.
+                case ocColumn :
+                case ocRow :
+                    // ocCell needs recalc on move for some possible type values.
+                case ocCell :
+                    pArr->SetRecalcModeOnRefMove();
+                break;
+                case ocHyperLink :
+                    pArr->SetHyperLink(TRUE);
+                break;
+                default:
+                    ;   // nothing
+            }
         }
         if (SC_OPCODE_START_NO_PAR <= eOp && eOp < SC_OPCODE_STOP_NO_PAR)
         {
--- framework/inc/uielement/generictoolbarcontroller.hxx.old	2009-10-07 15:06:59.000000000 +0200
+++ framework/inc/uielement/generictoolbarcontroller.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -37,6 +37,9 @@
 
 #include <svtools/toolboxcontroller.hxx>
 #include <vcl/toolbox.hxx>
+#include <memory>
+
+class PopupMenu;
 
 namespace framework
 {
@@ -64,7 +67,7 @@ class GenericToolbarController : public
 
          DECL_STATIC_LINK( GenericToolbarController, ExecuteHdl_Impl, ExecuteInfo* ); 
     
-    private:
+    protected:
         ToolBox*        m_pToolbar;
         sal_uInt16      m_nID;
         sal_Bool        m_bEnumCommand : 1,
@@ -72,6 +75,28 @@ class GenericToolbarController : public
         rtl::OUString   m_aEnumCommand;
 };
 
+class MenuToolbarController : public GenericToolbarController
+{
+    com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess > m_xMenuDesc;
+    PopupMenu* pMenu;
+    com::sun::star::uno::Reference< com::sun::star::lang::XComponent > m_xMenuManager;
+    rtl::OUString m_aModuleIdentifier;
+    public:
+        MenuToolbarController( const com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory >& rServiceManager, 
+                                  const com::sun::star::uno::Reference< com::sun::star::frame::XFrame >& rFrame,
+                                  ToolBox* pToolBar,
+                                  USHORT   nID,
+                                  const rtl::OUString& aCommand, 
+                                  const rtl::OUString& aModuleIdentifier, 
+                                  const com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess >& xMenuDesc );
+
+    ~MenuToolbarController();
+    // XToolbarController
+    virtual void SAL_CALL click() throw ( ::com::sun::star::uno::RuntimeException );
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindow > SAL_CALL createPopupWindow() throw (::com::sun::star::uno::RuntimeException);
+
+};
+
 }
 
 #endif // __FRAMEWORK_UIELEMENT_GENERICTOOLBARCONTROLLER_HXX_
--- framework/inc/uielement/toolbarmanager.hxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/inc/uielement/toolbarmanager.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -50,10 +50,12 @@
 #include <com/sun/star/lang/XComponent.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/frame/XUIControllerRegistration.hpp>
 #include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/XUIConfigurationManager.hpp>
 #include <com/sun/star/frame/XStatusListener.hpp>
 #include <com/sun/star/frame/XSubToolbarController.hpp>
 #include <com/sun/star/frame/XToolbarController.hpp>
@@ -200,6 +202,7 @@ class ToolBarManager : public ::com::sun
         typedef ::std::vector< ::com::sun::star::uno::Reference< ::com::sun::star::frame::XSubToolbarController > > SubToolBarControllerVector;
         typedef BaseHash< SubToolBarControllerVector >                                                              SubToolBarToSubToolBarControllerMap;
 
+        typedef ::std::hash_map< sal_uInt16, ::com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess > > MenuDescriptionMap;
         sal_Bool                                                                               m_bDisposed : 1,
                                                                                                m_bIsHiContrast : 1,
                                                                                                m_bSmallSymbols : 1,
@@ -225,10 +228,14 @@ class ToolBarManager : public ::com::sun
         ::com::sun::star::uno::Reference< ::com::sun::star::ui::XImageManager >                m_xModuleImageManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::ui::XImageManager >                m_xDocImageManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::lang::XComponent >                 m_xImageOrientationListener;
+        ::com::sun::star::uno::Reference< ::com::sun::star::ui::XUIConfigurationManager >                m_xUICfgMgr;
+        ::com::sun::star::uno::Reference< ::com::sun::star::ui::XUIConfigurationManager >                m_xDocUICfgMgr;
+
         CommandToInfoMap                                                                       m_aCommandMap;
         SubToolBarToSubToolBarControllerMap                                                    m_aSubToolBarControllerMap;
         Timer				                                                                   m_aAsyncUpdateControllersTimer;
         sal_Int16                                                                              m_nSymbolsStyle;
+        MenuDescriptionMap m_aMenuMap;
 };
     
 }
--- framework/inc/xml/menuconfiguration.hxx.old	2009-10-07 15:06:59.000000000 +0200
+++ framework/inc/xml/menuconfiguration.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -85,6 +85,7 @@ class MenuConfiguration
             ::rtl::OUString aTargetFrame;
             ::rtl::OUString	aImageId;
             ::com::sun::star::uno::WeakReference< ::com::sun::star::frame::XDispatchProvider > xDispatchProvider;
+                        sal_Int16 nStyle;
         };
                         
         MenuConfiguration(
--- framework/inc/xml/menudocumenthandler.hxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/inc/xml/menudocumenthandler.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -109,13 +109,14 @@ class ReadMenuDocumentHandlerBase : publ
         ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler> m_xReader;
         void initPropertyCommon( com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue > &rProps,
                                  const rtl::OUString &rCommandURL, const rtl::OUString &rHelpId,
-                                 const rtl::OUString &rLabel);
+                                 const rtl::OUString &rLabel, sal_Int16 nItemStyleBits );
     private:
         rtl::OUString m_aType;
         rtl::OUString m_aLabel;
         rtl::OUString m_aContainer;
         rtl::OUString m_aHelpURL;
         rtl::OUString m_aCommandURL;
+        rtl::OUString m_aStyle;
         ::com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue > m_aItemProp;
 };
 
@@ -306,7 +307,7 @@ class OWriteMenuDocumentHandler
         virtual void WriteMenu( const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >& rSubMenuContainer ) throw
             ( ::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException );
 
-        virtual void WriteMenuItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL );
+        virtual void WriteMenuItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL, sal_Int16 nStyle = 0 );
         virtual void WriteMenuSeparator();
 
         com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess > m_xMenuBarContainer;
--- framework/inc/xml/toolboxconfigurationdefines.hxx.old	2009-10-07 15:06:59.000000000 +0200
+++ framework/inc/xml/toolboxconfigurationdefines.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -29,6 +29,7 @@
 #define ATTRIBUTE_WIDTH				"width"
 #define ATTRIBUTE_USER				"userdefined"
 #define ATTRIBUTE_HELPID			"helpid"
+#define ATTRIBUTE_TOOLTIP			"tooltip"
 #define ATTRIBUTE_ITEMSTYLE			"style"
 
 #define ATTRIBUTE_ID				"id"
@@ -78,6 +79,8 @@
 #define ATTRIBUTE_ITEMSTYLE_AUTOSIZE	    "autosize"
 #define ATTRIBUTE_ITEMSTYLE_DROPDOWN	    "dropdown"
 #define ATTRIBUTE_ITEMSTYLE_REPEAT		    "repeat"
+#define ATTRIBUTE_ITEMSTYLE_TEXT    "text"
 #define ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY    "dropdownonly"
+#define ATTRIBUTE_ITEMSTYLE_IMAGE    "image"
 
 #endif // __FRAMEWORK_XML_TOOLBOXCONFIGURATIONDEFINES_HXX_
--- framework/inc/xml/toolboxdocumenthandler.hxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/inc/xml/toolboxdocumenthandler.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -77,6 +77,7 @@ class OReadToolBoxDocumentHandler : priv
             TB_ATTRIBUTE_HELPID,
             TB_ATTRIBUTE_STYLE,
             TB_ATTRIBUTE_UINAME,
+            TB_ATTRIBUTE_TOOLTIP,
             TB_XML_ENTRY_COUNT
         };
 
@@ -159,10 +160,13 @@ class OReadToolBoxDocumentHandler : priv
         sal_Int32																	    m_nHashCode_Style_DropDown;
         sal_Int32																	    m_nHashCode_Style_Repeat;
         sal_Int32                                                                       m_nHashCode_Style_DropDownOnly;
+        sal_Int32                                                                       m_nHashCode_Style_Text;
+        sal_Int32                                                                       m_nHashCode_Style_Image;
         rtl::OUString                                                                   m_aType;
         rtl::OUString                                                                   m_aLabel;
         rtl::OUString                                                                   m_aStyle;
         rtl::OUString                                                                   m_aHelpURL;
+        rtl::OUString                                                                   m_aTooltip;
         rtl::OUString                                                                   m_aIsVisible;
         rtl::OUString                                                                   m_aCommandURL;
 };
@@ -181,7 +185,7 @@ class OWriteToolBoxDocumentHandler : pri
               ::com::sun::star::uno::RuntimeException );
     
     protected:
-        virtual void WriteToolBoxItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL,
+        virtual void WriteToolBoxItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL, const rtl::OUString& aTooltip, sal_Int16 nStyle,
                                        sal_Int16 nWidth, sal_Bool bVisible ) throw
             ( ::com::sun::star::xml::sax::SAXException,
               ::com::sun::star::uno::RuntimeException );
--- framework/source/classes/menumanager.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/source/classes/menumanager.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -171,6 +171,12 @@ MenuManager::MenuManager(
     for ( USHORT i = 0; i < nItemCount; i++ )
     {
         USHORT nItemId = FillItemCommand(aItemCommand,pMenu, i );
+        bool bShowMenuImages( m_bShowMenuImages );
+        MenuItemBits nBits =  pMenu->GetItemBits( nItemId );
+        // overwrite the default?
+        if ( nBits )
+            bShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
+
 
         PopupMenu* pPopupMenu = pMenu->GetPopupMenu( nItemId );
         if ( pPopupMenu )
@@ -217,7 +223,7 @@ MenuManager::MenuManager(
                             aQueryLabelItemIdVector.push_back( nItemId );
 #endif
                         // Set image for the addon popup menu item
-                        if ( m_bShowMenuImages && !pPopupMenu->GetItemImage( ITEMID_ADDONLIST ))
+                        if ( bShowMenuImages && !pPopupMenu->GetItemImage( ITEMID_ADDONLIST ))
                         {
                             Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                             if ( !!aImage )
@@ -249,7 +255,7 @@ MenuManager::MenuManager(
                     aQueryLabelItemIdVector.push_back( nItemId );
 #endif
                 
-                if ( m_bShowMenuImages && !pMenu->GetItemImage( nItemId ))
+                if ( bShowMenuImages && !pMenu->GetItemImage( nItemId ))
                 {
                     Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                     if ( !!aImage )
@@ -274,7 +280,7 @@ MenuManager::MenuManager(
                     aQueryLabelItemIdVector.push_back( nItemId );
 #endif
                 
-                if ( m_bShowMenuImages && !pMenu->GetItemImage( nItemId ))
+                if ( bShowMenuImages && !pMenu->GetItemImage( nItemId ))
                 {
                     Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                     if ( !!aImage )
@@ -283,7 +289,7 @@ MenuManager::MenuManager(
             }
             else if ( pMenu->GetItemType( i ) != MENUITEM_SEPARATOR )
             {
-                if ( m_bShowMenuImages )
+                if ( bShowMenuImages )
                 {
                     if ( AddonMenuManager::IsAddonMenuId( nItemId ))
                     {
@@ -1131,7 +1137,13 @@ void MenuManager::FillMenuImages(Referen
         USHORT nId = _pMenu->GetItemId( nPos );
         if ( _pMenu->GetItemType( nPos ) != MENUITEM_SEPARATOR )
         {
-            if ( bShowMenuImages )
+            bool bTmpShowMenuImages( bShowMenuImages );
+            MenuItemBits nBits =  _pMenu->GetItemBits( nId );
+            // overwrite the default?
+            if ( nBits )
+                bTmpShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
+
+            if ( bTmpShowMenuImages )
             {
                 sal_Bool		bImageSet = sal_False;
                 ::rtl::OUString aImageId;
--- framework/source/uielement/generictoolbarcontroller.cxx.old	2009-10-07 15:06:59.000000000 +0200
+++ framework/source/uielement/generictoolbarcontroller.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -68,6 +68,9 @@
 #include <classes/fwkresid.hxx>
 #include <dispatch/uieventloghelper.hxx>
 
+#include <xml/menuconfiguration.hxx>
+#include <uielement/menubarmanager.hxx>
+
 using namespace ::com::sun::star::awt;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
@@ -75,6 +78,7 @@ using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::frame::status;
 using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::container;
 
 namespace framework
 {
@@ -326,5 +330,67 @@ IMPL_STATIC_LINK_NOINSTANCE( GenericTool
    return 0;
 }
 
+MenuToolbarController::MenuToolbarController( const Reference< XMultiServiceFactory >& rServiceManager, const Reference< XFrame >& rFrame, ToolBox* pToolBar, USHORT   nID, const rtl::OUString& aCommand, const rtl::OUString& aModuleIdentifier, const Reference< XIndexAccess >& xMenuDesc ) : GenericToolbarController( rServiceManager, rFrame, pToolBar, nID, aCommand ), m_xMenuDesc( xMenuDesc ), pMenu( NULL ), m_aModuleIdentifier( aModuleIdentifier )
+{
+}
+
+MenuToolbarController::~MenuToolbarController()
+{
+    try
+    {
+        if ( m_xMenuManager.is() )
+            m_xMenuManager->dispose();
+    }
+    catch( Exception& ) {}
+    if ( pMenu )
+    {
+        delete pMenu;
+        pMenu = NULL;
+    }
+ 
+}
+
+class Toolbarmenu : public PopupMenu
+{
+    public:
+    Toolbarmenu();
+    ~Toolbarmenu();
+};
+
+Toolbarmenu::Toolbarmenu()
+{
+    OSL_TRACE("**** contstructing Toolbarmenu 0x%x", this );
+}
+
+Toolbarmenu::~Toolbarmenu()
+{
+    OSL_TRACE("**** destructing Toolbarmenu 0x%x", this );
+}
+
+void SAL_CALL MenuToolbarController::click() throw (RuntimeException)
+{
+    createPopupWindow();
+}
+
+Reference< XWindow > SAL_CALL 
+MenuToolbarController::createPopupWindow() throw (::com::sun::star::uno::RuntimeException)
+{
+    if ( !pMenu ) 
+    {
+        Reference< XDispatchProvider > xDispatch;
+        Reference< XURLTransformer > xURLTransformer( m_xServiceManager->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.util.URLTransformer" ))), UNO_QUERY );
+        pMenu = new Toolbarmenu();
+        m_xMenuManager.set( new MenuBarManager( m_xServiceManager, m_xFrame, xURLTransformer, xDispatch, m_aModuleIdentifier, pMenu, sal_True, sal_True ) );
+        if ( m_xMenuManager.is() )
+        {
+            MenuBarManager* pMgr = dynamic_cast< MenuBarManager* >( m_xMenuManager.get() );
+            pMgr->SetItemContainer( m_xMenuDesc );
+        }
+    }
+
+    ::Rectangle aRect( m_pToolbar->GetItemRect( m_nID ) );
+    pMenu->Execute( m_pToolbar, aRect, POPUPMENU_EXECUTE_DOWN );
+    return NULL; 
+}
 } // namespace
 
--- framework/source/uielement/menubarmanager.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/source/uielement/menubarmanager.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -74,6 +74,7 @@
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
 #include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
 #include <com/sun/star/frame/status/Visibility.hpp>
 
 //_________________________________________________________________________________________________________________
@@ -136,6 +137,7 @@ static const char ITEM_DESCRIPTOR_LABEL[
 static const char ITEM_DESCRIPTOR_TYPE[]              = "Type";
 static const char ITEM_DESCRIPTOR_MODULEIDENTIFIER[]  = "ModuleIdentifier";
 static const char ITEM_DESCRIPTOR_DISPATCHPROVIDER[]  = "DispatchProvider";
+static const char   ITEM_DESCRIPTOR_STYLE[]         = "Style";
 
 const sal_Int32   LEN_DESCRIPTOR_COMMANDURL           = 10;
 const sal_Int32   LEN_DESCRIPTOR_HELPURL              = 7;
@@ -144,6 +146,7 @@ const sal_Int32   LEN_DESCRIPTOR_LABEL
 const sal_Int32   LEN_DESCRIPTOR_TYPE                 = 4;
 const sal_Int32   LEN_DESCRIPTOR_MODULEIDENTIFIER     = 16;
 const sal_Int32   LEN_DESCRIPTOR_DISPATCHPROVIDER     = 16;
+static const sal_Int32 ITEM_DESCRIPTOR_STYLE_LEN       = 5;
 
 const sal_uInt16 ADDONMENU_MERGE_ITEMID_START = 1500;
 
@@ -1327,6 +1330,11 @@ void MenuBarManager::FillMenuManager( Me
         Reference< XDispatch > xDispatch;
         Reference< XStatusListener > xStatusListener;
         PopupMenu* pPopup = pMenu->GetPopupMenu( nItemId );
+        bool bItemShowMenuImages = m_bShowMenuImages;
+        MenuItemBits nBits =  pMenu->GetItemBits( nItemId );
+        // overwrite the show icons on menu option?
+        if ( nBits )
+            bItemShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
         if ( pPopup )
         {
             // Retrieve module identifier from Help Command entry
@@ -1422,7 +1430,7 @@ void MenuBarManager::FillMenuManager( Me
                         pSubMenuManager->m_aMenuItemCommand = ::rtl::OUString();
 
                         // Set image for the addon popup menu item
-                        if ( m_bShowMenuImages && !pPopup->GetItemImage( ITEMID_ADDONLIST ))
+			            if ( bItemShowMenuImages && !pPopup->GetItemImage( ITEMID_ADDONLIST ))
                         {
                             Reference< XFrame > xTemp( rFrame );
                             Image aImage = GetImageFromURL( xTemp, aItemCommand, FALSE, m_bWasHiContrast );
@@ -1441,7 +1449,7 @@ void MenuBarManager::FillMenuManager( Me
         }
         else if ( pMenu->GetItemType( i ) != MENUITEM_SEPARATOR )
         {
-            if ( m_bShowMenuImages )
+            if ( bItemShowMenuImages )
             {
                 if ( AddonMenuManager::IsAddonMenuId( nItemId ))
                 {
@@ -1752,7 +1760,7 @@ void MenuBarManager::FillMenu(
         sal_uInt16                      nType = 0;
         Reference< XIndexAccess >       xIndexContainer;
         Reference< XDispatchProvider >  xDispatchProvider( rDispatchProvider );
-
+        sal_Int16 nStyle = 0;
         try
         {
             if ( rItemContainer->getByIndex( n ) >>= aProp )
@@ -1781,6 +1789,8 @@ void MenuBarManager::FillMenu(
                     else if ( aPropName.equalsAsciiL( ITEM_DESCRIPTOR_DISPATCHPROVIDER,
                                                       LEN_DESCRIPTOR_DISPATCHPROVIDER ))
                         aProp[i].Value >>= xDispatchProvider;
+                   else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_STYLE, ITEM_DESCRIPTOR_STYLE_LEN ))
+                        aProp[i].Value >>= nStyle;
                 }
 
                 if ( nType == ::com::sun::star::ui::ItemType::DEFAULT )
@@ -1791,7 +1801,15 @@ void MenuBarManager::FillMenu(
                     sal_Int32 nHelpId = aHelpURL.toInt32();
                     if ( nHelpId > 0 )
                         pMenu->SetHelpId( nId, (USHORT)nHelpId );
-
+                    if ( nStyle )
+                    {
+                        MenuItemBits nBits = pMenu->GetItemBits( nId );
+                        if ( nStyle & ::com::sun::star::ui::ItemStyle::ICON )
+                           nBits |= MIB_ICON;
+                        if ( nStyle & ::com::sun::star::ui::ItemStyle::TEXT )
+                           nBits |= MIB_TEXT;
+                        pMenu->SetItemBits( nId, nBits );
+                    } 
                     if ( xIndexContainer.is() )
                     {
                         PopupMenu* pNewPopupMenu = new PopupMenu;
--- framework/source/uielement/toolbarmanager.cxx.old	2010-01-21 01:00:49.000000000 +0100
+++ framework/source/uielement/toolbarmanager.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -71,7 +71,6 @@
 #include <com/sun/star/lang/XMultiComponentFactory.hpp>
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/ui/XUIElementSettings.hpp>
-#include <com/sun/star/container/XIndexContainer.hpp>
 #include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
 #include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
 #include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
@@ -122,6 +121,7 @@ namespace framework
 
 static const char   ITEM_DESCRIPTOR_COMMANDURL[]    = "CommandURL";
 static const char   ITEM_DESCRIPTOR_HELPURL[]       = "HelpURL";
+static const char   ITEM_DESCRIPTOR_TOOLTIP[]       = "Tooltip";
 static const char   ITEM_DESCRIPTOR_CONTAINER[]     = "ItemDescriptorContainer";
 static const char   ITEM_DESCRIPTOR_LABEL[]         = "Label";
 static const char   ITEM_DESCRIPTOR_TYPE[]          = "Type";
@@ -131,6 +131,7 @@ static const char   ITEM_DESCRIPTOR_STYL
 
 static const sal_Int32 ITEM_DESCRIPTOR_COMMANDURL_LEN  = 10;
 static const sal_Int32 ITEM_DESCRIPTOR_HELPURL_LEN     = 7;
+static const sal_Int32 ITEM_DESCRIPTOR_TOOLTIP_LEN     = 7;
 static const sal_Int32 ITEM_DESCRIPTOR_CONTAINER_LEN   = 23;
 static const sal_Int32 ITEM_DESCRIPTOR_LABEL_LEN       = 5;
 static const sal_Int32 ITEM_DESCRIPTOR_TYPE_LEN        = 4;
@@ -143,6 +144,7 @@ static const char   HELPID_PREFIX_TESTTO
 //static sal_Int32    HELPID_PREFIX_LENGTH            = 7;
 static const USHORT STARTID_CUSTOMIZE_POPUPMENU     = 1000;
 
+#define MENUPREFIX "private:resource/menubar/"
 
 class ImageOrientationListener : public svt::FrameStatusListener
 {
@@ -968,8 +970,13 @@ void ToolBarManager::CreateControllers()
                 }
                 else
                 {
-                    xController = Reference< XStatusListener >(
-                        new GenericToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL ));
+                    MenuDescriptionMap::iterator it = m_aMenuMap.find( nId );
+                    if ( it == m_aMenuMap.end() )
+                        xController = Reference< XStatusListener >(
+                            new GenericToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL ));
+                    else
+                        xController = Reference< XStatusListener >(
+                            new MenuToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL, m_aModuleIdentifier, m_aMenuMap[ nId ] ));
                 }
             }
             else if ( pController )
@@ -1101,6 +1108,10 @@ sal_uInt16 ToolBarManager::ConvertStyleT
         nItemBits |= TIB_REPEAT;
     if ( nStyle & ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY )
         nItemBits |= TIB_DROPDOWNONLY;
+    if ( nStyle & ::com::sun::star::ui::ItemStyle::TEXT )
+        nItemBits |= TIB_TEXT_ONLY;
+    if ( nStyle & ::com::sun::star::ui::ItemStyle::ICON )
+        nItemBits |= TIB_ICON_ONLY;
 
     return nItemBits;
 }
@@ -1130,8 +1141,8 @@ void ToolBarManager::FillToolbar( const
             Reference< XUIConfigurationManagerSupplier > xSupplier( xModel, UNO_QUERY );
             if ( xSupplier.is() )
             {
-                Reference< XUIConfigurationManager > xDocUICfgMgr( xSupplier->getUIConfigurationManager(), UNO_QUERY );
-                m_xDocImageManager = Reference< XImageManager >( xDocUICfgMgr->getImageManager(), UNO_QUERY );
+                m_xDocUICfgMgr.set( xSupplier->getUIConfigurationManager(), UNO_QUERY );
+                m_xDocImageManager = Reference< XImageManager >( m_xDocUICfgMgr->getImageManager(), UNO_QUERY );
                 m_xDocImageManager->addConfigurationListener(
                                         Reference< XUIConfigurationListener >(
                                             static_cast< OWeakObject* >( this ), UNO_QUERY ));
@@ -1153,8 +1164,8 @@ void ToolBarManager::FillToolbar( const
         Reference< XModuleUIConfigurationManagerSupplier > xModuleCfgMgrSupplier( m_xServiceManager->createInstance(
                                                                                     SERVICENAME_MODULEUICONFIGURATIONMANAGERSUPPLIER ),
                                                                                   UNO_QUERY );
-        Reference< XUIConfigurationManager > xUICfgMgr = xModuleCfgMgrSupplier->getUIConfigurationManager( m_aModuleIdentifier );
-        m_xModuleImageManager = Reference< XImageManager >( xUICfgMgr->getImageManager(), UNO_QUERY );
+        m_xUICfgMgr = xModuleCfgMgrSupplier->getUIConfigurationManager( m_aModuleIdentifier );
+        m_xModuleImageManager = Reference< XImageManager >( m_xUICfgMgr->getImageManager(), UNO_QUERY );
         m_xModuleImageManager->addConfigurationListener( Reference< XUIConfigurationListener >(
                                                             static_cast< OWeakObject* >( this ), UNO_QUERY ));
     }
@@ -1166,6 +1177,8 @@ void ToolBarManager::FillToolbar( const
     m_aControllerMap.clear();
     m_aCommandMap.clear();
 
+    m_aMenuMap.clear();
+
     CommandInfo aCmdInfo;
     for ( sal_Int32 n = 0; n < rItemContainer->getCount(); n++ )
     {
@@ -1173,11 +1186,13 @@ void ToolBarManager::FillToolbar( const
         rtl::OUString               aCommandURL;
         rtl::OUString               aLabel;
         rtl::OUString               aHelpURL;
+        rtl::OUString               aTooltip;
         sal_uInt16                  nType( ::com::sun::star::ui::ItemType::DEFAULT );
         sal_uInt16                  nWidth( 0 );
         sal_Bool                    bIsVisible( sal_True );
         sal_uInt32                  nStyle( 0 );
 
+        Reference< XIndexAccess >   aMenuDesc;
         try
         {
             if ( rItemContainer->getByIndex( n ) >>= aProp )
@@ -1185,9 +1200,44 @@ void ToolBarManager::FillToolbar( const
                 for ( int i = 0; i < aProp.getLength(); i++ )
                 {
                     if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_COMMANDURL, ITEM_DESCRIPTOR_COMMANDURL_LEN ))
+                    {
                         aProp[i].Value >>= aCommandURL;
+                        if ( aCommandURL.compareToAscii(MENUPREFIX, RTL_CONSTASCII_LENGTH(MENUPREFIX) ) == 0  )
+                        {
+                            try
+                            {
+                                Reference< XIndexAccess > xMenuContainer;
+                                if ( m_xDocUICfgMgr.is() )
+                                    xMenuContainer  = m_xDocUICfgMgr->getSettings( aCommandURL, sal_False );
+                                if ( !xMenuContainer.is() && m_xUICfgMgr.is() )
+                                    xMenuContainer = m_xUICfgMgr->getSettings( aCommandURL, sal_False );
+                                if ( xMenuContainer.is() && xMenuContainer->getCount() )
+                                {
+                                    Sequence< PropertyValue > aProps; 
+                                    // drop down menu info is currently
+                                    // the first ( and only ) menu
+                                    // in the menusettings container
+                                    xMenuContainer->getByIndex(0) >>= aProps;
+                                    for ( sal_Int32 index=0; index<aProps.getLength(); ++index )
+                                    {
+                                        if ( aProps[ index ].Name.equalsAsciiL( ITEM_DESCRIPTOR_CONTAINER, ITEM_DESCRIPTOR_CONTAINER_LEN ))
+ 
+                                        {
+                                            aProps[ index ].Value >>= aMenuDesc;
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                            catch( Exception& e )
+                            {
+                            }
+                        }
+                    }
                     else if (  aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_HELPURL, ITEM_DESCRIPTOR_HELPURL_LEN ))
                         aProp[i].Value >>= aHelpURL;
+                    else if (  aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_TOOLTIP, ITEM_DESCRIPTOR_TOOLTIP_LEN ))
+                        aProp[i].Value >>= aTooltip;
                     else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_LABEL, ITEM_DESCRIPTOR_LABEL_LEN ))
                         aProp[i].Value >>= aLabel;
                     else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_TYPE, ITEM_DESCRIPTOR_TYPE_LEN ))
@@ -1205,9 +1255,14 @@ void ToolBarManager::FillToolbar( const
                     ::rtl::OUString aString( RetrieveLabelFromCommand( aCommandURL ));
 
                     sal_uInt16 nItemBits = ConvertStyleToToolboxItemBits( nStyle );
+                    if ( aMenuDesc.is() )
+                        m_aMenuMap[ nId ] = aMenuDesc;
                     m_pToolBar->InsertItem( nId, aString, nItemBits );
                     m_pToolBar->SetItemCommand( nId, aCommandURL );
-                    m_pToolBar->SetQuickHelpText( nId, aString );
+                    if ( aTooltip.getLength() )
+                        m_pToolBar->SetQuickHelpText( nId, aTooltip );
+                    else
+                        m_pToolBar->SetQuickHelpText( nId, aString );
                     if ( aLabel.getLength() > 0 )
                         m_pToolBar->SetItemText( nId, aLabel );
                     else
--- framework/source/xml/menudocumenthandler.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/source/xml/menudocumenthandler.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -47,6 +47,7 @@
 #include <com/sun/star/xml/sax/XExtendedDocumentHandler.hpp>
 #include <com/sun/star/lang/XSingleComponentFactory.hpp>
 #include <com/sun/star/ui/ItemType.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 
@@ -80,11 +81,13 @@
 #define ATTRIBUTE_LABEL			    "http://openoffice.org/2001/menu^label"
 #define ATTRIBUTE_HELPID		    "http://openoffice.org/2001/menu^helpid"
 #define ATTRIBUTE_LINEBREAK		    "http://openoffice.org/2001/menu^linebreak"
+#define ATTRIBUTE_STYLE		    "http://openoffice.org/2001/menu^style"
 
 #define ATTRIBUTE_NS_ID			    "menu:id"
 #define ATTRIBUTE_NS_LABEL		    "menu:label"
 #define ATTRIBUTE_NS_HELPID		    "menu:helpid"
 #define ATTRIBUTE_NS_LINEBREAK	    "menu:linebreak"
+#define ATTRIBUTE_NS_STYLE		    "menu:style"
 
 #define ATTRIBUTE_XMLNS_MENU	    "xmlns:menu"
 
@@ -92,12 +95,16 @@
 
 #define MENUBAR_DOCTYPE			    "<!DOCTYPE menu:menubar PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"menubar.dtd\">"
 
+#define ATTRIBUTE_ITEMSTYLE_TEXT    "text"
+#define ATTRIBUTE_ITEMSTYLE_IMAGE    "image"
+
 // Property names of a menu/menu item ItemDescriptor
 static const char ITEM_DESCRIPTOR_COMMANDURL[]  = "CommandURL";
 static const char ITEM_DESCRIPTOR_HELPURL[]     = "HelpURL";
 static const char ITEM_DESCRIPTOR_CONTAINER[]   = "ItemDescriptorContainer";
 static const char ITEM_DESCRIPTOR_LABEL[]       = "Label";
 static const char ITEM_DESCRIPTOR_TYPE[]        = "Type";
+static const char ITEM_DESCRIPTOR_STYLE[]       = "Style";
 
 // special popup menus (filled during runtime) must be saved as an empty popup menu or menuitem!!!
 static const sal_Int32 CMD_PROTOCOL_SIZE        = 5;
@@ -121,12 +128,27 @@ using namespace ::com::sun::star::ui;
 namespace framework
 {
 
+struct MenuStyleItem
+{
+    sal_Int16 nBit;
+    const char* attrName;
+};
+
+MenuStyleItem MenuItemStyles[ ] = {
+    { ::com::sun::star::ui::ItemStyle::ICON, ATTRIBUTE_ITEMSTYLE_IMAGE },
+    { ::com::sun::star::ui::ItemStyle::TEXT, ATTRIBUTE_ITEMSTYLE_TEXT },
+};
+
+
+sal_Int32 nMenuStyleItemEntries = sizeof( MenuItemStyles ) / sizeof( MenuItemStyles[ 0 ] );
+
 static void ExtractMenuParameters( const Sequence< PropertyValue > rProp,
                                    ::rtl::OUString&                       rCommandURL,
                                    ::rtl::OUString&                       rLabel,
                                    ::rtl::OUString&                       rHelpURL,
                                    Reference< XIndexAccess >&      rSubMenu,
-                                   sal_Int16&                      rType )
+                                   sal_Int16&                      rType,
+                                   sal_Int16&                      rStyle )
 {
     for ( sal_Int32 i = 0; i < rProp.getLength(); i++ )
     {
@@ -151,6 +173,12 @@ static void ExtractMenuParameters( const
         {
             rProp[i].Value >>= rType;
         }
+#ifdef IZ105626
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_STYLE ))
+        {
+            rProp[i].Value >>= rStyle;
+        }
+#endif
     }
 }
 
@@ -165,7 +193,8 @@ ReadMenuDocumentHandlerBase::ReadMenuDoc
     m_aLabel( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_LABEL )),
     m_aContainer( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_CONTAINER )),
     m_aHelpURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_HELPURL )),
-    m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL ))
+    m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL )),
+    m_aStyle( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_STYLE ))
 {
 }
 
@@ -207,20 +236,29 @@ throw(	SAXException, RuntimeException )
 
 void ReadMenuDocumentHandlerBase::initPropertyCommon(
     Sequence< PropertyValue > &rProps, const rtl::OUString &rCommandURL,
-    const rtl::OUString &rHelpId, const rtl::OUString &rLabel)
+    const rtl::OUString &rHelpId, const rtl::OUString &rLabel, sal_Int16 nItemStyleBits )
 {
     rProps[0].Name = m_aCommandURL;
     rProps[1].Name = m_aHelpURL;
     rProps[2].Name = m_aContainer;
     rProps[3].Name = m_aLabel;
+#ifdef IZ105626
+	rProps[4].Name = m_aStyle;
+	rProps[5].Name = m_aType;
+#else
     rProps[4].Name = m_aType;
-
+#endif
     // Common values
     rProps[0].Value <<= rCommandURL.intern();
     rProps[1].Value <<= rHelpId;
     rProps[2].Value <<= Reference< XIndexContainer >();
     rProps[3].Value <<= rLabel;
+#ifdef IZ105626
+	rProps[4].Value <<= nItemStyleBits;
+	rProps[5].Value <<= ::com::sun::star::ui::ItemType::DEFAULT;
+#else
     rProps[4].Value <<= ::com::sun::star::ui::ItemType::DEFAULT;
+#endif
 }
 
 // -----------------------------------------------------------------------------
@@ -373,6 +411,7 @@ throw( SAXException, RuntimeException )
         ::rtl::OUString aHelpId;
         ::rtl::OUString aCommandId;
         ::rtl::OUString aLabel;
+        sal_Int16 nItemBits(0);
 
         m_bMenuMode = sal_True;
 
@@ -399,12 +438,35 @@ throw( SAXException, RuntimeException )
                     aLabel = aValue;
                 else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
                     aHelpId = aValue;
+#ifdef IZ105626
+                else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+                {
+                    ::rtl::OUString aTemp( aValue );
+                    sal_Int32 nIndex = 0;
+                    do
+                    {
+                        ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                        if ( aToken.getLength() > 0 )
+                        {
+                            if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                                nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                            if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                                nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                        }
+                    }
+                    while ( nIndex >= 0 );                    
+                }
+#endif
             }
 
             if ( aCommandId.getLength() > 0 )
             {
+#ifdef IZ105626 
+                Sequence< PropertyValue > aSubMenuProp( 6 );
+#else
                 Sequence< PropertyValue > aSubMenuProp( 5 );
-                initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel );
+#endif
+                initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel, nItemBits );
                 aSubMenuProp[2].Value <<= xSubItemContainer;
 
                 m_xMenuBarContainer->insertByIndex( m_xMenuBarContainer->getCount(), makeAny( aSubMenuProp ) );
@@ -589,6 +651,7 @@ throw( SAXException, RuntimeException )
         ::rtl::OUString aHelpId;
         ::rtl::OUString aCommandId;
         ::rtl::OUString aLabel;
+        sal_Int16 nItemBits(0);
 
         m_bMenuMode = sal_True;
 
@@ -614,12 +677,36 @@ throw( SAXException, RuntimeException )
                 aLabel = aValue;
             else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
                 aHelpId = aValue;
+#ifdef IZ105626
+            else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+            {
+                ::rtl::OUString aTemp( aValue );
+                sal_Int32 nIndex = 0;
+                do
+                {
+                    ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                    if ( aToken.getLength() > 0 )
+                    {
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                    }
+                }
+                while ( nIndex >= 0 );                    
+            }
+#endif
+
         }
 
         if ( aCommandId.getLength() > 0 )
         {
+#ifdef IZ105626
+            Sequence< PropertyValue > aSubMenuProp( 6 );
+#else
             Sequence< PropertyValue > aSubMenuProp( 5 );
-            initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel );
+#endif 
+            initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel, nItemBits );
             aSubMenuProp[2].Value <<= xSubItemContainer;
 
             m_xMenuContainer->insertByIndex( m_xMenuContainer->getCount(), makeAny( aSubMenuProp ) );
@@ -639,7 +726,7 @@ throw( SAXException, RuntimeException )
         ::rtl::OUString aHelpId;
         ::rtl::OUString aCommandId;
         ::rtl::OUString aLabel;
-
+        sal_Int16 nItemBits(0);
         // read attributes for menu item
         for ( sal_Int16 i=0; i< xAttrList->getLength(); i++ )
         {
@@ -651,12 +738,34 @@ throw( SAXException, RuntimeException )
                 aLabel = aValue;
             else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
                 aHelpId = aValue;
+            else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+            {
+                ::rtl::OUString aTemp( aValue );
+                sal_Int32 nIndex = 0;
+                do
+                {
+                    ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                    if ( aToken.getLength() > 0 )
+                    {
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                    }
+                }
+                while ( nIndex >= 0 );                    
+            }
+
         }
 
         if ( aCommandId.getLength() > 0 )
         {
+#ifdef IZ105626
+            Sequence< PropertyValue > aMenuItem( 6 );
+#else
             Sequence< PropertyValue > aMenuItem( 5 );
-            initPropertyCommon( aMenuItem, aCommandId, aHelpId, aLabel );
+#endif 
+            initPropertyCommon( aMenuItem, aCommandId, aHelpId, aLabel, nItemBits );
             aMenuItem[2].Value <<= Reference< XIndexContainer >();
 
             m_xMenuContainer->insertByIndex( m_xMenuContainer->getCount(), makeAny( aMenuItem ) );
@@ -809,15 +918,16 @@ throw ( SAXException, RuntimeException )
             ::rtl::OUString    aLabel;
             ::rtl::OUString    aHelpURL;
             sal_Int16   nType( ::com::sun::star::ui::ItemType::DEFAULT );
+            sal_Int16   nItemBits( 0 );
             Reference< XIndexAccess > xSubMenu;
 
-            ExtractMenuParameters( aProps, aCommandURL, aLabel, aHelpURL, xSubMenu, nType );
+            ExtractMenuParameters( aProps, aCommandURL, aLabel, aHelpURL, xSubMenu, nType, nItemBits );
             if ( xSubMenu.is() )
             {
                 if ( aCommandURL.equalsAscii( ADDDIRECT_CMD ) ||
                     aCommandURL.equalsAscii( AUTOPILOTMENU_CMD ))
                 {
-                    WriteMenuItem( aCommandURL, aLabel, aHelpURL );
+                    WriteMenuItem( aCommandURL, aLabel, aHelpURL, nItemBits );
                     bSeparator = sal_False;
                 }
                 else if (( aCommandURL.getLength() > 0 ) && !AddonPopupMenu::IsCommandURLPrefix ( aCommandURL ))
@@ -857,7 +967,7 @@ throw ( SAXException, RuntimeException )
                     if ( aCommandURL.getLength() > 0 )
                     {
                         bSeparator = FALSE;
-                        WriteMenuItem( aCommandURL, aLabel, aHelpURL );
+                        WriteMenuItem( aCommandURL, aLabel, aHelpURL, nItemBits );
                     }
                 }
                 else if ( !bSeparator )
@@ -872,7 +982,7 @@ throw ( SAXException, RuntimeException )
 }
 
 
-void OWriteMenuDocumentHandler::WriteMenuItem( const ::rtl::OUString& aCommandURL, const ::rtl::OUString& aLabel, const ::rtl::OUString& aHelpURL)
+void OWriteMenuDocumentHandler::WriteMenuItem( const ::rtl::OUString& aCommandURL, const ::rtl::OUString& aLabel, const ::rtl::OUString& aHelpURL, sal_Int16 nStyle )
 {
     ::comphelper::AttributeList* pList = new ::comphelper::AttributeList;
     Reference< XAttributeList > xList( (XAttributeList *) pList , UNO_QUERY );
@@ -894,6 +1004,24 @@ void OWriteMenuDocumentHandler::WriteMen
                                 m_aAttributeType,
                                 aLabel );
     }
+    if (( nStyle > 0 ) && !( aCommandURL.copy( CMD_PROTOCOL_SIZE ).equalsAscii( CMD_PROTOCOL )))
+    {
+        rtl::OUString aValue;
+        MenuStyleItem* pStyle = MenuItemStyles;
+
+        for ( sal_Int32 nIndex = 0; nIndex < nMenuStyleItemEntries; ++nIndex, ++pStyle )
+        {
+            if ( nStyle & pStyle->nBit )
+            {
+                if ( aValue.getLength() )
+                    aValue = aValue.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("+") ) );
+                aValue += rtl::OUString::createFromAscii( pStyle->attrName );
+            }
+        }
+        pList->AddAttribute( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_NS_STYLE )),
+                                m_aAttributeType,
+                                aValue );
+    }
 
     m_xWriteDocumentHandler->ignorableWhitespace( ::rtl::OUString() );
     m_xWriteDocumentHandler->startElement( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ELEMENT_NS_MENUITEM )), xList );
--- framework/source/xml/toolboxdocumenthandler.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ framework/source/xml/toolboxdocumenthandler.cxx	2010-03-03 16:59:34.000000000 +0100
@@ -79,6 +79,7 @@ namespace framework
 // Property names of a menu/menu item ItemDescriptor
 static const char ITEM_DESCRIPTOR_COMMANDURL[]  = "CommandURL";
 static const char ITEM_DESCRIPTOR_HELPURL[]     = "HelpURL";
+static const char ITEM_DESCRIPTOR_TOOLTIP[]     = "Tooltip";
 static const char ITEM_DESCRIPTOR_LABEL[]       = "Label";
 static const char ITEM_DESCRIPTOR_TYPE[]        = "Type";
 static const char ITEM_DESCRIPTOR_STYLE[]       = "Style";
@@ -89,6 +90,8 @@ static void ExtractToolbarParameters( co
                                       ::rtl::OUString&                       rCommandURL,
                                       ::rtl::OUString&                       rLabel,
                                       ::rtl::OUString&                       rHelpURL,
+                                      ::rtl::OUString&                       rTooltip,
+                                      sal_Int16&                      rStyle,
                                       sal_Int16&                      rWidth,
                                       sal_Bool&                       rVisible,
                                       sal_Int16&                      rType )
@@ -102,6 +105,8 @@ static void ExtractToolbarParameters( co
         }
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_HELPURL ))
             rProp[i].Value >>= rHelpURL;
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_TOOLTIP ))
+            rProp[i].Value >>= rTooltip;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_LABEL ))
             rProp[i].Value >>= rLabel;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_TYPE ))
@@ -110,9 +115,30 @@ static void ExtractToolbarParameters( co
             rProp[i].Value >>= rVisible;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_WIDTH ))
             rProp[i].Value >>= rWidth;
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_STYLE ))
+            rProp[i].Value >>= rStyle;
     }
 }
 
+struct ToolboxStyleItem
+{
+    sal_Int16 nBit;
+    const char* attrName;
+};
+
+ToolboxStyleItem Styles[ ] = {
+    { ::com::sun::star::ui::ItemStyle::RADIO_CHECK, ATTRIBUTE_ITEMSTYLE_RADIO },
+    { ::com::sun::star::ui::ItemStyle::ALIGN_LEFT, ATTRIBUTE_ITEMSTYLE_LEFT },
+    { ::com::sun::star::ui::ItemStyle::AUTO_SIZE, ATTRIBUTE_ITEMSTYLE_AUTO },
+    { ::com::sun::star::ui::ItemStyle::REPEAT, ATTRIBUTE_ITEMSTYLE_REPEAT },
+    { ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY, ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY },
+    { ::com::sun::star::ui::ItemStyle::DROP_DOWN, ATTRIBUTE_ITEMSTYLE_DROPDOWN },
+    { ::com::sun::star::ui::ItemStyle::ICON, ATTRIBUTE_ITEMSTYLE_IMAGE },
+    { ::com::sun::star::ui::ItemStyle::TEXT, ATTRIBUTE_ITEMSTYLE_TEXT },
+};
+
+sal_Int32 nStyleItemEntries = sizeof( Styles ) / sizeof( Styles[ 0 ] );
+
 struct ToolBarEntryProperty
 {
     OReadToolBoxDocumentHandler::ToolBox_XML_Namespace	nNamespace;
@@ -135,7 +161,8 @@ ToolBarEntryProperty ToolBoxEntries[ORea
     { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_USER				},
     { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_HELPID			},
     { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_ITEMSTYLE			},
-    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,   ATTRIBUTE_UINAME            }
+    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,   ATTRIBUTE_UINAME            },
+    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_TOOLTIP			},
 };
 
 OReadToolBoxDocumentHandler::OReadToolBoxDocumentHandler( const Reference< XIndexContainer >& rItemContainer ) :
@@ -145,6 +172,7 @@ OReadToolBoxDocumentHandler::OReadToolBo
     m_aLabel( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_LABEL )),
     m_aStyle( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_STYLE )),
     m_aHelpURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_HELPURL )),
+    m_aTooltip( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_TOOLTIP )),
     m_aIsVisible( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_VISIBLE )),
     m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL ))
  {
@@ -179,6 +207,8 @@ OReadToolBoxDocumentHandler::OReadToolBo
     m_nHashCode_Style_DropDown	    = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_DROPDOWN ).hashCode();
     m_nHashCode_Style_Repeat	    = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_REPEAT ).hashCode();
     m_nHashCode_Style_DropDownOnly  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY ).hashCode();
+    m_nHashCode_Style_Text  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_TEXT ).hashCode();
+    m_nHashCode_Style_Image  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_IMAGE ).hashCode();
 
     m_bToolBarStartFound			= sal_False;
     m_bToolBarEndFound				= sal_False;
@@ -298,6 +328,7 @@ throw(	SAXException, RuntimeException )
                 ::rtl::OUString        aLabel;
                 ::rtl::OUString        aCommandURL;
                 ::rtl::OUString        aHelpURL;
+                ::rtl::OUString        aTooltip;
                 ::rtl::OUString        aBitmapName;
                 sal_uInt16      nItemBits( 0 );
                 sal_uInt16      nWidth( 0 );
@@ -368,6 +399,13 @@ throw(	SAXException, RuntimeException )
                                 aHelpURL = xAttribs->getValueByIndex( n );
                             }
                             break;
+#ifdef IZ105626 
+                            case TB_ATTRIBUTE_TOOLTIP:
+                            {
+                                aTooltip = xAttribs->getValueByIndex( n );
+                            }
+                            break;
+#endif
 
                             case TB_ATTRIBUTE_STYLE:
                             {
@@ -393,6 +431,12 @@ throw(	SAXException, RuntimeException )
                                             nItemBits |= ::com::sun::star::ui::ItemStyle::REPEAT;
                                         else if ( nHashCode == m_nHashCode_Style_DropDownOnly )
                                             nItemBits |= ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY;
+#ifdef IZ105626 
+                                        else if ( nHashCode == m_nHashCode_Style_Text )
+                                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                                        else if ( nHashCode == m_nHashCode_Style_Image )
+                                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+#endif
                                     }
                                 }
                                 while ( nIndex >= 0 );
@@ -414,13 +458,20 @@ throw(	SAXException, RuntimeException )
 
                 if ( aCommandURL.getLength() > 0 )
                 {
+#ifdef IZ105626
+                    Sequence< PropertyValue > aToolbarItemProp( 7 );
+#else
                     Sequence< PropertyValue > aToolbarItemProp( 6 );
+#endif
                     aToolbarItemProp[0].Name = m_aCommandURL;
                     aToolbarItemProp[1].Name = m_aHelpURL;
                     aToolbarItemProp[2].Name = m_aLabel;
                     aToolbarItemProp[3].Name = m_aType;
                     aToolbarItemProp[4].Name = m_aStyle;
                     aToolbarItemProp[5].Name = m_aIsVisible;
+#ifdef IZ105626 
+                    aToolbarItemProp[6].Name = m_aTooltip;
+#endif
 
                     aToolbarItemProp[0].Value <<= aCommandURL;
                     aToolbarItemProp[1].Value <<= aHelpURL;
@@ -428,6 +479,9 @@ throw(	SAXException, RuntimeException )
                     aToolbarItemProp[3].Value = makeAny( ::com::sun::star::ui::ItemType::DEFAULT );
                     aToolbarItemProp[4].Value <<= nItemBits;
                     aToolbarItemProp[5].Value <<= bVisible;
+#ifdef IZ105626 
+                    aToolbarItemProp[6].Value <<= aTooltip;
+#endif
 
                     m_rItemContainer->insertByIndex( m_rItemContainer->getCount(), makeAny( aToolbarItemProp ) );
                 }
@@ -718,13 +772,15 @@ void OWriteToolBoxDocumentHandler::Write
             ::rtl::OUString    aCommandURL;
             ::rtl::OUString    aLabel;
             ::rtl::OUString    aHelpURL;
+            ::rtl::OUString    aTooltip;
             sal_Bool    bVisible( sal_True );
             sal_Int16   nType( ::com::sun::star::ui::ItemType::DEFAULT );
             sal_Int16   nWidth( 0 );
+            sal_Int16   nStyle( 0 );
 
-            ExtractToolbarParameters( aProps, aCommandURL, aLabel, aHelpURL, nWidth, bVisible, nType );
+            ExtractToolbarParameters( aProps, aCommandURL, aLabel, aHelpURL, aTooltip, nStyle, nWidth, bVisible, nType );
             if ( nType == ::com::sun::star::ui::ItemType::DEFAULT )
-                WriteToolBoxItem( aCommandURL, aLabel, aHelpURL, nWidth, bVisible );
+                WriteToolBoxItem( aCommandURL, aLabel, aHelpURL, aTooltip, nStyle, nWidth, bVisible );
             else if ( nType == ::com::sun::star::ui::ItemType::SEPARATOR_SPACE )
                 WriteToolBoxSpace();
             else if ( nType == ::com::sun::star::ui::ItemType::SEPARATOR_LINE )
@@ -748,6 +804,8 @@ void OWriteToolBoxDocumentHandler::Write
     const ::rtl::OUString& rCommandURL,
     const ::rtl::OUString& rLabel,
     const ::rtl::OUString& rHelpURL,
+    const ::rtl::OUString& rTooltip,
+    sal_Int16       nStyle,
     sal_Int16       nWidth,
     sal_Bool        bVisible )
 throw ( SAXException, RuntimeException )
@@ -784,6 +842,33 @@ throw ( SAXException, RuntimeException )
                              m_aAttributeType,
                              rHelpURL );
     }
+#ifdef IZ105626
+    if ( rTooltip.getLength() > 0 )
+    {
+        pList->AddAttribute( m_aXMLToolbarNS + ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_TOOLTIP )),
+                             m_aAttributeType,
+                             rTooltip );
+    }
+
+    if ( nStyle > 0 )
+    {
+        rtl::OUString aValue;
+        ToolboxStyleItem* pStyle = Styles;
+
+        for ( sal_Int32 nIndex = 0; nIndex < nStyleItemEntries; ++nIndex, ++pStyle )
+        {
+            if ( nStyle & pStyle->nBit )
+            {
+                if ( aValue.getLength() )
+                    aValue = aValue.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(" ") ) );
+                aValue += rtl::OUString::createFromAscii( pStyle->attrName );
+            }
+        } 
+        pList->AddAttribute( m_aXMLToolbarNS + ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_ITEMSTYLE )),
+                             m_aAttributeType,
+                             aValue );
+    }
+#endif
 
     if ( nWidth > 0 )
     {
--- offapi/com/sun/star/document/VbaEventId.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/VbaEventId.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventId_idl__
+#define __org_openoffice_vba_VbaEventId_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+/* VBA compatibility event id */
+constants VbaEventId
+{
+    // Worksheet
+    const long VBAEVENT_WORKSHEET_ACTIVATE                  	= 1;
+    const long VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK         	= 2;
+    const long VBAEVENT_WORKSHEET_BEFORERIGHTCLICK          	= 3;
+    const long VBAEVENT_WORKSHEET_CALCULATE                 	= 4;
+    const long VBAEVENT_WORKSHEET_CHANGE                    	= 5;
+    const long VBAEVENT_WORKSHEET_DEACTIVATE                	= 6;
+    const long VBAEVENT_WORKSHEET_FOLLOWHYPERLINK           	= 7;
+    const long VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE          	= 8;
+    const long VBAEVENT_WORKSHEET_SELECTIONCHANGE           	= 9;
+    // Workbook
+    const long VBAEVENT_WORKBOOK_ACTIVATE            			= 20;
+    const long VBAEVENT_WORKBOOK_DEACTIVATE          			= 21;
+    const long VBAEVENT_WORKBOOK_OPEN                			= 22;
+    const long VBAEVENT_WORKBOOK_AUTOOPEN            			= 23;
+    const long VBAEVENT_WORKBOOK_BEFORECLOSE         			= 24;
+    const long VBAEVENT_WORKBOOK_BEFOREPRINT         			= 25;
+    const long VBAEVENT_WORKBOOK_BEFORESAVE          			= 26;
+    const long VBAEVENT_WORKBOOK_NEWSHEET            			= 27;
+    const long VBAEVENT_WORKBOOK_WINDOWACTIVATE      			= 28;
+    const long VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    			= 29;
+    const long VBAEVENT_WORKBOOK_WINDOWRESIZE        			= 30;
+    // Workbook_sheet
+    const long VBAEVENT_WORKBOOK_SHEET_ACTIVATE               	= 51;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK      	= 52;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK       	= 53;
+    const long VBAEVENT_WORKBOOK_SHEET_CALCULATE              	= 54;
+    const long VBAEVENT_WORKBOOK_SHEET_CHANGE                 	= 55;
+    const long VBAEVENT_WORKBOOK_SHEET_DEACTIVATE             	= 56;
+    const long VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK        	= 57;
+    const long VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE       	= 58;
+    const long VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE        	= 59;
+
+    // Document event for Word
+    const long VBAEVENT_DOCUMENT_NEW                            = 70;
+    const long VBAEVENT_DOCUMENT_AUTONEW                        = 71;
+    const long VBAEVENT_DOCUMENT_OPEN                           = 72;
+    const long VBAEVENT_DOCUMENT_AUTOOPEN                       = 73;
+    const long VBAEVENT_DOCUMENT_CLOSE                          = 74;
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/VbaEventsHelper.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/VbaEventsHelper.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_VbaEventsHelper_idl__
+#define __com_sun_star_document_VbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#include <com/sun/star/frame/XModel.idl>
+#include <com/sun/star/document/XVbaEventsHelper.idl>
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+service VbaEventsHelper : XVbaEventsHelper
+{
+  	createVbaEventsHelper(  [in] ::com::sun::star::frame::XModel xModel );
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XCodeNameQuery.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/XCodeNameQuery.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDocumentPropertiesSupplier.idl,v $
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCodeNameQuery_idl__
+#define __com_sun_star_document_XCodeNameQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+//=============================================================================
+interface XCodeNameQuery
+{
+	//-------------------------------------------------------------------------
+    string getCodeNameForObject( [in] com::sun::star::uno::XInterface aObj );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XCompatWriterDocProperties.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/XCompatWriterDocProperties.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocumentProperties.idl,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCompatWriterDocProperties_idl__
+#define __com_sun_star_document_XCompatWriterDocProperties_idl__
+
+#ifndef __com_sun_star_document_XDocumentProperties_idl__
+#include <com/sun/star/document/XDocumentProperties.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+interface XCompatWriterDocProperties
+{
+//    interface ::com::sun::star::document::XDocumentProperties;
+    [attribute] string Manager;
+    [attribute] string Category;
+    [attribute] string Company;
+
+
+}; }; }; };
+};
+#endif
--- offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaEventHelper.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+#define __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+
+//=============================================================================
+interface XDocumentEventCompatibleHelper
+{
+    /* Execute some compatible VBA event related to document, such as document save, document print.
+       nEventId: event id.
+    */
+    boolean processCompatibleEvent( [in] short nEventId );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XVbaEventsHelper.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/XVbaEventsHelper.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_XVbaEventsHelper_idl__
+#define __org_openoffice_vba_XVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {  module sun {  module star {  module document {
+//=============================================================================
+
+interface XVbaEventsHelper
+{
+    /**
+        Execute VBA compatible event.
+        VbaEvent: Compatible VBA event id.
+        aArgs: the array of input arguments.
+        return: True if execute successfully, or False.
+    **/
+    boolean ProcessCompatibleVbaEvent( [in] long nEventId, [in] sequence< any > aArgs );
+    [attribute ] boolean IgnoreEvents;
+};
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/document/XVbaMethodParameter.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/document/XVbaMethodParameter.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright IBM Corporation 2009
+ * Copyright 2009 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaMethodParameter,v $
+ * $Revision: 1.13 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __org_openoffice_vba_XVbaMethodParameter_idl__
+#define __org_openoffice_vba_XVbaMethodParameter_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//============================================================================= 
+
+module com {  module sun {  module star {  module document {
+
+//============================================================================= 
+//gives access to vba method input/output parameters
+//
+//some OO objects need to implement this interface to support the passing of input/output parameters
+//for certain VBA events
+
+interface XVbaMethodParameter : com::sun::star::uno::XInterface
+{
+	//------------------------------------------------------------------------- 
+	 
+	/** sets the value of the parameter with the specified name.
+	 */
+	void setVbaMethodParameter( [in] string PropertyName, 
+			 [in] any Value ); 
+ 
+	//------------------------------------------------------------------------- 
+
+	/** returns the value of the parameter with the specified name.
+     */
+	any getVbaMethodParameter( [in] string PropertyName ); 
+};
+
+//============================================================================= 
+
+}; }; }; };
+#endif
--- offapi/com/sun/star/document/makefile.mk.old	2009-10-08 16:17:03.000000000 +0200
+++ offapi/com/sun/star/document/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -116,7 +116,15 @@ IDLFILES=\
     LinkUpdateModes.idl\
     XDocumentRevisionListPersistence.idl\
     DocumentRevisionListPersistence.idl \
-    XDocumentLanguages.idl
+    XDocumentLanguages.idl \
+    XCodeNameQuery.idl \
+    XDocumentEventCompatibleHelper.idl \
+    XCompatWriterDocProperties.idl \
+    XVbaMethodParameter.idl \
+    VbaEventId.idl \
+    XVbaEventsHelper.idl \
+    VbaEventsHelper.idl \
+
 
 # ------------------------------------------------------------------
 
--- offapi/com/sun/star/drawing/Shape.idl.old	2009-10-07 15:06:09.000000000 +0200
+++ offapi/com/sun/star/drawing/Shape.idl	2010-03-03 16:59:34.000000000 +0100
@@ -195,6 +195,10 @@ published service Shape
         the z-order.
     */
     [optional, property] long NavigationOrder;
+
+	/** this property lets you get and set a hyperlink for this shape.
+	 */
+	[optional, property] string Hyperlink;
 };
 
 //=============================================================================
--- offapi/com/sun/star/script/XLibraryQueryExecutable.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/script/XLibraryQueryExecutable.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+#define __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XLibraryQueryExecutable: com::sun::star::uno::XInterface
+{ 
+	boolean HasExecutableCode( [in] string name );
+};
+
+//============================================================================= 
+ 
+ 
+}; }; }; };  
+ 
+#endif 
--- offapi/com/sun/star/script/XVBACompat.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/script/XVBACompat.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XVBACompat_idl__ 
+#define __com_sun_star_script_XVBACompat_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XVBACompat: com::sun::star::uno::XInterface
+{ 
+
+//============================================================================= 
+    [attribute ] boolean VBACompatModeOn;
+ 
+}; }; }; };  
+}; 
+#endif 
--- offapi/com/sun/star/script/makefile.mk.old	2009-10-07 15:06:09.000000000 +0200
+++ offapi/com/sun/star/script/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -51,6 +51,8 @@ IDLFILES=\
     XLibraryContainerExport.idl\
     XPersistentLibraryContainer.idl\
     XStorageBasedLibraryContainer.idl\
+	XLibraryQueryExecutable.idl \
+	XVBACompat.idl\
     ModuleSizeExceededRequest.idl\
 
 # ------------------------------------------------------------------
--- offapi/com/sun/star/sheet/SpreadsheetDocumentVbaEventsHelper.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/sheet/SpreadsheetDocumentVbaEventsHelper.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: TextDocument.idl,v $
+ * $Revision: 1.18 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_sheet_SpreadsheetDocumentVbaEventsHelper_idl__
+#define __com_sun_star_sheet_SpreadsheetDocumentVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_document_VbaEventsHelper_idl__
+#include <com/sun/star/document/VbaEventsHelper.idl>
+#endif
+
+//=============================================================================
+
+ module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+service SpreadsheetDocumentVbaEventsHelper
+{
+    service com::sun::star::document::VbaEventsHelper;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/sheet/makefile.mk.old	2009-10-08 16:17:03.000000000 +0200
+++ offapi/com/sun/star/sheet/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -198,6 +198,7 @@ IDLFILES=\
     Spreadsheet.idl\
     SpreadsheetDocument.idl\
     SpreadsheetDocumentSettings.idl\
+    SpreadsheetDocumentVbaEventsHelper.idl\
     SpreadsheetDrawPage.idl\
     SpreadsheetView.idl\
     SpreadsheetViewPane.idl\
--- offapi/com/sun/star/text/TextDocumentVbaEventsHelper.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ offapi/com/sun/star/text/TextDocumentVbaEventsHelper.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: TextDocument.idl,v $
+ * $Revision: 1.18 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_text_TextDocumentVbaEventsHelper_idl__
+#define __com_sun_star_text_TextDocumentVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_document_VbaEventsHelper_idl__
+#include <com/sun/star/document/VbaEventsHelper.idl>
+#endif
+
+//=============================================================================
+
+ module com {  module sun {  module star {  module text {
+
+//=============================================================================
+
+service TextDocumentVbaEventsHelper
+{
+    service com::sun::star::document::VbaEventsHelper;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- offapi/com/sun/star/text/makefile.mk.old	2009-10-08 16:17:03.000000000 +0200
+++ offapi/com/sun/star/text/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -156,6 +156,7 @@ IDLFILES=\
      TextContentCollection.idl\
      TextCursor.idl\
      TextDocument.idl\
+     TextDocumentVbaEventsHelper.idl\
      TextDocumentView.idl\
      TextEmbeddedObject.idl\
      TextEmbeddedObjects.idl\
--- offapi/com/sun/star/ui/ItemStyle.idl.old	2009-10-07 15:06:09.000000000 +0200
+++ offapi/com/sun/star/ui/ItemStyle.idl	2010-03-03 16:59:34.000000000 +0100
@@ -149,6 +149,7 @@ constants ItemStyle
         <p>This style is only valid if the item describes a toolbar item.</p>
     */
     const short DROPDOWN_ONLY = 1024;
+    const short TEXT = 2048;
 };
 
 }; }; }; };
--- officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu.old	2010-03-03 16:59:14.000000000 +0100
+++ officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu	2010-03-03 16:59:34.000000000 +0100
@@ -1197,6 +1197,12 @@
                     <value xml:lang="en-US">~Remove Filter</value>
                 </prop>
             </node>
+                        <node oor:name=".uno:DataForm" oor:op="replace">
+                                <prop oor:name="Label" oor:type="xs:string">
+                                        <value xml:lang="de">D~atenForm...</value>
+                                        <value xml:lang="en-US">D~ataForm...</value>
+                                </prop>
+                        </node>
             <node oor:name=".uno:DataSubTotals" oor:op="replace">
                 <prop oor:name="Label" oor:type="xs:string">
                     <value xml:lang="en-US">Sub~totals...</value>
--- officecfg/registry/schema/org/openoffice/Office/Calc.xcs.old	2010-03-03 16:59:16.000000000 +0100
+++ officecfg/registry/schema/org/openoffice/Office/Calc.xcs	2010-03-03 16:59:34.000000000 +0100
@@ -1397,7 +1397,7 @@
               <desc>Indicates whether VBA macros are imported without comments to be executable.</desc>
               <label>Executable code</label>
             </info>
-            <value>false</value>
+            <value>true</value>
           </prop>
           <prop oor:name="Save" oor:type="xs:boolean">
 						<!-- OldPath: Filter/MS_Office/Basic/Excel -->
--- officecfg/registry/schema/org/openoffice/Office/Writer.xcs.old	2010-03-03 16:44:08.000000000 +0100
+++ officecfg/registry/schema/org/openoffice/Office/Writer.xcs	2010-03-03 16:59:34.000000000 +0100
@@ -749,6 +749,17 @@
 		</group>
 	</templates>
 	<component>
+        <group oor:name="GlobalTemplateList">
+            <info>
+               <desc>Contains the most recently opened documents.</desc>
+            </info>
+            <prop oor:name="Paths" oor:type="oor:string-list">
+                <info>
+                    <desc>Lists the file global templates loaded when importing writer documents.</desc>
+                </info>
+                <value oor:separator=";"></value> 
+            </prop>
+        </group>
         <group oor:name="MailMergeWizard">
             <info>
                 <desc>Settings of the mail merge wizard.</desc>
--- oovbaapi/ooo/vba/XDocumentBase.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/XDocumentBase.idl	2010-03-03 16:59:34.000000000 +0100
@@ -58,7 +58,6 @@ interface XDocumentBase
 	void Close([in] any SaveChanges, [in] any FileName, [in] any RouteWorkBook);
 	void Save();
 	void Activate();
-	void Protect( [in] any Password );
 	void Unprotect( [in] any Password );
 };
 
--- oovbaapi/ooo/vba/XFileDialog.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/XFileDialog.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#ifndef __ooo_vba_excel_XFileDialog_idl__
+#define __ooo_vba_excel_XFileDialog_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#include <ooo/vba/XFileDialogSelectedItems.idl>
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {
+                                                                                                                             
+//=============================================================================
+
+interface XFileDialog : com::sun::star::uno::XInterface
+{
+	[attribute, readonly] ooo::vba::XFileDialogSelectedItems SelectedItems;
+
+	long Show();
+};
+                                                                                                                             
+}; };
+                                                                                                                             
+#endif
+
--- oovbaapi/ooo/vba/XFileDialogSelectedItems.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/XFileDialogSelectedItems.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+
+#ifndef __ooo_vba_excel_XFileDialogSelectedItems_idl__
+#define __ooo_vba_excel_XFileDialogSelectedItems_idl__
+                                                                                                                             
+// #ifndef __com_sun_star_uno_XInterface_idl__
+// #include <com/sun/star/uno/XInterface.idl>
+// #endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  
+                                                                                                                             
+//=============================================================================
+
+interface XFileDialogSelectedItems 
+{
+	interface ooo::vba::XCollection;
+};
+                                                                                                                             
+}; }; 
+                                                                                                                             
+#endif
+
--- oovbaapi/ooo/vba/XFileSearch.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/XFileSearch.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+#ifndef __ooo_vba_XFileSearch_idl__
+#define __ooo_vba_XFileSearch_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XFileSearch
+{
+	interface ::com::sun::star::uno::XInterface;
+
+    [attribute] string FileName;
+    [attribute] string LookIn;
+    [attribute] boolean SearchSubFolders;
+    [attribute] boolean MatchTextExactly;
+    
+    long Execute();
+    void NewSearch();
+};
+
+}; };
+
+#endif
--- oovbaapi/ooo/vba/XVBAToOOEventDescGen.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/XVBAToOOEventDescGen.idl	2010-03-03 16:59:34.000000000 +0100
@@ -41,8 +41,8 @@
 module ooo {  module vba { 
 interface XVBAToOOEventDescGen : com::sun::star::uno::XInterface
 {
-    sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sLibModName, [in] sequence< string > handlerExts );
-    com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl );
+	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
+	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
 };
 
 }; };
--- oovbaapi/ooo/vba/excel/XApplication.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XApplication.idl	2010-03-03 16:59:34.000000000 +0100
@@ -42,6 +42,14 @@
 #include <ooo/vba/XAssistant.idl>
 #endif
 
+#ifndef __ooo_vba_excel_XFileDialog_idl__
+#include <ooo/vba/XFileDialog.idl>
+#endif
+
+#ifndef __ooo_vba_XFileSearch_idl__
+#include <ooo/vba/XFileSearch.idl>
+#endif
+
 module ooo {  module vba {  module excel { 
 
 interface XRange;
@@ -51,6 +59,8 @@ interface XWorksheets;
 interface XWorksheetFunction;
 interface XWindow;
 interface XWorksheet;
+interface XFileDialog;
+interface XFileSearch;
 
 interface XApplication : com::sun::star::uno::XInterface
 {
@@ -63,23 +73,29 @@ interface XApplication : com::sun::star:
     [attribute, readonly] XWindow ActiveWindow;
     [attribute, readonly] XWorksheet ActiveSheet;
     [attribute, readonly] ooo::vba::XAssistant Assistant;
+    [attribute, readonly] ooo::vba::XFileSearch FileSearch; //liuchen 2009-8-18, add the support of VBA Application.FileSearch
     [attribute] long Calculation;
     //#TODO #FIXME this is more of a placeholder, will return
     // the value of activeworkbook, in xl 'ThisWorkbook' should return the
     // workbook in which the 'calling' macro is running. Should be possible
     // to determine this
     [attribute, readonly] XWorkbook ThisWorkbook;
+	[attribute, readonly] ooo::vba::XFileDialog FileDialog;
     [attribute, readonly] string Name;
     [attribute] boolean DisplayAlerts;
     [attribute] boolean DisplayFormulaBar;
     [attribute] any CutCopyMode;
     [attribute] any StatusBar;
     [attribute] long Cursor; 
+	[attribute] boolean EnableEvents;
+	[attribute] boolean Visible;
 
     void setDefaultFilePath([in] string DefaultFilePath) raises(com::sun::star::script::BasicErrorException);
 
     string getDefaultFilePath() raises(com::sun::star::script::BasicErrorException); 
 
+	any GetOpenFilename([in] /*Optional*/ any FileFilter, [in] /*Optional*/ any FilterIndex, [in] /*Optional*/ any Title, [in] /*Optional*/ any ButtonText, [in] /*Optional*/ any MultiSelect); //minz, 2009-07-08
+
     string LibraryPath() raises(com::sun::star::script::BasicErrorException);
     string TemplatesPath() raises(com::sun::star::script::BasicErrorException);
     string PathSeparator() raises(com::sun::star::script::BasicErrorException);
@@ -102,8 +118,8 @@ interface XApplication : com::sun::star:
     XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
         raises(com::sun::star::script::BasicErrorException);
     void Volatile([in] any Volatile);
-    void DoEvents();
 	any Caller( [in] any aIndex );
+	any MenuBars( [in] any aIndex );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/excel/XGlobals.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XGlobals.idl	2010-03-03 16:59:34.000000000 +0100
@@ -76,6 +76,7 @@ XRange Intersect([in] XRange Arg1, [in]
 	any Names( [in] any Index );
 	XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
         raises(com::sun::star::script::BasicErrorException);
+	any MenuBars( [in] any aIndex );
 
 };
 
--- oovbaapi/ooo/vba/excel/XMenu.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenu.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenu_idl__
+#define __ooo_vba_excel_XMenu_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenu
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+    any MenuItems( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/excel/XMenuBar.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenuBar.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBar_idl__
+#define __ooo_vba_excel_XMenuBar_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuBar
+{
+	interface XHelperInterface;
+
+    any Menus( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/excel/XMenuBars.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenuBars.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuBars.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBars_idl__
+#define __ooo_vba_excel_XMenuBars_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuBars
+{
+	interface ooo::vba::XCollection;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/excel/XMenuItem.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenuItem.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItem_idl__
+#define __ooo_vba_excel_XMenuItem_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuItem
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+    [attribute] string OnAction;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/excel/XMenuItems.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenuItems.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuItems.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItems_idl__
+#define __ooo_vba_excel_XMenuItems_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuItem;
+
+interface XMenuItems
+{
+	interface ooo::vba::XCollection;
+
+    XMenuItem Add( [in] string Caption, [in] any OnAction, [in] any ShortcutKey, [in] any Before, [in] any Restore, [in] any StatusBar, [in] any HelpFile, [in] any HelpContextID ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/excel/XMenus.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XMenus.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenus.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenus_idl__
+#define __ooo_vba_excel_XMenus_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenu;
+
+interface XMenus
+{
+	interface ooo::vba::XCollection;
+
+    XMenu Add( [in] string Caption, [in] any Before, [in] any Restore ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/excel/XPivotCache.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/excel/XPivotCache.idl	2010-03-03 16:59:34.000000000 +0100
@@ -48,6 +48,7 @@ interface XPivotCache
 {
     interface ::ooo::vba::XHelperInterface;
 
+	[attribute] long MissingItemsLimit;
     void Refresh();
 };
 
--- oovbaapi/ooo/vba/excel/XQueryTable.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XQueryTable.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+
+#ifndef __ooo_vba_excel_XQueryTable_idl__
+#define __ooo_vba_excel_XQueryTable_idl__
+                                                     
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba__XHelperInterface_idl__
+#define __ooo_vba__XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  module excel {
+                                                                                                                             
+//=============================================================================
+
+interface XQueryTable 
+{
+	interface com::sun::star::uno::XInterface;
+	//interface ooo::vba::XHelperInterface;
+	boolean Refresh([in] any aBackgroundQuery);
+};
+                                                                                                                             
+}; }; };
+                                                                                                                             
+#endif
+
--- oovbaapi/ooo/vba/excel/XRange.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/excel/XRange.idl	2010-03-03 16:59:34.000000000 +0100
@@ -45,6 +45,9 @@
 #ifndef __com_sun_star_script_XDefaultMethod_idl__
 #include <com/sun/star/script/XDefaultMethod.idl>
 #endif
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#include <com/sun/star/script/XErrorQuery.idl>
+#endif
 #ifndef __ooo_vba_XCollection_idl__
 #include <ooo/vba/XCollection.idl>
 #endif
@@ -72,11 +75,14 @@ interface XBorders;
 interface XValidation;
 interface XWorksheet;
 
+interface XPivotTable;
+interface XQueryTable;
 interface XRange
 {
      interface com::sun::star::container::XEnumerationAccess;
     interface com::sun::star::script::XDefaultMethod;
     interface com::sun::star::script::XDefaultProperty;
+	interface com::sun::star::script::XErrorQuery;
     interface ::ooo::vba::excel::XFormat;
     //interface ::ooo::vba::XHelperInterface;
 
@@ -104,6 +110,7 @@ interface XRange
     [attribute] any Style;
     [attribute] any AddIndent;
     [attribute] any ShowDetail;
+	[attribute, readonly] XQueryTable QueryTable;
 
     XComment AddComment( [in] any Text ); 
     void Clear();
@@ -167,6 +174,8 @@ interface XRange
     void RemoveSubtotal() raises ( com::sun::star::script::BasicErrorException );
     void	Subtotal( [in] long GroupBy, [in] long Function, [in]  /*Optional*/ sequence<long> TotalList, [in]  /*Optional*/ any Replace, [in]  /*Optional*/ any PageBreaks, [in] any SummaryBelowData ) raises ( com::sun::star::script::BasicErrorException );
     XRange MergeArea( ) raises ( com::sun::star::script::BasicErrorException );
+	long   CopyFromRecordset([in] any Data, [in]  any MaxRows , [in]  any MaxColumns) raises ( com::sun::star::script::BasicErrorException );
+	XPivotTable PivotTable();
 
 };
 
--- oovbaapi/ooo/vba/excel/XWorkbook.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XWorkbook.idl	2010-03-03 16:59:34.000000000 +0100
@@ -65,6 +65,8 @@ interface XWorkbook : com::sun::star::un
     any Colors([in] any Index) raises (com::sun::star::script::BasicErrorException);
     long FileFormat() raises (com::sun::star::script::BasicErrorException);
     void SaveCopyAs( [in] string Filename );
+	void Protect( [in] any Password );
+	void SaveAs([in] string FileName, [in]any FileFormat, [in]any CreateBackup);
 };
 
 }; }; };
--- oovbaapi/ooo/vba/excel/XWorksheet.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/excel/XWorksheet.idl	2010-03-03 16:59:34.000000000 +0100
@@ -42,6 +42,9 @@
 #include <com/sun/star/script/XInvocation.idl>
 #endif
 
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
 //=============================================================================
 
 module ooo {  module vba {  module excel { 
@@ -58,9 +61,10 @@ interface XWorksheet
 {
     interface ::ooo::vba::XHelperInterface;
     interface ::com::sun::star::script::XInvocation;
+	interface ::com::sun::star::container::XNamed;
 
-        [attribute] string Name;
     [attribute] boolean Visible; 
+    [attribute] boolean AutoFilterMode; 
     [attribute, readonly] long StandardHeight;
     [attribute, readonly] long StandardWidth;
     [attribute, readonly] boolean ProtectionMode;
--- oovbaapi/ooo/vba/excel/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/excel/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -108,7 +108,13 @@ IDLFILES= XGlobals.idl\
  	XVPageBreak.idl \
  	XVPageBreaks.idl \
  	TextFrame.idl \
-
+ 	XMenuBar.idl \
+ 	XMenuBars.idl \
+ 	XMenu.idl \
+ 	XMenus.idl \
+ 	XMenuItem.idl \
+ 	XMenuItems.idl \
+ 	XQueryTable.idl
 
 # ------------------------------------------------------------------
 
--- oovbaapi/ooo/vba/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -70,7 +70,10 @@ IDLFILES=\
 	XFontBase.idl\
 	XDialogsBase.idl\
 	XDialogBase.idl\
+	XFileSearch.idl\
     XPageSetupBase.idl  \
+    XFileDialog.idl \
+    XFileDialogSelectedItems.idl
 
 # ------------------------------------------------------------------
 .ENDIF
--- oovbaapi/ooo/vba/msforms/XCheckBox.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/msforms/XCheckBox.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XCheckBox.idl,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_msforms_XCheckBox_idl__
+#define __ooo_vba_msforms_XCheckBox_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module msforms { 
+
+//=============================================================================
+interface XCheckBox: com::sun::star::uno::XInterface 
+{
+	[attribute] string Caption;
+	[attribute] any Value;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/msforms/XComboBox.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/msforms/XComboBox.idl	2010-03-03 16:59:34.000000000 +0100
@@ -50,6 +50,7 @@ interface XComboBox: ::com::sun::star::u
     void AddItem( [in] any pvargItem, [in] any pvargIndex );
     void removeItem( [in] any index );
     void Clear();
+    any List( [in] any pvargIndex, [in] any pvarColumn );
 };
 
 //=============================================================================
--- oovbaapi/ooo/vba/msforms/XControl.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/msforms/XControl.idl	2010-03-03 16:59:34.000000000 +0100
@@ -62,6 +62,7 @@ interface XControl
     [attribute] double  Top;
     [attribute] string Name;
 	[attribute] string ControlTipText;
+	[attribute] long ForeColor;
 };
 
 //=============================================================================
--- oovbaapi/ooo/vba/msforms/XLabel.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/msforms/XLabel.idl	2010-03-03 16:59:34.000000000 +0100
@@ -42,6 +42,7 @@ interface XLabel: com::sun::star::uno::X
 {
     [attribute] string Caption;
     [attribute] any Value;
+    [attribute] string Accelerator;
 };
 
 //=============================================================================
--- oovbaapi/ooo/vba/msforms/XListBox.idl.old	2009-10-07 15:07:00.000000000 +0200
+++ oovbaapi/ooo/vba/msforms/XListBox.idl	2010-03-03 16:59:34.000000000 +0100
@@ -43,7 +43,7 @@ interface XListBox: com::sun::star::uno:
 {
     [attribute] any Value;
     [attribute] string Text;
-    [attribute] boolean MultiSelect;
+	[attribute] long MultiSelect; //liuchen 2009-7-31 MultiSelect property in Excel VBA is type long
     [attribute] any ListIndex;
         [attribute, readonly ] long ListCount;
     void AddItem( [in] any pvargItem, [in] any pvargIndex );
--- oovbaapi/ooo/vba/msforms/XShapeRange.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/msforms/XShapeRange.idl	2010-03-03 16:59:34.000000000 +0100
@@ -50,6 +50,7 @@ interface XShapeRange
 {
     interface ooo::vba::XCollection;
 
+    [attribute] string Name;
     [attribute] double Height;
     [attribute] double Width;
     [attribute] double Left;
@@ -68,6 +69,7 @@ interface XShapeRange
     void IncrementRotation( [in] double Increment );
     void IncrementLeft( [in] double Increment );
     void IncrementTop( [in] double Increment );
+    void ZOrder( [in] long ZOrderCmd );
 };
 }; }; };
 
--- oovbaapi/ooo/vba/msforms/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/msforms/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -53,6 +53,7 @@ IDLFILES=\
     XLabel.idl \
     XTextBox.idl \
     XRadioButton.idl \
+	XCheckBox.idl \
     XShape.idl \
     XShapes.idl \
     XLineFormat.idl \
--- oovbaapi/ooo/vba/word/XApplication.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XApplication.idl	2010-03-03 16:59:34.000000000 +0100
@@ -60,6 +60,7 @@ interface XApplication : com::sun::star:
     any Documents( [in] any aIndex );
     any Addins( [in] any aIndex );
     any Dialogs( [in] any aIndex );
+    any ListGalleries( [in] any aIndex );
     float CentimetersToPoints([in] float Centimeters );
 };
 
--- oovbaapi/ooo/vba/word/XCell.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XCell.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCell_idl__
+#define __ooo_vba_word_XCell_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XCell
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Width;
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void SetWidth( [in] float ColumnWidth, [in] long RulerStyle );
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XCells.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XCells.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCells_idl__
+#define __ooo_vba_word_XCells_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XCells 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Width;
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void SetWidth( [in] float ColumnWidth, [in] long RulerStyle );
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XCheckBox.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XCheckBox.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XCheckBox_idl__
+#define __ooo_vba_word_XCheckBox_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XCheckBox
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] boolean Value;
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XColumn.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XColumn.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XColumn_idl__
+#define __ooo_vba_word_XColumn_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XColumn
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Width;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XColumns.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XColumns.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XColumns_idl__
+#define __ooo_vba_word_XColumns_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XColumns 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Width;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XDocument.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XDocument.idl	2010-03-03 16:59:34.000000000 +0100
@@ -52,6 +52,11 @@ interface XDocument : com::sun::star::sc
 {
     [attribute, readonly] XRange Content;
     [attribute] any AttachedTemplate;
+    [attribute] long ProtectionType;
+    [attribute] boolean UpdateStylesOnOpen;
+    [attribute] boolean AutoHyphenation;
+    [attribute] long HyphenationZone;
+    [attribute] long ConsecutiveHyphensLimit;
 
     XRange Range( [in] any Start, [in] any End );
     any BuiltInDocumentProperties( [in] any index );
@@ -66,6 +71,14 @@ interface XDocument : com::sun::star::sc
     any Sections([in] any Index);
 	void Activate();
     any PageSetup();
+    any TablesOfContents([in] any Index);
+    any FormFields([in] any Index);
+	void Protect( [in] long Type, [in] any NOReset, [in] any Password, [in] any UseIRM, [in] any EnforceStyleLock );
+    void PrintOut([in] any Background, [in] any Append, [in] any Range, [in] any OutputFileName, [in] any From, [in] any To, [in] any Item, [in] any Copies, [in] any Pages, [in] any PageType, [in] any PrintToFile, [in] any Collate, [in] any FileName, [in] any ActivePrinterMacGX, [in] any ManualDuplexPrint, [in] any PrintZoomColumn, [in] any PrintZoomRow, [in] any PrintZoomPaperWidth, [in] any PrintZoomPaperHeight);
+    void PrintPreview();
+    void ClosePrintPreview();
+    any Revisions( [in] any index );
+    any Frames( [in] any index );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XField.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XField.idl	2010-03-03 16:59:34.000000000 +0100
@@ -44,6 +44,8 @@ module ooo { module vba { module word {
 interface XField 
 {
     interface ::ooo::vba::XHelperInterface;
+
+    boolean Update();
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XFormField.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XFormField.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFormField_idl__
+#define __ooo_vba_word_XFormField_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFormField
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Result;
+    [attribute] boolean Enabled;
+
+    any CheckBox();
+
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XFormFields.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XFormFields.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFormFields_idl__
+#define __ooo_vba_word_XFormFields_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XFormFields 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XFrame.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XFrame.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFrame_idl__
+#define __ooo_vba_word_XFrame_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFrame
+{
+    interface ooo::vba::XHelperInterface;
+
+    void Select();
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XFrames.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XFrames.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFrames_idl__
+#define __ooo_vba_word_XFrames_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XFrames 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XGlobals.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XGlobals.idl	2010-03-03 16:59:34.000000000 +0100
@@ -52,6 +52,7 @@ interface XGlobals : com::sun::star::uno
     any Documents( [in] any aIndex );
     any Addins( [in] any aIndex );
     any Dialogs( [in] any aIndex );
+    any ListGalleries( [in] any aIndex );
     float CentimetersToPoints([in] float Centimeters );
 };
 
--- oovbaapi/ooo/vba/word/XHeadersFooters.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XHeadersFooters.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XHeadersFooters_idl__
+#define __ooo_vba_word_XHeadersFooters_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XHeadersFooters 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XListFormat.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListFormat.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListFormat_idl__
+#define __ooo_vba_word_XListFormat_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListTemplate;
+interface XListFormat
+{
+    interface ooo::vba::XHelperInterface;
+
+    void ApplyListTemplate([in] XListTemplate ListTemplate,
+        [in] any /* optional */ ContinuePreviousList,
+        [in] any /* optional */ ApplyTo,
+        [in] any /* optional */ DefaultListBehavior);
+    
+    void ConvertNumbersToText();
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XListGalleries.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListGalleries.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListGalleries_idl__
+#define __ooo_vba_word_XListGalleries_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListGalleries 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XListGallery.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListGallery.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListGallery_idl__
+#define __ooo_vba_word_XListGallery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListGallery
+{
+    interface ooo::vba::XHelperInterface;
+
+    any ListTemplates( [in] any aIndex );
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XListLevel.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListLevel.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListLevel_idl__
+#define __ooo_vba_word_XListLevel_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFont;
+interface XListLevel
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Alignment;
+    [attribute] XFont Font;
+    [attribute, readonly] long Index;
+    [attribute] string LinkedStyle;
+    [attribute] string NumberFormat;
+    [attribute] float NumberPosition;
+    [attribute] long NumberStyle;
+    [attribute] long ResetOnHigher;
+    [attribute] long StartAt;
+    [attribute] float TabPosition;
+    [attribute] float TextPosition;
+    [attribute] long TrailingCharacter;
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XListLevels.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListLevels.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListLevels_idl__
+#define __ooo_vba_word_XListLevels_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListLevels 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XListTemplate.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListTemplate.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListTemplate_idl__
+#define __ooo_vba_word_XListTemplate_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XListTemplate
+{
+    interface ooo::vba::XHelperInterface;
+
+    any ListLevels( [in] any aIndex );
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XListTemplates.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XListTemplates.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XListTemplates_idl__
+#define __ooo_vba_word_XListTemplates_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XListTemplates 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XParagraph.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XParagraph.idl	2010-03-03 16:59:34.000000000 +0100
@@ -46,6 +46,7 @@ interface XParagraph
     interface ooo::vba::XHelperInterface;
 
     [attribute, readonly] XRange Range;
+    [attribute] any Style;
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XRange.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XRange.idl	2010-03-03 16:59:34.000000000 +0100
@@ -48,13 +48,14 @@ module ooo {  module vba {  module word
 interface XParagraphFormat;
 interface XStyle;
 interface XFont;
+interface XListFormat;
 interface XRange
 {
     interface ooo::vba::XHelperInterface;
 
     [attribute] string Text;
     [attribute] XParagraphFormat ParagraphFormat;
-    [attribute] XStyle Style;
+    [attribute] any Style;
     [attribute,readonly] ::com::sun::star::text::XTextRange XTextRange;
     // Of course Font is NOT readonly, #FIXME #TODO
     // readonly though will force an error attempting to write
@@ -62,6 +63,7 @@ interface XRange
     [attribute] long LanguageID;
     [attribute] long Start;
     [attribute] long End;
+    [attribute, readonly] XListFormat ListFormat;
 
     void InsertBreak( [in] any Type );
     void Select();
@@ -69,6 +71,10 @@ interface XRange
     void InsertParagraphBefore();
     void InsertParagraphAfter();
     any PageSetup();
+    boolean InRange( [in] XRange Range );
+    any Revisions( [in] any index );
+    any Sections( [in] any index );
+    any Fields( [in] any index );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XReplacement.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XReplacement.idl	2010-03-03 16:59:34.000000000 +0100
@@ -45,6 +45,8 @@ interface XReplacement
     interface ooo::vba::XHelperInterface;
 
     [attribute] string Text;
+
+    void ClearFormatting();
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XRevision.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XRevision.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRevision_idl__
+#define __ooo_vba_word_XRevision_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XRevision
+{
+    interface ooo::vba::XHelperInterface;
+
+    void Accept();
+    void Reject();
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XRevisions.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XRevisions.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRevisions_idl__
+#define __ooo_vba_word_XRevisions_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XRevisions 
+{
+	interface ::ooo::vba::XCollection;
+
+    void AcceptAll();
+    void RejectAll();
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XRow.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XRow.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRow_idl__
+#define __ooo_vba_word_XRow_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRow
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] any Height;
+    [attribute] long HeightRule;
+
+    void Select();
+    void SetHeight( [in] float RowHeight, [in] long HeightRule );
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XRows.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XRows.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRows_idl__
+#define __ooo_vba_word_XRows_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XRows 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long Alignment;
+    [attribute] any AllowBreakAcrossPages;
+    [attribute] float SpaceBetweenColumns;
+
+    void Delete();
+    void SetLeftIndent( [in] float LeftIndent, [in] long RulerStyle );
+    void Select();
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XSection.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XSection.idl	2010-03-03 16:59:34.000000000 +0100
@@ -46,8 +46,8 @@ interface XSection
 
     [attribute] boolean ProtectedForForms;
 
-    any Headers();
-    any Footers();
+    any Headers( [in] any aIndex );
+    any Footers( [in] any aIndex );
     any PageSetup();
 };
 
--- oovbaapi/ooo/vba/word/XSelection.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XSelection.idl	2010-03-03 16:59:34.000000000 +0100
@@ -55,7 +55,7 @@ interface XSelection
     [attribute, readonly] XRange Range;
     [attribute] XParagraphFormat ParagraphFormat;
     [attribute, readonly] XFind Find;
-    [attribute] XStyle Style;
+    [attribute] any Style;
     [attribute, readonly] XFont Font;
     [attribute, readonly] XHeaderFooter HeaderFooter;
     [attribute] long LanguageID;
@@ -71,6 +71,7 @@ interface XSelection
     void MoveRight( [in] any Unit, [in] any Count, [in] any Extend );
     void MoveLeft( [in] any Unit, [in] any Count, [in] any Extend );
     void MoveDown( [in] any Unit, [in] any Count, [in] any Extend );
+    void MoveUp( [in] any Unit, [in] any Count, [in] any Extend );
     void TypeParagraph();
     void InsertParagraph();
     void InsertParagraphBefore();
@@ -80,6 +81,19 @@ interface XSelection
     any Information( [in] long Type );
     void InsertBreak( [in] any Type );
     any ShapeRange();
+    void SelectColumn();
+    void SelectRow();
+    any Rows( [in] any aIndex );
+    any Columns( [in] any aIndex );
+    any Cells( [in] any aIndex );
+    void Copy();
+    void CopyAsPicture();
+    void Paste();
+    void Collapse([in] any Direction);
+    void WholeStory();
+    boolean InRange( [in] XRange Range );
+    void SplitTable();
+    any Paragraphs( [in] any aIndex );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XStyle.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XStyle.idl	2010-03-03 16:59:34.000000000 +0100
@@ -38,17 +38,32 @@
 #include <ooo/vba/XHelperInterface.idl>
 #endif
 
+#ifndef __com_sun_star_script_XDefaultProperty_idl__
+#include <com/sun/star/script/XDefaultProperty.idl>
+#endif
+
 module ooo {  module vba {  module word { 
 
 interface XFont;
+interface XListTemplate;
+interface XParagraphFormat;
 interface XStyle
 {
     interface ooo::vba::XHelperInterface;
+    interface com::sun::star::script::XDefaultProperty;
 
     [attribute] string Name;
     [attribute] long LanguageID;
     [attribute, readonly] long Type;
     [attribute, readonly] XFont Font;
+    [attribute] string NameLocal;
+    [attribute, readonly] XParagraphFormat ParagraphFormat;
+    [attribute] boolean AutomaticallyUpdate;
+    [attribute] any BaseStyle;
+    [attribute] any NextParagraphStyle;
+    [attribute, readonly] long ListLevelNumber;
+
+    void LinkToListTemplate( [in] XListTemplate ListTemplate, [in] any ListLevelNumber );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XTabStop.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTabStop.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTabStop_idl__
+#define __ooo_vba_word_XTabStop_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XTabStop
+{
+    interface ooo::vba::XHelperInterface;
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XTabStops.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTabStops.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTabStops_idl__
+#define __ooo_vba_word_XTabStops_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XTabStop;
+interface XTabStops 
+{
+	interface ::ooo::vba::XCollection;
+
+    XTabStop Add([in] float Position, [in] any Alignment, [in] any Leader );
+    void ClearAll();
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XTable.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTable.idl	2010-03-03 16:59:34.000000000 +0100
@@ -77,7 +77,9 @@ interface XTable
         raises(com::sun::star::script::BasicErrorException);
 */
     any Borders( [in] any aIndex );
-
+    
+    any Rows([in] any aIndex );
+    any Columns([in] any aIndex );
 };
 
 }; }; };
--- oovbaapi/ooo/vba/word/XTableOfContents.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTableOfContents.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTableOfContents_idl__
+#define __ooo_vba_word_XTableOfContents_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XTableOfContents
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long LowerHeadingLevel;
+    [attribute] long TabLeader;
+    [attribute] boolean UseFields;
+    [attribute] boolean UseOutlineLevels;
+
+    void Delete();
+    void Update();
+};
+
+}; }; };
+
+#endif
+
+
--- oovbaapi/ooo/vba/word/XTablesOfContents.idl.old	2010-03-03 16:59:34.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTablesOfContents.idl	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTablesOfContents_idl__
+#define __ooo_vba_word_XTablesOfContents_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XTableOfContents;
+interface XRange;
+interface XTablesOfContents 
+{
+	interface ::ooo::vba::XCollection;
+
+    XTableOfContents Add([in] XRange Range, [in] any UseHeadingStyles, [in] any UpperHeadingLevel, [in] any LowerHeadingLevel, [in] any UseFields, [in] any TableID, [in] any RightAlignPageNumbers, [in] any IncludePageNumbers, [in] any AddedStyles, [in] any UseHyperlinks, [in] any HidePageNumbersInWeb, [in] any UseOutlineLevels );
+};
+
+}; }; };
+
+#endif
--- oovbaapi/ooo/vba/word/XTemplate.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XTemplate.idl	2010-03-03 16:59:34.000000000 +0100
@@ -45,6 +45,7 @@ interface XTemplate
     interface ooo::vba::XHelperInterface;
 
     [attribute, readonly] string Name;
+    [attribute, readonly] string Path;
 
     any AutoTextEntries( [in] any aIndex );
 };
--- oovbaapi/ooo/vba/word/XWindow.idl.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/XWindow.idl	2010-03-03 16:59:34.000000000 +0100
@@ -47,6 +47,7 @@ module ooo {  module vba {  module word
 interface XWindow : com::sun::star::uno::XInterface
 {
     [attribute] any View;
+    [attribute] any WindowState;
 	void Activate();
     void Close([in] any SaveChanges, [in] any RouteDocument);
 	any Panes( [in] any aIndex ); // this is a fake api for it seems not support in Write
--- oovbaapi/ooo/vba/word/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ oovbaapi/ooo/vba/word/makefile.mk	2010-03-03 16:59:34.000000000 +0100
@@ -83,6 +83,31 @@ IDLFILES= XGlobals.idl\
 	XPageSetup.idl \
 	XSection.idl \
 	XSections.idl \
+	XRow.idl \
+	XRows.idl \
+	XColumn.idl \
+	XColumns.idl \
+	XCell.idl \
+	XCells.idl \
+	XTabStop.idl \
+	XTabStops.idl \
+	XTableOfContents.idl \
+	XTablesOfContents.idl \
+	XListFormat.idl \
+	XListGalleries.idl \
+	XListGallery.idl \
+	XListTemplate.idl \
+	XListTemplates.idl \
+	XListLevel.idl \
+	XListLevels.idl \
+	XFormField.idl \
+	XFormFields.idl \
+	XRevision.idl \
+	XRevisions.idl \
+	XFrame.idl \
+	XFrames.idl \
+	XCheckBox.idl \
+	XHeadersFooters.idl \
 
 # ------------------------------------------------------------------
 
--- sc/inc/address.hxx.old	2010-03-03 16:59:17.000000000 +0100
+++ sc/inc/address.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -230,6 +230,9 @@ inline SCTAB SanitizeTab( SCTAB nTab, SC
 #define SCA_VALID_ROW       0x0100
 #define SCA_VALID_COL       0x0200
 #define SCA_VALID_TAB       0x0400
+// SCA_BITS is a convience for 
+// (SCA_VALID_TAB | SCA_VALID_COL | SCA_VALID_ROW | SCA_TAB_3D | SCA_TAB_ABSOLUTE | SCA_ROW_ABSOLUTE | SCA_COL_ABSOLUTE)
+#define SCA_BITS            0x070F
 // somewhat cheesy kludge to force the display of the document name even for
 // local references.  Requires TAB_3D to be valid
 #define SCA_FORCE_DOC       0x0800
--- sc/inc/addruno.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/inc/addruno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -50,7 +50,7 @@ private:
     sal_Int32               nRefSheet;
     sal_Bool                bIsRange;
 
-    sal_Bool                ParseUIString( const String& rUIString );
+    sal_Bool                ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv = ::formula::FormulaGrammar::CONV_OOO );
 
 public:
 
--- sc/inc/cell.hxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/inc/cell.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -409,7 +409,7 @@ public:
                                 const formula::FormulaGrammar::Grammar = formula::FormulaGrammar::GRAM_DEFAULT ) const;
 
     void			SetDirty();
-    inline void		SetDirtyVar() { bDirty = TRUE; }
+	void			SetDirtyVar();
     // If setting entire document dirty after load, no broadcasts but still append to FormulaTree.
     void            SetDirtyAfterLoad();
     inline void		ResetTableOpDirtyVar() { bTableOpDirty = FALSE; }
--- sc/inc/document.hxx.old	2010-03-03 16:59:20.000000000 +0100
+++ sc/inc/document.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -97,6 +97,7 @@ class ScDrawLayer;
 class ScExtDocOptions;
 class ScExternalRefManager;
 class ScFormulaCell;
+class ScMacroManager;
 class ScMarkData;
 class ScOutlineTable;
 class ScPatternAttr;
@@ -160,6 +161,9 @@ namespace com { namespace sun { namespac
     }
 } } }
 
+namespace com { namespace sun { namespace star { namespace document {
+    class XVbaEventsHelper;
+} } } }
 #include <svtools/zforlist.hxx>
 /*
 #ifdef _ZFORLIST_DECLARE_TABLE
@@ -290,12 +294,15 @@ private:
     ::std::auto_ptr<ScClipParam>     mpClipParam;
 
     ::std::auto_ptr<ScExternalRefManager> pExternalRefMgr;
+    ::std::auto_ptr<ScMacroManager> mpMacroMgr;
+
 
     // mutable for lazy construction
     mutable ::std::auto_ptr< ScFormulaParserPool >
                         mxFormulaParserPool;            /// Pool for all external formula parsers used by this document.
 
     String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
     ScRangePairListRef	xColNameRanges;
     ScRangePairListRef	xRowNameRanges;
 
@@ -322,6 +329,8 @@ private:
 
     Timer				aTrackTimer;
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > mxVbaEventsHelper;
+
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -422,6 +431,9 @@ private:
 
     sal_Int16           mnNamedRangesLockCount;
 
+	// for worksheet calculate event
+	::std::vector< SCTAB > maTabs;
+
 public:
     SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
     ULONG			GetWeightedCount() const;	// Formeln und Edit staerker gewichtet
@@ -438,7 +450,10 @@ public:
 
     SC_DLLPUBLIC const String& 	GetName() const { return aDocName; }
     void			SetName( const String& r ) { aDocName = r; }
-
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
+    
+    SC_DLLPUBLIC NameToNameMap*              GetLocalNameMap( SCTAB& rTab );
     void			GetDocStat( ScDocStat& rDocStat );
 
     SC_DLLPUBLIC void			InitDrawLayer( SfxObjectShell* pDocShell = NULL );
@@ -523,6 +538,8 @@ public:
 
     SC_DLLPUBLIC BOOL			HasTable( SCTAB nTab ) const;
     SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
     SC_DLLPUBLIC BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
     SC_DLLPUBLIC inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
     SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
@@ -869,6 +886,10 @@ public:
     BOOL			IsForcedFormulaPending() const { return bForcedFormulaPending; }
                     // if CalcFormulaTree() is currently running
     BOOL			IsCalculatingFormulaTree() { return bCalculatingFormulaTree; }
+	
+					// for worksheet calculate event
+	BOOL			FireCalculateEvent( SCTAB nTab );
+	void			AddCalculateTable( SCTAB nTab );
 
     USHORT			GetErrCode( const ScAddress& ) const;
 
@@ -917,7 +938,7 @@ public:
                                SCROW nStartRow, SCSIZE nSize,
                                ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL,
                                const ScMarkData* pTabMark = NULL );
-    void			DeleteRow( const ScRange& rRange,
+	SC_DLLPUBLIC void	DeleteRow( const ScRange& rRange,
                                ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL );
     BOOL			InsertCol( SCROW nStartRow, SCTAB nStartTab,
                                SCROW nEndRow,   SCTAB nEndTab,
@@ -1541,6 +1562,7 @@ public:
     SC_DLLPUBLIC ScLkUpdMode		GetLinkMode() const				{ return eLinkMode ;}
     void			SetLinkMode( ScLkUpdMode nSet )	{ 	eLinkMode  = nSet;}
 
+    SC_DLLPUBLIC ScMacroManager* GetMacroManager();
 
 private:
     ScDocument(const ScDocument& r); // disabled with no definition
@@ -1750,6 +1772,8 @@ public:
     void GetSortParam( ScSortParam& rParam, SCTAB nTab );
     void SetSortParam( ScSortParam& rParam, SCTAB nTab );
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > GetVbaEventsHelper();
+
     /** Should only be GRAM_PODF or GRAM_ODFF. */
     void                SetStorageGrammar( formula::FormulaGrammar::Grammar eGrammar );
     formula::FormulaGrammar::Grammar  GetStorageGrammar() const
--- sc/inc/docuno.hxx.old	2009-10-19 13:27:16.000000000 +0200
+++ sc/inc/docuno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -56,6 +56,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/sheet/XCellRangesAccess.hpp>
 #include <com/sun/star/util/XChangesNotifier.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
@@ -90,6 +91,7 @@ class SC_DLLPUBLIC ScModelObj : public S
                     public com::sun::star::view::XRenderable,
                     public com::sun::star::document::XLinkTargetSupplier,
                     public com::sun::star::beans::XPropertySet,
+                    public com::sun::star::document::XDocumentEventCompatibleHelper,
                     public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo,
                     public ::com::sun::star::util::XChangesNotifier
@@ -320,6 +322,8 @@ public:
     virtual void SAL_CALL removeChangesListener( const ::com::sun::star::uno::Reference<
                                     ::com::sun::star::util::XChangesListener >& aListener )
                                 throw (::com::sun::star::uno::RuntimeException);
+                            // XVbaEventHelper
+    virtual sal_Bool SAL_CALL processCompatibleEvent( sal_Int16 nEventId ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 
--- sc/inc/global.hxx.old	2010-03-03 16:59:18.000000000 +0100
+++ sc/inc/global.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -228,6 +228,7 @@ const USHORT IDF_HARDATTR   = 0x0020;
 const USHORT IDF_STYLES     = 0x0040;   /// Cell styles.
 const USHORT IDF_OBJECTS    = 0x0080;   /// Drawing objects.
 const USHORT IDF_EDITATTR   = 0x0100;   /// Rich-text attributes.
+const USHORT IDF_SPECIAL_BOOLEAN = 0x1000;
 const USHORT IDF_ATTRIB     = IDF_HARDATTR | IDF_STYLES;
 const USHORT IDF_CONTENTS   = IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_NOTE | IDF_FORMULA;
 const USHORT IDF_ALL        = IDF_CONTENTS | IDF_ATTRIB | IDF_OBJECTS;
--- sc/inc/globstr.hrc.old	2010-03-03 16:44:04.000000000 +0100
+++ sc/inc/globstr.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -576,7 +576,23 @@
 #define STR_UNDO_SET_TAB_BG_COLOR       435
 #define STR_UNDO_SET_MULTI_TAB_BG_COLOR 436
 
-#define STR_COUNT                   437
+#define STR_SHAPE_AUTOSHAPE         437
+#define STR_SHAPE_RECTANGLE         438
+#define STR_SHAPE_LINE              439
+#define STR_SHAPE_OVAL              440
+#define STR_SHAPE_TEXTBOX           441
+                                       
+#define STR_FORM_BUTTON             442
+#define STR_FORM_CHECKBOX           443
+#define STR_FORM_OPTIONBUTTON       444
+#define STR_FORM_LABEL              445
+#define STR_FORM_LISTBOX            446
+#define STR_FORM_GROUPBOX           447
+#define STR_FORM_DROPDOWN           448
+#define STR_FORM_SPINNER            449
+#define STR_FORM_SCROLLBAR          450
+
+#define STR_COUNT                   451
 
 #endif
 
--- sc/inc/macromgr.hxx.old	2010-03-03 16:59:34.000000000 +0100
+++ sc/inc/macromgr.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_MACROMGR_HXX
+#define SC_MACROMGR_HXX
+
+#include <com/sun/star/container/XContainerListener.hpp>
+
+#include "rtl/ustring.hxx"
+#include "scdllapi.h"
+
+#include <hash_map>
+#include <memory>
+
+class ScDocument;
+class ScFormulaCell;
+class ScUserMacroDepTracker;
+
+class ScMacroManager
+{
+public:
+    explicit ScMacroManager(ScDocument* pDoc);
+    ~ScMacroManager();
+
+    SC_DLLPUBLIC void InitUserFuncData();
+    SC_DLLPUBLIC void SetUserFuncVolatile( const rtl::OUString& sName, bool isVolatile );
+    SC_DLLPUBLIC bool GetUserFuncVolatile( const rtl::OUString& sName );
+
+    void AddDependentCell(const ::rtl::OUString& aModuleName, ScFormulaCell* pCell);
+    void RemoveDependentCell(ScFormulaCell* pCell);
+    void BroadcastModuleUpdate(const ::rtl::OUString& aModuleName);
+
+private:
+    typedef std::hash_map< ::rtl::OUString, bool, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameBoolMap;
+    NameBoolMap mhFuncToVolatile;
+    com::sun::star::uno::Reference< com::sun::star::container::XContainerListener > mxContainerListener;
+
+    ::std::auto_ptr<ScUserMacroDepTracker> mpDepTracker;
+    ScDocument* mpDoc;
+};
+
+#endif
+
--- sc/inc/rangenam.hxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/inc/rangenam.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -145,7 +145,7 @@ public:
 
     SC_DLLPUBLIC BOOL			IsReference( ScRange& rRef ) const;
     BOOL			IsReference( ScRange& rRef, const ScAddress& rPos ) const;
-    BOOL			IsValidReference( ScRange& rRef ) const;
+    SC_DLLPUBLIC BOOL			IsValidReference( ScRange& rRef ) const;
 
 //UNUSED2009-05 BOOL			IsRangeAtCursor( const ScAddress&, BOOL bStartOnly ) const;
     BOOL			IsRangeAtBlock( const ScRange& ) const;
--- sc/inc/sc.hrc.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/inc/sc.hrc	2010-03-03 16:59:34.000000000 +0100
@@ -593,11 +593,9 @@
 // #i59082# assign macro to shape
 #define SID_ASSIGNMACRO                 (SC_VIEW_START + 95)
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 // #i66550# hyperlinks in shapes
 #define SID_DRAW_HLINK_EDIT             (SC_VIEW_START + 96)
 #define SID_DRAW_HLINK_DELETE           (SC_VIEW_START + 97)
-#endif
 
 // "Zoom / Synchronize sheets" in options dialog
 #define SID_SC_OPT_SYNCZOOM             (SC_VIEW_START + 98)
@@ -1672,6 +1670,11 @@
 #define RID_SCPAGE_FORMULA          (SC_OOO_BUILD_START + 3)
 #define HID_SCPAGE_FORMULA          (SC_OOO_BUILD_START + 4)
 
+// Data Form
+#define SID_DATAFORM_NEW            (SC_OOO_BUILD_START + 5) // message
+#define SID_DATA_FORM               (SC_OOO_BUILD_START + 6) // menu (in Data menu)
+#define RID_SCDLG_DATAFORM          (SC_OOO_BUILD_START + 7) // dialog
+
 #endif 
 
 
--- sc/inc/scabstdlg.hxx.old	2010-03-03 16:44:04.000000000 +0100
+++ sc/inc/scabstdlg.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -43,6 +43,8 @@
 #include "pivot.hxx"
 #include "i18npool/lang.h"
 
+#include <tabvwsh.hxx>
+
 class ScAsciiOptions;
 class ScAutoFormat;
 class ScAutoFormatData;
@@ -113,6 +115,12 @@ public:
     virtual DelCellCmd GetDelCellCmd() const = 0;
 };
 
+//for dataform
+class AbstractScDataFormDlg : public VclAbstractDialog  //add for ScDeleteCellDlg
+{
+
+};
+
 class AbstractScDeleteContentsDlg: public VclAbstractDialog  //add for ScDeleteContentsDlg
 {
 public:
@@ -309,7 +317,7 @@ public:
 class ScAbstractDialogFactory
 {
 public:
-    static ScAbstractDialogFactory* 	Create();
+	SC_DLLPUBLIC static ScAbstractDialogFactory* 	Create();
 
     virtual 	AbstractScImportAsciiDlg * CreateScImportAsciiDlg( Window* pParent, String aDatName, //add for ScImportAsciiDlg
                                                                     SvStream* pInStream, int nId,
@@ -343,6 +351,9 @@ public:
 
     virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId, BOOL bDisallowCellMove = FALSE ) = 0 ; //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell ) = 0 ; //add for ScDataFormDlg
+
     virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults = 0 ) = 0;
     virtual AbstractScFillSeriesDlg * CreateScFillSeriesDlg( Window*		pParent, //add for ScFillSeriesDlg
--- sc/inc/scextopt.hxx.old	2010-03-03 16:59:12.000000000 +0100
+++ sc/inc/scextopt.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -127,6 +127,8 @@ public:
     const String&       GetCodeName( size_t nIdx ) const;
     /** Appends a codename for a sheet. */
     void                AppendCodeName( const String& rCodeName );
+    void                SetCodeName( const String& rCodeName, size_t nIdx );
+    void                DeleteCodeName( size_t nIdx );
 
 private:
     ::std::auto_ptr< ScExtDocOptionsImpl > mxImpl;
--- sc/inc/servuno.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/inc/servuno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -93,8 +93,9 @@ class ScDocShell;
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
-
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_VBACODENAMEPROVIDER   41
+#define SC_SERVICE_COUNT        42
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
--- sc/inc/shapeuno.hxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/inc/shapeuno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -55,6 +55,7 @@ namespace com { namespace sun { namespac
 class SdrObject;
 struct SvEventDescription;
 class ShapeUnoEventAccessImpl;
+class  ScMacroInfo;
 
 //------------------------------------------------------------------------
 
@@ -73,6 +74,7 @@ class ScShapeObj    :public ScShapeObj_B
                     ,public ScShapeObj_TextBase
 {
 private:
+friend  ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate );
     ::com::sun::star::uno::Reference< ::com::sun::star::uno::XAggregation > mxShapeAgg;
     // cached pointers to avoid repeated queryAggregation calls:
     ::com::sun::star::beans::XPropertySet*                                  pShapePropertySet;
--- sc/inc/table.hxx.old	2010-03-03 16:59:20.000000000 +0100
+++ sc/inc/table.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -89,6 +89,8 @@ class ScFlatUInt16RowSegments;
 class ScFlatBoolRowSegments;
 class ScFlatBoolColSegments;
 
+typedef std::hash_map< ::rtl::OUString, rtl::OUString, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameToNameMap;
+
 class ScTable
 {
 private:
@@ -101,6 +103,7 @@ private:
     ScColumn		aCol[MAXCOLCOUNT];
 
     String			aName;
+	String			aCodeName;
     String			aComment;
     BOOL			bScenario;
     BOOL			bLayoutRTL;
@@ -178,6 +181,7 @@ private:
     Color			aScenarioColor;
     USHORT			nScenarioFlags;
     BOOL			bActiveScenario;
+    NameToNameMap       localNameToGlobalName;
     bool            mbPageBreaksValid;
 
 friend class ScDocument;					// fuer FillInfo
@@ -251,6 +255,9 @@ public:
     void		GetName( String& rName ) const;
     void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
     const String&	GetPageStyle() const					{ return aPageStyle; }
--- sc/inc/unonames.hxx.old	2010-03-03 16:44:04.000000000 +0100
+++ sc/inc/unonames.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -186,6 +186,8 @@
 #define SC_UNONAME_ANCHOR           "Anchor"
 #define SC_UNONAME_HORIPOS          "HoriOrientPosition"
 #define SC_UNONAME_VERTPOS          "VertOrientPosition"
+//     #i66550 HLINK_FOR_SHAPES
+#define SC_UNONAME_HYPERLINK        "Hyperlink" 
 
 //	other cell properties
 #define SC_UNONAME_CHCOLHDR			"ChartColumnAsLabel"
@@ -529,6 +531,7 @@
 #define SC_UNO_ZOOMTYPE             "ZoomType"
 #define SC_UNO_ZOOMVALUE            "ZoomValue"
 #define SC_UNO_UPDTEMPL             "UpdateFromTemplate"
+#define SC_UNO_FILTERED_RANGE_SELECTION       "FilteredRangeSelection"
 #define SC_UNO_TABCOLOR             "TabColor"
  
 /*Stampit enable/disable print cancel */
@@ -601,6 +604,7 @@
 #define SC_UNONAME_ADDRESS          "Address"
 #define SC_UNONAME_UIREPR           "UserInterfaceRepresentation"
 #define SC_UNONAME_PERSREPR         "PersistentRepresentation"
+#define SC_UNONAME_XL_A1_REPR       "XL_A1_Representation"
 #define SC_UNONAME_REFSHEET         "ReferenceSheet"
 
 // --> PB 2004-08-23 #i33095# Security Options
--- sc/inc/userdat.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/inc/userdat.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -102,16 +102,12 @@ public:
     void            SetMacro( const rtl::OUString& rMacro ) { maMacro = rMacro; }
     const rtl::OUString& GetMacro() const { return maMacro; }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void            SetHlink( const rtl::OUString& rHlink ) { maHlink = rHlink; }
     const rtl::OUString& GetHlink() const { return maHlink; }
-#endif
 
 private:
     rtl::OUString   maMacro;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     rtl::OUString   maHlink;
-#endif
 };
 
 //-------------------------------------------------------------------------
--- sc/inc/viewuno.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/inc/viewuno.hxx	2010-03-03 16:59:34.000000000 +0100
@@ -198,6 +198,7 @@ private:
     XMouseClickHandlerArr_Impl              aMouseClickHandlers;
     XActivationEventListenerArr_Impl        aActivationListeners;
     sal_Bool								bDrawSelModeSet;
+    sal_Bool                                bFilteredRangeSelection;
 
     ScViewPaneObj*			GetObjectByIndex_Impl(USHORT nIndex) const;
     INT16                   GetZoom(void) const;
--- sc/sdi/cellsh.sdi.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/sdi/cellsh.sdi	2010-03-03 16:59:34.000000000 +0100
@@ -60,6 +60,7 @@ interface CellSelection
     SID_SBA_BRW_INSERT		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_SELECT_DB			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_SORT				[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
+	SID_DATA_FORM			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     FID_FILTER_OK			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_AUTO_FILTER			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
     SID_AUTOFILTER_HIDE		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
--- sc/sdi/drawsh.sdi.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/sdi/drawsh.sdi	2010-03-03 16:59:34.000000000 +0100
@@ -229,9 +229,9 @@ interface TableDraw
     SID_FONTWORK_CHARACTER_SPACING_DIALOG	[ ExecMethod = ExecDrawFunc ; StateMethod = GetDrawFuncState ; ]
 
 // ISSUE66550_HLINK_FOR_SHAPES
-//    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
 }
 
 
--- sc/sdi/scalc.sdi.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/sdi/scalc.sdi	2010-03-03 16:59:34.000000000 +0100
@@ -1579,6 +1579,31 @@ SfxVoidItem DataSelect SID_DATA_SELECT
 SfxVoidItem DataSort SID_SORT
 (SfxBoolItem ByRows SID_SORT_BYROW,SfxBoolItem HasHeader SID_SORT_HASHEADER,SfxBoolItem CaseSensitive SID_SORT_CASESENS,SfxBoolItem NaturalSort SID_SORT_NATURALSORT,SfxBoolItem IncludeAttribs SID_SORT_ATTRIBS,SfxUInt16Item UserDefIndex SID_SORT_USERDEF,SfxInt32Item Col1 FN_PARAM_1,SfxBoolItem Ascending1 FN_PARAM_2,SfxInt32Item Col2 FN_PARAM_3,SfxBoolItem Ascending2 FN_PARAM_4,SfxInt32Item Col3 FN_PARAM_5,SfxBoolItem Ascending3 FN_PARAM_6)
 [
+	/* flags: */
+	AutoUpdate = FALSE,
+	Cachable = Cachable,
+	FastCall = FALSE,
+	HasCoreId = FALSE,
+	HasDialog = TRUE,
+	ReadOnlyDoc = TRUE,
+	Toggle = FALSE,
+	Container = FALSE,
+	RecordAbsolute = FALSE,
+	RecordPerSet;
+	Synchron;
+
+	/* config: */
+	AccelConfig = TRUE,
+	MenuConfig = TRUE,
+	StatusBarConfig = FALSE,
+	ToolBoxConfig = FALSE,
+	GroupId = GID_DATA;
+]
+
+//--------------------------------------------------------------------------
+SfxVoidItem DataForm SID_DATA_FORM
+()
+[
     /* flags: */
     AutoUpdate = FALSE,
     Cachable = Cachable,
@@ -6271,55 +6296,55 @@ SfxVoidItem StandardFonts SID_STANDARD_F
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = FALSE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = TRUE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
+SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
+()
+[
+   /* flags: */
+   AutoUpdate = FALSE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = TRUE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
+
 //   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = TRUE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = FALSE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
-//   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
+()
+[
+   /* flags: */
+   AutoUpdate = TRUE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = FALSE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
+
+   /* config: */
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
 
 //--------------------------------------------------------------------------
 SfxVoidItem StandardTextAttributes SID_TEXT_STANDARD
--- sc/source/core/data/cell.cxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/source/core/data/cell.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -54,6 +54,7 @@
 #include "recursionhelper.hxx"
 #include "postit.hxx"
 #include "externalrefmgr.hxx"
+#include "macromgr.hxx"
 #include <svx/editobj.hxx>
 #include <svtools/intitem.hxx>
 #include <svx/flditem.hxx>
@@ -822,10 +823,13 @@ ScFormulaCell::ScFormulaCell( const ScFo
 ScFormulaCell::~ScFormulaCell()
 {
     pDocument->RemoveFromFormulaTree( this );
+
+    if (pCode->HasOpCode(ocMacro))
+        pDocument->GetMacroManager()->RemoveDependentCell(this);
 
     if (pDocument->HasExternalRefManager())
         pDocument->GetExternalRefManager()->removeRefCell(this);
 
     delete pCode;
 #ifdef DBG_UTIL
     eCellType = CELLTYPE_DESTROYED;
@@ -1469,6 +1473,9 @@ void ScFormulaCell::Interpret()
             }
         } while (bIterationFromRecursion || bResumeIteration);
     }
+
+	// Fire worksheet calculate event
+	pDocument->FireCalculateEvent( aPos.Tab() );
 }
 
 void ScFormulaCell::InterpretTail( ScInterpretTailParameter eTailParam )
@@ -1741,6 +1748,36 @@ void ScFormulaCell::InterpretTail( ScInt
         // Reschedule verlangsamt das ganze erheblich, nur bei Prozentaenderung ausfuehren
         ScProgress::GetInterpretProgress()->SetStateCountDownOnPercent(
             pDocument->GetFormulaCodeInTree()/MIN_NO_CODES_PER_PROGRESS_UPDATE );
+
+        switch (p->GetVolatileType())
+        {
+            case ScInterpreter::VOLATILE:
+                // Volatile via built-in volatile functions.  No actions needed.
+            break;
+            case ScInterpreter::VOLATILE_MACRO:
+                // The formula contains a volatile macro.
+                pCode->SetRecalcModeAlways();
+                pDocument->PutInFormulaTree(this);
+                StartListeningTo(pDocument);
+            break;
+            case ScInterpreter::NOT_VOLATILE:
+                if (pCode->IsRecalcModeAlways())
+                {
+                    // The formula was previously volatile, but no more.
+                    EndListeningTo(pDocument);
+                    pCode->SetRecalcModeNormal();
+                }
+                else
+                {    
+                    // non-volatile formula.  End listening to the area in case 
+                    // it's listening due to macro module change.
+                    pDocument->EndListeningArea(BCA_LISTEN_ALWAYS, this);
+                }
+                pDocument->RemoveFromFormulaTree(this);
+            break;
+            default:
+                ;
+        }
     }
     else
     {
@@ -1808,7 +1845,7 @@ void __EXPORT ScFormulaCell::Notify( Svt
             else
             {
                 bForceTrack = !bDirty;
-                bDirty = TRUE;
+				SetDirtyVar();
             }
             // #35962# Don't remove from FormulaTree to put in FormulaTrack to
             // put in FormulaTree again and again, only if necessary.
@@ -1831,7 +1868,7 @@ void ScFormulaCell::SetDirty()
     if ( !IsInChangeTrack() )
     {
         if ( pDocument->GetHardRecalcState() )
-            bDirty = TRUE;
+			SetDirtyVar();
         else
         {
             // Mehrfach-FormulaTracking in Load und in CompileAll
@@ -1840,7 +1877,7 @@ void ScFormulaCell::SetDirty()
             // setzen, z.B. in CompileTokenArray
             if ( !bDirty || !pDocument->IsInFormulaTree( this ) )
             {
-                bDirty = TRUE;
+				SetDirtyVar();
                 pDocument->AppendToFormulaTrack( this );
                 pDocument->TrackFormulas();
             }
@@ -1851,6 +1888,13 @@ void ScFormulaCell::SetDirty()
     }
 }
 
+void ScFormulaCell::SetDirtyVar()
+{
+	bDirty = TRUE;
+	// mark the sheet of this cell to be calculated
+	pDocument->AddCalculateTable( aPos.Tab() );
+}
+
 void ScFormulaCell::SetDirtyAfterLoad()
 {
     if ( bDirty && !pDocument->GetHardRecalcState() )
--- sc/source/core/data/column3.cxx.old	2010-03-03 16:59:15.000000000 +0100
+++ sc/source/core/data/column3.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -832,8 +832,10 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE n
     bool bCloneValue    = (nFlags & IDF_VALUE) != 0;
     bool bCloneDateTime = (nFlags & IDF_DATETIME) != 0;
     bool bCloneString   = (nFlags & IDF_STRING) != 0;
+    bool bCloneSpecialBoolean  = (nFlags & IDF_SPECIAL_BOOLEAN) != 0;
     bool bCloneFormula  = (nFlags & IDF_FORMULA) != 0;
     bool bCloneNote     = (nFlags & IDF_NOTE) != 0;
+    bool bForceFormula  = false;
 
     ScBaseCell* pNew = 0;
     ScBaseCell& rSource = *pItems[nIndex].pCell;
@@ -857,7 +859,18 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE n
         break;
 
         case CELLTYPE_FORMULA:
-            if (bCloneFormula)
+            if ( bCloneSpecialBoolean )
+            {
+                ScFormulaCell& rForm = (ScFormulaCell&)rSource;
+                rtl::OUStringBuffer aBuf;
+                // #TODO #FIXME do we have a localisation issue here?
+                rForm.GetFormula( aBuf );
+                rtl::OUString aVal( aBuf.makeStringAndClear() );
+                if ( aVal.equalsAscii( "=TRUE()" )
+                        || aVal.equalsAscii( "=FALSE()" ) )
+                    bForceFormula = true;
+            }
+            if (bForceFormula || bCloneFormula)
             {
                 // note will be cloned below
                 pNew = rSource.CloneWithoutNote( rDestDoc, rDestPos );
--- sc/source/core/data/documen2.cxx.old	2010-03-03 16:59:11.000000000 +0100
+++ sc/source/core/data/documen2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -96,6 +96,8 @@
 #include "tabprotection.hxx"
 #include "formulaparserpool.hxx"
 #include "clipparam.hxx"
+#include "macromgr.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
 // dtor plus helpers are convenient.
@@ -157,6 +159,7 @@ ScDocument::ScDocument( ScDocumentMode	e
         pDocProtection( NULL ),
         mpClipParam( NULL),
         pExternalRefMgr( NULL ),
+        mpMacroMgr( NULL ), 
         pViewOptions( NULL ),
         pDocOptions( NULL ),
         pExtDocOptions( NULL ),
@@ -1261,6 +1264,29 @@ void ScDocument::RemoveLookupCache( ScLo
     }
 }
 
+using namespace com::sun::star;
+uno::Reference< document::XVbaEventsHelper > 
+ScDocument::GetVbaEventsHelper()
+{
+	if( !mxVbaEventsHelper.is() )
+	{
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pShell ? pShell->GetModel() : NULL, uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocumentVbaEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            mxVbaEventsHelper.set( xVbaEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+	}
+	return mxVbaEventsHelper;
+}
+
 void ScDocument::ClearLookupCaches()
 {
     if( pLookupCacheMapImpl )
--- sc/source/core/data/documen7.cxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/source/core/data/documen7.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -59,7 +59,15 @@
 
 
 #include "globstr.hrc"
+#include <algorithm>
+#include <vector>
 
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 extern const ScFormulaCell* pLastFormulaTreeTop;	// cellform.cxx Err527 WorkAround
 
 // STATIC DATA -----------------------------------------------------------
@@ -527,5 +535,35 @@ void ScDocument::SetAutoCalc( BOOL bNewA
     }
 }
 
-
+BOOL ScDocument::FireCalculateEvent( SCTAB nTab )
+{
+	BOOL bSuccess = FALSE;
+	::std::vector<SCTAB>::iterator iter;
+	iter = ::std::find( maTabs.begin(), maTabs.end(), nTab );
+	if( iter != maTabs.end() )
+	{
+		// make sure fire worksheet calculate event only once for each sheet 
+		// regardless of how many formula cells are calculated.
+		maTabs.erase(iter);
+
+		uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( GetVbaEventsHelper(), uno::UNO_QUERY );
+		if( xVbaEventsHelper.is() )
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] <<= nTab;
+			bSuccess = xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CALCULATE, aArgs );
+		}
+	}	
+	return bSuccess;
+}
+
+void ScDocument::AddCalculateTable( SCTAB nTab )
+{
+	::std::vector<SCTAB>::iterator iter;
+	iter = ::std::find( maTabs.begin(), maTabs.end(), nTab );
+	if( iter == maTabs.end() )
+	{
+		maTabs.push_back( nTab );
+	}
+}
 
--- sc/source/core/data/documen8.cxx.old	2010-03-03 16:44:01.000000000 +0100
+++ sc/source/core/data/documen8.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -96,6 +96,7 @@
 #include "globstr.hrc"
 #include "sc.hrc"
 #include "charthelper.hxx"
+#include "macromgr.hxx"
 #include "dpobject.hxx"
 
 #define GET_SCALEVALUE(set,id) 	((const SfxUInt16Item&)(set.Get( id ))).GetValue()
@@ -421,6 +422,13 @@ BYTE ScDocument::GetEditTextDirection(SC
     return sal::static_int_cast<BYTE>(eRet);
 }
 
+ScMacroManager* ScDocument::GetMacroManager()
+{
+    if (!mpMacroMgr.get())
+        mpMacroMgr.reset(new ScMacroManager(this));
+    return mpMacroMgr.get();
+}
+
 //------------------------------------------------------------------------
 
 void ScDocument::InvalidateTextWidth( const ScAddress* pAdrFrom, const ScAddress* pAdrTo,
--- sc/source/core/data/document.cxx.old	2010-03-03 16:59:20.000000000 +0100
+++ sc/source/core/data/document.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -95,6 +95,8 @@
 #include "externalrefmgr.hxx"
 #include "tabprotection.hxx"
 #include "clipparam.hxx"
+#include <basic/basmgr.hxx>
+#include <com/sun/star/container/XContainer.hpp>
 
 #include <map>
 #include <limits>
@@ -159,6 +161,39 @@ BOOL ScDocument::GetName( SCTAB nTab, St
     return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
+
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
+NameToNameMap*
+ScDocument::GetLocalNameMap( SCTAB& rTab )
+{
+    if ( !HasTable( rTab ) )
+        return NULL;
+    return &pTab[rTab]->localNameToGlobalName;
+}
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
@@ -298,6 +333,7 @@ BOOL ScDocument::InsertTab( SCTAB nPos,
         if (nPos == SC_TAB_APPEND || nPos == nTabCount)
         {
             pTab[nTabCount] = new ScTable(this, nTabCount, rName);
+            pTab[nTabCount]->SetCodeName( rName );
             ++nMaxTableNumber;
             if ( bExternalDocument )
                 pTab[nTabCount]->SetVisible( FALSE );
@@ -325,10 +361,16 @@ BOOL ScDocument::InsertTab( SCTAB nPos,
                 for (i = 0; i <= MAXTAB; i++)
                     if (pTab[i])
                         pTab[i]->UpdateInsertTab(nPos);
+
                 for (i = nTabCount; i > nPos; i--)
+				{
                     pTab[i] = pTab[i - 1];
+				}
+
                 pTab[nPos] = new ScTable(this, nPos, rName);
+                pTab[nPos]->SetCodeName( rName );
                 ++nMaxTableNumber;
+
                 // UpdateBroadcastAreas must be called between UpdateInsertTab, 
                 // which ends listening, and StartAllListeners, to not modify 
                 // areas that are to be inserted by starting listeners.
@@ -419,7 +461,10 @@ BOOL ScDocument::DeleteTab( SCTAB nTab,
                                     pRefUndoDoc ? pRefUndoDoc->pTab[i] : 0);
                 delete pTab[nTab];
                 for (i=nTab + 1; i < nTabCount; i++)
+				{
                     pTab[i - 1] = pTab[i];
+				}
+
                 pTab[nTabCount - 1] = NULL;
                 --nMaxTableNumber;
                 // UpdateBroadcastAreas must be called between UpdateDeleteTab, 
--- sc/source/core/data/table1.cxx.old	2010-03-03 16:59:20.000000000 +0100
+++ sc/source/core/data/table1.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -126,6 +126,7 @@ extern BOOL bIsOlk, bOderSo;
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
                     BOOL bColInfo, BOOL bRowInfo ) :
     aName( rNewName ),
+	aCodeName( rNewName ),
     bScenario( FALSE ),
     bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
--- sc/source/core/inc/interpre.hxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/core/inc/interpre.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -146,6 +146,15 @@ public:
     static inline double div( const double& fNumerator, const double& fDenominator );
 
     ScMatrixRef GetNewMat(SCSIZE nC, SCSIZE nR);
+
+    enum VolatileType { 
+        VOLATILE,   
+        VOLATILE_MACRO,
+        NOT_VOLATILE
+    };
+
+    VolatileType GetVolatileType() const;
+
 private:
     static ScTokenStack*    pGlobalStack;
     static BOOL             bGlobalStackInUse;
@@ -179,6 +188,8 @@ private:
     BOOL        bCalcAsShown;           // precision as shown
     BOOL        bMatrixFormula;         // formula cell is a matrix formula
 
+    VolatileType meVolaileType;
+
     sal_Unicode cDecSep;                // decimal separator 
     sal_Unicode cGrpSep;                // group separator
 
--- sc/source/core/tool/address.cxx.old	2010-03-03 16:44:05.000000000 +0100
+++ sc/source/core/tool/address.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1377,7 +1377,7 @@ lcl_ScRange_Parse_OOo( ScRange &aRange,
     }
     nRes1 = ( ( nRes1 | nRes2 ) & SCA_VALID )
           | nRes1
-          | ( ( nRes2 & 0x070F ) << 4 );
+          | ( ( nRes2 & SCA_BITS ) << 4 );
     return nRes1;
 }
 
--- sc/source/core/tool/interpr1.cxx.old	2010-03-03 16:44:03.000000000 +0100
+++ sc/source/core/tool/interpr1.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -74,6 +74,7 @@
 #include "rangenam.hxx"
 #include "compiler.hxx"
 #include "externalrefmgr.hxx"
+#include <basic/sbstar.hxx>
 #include "doubleref.hxx"
 #include "queryparam.hxx"
 
@@ -4182,7 +4183,20 @@ void ScInterpreter::ScMatch()
                 }
             }
             if ( rEntry.bQueryByString )
-                rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            {
+		BOOL bIsVBAMode = FALSE;
+                if ( pDok ) 
+                {
+                   SfxObjectShell* pDocSh = pDok->GetDocumentShell();
+                   if ( pDocSh )
+                        bIsVBAMode = pDocSh->GetBasic()->isVBAEnabled();
+                }
+                // #TODO handle MSO wildcards
+                if ( bIsVBAMode )
+                    rParam.bRegExp = FALSE;
+                else
+                    rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            }
 
             if (pMatSrc) // The source data is matrix array.
             {
--- sc/source/core/tool/interpr4.cxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/core/tool/interpr4.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -36,10 +36,13 @@
 #include <sfx2/app.hxx>
 #include <sfx2/docfile.hxx>
 #include <sfx2/objsh.hxx>
+#include <sfx2/docfilt.hxx>
 #include <basic/sbmeth.hxx>
 #include <basic/sbmod.hxx>
 #include <basic/sbstar.hxx>
 #include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/urlobj.hxx>
 #include <rtl/logfile.hxx>
@@ -48,6 +51,7 @@
 #include <signal.h>
 
 #include <com/sun/star/table/XCellRange.hpp>
+#include <comphelper/processfactory.hxx>
 
 #include "interpre.hxx"
 #include "global.hxx"
@@ -68,6 +72,8 @@
 #include "jumpmatrix.hxx"
 #include "parclass.hxx"
 #include "externalrefmgr.hxx"
+#include "formula/FormulaCompiler.hxx"
+#include "macromgr.hxx"
 #include "doubleref.hxx"
 
 #include <math.h>
@@ -75,6 +81,8 @@
 #include <map>
 #include <algorithm>
 #include <functional>
+#include <vbahelper/vbahelper.hxx>
+#include <basic/basmgr.hxx>
 #include <memory>
 
 using namespace com::sun::star;
@@ -2683,7 +2691,31 @@ void ScInterpreter::ScMissing()
     PushTempToken( new FormulaMissingToken );
 }
 
-
+bool
+lcl_setVBARange( ScRange& aRange, ScDocument* pDok, SbxVariable* pPar )
+{
+	bool bOk = false;
+	try
+	{
+		uno::Reference< uno::XInterface > xVBARange;
+		uno::Reference<table::XCellRange> xCellRange = ScCellRangeObj::CreateRangeFromDoc( pDok, aRange );
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+		aArgs[1] = uno::Any( xCellRange );
+		xVBARange = ov::createVBAUnoAPIServiceWithArgs( pDok->GetDocumentShell(), "ooo.vba.excel.Range", aArgs );
+		if ( xVBARange.is() )
+		{
+			String sDummy(RTL_CONSTASCII_USTRINGPARAM("A-Range") );
+			SbxObjectRef aObj = GetSbUnoObject( sDummy, uno::Any( xVBARange ) );
+			SetSbUnoObjectDfltPropName( aObj );
+			bOk = pPar->PutObject( aObj );
+		}
+	}
+	catch( uno::Exception& )
+	{
+	}
+	return bOk;
+}
 void ScInterpreter::ScMacro()
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "sc", "er", "ScInterpreter::ScMacro" );
@@ -2720,8 +2752,11 @@ void ScInterpreter::ScMacro()
         return;
     }
 
+    bool bVolatileMacro = false; 
     SbMethod* pMethod = (SbMethod*)pVar;
+
     SbModule* pModule = pMethod->GetModule();
+	bool bUseVBAObjects = pModule->IsVBACompat();
     SbxObject* pObject = pModule->GetParent();
     DBG_ASSERT(pObject->IsA(TYPE(StarBASIC)), "Kein Basic gefunden!");
     String aMacroStr = pObject->GetName();
@@ -2731,7 +2766,13 @@ void ScInterpreter::ScMacro()
     aMacroStr += pMethod->GetName();
     String aBasicStr;
     if (pObject->GetParent())
+	{
         aBasicStr = pObject->GetParent()->GetName();    // Dokumentenbasic
+		const SfxFilter* pFilter = NULL;
+		SfxMedium* pMedium = pDok->GetDocumentShell()->GetMedium();
+		if ( pMedium )
+			pFilter = pMedium->GetFilter();
+	}
     else
         aBasicStr = SFX_APP()->GetName();               // Applikationsbasic
 
@@ -2755,7 +2796,13 @@ void ScInterpreter::ScMacro()
             {
                 ScAddress aAdr;
                 PopSingleRef( aAdr );
-                bOk = SetSbxVariable( pPar, aAdr );
+				if ( bUseVBAObjects )
+				{
+					ScRange aRange( aAdr );
+					bOk = lcl_setVBARange( aRange, pDok, pPar );
+				}
+				else
+					bOk = SetSbxVariable( pPar, aAdr );
             }
             break;
             case svDoubleRef:
@@ -2774,24 +2821,32 @@ void ScInterpreter::ScMacro()
                 }
                 else
                 {
-                    SbxDimArrayRef refArray = new SbxDimArray;
-                    refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
-                    refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
-                    ScAddress aAdr( nCol1, nRow1, nTab1 );
-                    for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+					if ( bUseVBAObjects )
                     {
-                        aAdr.SetRow( nRow );
-                        INT32 nIdx[ 2 ];
-                        nIdx[ 0 ] = nRow-nRow1+1;
-                        for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
-                        {
-                            aAdr.SetCol( nCol );
-                            nIdx[ 1 ] = nCol-nCol1+1;
-                            SbxVariable* p = refArray->Get32( nIdx );
-                            bOk = SetSbxVariable( p, aAdr );
+						ScRange aRange( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
+						bOk = lcl_setVBARange( aRange, pDok, pPar );
+					}
+					else
+					{
+						SbxDimArrayRef refArray = new SbxDimArray;
+						refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
+						refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
+						ScAddress aAdr( nCol1, nRow1, nTab1 );
+						for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+						{
+							aAdr.SetRow( nRow );
+							INT32 nIdx[ 2 ];
+							nIdx[ 0 ] = nRow-nRow1+1;
+							for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
+							{
+								aAdr.SetCol( nCol );
+								nIdx[ 1 ] = nCol-nCol1+1;
+								SbxVariable* p = refArray->Get32( nIdx );
+								bOk = SetSbxVariable( p, aAdr );
+							}
                         }
+						pPar->PutObject( refArray );
                     }
-                    pPar->PutObject( refArray );
                 }
             }
             break;
@@ -2839,6 +2894,13 @@ void ScInterpreter::ScMacro()
         pDok->DecMacroInterpretLevel();
         pDok->UnlockTable( aPos.Tab() );
 
+        ScMacroManager* pMacroMgr = pDok->GetMacroManager();
+        if (pMacroMgr)
+        {
+            bVolatileMacro = pMacroMgr->GetUserFuncVolatile( pMethod->GetName() );
+            pMacroMgr->AddDependentCell(pModule->GetName(), pMyFormulaCell);
+        }
+
         SbxDataType eResType = refRes->GetType();
         if( pVar->GetError() )
             SetError( errNoValue);
@@ -2910,6 +2972,9 @@ void ScInterpreter::ScMacro()
     }
 
     pSfxApp->LeaveBasicCall();
+
+    if (bVolatileMacro && meVolaileType == NOT_VOLATILE)
+        meVolaileType = VOLATILE_MACRO;
 }
 
 
@@ -3567,7 +3632,8 @@ ScInterpreter::ScInterpreter( ScFormulaC
     pTokenMatrixMap( NULL ),
     pMyFormulaCell( pCell ),
     pFormatter( pDoc->GetFormatTable() ),
-    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() )
+    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() ),
+    meVolaileType(NOT_VOLATILE)
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "sc", "er", "ScInterpreter::ScTTT" );
 //  pStack = new ScToken*[ MAXSTACK ];
@@ -4022,6 +4088,9 @@ StackVar ScInterpreter::Interpret()
                 continue;   // while( ( pCur = aCode.Next() ) != NULL  ...
             }
 
+            if (FormulaCompiler::IsOpCodeVolatile(eOp))
+                meVolaileType = VOLATILE;
+
             // Remember result matrix in case it could be reused.
             if (pTokenMatrixMap && sp && GetStackType() == svMatrix)
                 pTokenMatrixMap->insert( ScTokenMatrixMap::value_type( pCur,
--- sc/source/core/tool/interpr5.cxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/source/core/tool/interpr5.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -324,6 +324,11 @@ ScMatrixRef ScInterpreter::GetNewMat(SCS
     return pMat;
 }
 
+ScInterpreter::VolatileType ScInterpreter::GetVolatileType() const
+{
+    return meVolaileType;
+}
+
 ScMatrixRef ScInterpreter::CreateMatrixFromDoubleRef( const FormulaToken* pToken,
         SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
         SCCOL nCol2, SCROW nRow2, SCTAB nTab2 )
--- sc/source/core/tool/rangelst.cxx.old	2010-03-03 16:59:17.000000000 +0100
+++ sc/source/core/tool/rangelst.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -86,15 +86,18 @@ USHORT ScRangeList::Parse( const String&
         for ( USHORT i=0; i<nTCount; i++ )
         {
             aOne = rStr.GetToken( i, cDelimiter );
-            // FIXME : broken for Lotus
-            if ( aOne.Search( ':' ) == STRING_NOTFOUND )
-            {	// Range muss es sein
-                String aStrTmp( aOne );
-                aOne += ':';
-                aOne += aStrTmp;
-            }
             aRange.aStart.SetTab( nTab );	// Default Tab wenn nicht angegeben
-            USHORT nRes = aRange.Parse( aOne, pDoc, eConv );
+			USHORT nRes = aRange.ParseAny( aOne, pDoc, eConv );
+			USHORT nEndRangeBits = SCA_VALID_COL2 | SCA_VALID_ROW2 |
+SCA_VALID_TAB2;
+			USHORT nTmp1 = ( nRes & SCA_BITS );
+			USHORT nTmp2 = ( nRes & nEndRangeBits );
+			// If we have a valid single range with
+			// any of the address bits we are interested in
+			// set - set the equiv end range bits
+			if ( (nRes & SCA_VALID ) && nTmp1 && ( nTmp2 != nEndRangeBits ) )
+					nRes |= ( nTmp1 << 4 );
+	
             if ( (nRes & nMask) == nMask )
                 Append( aRange );
             nResult &= nRes;		// alle gemeinsamen Bits bleiben erhalten
--- sc/source/filter/excel/excimp8.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/filter/excel/excimp8.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -99,13 +99,16 @@
 #include "stlpool.hxx"
 #include "stlsheet.hxx"
 #include "detfunc.hxx"
+#include "macromgr.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 #include <basic/basmgr.hxx>
 #include <cppuhelper/component_context.hxx>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <sfx2/app.hxx>
+#include "xltoolbar.hxx"
 
 
 using namespace com::sun::star;
@@ -114,10 +117,11 @@ using namespace com::sun::star;
 #define	INVALID_POS		0xFFFFFFFF
 
 
-
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
     delete pFormConv;
 
@@ -240,9 +244,15 @@ void ImportExcel8::Codename( BOOL bWorkb
         if( aName.Len() )
         {
             if( bWorkbookGlobals )
+            {
                 GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
+            {
                 GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( GetCurrScTab(), aName );
+            }
         }
     }
 }
@@ -269,6 +279,27 @@ void ImportExcel8::ReadBasic( void )
             SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
 	    bool bAsComment = !bLoadExecutable;
             aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, bAsComment );
+            if ( !bAsComment )
+            {
+                GetObjectManager().SetOleNameOverrideInfo( aBasicImport.ControlNameForObjectId() );
+                ScDocument& rDoc = GetDoc();
+#if 1
+                // see if we have the XCB stream
+                SvStorageStreamRef xXCB = xRootStrg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "XCB" ) ), STREAM_STD_READ | STREAM_NOCREATE  );
+                if ( xXCB.Is()|| SVSTREAM_OK == xXCB->GetError() )
+                {
+                    CTBWrapper wrapper;
+                    if ( wrapper.Read( xXCB ) )
+                    {
+#if DEBUG
+                        wrapper.Print( stderr ); 
+#endif
+                        wrapper.ImportCustomToolBar( *pShell );
+                    }
+                }
+#endif
+
+            }
         }
     }
 }
@@ -283,6 +314,10 @@ void ImportExcel8::EndSheet( void )
 
 void ImportExcel8::PostDocLoad( void )
 {
+    // delay reading basic until sheet object ( codenames etc. ) are read
+
+    if ( bHasBasic ) 
+        ReadBasic();
     // #i11776# filtered ranges before outlines and hidden rows
     if( pExcRoot->pAutoFilterBuffer )
         pExcRoot->pAutoFilterBuffer->Apply();
--- sc/source/filter/excel/makefile.mk.old	2009-10-19 13:27:16.000000000 +0200
+++ sc/source/filter/excel/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -106,7 +106,8 @@ SLOFILES =	\
         $(SLO)$/xlstyle.obj					\
         $(SLO)$/xltools.obj					\
         $(SLO)$/xltracer.obj				\
-        $(SLO)$/xlview.obj
+		$(SLO)$/xlview.obj \
+		$(SLO)$/xltoolbar.obj \
 
 .IF "$(OS)$(COM)$(CPUNAME)"=="LINUXGCCSPARC"
 NOOPTFILES = \
@@ -155,7 +156,8 @@ EXCEPTIONSFILES = \
         $(SLO)$/xlpivot.obj					\
         $(SLO)$/xlroot.obj					\
         $(SLO)$/xlstyle.obj					\
-        $(SLO)$/xlview.obj
+		$(SLO)$/xlview.obj \
+		$(SLO)$/xltoolbar.obj \
 
 # --- Targets -------------------------------------------------------
 
--- sc/source/filter/excel/read.cxx.old	2010-03-03 16:59:13.000000000 +0100
+++ sc/source/filter/excel/read.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -831,6 +831,12 @@ FltError ImportExcel8::Read( void )
     sal_Size nProgressBasePos = 0;
     sal_Size nProgressBaseSize = 0;
 
+    bool bSheetHasCodeName = false;
+
+    std::vector< String > CodeNames;
+
+    std::vector < SCTAB > nTabsWithNoCodeName;
+
     while( eAkt != EXC_STATE_END )
     {
         if( eAkt == EXC_STATE_BEFORE_SHEET )
@@ -912,6 +918,7 @@ FltError ImportExcel8::Read( void )
                         // #i62752# possible to have BIFF8 sheet without globals
                         NeueTabelle();
                         eAkt = EXC_STATE_SHEET_PRE;  // Shrfmla Prefetch, Row-Prefetch
+                        bSheetHasCodeName = false; // reset
                         aIn.StoreGlobalPosition();
                     }
                 }
@@ -986,7 +993,8 @@ FltError ImportExcel8::Read( void )
                     case 0x22:	Rec1904(); break;		// 1904			[ 2345   ]
                     case 0x56:	Builtinfmtcnt(); break;	// BUILTINFMTCNT[  34    ]
                     case 0x8D:	Hideobj(); break;		// HIDEOBJ		[  345   ]
-                    case 0xD3:	ReadBasic(); break;
+					case 0xD3:	/*ReadBasic()*/bHasBasic = true; break;
+//					case 0xD3:	ReadBasic(); break;
                     case 0xDE:  Olesize(); break;
                     case 0x01BA: Codename( TRUE ); break;
 
@@ -1083,9 +1091,30 @@ FltError ImportExcel8::Read( void )
                     case EXC_ID3_DIMENSIONS:    ReadDimensions();                       break;
 
                     case 0x0A:                          // EOF          [ 2345   ]
+                    {
                         eAkt = EXC_STATE_SHEET;
+                        String sName;
+                        GetDoc().GetName( GetCurrScTab(), sName );
+                        if ( !bSheetHasCodeName )
+                        {
+                            nTabsWithNoCodeName.push_back( GetCurrScTab() );
+                            OSL_TRACE("No Codename for %d", GetCurrScTab() );
+                        }
+                        else
+                        {
+                            String sCodeName;
+                            GetDoc().GetCodeName( GetCurrScTab(), sCodeName );
+                            OSL_TRACE("Have CodeName %s for SheetName %s",
+                                rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                            CodeNames.push_back( sCodeName );
+                        }
+
+                        bSheetHasCodeName = false; // reset
+
+
                         aIn.SeekGlobalPosition();         // und zurueck an alte Position
                         break;
+                    }
                     case 0x12:  SheetProtect(); break;
                     case 0x13:  SheetPassword(); break;
                     case 0x42:  Codepage(); break;      // CODEPAGE     [ 2345   ]
@@ -1097,7 +1126,7 @@ FltError ImportExcel8::Read( void )
                     case 0x9B:  FilterMode(); break;    // FILTERMODE
                     case 0x9D:  AutoFilterInfo(); break;// AUTOFILTERINFO
                     case 0x9E:  AutoFilter(); break;    // AUTOFILTER
-                    case 0x01BA: Codename( FALSE ); break;
+                    case 0x01BA: Codename( FALSE ); bSheetHasCodeName = true; break;
                     case 0x0208: Row34(); break;        // ROW          [  34    ]
                     case 0x0021:
                     case 0x0221: Array34(); break;      // ARRAY        [  34    ]
@@ -1207,6 +1236,42 @@ FltError ImportExcel8::Read( void )
 
     if( eLastErr == eERR_OK )
     {
+        // In some strange circumstances a the codename might be missing
+        // # Create any missing Sheet CodeNames
+        std::vector < SCTAB >::iterator it_end = nTabsWithNoCodeName.end();
+        for ( std::vector < SCTAB >::iterator it = nTabsWithNoCodeName.begin(); it != it_end; ++it )
+        {
+            bool bGotCodeName = false;
+            SCTAB nTab = 1;
+            OSL_TRACE("Trying to find suitable codename for %d", *it );
+            while ( true )
+            {
+                String sTmpName( RTL_CONSTASCII_USTRINGPARAM("Sheet" ) );
+                sTmpName += String::CreateFromInt32( sal_Int32(nTab++) );
+                std::vector< String >::iterator codeName_It = CodeNames.begin();
+                std::vector< String >::iterator codeName_It_end = CodeNames.end();
+                // search for codename
+                for ( ; codeName_It != codeName_It_end; ++codeName_It )
+                {
+                    if ( *codeName_It == sTmpName )
+                        break;
+                }
+
+                if ( codeName_It == codeName_It_end ) // generated codename not found
+                {
+                    OSL_TRACE("Using generated codename %s", rtl::OUStringToOString( sTmpName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    // Set new codename
+                    GetDoc().SetCodeName( *it, sTmpName );
+                    // Record newly used codename
+                    CodeNames.push_back( sTmpName );
+                    // Record those we have created so they can be created in
+                    // basic
+                    AutoGeneratedCodeNames.push_back( sTmpName );
+                    break;
+                }
+            }
+            
+        }
         // #i45843# Convert pivot tables before calculation, so they are available
         // for the GETPIVOTDATA function.
         if( GetBiff() == EXC_BIFF8 )
--- sc/source/filter/excel/xecontent.cxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/filter/excel/xecontent.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -527,12 +527,17 @@ void XclExpHyperlink::WriteBody( XclExpS
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
     sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
-    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
+    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
+    WriteEmbeddedData( rStrm );
+}
 
-    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol
-            << XclTools::maGuidStdLink
+void XclExpHyperlink::WriteEmbeddedData( XclExpStream& rStrm )
+{
+    rStrm << XclTools::maGuidStdLink
             << sal_uInt32( 2 )
             << mnFlags;
+
+    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( *mxVarData );
 }
 
--- sc/source/filter/excel/xeescher.cxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/filter/excel/xeescher.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -66,6 +66,9 @@
 #include "xelink.hxx"
 #include "xename.hxx"
 #include "xestyle.hxx"
+#include "userdat.hxx"
+#include "drwlayer.hxx"
+#include "svx/unoapi.hxx"
 
 #include <oox/core/tokens.hxx>
 
@@ -333,7 +336,7 @@ void XclExpOcxControlObj::WriteSubRecs(
 
 XclExpTbxControlObj::XclExpTbxControlObj( const XclExpRoot& rRoot, Reference< XShape > xShape ) :
     XclObj( rRoot, EXC_OBJTYPE_UNKNOWN, true ),
-    XclExpControlHelper( rRoot ),
+    XclMacroHelper( rRoot ),
     mnHeight( 0 ),
     mnState( 0 ),
     mnLineCount( 0 ),
@@ -583,6 +586,8 @@ XclExpTbxControlObj::XclExpTbxControlObj
 
 bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
 {
+    return XclMacroHelper::SetMacroLink( rEvent, meEventType );
+/*
     String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, meEventType );
     if( aMacroName.Len() )
     {
@@ -592,6 +597,7 @@ bool XclExpTbxControlObj::SetMacroLink(
         return true;
     }
     return false;
+*/
 }
 
 void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
@@ -732,12 +738,6 @@ void XclExpTbxControlObj::WriteSubRecs(
     }
 }
 
-void XclExpTbxControlObj::WriteMacroSubRec( XclExpStream& rStrm )
-{
-    if( mxMacroLink.is() )
-        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
-}
-
 void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId )
 {
     if( const XclTokenArray* pCellLink = GetCellLinkTokArr() )
@@ -766,6 +766,7 @@ void XclExpTbxControlObj::WriteSbs( XclE
 
 #endif
 
+
 // ----------------------------------------------------------------------------
 
 XclExpChartObj::XclExpChartObj( const XclExpRoot& rRoot, Reference< XShape > xShape ) :
@@ -911,6 +912,7 @@ void XclExpNote::Save( XclExpStream& rSt
     }
 }
 
+
 void XclExpNote::WriteBody( XclExpStream& rStrm )
 {
     // BIFF5/BIFF7 is written separately
@@ -946,6 +948,70 @@ void XclExpNote::WriteXml( sal_Int32 nAu
 }
 
 // ============================================================================
+
+XclMacroHelper::XclMacroHelper( const XclExpRoot& rRoot ) :
+    XclExpControlHelper( rRoot )
+{
+}
+
+XclMacroHelper::~XclMacroHelper()
+{
+}
+
+void XclMacroHelper::WriteMacroSubRec( XclExpStream& rStrm )
+{
+    if( mxMacroLink.is() )
+        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
+}
+
+bool 
+XclMacroHelper::SetMacroLink( const ScriptEventDescriptor& rEvent, const XclTbxEventType& nEventType )
+{
+    String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, nEventType );
+    if( aMacroName.Len() )
+    {
+        return SetMacroLink( aMacroName );
+    }
+    return false;
+}
+
+bool
+XclMacroHelper::SetMacroLink( const String& rMacroName )
+{
+    OSL_TRACE("SetMacroLink( macroname:=%s )", rtl::OUStringToOString( rMacroName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( rMacroName.Len() )
+    {
+        sal_uInt16 nExtSheet = GetLocalLinkManager().FindExtSheet( EXC_EXTSH_OWNDOC );
+        sal_uInt16 nNameIdx = GetNameManager().InsertMacroCall( rMacroName, true, false );
+        mxMacroLink = GetFormulaCompiler().CreateNameXFormula( nExtSheet, nNameIdx );
+        return true;
+    }
+    return false;
+}
+
+XclExpShapeObj::XclExpShapeObj( const XclExpRoot& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape ) : 
+    XclObjAny( rRoot ),
+    XclMacroHelper( rRoot )
+{
+    if( SdrObject* pSdrObj = ::GetSdrObjectFromXShape( xShape ) )
+    {
+        ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pSdrObj );
+        if ( pInfo && pInfo->GetMacro().getLength() )
+            SetMacroLink( XclControlHelper::GetXclMacroName( pInfo->GetMacro() ) ); 
+    }
+}
+
+XclExpShapeObj::~XclExpShapeObj()
+{
+}
+
+void XclExpShapeObj::WriteSubRecs( XclExpStream& rStrm )
+{
+    XclObjAny::WriteSubRecs( rStrm );
+    WriteMacroSubRec( rStrm );
+}
+
+// ============================================================================
 
 XclExpComments::XclExpComments( SCTAB nTab, XclExpRecordList< XclExpNote >& rNotes )
     : mnTab( nTab ), mrNotes( rNotes )
--- sc/source/filter/excel/xiescher.cxx.old	2010-03-03 16:44:03.000000000 +0100
+++ sc/source/filter/excel/xiescher.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -116,6 +116,8 @@
 #include "xipage.hxx"
 #include "xichart.hxx"
 #include "xicontent.hxx"
+#include "scextopt.hxx"
+
 #include "namebuff.hxx"
 
 using ::rtl::OUString;
@@ -483,20 +485,15 @@ void XclImpDrawObjBase::ProcessSdrObject
     }
 
     // macro and hyperlink
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    if( mbSimpleMacro && ((maMacroName.Len() > 0) || (maHyperlink.getLength() > 0)) )
+    if( mbSimpleMacro && ((maMacroName.Len() > 0) ||
+ (maHyperlink.Len() > 0)) )
     {
         if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
         {
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ) );
+            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName, GetDocShell() ) );
             pInfo->SetHlink( maHyperlink );
         }
     }
-#else
-    if( mbSimpleMacro && (maMacroName.Len() > 0) )
-        if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ) );
-#endif
 
     // call virtual function for object type specific processing
     DoProcessSdrObj( rSdrObj );
@@ -1686,22 +1683,15 @@ SdrObject* XclImpControlHelper::CreateSd
     return xSdrObj.release();
 }
 
-void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+void XclImpControlHelper::ApplySheetLinkProps() const
 {
+
     Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
     if( !xCtrlModel.is() )
         return;
-
     ScfPropertySet aPropSet( xCtrlModel );
 
-    // #118053# #i51348# set object name at control model
-    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
-
-    // control visible and printable?
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
-
-    // sheet links
+   // sheet links
     if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
     {
         Reference< XMultiServiceFactory > xFactory( pDocShell->GetModel(), UNO_QUERY );
@@ -1764,7 +1754,26 @@ void XclImpControlHelper::ProcessControl
             }
         }
     }
+}
+
+void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+{
+    Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
+    if( !xCtrlModel.is() )
+        return;
+
+    ApplySheetLinkProps();
+
+    ScfPropertySet aPropSet( xCtrlModel );
+
+    // #118053# #i51348# set object name at control model
+    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
+
+    // control visible and printable?
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
 
+ 
     // virtual call for type specific processing
     DoProcessControl( aPropSet );
 }
@@ -1858,7 +1867,7 @@ void XclImpTbxObjBase::SetDffProperties(
 
 bool XclImpTbxObjBase::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor ) const
 {
-    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName() );
+    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName(), GetDocShell() );
 }
 
 void XclImpTbxObjBase::ConvertFont( ScfPropertySet& rPropSet ) const
@@ -2095,6 +2104,45 @@ void XclImpOptionButtonObj::DoProcessCon
 {
     XclImpCheckBoxObj::DoProcessControl( rPropSet );
     // TODO: grouping
+    XclImpOptionButtonObj* pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), mnNextInGroup ) ).get() );
+    if ( ( pTbxObj && pTbxObj->mnFirstInGroup ) )
+    {
+        // Group has terminated
+        // traverse each RadioButton in group and 
+        //     a) apply the groupname 
+        //     b) propagate the linked cell from the lead radiobutton
+        //     c) apply the correct Ref value
+        XclImpOptionButtonObj* pLeader = pTbxObj;
+ ;
+        sal_Int32 nRefVal = 1;
+        OSL_TRACE( "0x%x start group ", pLeader->GetObjId().mnObjId );
+        do 
+        {
+           
+            Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( pTbxObj->mxShape );
+            if ( xCtrlModel.is() )
+            {
+                ScfPropertySet aProps( xCtrlModel );
+                rtl::OUString sGroupName = rtl::OUString::valueOf( static_cast< sal_Int32 >( pLeader->GetDffShapeId() ) );
+
+                aProps.SetStringProperty( CREATE_OUSTRING( "GroupName" ), sGroupName );
+                aProps.SetStringProperty( CREATE_OUSTRING( "RefValue" ), rtl::OUString::valueOf( nRefVal++ ) );
+                if ( pLeader->HasCellLink() && !pTbxObj->HasCellLink() )
+                {
+                    // propagate cell link info
+                    pTbxObj->mxCellLink.reset( new ScAddress( *pLeader->mxCellLink.get() ) );                
+                    pTbxObj->ApplySheetLinkProps();
+                }
+                pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), pTbxObj->mnNextInGroup ) ).get() );
+            }
+            else
+                pTbxObj = NULL;
+        } while ( pTbxObj && !( pTbxObj->mnFirstInGroup == 1 ) );
+    }
+    else
+    {
+        // not the leader? try and find it
+    }
 }
 
 OUString XclImpOptionButtonObj::DoGetServiceName() const
@@ -2731,6 +2779,17 @@ SdrObject* XclImpPictureObj::DoCreateSdr
     return xSdrObj.release();
 }
 
+String XclImpPictureObj::GetObjName() const
+{
+    if( IsOcxControl() )
+    {
+        String sName( GetObjectManager().GetOleNameOverride( GetObjId() ) );
+        if ( sName.Len() > 0 )
+            return sName;
+    }
+    return XclImpDrawObjBase::GetObjName();
+}
+
 void XclImpPictureObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
 {
     if( IsOcxControl() )
@@ -3036,6 +3095,23 @@ XclImpDffManager::~XclImpDffManager()
 {
 }
 
+String XclImpObjectManager::GetOleNameOverride( const XclObjId& nObjId )
+{
+    String sOleName; 
+    String sCodeName = GetExtDocOptions().GetCodeName( nObjId.mnScTab );
+    
+    CodeNameToCntrlObjIdInfo::iterator it = maOleCtrlNameOverride.find( sCodeName );
+    if ( it != maOleCtrlNameOverride.end() )
+    {
+        CntrlObjIdToName::iterator it_id = it->second.find( nObjId.mnObjId );
+        if ( it_id != it->second.end() )
+        {
+            sOleName = it_id->second;
+        }
+    }
+    return sOleName;
+}
+
 void XclImpDffManager::StartProgressBar( sal_Size nProgressSize )
 {
     mxProgress.reset( new ScfProgressBar( GetDocShell(), STR_PROGRESS_CALCULATING ) );
@@ -3511,27 +3587,27 @@ XclImpObjectManager::XclImpObjectManager
     XclImpRoot( rRoot )
 {
     maDefObjNames[ EXC_OBJTYPE_GROUP ]          = CREATE_STRING( "Group" );
-    maDefObjNames[ EXC_OBJTYPE_LINE ]           = CREATE_STRING( "Line" );
-    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = CREATE_STRING( "Rectangle" );
-    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = CREATE_STRING( "Oval" );
+    maDefObjNames[ EXC_OBJTYPE_LINE ]           = ScGlobal::GetRscString( STR_SHAPE_LINE );
+    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = ScGlobal::GetRscString( STR_SHAPE_RECTANGLE );
+    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = ScGlobal::GetRscString( STR_SHAPE_OVAL );
     maDefObjNames[ EXC_OBJTYPE_ARC ]            = CREATE_STRING( "Arc" );
     maDefObjNames[ EXC_OBJTYPE_CHART ]          = CREATE_STRING( "Chart" );
     maDefObjNames[ EXC_OBJTYPE_TEXT ]           = CREATE_STRING( "Text" );
-    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         = CREATE_STRING( "Button" );
+    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         =  ScGlobal::GetRscString( STR_FORM_BUTTON );
     maDefObjNames[ EXC_OBJTYPE_PICTURE ]        = CREATE_STRING( "Picture" );
     maDefObjNames[ EXC_OBJTYPE_POLYGON ]        = CREATE_STRING( "Freeform" );
-    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = CREATE_STRING( "Check Box" );
-    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = CREATE_STRING( "Option Button" );
+    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = ScGlobal::GetRscString( STR_FORM_CHECKBOX ); 
+    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = ScGlobal::GetRscString( STR_FORM_OPTIONBUTTON );
     maDefObjNames[ EXC_OBJTYPE_EDIT ]           = CREATE_STRING( "Edit Box" );
-    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = CREATE_STRING( "Label" );
+    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = ScGlobal::GetRscString( STR_FORM_LABEL );
     maDefObjNames[ EXC_OBJTYPE_DIALOG ]         = CREATE_STRING( "Dialog Frame" );
-    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = CREATE_STRING( "Spinner" );
-    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = CREATE_STRING( "Scroll Bar" );
-    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = CREATE_STRING( "List Box" );
-    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = CREATE_STRING( "Group Box" );
-    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = CREATE_STRING( "Drop Down" );
+    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = ScGlobal::GetRscString( STR_FORM_SPINNER );
+    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = ScGlobal::GetRscString( STR_FORM_SCROLLBAR );
+    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = ScGlobal::GetRscString( STR_FORM_LISTBOX );
+    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = ScGlobal::GetRscString( STR_FORM_GROUPBOX );
+    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = ScGlobal::GetRscString( STR_FORM_DROPDOWN );
     maDefObjNames[ EXC_OBJTYPE_NOTE ]           = CREATE_STRING( "Comment" );
-    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = CREATE_STRING( "AutoShape" );
+    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = ScGlobal::GetRscString( STR_SHAPE_AUTOSHAPE );
 }
 
 XclImpObjectManager::~XclImpObjectManager()
--- sc/source/filter/excel/xiname.cxx.old	2010-03-03 16:59:10.000000000 +0100
+++ sc/source/filter/excel/xiname.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,7 +38,8 @@
 #include "excform.hxx"
 // for filter manager
 #include "excimp8.hxx"
-
+#include "scextopt.hxx"
+#include "document.hxx"
 // ============================================================================
 // *** Implementation ***
 // ============================================================================
@@ -130,6 +131,7 @@ XclImpName::XclImpName( XclImpStream& rS
         maScName = maXclName;
         ScfTools::ConvertToScDefinedName( maScName );
     }
+    rtl::OUString aRealOrigName = maScName;
 
     // add index for local names
     if( nXclTab != EXC_NAME_GLOBAL )
@@ -220,6 +222,25 @@ XclImpName::XclImpName( XclImpStream& rS
         pData->GuessPosition();             // calculate base position for relative refs
         pData->SetIndex( nXclNameIdx );     // used as unique identifier in formulas
         rRangeNames.Insert( pData );        // takes ownership of pData
+        if( nXclTab != EXC_NAME_GLOBAL )
+        {
+            if (GetBiff() == EXC_BIFF8)
+            {
+                ScRange aRange;
+                // discard deleted ranges ( for the moment at least )
+                if ( pData->IsValidReference( aRange ) )
+                {
+                    ScExtTabSettings& rTabSett = GetExtDocOptions().GetOrCreateTabSettings( nXclTab );
+                    // create a mapping between the unmodified localname to
+                    // the name in the global name container for named ranges
+                    OSL_TRACE(" mapping local name to global name for tab %d which exists? %s", nXclTab, GetDoc().HasTable( mnScTab ) ? "true" : "false" );
+                    SCTAB nTab( static_cast< SCTAB >( mnScTab ) );
+                    NameToNameMap* pMap = GetDoc().GetLocalNameMap( nTab );
+                    if ( pMap )
+                       (*pMap)[ aRealOrigName ] = maScName;
+                }
+            }
+        }
         mpScData = pData;                   // cache for later use
     }
 }
--- sc/source/filter/excel/xistyle.cxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/filter/excel/xistyle.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -68,10 +68,70 @@
 #include "root.hxx"
 #include "colrowst.hxx"
 
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
+typedef ::std::vector< ColorData > ColorDataVec;
+
+class PaletteIndex : public XIndexAccess_BASE
+{
+public:
+    PaletteIndex( const ColorDataVec& rColorDataTable ) : maColorData( rColorDataTable ) {}
+
+    // Methods XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
+    {
+         return  maColorData.size();
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        //--Index;  // apparently the palette is already 1 based
+        return uno::makeAny( sal_Int32( maColorData[ Index ] ) );
+    }
+
+    // Methods XElementAcess
+    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (sal_Int32*)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
+    {
+        return (maColorData.size() > 0);
+    }
+
+private:
+    ColorDataVec        maColorData; 
+};
+
+void
+XclImpPalette::ExportPalette()
+{
+    if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
+    {
+        // copy values in color palette
+        sal_Int16 nColors =  maColorTable.size();
+        ColorDataVec aColors;
+        aColors.resize( nColors );
+        for( sal_uInt16 nIndex = 0; nIndex < nColors; ++nIndex )
+            aColors[ nIndex ] = GetColorData( nIndex );
+
+        uno::Reference< beans::XPropertySet > xProps( pDocShell->GetModel(), uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            uno::Reference< container::XIndexAccess > xIndex( new PaletteIndex( aColors ) ); 
+            xProps->setPropertyValue( CREATE_OUSTRING("ColorPalette"), uno::makeAny( xIndex ) ); 
+        }
+    }
+            
+}
 // PALETTE record - color information =========================================
 
 XclImpPalette::XclImpPalette( const XclImpRoot& rRoot ) :
-    XclDefaultPalette( rRoot )
+    XclDefaultPalette( rRoot ), mrRoot( rRoot )
 {
 }
 
@@ -105,6 +165,7 @@ void XclImpPalette::ReadPalette( XclImpS
         rStrm >> aColor;
         maColorTable[ nIndex ] = aColor.GetColor();
     }
+    ExportPalette();
 }
 
 // FONT record - font information =============================================
--- sc/source/filter/excel/xlescher.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/filter/excel/xlescher.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,6 +38,14 @@
 #include "document.hxx"
 #include "xistream.hxx"
 #include "xlescher.hxx"
+#include "globstr.hrc"
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/basmgr.hxx>
+#include <svx/msvbahelper.hxx>
 
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
@@ -300,10 +308,16 @@ Reference< XControlModel > XclControlHel
 #define EXC_MACRONAME_PRE "vnd.sun.star.script:Standard."
 #define EXC_MACRONAME_SUF "?language=Basic&location=document"
 
-OUString XclControlHelper::GetScMacroName( const String& rXclMacroName )
+OUString XclControlHelper::GetScMacroName( const String& rXclMacroName, SfxObjectShell* pDocShell )
 {
+    String sTmp( rXclMacroName );
     if( rXclMacroName.Len() > 0 )
-        return CREATE_OUSTRING( EXC_MACRONAME_PRE ) + rXclMacroName + CREATE_OUSTRING( EXC_MACRONAME_SUF );
+    {
+        ooo::vba::VBAMacroResolvedInfo aMacro = ooo::vba::resolveVBAMacro( pDocShell, rXclMacroName, false );
+        if ( aMacro.IsResolved() )
+            return ooo::vba::makeMacroURL( aMacro.ResolvedMacro() );
+
+    }
     return OUString();
 }
 
@@ -337,14 +351,14 @@ spTbxListenerData[] =
 #define EXC_MACROSCRIPT "Script"
 
 bool XclControlHelper::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor,
-        XclTbxEventType eEventType, const String& rXclMacroName )
+        XclTbxEventType eEventType, const String& rXclMacroName, SfxObjectShell* pShell )
 {
     if( rXclMacroName.Len() > 0 )
     {
         rDescriptor.ListenerType = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcListenerType );
         rDescriptor.EventMethod = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcEventMethod );
         rDescriptor.ScriptType = CREATE_OUSTRING( EXC_MACROSCRIPT );
-        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName );
+        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName, pShell );
         return true;
     }
     return false;
--- sc/source/filter/excel/xltoolbar.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/filter/excel/xltoolbar.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,433 @@
+#include "xltoolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOExcelCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOExcelCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOExcelCommandConvertor::MSOExcelCommandConvertor()
+{
+/*
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+*/
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+
+CTBS::CTBS() : bSignature(0), bVersion(0), reserved1(0), reserved2(0), reserved3(0), ctb(0), ctbViews(0), ictbView(0)
+{
+}
+
+CTB::CTB() : nViews( 0 ), ectbid(0)
+{
+}
+
+CTB::CTB(sal_uInt16 nNum ) : nViews( nNum ), ectbid(0)
+{
+}
+
+bool CTB::Read( SvStream *pS )
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    tb.Read( pS );
+    for ( sal_uInt16 index = 0; index < nViews; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+    *pS >> ectbid;
+  
+    for ( sal_Int16 index = 0; index < tb.getcCL(); ++index )
+    {
+        TBC aTBC;
+        aTBC.Read( pS );
+        rTBC.push_back( aTBC ); 
+    }
+    return true;
+}
+
+void CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTB -- dump\n", nOffSet );
+    indent_printf( fp, "  nViews 0x%x\n", nViews);
+    tb.Print( fp );
+
+    std::vector<TBVisualData>::iterator visData_end = rVisualData.end();
+    sal_Int32 counter = 0;
+    for ( std::vector<TBVisualData>::iterator it = rVisualData.begin(); it != visData_end; ++it )
+    {
+        
+        indent_printf( fp, "  TBVisualData [%d]\n", counter++ );
+        Indent b;
+        it->Print( fp );
+    } 
+    indent_printf( fp, "  ectbid 0x%x\n", ectbid);
+    std::vector<TBC>::iterator it_end = rTBC.end();
+    counter = 0;
+    for ( std::vector<TBC>::iterator it = rTBC.begin(); it != it_end; ++it )
+    {
+        indent_printf( fp, "  TBC [%d]\n", counter++);
+        Indent c;
+        it->Print( fp );
+    }
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xMenuDesc, CustomToolBarImportHelper& helper )
+{
+    sal_Int32 index = 0;
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it, ++index )
+    {
+        if ( !it->ImportToolBarControl( rWrapper, xMenuDesc, helper, IsMenuToolbar() ) )
+            return false;
+    }
+    return true;
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        WString& name = tb.getName();
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif 
+    
+        bRes = true;
+    }
+    catch( uno::Exception& )
+    {
+       bRes = false; 
+    }
+    return bRes;
+}
+bool CTBS::Read( SvStream *pS )
+{
+    OSL_TRACE("CTBS::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> bSignature >> bVersion >> reserved1 >> reserved2 >> reserved3 >> ctb >> ctbViews >> ictbView;
+    return true;
+}
+
+void CTBS::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBS -- dump\n", nOffSet );
+
+    indent_printf( fp, "  bSignature 0x%x\n", bSignature);
+    indent_printf( fp, "  bVersion 0x%x\n", bVersion);
+
+    indent_printf( fp, "  reserved1 0x%x\n", reserved1 );
+    indent_printf( fp, "  reserved2 0x%x\n", reserved2 );
+    indent_printf( fp, "  reserved3 0x%x\n", reserved3 );
+
+    indent_printf( fp, "  ctb 0x%x\n", ctb );
+    indent_printf( fp, "  ctbViews 0x%x\n", ctbViews );
+    indent_printf( fp, "  ictbView 0x%x\n", ictbView );
+}
+
+TBC::TBC()
+{
+}
+
+bool 
+TBC::Read(SvStream *pS)
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    if ( !tbch.Read( pS ) )
+        return false;
+    sal_uInt16 tcid = tbch.getTcID();
+    sal_uInt8 tct = tbch.getTct();
+    if (  ( tcid != 0x0001 && tcid != 0x06CC && tcid != 0x03D8 && tcid != 0x03EC && tcid != 0x1051 ) && ( ( tct > 0 && tct < 0x0B ) || ( ( tct > 0x0B && tct < 0x10 ) || tct == 0x15 ) ) )
+    {
+        tbcCmd.reset( new TBCCmd );
+        if ( !  tbcCmd->Read( pS ) )
+            return false;
+    }
+    if ( tct != 0x16 )
+    {
+        tbcd.reset( new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+
+void
+TBC::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBC -- dump\n", nOffSet );
+    tbch.Print( fp );
+    if ( tbcCmd.get() )
+        tbcCmd->Print( fp );    
+    if ( tbcd.get() )
+        tbcd->Print( fp );    
+}
+
+bool TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuToolbar )
+{
+    // how to identify built-in-command ?
+//    bool bBuiltin = false;
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+/*
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+         
+        }
+*/
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuToolbar ) )
+            return false;
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                 if ( !pCustTB->ImportMenuTB( rWrapper, xMenuDesc, helper ) )
+                     return false;     
+                 if ( !bIsMenuToolbar ) 
+                 {
+                     if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                         return false;
+                 }
+                 else
+                 {
+                     beans::PropertyValue aProp;
+                     aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                     aProp.Value <<= xMenuDesc;
+                     props.push_back( aProp );
+                 }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+        }
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+void
+TBCCmd::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, " TBCCmd -- dump\n" );
+    indent_printf( fp, "   cmdID 0x%x\n", cmdID );
+    indent_printf( fp, "   A ( fHideDrawing ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   B ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   cmdType 0x%x\n", cmdType );
+    indent_printf( fp, "   C ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   reserved3 0x%x\n", reserved3 );
+}
+
+bool TBCCmd::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCCmd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> cmdID;
+    sal_uInt16 temp;
+    *pS >> temp;
+    OSL_TRACE("TBCmd temp = 0x%x", temp );
+    A = (temp & 0x8000 ) == 0x8000; 
+    B = (temp & 0x4000) == 0x4000; 
+    cmdType = ( temp & 0x3E00 ) >> 9;
+    C = ( temp & 0x100 ) == 0x100; 
+    reserved3 = ( temp & 0xFF ); 
+    return true;
+}
+
+CTBWrapper::CTBWrapper()
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+bool 
+CTBWrapper::Read( SvStream *pS)
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    if ( !ctbSet.Read( pS ) )
+        return false;
+    for ( sal_uInt16 index = 0; index < ctbSet.ctb; ++index )
+    {
+        CTB aCTB( ctbSet.ctbViews );
+        if ( !aCTB.Read( pS ) )
+            return false;
+        rCTB.push_back( aCTB ); 
+    }
+    return true;
+}
+
+void 
+CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBWrapper -- dump\n", nOffSet );
+    ctbSet.Print( fp );
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        Indent b;
+        it->Print( fp );
+    } 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< CTB >::iterator it = rCTB.begin(); it != rCTB.end(); ++it )
+    {
+        if ( it->GetName().equals( sTBName ) )
+        {
+            pCTB = &(*it);
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        // for each customtoolbar
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument" ) ) ) );
+        helper.setMSOCommandMap( new  MSOExcelCommandConvertor() );
+        // Ignore menu toolbars, excel doesn't ( afaics ) store
+        // menu customizations ( but you can have menus in a customtoolbar
+        // such menus will be dealt with when they are encountered 
+        // as part of importing the appropriate MenuSpecific toolbar control )
+
+
+        if ( !(*it).IsMenuToolbar() ) 
+        {
+            if ( !(*it).ImportCustomToolBar( *this, helper ) )
+                return false;
+        }
+    } 
+    return true;
+}
+
+
--- sc/source/filter/excel/xltoolbar.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/filter/excel/xltoolbar.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,95 @@
+#ifndef _XLTOOLBAR_HXX
+#define _XLTOOLBAR_HXX
+
+#include <svx/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class CTBWrapper;
+// hmm I don't normally use these packed structures
+// but.. hey always good to do something different
+class TBCCmd : public TBBase
+{
+public:
+    TBCCmd() : cmdID(0), A(0), B(0), cmdType(0), C(0), reserved3(0) {}
+    sal_uInt16 cmdID;
+    sal_uInt16 A:1;
+    sal_uInt16 B:1;
+    sal_uInt16 cmdType:5;
+    sal_uInt16 C:1;
+    sal_uInt16 reserved3:8;
+    bool Read( SvStream* pS );
+    void Print(FILE* fp);
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr<TBCCmd> tbcCmd; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool ImportToolBarControl( CTBWrapper&, const com::sun::star::uno::Reference< com::sun::star::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar );
+};
+ 
+class CTB : public TBBase
+{
+    sal_uInt16 nViews;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_uInt32 ectbid;
+    std::vector< TBC > rTBC;
+    bool ImportCustomToolBar_Impl( CTBWrapper&, CustomToolBarImportHelper& );
+public:
+    CTB();
+    CTB(sal_uInt16);
+    ~CTB(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+
+
+};
+
+class CTBS : public TBBase
+{
+public:
+    sal_uInt8 bSignature;
+    sal_uInt8 bVersion;
+    sal_uInt16 reserved1;
+    sal_uInt16 reserved2;
+    sal_uInt16 reserved3;
+    sal_uInt16 ctb;
+    sal_uInt16 ctbViews;
+    sal_uInt16 ictbView;
+    CTBS(const CTBS&);
+    CTBS& operator = ( const CTBS&);
+    CTBS();
+    ~CTBS(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper : public TBBase
+{
+    CTBS ctbSet;
+
+    std::vector< CTB > rCTB; 
+
+public:
+    CTBWrapper();
+    ~CTBWrapper();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+};
+
+
+#endif //_XLTOOLBAR_HXX
--- sc/source/filter/inc/excimp8.hxx.old	2010-03-03 16:44:03.000000000 +0100
+++ sc/source/filter/inc/excimp8.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -53,7 +53,11 @@ class XclImpStream;
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
     protected:
+        // represents codename ( and associated modules ) 
+        // not speficied directly in the binary format
+        std::vector< String > AutoGeneratedCodeNames; 
         ExcScenarioList         aScenList;
 
         BOOL					bHasBasic;
--- sc/source/filter/inc/xcl97esc.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/inc/xcl97esc.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -54,6 +54,15 @@ class XclExpOcxControlObj;
 #else
 class XclExpTbxControlObj;
 #endif
+class XclExpShapeObj;
+class EscherExHostAppData;
+class ShapeInteractionHelper
+{
+public:
+   static XclExpShapeObj* CreateShapeObj(const XclExpRoot& rRoot, const ::com::sun::star::uno::Reference<
+                            ::com::sun::star::drawing::XShape >& xShape );
+   static void PopulateShapeInteractionInfo( const XclExpRoot& rRoot, const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >& xShape, EscherExHostAppData& rHostAppData );
+};
 
 class XclEscherEx : public EscherEx, protected XclExpRoot
 {
--- sc/source/filter/inc/xcl97rec.hxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/filter/inc/xcl97rec.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -285,7 +285,7 @@ public:
 
 class XclObjAny : public XclObj
 {
-private:
+protected:
     virtual void                WriteSubRecs( XclExpStream& rStrm );
 
 public:
--- sc/source/filter/inc/xecontent.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/inc/xecontent.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -116,6 +116,8 @@ public:
     inline const String* GetRepr() const { return mxRepr.get(); }
 
     virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+    virtual void        WriteEmbeddedData( XclExpStream& rStrm );
 private:
     /** Builds file name from the passed file URL. Tries to convert to relative file name.
         @param rnLevel  (out-param) The parent directory level.
--- sc/source/filter/inc/xeescher.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/inc/xeescher.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -88,6 +88,34 @@ private:
     sal_uInt16          mnEntryCount;   /// Number of entries in source range.
 };
 
+class XclMacroHelper : public XclExpControlHelper
+{
+protected:
+    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
+
+public:
+    explicit            XclMacroHelper( const XclExpRoot& rRoot );
+    virtual             ~XclMacroHelper();
+    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
+    void                WriteMacroSubRec( XclExpStream& rStrm  );
+    /** Sets the name of a macro for object of passed type
+        @return  true = The passed event descriptor was valid, macro name has been found. */
+    bool                SetMacroLink( const ::com::sun::star::script::ScriptEventDescriptor& rEvent,  const XclTbxEventType& nEventType );
+
+    /** Sets the name of a macro 
+        @return  true = The passed macro name has been found. */
+    bool                SetMacroLink( const String& rMacro );
+};
+
+class XclExpShapeObj : public XclObjAny, public XclMacroHelper
+{
+public:
+    explicit            XclExpShapeObj( const XclExpRoot& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual             ~XclExpShapeObj();
+private:
+    virtual void        WriteSubRecs( XclExpStream& rStrm );
+};
+
 // ----------------------------------------------------------------------------
 
 #if EXC_EXP_OCX_CTRL
@@ -114,7 +142,7 @@ private:
 #else
 
 /** Represents an OBJ record for an TBX form control. */
-class XclExpTbxControlObj : public XclObj, public XclExpControlHelper
+class XclExpTbxControlObj : public XclObj, public XclMacroHelper
 {
 public:
     explicit            XclExpTbxControlObj(
@@ -128,8 +156,6 @@ public:
 private:
     virtual void        WriteSubRecs( XclExpStream& rStrm );
 
-    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
-    void                WriteMacroSubRec( XclExpStream& rStrm );
     /** Writes a subrecord containing a cell link, or nothing, if no link present. */
     void                WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId );
     /** Writes the ftSbs sub structure containing scrollbar data. */
@@ -137,7 +163,6 @@ private:
 
 private:
     ScfInt16Vec         maMultiSel;     /// Indexes of all selected entries in a multi selection.
-    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
     XclTbxEventType     meEventType;    /// Type of supported macro event.
     sal_Int32           mnHeight;       /// Height of the control.
     sal_uInt16          mnState;        /// Checked/unchecked state.
--- sc/source/filter/inc/xiescher.hxx.old	2009-10-08 16:17:08.000000000 +0200
+++ sc/source/filter/inc/xiescher.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -33,6 +33,7 @@
 
 #include <vector>
 #include <map>
+#include <hash_map>
 #include <svx/msdffimp.hxx>
 #include <svx/msocximex.hxx>
 #include <vcl/graph.hxx>
@@ -94,7 +95,7 @@ public:
     /** Returns the Excel object type from OBJ record. */
     inline sal_uInt16   GetObjType() const { return mnObjType; }
     /** Returns the name of this object, may generate a default name. */
-    String              GetObjName() const;
+    virtual String              GetObjName() const;
     /** Returns associated macro name, if set, otherwise zero length string. */
     inline const String& GetMacroName() const { return maMacroName; }
 
@@ -497,6 +498,10 @@ protected:
     /** Derived classes will set additional properties for the current form control. */
     virtual void        DoProcessControl( ScfPropertySet& rPropSet ) const;
 
+    void ApplySheetLinkProps() const;
+    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
+                        mxShape;        /// The UNO wrapper of the control shape.
+    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
 private:
     /** Reads a list of cell ranges from a formula at the current stream position. */
     void                ReadRangeList( ScRangeList& rScRanges, XclImpStream& rStrm );
@@ -505,9 +510,6 @@ private:
 
 private:
     const XclImpRoot&   mrRoot;         /// Not derived from XclImpRoot to allow multiple inheritance.
-    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
-                        mxShape;        /// The UNO wrapper of the control shape.
-    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
     ScfRef< ScRange >   mxSrcRange;     /// Source data range in the Calc document.
     XclCtrlBindMode     meBindMode;     /// Value binding mode.
 };
@@ -609,6 +611,7 @@ protected:
     virtual XclTbxEventType DoGetEventType() const;
 
 protected:
+    void ApplyGrouping( XclImpOptionButtonObj& rLeader, sal_Int32 nRefVal );
     sal_uInt16          mnNextInGroup;      /// Next option button in a group.
     sal_uInt16          mnFirstInGroup;     /// 1 = Button is the first in a group.
 };
@@ -857,7 +860,8 @@ class XclImpPictureObj : public XclImpRe
 {
 public:
     explicit            XclImpPictureObj( const XclImpRoot& rRoot );
-
+    /** Returns the ObjectName - can use non-obvious lookup for override in the associated vba document module stream**/
+    virtual String              GetObjName() const;
     /** Returns the graphic imported from the IMGDATA record. */
     inline const Graphic& GetGraphic() const { return maGraphic; }
     /** Returns the visible area of the imported graphic. */
@@ -888,7 +892,6 @@ protected:
     virtual SdrObject*  DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const;
     /** Overloaded to do additional processing on the SdrObject. */
     virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
-
 private:
     /** Reads and sets the picture flags from a BIFF3-BIFF5 OBJ picture record. */
     void                ReadFlags3( XclImpStream& rStrm );
@@ -1083,6 +1086,8 @@ private:
 /** Stores all drawing and OLE objects and additional data related to these objects. */
 class XclImpObjectManager : protected XclImpRoot
 {
+typedef std::hash_map< sal_Int32, String >  CntrlObjIdToName;
+typedef std::map< String, CntrlObjIdToName > CodeNameToCntrlObjIdInfo;
 public:
     explicit            XclImpObjectManager( const XclImpRoot& rRoot );
     virtual             ~XclImpObjectManager();
@@ -1128,9 +1133,13 @@ public:
     String              GetDefaultObjName( const XclImpDrawObjBase& rDrawObj ) const;
     /** Returns the used area in the sheet with the passed index. */
     ScRange             GetUsedArea( SCTAB nScTab ) const;
-
+    void SetOleNameOverrideInfo( const CodeNameToCntrlObjIdInfo& rOverrideInfo ) {  maOleCtrlNameOverride = rOverrideInfo; }
+    String GetOleNameOverride( const XclObjId& nObjId );
     // ------------------------------------------------------------------------
 private:
+
+    CodeNameToCntrlObjIdInfo maOleCtrlNameOverride;
+
     /** Reads and returns a bitmap from WMF/PICT format. */
     static void         ReadWmf( Graphic& rGraphic, XclImpStream& rStrm );
     /** Reads and returns a bitmap from BMP format. */
--- sc/source/filter/inc/xistyle.hxx.old	2010-03-03 16:59:16.000000000 +0100
+++ sc/source/filter/inc/xistyle.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -72,8 +72,10 @@ public:
     void                ReadPalette( XclImpStream& rStrm );
 
 private:
+    void ExportPalette();
     typedef ::std::vector< ColorData > ColorDataVec;
     ColorDataVec        maColorTable;       /// Colors read from file.
+    const XclImpRoot&             mrRoot;
 };
 
 // FONT record - font information =============================================
--- sc/source/filter/inc/xlescher.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/inc/xlescher.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -432,7 +432,8 @@ public:
                         GetControlModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
 
     /** Returns the Calc macro name from an Excel macro name. */
-    static ::rtl::OUString GetScMacroName( const String& rXclMacroName );
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+
     /** Returns the Excel macro name from a Calc macro name. */
     static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
 
@@ -440,7 +441,7 @@ public:
     static bool         FillMacroDescriptor(
                             ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
                             XclTbxEventType eEventType,
-                            const String& rXclMacroName );
+                            const String& rXclMacroName, SfxObjectShell* pShell = NULL );
     /** Tries to extract an Excel macro name from the passed macro descriptor. */
     static String       ExtractFromMacroDescriptor(
                             const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
--- sc/source/filter/xcl97/xcl97esc.cxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/filter/xcl97/xcl97esc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -57,6 +57,9 @@
 #include "global.hxx"
 #include "document.hxx"
 #include "drwlayer.hxx"
+#include "xecontent.hxx"
+#include <svx/flditem.hxx>
+#include "userdat.hxx"
 #include "xcl97rec.hxx"
 #include "xehelper.hxx"
 #include "xechart.hxx"
@@ -232,7 +235,8 @@ EscherExHostAppData* XclEscherEx::StartS
         {
             // #107540# ignore permanent note shapes
             // #i12190# do not ignore callouts (do not filter by object type ID)
-            pCurrXclObj = new XclObjAny( GetRoot() );   // just a metafile
+            pCurrXclObj = ShapeInteractionHelper::CreateShapeObj( GetRoot(), rShape );
+            ShapeInteractionHelper::PopulateShapeInteractionInfo( GetRoot(), rShape, *pCurrAppData );
         }
     }
     if ( pCurrXclObj )
@@ -345,6 +349,7 @@ void XclEscherEx::DeleteCurrAppData()
         delete pCurrAppData->GetClientAnchor();
 //		delete pCurrAppData->GetClientData();
         delete pCurrAppData->GetClientTextbox();
+		delete pCurrAppData->GetInteractionInfo();
         delete pCurrAppData;
     }
 }
@@ -576,4 +581,40 @@ void XclEscherClientTextbox::WriteData(
     pXclObj->SetText( GetRoot(), rTextObj );
 }
 
+XclExpShapeObj* 
+ShapeInteractionHelper::CreateShapeObj(const XclExpRoot& rRoot, const Reference< XShape >& xShape )
+{
+    return new XclExpShapeObj( rRoot, xShape );
+}
+
+void
+ShapeInteractionHelper::PopulateShapeInteractionInfo(const XclExpRoot& rRoot, const Reference< XShape >& xShape, EscherExHostAppData& rHostAppData )
+{
+   try
+   {
+      SvMemoryStream* pMemStrm = NULL;
+      rtl::OUString sHyperLink;
+      rtl::OUString sMacro;
+      if ( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( ::GetSdrObjectFromXShape( xShape ) ) )
+      {
+         sHyperLink = pInfo->GetHlink();      
+         sMacro = pInfo->GetMacro();
+      }
+      if (  sHyperLink.getLength() > 0 )
+      {
+         pMemStrm = new SvMemoryStream();
+         XclExpStream tmpStream( *pMemStrm, rRoot );
+         ScAddress dummyAddress;
+         SvxURLField aUrlField;
+         aUrlField.SetURL( sHyperLink );
+         XclExpHyperlink hExpHlink( rRoot, aUrlField, dummyAddress );
+         hExpHlink.WriteEmbeddedData( tmpStream );
+      }
+      if ( ( sHyperLink.getLength() > 0 ) || ( sMacro.getLength() > 0 ) )
+          rHostAppData.SetInteractionInfo( new InteractionInfo( pMemStrm, true ) );
+   }
+   catch( Exception& )
+   {
+   }
+}
 
--- sc/source/filter/xml/xmlexprt.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/filter/xml/xmlexprt.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -3213,7 +3213,34 @@ void ScXMLExport::ExportShape(const uno:
         }
     }
     if (!bIsChart)
+	{
+		// #i66550 HLINK_FOR_SHAPES
+		rtl::OUString sHlink;
+		uno::Reference< beans::XPropertySet > xProps( xShape, uno::UNO_QUERY );
+		if ( xProps.is() )
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_HYPERLINK ) ) ) >>= sHlink;
+
+		std::auto_ptr< SvXMLElementExport > pDrawA;
+		// enlose shapes with <draw:a> element only if sHlink contains something
+		if ( sHlink.getLength() > 0 )
+		{
+			// need to get delete the attributes that are pre-loaded
+			// for the shape export ( otherwise they will become 	
+			// attributes of the draw:a element ) This *shouldn't* 
+			// affect performance adversely as there are only a 
+			// couple of attributes involved
+			uno::Reference< xml::sax::XAttributeList > xSaveAttribs( new  SvXMLAttributeList( GetAttrList() ) );
+			ClearAttrList();
+			// Add Hlink	
+			AddAttribute( XML_NAMESPACE_XLINK, XML_TYPE, XML_SIMPLE );
+			AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, sHlink);
+			pDrawA.reset( new SvXMLElementExport( *this, XML_NAMESPACE_DRAW, XML_A, sal_False, sal_False ) );
+			// Attribute list has been cleared by previous operation
+			// re-add pre-loaded attributes
+			AddAttributeList( xSaveAttribs );
+		}
         GetShapeExport()->exportShape(xShape, SEF_DEFAULT, pPoint);
+	}
     IncrementProgressBar(sal_False);
 }
 
--- sc/source/ui/attrdlg/scdlgfact.cxx.old	2010-03-03 16:59:12.000000000 +0100
+++ sc/source/ui/attrdlg/scdlgfact.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -82,6 +82,8 @@
 #include "tpstat.hxx" //add for ScDocStatPage
 #include "tpusrlst.hxx" //add for ScTpUserLists
 #include "tpview.hxx" //add for ScTpContentOptions
+//for dataform
+#include "datafdlg.hxx" //add for ScDataFormDlg
 #include "tpformula.hxx"
 
 // ause
@@ -96,6 +98,8 @@ IMPL_ABSTDLG_BASE(AbstractScDataPilotDat
 IMPL_ABSTDLG_BASE(AbstractScDataPilotSourceTypeDlg_Impl); //add for ScDataPilotSourceTypeDlg
 IMPL_ABSTDLG_BASE(AbstractScDataPilotServiceDlg_Impl); //add for ScDataPilotServiceDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteCellDlg_Impl); //add for ScDeleteCellDlg
+//for dataform
+IMPL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl); //add for ScDataFormDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteContentsDlg_Impl); //add for ScDeleteContentsDlg
 IMPL_ABSTDLG_BASE(AbstractScFillSeriesDlg_Impl); //add for ScFillSeriesDlg
 IMPL_ABSTDLG_BASE(AbstractScGroupDlg_Impl); //add for ScGroupDlg
@@ -867,6 +871,26 @@ AbstractScDeleteCellDlg* ScAbstractDialo
 
 //add for ScDeleteCellDlg  end
 
+//add for ScDataFormDlg begin
+AbstractScDataFormDlg* ScAbstractDialogFactory_Impl::CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*	pTabViewShell )
+{
+	ScDataFormDlg * pDlg=NULL;
+	switch ( nId )
+	{
+		case RID_SCDLG_DATAFORM :
+			pDlg = new ScDataFormDlg( pParent, pTabViewShell);
+			break;
+		default:
+			break;
+	}
+
+	if ( pDlg )
+		return new AbstractScDataFormDlg_Impl( pDlg );
+	return 0;
+}
+
+//add for ScDataFormDlg  end
+
 //add for ScDeleteContentsDlg begin
 AbstractScDeleteContentsDlg* ScAbstractDialogFactory_Impl::CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults )
--- sc/source/ui/attrdlg/scdlgfact.hxx.old	2010-03-03 16:44:04.000000000 +0100
+++ sc/source/ui/attrdlg/scdlgfact.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,7 @@ class ScDataPilotDatabaseDlg;
 class ScDataPilotSourceTypeDlg;
 class ScDataPilotServiceDlg;
 class ScDeleteCellDlg;
+class ScDataFormDlg;
 class ScDeleteContentsDlg;
 class ScFillSeriesDlg;
 class ScGroupDlg;
@@ -167,6 +168,12 @@ class AbstractScDeleteCellDlg_Impl : pub
     virtual DelCellCmd GetDelCellCmd() const;
 };
 
+//for dataform
+class AbstractScDataFormDlg_Impl : public AbstractScDataFormDlg  //add for ScDataFormDlg
+{
+	DECL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl,ScDataFormDlg);
+};
+
 class AbstractScDeleteContentsDlg_Impl : public AbstractScDeleteContentsDlg  //add for ScDeleteContentsDlg
 {
     DECL_ABSTDLG_BASE( AbstractScDeleteContentsDlg_Impl,ScDeleteContentsDlg)
@@ -430,6 +437,9 @@ public:
     virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId,
                                                             BOOL bDisallowCellMove = FALSE ); //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell); //add for ScDeleteCellDlg
+
     virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
                                                                  USHORT  nCheckDefaults = 0 );
 
--- sc/source/ui/docshell/docfunc.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/ui/docshell/docfunc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -51,6 +51,12 @@
 #include <svtools/zforlist.hxx>
 #include <svtools/PasswordHelper.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -104,6 +110,7 @@ using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 using ::std::vector;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2630,6 +2637,92 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName )
+{
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    uno::Reference< uno::XInterface > xDocModuleApiObject;
+    if ( xSF.is() )
+    {
+        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+        xDocModuleApiObject.set( xVBACodeNamedObjectAccess->getByName( sCodeName ), uno::UNO_QUERY );    
+    }
+    return xDocModuleApiObject;
+
+}
+
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule, String& sSource )
+{
+    ::rtl::OUString aModName( sModule );
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    script::ModuleInfo sModuleInfo;
+    sModuleInfo.ModuleName = aModName;
+    if ( sSource.Len() > 0 )
+        sModuleInfo.ModuleSource = sSource;
+    else
+        sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = script::ModuleType::Document;
+    sModuleInfo.ModuleObject = GetDocModuleObject( rDocSh, sModule );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sSource )
+{
+    SFX_APP()->EnterBasicCall();
+    script::ModuleInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName, sSource );
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // if the Module with codename exists then find a new name
+        sal_Int32 nNum = 1;
+        sModuleInfo.ModuleName = sModuleName;
+        while( xLib->hasByName( sModuleInfo.ModuleName  ) )
+        {
+            sModuleInfo.ModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            nNum += 1;
+        }
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleInfo.ModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleInfo.ModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
@@ -2639,8 +2732,18 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
     ScDocShellModificator aModificator( rDocShell );
 
     ScDocument* pDoc = rDocShell.GetDocument();
-    if (bRecord && !pDoc->IsUndoEnabled())
-        bRecord = FALSE;
+    // Strange loop, also basic is loaded too early ( InsertTable )
+    // is called via the xml import for sheets in described in odf 
+    BOOL bInsertDocModule = false;
+
+    if(  !rDocShell.GetDocument()->IsImportingXML() )
+    {
+        StarBASIC* pStarBASIC = rDocShell.GetBasic(); 
+        bInsertDocModule = pStarBASIC ? pStarBASIC->isVBAEnabled() : false;
+    }
+	if ( bInsertDocModule || ( bRecord && !pDoc->IsUndoEnabled() ) )
+		bRecord = FALSE;
+
     if (bRecord)
         pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2651,10 +2754,19 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 
     if (pDoc->InsertTab( nTab, rName ))
     {
+		String sCodeName;
         if (bRecord)
             rDocShell.GetUndoManager()->AddUndoAction(
                         new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
         //	Views updaten:
+        // Only insert vba modules if vba mode ( and not currently importing XML )
+        if( bInsertDocModule )
+        {
+            if ( sCodeName.Len() == 0 )
+		sCodeName = rName;
+            String sSource;
+            lcl_InsertModule( rDocShell, nTab, sCodeName, sSource );
+        }
         rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
         rDocShell.PostPaintExtras();
@@ -2676,7 +2788,11 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
     BOOL bSuccess = FALSE;
     ScDocument* pDoc = rDocShell.GetDocument();
-    if (bRecord && !pDoc->IsUndoEnabled())
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
+	if (bRecord && !pDoc->IsUndoEnabled())
+		bRecord = FALSE;
+    if ( bVbaEnabled )
         bRecord = FALSE;
     BOOL bWasLinked = pDoc->IsLinked(nTab);
     ScDocument* pUndoDoc = NULL;
@@ -2718,6 +2834,8 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
         pUndoData = new ScRefUndoData( pDoc );
     }
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
     if (pDoc->DeleteTab( nTab, pUndoDoc ))
     {
         if (bRecord)
@@ -2728,6 +2846,13 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
                         new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
         }
         //	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+            }
+        }
         rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
         if (bWasLinked)
@@ -4085,6 +4210,13 @@ BOOL ScDocFunc::FillSeries( const ScRang
 BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
                             FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi )
 {
+	double		fStep = 1.0;
+	double		fMax = MAXDOUBLE;
+	return FillAuto( rRange, pTabMark, eDir, FILL_AUTO, FILL_DAY, nCount, fStep, fMax, bRecord, bApi );
+}
+
+BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax,  BOOL bRecord, BOOL bApi )
+{
     ScDocShellModificator aModificator( rDocShell );
 
     ScDocument* pDoc = rDocShell.GetDocument();
@@ -4110,10 +4242,6 @@ BOOL ScDocFunc::FillAuto( ScRange& rRang
     ScRange aSourceArea = rRange;
     ScRange aDestArea   = rRange;
 
-    FillCmd		eCmd = FILL_AUTO;
-    FillDateCmd	eDateCmd = FILL_DAY;
-    double		fStep = 1.0;
-    double		fMax = MAXDOUBLE;
 
     switch (eDir)
     {
--- sc/source/ui/docshell/docsh.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/docshell/docsh.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -128,9 +128,16 @@
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
+#include "uiitems.hxx"
+#include "cellsuno.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 #include <basic/sbstar.hxx>
 #include <basic/basmgr.hxx>
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
+
+using namespace com::sun::star;
 using ::rtl::OUString;
 using ::rtl::OUStringBuffer;
 
@@ -276,7 +283,12 @@ sal_uInt16 ScDocShell::GetHiddenInformat
 void ScDocShell::BeforeXMLLoading()
 {
     aDocument.DisableIdle( TRUE );
-
+    // suppress VBA events when loading the xml
+    uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+    if ( xEvt.is() )
+       xEvt->setIgnoreEvents( sal_True );
+    
+// if VBA enabled then we need to  
     // prevent unnecessary broadcasts and updates
     DBG_ASSERT(pModificator == NULL, "The Modificator should not exist");
     pModificator = new ScDocShellModificator( *this );
@@ -381,7 +393,12 @@ void ScDocShell::AfterXMLLoading(sal_Boo
         BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
         if ( pAppMgr )
             pAppMgr->SetGlobalUNOConstant( "ThisExcelDoc", aArgs[ 0 ] );
-
+#if 0 // this should be controlled by a compatibility mode
+        // suppress VBA events when loading the xml
+        uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+        if ( xEvt.is() )
+            xEvt->setIgnoreEvents( sal_False );
+#endif
     aDocument.SetImportingXML( FALSE );
     aDocument.EnableExecuteLink( true );
     aDocument.EnableUndo( TRUE );
@@ -524,9 +541,71 @@ BOOL __EXPORT ScDocShell::Load( SfxMediu
     return bRet;
 }
 
+void lcl_processCompatibleSfxHint( uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper, const SfxHint& rHint )
+{
+    if (rHint.ISA(ScTablesHint) )
+    {
+		USHORT nId = ((ScTablesHint&)rHint).GetId();	
+		SCTAB nTab = ((ScTablesHint&)rHint).GetTab1();	
+        if( nId == SC_TAB_INSERTED )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= nTab;
+            xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_NEWSHEET, aArgs );
+        }
+    }
+    else if ( rHint.ISA( SfxEventHint ) )
+    {
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch ( nEventId )
+        {
+            case SFX_EVENT_ACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+                break;
+            case SFX_EVENT_DEACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_DEACTIVATE, aArgs );
+            }
+                break;
+            /*case SFX_EVENT_CLOSEDOC :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_CLOSE, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEVIEW :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWCOLSE, aArgs );
+            }
+                break;
+            */    
+            case SFX_EVENT_OPENDOC:
+            {
+                // some later than workbook activate.
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+            }
+                break;
+            default:
+                {
+                }
+                break;
+        }
+    }
+}
 
 void __EXPORT ScDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
 {
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+    {
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
+    }
     if (rHint.ISA(SfxSimpleHint))								// ohne Parameter
     {
         ULONG nSlot = ((const SfxSimpleHint&)rHint).GetId();
@@ -2209,6 +2288,16 @@ USHORT __EXPORT ScDocShell::PrepareClose
 
     DoEnterHandler();
 
+	// start handler for possible veto from DocBefore_Close
+    uno::Sequence< uno::Any > aArgs;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( !IsInPrepareClose() && xVbaEventsHelper.is() )
+    {
+	    if ( xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORECLOSE, aArgs ) )
+		    return sal_False;
+    }
+	// end handler code
+
     USHORT nRet = SfxObjectShell::PrepareClose( bUI, bForBrowsing );
     if (nRet == TRUE)						// TRUE = schliessen
         aDocument.DisableIdle(TRUE);		// nicht mehr drin rumpfuschen !!!
--- sc/source/ui/docshell/docsh5.cxx.old	2009-11-20 11:38:03.000000000 +0100
+++ sc/source/ui/docshell/docsh5.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -68,6 +68,11 @@
 #include "sc.hrc"
 #include "waitoff.hxx"
 #include "sizedev.hxx"
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+
+// defined in docfunc.cxx
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sModuleSource );
 
 // ---------------------------------------------------------------------------
 
@@ -872,6 +877,43 @@ BOOL ScDocShell::MoveTable( SCTAB nSrcTa
                 GetUndoManager()->AddUndoAction(
                         new ScUndoCopyTab( this, aSrcList, aDestList ) );
             }
+			
+			StarBASIC* pStarBASIC = GetBasic();
+        		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+                        if ( GetBasicManager()->GetName().Len() > 0 )
+			{
+				aLibName = GetBasicManager()->GetName();
+				pStarBASIC = GetBasicManager()->GetLib( aLibName );
+			}
+			BOOL bVbaEnabled = pStarBASIC ? pStarBASIC->isVBAEnabled() : FALSE;
+			SCTAB nTabToUse = nDestTab; 
+
+			if ( nDestTab == SC_TAB_APPEND )
+				nTabToUse = aDocument.GetMaxTableNumber() - 1;
+
+			if ( bVbaEnabled )
+			{
+				String sCodeName;
+				String sSource;
+				aDocument.GetCodeName( nTabToUse, sCodeName );
+				com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xLibContainer = GetBasicContainer();
+				com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLib;
+    				if( xLibContainer.is() )
+    				{
+        				com::sun::star::uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        				aLibAny >>= xLib;
+    				}
+    				if( xLib.is() )
+    				{
+					String sSrcCodeName;
+					aDocument.GetCodeName( nSrcTab, sSrcCodeName );
+					rtl::OUString sModName = sSrcCodeName;
+					com::sun::star::script::ModuleInfo sModuleInfo;
+					xLib->getByName( sModName ) >>= sModuleInfo;
+					sSource = sModuleInfo.ModuleSource;
+				} 
+				lcl_InsertModule( *this, nTabToUse, sCodeName, sSource );
+			}
         }
 
         Broadcast( ScTablesHint( SC_TAB_COPIED, nSrcTab, nDestTab ) );
--- sc/source/ui/docshell/macromgr.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/docshell/macromgr.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+// INCLUDE ---------------------------------------------------------------
+
+#include "macromgr.hxx"
+#include "document.hxx"
+
+#include "basic/basmgr.hxx"
+#include "cppuhelper/implbase1.hxx"
+#include "sfx2/objsh.hxx"
+#include "cell.hxx"
+#include <com/sun/star/container/XContainer.hpp>
+
+#include <list>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::RuntimeException;
+using ::com::sun::star::uno::Reference;
+using ::rtl::OUString;
+using ::rtl::OUStringHash;
+using ::std::hash_map;
+using ::std::list;
+using ::std::for_each;
+using ::std::pair;
+
+// ============================================================================
+
+/** 
+ * A simple container to keep track of cells that depend on basic modules 
+ * changes.  We don't check for duplicates at insertion time; instead, we 
+ * remove duplicates at query time. 
+ */
+class ScUserMacroDepTracker
+{
+public:
+    void addCell(const OUString& rModuleName, ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+        {
+            pair<ModuleCellMap::iterator, bool> r = maCells.insert(
+                ModuleCellMap::value_type(rModuleName, list<ScFormulaCell*>()));
+
+            if (!r.second)
+                // insertion failed.
+                return;
+
+            itr = r.first;
+        }
+        itr->second.push_back(pCell);
+    }
+
+    void removeCell(ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.begin(), itrEnd = maCells.end();
+        for (; itr != itrEnd; ++itr)
+            itr->second.remove(pCell);
+    }
+
+    void getCellsByModule(const OUString& rModuleName, list<ScFormulaCell*>& rCells)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+            return;
+
+        list<ScFormulaCell*>& rCellList = itr->second;
+
+        // Remove duplicates.
+        rCellList.sort();
+        rCellList.unique();
+        // exception safe copy
+        list<ScFormulaCell*> temp(rCellList);
+        rCells.swap(temp);
+    }
+
+private:
+    typedef hash_map<OUString, list<ScFormulaCell*>, OUStringHash> ModuleCellMap;
+    ModuleCellMap maCells;
+};
+
+
+// ============================================================================
+
+ScMacroManager::ScMacroManager(ScDocument* pDoc) :
+    mpDepTracker(new ScUserMacroDepTracker),
+    mpDoc(pDoc)
+{
+}
+
+ScMacroManager::~ScMacroManager()
+{
+}
+
+typedef ::cppu::WeakImplHelper1< ::com::sun::star::container::XContainerListener > ContainerListenerHelper;
+
+class VBAProjectListener : public ContainerListenerHelper
+{
+    ScMacroManager* mpMacroMgr;
+public:
+    VBAProjectListener( ScMacroManager* pMacroMgr ) : mpMacroMgr( pMacroMgr ) {}
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& /*Source*/ ) throw(RuntimeException) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& Event ) throw(RuntimeException)
+    {
+        rtl::OUString sModuleName;
+        Event.Accessor >>= sModuleName;
+        OSL_TRACE("VBAProjectListener::elementReplaced(%s)", rtl::OUStringToOString( sModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mpMacroMgr->InitUserFuncData();
+        mpMacroMgr->BroadcastModuleUpdate(sModuleName);
+    }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+
+};
+
+void ScMacroManager::InitUserFuncData()
+{
+    // Clear hash_map
+    mhFuncToVolatile.clear();
+    String sProjectName( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+
+    Reference< container::XContainer > xModuleContainer;
+    SfxObjectShell* pShell = mpDoc->GetDocumentShell();
+    if ( pShell && pShell->GetBasicManager()->GetName().Len() > 0 )
+        sProjectName = pShell->GetBasicManager()->GetName();
+    try
+    { 
+        Reference< script::XLibraryContainer > xLibraries( pShell->GetBasicContainer(), uno::UNO_QUERY_THROW );
+        xModuleContainer.set( xLibraries->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+        
+        if ( xModuleContainer.is() )
+        {
+            // remove old listener ( if there was one )
+            if ( mxContainerListener.is() )
+                xModuleContainer->removeContainerListener( mxContainerListener );
+            // Create listener
+            mxContainerListener = new VBAProjectListener( this );
+            xModuleContainer->addContainerListener( mxContainerListener );
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+void ScMacroManager::SetUserFuncVolatile( const OUString& sName, bool isVolatile )
+{
+    mhFuncToVolatile[ sName ] = isVolatile;
+}
+
+bool ScMacroManager::GetUserFuncVolatile( const OUString& sName )
+{
+    NameBoolMap::iterator it = mhFuncToVolatile.find( sName );
+    if ( it == mhFuncToVolatile.end() )
+        return false;
+    return it->second;
+}
+
+void ScMacroManager::AddDependentCell(const OUString& aModuleName, ScFormulaCell* pCell)
+{
+    mpDepTracker->addCell(aModuleName, pCell);
+}
+
+void ScMacroManager::RemoveDependentCell(ScFormulaCell* pCell)
+{
+    mpDepTracker->removeCell(pCell);
+}
+
+void ScMacroManager::BroadcastModuleUpdate(const OUString& aModuleName)
+{
+    list<ScFormulaCell*> aCells;
+    mpDepTracker->getCellsByModule(aModuleName, aCells);
+    list<ScFormulaCell*>::iterator itr = aCells.begin(), itrEnd = aCells.end();
+    for (; itr != itrEnd; ++itr)
+    {   
+        ScFormulaCell* pCell = *itr; 
+        mpDoc->PutInFormulaTree(pCell); // for F9 recalc
+
+        // for recalc on cell value change.  If the cell is not volatile, the
+        // cell stops listening right away after it gets re-interpreted.
+        mpDoc->StartListeningArea(BCA_LISTEN_ALWAYS, pCell);
+    }
+}
+
--- sc/source/ui/docshell/makefile.mk.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/docshell/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -95,7 +95,8 @@ SLOFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 
 EXCEPTIONSFILES= \
@@ -105,7 +106,8 @@ EXCEPTIONSFILES= \
         $(SLO)$/docsh8.obj \
         $(SLO)$/externalrefmgr.obj \
         $(SLO)$/dbdocimp.obj \
-        $(SLO)$/docfunc.obj
+        $(SLO)$/docfunc.obj \
+	$(SLO)$/macromgr.obj
 
 SRS1NAME=$(TARGET)
 SRC1FILES =  tpstat.src
@@ -135,7 +137,8 @@ LIB1OBJFILES =  \
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 # --- Tagets -------------------------------------------------------
 
--- sc/source/ui/drawfunc/drawsh.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/drawfunc/drawsh.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -211,7 +211,6 @@ void ScDrawShell::ExecDrawAttr( SfxReque
             ExecuteTextAttrDlg( rReq );
             break;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         case SID_DRAW_HLINK_EDIT:
             if ( pSingleSelectedObj )
                 pViewData->GetDispatcher().Execute( SID_HYPERLINK_DIALOG );
@@ -239,7 +238,6 @@ void ScDrawShell::ExecDrawAttr( SfxReque
                     ScGlobal::OpenURL( pInfo->GetHlink(), String::EmptyString() );
             }
             break;
-#endif
 
         case SID_ATTR_TRANSFORM:
             {
@@ -494,7 +492,6 @@ void ScDrawShell::ExecuteTextAttrDlg( Sf
     delete( pDlg );
 }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 void ScDrawShell::SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk )
 {
     if ( pObj )
@@ -504,5 +501,4 @@ void ScDrawShell::SetHlinkForObject( Sdr
         lcl_setModified( GetObjectShell() );
     }
 }
-#endif
 
--- sc/source/ui/drawfunc/drawsh2.cxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/drawfunc/drawsh2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -200,24 +200,20 @@ void ScDrawShell::GetDrawFuncState( SfxI
     BOOL bCanRename = FALSE;
     if ( nMarkCount > 1 )
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         // no hypelink options for a selected group
         rSet.DisableItem( SID_DRAW_HLINK_EDIT );
         rSet.DisableItem( SID_DRAW_HLINK_DELETE );
         rSet.DisableItem( SID_OPEN_HYPERLINK );
-#endif
     }
     else if ( nMarkCount == 1 )
     {
         SdrObject* pObj = rMarkList.GetMark( 0 )->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( !pInfo || (pInfo->GetHlink().getLength() == 0) )
         {
             rSet.DisableItem( SID_DRAW_HLINK_DELETE );
             rSet.DisableItem( SID_OPEN_HYPERLINK );
         }
-#endif
         SdrLayerID nLayerID = pObj->GetLayer();
         if ( nLayerID != SC_LAYER_INTERN )
             bCanRename = TRUE;                          // #i51351# anything except internal objects can be renamed
--- sc/source/ui/drawfunc/drawsh5.cxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/drawfunc/drawsh5.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -95,14 +95,12 @@ void ScDrawShell::GetHLinkState( SfxItem
     if ( nMarkCount == 1 )              // URL-Button markiert ?
     {
         SdrObject* pObj = rMarkList.GetMark(0)->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
         {
             aHLinkItem.SetURL( pInfo->GetHlink() );
             aHLinkItem.SetInsertMode(HLINK_FIELD);
         }
-#endif
         SdrUnoObj* pUnoCtrl = PTR_CAST(SdrUnoObj, pObj);
         if (pUnoCtrl && FmFormInventor == pUnoCtrl->GetObjInventor())
         {
@@ -245,13 +243,11 @@ void ScDrawShell::ExecuteHLink( SfxReque
                                     bDone = TRUE;
                                 }
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             else
                             {
                                 SetHlinkForObject( pObj, rURL );
                                 bDone = TRUE;
                             }
-#endif
                         }
                     }
 
--- sc/source/ui/drawfunc/fudraw.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/drawfunc/fudraw.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -831,11 +831,7 @@ void FuDraw::ForcePointer(const MouseEve
             SdrObjMacroHitRec aHitRec;	//! muss da noch irgendwas gesetzt werden ????
             pViewShell->SetActivePointer( pObj->GetMacroPointer(aHitRec) );
         }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         else if ( !bAlt && pInfo && ((pInfo->GetMacro().getLength() > 0) || (pInfo->GetHlink().getLength() > 0)) )
-#else
-        else if ( !bAlt && pInfo && (pInfo->GetMacro().getLength() > 0) )
-#endif
             pWindow->SetPointer( Pointer( POINTER_REFHAND ) );
         else if ( IsDetectiveHit( aPnt ) )
             pViewShell->SetActivePointer( Pointer( POINTER_DETECTIVE ) );
--- sc/source/ui/drawfunc/fusel.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/drawfunc/fusel.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -205,7 +205,6 @@ BOOL __EXPORT FuSelection::MouseButtonDo
                    }
 
                    ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj, TRUE );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                    // For interoperability favour links over macros if both are defined
                    if ( pInfo->GetHlink().getLength() > 0 )
                    {
@@ -213,20 +212,27 @@ BOOL __EXPORT FuSelection::MouseButtonDo
                        sURL = pInfo->GetHlink();
                    }
                    else if ( pInfo->GetMacro().getLength() > 0 )
-#else
-                   if ( pInfo->GetMacro().getLength() > 0 )
-#endif
                    {
                        SfxObjectShell* pObjSh = SfxObjectShell::Current();
                        if ( pObjSh && SfxApplication::IsXScriptURL( pInfo->GetMacro() ) )
                        {
+                           uno::Reference< beans::XPropertySet > xProps( pObj->getUnoShape(), uno::UNO_QUERY );
+                           uno::Any aCaller;
+                           if ( xProps.is() )
+                           {
+                               try
+                               {
+                                   aCaller = xProps->getPropertyValue( rtl::OUString::createFromAscii("Name") );
+                               }
+                               catch( uno::Exception& ) {}
+                           }
                            uno::Any aRet;
                            uno::Sequence< sal_Int16 > aOutArgsIndex;
                            uno::Sequence< uno::Any > aOutArgs;
                            uno::Sequence< uno::Any >* pInArgs =
                                new uno::Sequence< uno::Any >(0);
                            pObjSh->CallXScript( pInfo->GetMacro(),
-                               *pInArgs, aRet, aOutArgsIndex, aOutArgs);
+                               *pInArgs, aRet, aOutArgsIndex, aOutArgs, true, &aCaller );
                            pViewShell->FakeButtonUp( pViewShell->GetViewData()->GetActivePart() );
                            return TRUE;        // kein CaptureMouse etc.
                        }
--- sc/source/ui/drawfunc/makefile.mk.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/drawfunc/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -79,6 +79,7 @@ SLOFILES =  \
         $(SLO)$/mediash.obj
 
 EXCEPTIONSFILES= \
+        $(SLO)$/fusel.obj \
         $(SLO)$/fuins2.obj
 
 NOOPTFILES=\
--- sc/source/ui/drawfunc/objdraw.src.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/drawfunc/objdraw.src	2010-03-03 16:59:35.000000000 +0100
@@ -189,7 +189,6 @@
         ITEM_FORMAT_PARA_DLG\
     };
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 #define MN_EDITLNK \
     MenuItem\
     {\
@@ -205,7 +204,6 @@
         HelpID = SID_DRAW_HLINK_DELETE ; \
         Text [ en-US ] = "~Remove Hyperlink" ; \
     };
-#endif
 
 #define MN_DRWTXTATTR \
     MenuItem\
@@ -1298,14 +1296,12 @@ Menu RID_POPUP_DRAW
         MenuItem { Separator = TRUE ; };
          //------------------------------
         ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
          //------------------------------
         MenuItem { Separator = TRUE ; };
          //------------------------------
         MN_EDITLNK
         MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
     };
 };
 
@@ -1375,14 +1371,12 @@ Menu RID_POPUP_GRAPHIC
         MenuItem { Separator = TRUE ; };
          //------------------------------
         ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
          //------------------------------
         MenuItem { Separator = TRUE ; };
          //------------------------------
         MN_EDITLNK
         MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
     };
 };
 
--- sc/source/ui/inc/datafdlg.hrc.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/inc/datafdlg.hrc	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hrc,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:37:12 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sc.hrc"	// -> RID_SCDLG_DATAFORM
+
+//dataform
+#define BTN_DATAFORM_NEW          1001
+#define BTN_DATAFORM_DELETE       1002
+#define BTN_DATAFORM_RESTORE      1003
+#define BTN_DATAFORM_LAST         1004
+#define BTN_DATAFORM_NEXT         1005
+#define BTN_DATAFORM_CLOSE        1007
+#define WND_DATAFORM_SCROLLBAR    1008
+#define LAB_DATAFORM_RECORDNO     1009
+
+#define FT_DATAFORM_FIXEDTEXT1    2001
+#define ED_DATAFORM_EDIT1         2002
\ No newline at end of file
--- sc/source/ui/inc/datafdlg.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/inc/datafdlg.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:20:35 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DATAFDLG_HXX
+#define SC_DATAFDLG_HXX
+
+
+#ifndef _SV_DIALOG_HXX //autogen
+#include <vcl/dialog.hxx>
+#endif
+
+#ifndef _SV_BUTTON_HXX //autogen
+#include <vcl/imagebtn.hxx>
+#endif
+
+#ifndef _SV_FIXED_HXX //autogen
+#include <vcl/fixed.hxx>
+#endif
+
+
+#include "global.hxx"
+
+#include <tabvwsh.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/dispatch.hxx>
+
+#define MAX_DATAFORM_COLS   256
+#define MAX_DATAFORM_ROWS   32000
+#define CTRL_HEIGHT         22
+#define FIXED_WIDTH         60
+#define EDIT_WIDTH          140 
+#define FIXED_LEFT          12
+#define EDIT_LEFT           78
+#define LINE_HEIGHT         30
+
+//zhangyun
+class ScDataFormDlg : public ModalDialog
+{
+private:
+
+    PushButton      aBtnNew;
+    PushButton      aBtnDelete;
+    PushButton      aBtnRestore;
+    PushButton      aBtnLast;
+    PushButton      aBtnNext;
+    PushButton      aBtnClose;
+    ScrollBar       aSlider;
+    FixedText       aFixedText;
+    //FixedText       aFixedText1;
+    //Edit            aEdit1;
+    
+    ScTabViewShell* pTabViewShell;
+    ScDocument*     pDoc;
+    sal_uInt16      aColLength;
+    SCROW           aCurrentRow;
+    SCCOL           nStartCol;
+    SCCOL           nEndCol;
+    SCROW           nStartRow;
+    SCROW           nEndRow;
+    SCTAB           nTab;
+    BOOL            bNoSelection;
+    
+    FixedText** pFixedTexts;
+    Edit** pEdits;
+
+public:
+    ScDataFormDlg( Window* pParent, ScTabViewShell* pTabViewShell);
+    ~ScDataFormDlg();
+    
+    void FillCtrls(SCROW nCurrentRow);
+private:
+
+    void SetButtonState();
+
+    // Handler:
+    DECL_LINK( Impl_NewHdl,     PushButton*    );
+    DECL_LINK( Impl_LastHdl,    PushButton*    );
+    DECL_LINK( Impl_NextHdl,    PushButton*    );
+    
+    DECL_LINK( Impl_RestoreHdl, PushButton*    );
+    DECL_LINK( Impl_DeleteHdl,  PushButton*    );
+    DECL_LINK( Impl_CloseHdl,   PushButton*    );
+    
+    DECL_LINK( Impl_ScrollHdl,  ScrollBar*    );
+    DECL_LINK( Impl_DataModifyHdl,  Edit*    );
+};
+#endif // SC_DATAFDLG_HXX
+
+
--- sc/source/ui/inc/docfunc.hxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/source/ui/inc/docfunc.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -173,6 +173,8 @@ public:
                                 double fStart, double fStep, double fMax,
                                 BOOL bRecord, BOOL bApi );
                     // FillAuto: rRange wird von Source-Range auf Dest-Range angepasst
+	SC_DLLPUBLIC	BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax, BOOL bRecord, BOOL bApi );
+
     BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
                                 FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi );
 
--- sc/source/ui/inc/docsh.hxx.old	2010-03-03 16:44:02.000000000 +0100
+++ sc/source/ui/inc/docsh.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,6 +47,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
--- sc/source/ui/inc/drawsh.hxx.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/inc/drawsh.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,9 +47,7 @@ class ScDrawShell : public SfxShell
 
     DECL_LINK( NameObjectHdl, AbstractSvxNameDialog* );
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk );
-#endif
 
 protected:
     ScViewData*	GetViewData()	{ return pViewData; }
--- sc/source/ui/inc/tabvwsh.hxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/inc/tabvwsh.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -252,7 +252,7 @@ public:
 
     virtual			~ScTabViewShell();
 
-    Window*			GetDialogParent();
+	SC_DLLPUBLIC Window* GetDialogParent();
 
     bool            IsRefInputMode() const;
     void			ExecuteInputDirect();
--- sc/source/ui/inc/undodat.hxx.old	2010-03-03 16:44:03.000000000 +0100
+++ sc/source/ui/inc/undodat.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -531,7 +531,43 @@ private:
     void				Init();
 };
 
+// amelia
+class ScUndoDataForm: public ScBlockUndo
+{
+public:
+					TYPEINFO();
+					ScUndoDataForm( ScDocShell* pNewDocShell,
+								SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+								SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+								const ScMarkData& rMark,
+								ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+								USHORT nNewFlags,
+								ScRefUndoData* pRefData, void* pFill1, void* pFill2, void* pFill3,
+								BOOL bRedoIsFilled = TRUE
+								 );
+	virtual		~ScUndoDataForm();
 
+	virtual	void	Undo();
+	virtual	void	Redo();
+	virtual void	Repeat(SfxRepeatTarget& rTarget);
+	virtual BOOL	CanRepeat(SfxRepeatTarget& rTarget) const;
+
+	virtual String	GetComment() const;
+
+private:
+	ScMarkData		aMarkData;
+	ScDocument*		pUndoDoc;
+	ScDocument*		pRedoDoc;
+	USHORT			nFlags;
+	ScRefUndoData*		pRefUndoData;
+	ScRefUndoData*		pRefRedoData;
+	ULONG			nStartChangeAction;
+	ULONG			nEndChangeAction;
+	BOOL			bRedoFilled;
+
+	void			DoChange( const BOOL bUndo );
+	void			SetChangeTrack();
+};
 
 
 #endif
--- sc/source/ui/inc/viewfunc.hxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/source/ui/inc/viewfunc.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -341,6 +341,13 @@ public:
     void			ForgetFormatArea()		{ bFormatValid = FALSE; }
     BOOL			SelectionEditable( BOOL* pOnlyNotBecauseOfMatrix = NULL );
 
+        // Amelia Wang
+        SC_DLLPUBLIC void                   DataFormPutData( SCROW nCurrentRow ,
+                                                             SCROW nStartRow , SCCOL nStartCol ,
+                                                             SCROW nEndRow , SCCOL nEndCol ,
+                                                             Edit** pEdits ,
+                                                             sal_uInt16 aColLength );
+
                                                 // interne Hilfsfunktionen
 protected:
     void			UpdateLineAttrs( SvxBorderLine&		  rLine,
--- sc/source/ui/miscdlgs/datafdlg.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/miscdlgs/datafdlg.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,422 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.cxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: kz $ $Date: 2006/07/21 14:04:33 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+#undef SC_DLLIMPLEMENTATION
+
+//------------------------------------------------------------------
+
+#include "datafdlg.hxx"
+#include "scresid.hxx"
+#include "datafdlg.hrc"
+#include "viewdata.hxx"
+//#include "document.hxx"
+#include "docsh.hxx"
+#include "refundo.hxx"
+#include "undodat.hxx"
+
+#define HDL(hdl)            LINK( this, ScDataFormDlg, hdl )
+
+//zhangyun
+ScDataFormDlg::ScDataFormDlg( Window* pParent, ScTabViewShell*  pTabViewShellOri) :
+    ModalDialog     ( pParent, ScResId( RID_SCDLG_DATAFORM ) ),
+    //
+    aBtnNew          ( this, ScResId( BTN_DATAFORM_NEW ) ),
+    aBtnDelete          ( this, ScResId( BTN_DATAFORM_DELETE ) ),
+    aBtnRestore          ( this, ScResId( BTN_DATAFORM_RESTORE ) ),
+    aBtnLast          ( this, ScResId( BTN_DATAFORM_LAST ) ),
+    aBtnNext          ( this, ScResId( BTN_DATAFORM_NEXT ) ),
+    aBtnClose          ( this, ScResId( BTN_DATAFORM_CLOSE ) ),
+    aSlider         ( this, ScResId( WND_DATAFORM_SCROLLBAR ) ),
+    aFixedText          ( this, ScResId( LAB_DATAFORM_RECORDNO ) )
+{
+    pTabViewShell = pTabViewShellOri;
+    FreeResource();
+    //read header form current document, and add new controls
+    DBG_ASSERT( pTabViewShell, "pTabViewShell is NULL! :-/" );
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    
+    pDoc = pViewData->GetDocument();
+    if (pDoc)
+    {
+        ScRange aRange;
+        pViewData->GetSimpleArea( aRange );
+        ScAddress aStart = aRange.aStart;
+        ScAddress aEnd = aRange.aEnd;
+        
+        nStartCol = aStart.Col();
+        nEndCol = aEnd.Col();
+        nStartRow   = aStart.Row();
+        nEndRow = aEnd.Row();
+        
+        nTab = pViewData->GetTabNo();
+        //if there is no selection
+        if ((nStartCol == nEndCol) && (nStartRow == nEndRow))
+            bNoSelection = TRUE;
+        
+        if (bNoSelection)
+        {
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                nEndCol++;
+                pDoc->GetString( nEndCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nEndCol--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                if (nStartCol <= 0)
+                    break;
+                nStartCol--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nStartCol++;
+                    break;
+                }
+            }
+            
+            //skip leading hide column
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                int nColWidth = pDoc->GetColWidth( nStartCol, nTab );
+                if (nColWidth)
+                    break;
+                nStartCol++;
+            }
+
+            if (nEndCol < nStartCol)
+                nEndCol = nStartCol;
+                
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                nEndRow++;
+                pDoc->GetString( nStartCol, nEndRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nEndRow--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                if (nStartRow <= 0)
+                    break;
+                nStartRow--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nStartRow++;
+                    break;
+                }
+            }
+
+            if (nEndRow < nStartRow)
+                nEndRow = nStartRow;
+        }
+        
+        aCurrentRow = nStartRow + 1;
+        
+        String  aFieldName;
+
+        int nTop = 12;
+
+        Size    nFixedSize(FIXED_WIDTH, CTRL_HEIGHT );
+        Size    nEditSize(EDIT_WIDTH, CTRL_HEIGHT );
+        
+        //pFtArray = new FixedText(this);
+        aColLength = nEndCol - nStartCol + 1;
+        
+        //new the controls
+        pFixedTexts = new FixedText*[aColLength];
+        pEdits = new Edit*[aColLength];
+        
+        for(sal_uInt16 nIndex = 0; nIndex < aColLength; nIndex++)
+        {
+            pDoc->GetString( nIndex + nStartCol, nStartRow, nTab, aFieldName );
+            int nColWidth = pDoc->GetColWidth( nIndex + nStartCol, nTab );
+            if (nColWidth)
+            {
+                pFixedTexts[nIndex] = new FixedText(this);
+                pEdits[nIndex] = new Edit(this, WB_BORDER);
+        
+                pFixedTexts[nIndex]->SetSizePixel(nFixedSize);
+                pEdits[nIndex]->SetSizePixel(nEditSize);
+                pFixedTexts[nIndex]->SetPosPixel(Point(FIXED_LEFT, nTop));
+                pEdits[nIndex]->SetPosPixel(Point(EDIT_LEFT, nTop));
+                //pFixedTexts[nIndex]->SetText(String::CreateFromAscii("W4W-Filter Nr. "));
+                pFixedTexts[nIndex]->SetText(aFieldName);
+                pFixedTexts[nIndex]->Show();
+                pEdits[nIndex]->Show();
+                
+                nTop += LINE_HEIGHT;
+            }
+            else
+            {
+                pFixedTexts[nIndex] = NULL;
+                pEdits[nIndex] = NULL;
+            }
+        pEdits[nIndex]->SetModifyHdl( HDL(Impl_DataModifyHdl) );
+        }
+        
+        Size nDialogSize = this->GetSizePixel();
+        if (nTop > nDialogSize.Height())
+        {
+            nDialogSize.setHeight(nTop);
+            this->SetSizePixel(nDialogSize);
+        }
+        Size nScrollSize = aSlider.GetSizePixel();
+        nScrollSize.setHeight(nDialogSize.Height()-20);
+        aSlider.SetSizePixel(nScrollSize);
+    }
+    
+    FillCtrls(aCurrentRow);
+    
+    aSlider.SetPageSize( 10 );
+    aSlider.SetVisibleSize( 1 );
+    aSlider.SetLineSize( 1 );
+    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+    aSlider.Show();
+    
+    aBtnNew.SetClickHdl     ( HDL(Impl_NewHdl)    );
+    aBtnLast.SetClickHdl    ( HDL(Impl_LastHdl)    );
+    aBtnNext.SetClickHdl    ( HDL(Impl_NextHdl)    );
+    
+    aBtnRestore.SetClickHdl     ( HDL(Impl_RestoreHdl)    );
+    aBtnDelete.SetClickHdl  ( HDL(Impl_DeleteHdl)    );
+    aBtnClose.SetClickHdl   ( HDL(Impl_CloseHdl)    );
+    
+    aSlider.SetEndScrollHdl( HDL( Impl_ScrollHdl ) );
+
+    SetButtonState();
+
+    //end
+    //FreeResource();
+}
+
+ScDataFormDlg::~ScDataFormDlg()
+{
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+            delete pEdits[i];
+        if (pFixedTexts[i])
+            delete pFixedTexts[i];
+    }
+    if (pEdits)
+        delete pEdits;
+    if (pFixedTexts)
+        delete pFixedTexts;
+}
+
+void ScDataFormDlg::FillCtrls(SCROW /*nCurrentRow*/)
+{
+    //ScViewData*   pViewData = pTabViewShell->GetViewData();
+    
+    //pDoc = pViewData->GetDocument();
+    String  aFieldName;
+    int nRecordNum = nEndRow - nStartRow;
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+        {
+            if (aCurrentRow<=nEndRow)
+            {
+                pDoc->GetString( i + nStartCol, aCurrentRow, nTab, aFieldName );
+                pEdits[i]->SetText(aFieldName);
+            }
+            else
+                pEdits[i]->SetText(String());
+        }
+    }
+    char sRecordStr[256];
+    if (aCurrentRow<=nEndRow)
+        aFixedText.SetText(String::CreateFromAscii(sRecordStr));
+    else
+        aFixedText.SetText(String::CreateFromAscii("New Record"));
+        
+    aSlider.SetThumbPos(aCurrentRow-nStartRow-1);
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DataModifyHdl, Edit*, pEdit)
+{
+    if ( pEdit->IsModified() )
+        aBtnRestore.Enable( TRUE );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NewHdl, PushButton*, EMPTYARG )
+{
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if ( pDoc )
+    {
+        sal_Bool bHasData = sal_False;
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+            if (pEdits[i])
+                if ( pEdits[i]->GetText().Len() != 0 )
+                {
+                    bHasData = sal_True;
+                    break;
+                }
+
+        if ( bHasData )
+        {
+            pTabViewShell->DataFormPutData( aCurrentRow , nStartRow , nStartCol , nEndRow , nEndCol , pEdits , aColLength );
+            aCurrentRow++;
+            if (aCurrentRow >= nEndRow + 2)
+            {
+                    nEndRow ++ ;
+                    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+            }
+            SetButtonState();
+            FillCtrls(aCurrentRow);
+            pDocSh->SetDocumentModified();
+            pDocSh->PostPaintGridAll();
+            }
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_LastHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow > nStartRow +1 )
+            aCurrentRow--;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NextHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow <= nEndRow)
+            aCurrentRow++;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_RestoreHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DeleteHdl, PushButton*, EMPTYARG )
+{   
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if (pDoc)
+    {
+        ScRange aRange(nStartCol, aCurrentRow, nTab, nEndCol, aCurrentRow, nTab);
+        pDoc->DeleteRow(aRange);
+        nEndRow--;
+        
+        SetButtonState();
+        pDocSh->GetUndoManager()->Clear();
+
+        FillCtrls(aCurrentRow);
+        pDocSh->SetDocumentModified();
+        pDocSh->PostPaintGridAll();
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_CloseHdl, PushButton*, EMPTYARG )
+{   
+    EndDialog( );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_ScrollHdl, ScrollBar*, EMPTYARG )
+{   
+    long nOffset = aSlider.GetThumbPos();
+    aCurrentRow = nStartRow + nOffset + 1;
+    SetButtonState();
+    FillCtrls(aCurrentRow);
+    return 0;
+}
+
+void ScDataFormDlg::SetButtonState()
+{
+    if ( aCurrentRow > nEndRow )
+    {
+        aBtnDelete.Enable( FALSE );
+        aBtnLast.Enable( TRUE );
+        aBtnNext.Enable( FALSE );
+    }
+    else
+    {
+        aBtnDelete.Enable( TRUE );
+        aBtnNext.Enable( TRUE );
+    }
+    if ( 1 == aCurrentRow )
+        aBtnLast.Enable( FALSE );
+
+    aBtnRestore.Enable( FALSE );
+    if ( pEdits )
+        pEdits[0]->GrabFocus();
+}
--- sc/source/ui/miscdlgs/makefile.mk.old	2010-03-03 16:59:09.000000000 +0100
+++ sc/source/ui/miscdlgs/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -45,6 +45,7 @@ LIBTARGET=no
 # --- Files --------------------------------------------------------
 
 SLOFILES =  \
+	$(SLO)$/datafdlg.obj		\
     $(SLO)$/delcldlg.obj		\
     $(SLO)$/inscldlg.obj		\
     $(SLO)$/delcodlg.obj		\
--- sc/source/ui/src/datafdlg.src.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/src/datafdlg.src	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.src,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: hr $ $Date: 2005/09/23 15:07:30 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "datafdlg.hrc"
+
+//zhangyun, dataform
+ModalDialog RID_SCDLG_DATAFORM
+{
+    OutputSize = TRUE ;
+    SVLook = TRUE ;
+    Size = MAP_APPFONT ( 191 , 180 ) ;
+    Text [ en-US ] = "Data Form" ;
+    Moveable = TRUE ;
+    Closeable = TRUE ;
+    FixedText LAB_DATAFORM_RECORDNO
+    {
+        Pos = MAP_APPFONT ( 136 , 6 ) ;
+        Size = MAP_APPFONT ( 50 , 12 ) ;
+        Text [ en-US ] = "/" ;
+    };
+    PushButton BTN_DATAFORM_NEW
+    {
+        Pos = MAP_APPFONT ( 135 , 23 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        DefButton = TRUE ;
+        Text [ en-US ] = "New" ;
+    };
+    PushButton BTN_DATAFORM_DELETE
+    {
+        Pos = MAP_APPFONT ( 135 , 40 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Delete" ;
+    };
+    PushButton BTN_DATAFORM_RESTORE
+    {
+        Pos = MAP_APPFONT ( 135 , 57 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Restore" ;
+    };
+    PushButton BTN_DATAFORM_LAST
+    {
+        Pos = MAP_APPFONT ( 135 , 82 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Last Record" ;
+    };
+    PushButton BTN_DATAFORM_NEXT
+    {
+        Pos = MAP_APPFONT ( 135 , 99 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Next Record" ;
+    };
+    PushButton BTN_DATAFORM_CLOSE
+    {
+        Pos = MAP_APPFONT ( 135 , 116 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Close" ;
+    };
+    ScrollBar WND_DATAFORM_SCROLLBAR
+    {
+        Pos = MAP_APPFONT ( 124 , 6 ) ;
+        Size = MAP_APPFONT ( 8 , 135 ) ;
+        HScroll = FALSE ;
+        TabStop = FALSE ;
+    };
+};
+//end
+
+
+
+
--- sc/source/ui/src/globstr.src.old	2010-03-03 16:44:04.000000000 +0100
+++ sc/source/ui/src/globstr.src	2010-03-03 16:59:35.000000000 +0100
@@ -1725,6 +1725,77 @@ Resource RID_GLOBSTR
     {
         Text [ en-US ] = "Unknown User";
     };
+
+    String STR_SHAPE_AUTOSHAPE
+    {
+        Text [ en-US ] = "AutoShape";
+    };
+
+    String STR_SHAPE_RECTANGLE
+    {
+        Text [ en-US ] = "Rectangle";
+    };
+
+    String STR_SHAPE_LINE
+    {
+        Text [ en-US ] = "Line";
+    };
+
+    String STR_SHAPE_OVAL
+    {
+        Text [ en-US ] = "Oval";
+    };
+
+    String STR_SHAPE_TEXTBOX
+    {
+        Text [ en-US ] = "Text Box";
+    };
+
+    String STR_FORM_BUTTON
+    {
+        Text [ en-US ] = "Button";
+    };
+
+    String STR_FORM_CHECKBOX
+    {
+        Text [ en-US ] = "Check Box";
+    };
+
+    String STR_FORM_OPTIONBUTTON
+    {
+        Text [ en-US ] = "Option Button";
+    };
+
+    String STR_FORM_LABEL
+    {
+        Text [ en-US ] = "Label";
+    };
+
+    String STR_FORM_LISTBOX
+    {
+        Text [ en-US ] = "List Box";
+    };
+
+    String STR_FORM_GROUPBOX
+    {
+        Text [ en-US ] = "Group Box";
+    };
+
+    String STR_FORM_DROPDOWN 
+    {
+        Text [ en-US ] = "Drop Down";
+    };
+
+    String STR_FORM_SPINNER
+    {
+        Text [ en-US ] = "Spinner";
+    };
+
+    String STR_FORM_SCROLLBAR
+    {
+        Text [ en-US ] = "Scroll Bar";
+    };
+
     String STR_STYLE_FAMILY_CELL
     {
         Text [ en-US ] = "Cell Styles";
--- sc/source/ui/src/makefile.mk.old	2009-10-07 15:06:14.000000000 +0200
+++ sc/source/ui/src/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -57,6 +57,7 @@ SRC1FILES = \
     dbnamdlg.src \
     subtdlg.src  \
     miscdlgs.src \
+	datafdlg.src \
     autofmt.src  \
     solvrdlg.src \
     optsolver.src \
--- sc/source/ui/undo/undodat.cxx.old	2010-03-03 16:59:18.000000000 +0100
+++ sc/source/ui/undo/undodat.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -54,6 +54,8 @@
 #include "dpobject.hxx"
 #include "attrib.hxx"
 #include "sc.hrc"
+#include "chgtrack.hxx"  // Amelia Wang
+#include "refundo.hxx"  // Amelia Wang
 
 // -----------------------------------------------------------------------
 
@@ -74,6 +76,7 @@ TYPEINIT1(ScUndoRepeatDB,           ScSi
 TYPEINIT1(ScUndoDataPilot,          ScSimpleUndo);
 TYPEINIT1(ScUndoConsolidate,        ScSimpleUndo);
 TYPEINIT1(ScUndoChartData,          ScSimpleUndo);
+TYPEINIT1(ScUndoDataForm,           SfxUndoAction);    // amelia
 
 // -----------------------------------------------------------------------
 
@@ -2182,8 +2185,210 @@ BOOL __EXPORT ScUndoChartData::CanRepeat
     return FALSE;
 }
 
+// Amelia Wang
+ScUndoDataForm::ScUndoDataForm( ScDocShell* pNewDocShell,
+                                SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+                                SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+                                const ScMarkData& rMark,
+                                ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+                                USHORT nNewFlags,
+                                ScRefUndoData* pRefData,
+                                void* /*pFill1*/, void* /*pFill2*/, void* /*pFill3*/,
+                                BOOL bRedoIsFilled ) :
+        ScBlockUndo( pNewDocShell, ScRange( nStartX, nStartY, nStartZ, nEndX, nEndY, nEndZ ), SC_UNDO_SIMPLE ),
+        aMarkData( rMark ),
+        pUndoDoc( pNewUndoDoc ),
+        pRedoDoc( pNewRedoDoc ),
+        nFlags( nNewFlags ),
+        pRefUndoData( pRefData ),
+        pRefRedoData( NULL ),
+        bRedoFilled( bRedoIsFilled )
+{
+        //      pFill1,pFill2,pFill3 are there so the ctor calls for simple paste (without cutting)
+        //      don't have to be changed and branched for 641.
+        //      They can be removed later.
+
+        if ( !aMarkData.IsMarked() )                            // no cell marked:
+                aMarkData.SetMarkArea( aBlockRange );   //  mark paste block
+
+        if ( pRefUndoData )
+                pRefUndoData->DeleteUnchanged( pDocShell->GetDocument() );
+
+        SetChangeTrack();
+}
+
+ScUndoDataForm::~ScUndoDataForm()
+{
+        delete pUndoDoc;
+        delete pRedoDoc;
+        delete pRefUndoData;
+        delete pRefRedoData;
+}
+
+String ScUndoDataForm::GetComment() const
+{
+        return ScGlobal::GetRscString( STR_UNDO_PASTE ); 
+}
+
+void ScUndoDataForm::SetChangeTrack()
+{
+        ScChangeTrack* pChangeTrack = pDocShell->GetDocument()->GetChangeTrack();
+        if ( pChangeTrack && (nFlags & IDF_CONTENTS) )
+                pChangeTrack->AppendContentRange( aBlockRange, pUndoDoc,
+                        nStartChangeAction, nEndChangeAction, SC_CACM_PASTE );
+        else
+                nStartChangeAction = nEndChangeAction = 0;
+}
+
+
+void ScUndoDataForm::Undo()
+{
+        BeginUndo();
+        DoChange( TRUE );
+        ShowTable( aBlockRange );
+        EndUndo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Redo()
+{
+        BeginRedo();
+        ScDocument* pDoc = pDocShell->GetDocument();
+        EnableDrawAdjust( pDoc, FALSE );                                //! include in ScBlockUndo?
+        DoChange( FALSE );
+        EnableDrawAdjust( pDoc, TRUE );                                 //! include in ScBlockUndo?
+        EndRedo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Repeat(SfxRepeatTarget& /*rTarget*/)
+{
+}
+
+BOOL ScUndoDataForm::CanRepeat(SfxRepeatTarget& rTarget) const
+{
+        return (rTarget.ISA(ScTabViewTarget));
+}
+
+void ScUndoDataForm::DoChange( const BOOL bUndo )
+{
+    ScDocument* pDoc = pDocShell->GetDocument();
+
+    //      RefUndoData for redo is created before first undo
+    //      (with DeleteUnchanged after the DoUndo call)
+    BOOL bCreateRedoData = ( bUndo && pRefUndoData && !pRefRedoData );
+    if ( bCreateRedoData )
+            pRefRedoData = new ScRefUndoData( pDoc );
+
+    ScRefUndoData* pWorkRefData = bUndo ? pRefUndoData : pRefRedoData;
 
+    //      fuer Undo immer alle oder keine Inhalte sichern
+    USHORT nUndoFlags = IDF_NONE;
+    if (nFlags & IDF_CONTENTS)
+            nUndoFlags |= IDF_CONTENTS;
+    if (nFlags & IDF_ATTRIB)
+            nUndoFlags |= IDF_ATTRIB;
 
+    BOOL bPaintAll = FALSE;
 
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
+
+    // marking is in ScBlockUndo...
+    //ScUndoUtil::MarkSimpleBlock( pDocShell, aBlockRange );
+
+    SCTAB nTabCount = pDoc->GetTableCount();
+    if ( bUndo && !bRedoFilled )
+    {
+        if (!pRedoDoc)
+        {
+            BOOL bColInfo = ( aBlockRange.aStart.Row()==0 && aBlockRange.aEnd.Row()==MAXROW );
+            BOOL bRowInfo = ( aBlockRange.aStart.Col()==0 && aBlockRange.aEnd.Col()==MAXCOL );
+
+            pRedoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pRedoDoc->InitUndoSelected( pDoc, aMarkData, bColInfo, bRowInfo );
+        }
+        //  read "redo" data from the document in the first undo
+            //  all sheets - CopyToDocument skips those that don't exist in pRedoDoc
+        ScRange aCopyRange = aBlockRange;
+        aCopyRange.aStart.SetTab(0);
+        aCopyRange.aEnd.SetTab(nTabCount-1);
+        pDoc->CopyToDocument( aCopyRange, 1, FALSE, pRedoDoc );
+        bRedoFilled = TRUE;
+    }
+
+    USHORT nExtFlags = 0;
+    pDocShell->UpdatePaintExt( nExtFlags, aBlockRange );
 
+    for ( sal_uInt16 i=0; i <= ( aBlockRange.aEnd.Col() - aBlockRange.aStart.Col() ); i++ )
+    {
+        String aOldString;
+        pUndoDoc->GetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+        pDoc->SetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+    }
+
+    //ScRange aTabSelectRange = aBlockRange;
 
+    if (pWorkRefData)
+    {
+        pWorkRefData->DoUndo( pDoc, TRUE );             // TRUE = bSetChartRangeLists for SetChartListenerCollection
+        if ( pDoc->RefreshAutoFilter( 0,0, MAXCOL,MAXROW, aBlockRange.aStart.Tab() ) )
+            bPaintAll = TRUE;
+    }
+
+    if ( bCreateRedoData && pRefRedoData )
+            pRefRedoData->DeleteUnchanged( pDoc );
+    
+    if ( bUndo )
+    {
+        ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+        if ( pChangeTrack )
+            pChangeTrack->Undo( nStartChangeAction, nEndChangeAction );
+    }
+    else
+        SetChangeTrack();
+
+    ScRange aDrawRange( aBlockRange );
+    pDoc->ExtendMerge( aDrawRange, TRUE );      // only needed for single sheet (text/rtf etc.)
+    USHORT nPaint = PAINT_GRID;
+    if (bPaintAll)
+    {
+        aDrawRange.aStart.SetCol(0);
+        aDrawRange.aStart.SetRow(0);
+        aDrawRange.aEnd.SetCol(MAXCOL);
+        aDrawRange.aEnd.SetRow(MAXROW);
+        nPaint |= PAINT_TOP | PAINT_LEFT;
+/*A*/   if (pViewShell)
+            pViewShell->AdjustBlockHeight(FALSE);
+    }
+    else
+    {
+        if ( aBlockRange.aStart.Row() == 0 && aBlockRange.aEnd.Row() == MAXROW )        // ganze Spalte
+        {
+            nPaint |= PAINT_TOP;
+            aDrawRange.aEnd.SetCol(MAXCOL);
+        }
+        if ( aBlockRange.aStart.Col() == 0 && aBlockRange.aEnd.Col() == MAXCOL )        // ganze Zeile
+        {
+            nPaint |= PAINT_LEFT;
+            aDrawRange.aEnd.SetRow(MAXROW);
+        }
+/*A*/   if ((pViewShell) && pViewShell->AdjustBlockHeight(FALSE))
+        {
+            aDrawRange.aStart.SetCol(0);
+            aDrawRange.aStart.SetRow(0);
+            aDrawRange.aEnd.SetCol(MAXCOL);
+            aDrawRange.aEnd.SetRow(MAXROW);
+            nPaint |= PAINT_LEFT;
+        }
+        pDocShell->UpdatePaintExt( nExtFlags, aDrawRange );
+    }
+
+    if ( !bUndo )                               //      draw redo after updating row heights
+        RedoSdrUndoAction( pDrawUndo );                 //!     include in ScBlockUndo?
+
+    pDocShell->PostPaint( aDrawRange, nPaint, nExtFlags );
+
+    pDocShell->PostDataChanged();
+    if (pViewShell)
+        pViewShell->CellContentChanged();
+}
--- sc/source/ui/unoobj/addruno.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/unoobj/addruno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -72,7 +72,7 @@ void ScAddressConversionObj::Notify( Sfx
     }
 }
 
-sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString )
+sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv )
 {
     if (!pDocShell)
         return sal_False;
@@ -81,7 +81,7 @@ sal_Bool ScAddressConversionObj::ParseUI
     sal_Bool bSuccess = sal_False;
     if ( bIsRange )
     {
-        USHORT nResult = aRange.ParseAny( rUIString, pDoc );
+        USHORT nResult = aRange.ParseAny( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -95,7 +95,7 @@ sal_Bool ScAddressConversionObj::ParseUI
     }
     else
     {
-        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc );
+        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -119,6 +119,7 @@ uno::Reference<beans::XPropertySetInfo>
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellRangeAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -132,6 +133,7 @@ uno::Reference<beans::XPropertySetInfo>
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -193,8 +195,11 @@ void SAL_CALL ScAddressConversionObj::se
             bSuccess = ParseUIString( aUIString );
         }
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
         //  parse the file format string
         rtl::OUString sRepresentation;
         if (aValue >>= sRepresentation)
@@ -215,7 +220,7 @@ void SAL_CALL ScAddressConversionObj::se
             }
 
             //  parse the rest like a UI string
-            bSuccess = ParseUIString( aUIString );
+            bSuccess = ParseUIString( aUIString, aConv );
         }
     }
     else
@@ -268,17 +273,24 @@ uno::Any SAL_CALL ScAddressConversionObj
             aRange.aStart.Format( aFormatStr, nFlags, pDoc );
         aRet <<= rtl::OUString( aFormatStr );
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
+
         //  generate file format string - always include sheet
         String aFormatStr;
-        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc );
+        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
         if ( bIsRange )
         {
             //  manually concatenate range so both parts always have the sheet name
             aFormatStr.Append( (sal_Unicode) ':' );
             String aSecond;
-            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc );
+            USHORT nFlags = SCA_VALID;
+            if( aConv != ::formula::FormulaGrammar::CONV_XL_A1 )
+		nFlags |= SCA_TAB_3D;
+            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
             aFormatStr.Append( aSecond );
         }
         aRet <<= rtl::OUString( aFormatStr );
--- sc/source/ui/unoobj/docuno.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/ui/unoobj/docuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -100,7 +100,12 @@
 #include <svx/unoshape.hxx>
 #endif
 
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
+
+#define SC_UNO_VBADOCOBJ "ThisVBADocObj" // perhaps we want to actually make this ThisWorkbook ?
 
 //------------------------------------------------------------------------
 
@@ -116,6 +121,7 @@ const SfxItemPropertyMapEntry* lcl_GetDo
         {MAP_CHAR_LEN(SC_UNO_AUTOCONTFOC),       0, &getBooleanCppuType(),                                    0, 0},
         {MAP_CHAR_LEN(SC_UNO_BASICLIBRARIES),    0, &getCppuType((uno::Reference< script::XLibraryContainer >*)0), beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN(SC_UNO_DIALOGLIBRARIES),   0, &getCppuType((uno::Reference< script::XLibraryContainer >*)0), beans::PropertyAttribute::READONLY, 0},
+        {MAP_CHAR_LEN(SC_UNO_VBADOCOBJ),   0, &getCppuType((beans::PropertyValue*)0), beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN(SC_UNO_CALCASSHOWN),       PROP_UNO_CALCASSHOWN, &getBooleanCppuType(),                                    0, 0},
         {MAP_CHAR_LEN(SC_UNONAME_CLOCAL),        0, &getCppuType((lang::Locale*)0),                           0, 0},
         {MAP_CHAR_LEN(SC_UNO_CJK_CLOCAL),        0, &getCppuType((lang::Locale*)0),                           0, 0},
@@ -320,6 +326,7 @@ uno::Any SAL_CALL ScModelObj::queryInter
     SC_QUERYINTERFACE( view::XRenderable )
     SC_QUERYINTERFACE( document::XLinkTargetSupplier )
     SC_QUERYINTERFACE( beans::XPropertySet )
+	SC_QUERYINTERFACE( document::XDocumentEventCompatibleHelper)
     SC_QUERYINTERFACE( lang::XMultiServiceFactory )
     SC_QUERYINTERFACE( lang::XServiceInfo )
     SC_QUERYINTERFACE( util::XChangesNotifier )
@@ -1578,6 +1585,18 @@ uno::Any SAL_CALL ScModelObj::getPropert
         {
             aRet <<= pDocShell->GetDialogContainer();
         }
+        else if ( aString.EqualsAscii( SC_UNO_VBADOCOBJ ) )
+        {
+            // PropertyValue seems extreme because we store
+            // the model ( as the value member ) of the PropertyValue that is
+            // itself a property of the model ( the intention however is to 
+            // store something like a Workbook object... but we don't do that )
+            // yet
+            beans::PropertyValue aProp;
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisExcelDoc") );
+            aProp.Value <<= pDocShell->GetModel();
+            aRet <<= aProp;
+        }
         else if ( aString.EqualsAscii( SC_UNO_RUNTIMEUID ) )
         {
             aRet <<= getRuntimeUID();
@@ -1751,6 +1770,39 @@ uno::Sequence<rtl::OUString> SAL_CALL Sc
     return concatServiceNames( aMyServices, aDrawServices );
 }
 
+// XVbaEventHelper
+// For Vba Event
+sal_Bool SAL_CALL
+ScModelObj::processCompatibleEvent( sal_Int16 nSlotId ) throw( ::com::sun::star::uno::RuntimeException )
+{
+    USHORT nId = (USHORT)nSlotId;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+    if( xVbaEventsHelper.is() )
+    {
+        switch( nId )
+        {
+            case SID_SAVEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_False;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_SAVEASDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_True;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_PRINTDOC:
+            case SID_PRINTDOCDIRECT:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFOREPRINT, aArgs );
+            }
+        }
+    }
+    return sal_False;
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
@@ -1789,6 +1841,12 @@ sal_Int64 SAL_CALL ScModelObj::getSometh
         return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(this));
     }
 
+	if ( rId.getLength() == 16 &&
+          0 == rtl_compareMemory( SfxObjectShell::getUnoTunnelId().getConstArray(),
+									rId.getConstArray(), 16 ) )
+        {
+            return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(pDocShell ));
+        }
     //	aggregated number formats supplier has XUnoTunnel, too
     //	interface from aggregated object must be obtained via queryAggregation
 
--- sc/source/ui/unoobj/servuno.cxx.old	2009-10-19 13:27:16.000000000 +0200
+++ sc/source/ui/unoobj/servuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,6 +38,7 @@
 #include <svx/unofill.hxx>
 #include <svx/unonrule.hxx>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
 
 #include "servuno.hxx"
 #include "unonames.hxx"
@@ -61,8 +62,153 @@
 #include <svx/xmleohlp.hxx>
 #include <svx/xmlgrhlp.hxx>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <cppuhelper/component_context.hxx>
+#include <vbahelper/vbahelper.hxx>
 using namespace ::com::sun::star;
 
+class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    uno::Any maWorkbook;
+    uno::Any maCachedObject;
+    ScDocShell* mpDocShell;
+public:
+    ScVbaObjectForCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
+
+        uno::Sequence< uno::Any > aArgs(2);
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( mpDocShell->GetModel() );
+        maWorkbook <<= ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.excel.Workbook", aArgs );
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        maCachedObject = uno::Any(); // clear cached object
+        String sName = aName;
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        if ( sName == pDoc->GetCodeName() )
+            maCachedObject = maWorkbook;
+        else 
+        {
+            String sCodeName;
+            SCTAB nCount = pDoc->GetTableCount();
+            for( SCTAB i = 0; i < nCount; i++ )
+            {
+                pDoc->GetCodeName( i, sCodeName );
+                if( sCodeName == sName )
+                {
+                    String sSheetName;
+                    if( pDoc->GetName( i, sSheetName ) )
+                    {
+                        uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                        uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                        uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                        uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                        uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                        uno::Sequence< uno::Any > aArgs(3);
+                        aArgs[0] = maWorkbook;
+                        aArgs[1] = uno::Any( xModel );
+                        aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                        maCachedObject <<= ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.excel.Worksheet", aArgs );
+                        break;
+                    }
+                }
+            }
+        }
+        return maCachedObject.hasValue();
+
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectForCodeNameProvider::getByName( %s )",
+            rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( !hasByName( aName ) )
+            throw ::com::sun::star::container::NoSuchElementException();
+        return maCachedObject;
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        SCTAB nCount = pDoc->GetTableCount();
+        uno::Sequence< rtl::OUString > aNames( nCount + 1 ); 
+        SCTAB index = 0;
+        String sCodeName;
+        for( ; index < nCount; ++index )
+        {
+            pDoc->GetCodeName( index, sCodeName );
+            aNames[ index ] = sCodeName;
+        }
+        aNames[ index ] = pDoc->GetCodeName();
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
+
+class ScVbaCodeNameProvider : public ::cppu::WeakImplHelper1< document::XCodeNameQuery >
+{
+ScDocShell* mpDocShell;
+public:
+    ScVbaCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+    // XCodeNameQuery
+    rtl::OUString SAL_CALL getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sCodeName;
+        if ( mpDocShell )
+        {
+            OSL_TRACE( "*** In ScVbaCodeNameProvider::getCodeNameForObject");
+            // need to find the page ( and index )  for this control
+            uno::Reference< drawing::XDrawPagesSupplier > xSupplier( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPages(), uno::UNO_QUERY_THROW );
+            sal_Int32 nLen = xIndex->getCount();
+            bool bMatched = false;
+            uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+            for ( sal_Int32 index = 0; index < nLen; ++index )
+            {
+                try
+                {
+                    uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex->getByIndex( index ), uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                    // get the www-standard container
+                    uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                    sal_Int32 nCntrls = xFormControls->getCount();
+                    for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                    {
+                        uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                        bMatched = ( xControl == xIf );
+                        if ( bMatched )
+                        {
+                            String sName;
+                            mpDocShell->GetDocument()->GetCodeName( index, sName );
+                            sCodeName = sName;
+                        }
+                    }
+                }
+                catch( uno::Exception& ) {}
+                if ( bMatched )
+                    break;
+            }
+        }
+        // Probably should throw here ( if !bMatched )
+         return sCodeName;
+    }
+
+};
 
 //------------------------------------------------------------------------
 //
@@ -119,7 +265,8 @@ static const ProvNamesId_Type __FAR_DATA
     { SC_SERVICENAME_CHDATAPROV,            SC_SERVICE_CHDATAPROV },
     { SC_SERVICENAME_FORMULAPARS,           SC_SERVICE_FORMULAPARS },
     { SC_SERVICENAME_OPCODEMAPPER,          SC_SERVICE_OPCODEMAPPER },
-
+    { "ooo.vba.VBAObjectModuleObjectProvider", SC_SERVICE_VBAOBJECTPROVIDER }, // SC_SERVICE_VBAOBJECTPROVIDER
+    { "ooo.vba.VBACodeNameProvider", SC_SERVICE_VBACODENAMEPROVIDER }, // SC_SERVICE_VBACODENAMEPROVIDER
     // case-correct versions of the service names (#i102468#)
     { "com.sun.star.text.textfield.URL",                SC_SERVICE_URLFIELD },
     { "com.sun.star.text.textfield.PageNumber",         SC_SERVICE_PAGEFIELD },
@@ -180,7 +327,9 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
+        "",                                         // SC_SERVICE_VBACODENAMEPROVIDER
     };
 
 
@@ -385,6 +534,12 @@ uno::Reference<uno::XInterface> ScServic
                 xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj(::std::auto_ptr<formula::FormulaCompiler> (pComp))));
             }
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<container::XNameAccess*>(new ScVbaObjectForCodeNameProvider( pDocShell )));
+            break;
+        case SC_SERVICE_VBACODENAMEPROVIDER:
+            xRet.set(static_cast<document::XCodeNameQuery*>(new ScVbaCodeNameProvider( pDocShell )));
+            break;
     }
     return xRet;
 }
--- sc/source/ui/unoobj/shapeuno.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/unoobj/shapeuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -73,6 +73,8 @@ const SfxItemPropertyMapEntry* lcl_GetSh
         {MAP_CHAR_LEN(SC_UNONAME_HORIPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_IMAGEMAP),	0, &getCppuType((uno::Reference<container::XIndexContainer>*)0), 0, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_VERTPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
+		// #i66550 HLINK_FOR_SHAPES
+		{MAP_CHAR_LEN(SC_UNONAME_HYPERLINK), 0, &getCppuType((rtl::OUString*)0), 0, 0 },
         {0,0,0,0,0,0}
     };
     return aShapeMap_Impl;
@@ -87,6 +89,14 @@ const SvEventDescription* ScShapeObj::Ge
     };
     return aMacroDescriptionsImpl;
 }
+// #i66550 HLINK_FOR_SHAPES
+ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate = FALSE )
+{
+        if( pShape )
+            if( SdrObject* pObj = pShape->GetSdrObject() )
+                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
+        return 0;
+}
 
 //------------------------------------------------------------------------
 
@@ -162,12 +172,12 @@ uno::Any SAL_CALL ScShapeObj::queryInter
 
 void SAL_CALL ScShapeObj::acquire() throw()
 {
-        OWeakObject::acquire();
+        OWeakObject::acquire();
 }
 
 void SAL_CALL ScShapeObj::release() throw()
 {
-        OWeakObject::release();
+        OWeakObject::release();
 }
 
 void ScShapeObj::GetShapePropertySet()
@@ -638,6 +648,13 @@ void SAL_CALL ScShapeObj::setPropertyVal
             }
         }
     }
+	else if  ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+                rtl::OUString sHlink;
+        	ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this, TRUE);
+        	if ( ( aValue >>= sHlink ) && pInfo )
+			pInfo->SetHlink( sHlink );
+	}
     else
     {
         GetShapePropertySet();
@@ -819,6 +836,13 @@ uno::Any SAL_CALL ScShapeObj::getPropert
             }
         }
     }
+	else if ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+		rtl::OUString sHlink;
+		if ( ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this) )
+			sHlink = pInfo->GetHlink();
+		aAny <<= sHlink;
+	}
     else
     {
         GetShapePropertySet();
@@ -1342,11 +1366,6 @@ SdrObject* ScShapeObj::GetSdrObject() co
 }
 
 #define SC_EVENTACC_ONCLICK     ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) )
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-#define SC_EVENTACC_ONACTION    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) )
-#define SC_EVENTACC_URL         ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) )
-#define SC_EVENTACC_ACTION      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) )
-#endif
 #define SC_EVENTACC_SCRIPT      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Script" ) )
 #define SC_EVENTACC_EVENTTYPE   ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) )
 
@@ -1358,10 +1377,7 @@ private:
 
     ScMacroInfo* getInfo( BOOL bCreate = FALSE )
     {
-        if( mpShape )
-            if( SdrObject* pObj = mpShape->GetSdrObject() )
-                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
-        return 0;
+		return lcl_getShapeHyperMacroInfo( mpShape, bCreate );
     }
 
 public:
@@ -1387,11 +1403,7 @@ public:
                 isEventType = true;
                 continue;
             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( isEventType && ((pProperties->Name == SC_EVENTACC_SCRIPT) || (pProperties->Name == SC_EVENTACC_URL)) )
-#else
             if ( isEventType && (pProperties->Name == SC_EVENTACC_SCRIPT) )
-#endif
             {
                 rtl::OUString sValue;
                 if ( pProperties->Value >>= sValue )
@@ -1402,10 +1414,8 @@ public:
                         break;
                     if ( pProperties->Name == SC_EVENTACC_SCRIPT )
                         pInfo->SetMacro( sValue );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                     else
                         pInfo->SetHlink( sValue );
-#endif
                 }
             }
         }
@@ -1428,19 +1438,6 @@ public:
                 aProperties[ 1 ].Value <<= pInfo->GetMacro();
             }
         }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        else if( aName == SC_EVENTACC_ONACTION )
-        {
-            if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
-            {
-                aProperties.realloc( 2 );
-                aProperties[ 0 ].Name = SC_EVENTACC_EVENTTYPE;
-                aProperties[ 0 ].Value <<= SC_EVENTACC_ACTION;
-                aProperties[ 1 ].Name = SC_EVENTACC_URL;
-                aProperties[ 1 ].Value <<= pInfo->GetHlink();
-            }
-        }
-#endif
         else
         {
             throw container::NoSuchElementException();
@@ -1451,25 +1448,14 @@ public:
 
     virtual uno::Sequence< rtl::OUString > SAL_CALL getElementNames() throw(uno::RuntimeException)
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        uno::Sequence< rtl::OUString > aSeq( 2 );
-#else
         uno::Sequence< rtl::OUString > aSeq( 1 );
-#endif
         aSeq[ 0 ] = SC_EVENTACC_ONCLICK;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        aSeq[ 1 ] = SC_EVENTACC_ONACTION;
-#endif
         return aSeq;
     }
 
     virtual sal_Bool SAL_CALL hasByName( const rtl::OUString& aName ) throw(uno::RuntimeException)
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        return (aName == SC_EVENTACC_ONCLICK) || (aName == SC_EVENTACC_ONACTION);
-#else
         return aName == SC_EVENTACC_ONCLICK;
-#endif
     }
 
     // XElementAccess
--- sc/source/ui/unoobj/viewuno.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/unoobj/viewuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -71,9 +71,13 @@
 #include "gridwin.hxx"
 #include <com/sun/star/view/DocumentZoomType.hpp>
 #include "AccessibilityHints.hxx"
+#include <com/sun/star/awt/MouseButton.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 #include <svx/sdrhittesthelper.hxx>
 
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -459,6 +463,78 @@ void SAL_CALL ScViewPaneObj::release() t
     OWeakObject::release();
 }
 
+// To process sheet compatibile event
+typedef ::cppu::WeakImplHelper2< awt::XEnhancedMouseClickHandler, view::XSelectionChangeListener > TabViewEventListener_BASE;
+class ScTabViewEventListener: public TabViewEventListener_BASE
+{
+private:
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper;
+    ScTabViewObj* pViewObj;
+    
+public:
+    ScTabViewEventListener( ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper);
+    ~ScTabViewEventListener();
+	// XEnhancedMouseClickHandler
+	virtual sal_Bool SAL_CALL mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+	virtual sal_Bool SAL_CALL mouseReleased( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+
+    // XSelectionChangeListener
+    virtual void SAL_CALL selectionChanged( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XEventListener
+	virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+
+ScTabViewEventListener::ScTabViewEventListener(ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper):
+                        pViewObj( pObj ),xVbaEventsHelper( rVbaEventsHelper )
+{
+}
+
+ScTabViewEventListener::~ScTabViewEventListener()
+{
+}
+
+void SAL_CALL ScTabViewEventListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException)
+{
+	sal_Bool result =  sal_False;
+    // process BeforeDoubleClick and BeforeRightClick events
+	if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+	{
+		// ensure the target is a cell
+        uno::Reference< table::XCell > xCell( e.Target, uno::UNO_QUERY );
+		if( xCell.is() && xVbaEventsHelper.is() && pViewObj)
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] = pViewObj->getSelection();
+			sal_Int32 nEventId = VBAEVENT_WORKSHEET_BEFORERIGHTCLICK;
+			if( e.ClickCount == 2 )
+				nEventId = VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK;
+            
+            result = xVbaEventsHelper->ProcessCompatibleVbaEvent( nEventId, aArgs );
+			// TODO: process Cancel argument	
+		}
+	}
+	return result;
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mouseReleased( const awt::EnhancedMouseEvent&/*e*/) throw (uno::RuntimeException)
+{
+	return sal_False;
+}
+
+void SAL_CALL ScTabViewEventListener::selectionChanged( const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+	if ( xVbaEventsHelper.is() && pViewObj)
+	{
+	    uno::Sequence< uno::Any > aArgs(1);
+	    aArgs[0] = pViewObj->getSelection();
+	    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_SELECTIONCHANGE, aArgs );
+	}
+}
+
 //------------------------------------------------------------------------
 
 //	Default-ctor wird fuer SMART_REFLECTION_IMPLEMENTATION gebraucht
@@ -469,7 +545,8 @@ void SAL_CALL ScViewPaneObj::release() t
 //UNUSED2008-05  aPropSet( lcl_GetViewOptPropertyMap() ),
 //UNUSED2008-05  aMouseClickHandlers( 0 ),
 //UNUSED2008-05  aActivationListeners( 0 ),
-//UNUSED2008-05  bDrawSelModeSet(sal_False)
+//UNUSED2008-05  bDrawSelModeSet(sal_False),
+//UNUSED2008-05  bFilteredRangeSelection(sal_True)
 //UNUSED2008-05  {
 //UNUSED2008-05  }
 
@@ -479,9 +556,22 @@ ScTabViewObj::ScTabViewObj( ScTabViewShe
     aPropSet( lcl_GetViewOptPropertyMap() ),
     aMouseClickHandlers( 0 ),
     aActivationListeners( 0 ),
-    bDrawSelModeSet(sal_False)
+	bDrawSelModeSet(sal_False),
+    bFilteredRangeSelection(sal_True)
 {
-    //!	Listening oder so
+	if( pViewSh )
+	{
+		ScViewData* pViewData = pViewSh->GetViewData();
+		if( pViewData )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper (pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+			ScTabViewEventListener* pEventListener = new ScTabViewEventListener( this, xVbaEventsHelper );
+			uno::Reference< awt::XEnhancedMouseClickHandler > aMouseClickHandler( *pEventListener, uno::UNO_QUERY );
+			addEnhancedMouseClickHandler( aMouseClickHandler );
+            uno::Reference< view::XSelectionChangeListener > aSelectionChangeListener( *pEventListener, uno::UNO_QUERY );
+            addSelectionChangeListener( aSelectionChangeListener );
+		}
+	}
 }
 
 ScTabViewObj::~ScTabViewObj()
@@ -884,6 +974,15 @@ uno::Any SAL_CALL ScTabViewObj::getSelec
 
         ScRange aRange;
         ScMarkType eMarkType = pViewData->GetSimpleArea(aRange);
+
+        if (!bFilteredRangeSelection)
+        {
+            if (eMarkType == SC_MARK_SIMPLE_FILTERED)
+                eMarkType = SC_MARK_SIMPLE;
+            else if (eMarkType == SC_MARK_FILTERED)
+                eMarkType = SC_MARK_MULTI;
+        }
+
         if ( nTabs == 1 && (eMarkType == SC_MARK_SIMPLE) )
         {
             if (aRange.aStart == aRange.aEnd)
@@ -1729,6 +1828,12 @@ void SAL_CALL ScTabViewObj::setPropertyV
     ScUnoGuard aGuard;
     String aString(aPropertyName);
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        bFilteredRangeSelection = ScUnoHelpFunctions::GetBoolFromAny(aValue);
+        return;
+    }
+
     ScTabViewShell* pViewSh = GetViewShell();
     if (pViewSh)
     {
@@ -1849,6 +1954,12 @@ uno::Any SAL_CALL ScTabViewObj::getPrope
     String aString(aPropertyName);
     uno::Any aRet;
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        ScUnoHelpFunctions::SetBoolInAny(aRet, bFilteredRangeSelection);
+        return aRet;
+    }
+
     ScTabViewShell* pViewSh = GetViewShell();
     if (pViewSh)
     {
--- sc/source/ui/vba/excelvbahelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/excelvbahelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -44,6 +44,55 @@ namespace vba
 {
 namespace excel
 {
+
+
+uno::Reference< sheet::XDatabaseRanges > 
+GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
+{
+    uno::Reference< frame::XModel > xModel;
+    if ( pShell )
+        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
+    return xDBRanges;
+}
+
+// returns the XDatabaseRange for the autofilter on sheet (nSheet)
+// also populates sName with the name of range
+uno::Reference< sheet::XDatabaseRange > 
+GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XIndexAccess > xIndexAccess( GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
+    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
+    table::CellRangeAddress dbAddress;
+    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
+    {
+        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
+        // autofilters work weirdly with openoffice, unnamed is the default 
+        // named range which is used to create an autofilter, but
+        // its also possible that another name could be used
+        //     this also causes problems when an autofilter is created on
+        //     another sheet
+        // ( but.. you can use any named range )
+        dbAddress = xDBRange->getDataArea();
+        if ( dbAddress.Sheet == nSheet )
+        {
+            sal_Bool bHasAuto = sal_False;
+            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
+            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
+            if ( bHasAuto )
+            {
+                sName = xNamed->getName();	
+                xDataBaseRange=xDBRange;
+                break;
+            }
+        }
+    }
+    return xDataBaseRange;
+} 
+
+
 void implSetZoom( const uno::Reference< frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs )
 {
     ScTabViewShell* pViewSh = excel::getBestViewShell( xModel );
@@ -217,6 +266,7 @@ ScVbaCellRangeAccess::GetDataSet( ScCell
 	return pDataSet;
 	
 }
+
 } //excel
 } //vba 
 } //ooo 
--- sc/source/ui/vba/excelvbahelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/excelvbahelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,6 +32,8 @@
 
 #include<vbahelper/vbahelper.hxx>
 #include <docsh.hxx>
+#include <com/sun/star/sheet/XDatabaseRanges.hpp>
+#include <com/sun/star/sheet/XDatabaseRange.hpp>
 
 class ScCellRangeObj;
 
@@ -51,6 +53,10 @@ namespace ooo
 		ScDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
 		ScTabViewShell* getCurrentBestViewShell( const css::uno::Reference< css::uno::XComponentContext >& xContext );
 		SfxViewFrame* getViewFrame( const css::uno::Reference< css::frame::XModel >& xModel );
+
+                css::uno::Reference< css::sheet::XDatabaseRanges > GetDataBaseRanges( ScDocShell* pShell ) throw ( css::uno::RuntimeException );
+
+                css::uno::Reference< css::sheet::XDatabaseRange > GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( css::uno::RuntimeException );
             class ScVbaCellRangeAccess
             {
             public:
--- sc/source/ui/vba/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -35,7 +35,7 @@ PRJNAME=sc
 TARGET=vbaobj
 ENABLE_EXCEPTIONS=TRUE
 VISIBILITY_HIDDEN=TRUE
-
+CDEFS+=-DVBA_OOBUILD_HACK
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :  settings.mk
@@ -54,6 +54,7 @@ SLOFILES= \
         $(SLO)$/vbaglobals.obj \
         $(SLO)$/vbaworkbook.obj \
         $(SLO)$/vbaworksheets.obj \
+		$(SLO)$/vbafiledialog.obj \
         $(SLO)$/vbaapplication.obj \
         $(SLO)$/vbarange.obj \
         $(SLO)$/vbaname.obj \
@@ -68,6 +69,7 @@ SLOFILES= \
         $(SLO)$/vbainterior.obj\
         $(SLO)$/vbawsfunction.obj\
         $(SLO)$/vbawindow.obj\
+		$(SLO)$/vbaquerytable.obj \
         $(SLO)$/vbachart.obj\
         $(SLO)$/vbachartobject.obj\
         $(SLO)$/vbachartobjects.obj\
@@ -99,11 +101,21 @@ SLOFILES= \
                 $(SLO)$/vbastyle.obj \
                 $(SLO)$/vbastyles.obj \
                 $(SLO)$/vbaassistant.obj \
+                $(SLO)$/vbafilesearch.obj \
                 $(SLO)$/vbahyperlink.obj \
                 $(SLO)$/vbapagesetup.obj \
                 $(SLO)$/vbapagebreak.obj \
                 $(SLO)$/vbapagebreaks.obj \
-                $(SLO)$/service.obj
+				$(SLO)$/service.obj \
+		$(SLO)$/vbaeventshelper.obj \
+		$(SLO)$/vbamenubar.obj  \
+		$(SLO)$/vbamenubars.obj \
+		$(SLO)$/vbamenu.obj \
+		$(SLO)$/vbamenus.obj \
+		$(SLO)$/vbamenuitem.obj \
+		$(SLO)$/vbamenuitems.obj \
+		$(SLO)$/vbafiledialogselecteditems.obj \
+
 .ENDIF
 # --- Targets ------------------------------------------------------
 
--- sc/source/ui/vba/service.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/service.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -69,6 +69,10 @@ namespace application
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
 namespace textframe 
 {
 extern sdecl::ServiceDecl const serviceDecl;
@@ -90,7 +94,7 @@ extern "C"
 #if 0
     // Component registration
         if ( component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) )
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl ) )
         {
             // Singleton registration
             try
@@ -113,7 +117,7 @@ extern "C"
 #else
 	// Component registration
         return component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, textframe::serviceDecl );
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl, textframe::serviceDecl );
 #endif
 	
     }
@@ -125,8 +129,8 @@ extern "C"
         OSL_TRACE("In component_getFactory for %s", pImplName );
     void* pRet =  component_getFactoryHelper(
         	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl );
-     if( !pRet )
-        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, textframe::serviceDecl );
+    if( !pRet )
+        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl, textframe::serviceDecl );
     OSL_TRACE("Ret is 0x%x", pRet);
     return pRet;
     }
--- sc/source/ui/vba/testvba/TestDocuments/logs/unix/MiscOperatorTests.log.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/testvba/TestDocuments/logs/unix/MiscOperatorTests.log	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,30 @@
+Test run started : 12/05/2009 12:36:15
+----------------------------------------------------------------
+TestAddress
+ TEST START : TestAddress
+  ITEM Assertion OK : test1: res = Not ( A > B )
+  ITEM Assertion OK : test2: res = Not ( B > A )
+  ITEM Assertion OK : test3: res = Not ( D )
+  ITEM Assertion OK : test4: res = Not A
+  ITEM Assertion OK : test5: res = ( A > D )
+  ITEM Assertion OK : test6: res = ( D > A )
+  ITEM Assertion OK : test7: res = ( A < D )
+  ITEM Assertion OK : test8: res = ( D < A )
+  ITEM Assertion OK : test9: res = ( A >= D )
+  ITEM Assertion OK : test10: res = ( D >= A )
+  ITEM Assertion OK : test11: res = ( A <= D )
+  ITEM Assertion OK : test12: res = ( D <= A )
+  ITEM Assertion OK : test13: res = ( D = A )
+  ITEM Assertion OK : test14: res = ( A = D )
+  ITEM Assertion OK : test15: res = ( D <> A )
+  ITEM Assertion OK : test16: res = ( A <> D )
+  ITEM Assertion OK : test17: ( A = D ) = True 
+Test Results
+============
+
+Tests passed: 17
+Tests failed: 0
+
+END 'TestAddress
+ TEST OK : TestAddress
+Test run finished : 12/05/2009 12:36:15
--- sc/source/ui/vba/testvba/testvba.cxx.old	2009-10-07 15:06:15.000000000 +0200
+++ sc/source/ui/vba/testvba/testvba.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -159,15 +159,15 @@ mxCompLoader( _xCompLoader ), msOutDirPa
                         Reference< script::provider::XScript > xScript;
                         try
                         {
-                            xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.TestMacros.Main?language=Basic&location=document" ));
+						    xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.TestMacros.Main?language=Basic&location=document" ));
                         } catch ( uno::Exception& e )
                         {
                             try
                             {
-                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMacro.Main?language=Basic&location=document" ));
+						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMacro.Main?language=Basic&location=document" ));
                             } catch ( uno::Exception& e2 )
                             {
-                                xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMain.Main?language=Basic&location=document" ));
+						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMain.Main?language=Basic&location=document" ));
                             }
                         }
                         OSL_TRACE("Got script for doc %s", rtl::OUStringToOString( sUrl, RTL_TEXTENCODING_UTF8 ).getStr() );
--- sc/source/ui/vba/vbaapplication.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaapplication.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -43,6 +43,9 @@
 #include <ooo/vba/excel/XlMousePointer.hpp>
 #include <com/sun/star/sheet/XNamedRanges.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker.hpp>
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#include<ooo/vba/XCommandBars.hpp>
 
 #include "vbaapplication.hxx"
 #include "vbaworkbooks.hxx"
@@ -54,13 +57,16 @@
 #include "vbawindow.hxx"
 #include "vbawindows.hxx"
 #include "vbaglobals.hxx"
+#include "vbamenubars.hxx"
 #include "tabvwsh.hxx"
 #include "gridwin.hxx"
 #include "vbanames.hxx"
 #include <vbahelper/vbashape.hxx>
 #include "vbatextboxshape.hxx"
 #include "vbaassistant.hxx"
+#include "vbafilesearch.hxx" //liuchen 2009-8-18, add the support of VBA Application.FileSearch
 #include "sc.hrc"
+#include "macromgr.hxx"
 
 #include <osl/file.hxx>
 
@@ -69,6 +75,8 @@
 #include <sfx2/viewfrm.hxx>
 #include <sfx2/app.hxx>
 
+#include <comphelper/processfactory.hxx>
+
 #include <toolkit/awt/vclxwindow.hxx>
 #include <toolkit/helper/vclunohelper.hxx>
 
@@ -83,13 +91,26 @@
 
 #include "convuno.hxx"
 #include "cellsuno.hxx"
+#include "miscuno.hxx"
+#include "unonames.hxx"
 #include "docsh.hxx"
 #include <vbahelper/helperdecl.hxx>
 #include "excelvbahelper.hxx"
 
-
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
+//limingl 2009-07-20
+#include "vbafiledialog.hxx"
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::rtl::OUString;
 
 // Enable our own join detection for Intersection and Union
 // should be more efficient than using ScRangeList::Join ( because
@@ -147,16 +168,49 @@ ScVbaApplication::getAssistant() throw (
     return uno::Reference< XAssistant >( new ScVbaAssistant( this, mxContext ) );
 }
 
+//liuchen 2009-8-18, add support of VBA Application.FileSearch
+uno::Reference< XFileSearch > SAL_CALL
+ScVbaApplication::getFileSearch() throw (uno::RuntimeException)
+{
+	if (! m_xFileSearch.get() )
+	{
+		m_xFileSearch = uno::Reference< XFileSearch >( new ScVbaFileSearch( ) );
+	}
+	
+    return m_xFileSearch;
+}
+//liuchen
+
 uno::Any SAL_CALL
 ScVbaApplication::getSelection() throw (uno::RuntimeException)
 {
     OSL_TRACE("** ScVbaApplication::getSelection() ** ");
     uno::Reference< frame::XModel > xModel( getCurrentDocument() );
-    uno::Reference< lang::XServiceInfo > xServiceInfo( xModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
-    rtl::OUString sImpementaionName = xServiceInfo->getImplementationName();
-    if( sImpementaionName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+
+    Reference< view::XSelectionSupplier > xSelSupp( xModel->getCurrentController(), UNO_QUERY_THROW );
+    Reference< beans::XPropertySet > xPropSet( xSelSupp, UNO_QUERY_THROW );
+    OUString aPropName = OUString::createFromAscii( SC_UNO_FILTERED_RANGE_SELECTION );
+    uno::Any aOldVal = xPropSet->getPropertyValue( aPropName );
+    uno::Any any;
+    any <<= sal_False;
+    xPropSet->setPropertyValue( aPropName, any );
+    uno::Reference< uno::XInterface > aSelection = ScUnoHelpFunctions::AnyToInterface(
+        xSelSupp->getSelection() );
+    xPropSet->setPropertyValue( aPropName, aOldVal );
+
+    if (!aSelection.is())
     {
-        uno::Reference< drawing::XShapes > xShapes( xModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
+        throw uno::RuntimeException( 
+            rtl::OUString::createFromAscii("failed to obtain current selection"), 
+            uno::Reference< uno::XInterface >() );
+    }
+
+    uno::Reference< lang::XServiceInfo > xServiceInfo( aSelection, uno::UNO_QUERY_THROW );
+    rtl::OUString sImplementationName = xServiceInfo->getImplementationName();
+
+    if( sImplementationName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+    {
+        uno::Reference< drawing::XShapes > xShapes( aSelection, uno::UNO_QUERY_THROW );
         uno::Reference< container::XIndexAccess > xIndexAccess( xShapes, uno::UNO_QUERY_THROW );
         uno::Reference< drawing::XShape > xShape( xIndexAccess->getByIndex(0), uno::UNO_QUERY_THROW );
     // if ScVbaShape::getType( xShape ) == office::MsoShapeType::msoAutoShape
@@ -175,10 +229,10 @@ ScVbaApplication::getSelection() throw (
     else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRange")) ||
              xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRanges")))
     {
-        uno::Reference< table::XCellRange > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	    uno::Reference< table::XCellRange > xRange( aSelection, ::uno::UNO_QUERY);
         if ( !xRange.is() )
         {
-            uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+		    uno::Reference< sheet::XSheetCellRangeContainer > xRanges( aSelection, ::uno::UNO_QUERY);
             if ( xRanges.is() )
                 return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( this, mxContext, xRanges ) ) );
 
@@ -187,7 +241,7 @@ ScVbaApplication::getSelection() throw (
     }
     else
     {
-        throw uno::RuntimeException( sImpementaionName + rtl::OUString::createFromAscii(" donot be surpported"), uno::Reference< uno::XInterface >() );
+        throw uno::RuntimeException( sImplementationName + rtl::OUString::createFromAscii(" not surpported"), uno::Reference< uno::XInterface >() );
     }
 }
 
@@ -628,6 +682,33 @@ ScVbaApplication::getDisplayAlerts() thr
 {
     return sal_True;
 }
+
+//VBA by minz@cn.ibm.com. Add Application.EnableEvents.
+void SAL_CALL
+ScVbaApplication::setEnableEvents(sal_Bool /*bEnable*/) throw (uno::RuntimeException)
+{
+	//TODO.
+}
+
+sal_Bool SAL_CALL
+ScVbaApplication::getEnableEvents() throw (uno::RuntimeException)
+{
+	//TODO.
+	return sal_True;
+}
+
+sal_Bool SAL_CALL
+ScVbaApplication::getVisible() throw (uno::RuntimeException)
+{
+	sal_Bool bVisible = sal_True;	
+	return bVisible;
+}
+
+void SAL_CALL
+ScVbaApplication::setVisible(sal_Bool bVisible) throw (uno::RuntimeException)
+{
+}
+
 void SAL_CALL
 ScVbaApplication::Calculate() throw(  script::BasicErrorException , uno::RuntimeException )
 {
@@ -1084,13 +1165,19 @@ ScVbaApplication::Volatile( const uno::A
 {
     sal_Bool bVolatile = sal_True;
     aVolatile >>= bVolatile;
+    SbMethod* pMeth = StarBASIC::GetActiveMethod();
+    if ( pMeth )
+    {
+        OSL_TRACE("ScVbaApplication::Volatile() In method ->%s<-", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+        uno::Reference< frame::XModel > xModel( getCurrentDocument() );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        pDoc->GetMacroManager()->SetUserFuncVolatile( pMeth->GetName(), bVolatile);
+    }
+
+// this is bound to break when loading the document
     return; 
 }
 
-void SAL_CALL
-ScVbaApplication::DoEvents() throw ( uno::RuntimeException )
-{
-}
 ::sal_Bool SAL_CALL 
 ScVbaApplication::getDisplayFormulaBar() throw ( css::uno::RuntimeException )
 {
@@ -1142,12 +1229,77 @@ ScVbaApplication::Caller( const uno::Any
 	return aRet;
 }
 
+//Add by minz@cn.ibm.com. 2009-07-08.
+uno::Any SAL_CALL 
+ScVbaApplication::GetOpenFilename(const uno::Any& FileFilter, const uno::Any& /*FilterIndex*/, const uno::Any& /*Title*/, const uno::Any& /*ButtonText*/, const uno::Any& /*MultiSelect*/)  throw (uno::RuntimeException)
+{
+	uno::Any aRet;	
+	try
+	{
+		//XubString aNewText;
+		::rtl::OUString aNewText;
+
+		const ::rtl::OUString sServiceName = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+
+		uno::Reference< lang::XMultiServiceFactory > xMSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+
+		// Set the type of File Picker Dialog: TemplateDescription::FILEOPEN_SIMPLE.
+		uno::Sequence< uno::Any > aDialogType( 1 );
+		aDialogType[0] <<= ui::dialogs::TemplateDescription::FILEOPEN_SIMPLE;
+		uno::Reference< ui::dialogs::XFilePicker > xFilePicker( xMSF->createInstanceWithArguments( sServiceName, aDialogType ), UNO_QUERY );
+
+		if ( xFilePicker.is() && xFilePicker->execute() )
+		{
+			uno::Sequence < rtl::OUString > aPathSeq = xFilePicker->getFiles();
+
+			if ( aPathSeq.getLength() )
+			{
+				aNewText = aPathSeq[0];
+				INetURLObject aObj( aNewText );
+				if ( aObj.GetProtocol() == INET_PROT_FILE )
+					aNewText = aObj.PathToFileName();
+			}
+		}
+
+		aRet = uno::makeAny(aNewText);
+	}
+	catch( const uno::Exception& )
+	{
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());   
+		//throw uno::RuntimeException( rtl::OUString::createFromAscii( "invalid reference for range name, it should be procedure name" ),
+        //           uno::Reference< uno::XInterface >() );
+	}
+
+	return aRet;
+}
+
+//liming 2009-7-17
+::com::sun::star::uno::Reference< ::ooo::vba::XFileDialog > SAL_CALL 
+ScVbaApplication::getFileDialog() throw (::com::sun::star::uno::RuntimeException)
+{	
+	uno::Reference< XFileDialog > xFileDialogs( new ScVbaFileDialog( uno::Reference< XHelperInterface >( this ), mxContext, getCurrentDocument() ) );
+	return  xFileDialogs;
+}
+
 uno::Reference< frame::XModel > 
 ScVbaApplication::getCurrentDocument() throw (css::uno::RuntimeException)
 {
     return getCurrentExcelDoc(mxContext);
 }
 
+uno::Any SAL_CALL
+ScVbaApplication::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCommandBars > xCommandBars( CommandBars( uno::Any() ), uno::UNO_QUERY_THROW );
+	uno::Reference< XCollection > xMenuBars( new ScVbaMenuBars( this, mxContext, xCommandBars ) );
+	if (  aIndex.hasValue() )
+	{
+	    return uno::Any ( xMenuBars->Item( aIndex, uno::Any() ) );
+	}
+
+	return uno::Any( xMenuBars );
+}
+
 rtl::OUString& 
 ScVbaApplication::getServiceImplName()
 {
--- sc/source/ui/vba/vbaapplication.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaapplication.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,6 +47,7 @@ class ScVbaApplication : public ScVbaApp
 private:
     sal_Int32 m_xCalculation;
     rtl::OUString getOfficePath( const rtl::OUString& sPath ) throw ( css::uno::RuntimeException );
+	css::uno::Reference< ov::XFileSearch > m_xFileSearch; //
 protected:
         virtual css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException);
 public:
@@ -76,6 +77,7 @@ public:
     virtual void SAL_CALL setDisplayFormulaBar( ::sal_Bool _displayformulabar ) throw ( css::uno::RuntimeException );
 
     virtual css::uno::Reference< ov::XAssistant > SAL_CALL getAssistant() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::XFileSearch > SAL_CALL getFileSearch() throw (css::uno::RuntimeException); //liuchen 2009-8-18 add the support of Application.FileSearch
     virtual css::uno::Reference< ov::excel::XWorkbook > SAL_CALL getThisWorkbook() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Workbooks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
@@ -88,6 +90,12 @@ public:
     virtual void SAL_CALL setStatusBar( const css::uno::Any& _statusbar ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getCursor() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCursor( ::sal_Int32 _cursor ) throw (css::uno::RuntimeException);
+	
+	virtual sal_Bool SAL_CALL getEnableEvents() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setEnableEvents( sal_Bool bEnable ) throw (css::uno::RuntimeException);
+
+	virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool bVisible ) throw (css::uno::RuntimeException);
 
     virtual double SAL_CALL CountA( const css::uno::Any& arg1 ) throw (css::uno::RuntimeException) ;
 
@@ -100,8 +108,11 @@ public:
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual void SAL_CALL Volatile( const css::uno::Any& Volatile ) throw (css::uno::RuntimeException );
-    virtual void SAL_CALL DoEvents() throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Caller( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL GetOpenFilename( const css::uno::Any& FileFilter, const css::uno::Any& FilterIndex, const css::uno::Any& Title, const css::uno::Any& ButtonText, const css::uno::Any& MultiSelect ) throw (css::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Reference< ::ooo::vba::XFileDialog > SAL_CALL getFileDialog() throw (::com::sun::star::uno::RuntimeException); //liminl 2009-08-12 add
+	
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- sc/source/ui/vba/vbacomment.cxx.old	2009-10-07 15:06:15.000000000 +0200
+++ sc/source/ui/vba/vbacomment.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -34,6 +34,7 @@
 #include <com/sun/star/sheet/XSheetAnnotationAnchor.hpp>
 #include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/table/XCell.hpp>
 #include <com/sun/star/text/XText.hpp>
@@ -161,8 +162,7 @@ ScVbaComment::Text( const uno::Any& aTex
     aText >>= sText;
 
     uno::Reference< text::XSimpleText > xAnnoText( getAnnotation(), uno::UNO_QUERY_THROW );
-    rtl::OUString sAnnoText = xAnnoText->getString();
-
+        
     if ( aStart.hasValue() )
     {
         sal_Int16 nStart = 0;
@@ -194,8 +194,13 @@ ScVbaComment::Text( const uno::Any& aTex
             throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaComment::Text - bad Start value " ) ), uno::Reference< uno::XInterface >() );
     }
     else if ( aText.hasValue() )
-        xAnnoText->setString( sText );
+	{
+		uno::Reference< sheet::XCellAddressable > xCellAddr(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+		table::CellAddress aAddress = xCellAddr->getCellAddress();
+		getAnnotations()->insertNew( aAddress, sText );
+	}
 
+	rtl::OUString sAnnoText = xAnnoText->getString();
     return sAnnoText;
 }
 
--- sc/source/ui/vba/vbadialog.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbadialog.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,42 +32,58 @@
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-static const rtl::OUString aStringList[]=
+//liuchen 2009-7-27 
+//solve the problem that "Application.Dialogs.Item(***).Show" and "Application.Dialogs.Count" cannot get the correct result
+struct DialogMatch
 {
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation") ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ),
-    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) )	
+	sal_Int32 		nVbaDlgIndex;
+	rtl::OUString	aOODlgName;
 };
 
-const sal_Int32 nDialogSize = sizeof( aStringList ) / sizeof( aStringList[ 0 ] );
+static const DialogMatch aDialogMatchList[] = 
+{
+	{ 1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ) },						// xlDialogOpen -> .uno:Open
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ) },			// ??? -> .uno:FormatCellDialog
+	{ 55, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ) },				// xlDialogInsert -> .uno:InsertCell
+	{ 8, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ) },						// xlDialogPrint -> .uno:Print
+	{ 9,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PrinterSetup" ) ) }, 				// xlDialogPrinterSetup -> .uno:PrinterSetup
+	{ 53, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ) },				// xlDialogPasteSpecial -> .uno:PasteSpecial
+	{ 28, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ) },	// xlDialogProtectDocument -> uno:ToolProtectionDocument
+	{ 47,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ) },				// xlDialogColumnWidth -> .uno:ColumnWidth
+	{ 61,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ) },				// xlDialogDefineName -> .uno:DefineName
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ) },			// ??? -> .uno:ConfigureDialog
+	{ 596, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ) },			// xlDialogInsertHyperlink -> .uno:HyperlinkDialog
+	{ 342,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ) },				// xlDialogInsertPicture -> .uno:InsertGraphic
+	{ 259, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ) },				// xlDialogInsertObject -> .uno:InsertObject
+	{ 7,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ) },			// xlDialogPageSetup -> .uno:PageFormatDialog
+	{ 39,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ) },					// xlDialogSort -> .uno:DataSort
+	{ 127, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ) },					// xlDialogRowHeight -> .uno:RowHeight
+	{ 485,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ) },			// xlDialogAutoCorrect -> .uno:AutoCorrectDlg
+	{ 583, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ) },	// xlDialogCondiationalFormatting -> .uno:ConditionalFormatDialog
+	{ 191,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ) },			// xlDialogConsolidate -> .uno:DataConsolidate
+	{ 62,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ) },				// xlDialogCreateNames -> .uno:CreateNames
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ) },				// ??? -> .uno:FillSeries
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation" ) ) },				// ??? -> .uno:Validation"
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ) },			// ??? -> .uno:DefineLabelRange
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ) },		// ??? -> .uno:DataFilterAutoFilter
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ) }, 	// ??? -> .uno:DataFilterSpecialFilter
+	{ 269,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) ) }					// xlDialogFormatAuto -> .uno:AutoFormat
+};
+
+const sal_Int32 nDialogSize = sizeof( aDialogMatchList ) / sizeof( aDialogMatchList[ 0 ] );
 
+//liuchen modified 2009-2-27
 rtl::OUString 
 ScVbaDialog::mapIndexToName( sal_Int32 nIndex )
 {
-    if( nIndex < nDialogSize )
-        return aStringList[ nIndex ];
+	for (int i = 0; i < nDialogSize; i++)
+	{
+		if ( aDialogMatchList[i].nVbaDlgIndex == nIndex )
+		{
+			return aDialogMatchList[i].aOODlgName;
+		}
+	}
+	
     return rtl::OUString();
 }
 
@@ -89,3 +105,9 @@ ScVbaDialog::getServiceNames()
     }
     return aServiceNames;
 }
+
+//liuchen add 2009-7-27
+sal_Int32 ScVbaDialog::GetSupportedDialogCount()
+{
+	return nDialogSize;
+}
\ No newline at end of file
--- sc/source/ui/vba/vbadialog.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbadialog.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,6 +48,9 @@ public:
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	//liuchen 2009-7-27
+	static sal_Int32 GetSupportedDialogCount();
 };
 
 #endif /* SC_VBA_DIALOG_HXX */
--- sc/source/ui/vba/vbadialogs.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbadialogs.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -67,5 +67,13 @@ ScVbaDialogs::getServiceNames()
     return aServiceNames;
 }
 
+//liuchen 2009-7-27
+::sal_Int32
+ScVbaDialogs::getCount() throw (uno::RuntimeException)
+{	
+	return ScVbaDialog::GetSupportedDialogCount();
+}
+
+
 
 
--- sc/source/ui/vba/vbadialogs.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbadialogs.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,6 +47,7 @@ public:
 
     // XCollection
     virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException); //liuchen 2009-7-27
 
     // XDialogs
     virtual void SAL_CALL Dummy() throw (css::uno::RuntimeException);
--- sc/source/ui/vba/vbaeventshelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbaeventshelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,1065 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include <vbahelper/helperdecl.hxx>
+#include <sfx2/objsh.hxx> 
+#include "scextopt.hxx"
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/table/XCell.hpp> 
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/util/XCloseListener.hpp>
+#include <com/sun/star/util/XCloseBroadcaster.hpp>
+#include <com/sun/star/frame/XControllerBorder.hpp>
+#include <com/sun/star/frame/XBorderResizeListener.hpp>
+#include <com/sun/star/util/XChangesListener.hpp>
+#include <com/sun/star/util/ElementChange.hpp>
+#include <com/sun/star/util/XChangesNotifier.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <cellsuno.hxx> 
+#include <convuno.hxx>
+#include <map>
+#include <svx/msvbahelper.hxx>
+#include <vcl/svapp.hxx>
+
+using namespace std;
+using namespace com::sun::star;
+using namespace ooo::vba;
+using namespace com::sun::star::document::VbaEventId;
+
+typedef ::cppu::WeakImplHelper1< util::XChangesListener > WorksheetChangeListener_BASE;
+
+class WorksheetChangeListener : public WorksheetChangeListener_BASE
+{
+private:
+    ScVbaEventsHelper* pVbaEventsHelper;
+public:
+    WorksheetChangeListener(ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper ){}
+    virtual void SAL_CALL changesOccurred(const util::ChangesEvent& aEvent) throw (uno::RuntimeException);
+    virtual void SAL_CALL disposing(const lang::EventObject& aSource) throw(uno::RuntimeException){}
+};
+
+void WorksheetChangeListener::changesOccurred(const util::ChangesEvent& aEvent) throw (uno::RuntimeException)
+{
+    sal_Int32 nCount = aEvent.Changes.getLength();
+    if( nCount == 0 )
+        return;
+    
+    util::ElementChange aChange = aEvent.Changes[ 0 ];
+    rtl::OUString sOperation;
+    aChange.Accessor >>= sOperation;
+    if( !sOperation.equalsIgnoreAsciiCaseAscii("cell-change") )
+        return;
+
+    if( nCount == 1 )
+    {
+        uno::Reference< table::XCellRange > xRangeObj;
+        aChange.ReplacedElement >>= xRangeObj;
+        if( xRangeObj.is() )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= xRangeObj;
+            pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CHANGE, aArgs );
+        }    
+        return;
+    }
+
+    ScRangeList aRangeList;
+    for( sal_Int32 nIndex = 0; nIndex < nCount; ++nIndex )
+    {
+        aChange = aEvent.Changes[ nIndex ];
+        aChange.Accessor >>= sOperation;
+        uno::Reference< table::XCellRange > xRangeObj;
+        aChange.ReplacedElement >>= xRangeObj;
+        if( xRangeObj.is() && sOperation.equalsIgnoreAsciiCaseAscii("cell-change") )
+        {
+            uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( xRangeObj, uno::UNO_QUERY );
+            if( xCellRangeAddressable.is() )
+            {
+                ScRange aRange;
+                ScUnoConversion::FillScRange( aRange, xCellRangeAddressable->getRangeAddress() );
+                aRangeList.Append( aRange );
+            }
+        }
+    }
+    
+    if( aRangeList.Count() > 0 )
+    {
+        uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pVbaEventsHelper->getDocumentShell(), aRangeList ) );
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] <<= xRanges;
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CHANGE, aArgs );
+    }
+}
+
+typedef ::cppu::WeakImplHelper3< awt::XWindowListener, util::XCloseListener, frame::XBorderResizeListener > WindowListener_BASE;
+
+// This class is to process Workbook window related event
+class VbaEventsListener : public WindowListener_BASE
+{
+    ::osl::Mutex m_aMutex;
+    ScVbaEventsHelper* pVbaEventsHelper;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bWindowResized;
+    sal_Bool m_bBorderChanged;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    uno::Reference< frame::XFrame > GetFrame();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, void* );
+    void processWindowResizeMacro();
+public :
+    VbaEventsListener( ScVbaEventsHelper* pHelper );
+    ~VbaEventsListener();
+    void startEventsLinstener();
+    void stopEventsLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XCloseListener
+    virtual void SAL_CALL queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException);
+    virtual void SAL_CALL notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException);
+    // XBorderResizeListener
+    virtual void SAL_CALL borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException);
+};
+VbaEventsListener::VbaEventsListener( ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper )
+{
+    OSL_TRACE("VbaEventsListener::VbaEventsListener( 0x%x ) - ctor ", this );
+    m_xModel.set( pVbaEventsHelper->getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    m_bWindowResized = sal_False;
+    m_bBorderChanged = sal_False;
+}
+
+VbaEventsListener::~VbaEventsListener()
+{
+    OSL_TRACE("VbaEventsListener::~VbaEventsListener( 0x%x ) - dtor ", this );
+}
+uno::Reference< frame::XFrame > 
+VbaEventsListener::GetFrame()
+{
+    try
+    {
+        if( pVbaEventsHelper )
+        {
+            if( m_xModel.is() )
+            {
+                uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+                if( xController.is() )
+                {
+                    uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY );
+                    if( xFrame.is() )
+                    {
+                            return xFrame;
+                    }
+                }
+            }
+        }
+    }
+	catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< frame::XFrame >();
+}
+uno::Reference< awt::XWindow > 
+VbaEventsListener::GetContainerWindow() 
+{
+    try
+    {
+        uno::Reference< frame::XFrame > xFrame( GetFrame(), uno::UNO_QUERY );
+        if( xFrame.is() )
+        {
+            uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY );
+            if( xWindow.is() )
+                return xWindow;
+        }
+    }
+	catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaEventsListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaEventsListener::startEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        // add window listener
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+            xWindow->addWindowListener( this );
+        // add close listener
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->addCloseListener( this );
+        }
+        // add Border resize listener
+        try
+        {
+            uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+            if( xController.is() )
+            {
+                uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+                if( xControllerBorder.is() )
+                {
+                    xControllerBorder->addBorderResizeListener( this );
+                }
+            }
+        }
+        catch( uno::Exception& e) {} // Disposed already most likely
+    }
+}
+void
+VbaEventsListener::stopEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+        {
+            xWindow->removeWindowListener( this );
+        }
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->removeCloseListener( this );
+        }
+        try
+        {
+            uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+            if( xController.is() )
+            {
+                uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+                if( xControllerBorder.is() )
+                {
+                    xControllerBorder->removeBorderResizeListener( this );
+                }
+            }
+        }
+        catch ( uno::Exception& e ){}      
+    }
+    pVbaEventsHelper = NULL;
+}
+
+void
+VbaEventsListener::processWindowResizeMacro()
+{
+    OSL_TRACE("**** Attempt to FIRE MACRO **** ");
+    if( pVbaEventsHelper )
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWRESIZE, uno::Sequence< uno::Any >() );
+}
+
+IMPL_LINK( VbaEventsListener, fireResizeMacro, void*, pParam )
+{
+    if ( pVbaEventsHelper ) 
+    {
+        if( IsMouseReleased() )
+                processWindowResizeMacro();
+    }
+    release();
+    return 0;
+}
+
+void SAL_CALL
+VbaEventsListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    // Workbook_window_resize event
+    m_bWindowResized = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+
+    if( pWindow && m_bBorderChanged )
+    {
+        m_bBorderChanged = m_bWindowResized = sal_False;
+        acquire(); // ensure we don't get deleted before the event is handled
+        Application::PostUserEvent( LINK( this, VbaEventsListener, fireResizeMacro ), NULL );
+    }
+}
+void SAL_CALL
+VbaEventsListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    OSL_TRACE("VbaEventsListener::disposing(0x%x)", this);
+    pVbaEventsHelper = NULL;
+}
+void SAL_CALL 
+VbaEventsListener::queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException)
+{
+     // it can cancel the close, but need to throw a CloseVetoException, and it will be transmit to caller.
+}
+void SAL_CALL 
+VbaEventsListener::notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    stopEventsLinstener();
+}
+void SAL_CALL 
+VbaEventsListener::borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    // work with WindowResized event to guard Window Resize event.
+    m_bBorderChanged = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && m_bWindowResized )
+    {
+        m_bWindowResized = m_bBorderChanged = sal_False;
+        acquire(); // ensure we don't get deleted before the timer fires.
+        Application::PostUserEvent( LINK( this, VbaEventsListener, fireResizeMacro ), NULL );
+    }
+}
+
+ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext ) : VbaEventsHelperBase( xContext ), mbOpened( sal_False ), mbDocDisposed( false )
+{
+    Initilize();
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    pDocShell = excel::getDocShell( xModel );
+    pDoc = pDocShell->GetDocument();
+    // Add worksheet change listener
+    uno::Reference< util::XChangesNotifier > xChangesNotifier( xModel, uno::UNO_QUERY );
+    if( xChangesNotifier.is() )
+        xChangesNotifier->addChangesListener( uno::Reference< util::XChangesListener >( new WorksheetChangeListener( this ) ) );
+    if ( xModel.is() )
+    {
+        uno::Reference< lang::XComponent > xComponent( xModel, uno::UNO_QUERY );
+        if ( xComponent.is() )
+        {
+            xComponent->addEventListener( this );
+        }
+    }
+}
+
+ScVbaEventsHelper::~ScVbaEventsHelper()
+{
+    stopListening();
+}
+
+void ScVbaEventsHelper::stopListening()
+{
+    if ( mbDocDisposed )
+        return;
+    uno::Reference< frame::XModel > xModel( getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    if ( xModel.is() )
+    {
+        uno::Reference< lang::XComponent > xComponent( xModel, uno::UNO_QUERY );
+        if ( xComponent.is() )
+        {
+            try
+            {
+               xComponent->removeEventListener( this );
+            }
+            catch( uno::Exception& e ) {}
+        }
+    }
+    if ( xModel.is() )
+    {
+        uno::Reference< lang::XComponent > xComponent( xModel, uno::UNO_QUERY );
+        if ( xComponent.is() )
+        {
+            xComponent->addEventListener( this );
+        }
+    }
+}
+
+#define CREATEOUSTRING(asciistr) rtl::OUString::createFromAscii(asciistr)
+
+#define INSERT_EVENT_INFO( Object, Event, ObjectName, EventName ) \
+        insert( VBAEVENT_##Object##_##Event, ObjectName + CREATEOUSTRING( EventName ) )
+
+#define INSERT_WORKSHEET_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO( WORKSHEET, Event,CREATEOUSTRING("Worksheet_"), EventName ); \
+        INSERT_EVENT_INFO( WORKBOOK_SHEET, Event, CREATEOUSTRING("Workbook_Sheet"), EventName )
+
+#define INSERT_WORKBOOK_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO(  WORKBOOK, Event, CREATEOUSTRING("Workbook_"), EventName )
+
+void ScVbaEventsHelper::Initilize()
+{
+    INSERT_WORKSHEET_EVENT_INFO( ACTIVATE, "Activate");
+    INSERT_WORKSHEET_EVENT_INFO( BEFOREDOUBLECLICK, "BeforeDoubleClick" );
+    INSERT_WORKSHEET_EVENT_INFO( BEFORERIGHTCLICK, "BeforeRightClick" );
+    INSERT_WORKSHEET_EVENT_INFO( CALCULATE, "Calculate" );
+    INSERT_WORKSHEET_EVENT_INFO( CHANGE, "Change" );
+    INSERT_WORKSHEET_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKSHEET_EVENT_INFO( FOLLOWHYPERLINK, "FollowHyperlink" );
+    INSERT_WORKSHEET_EVENT_INFO( PIVOTTABLEUPDATE, "PivotTableUpdate" );
+    INSERT_WORKSHEET_EVENT_INFO( SELECTIONCHANGE, "SelectionChange" );
+
+    // Workbook
+    INSERT_WORKBOOK_EVENT_INFO( ACTIVATE, "Activate" );
+    INSERT_WORKBOOK_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( OPEN, "Open" );
+    // AUTOOPEN doesn't be used. TODO, this should be "auto_open"
+    insert( VBAEVENT_WORKBOOK_AUTOOPEN, CREATEOUSTRING("Auto_Open") );                       
+    INSERT_WORKBOOK_EVENT_INFO( BEFORECLOSE, "BeforeClose" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFOREPRINT, "BeforePrint" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFORESAVE, "BeforeSave" );
+    INSERT_WORKBOOK_EVENT_INFO( NEWSHEET, "NewSheet" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWACTIVATE, "WindowActivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWDEACTIVATE, "WindowDeactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWRESIZE, "WindowResize" );
+}
+
+uno::Any ScVbaEventsHelper::createWorkSheet( SfxObjectShell* pShell, SCTAB nTab )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		// Eventually we will be able to pull the Workbook/Worksheet objects
+		// directly from basic and register them as listeners
+
+		// create Workbook
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+		aArgs[1] = uno::Any( pShell->GetModel() );
+		uno::Reference< uno::XInterface > xWorkbook( ov::createVBAUnoAPIServiceWithArgs( pShell, "ooo.vba.excel.Workbook", aArgs ), uno::UNO_QUERY );
+
+		// create WorkSheet
+		String sSheetName;
+		pDoc->GetName( nTab, sSheetName );
+		aArgs = uno::Sequence< uno::Any >(3);
+		aArgs[ 0 ] <<= xWorkbook;
+		aArgs[ 1 ] <<= pShell->GetModel();
+		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+		aRet <<= ov::createVBAUnoAPIServiceWithArgs( pShell, "ooo.vba.excel.Worksheet", aArgs );
+	}
+	catch( uno::Exception& e )
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createRange( const uno::Any& aRange )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		if (  xRanges.is() || xRange.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			if ( xRanges.is() )
+			{
+				aArgs[1] <<= xRanges;
+			}
+			else if ( xRange.is() )
+			{
+				aArgs[1] <<= xRange;
+			}
+			else
+			{
+				throw uno::RuntimeException(); // 
+			}
+			aRet <<= ov::createVBAUnoAPIServiceWithArgs( pDoc->GetDocumentShell(), "ooo.vba.excel.Range", aArgs );	
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createHyperlink( const uno::Any& rCell )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW ); 
+		uno::Reference< table::XCell > xCell( rCell, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			aArgs[1] <<= rCell;
+			
+			aRet <<= ov::createVBAUnoAPIServiceWithArgs( pDoc->GetDocumentShell(), "ooo.vba.excel.Hyperlink", aArgs );	
+		}
+		else
+		{
+			throw uno::RuntimeException(); // 
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createWindow( SfxObjectShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+	catch( uno::Exception& e )
+	{
+	}
+    return uno::Any();
+}
+
+String ScVbaEventsHelper::getSheetModuleName( SCTAB nTab )
+{
+	ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+	String aCodeName;
+	pDoc->GetName( nTab, aCodeName);
+	// Use code name if that exists
+	if ( pExtOptions )
+		aCodeName = pExtOptions->GetCodeName( nTab );
+	return aCodeName;	
+}
+
+rtl::OUString
+ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    String sMacroName = getEventName( nEventId );
+    VBAMacroResolvedInfo sMacroResolvedInfo;
+    switch( nEventId )
+    {
+        // Worksheet
+    	case VBAEVENT_WORKSHEET_ACTIVATE                      :
+    	case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK             :
+    	case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK              :
+    	case VBAEVENT_WORKSHEET_CALCULATE                     :
+    	case VBAEVENT_WORKSHEET_CHANGE                        :
+    	case VBAEVENT_WORKSHEET_DEACTIVATE                    :
+    	case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK               :
+    	case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE              :
+    	case VBAEVENT_WORKSHEET_SELECTIONCHANGE               :
+        {
+            String  aSheetModuleName = getSheetModuleName( nTab );
+            sMacroName.Insert( '.', 0 ).Insert( aSheetModuleName, 0);
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+        // Workbook
+    	case VBAEVENT_WORKBOOK_ACTIVATE                       :
+    	case VBAEVENT_WORKBOOK_DEACTIVATE                     :
+    	case VBAEVENT_WORKBOOK_OPEN                           :
+    	case VBAEVENT_WORKBOOK_BEFORECLOSE                    :
+    	case VBAEVENT_WORKBOOK_BEFOREPRINT                    :
+    	case VBAEVENT_WORKBOOK_BEFORESAVE                     :
+    	case VBAEVENT_WORKBOOK_NEWSHEET                       :
+    	case VBAEVENT_WORKBOOK_WINDOWACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_WINDOWRESIZE                   :
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK        :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK         :
+    	case VBAEVENT_WORKBOOK_SHEET_CALCULATE                :
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE                   :
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK          :
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE         :
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE          :
+        {
+	        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+            String sWorkbookModuleName = pDoc->GetCodeName();
+            if( pExtOptions )
+            {
+                ScExtDocSettings aExtDocSettings = pExtOptions->GetDocSettings();
+                sWorkbookModuleName = aExtDocSettings.maGlobCodeName;
+            }
+           
+            sMacroName.Insert( '.', 0 ).Insert( sWorkbookModuleName, 0);
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_AUTOOPEN                       :
+        {
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+        default:
+            break;
+    }
+    return sMacroResolvedInfo.ResolvedMacro();
+}
+
+sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& rArgs, const SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+
+	sal_Bool result = sal_False;
+    sal_Bool bCancel = sal_False;
+	uno::Sequence< uno::Any > aArgs;
+	uno::Any aRet;
+	uno::Any aDummyCaller;
+    
+    // For most cases, there is no corresponsible event macro in the document. 
+    // It is better fo check if the event macro exists before process the arguments to improve performance.
+    rtl::OUString sMacroPath = getMacroPath( nEventId, nTab );
+	if( sMacroPath.getLength() )
+	{
+		switch( nEventId )
+		{
+			case VBAEVENT_WORKSHEET_ACTIVATE:
+			case VBAEVENT_WORKSHEET_CALCULATE:
+			case VBAEVENT_WORKSHEET_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_ACTIVATE:
+            case VBAEVENT_WORKBOOK_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_OPEN:
+    	    case VBAEVENT_WORKBOOK_AUTOOPEN:
+			{
+				// no arguments
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+            case VBAEVENT_WORKBOOK_NEWSHEET:
+            {
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = createWorkSheet( pShell, nTab ); 
+				break;
+            }
+			case VBAEVENT_WORKSHEET_CHANGE:
+			case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+			{
+				// one argument: range
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aRange;
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+    	    case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				break;
+            }
+			case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+			case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+			{
+				// two aruments: range and cancel
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = aRange;
+				aArgs[1] <<= bCancel;
+				// TODO: process "cancel" action  
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(3);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				aArgs[2] <<= bCancel;
+				// TODO: process "cancel" action  
+				break;
+            }
+			case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+			{
+				// one argument: hyperlink
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aHyperlink;
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+            {
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aHyperlink;
+				break;
+            }
+			case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+			{
+				// one argument: pivottable
+                // TODO: not support yet
+				return result;
+			}
+            case VBAEVENT_WORKBOOK_BEFORECLOSE:
+            case VBAEVENT_WORKBOOK_BEFOREPRINT:
+            {
+                // process Cancel argument
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                aArgs[0] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_BEFORESAVE:
+            {
+                // two arguments: SaveAs and Cancel
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = rArgs[0];
+                aArgs[1] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                aArgs[1] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+            {
+                // one argument: windows
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = createWindow( pShell );
+                break;
+            }
+            default:
+                return result;
+		}
+    
+        // excute the macro
+        result = executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+	}
+    
+	return result;
+}
+
+SCTAB ScVbaEventsHelper::getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos )
+{
+    SCTAB nTab = -1;
+    uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( getXSomethingFromArgs< sheet::XCellRangeAddressable >( aArgs, nPos ), uno::UNO_QUERY );
+    if( xCellRangeAddressable.is() )
+    {
+        table::CellRangeAddress aAddress = xCellRangeAddressable->getRangeAddress();
+        nTab = aAddress.Sheet;
+    }
+    else
+    {
+        uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getXSomethingFromArgs< sheet::XSheetCellRangeContainer >( aArgs, nPos ), uno::UNO_QUERY );
+        if( xRanges.is() )
+        {
+            uno::Sequence< table::CellRangeAddress > aRangeAddresses = xRanges->getRangeAddresses();
+            if( aRangeAddresses.getLength() > 0 )
+            {
+                nTab = aRangeAddresses[ 0 ].Sheet;
+            }
+        }
+    }
+    return nTab;
+}
+
+void
+ScVbaEventsHelper::disposing(const com::sun::star::lang::EventObject& aSource ) throw (com::sun::star::uno::RuntimeException)
+{
+    OSL_TRACE("ScVbaEventsHelper::disposing");
+    stopListening();
+    mbDocDisposed = true;
+}
+
+sal_Bool SAL_CALL 
+ScVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 nEventId, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell || mbIgnoreEvents || mbDocDisposed )
+		return sal_False;
+    
+    // In order to better support "withevents" in the future, 
+    // it is better to process a event at a time
+    SCTAB nTab = INVALID_TAB;
+    switch( nEventId )
+    {
+        // Worksheet
+		case VBAEVENT_WORKSHEET_ACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                // process the event
+                processVbaEvent( nEventId, aArgs, nTab );
+                // recursive process related workbook sheet event.
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_ACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CALCULATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CALCULATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CHANGE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_DEACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+            // TODO
+            break;
+		case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE, aArgs );
+            }
+            break;
+        }
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+        case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+        case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+        // TODO
+            break;
+		// Workbook
+		case VBAEVENT_WORKBOOK_ACTIVATE:
+        {
+            // if workbook open event do not be fired. fired it before 
+            // workbook activate event to compatible with MSO.
+            if( mbOpened )
+            {
+                // process workbook activate event
+                processVbaEvent( nEventId, aArgs );
+                // process workbook window activate event at the same time
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_DEACTIVATE:
+        {
+            processVbaEvent( nEventId, aArgs );
+            // same as workbook window deactivate
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWDEACTIVATE, aArgs );
+            break;
+        }
+		case VBAEVENT_WORKBOOK_OPEN:
+        {
+            // process workbook open macro
+            // does auto open work here?
+            if( !mbOpened )
+            {
+                processVbaEvent( nEventId, aArgs );
+                processVbaEvent( VBAEVENT_WORKBOOK_AUTOOPEN, aArgs );
+                mbOpened = sal_True;
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+            // register the window listener.
+            if( !m_xVbaEventsListener.is() )
+            {
+                m_xVbaEventsListener = new VbaEventsListener( this );
+                VbaEventsListener* pEventsListener = dynamic_cast< VbaEventsListener* >( m_xVbaEventsListener.get() );
+                pEventsListener->startEventsLinstener();
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_BEFORECLOSE:
+        {
+            sal_Bool bCancel = processVbaEvent( nEventId, aArgs ); 
+            if( m_xVbaEventsListener.is() && !bCancel )
+            {
+                VbaEventsListener* pEventsListener = dynamic_cast< VbaEventsListener* >( m_xVbaEventsListener.get() );
+                pEventsListener->stopEventsLinstener();
+                m_xVbaEventsListener = NULL;
+            }
+            return bCancel;
+        }
+		case VBAEVENT_WORKBOOK_BEFOREPRINT:
+		case VBAEVENT_WORKBOOK_BEFORESAVE:
+		case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+		case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+		case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+        {
+            return processVbaEvent( nEventId, aArgs );
+        }
+		case VBAEVENT_WORKBOOK_NEWSHEET:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaEventsHelper::getIgnoreEvents() throw (uno::RuntimeException)
+{
+    return VbaEventsHelperBase::getIgnoreEvents();
+}
+
+void SAL_CALL 
+ScVbaEventsHelper::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (uno::RuntimeException)
+{
+    VbaEventsHelperBase::setIgnoreEvents( _ignoreevents );
+}
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ScVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaEventsHelper",
+    "com.sun.star.sheet.SpreadsheetDocumentVbaEventsHelper" );
+}
--- sc/source/ui/vba/vbaeventshelper.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbaeventshelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_VBAEVENTS_HXX
+#define SC_VBAEVENTS_HXX
+
+#include "document.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbaeventshelperbase.hxx>
+
+#define INVALID_TAB -1
+
+typedef ::cppu::WeakImplHelper2< com::sun::star::document::XVbaEventsHelper, com::sun::star::lang::XEventListener > VBAWorkbookEvent_BASE;
+
+class VbaEventsListener;
+class ScDocShell;
+class ScVbaEventsHelper : public VBAWorkbookEvent_BASE, public VbaEventsHelperBase
+{
+friend class VbaEventsListener;
+private:
+	ScDocument* pDoc;
+	ScDocShell* pDocShell;
+    css::uno::Reference< css::awt::XWindowListener > m_xVbaEventsListener;
+    sal_Bool mbOpened;
+    sal_Bool mbDocDisposed;
+
+	String getSheetModuleName( SCTAB nTab );
+	css::uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+	css::uno::Any createRange( const css::uno::Any& aRange );
+	css::uno::Any createHyperlink( const css::uno::Any& rCell );
+	css::uno::Any createWindow( SfxObjectShell* pShell );
+    SCTAB getTabFromArgs( const css::uno::Sequence< css::uno::Any > aArgs, const sal_Int32 nPos = 0 );
+    rtl::OUString getMacroPath( const sal_Int32 nEventId, const SCTAB nTab = INVALID_TAB );
+    sal_Bool processVbaEvent( const sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& rArgs, const SCTAB nTab = INVALID_TAB );
+    void Initilize();
+    void stopListening();
+public:
+	//ScVbaEventsHelper( ScDocument* pDocument ):pDoc( pDocument ), mbOpened( sal_False ){};
+    ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~ScVbaEventsHelper();
+	ScDocument* getDocument() { return pDoc; };
+	ScDocShell* getDocumentShell() { return pDocShell; };
+    // XEventListener
+    virtual void SAL_CALL disposing(const css::lang::EventObject& aSource) throw(css::uno::RuntimeException);
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+};
+
+#endif
+
--- sc/source/ui/vba/vbafiledialog.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafiledialog.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,168 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#include "vbafiledialog.hxx"
+#include "comphelper/processfactory.hxx"
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker.hpp>
+#include <com/sun/star/ui/dialogs/XFilePicker2.hpp>
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#include "tools/urlobj.hxx"
+
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+
+ScVbaFileDialog::ScVbaFileDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel )
+:	ScVbaFileDialog_BASE( xParent, xContext, xModel )
+{	
+	m_pFileDialogSelectedItems = new VbaFileDialogSelectedItems(xParent, xContext, (com::sun::star::container::XIndexAccess *)&m_FileDialogSelectedObj);
+} 
+
+ScVbaFileDialog::~ScVbaFileDialog() 
+{
+	if (m_pFileDialogSelectedItems != NULL)
+	{
+		delete m_pFileDialogSelectedItems;
+	}
+}
+
+rtl::OUString& 
+ScVbaFileDialog::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFileDialog") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+ScVbaFileDialog::getServiceNames()
+{
+	static Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.FileDialog" ) );
+	}
+	return aServiceNames;
+
+}
+
+css::uno::Reference< ov::XFileDialogSelectedItems > SAL_CALL 
+ScVbaFileDialog::getSelectedItems() throw (css::uno::RuntimeException)
+{
+	css::uno::Reference< ov::XFileDialogSelectedItems > xFileDlgSlc = (ov::XFileDialogSelectedItems *)m_pFileDialogSelectedItems;
+	return xFileDlgSlc;
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaFileDialog::Show( ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	// Returns an Integer indicating if user pressed "Open" button(-1) or "Cancel" button(0).
+	sal_Int32 nResult = -1;
+	try
+	{
+		m_sSelectedItems.realloc(0);
+
+		const ::rtl::OUString sServiceName = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+
+		Reference< lang::XMultiServiceFactory > xMSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+		// Set the type of File Picker Dialog: TemplateDescription::FILEOPEN_SIMPLE.
+		Sequence< uno::Any > aDialogType( 1 );
+		aDialogType[0] <<= ui::dialogs::TemplateDescription::FILEOPEN_SIMPLE;
+		Reference < ui::dialogs::XFilePicker > xFilePicker( xMSF->createInstanceWithArguments( sServiceName, aDialogType ), UNO_QUERY );
+		Reference < ui::dialogs::XFilePicker2 > xFilePicker2( xFilePicker, UNO_QUERY );
+		if ( xFilePicker.is() )
+		{
+			xFilePicker->setMultiSelectionMode(sal_True);
+			if ( xFilePicker->execute() )
+			{
+				sal_Bool bUseXFilePicker2 = sal_False;
+				Reference< lang::XServiceInfo > xServiceInfo( xFilePicker, UNO_QUERY );
+				if (xServiceInfo.is())
+				{
+					rtl::OUString sImplName = xServiceInfo->getImplementationName();
+					if (sImplName.equalsAscii("com.sun.star.comp.fpicker.VistaFileDialog") || 
+						sImplName.equalsAscii("com.sun.star.ui.dialogs.SalGtkFilePicker"))
+					{
+						bUseXFilePicker2 = sal_True;
+					}
+				}
+				if ( bUseXFilePicker2 && xFilePicker2.is() )
+				{
+					// On Linux, XFilePicker->getFiles() always return one selected file although we select 
+					// more than one file, also on Vista XFilePicker->getFiles() does not work well too, 
+					// so we call XFilePicker2->getSelectedFiles() to get selected files.
+					m_sSelectedItems = xFilePicker2->getSelectedFiles();
+				}
+				else
+				{
+					// If only one file is selected, the first entry of the sequence contains the complete path/filename in 
+					// URL format. If multiple files are selected, the first entry of the sequence contains the path in URL 
+					// format, and the other entries contains the names of the selected files without path information.
+					Sequence< rtl::OUString > aSelectedFiles = xFilePicker->getFiles();
+					sal_Int32 iFileCount = aSelectedFiles.getLength();
+					if ( iFileCount > 1 )
+					{
+						m_sSelectedItems.realloc( iFileCount - 1 );
+						INetURLObject aPath( aSelectedFiles[0] );
+						aPath.setFinalSlash();
+						for ( sal_Int32 i = 1; i < iFileCount; i++ )
+						{
+							if ( aSelectedFiles[i].indexOf ('/') > 0 || aSelectedFiles[i].indexOf ('\\') > 0 )
+							{
+								m_sSelectedItems[i - 1] = aSelectedFiles[i];
+							}
+							else
+							{
+								if ( i == 1 )
+									aPath.Append( aSelectedFiles[i] );
+								else
+									aPath.setName( aSelectedFiles[i] );
+								m_sSelectedItems[i - 1] = aPath.GetMainURL(INetURLObject::NO_DECODE);
+							}
+						}
+					}
+					else if ( iFileCount == 1 )
+					{
+						m_sSelectedItems = aSelectedFiles;
+					}
+				}
+
+				sal_Int32 iFileCount = m_sSelectedItems.getLength();
+				rtl::OUString aTemp;
+				for ( sal_Int32 i = 0; i < iFileCount; i++ )
+				{
+					INetURLObject aObj( m_sSelectedItems[i] );
+					if ( aObj.GetProtocol() == INET_PROT_FILE )
+					{
+						aTemp = aObj.PathToFileName();
+						m_sSelectedItems[i] = aTemp.getLength() > 0 ? aTemp : m_sSelectedItems[i];
+					}
+				}
+			}
+			else
+			{
+				nResult = 0;
+			}
+		}
+
+		m_FileDialogSelectedObj.SetSelectedFile(m_sSelectedItems);
+	}
+	catch( const uno::Exception& )
+	{
+		return 0;
+	}
+
+	return nResult;
+}
+
+
+
--- sc/source/ui/vba/vbafiledialog.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafiledialog.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+
+#ifndef _vbafiledialog_hxx_
+#define _vbafiledialog_hxx_
+
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbadialogsbase.hxx>
+#include <ooo/vba/XFileDialog.hpp>
+#include "vbafiledialogselecteditems.hxx"
+
+
+typedef cppu::ImplInheritanceHelper1< VbaDialogsBase, ov::XFileDialog > ScVbaFileDialog_BASE;
+
+class ScVbaFileDialog : public ScVbaFileDialog_BASE
+{
+public:
+
+	ScVbaFileDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel ) ;
+	virtual ~ScVbaFileDialog() ;
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+	//XFileDialog
+	virtual css::uno::Reference< ov::XFileDialogSelectedItems > SAL_CALL getSelectedItems() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL Show(  ) throw (::com::sun::star::uno::RuntimeException) ;
+
+private:
+	css::uno::Sequence < rtl::OUString > m_sSelectedItems;
+	VbaFileDialogSelectedItems *m_pFileDialogSelectedItems;
+	VbaFileDialogSelectedObj   m_FileDialogSelectedObj;
+};
+
+#endif
\ No newline at end of file
--- sc/source/ui/vba/vbafiledialogselecteditems.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafiledialogselecteditems.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,139 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#include "vbafiledialogselecteditems.hxx"
+
+using namespace ::com::sun::star;
+
+VbaFileDialogSelectedItems::VbaFileDialogSelectedItems( const css::uno::Reference< ov::XHelperInterface >& xParent,
+													   const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+													   const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess 
+													   )
+	: FileDialogSelectedItems_BASE( xParent, xContext,  xIndexAccess  )
+{
+}
+
+
+rtl::OUString& VbaFileDialogSelectedItems::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaFileDialogSelectedItems") );
+	return sImplName;
+
+}
+css::uno::Sequence<rtl::OUString> VbaFileDialogSelectedItems::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.FileDialogSelectedItems" ) );
+	}
+	return aServiceNames;
+
+}
+
+css::uno::Any VbaFileDialogSelectedItems::createCollectionObject( const css::uno::Any& aSource )
+{
+	css::uno::Any aRet;
+	aRet = aSource;
+	return aRet;
+}
+
+
+css::uno::Type SAL_CALL 
+VbaFileDialogSelectedItems::getElementType() throw (css::uno::RuntimeException)
+{
+	return ooo::vba::XFileDialogSelectedItems::static_type(0);
+}
+
+css::uno::Reference< css::container::XEnumeration > SAL_CALL 
+VbaFileDialogSelectedItems::createEnumeration() throw (css::uno::RuntimeException)
+{
+	css::uno::Reference< css::container::XEnumeration > xEnumRet(m_xIndexAccess, css::uno::UNO_QUERY);
+	return xEnumRet;
+}
+
+
+//VbaFileDialogSelectedObj
+//////////////////////////////////////////////////////////////////////////
+
+VbaFileDialogSelectedObj::VbaFileDialogSelectedObj()
+{
+	m_nIndex = 0;
+}
+
+
+sal_Bool 
+VbaFileDialogSelectedObj::SetSelectedFile(css::uno::Sequence<rtl::OUString> &sFList)
+{
+	m_sFileList = sFList;
+	return sal_True;
+}
+
+sal_Int32 SAL_CALL 
+VbaFileDialogSelectedObj::getCount() throw(::com::sun::star::uno::RuntimeException)
+{
+	sal_Int32 nListCnt = m_sFileList.getLength();
+	return nListCnt;
+}
+
+::com::sun::star::uno::Any SAL_CALL VbaFileDialogSelectedObj::getByIndex( sal_Int32 nIndex )
+throw(::com::sun::star::lang::IndexOutOfBoundsException,
+	  ::com::sun::star::lang::WrappedTargetException,
+	  ::com::sun::star::uno::RuntimeException)
+{
+	css::uno::Any  aRet;
+	
+	if ( nIndex >= getCount() )
+	{
+		throw css::lang::IndexOutOfBoundsException();
+	}
+
+	return uno::makeAny(m_sFileList[nIndex]);
+}
+
+::com::sun::star::uno::Type SAL_CALL 
+VbaFileDialogSelectedObj::getElementType()
+throw(::com::sun::star::uno::RuntimeException)
+{
+	return getCppuType((uno::Reference<com::sun::star::container::XIndexAccess>*)0);
+}
+
+sal_Bool SAL_CALL VbaFileDialogSelectedObj::hasElements() 
+throw(::com::sun::star::uno::RuntimeException)
+{
+	return ( getCount() != 0 );
+}
+
+::sal_Bool SAL_CALL 
+VbaFileDialogSelectedObj::hasMoreElements(  ) 
+throw (uno::RuntimeException)
+{
+	if (getCount() > m_nIndex)
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+
+uno::Any SAL_CALL 
+VbaFileDialogSelectedObj::nextElement(  ) 	
+throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+{
+	if (!hasMoreElements())
+	{
+		throw container::NoSuchElementException();
+	}
+
+	return uno::makeAny(m_sFileList[m_nIndex++]);
+}
+
+
+
--- sc/source/ui/vba/vbafiledialogselecteditems.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafiledialogselecteditems.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#ifndef _vbafiledialogselecteditems_hxx_
+#define _vbafiledialogselecteditems_hxx_
+
+#include <ooo/vba/XFileDialogSelectedItems.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+
+typedef CollTestImplHelper< ov::XFileDialogSelectedItems > FileDialogSelectedItems_BASE;
+
+
+class VbaFileDialogSelectedItems : public FileDialogSelectedItems_BASE
+{
+public:
+	VbaFileDialogSelectedItems( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+		const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+		const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+protected:
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+private:
+};
+
+
+class VbaFileDialogSelectedObj : public cppu::WeakImplHelper2<css::container::XIndexAccess, css::container::XEnumeration>
+{
+public:
+	VbaFileDialogSelectedObj();
+	sal_Bool SetSelectedFile(css::uno::Sequence<rtl::OUString> &sFList);
+	//XIndexAccess
+	virtual sal_Int32 SAL_CALL getCount() throw(::com::sun::star::uno::RuntimeException);
+
+	virtual ::com::sun::star::uno::Any SAL_CALL getByIndex( sal_Int32 nIndex )
+		throw(::com::sun::star::lang::IndexOutOfBoundsException,
+		::com::sun::star::lang::WrappedTargetException,
+		::com::sun::star::uno::RuntimeException);
+
+	// XElementAccess
+	virtual ::com::sun::star::uno::Type SAL_CALL getElementType()
+		throw(::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Bool SAL_CALL hasElements() throw(::com::sun::star::uno::RuntimeException);
+
+	//XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL nextElement(  ) 	throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+
+protected:
+private:
+	css::uno::Sequence<rtl::OUString> m_sFileList;
+	sal_Int32 m_nIndex;
+};
+
+#endif
--- sc/source/ui/vba/vbafilesearch.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafilesearch.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,201 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+#include "vbafilesearch.hxx"
+#include <comphelper/processfactory.hxx>
+#include <tools/wldcrd.hxx>
+#include <com/sun/star/ucb/XSimpleFileAccess3.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/uno/Sequence.hxx>
+#include <vector>
+#include "svtools/viewoptions.hxx"
+#include "osl/file.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::ucb;
+using namespace ::com::sun::star::lang;
+using namespace comphelper;
+
+static Reference< XSimpleFileAccess3 > getFileAccess( void )
+{
+	static Reference< XSimpleFileAccess3 > xSFI;
+	if( !xSFI.is() )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+		if( xSMgr.is() )
+		{
+			xSFI = Reference< XSimpleFileAccess3 >( xSMgr->createInstance
+				( ::rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), UNO_QUERY );
+		}
+	}
+	return xSFI;
+}
+
+ScVbaFileSearch::ScVbaFileSearch()
+{
+	NewSearch();
+}
+
+ScVbaFileSearch::~ScVbaFileSearch()
+{
+}
+
+::rtl::OUString SAL_CALL ScVbaFileSearch::getFileName() throw (css::uno::RuntimeException)
+{
+	return m_sFileName;
+}
+
+void SAL_CALL ScVbaFileSearch::setFileName(const ::rtl::OUString& _fileName ) throw (css::uno::RuntimeException)
+{
+	m_sFileName = _fileName;
+}
+
+::rtl::OUString SAL_CALL ScVbaFileSearch::getLookIn() throw (css::uno::RuntimeException)
+{
+	return m_sLookIn;
+}
+
+void SAL_CALL ScVbaFileSearch::setLookIn( const ::rtl::OUString& _lookIn ) throw (css::uno::RuntimeException)
+{
+	m_sLookIn = _lookIn;
+}
+
+sal_Bool SAL_CALL ScVbaFileSearch::getSearchSubFolders() throw (css::uno::RuntimeException)
+{
+	return m_bSearchSubFolders;
+}
+
+void SAL_CALL ScVbaFileSearch::setSearchSubFolders( sal_Bool _searchSubFolders ) throw (css::uno::RuntimeException)
+{
+	m_bSearchSubFolders = _searchSubFolders;
+}
+
+sal_Bool SAL_CALL ScVbaFileSearch::getMatchTextExactly() throw (css::uno::RuntimeException)
+{
+	return m_bMatchTextExactly;
+}
+
+void SAL_CALL ScVbaFileSearch::setMatchTextExactly( sal_Bool _matchTextExactly ) throw (css::uno::RuntimeException)
+{
+	m_bMatchTextExactly = _matchTextExactly;
+}
+
+static bool IsWildCard( const ::rtl::OUString& fileName )
+{		
+	static sal_Char cWild1 = '*';
+	static sal_Char cWild2 = '?';	
+
+	return  ( ( fileName.indexOf( cWild1 ) >= 0 )
+			|| ( fileName.indexOf( cWild2 ) >= 0 ) );
+}
+
+static sal_Int32 SearchWildCard(const WildCard& wildCard, const ::rtl::OUString& aDir, bool bSearchSubFolders)
+{
+	Reference< XSimpleFileAccess3 > xSFI = getFileAccess();
+	Sequence< rtl::OUString > aDirSeq = xSFI->getFolderContents( aDir, bSearchSubFolders );
+	std::vector< rtl::OUString > aSubDirSeq;
+
+	for (int i = 0; i < aDirSeq.getLength(); i++)
+	{
+		rtl::OUString aURLStr = aDirSeq[i];
+
+		if (bSearchSubFolders)
+		{
+			if ( xSFI->isFolder( aURLStr ) )
+			{
+				aSubDirSeq.push_back(aURLStr);
+				continue;
+			}
+		}
+
+		rtl::OUString aFileName = aURLStr.copy(aURLStr.lastIndexOf('/') + 1);
+		if ( wildCard.Matches( aFileName ) )
+		{
+			return 1;
+		}
+	}
+
+	if (bSearchSubFolders)
+	{
+		for (int j = 0; j < aSubDirSeq.size(); j++)
+		{
+			if ( SearchWildCard(wildCard, aSubDirSeq[j], true) > 0 )
+			{
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static sal_Int32 SearchFileName(const ::rtl::OUString& aFileName, const ::rtl::OUString& aDir, bool bSearchSubFolders)
+{
+	Reference< XSimpleFileAccess3 > xSFI = getFileAccess();
+	::rtl::OUString aFileURLStr = aDir + ::rtl::OUString::createFromAscii( "/" ) + aFileName;
+
+	if ( xSFI->exists( aFileURLStr ) )
+	{
+		return 1;
+	}
+	else if (bSearchSubFolders)
+	{
+		Sequence< rtl::OUString > aDirSeq = xSFI->getFolderContents( aDir, true );
+
+		for (int i = 0; i < aDirSeq.getLength(); i++)
+		{
+			rtl::OUString aURLStr = aDirSeq[i];
+			
+			if ( xSFI->isFolder( aURLStr ) )
+			{
+				if ( SearchFileName(aFileName, aURLStr, true) > 0)
+				{
+					return 1;
+				}
+			}
+		}		
+	}
+
+	return 0;
+}
+
+sal_Int32 SAL_CALL ScVbaFileSearch::Execute( )  throw (css::uno::RuntimeException)
+{
+	Reference< XSimpleFileAccess3 > xSFI = getFileAccess();
+	if ( !xSFI->isFolder( m_sLookIn ) )
+	{
+		return 0;
+	}
+
+	if ( m_sFileName == ::rtl::OUString::createFromAscii( "" ) )
+	{
+		return 1;
+	}
+
+	if ( IsWildCard(m_sFileName) )
+	{			
+		WildCard wildCard( m_sFileName.toAsciiLowerCase() );
+		return SearchWildCard(wildCard, m_sLookIn, m_bSearchSubFolders);			
+	}
+	else
+	{
+		return SearchFileName(m_sFileName, m_sLookIn, m_bSearchSubFolders);
+	}
+}
+
+void SAL_CALL ScVbaFileSearch::NewSearch( )  throw (css::uno::RuntimeException)
+{
+	m_sFileName = ::rtl::OUString::createFromAscii( "" );
+	m_sLookIn = ::rtl::OUString::createFromAscii( "" );
+	m_bSearchSubFolders = false;
+	m_bMatchTextExactly = false;
+}
+
--- sc/source/ui/vba/vbafilesearch.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbafilesearch.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+#ifndef SC_VBA_FILESEARCH_HXX
+#define SC_VBA_FILESEARCH_HXX
+
+#include <ooo/vba/XFileSearch.hpp>
+#include <cppuhelper/implbase1.hxx>
+namespace css = ::com::sun::star;
+
+
+typedef ::cppu::WeakImplHelper1< ooo::vba::XFileSearch > ScVbaFileSearchImpl_BASE;
+
+class ScVbaFileSearch : public ScVbaFileSearchImpl_BASE
+{
+private:
+	rtl::OUString   m_sFileName;
+	rtl::OUString   m_sLookIn;
+    sal_Bool        m_bSearchSubFolders;
+    sal_Bool       	m_bMatchTextExactly;
+public:
+    ScVbaFileSearch(  );
+    virtual ~ScVbaFileSearch();
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getFileName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFileName(const ::rtl::OUString& _fileName ) throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getLookIn() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setLookIn(const ::rtl::OUString& _lookIn ) throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getSearchSubFolders() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSearchSubFolders( sal_Bool _searchSubFolders ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getMatchTextExactly() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchTextExactly( sal_Bool _matchTextExactly ) throw (css::uno::RuntimeException);
+    
+    virtual sal_Int32 SAL_CALL Execute(  )  throw (css::uno::RuntimeException);
+	virtual void SAL_CALL NewSearch(  )  throw (css::uno::RuntimeException);
+	
+};
+
+
+#endif /* SC_VBA_FILESEARCH_HXX */
--- sc/source/ui/vba/vbaglobals.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaglobals.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -222,6 +222,12 @@ ScVbaGlobals::Rows( const uno::Any& aInd
 	
 }
 
+uno::Any SAL_CALL 
+ScVbaGlobals::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return uno::Any( getApplication()->MenuBars(aIndex) );
+}
+
 uno::Sequence< ::rtl::OUString > SAL_CALL 
 ScVbaGlobals::getAvailableServiceNames(  ) throw (uno::RuntimeException)
 {
--- sc/source/ui/vba/vbaglobals.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaglobals.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -86,6 +86,8 @@ typedef ::cppu::ImplInheritanceHelper1<
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
 
+    virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
 
 
     // XMultiServiceFactory
--- sc/source/ui/vba/vbamenu.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenu.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenu.hxx" 
+#include "vbamenuitems.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenu::ScVbaMenu( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : Menu_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenu::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenu::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+void SAL_CALL
+ScVbaMenu::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+uno::Any SAL_CALL 
+ScVbaMenu::MenuItems( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBarControl->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenuItems > xMenuItems( new ScVbaMenuItems( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenuItems->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenuItems );
+}
+
+rtl::OUString& 
+ScVbaMenu::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenu") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenu::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menu" ) );
+	}
+	return aServiceNames;
+}
--- sc/source/ui/vba/vbamenu.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenu.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENU_HXX
+#define SC_VBA_MENU_HXX
+
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenu > Menu_BASE;
+
+class ScVbaMenu : public Menu_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenu( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL MenuItems( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENU_HXX
--- sc/source/ui/vba/vbamenubar.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenubar.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubar.hxx" 
+#include "vbamenus.hxx"
+#include <ooo/vba/XCommandBarControls.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuBar::ScVbaMenuBar( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBar >& xCommandBar ) throw( uno::RuntimeException ) : MenuBar_BASE( xParent, xContext ), m_xCommandBar( xCommandBar )
+{
+}
+
+uno::Any SAL_CALL 
+ScVbaMenuBar::Menus( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBar->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenus > xMenus( new ScVbaMenus( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenus->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenus );
+}
+
+rtl::OUString& 
+ScVbaMenuBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBar") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBar" ) );
+	}
+	return aServiceNames;
+}
--- sc/source/ui/vba/vbamenubar.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenubar.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBAR_HXX
+#define SC_VBA_MENUBAR_HXX
+
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBar.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuBar > MenuBar_BASE;
+
+class ScVbaMenuBar : public MenuBar_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBar > m_xCommandBar;
+
+public:
+    ScVbaMenuBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBar >& xCommandBar ) throw( css::uno::RuntimeException );
+    
+    virtual css::uno::Any SAL_CALL Menus( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUBAR_HXX
--- sc/source/ui/vba/vbamenubars.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenubars.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,146 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubars.hxx"
+#include "vbamenubar.hxx"
+#include <ooo/vba/excel/XlSheetType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuBarEnumeration_BASE;
+
+class MenuBarEnumeration : public MenuBarEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuBarEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menubar
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBar > xCommandBar( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( m_xParent, m_xContext, xCommandBar ) );
+            return uno::makeAny( xMenuBar );
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuBars::ScVbaMenuBars( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBars >& xCommandBars ) throw ( uno::RuntimeException ) : MenuBars_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBars( xCommandBars )
+{
+}
+
+ScVbaMenuBars::~ScVbaMenuBars()
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuBars::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuBar::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuBars::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBars, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuBarEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuBars::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuBars::getCount() throw(css::uno::RuntimeException)
+{
+    return m_xCommandBars->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuBars::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    sal_Int16 nIndex = 0;
+    aIndex >>= nIndex;
+    if( nIndex == excel::XlSheetType::xlWorksheet )
+    {
+        uno::Any aSource;
+        aSource <<= rtl::OUString::createFromAscii( "Worksheet Menu Bar" );
+        uno::Reference< XCommandBar > xCommandBar( m_xCommandBars->Item( aSource, uno::Any() ), uno::UNO_QUERY_THROW );
+        uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( this, mxContext, xCommandBar ) );
+        return uno::makeAny( xMenuBar );
+    }
+
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    
+    return uno::Any();
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuBars::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBars") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBars::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBars" ) );
+    }
+    return aServiceNames;
+}
+
--- sc/source/ui/vba/vbamenubars.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenubars.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBARS_HXX
+#define SC_VBA_MENUBARS_HXX
+
+#include <ooo/vba/excel/XMenuBars.hpp>
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBars.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuBars > MenuBars_BASE;
+
+class ScVbaMenuBars : public MenuBars_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBars > m_xCommandBars;
+
+public:
+    ScVbaMenuBars( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBars >& xCommandBars ) throw (css::uno::RuntimeException);
+    virtual ~ScVbaMenuBars();
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& aIndex, const css::uno::Any& /*aIndex2*/ ) throw( css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUBARS_HXX
--- sc/source/ui/vba/vbamenuitem.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenuitem.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitem.hxx" 
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuItem::ScVbaMenuItem( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : MenuItem_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getOnAction() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getOnAction();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setOnAction( const ::rtl::OUString& _onaction ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setOnAction( _onaction );
+}
+
+void SAL_CALL
+ScVbaMenuItem::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+rtl::OUString& 
+ScVbaMenuItem::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItem") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItem::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItem" ) );
+	}
+	return aServiceNames;
+}
--- sc/source/ui/vba/vbamenuitem.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenuitem.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEM_HXX
+#define SC_VBA_MENUITEM_HXX
+
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuItem > MenuItem_BASE;
+
+class ScVbaMenuItem : public MenuItem_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenuItem( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getOnAction() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setOnAction( const ::rtl::OUString& _onaction ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUITEM_HXX
--- sc/source/ui/vba/vbamenuitems.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenuitems.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,159 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitems.hxx"
+#include "vbamenuitem.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+            {
+                uno::Reference< excel::XMenuItem > xMenuItem( new ScVbaMenuItem( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenuItem );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuItems::ScVbaMenuItems( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : MenuItems_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuItems::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuItem::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuItems::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuItems::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuItems::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuItems::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+        return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+    else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+        return uno::makeAny( uno::Reference< excel::XMenuItem > ( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) ) );
+    throw uno::RuntimeException();    
+}
+
+uno::Reference< excel::XMenuItem > SAL_CALL ScVbaMenuItems::Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& /*ShortcutKey*/, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& /*StatusBar*/, const css::uno::Any& /*HelpFile*/, const css::uno::Any& /*HelpContextID*/ ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlButton;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    if( OnAction.hasValue() )
+    {
+        rtl::OUString sAction;
+        OnAction >>= sAction;
+        xCommandBarControl->setOnAction( sAction );
+    }
+    return uno::Reference< excel::XMenuItem >( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuItems::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItems") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItems::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItems" ) );
+    }
+    return aServiceNames;
+}
+
--- sc/source/ui/vba/vbamenuitems.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenuitems.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEMS_HXX
+#define SC_VBA_MENUITEMS_HXX
+
+#include <ooo/vba/excel/XMenuItems.hpp>
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuItems > MenuItems_BASE;
+
+class ScVbaMenuItems : public MenuItems_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenuItems( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenuItem > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& ShortcutKey, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& StatusBar, const css::uno::Any& HelpFile, const css::uno::Any& HelpContextID ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUITEMS_HXX
--- sc/source/ui/vba/vbamenus.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenus.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,145 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenus.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenus::ScVbaMenus( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : Menus_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenus::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenu::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenus::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenus::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenus::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenus::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() != office::MsoControlType::msoControlPopup )
+        throw uno::RuntimeException();
+    return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+}
+
+uno::Reference< excel::XMenu > SAL_CALL ScVbaMenus::Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlPopup;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    return uno::Reference< excel::XMenu >( new ScVbaMenu( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenus::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenus") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenus::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menus" ) );
+    }
+    return aServiceNames;
+}
+
--- sc/source/ui/vba/vbamenus.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbamenus.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUS_HXX
+#define SC_VBA_MENUS_HXX
+
+#include <ooo/vba/excel/XMenus.hpp>
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenus > Menus_BASE;
+
+class ScVbaMenus : public Menus_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenus( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenu > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUS_HXX
--- sc/source/ui/vba/vbaname.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaname.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -72,8 +72,8 @@ ScVbaName::getWorkSheet() throw (css::un
 ScVbaName::getName() throw (css::uno::RuntimeException)
 {
     String sName;
-    sName += UniString( getWorkSheet()->getName());
-    sName += String::CreateFromAscii("!");
+	//sName += UniString( getWorkSheet()->getName()); //liuchen 2009-9-9 resolve the defect that the name get by macro code are not the same with that in UI (for example, if a name of "AA" is found in the UI "Define Names" dialog box, the result of get that name through macro code will be "Sheet1!AA")
+	//sName += String::CreateFromAscii("!");
     sName += UniString ( mxNamedRange->getName() );
     return ::rtl::OUString( sName );
 }
--- sc/source/ui/vba/vbapagebreaks.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbapagebreaks.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -118,10 +118,13 @@ sal_Int32 SAL_CALL RangePageBreaks::getC
     for( sal_Int32 i=0; i<nLength; i++ )
     {
         sal_Int32 nPos = aTablePageBreakData[i].Position;
-        if( nPos > nUsedEnd )
-            return nCount;
-        if( nPos >= nUsedStart )
-            nCount++;
+
+		// VBA. minz@cn.ibm.com. All page breaks before the used range should be counted. 
+		// And the page break at the end of the used range also should be counted.
+		if(  nPos <= nUsedEnd + 1 )
+			nCount++;
+		else
+			return nCount;
     }
 
     return nCount;
@@ -156,17 +159,9 @@ sheet::TablePageBreakData RangePageBreak
     uno::Sequence<sheet::TablePageBreakData> aTablePageBreakDataList = getAllPageBreaks();
 
     sal_Int32 nLength = aTablePageBreakDataList.getLength();
-    for( sal_Int32 i=0; i<nLength; i++ )
-    {
-        aTablePageBreakData = aTablePageBreakDataList[i];
-        sal_Int32 nPos = aTablePageBreakData.Position;
-        if( nPos >= nUsedStart )
-            index++;
-        if( nPos > nUsedEnd )
-            DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
-        if( index == nAPIItemIndex )
-            return aTablePageBreakData;
-    }
+    //VBA. minz@cn.ibm.com. No need to filter the page break. All page breaks before the used range are counted.
+    if ( nAPIItemIndex < nLength && nAPIItemIndex>=0 )
+        aTablePageBreakData = aTablePageBreakDataList[nAPIItemIndex];
 
     return aTablePageBreakData;
 }
--- sc/source/ui/vba/vbapivotcache.cxx.old	2009-10-07 15:06:15.000000000 +0200
+++ sc/source/ui/vba/vbapivotcache.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -37,6 +37,17 @@ ScVbaPivotCache::ScVbaPivotCache( const
 {
 }
 
+sal_Int32  
+ScVbaPivotCache::getMissingItemsLimit() throw (css::uno::RuntimeException)
+{
+	return -1;
+}
+
+void 
+ScVbaPivotCache::setMissingItemsLimit( sal_Int32 aValue ) throw ( css::uno::RuntimeException)
+{
+}
+
 void SAL_CALL 
 ScVbaPivotCache::Refresh() throw (css::uno::RuntimeException)
 {
--- sc/source/ui/vba/vbapivotcache.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbapivotcache.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -43,6 +43,10 @@ class ScVbaPivotCache : public PivotCach
     css::uno::Reference< css::sheet::XDataPilotTable > m_xTable;
 public:
     ScVbaPivotCache( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::sheet::XDataPilotTable >& xTable );
+	
+	virtual ::sal_Int32 SAL_CALL getMissingItemsLimit() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setMissingItemsLimit( ::sal_Int32 aValue ) throw ( css::uno::RuntimeException);
+
     virtual void SAL_CALL Refresh() throw (css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
--- sc/source/ui/vba/vbaquerytable.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbaquerytable.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#include "vbaquerytable.hxx"
+#include "document.hxx"
+#include "docsh.hxx"
+#include "sfx2/lnkbase.hxx"
+#include "svx/linkmgr.hxx"
+#include "arealink.hxx"
+#include "vbarange.hxx"
+
+using namespace com::sun::star;
+
+
+ScVbaQueryTable::ScVbaQueryTable(const css::uno::Reference< ov::XHelperInterface >& xParent, 
+								 const css::uno::Reference< css::uno::XComponentContext > & xContext,
+								 ScDocument *pDocument , 
+								 ScVbaRange *pParent
+								 )
+//:QueryTable_Base(xParent, xContext)
+{
+	m_pDocument = pDocument;
+	m_pParent = pParent;
+}
+
+ScVbaQueryTable::~ScVbaQueryTable()
+{
+
+}
+
+::sal_Bool SAL_CALL 
+ScVbaQueryTable::Refresh( const ::com::sun::star::uno::Any& aBackgroundQuery ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	
+	//Get parent Info
+	sal_Int32 nRow = m_pParent->getRow();
+	sal_Int32 nClm = m_pParent->getColumn();
+	sal_Int16 nTab = m_pParent->getWorksheet()->getIndex() - 1; //The vba index begin from 1. 
+	ScAddress crrRngAddr(nClm, nRow, nTab);
+
+	//Get link info
+	SvxLinkManager *pLinkMng = m_pDocument->GetLinkManager();
+	const ::sfx2::SvBaseLinks &rLinks = pLinkMng->GetLinks();
+	USHORT nCount = rLinks.Count();
+
+	for (USHORT i=0; i<nCount; i++)
+	{
+		::sfx2::SvBaseLink* pBase = *rLinks[i];
+		if (pBase->ISA(ScAreaLink))
+		{
+		
+			ScAreaLink *pAreaLink = (ScAreaLink *)pBase;
+			const ScRange &destRange = pAreaLink->GetDestArea();
+			if (destRange.In(crrRngAddr))
+			{
+				pBase->Update();
+			}
+		}
+	}
+	
+	return sal_True;
+}
+
+
--- sc/source/ui/vba/vbaquerytable.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sc/source/ui/vba/vbaquerytable.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+* 
+* Copyright IBM Corporation 2009.
+* Copyright 2009 by Sun Microsystems, Inc.
+*
+* OpenOffice.org - a multi-platform office productivity suite
+*
+*/
+
+#ifndef SC_VBA_QUERYTABLE_HXX
+#define SC_VBA_QUERYTABLE_HXX
+
+
+#include <ooo/vba/excel/XQueryTable.hpp>
+#include "vbahelper/vbahelperinterface.hxx"
+
+using namespace ::ooo::vba;
+typedef ::cppu::WeakImplHelper1<excel::XQueryTable> QueryTable_Base;
+
+class ScDocument;
+class ScVbaRange;
+
+class ScVbaQueryTable : public QueryTable_Base
+{
+private:
+	ScDocument *m_pDocument;
+	ScVbaRange *m_pParent;
+public:
+	ScVbaQueryTable(const css::uno::Reference< ov::XHelperInterface >& xParent, 
+		            const css::uno::Reference< css::uno::XComponentContext > & xContext,
+					ScDocument *pDocument = NULL, 
+					ScVbaRange *pParent = NULL
+					);
+	~ScVbaQueryTable();
+	virtual ::sal_Bool SAL_CALL Refresh( const ::com::sun::star::uno::Any& aBackgroundQuery ) 
+		throw (::com::sun::star::uno::RuntimeException);
+
+};
+
+#endif
--- sc/source/ui/vba/vbarange.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbarange.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -94,6 +94,15 @@
 #include <com/sun/star/sheet/XSubTotalDescriptor.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hdl>
 
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XSheetAnnotations.hpp>
+
+#include <com/sun/star/sheet/XDataPilotTable.hpp>
+#include <com/sun/star/sheet/XDataPilotTable2.hpp>
+#include <com/sun/star/sheet/XDataPilotTablesSupplier.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionData.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionType.hpp>
+
 #include <ooo/vba/excel/XlPasteSpecialOperation.hpp>
 #include <ooo/vba/excel/XlPasteType.hpp>
 #include <ooo/vba/excel/Constants.hpp>
@@ -145,6 +154,8 @@
 #include "vbaworksheet.hxx"
 #include "vbavalidation.hxx"
 
+#include "vbapivottable.hxx"
+
 #include "tabvwsh.hxx"
 #include "rangelst.hxx"
 #include "convuno.hxx"
@@ -794,9 +805,10 @@ protected:
         double aDblValue = 0.0;
         if ( aValue >>= sFormula )
         {
-            // convert to CONV_OOO style formula string because XCell::setFormula
-            // always compile it in CONV_OOO style.  Perhaps css.sheet.FormulaParser
-            // should be used in future to directly pass formula tokens.
+            // convert to GRAM_PODF_A1 style grammar because XCell::setFormula
+            // always compile it in that grammar. Perhaps
+            // css.sheet.FormulaParser should be used in future to directly
+            // pass formula tokens when that API stabilizes.
             if ( m_eGrammar != formula::FormulaGrammar::GRAM_PODF_A1 && ( sFormula.trim().indexOf('=') == 0 ) )	
             {
                 uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
@@ -1102,6 +1114,24 @@ bool getScRangeListForAddress( const rtl
         formula::FormulaGrammar::AddressConvention eConv = aConv; 
         // spaces are illegal ( but the user of course can enter them )
         rtl::OUString sAddress = (*it).trim();
+        // if a local name ( on the active sheet ) exists this will
+        // take precedence over a global with the same name
+        if ( !xNameAccess->hasByName( sAddress ) && pDocSh )
+        {
+            // try a local name
+            ScDocument* pDoc = pDocSh->GetDocument();     
+            SCTAB nCurTab = pDocSh->GetCurTab();
+            if ( pDoc )
+            {
+                NameToNameMap* pMap = pDoc->GetLocalNameMap( nCurTab );
+                if ( pMap )
+                {
+                    NameToNameMap::iterator it = pMap->find( sAddress );
+                    if ( it != pMap->end() ) // found a mapping
+                        sAddress = it->second;
+                }
+            }
+        }
         if ( xNameAccess->hasByName( sAddress ) )
         {
             uno::Reference< sheet::XNamedRange > xNamed( xNameAccess->getByName( sAddress ), uno::UNO_QUERY_THROW );
@@ -1739,7 +1769,16 @@ ScVbaRange::getFormulaArray() throw (uno
     uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
     uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
     uno::Any aMatrix;
-    aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+
+	//VBA, minz@cn.ibm.com
+	uno::Sequence< uno::Sequence<rtl::OUString> > aFmArray = xCellRangeFormula->getFormulaArray();
+	if( aFmArray.getLength() )
+	{
+		if( aFmArray.getLength() == 1 && aFmArray[0].getLength() == 1 )
+			aMatrix <<= aFmArray[0][0];
+		else	
+			aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+	}	
     return aMatrix;
 }
 
@@ -2242,7 +2281,8 @@ ScVbaRange::Cut(const ::uno::Any& Destin
         uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
         xMover->moveRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
     }
-    {
+	//VBA, minz@cn.ibm.com.
+	else {
 		uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
         Select();
 		excel::implnCut( xModel );
@@ -2557,8 +2597,6 @@ ScVbaRange::PasteSpecial( const uno::Any
   
         uno::Reference< frame::XModel > xModel( ( pShell ? pShell->GetModel() : NULL ), uno::UNO_QUERY_THROW );
 	uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    // save old selection
-	uno::Reference< uno::XInterface > xSel( xModel->getCurrentSelection() );
     // select this range
     xSelection->select( uno::makeAny( mxRange ) );
     // set up defaults	
@@ -2579,8 +2617,6 @@ ScVbaRange::PasteSpecial( const uno::Any
     USHORT nFlags = getPasteFlags(nPaste);
     USHORT nFormulaBits = getPasteFormulaBits(nOperation);
 	excel::implnPasteSpecial(pShell->GetModel(), nFlags,nFormulaBits,bSkipBlanks,bTranspose);
-    // restore selection
-    xSelection->select( uno::makeAny( xSel ) );
 }
 
 uno::Reference< excel::XRange > 
@@ -2630,11 +2666,12 @@ ScVbaRange::AddComment( const uno::Any&
 {
 
     uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
-    // if you don't pass a valid text or if there is already a comment
-    // associated with the range then return NULL
-    if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength() 
-    ||   xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
-        return NULL;
+        // if there is existing text then error
+	if ( Text.hasValue() && xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+            throw uno::RuntimeException(); 
+        // failed to write text? ( can this happen ?? )
+	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength()  )
+		return NULL;	
     return xComment;
 }
 
@@ -2943,6 +2980,13 @@ ScVbaRange::Find( const uno::Any& What,
         uno::Reference< util::XSearchDescriptor > xSearchDescriptor( xDescriptor, uno::UNO_QUERY );
         uno::Reference< uno::XInterface > xInterface = xStartCell.is() ? xSearch->findNext( xStartCell, xSearchDescriptor) : xSearch->findFirst( xSearchDescriptor );
         uno::Reference< table::XCellRange > xCellRange( xInterface, uno::UNO_QUERY );
+        // if we are searching from a starting cell and failed to find a match 
+        // then try from the begining
+        if ( !xCellRange.is() && xStartCell.is() )
+        { 
+            xInterface = xSearch->findFirst( xSearchDescriptor );
+            xCellRange.set( xInterface, uno::UNO_QUERY ); 
+        }
         if ( xCellRange.is() )
         {
             uno::Reference< excel::XRange > xResultRange = new ScVbaRange( this, mxContext, xCellRange );
@@ -3929,56 +3973,12 @@ ScVbaRange::ApplicationRange( const uno:
     return pRange->Range( Cell1, Cell2, true ); 
 }
 
-uno::Reference< sheet::XDatabaseRanges > 
-lcl_GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
-{
-    uno::Reference< frame::XModel > xModel;
-    if ( pShell )
-        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
-    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
-    return xDBRanges;	
-}
-// returns the XDatabaseRange for the autofilter on sheet (nSheet)
-// also populates sName with the name of range
-uno::Reference< sheet::XDatabaseRange > 
-lcl_GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName )
-{
-    uno::Reference< container::XIndexAccess > xIndexAccess( lcl_GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
-    table::CellRangeAddress dbAddress;
-    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
-    {
-        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
-        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
-        // autofilters work weirdly with openoffice, unnamed is the default 
-        // named range which is used to create an autofilter, but
-        // its also possible that another name could be used
-        //     this also causes problems when an autofilter is created on
-        //     another sheet
-        // ( but.. you can use any named range )
-        dbAddress = xDBRange->getDataArea();
-        if ( dbAddress.Sheet == nSheet )
-        {
-            sal_Bool bHasAuto = sal_False;
-            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
-            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
-            if ( bHasAuto )
-            {
-                sName = xNamed->getName();	
-                xDataBaseRange=xDBRange;
-                break;
-            }
-        }
-    }
-    return xDataBaseRange;
-} 
 
 // Helper functions for AutoFilter
 ScDBData* lcl_GetDBData_Impl( ScDocShell* pDocShell, sal_Int16 nSheet )
 {
     rtl::OUString sName;
-    lcl_GetAutoFiltRange( pDocShell, nSheet, sName );
+    excel::GetAutoFiltRange( pDocShell, nSheet, sName );
     OSL_TRACE("lcl_GetDBData_Impl got autofilter range %s for sheet %d",
         rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
     ScDBData* pRet = NULL;
@@ -4145,7 +4145,7 @@ ScVbaRange::AutoFilter( const uno::Any&
     ScDocShell* pShell = getScDocShell();
     sal_Bool bHasAuto = sal_False;	
     rtl::OUString sAutofiltRangeName;
-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = lcl_GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
+    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = excel::GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
     if ( xDataBaseRange.is() )
         bHasAuto = true;	
 
@@ -4178,7 +4178,7 @@ ScVbaRange::AutoFilter( const uno::Any&
             autoFiltAddress = multiCellRange.getCellRangeAddressable()->getRangeAddress();
         }
 
-        uno::Reference< sheet::XDatabaseRanges > xDBRanges = lcl_GetDataBaseRanges( pShell );
+        uno::Reference< sheet::XDatabaseRanges > xDBRanges = excel::GetDataBaseRanges( pShell );
         if ( xDBRanges.is() )
         {
             rtl::OUString sGenName( RTL_CONSTASCII_USTRINGPARAM("VBA_Autofilter_") );
@@ -4691,6 +4691,24 @@ void ScVbaRange::setShowDetail(const uno
     }
 }
 
+//09-09-16 add by limingl
+::com::sun::star::uno::Reference< ::ooo::vba::excel::XQueryTable > SAL_CALL 
+ScVbaRange::getQueryTable() throw (::com::sun::star::uno::RuntimeException)
+{
+	/*
+	if (m_pQueryTable == NULL)
+	{
+		m_pQueryTable = new ScVbaQueryTable(mxParent ,mxContext, getScDocument(), this); //add by limingl
+	}
+	//*/
+	if (!m_xQueryTable.is())
+	{
+		m_xQueryTable = new ScVbaQueryTable(mxParent ,mxContext, getScDocument(), this); //add by limingl
+	}
+	
+	return m_xQueryTable;
+}
+//end add
 uno::Reference< excel::XRange > SAL_CALL 
 ScVbaRange::MergeArea() throw (script::BasicErrorException, uno::RuntimeException)
 {
@@ -4720,6 +4738,118 @@ ScVbaRange::MergeArea() throw (script::B
     return new ScVbaRange( getParent(),mxContext,mxRange );
 }
 
+//2008-08-25 add by limingl
+//The recordset's member: Recordset.Fields.Item will get a Field obj. 
+//Field.value is the column value.
+::sal_Int32 SAL_CALL 
+ScVbaRange::CopyFromRecordset( const ::com::sun::star::uno::Any& Data,  const ::com::sun::star::uno::Any& MaxRows, const ::com::sun::star::uno::Any& MaxColumns ) 
+throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException)
+{
+ 	uno::Sequence< uno::Any > aParams;
+	uno::Sequence< uno::Any > aFieldsParams(1);
+ 	uno::Sequence< sal_Int16 > aOutParamIndex;
+ 	uno::Sequence< uno::Any > aOutParam;
+	uno::Reference< uno::XInterface > xIntRes;
+	uno::Reference< uno::XInterface > xIntFields;
+	uno::Reference< uno::XInterface > xIntFld;
+	uno::Any aRet;
+	uno::Any aPar;
+	uno::Any aCrrCol;
+	uno::Any aCrrRow;
+	sal_Int16 nCrrCol = 0;
+	sal_Int32 nCrrRow = 0;
+	sal_Int32  nCol;
+	sal_Int32 nMaxRows = 0;
+	sal_Int32 nMaxColumns = 0;
+	sal_Bool bEof;
+// 	sal_Bool bColName = sal_True;
+	long lColCnt = 0;
+	if (MaxColumns.hasValue())
+	{
+		MaxColumns >>= nMaxColumns;
+	}
+	
+	long lMaxCol = nMaxColumns;
+	
+	if (MaxRows.hasValue())
+	{
+		MaxRows >>= nMaxRows;
+	}
+	
+
+	Data >>= xIntRes;
+	uno::Reference< script::XInvocation > xInvRes(xIntRes, uno::UNO_QUERY_THROW);
+	rtl::OUString oMoveNext = rtl::OUString::createFromAscii("MoveNext") ;
+	rtl::OUString oEof  = rtl::OUString::createFromAscii("EOF") ;
+	rtl::OUString oFields  = rtl::OUString::createFromAscii("Fields") ;
+
+	if( !xInvRes->hasMethod(oMoveNext))
+	{
+		return -1;
+	}
+	
+	//Get columns count
+	aRet = xInvRes->getValue(oFields);
+	aRet >>= xIntFields;
+	uno::Reference< script::XInvocation > xInvFields(xIntFields, uno::UNO_QUERY_THROW);
+	aRet = xInvFields->getValue( rtl::OUString::createFromAscii("Count")) ;
+	aRet >>= lColCnt;
+
+	//Set the assign column number
+	if (lMaxCol != 0)
+	{
+		if (lColCnt > lMaxCol)
+		{
+			lColCnt = lMaxCol;
+		}		
+	}
+	
+	aCrrRow <<= nCrrRow;
+	aCrrCol <<= nCrrCol;
+
+
+	//Get start position
+	uno::Reference< excel::XRange > xRngStartRow = Rows(uno::Any(sal_Int32(1)) );
+	uno::Reference< excel::XRange > xRngPos = xRngStartRow->Columns( uno::Any(sal_Int32(1)) );
+
+	while(1)
+	{//travel recordset
+		//get every column
+		for (long l = 0; l < lColCnt ; l++)
+		{
+			nCol = l;
+			aPar <<= nCol;
+			//get every field
+			aRet = xInvFields->invoke( rtl::OUString::createFromAscii("Item"), uno::Sequence< uno::Any >(&aPar,1) , aOutParamIndex,aOutParam);
+			aRet >>= xIntFld;
+			uno::Reference< script::XInvocation > xInvFld(xIntFld, uno::UNO_QUERY_THROW); //Get the Field obj
+
+			//set the field value
+			aRet = xInvFld->getValue( rtl::OUString::createFromAscii("Value") );
+ 			uno::Reference< excel::XRange > xRngToFill = xRngPos->Offset(aCrrRow,aCrrCol );
+			
+			xRngToFill->setValue(aRet);
+			nCrrCol++;
+			aCrrCol <<= nCrrCol;
+		}
+		
+		aRet = xInvRes->invoke(oMoveNext, aParams,aOutParamIndex,aOutParam );
+		aRet = xInvRes->getValue(oEof);
+		aRet >>= bEof;
+		if (bEof || ( nCrrRow >= nMaxRows && nMaxRows != 0) )
+		{//Arrive the end of recordset
+			break;
+		}
+		
+ 		nCrrRow++;
+ 		aCrrRow <<= nCrrRow;
+		nCrrCol = 0;
+		aCrrCol <<= nCrrCol;
+	}
+
+	return 0;
+}
+//end add
 void SAL_CALL 
 ScVbaRange::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& ActivePrinter, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& PrToFileName ) throw (uno::RuntimeException)
 {
@@ -5378,6 +5508,42 @@ ScVbaRange::Subtotal( ::sal_Int32 _nGrou
     }
 }
 
+//Add by minz@cn.ibm.com. Range.PivotTable.
+//Returns a PivotTable object that represents the PivotTable report containing the upper-left corner of the specified range.
+uno::Reference< excel::XPivotTable >
+ScVbaRange::PivotTable() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XPivotTable > xDestPVTable;
+
+	RangeHelper thisRange( mxRange );
+	uno::Reference< sheet::XSpreadsheet > xSheet = thisRange.getSpreadSheet();
+	uno::Reference< sheet::XDataPilotTablesSupplier > xTables(xSheet, uno::UNO_QUERY_THROW ) ;
+	uno::Reference< container::XIndexAccess > xIndexAccess( xTables->getDataPilotTables(), uno::UNO_QUERY_THROW );
+	if ( xIndexAccess.is() )
+	{
+		//get the upper-left cell address
+		uno::Reference< sheet::XCellAddressable > xCellAddr(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+		table::CellAddress aAddress = xCellAddr->getCellAddress();
+
+		sal_Int32 nCount = xIndexAccess->getCount();
+		for (sal_Int32 i=0; i < nCount; i++)
+		{
+			uno::Reference< sheet::XDataPilotTable > xDPTable(xIndexAccess->getByIndex(i), uno::UNO_QUERY);
+			uno::Reference< sheet::XDataPilotTable2 > xDPTable2(xDPTable, uno::UNO_QUERY);
+
+			//check if the cell is in the pivot table
+			sheet::DataPilotTablePositionData posData = xDPTable2->getPositionData(aAddress);
+			if( !(posData.PositionType == sheet::DataPilotTablePositionType::NOT_IN_TABLE) )
+			{
+				xDestPVTable = new ScVbaPivotTable( mxContext, xDPTable );
+				break;
+			}
+		}
+	}
+	return xDestPVTable;
+}
+
+
 rtl::OUString& 
 ScVbaRange::getServiceImplName()
 {
@@ -5397,6 +5563,25 @@ ScVbaRange::getServiceNames()
     return aServiceNames;
 }
 
+sal_Bool SAL_CALL
+ScVbaRange::hasError() throw (uno::RuntimeException)
+{
+    double dResult = sal_False;
+    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+    uno::Reference< script::XInvocation > xInvoc( xApplication->WorksheetFunction(), uno::UNO_QUERY_THROW );
+
+    static rtl::OUString FunctionName( RTL_CONSTASCII_USTRINGPARAM("IsError" ) );
+    uno::Sequence< uno::Any > Params(1);
+    uno::Reference< excel::XRange > aRange( this );
+    Params[0] = uno::makeAny( aRange );
+    uno::Sequence< sal_Int16 > OutParamIndex;
+    uno::Sequence< uno::Any > OutParam;
+    xInvoc->invoke( FunctionName, Params, OutParamIndex, OutParam ) >>= dResult;
+    if ( dResult > 0.0 )
+         return sal_True;
+    return sal_False;
+}
+
 namespace range
 {
 namespace sdecl = comphelper::service_decl;
--- sc/source/ui/vba/vbarange.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbarange.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,6 +38,7 @@
 #include <ooo/vba/excel/XFont.hpp>
 #include <ooo/vba/excel/XComment.hpp>
 #include <ooo/vba/XCollection.hpp>
+#include <ooo/vba/excel/XPivotTable.hpp>
 #include <ooo/vba/excel/XlPasteType.hdl>
 #include <ooo/vba/excel/XlPasteSpecialOperation.hdl>
 
@@ -52,6 +53,7 @@
 #include <com/sun/star/sheet/FillDirection.hpp>
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
 #include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include "vbaquerytable.hxx" //09-09-18 add by limingl
 
 //#include <vbahelper/vbahelperinterface.hxx>
 #include "vbaformat.hxx"
@@ -100,6 +102,7 @@ class ScVbaRange : public ScVbaRange_BAS
     sal_Bool mbIsRows;
     sal_Bool mbIsColumns;
     css::uno::Reference< ov::excel::XValidation > m_xValidation;
+	css::uno::Reference<excel::XQueryTable> m_xQueryTable; //09-09-16 add by limingl
     double getCalcColWidth( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
     double getCalcRowHeight( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
     void visitArray( ArrayVisitor& vistor );
@@ -179,6 +182,7 @@ public:
     //virtual void SAL_CALL setLocked(const css::uno::Any& aLocked) throw (css::script::BasicErrorException, css::uno::RuntimeException);	
     virtual css::uno::Any SAL_CALL getShowDetail() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setShowDetail(const css::uno::Any& aShowDetail) throw (css::uno::RuntimeException);	
+	virtual ::com::sun::star::uno::Reference< ::ooo::vba::excel::XQueryTable > SAL_CALL getQueryTable() throw (::com::sun::star::uno::RuntimeException); //09-09-16 add by limingl
     // Methods
     sal_Bool IsRows() { return mbIsRows; }
     sal_Bool IsColumns() { return mbIsColumns; }
@@ -252,6 +256,10 @@ public:
     virtual void SAL_CALL RemoveSubtotal(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL MergeArea() throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual void SAL_CALL Subtotal( ::sal_Int32 GroupBy, ::sal_Int32 Function, const css::uno::Sequence< ::sal_Int32 >& TotalList, const css::uno::Any& Replace, const css::uno::Any& PageBreaks, const css::uno::Any& SummaryBelowData ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+	
+	virtual css::uno::Reference< ov::excel::XPivotTable > SAL_CALL PivotTable(  ) throw (css::uno::RuntimeException);
+
+	virtual ::sal_Int32 SAL_CALL CopyFromRecordset( const ::com::sun::star::uno::Any& Data,  const ::com::sun::star::uno::Any& MaxRows, const ::com::sun::star::uno::Any& MaxColumns ) throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException); //2008-08-25 add by limingl
     // XEnumerationAccess
     virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
     // XElementAccess
@@ -277,6 +285,8 @@ public:
     static css::uno::Reference< ov::excel::XRange > ApplicationRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException);
     virtual sal_Bool SAL_CALL GoalSeek( const css::uno::Any& Goal, const css::uno::Reference< ov::excel::XRange >& ChangingCell ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ov::excel::XRange > SAL_CALL SpecialCells( const css::uno::Any& _oType, const css::uno::Any& _oValue) throw ( css::script::BasicErrorException );  
+	// XErrorQuery
+	virtual ::sal_Bool SAL_CALL hasError(  ) throw (css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- sc/source/ui/vba/vbawindow.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbawindow.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -59,7 +59,7 @@ using namespace ::ooo::vba;
 using namespace ::ooo::vba::excel::XlWindowState;
 
 // nameExists defined in vbaworksheet.cxx
-bool nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException );
+bool nameExists( const uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, const ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException );
 
 typedef  std::hash_map< rtl::OUString,
 SCTAB, ::rtl::OUStringHash,
--- sc/source/ui/vba/vbaworkbook.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaworkbook.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -187,6 +187,24 @@ ScVbaWorkbook::FileFormat(  ) throw (::s
         return aFileFormat;
 }
 
+//VBA by minz@cn.ibm.com. Convert Excel fileformat to OO file filter
+::rtl::OUString ScVbaWorkbook::convertFileFormat(sal_Int32 aFileFormat)
+{
+	rtl::OUString aFilterName;
+
+	switch(aFileFormat) 
+	{
+		case excel::XlFileFormat::xlCSV:
+				aFilterName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Text - txt - csv (StarCalc)" ) );
+				break;
+		case excel::XlFileFormat::xlExcel9795:
+				aFilterName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MS Excel 97" ) );
+				break;
+	}
+
+	return aFilterName;
+}
+
 void 
 ScVbaWorkbook::init()
 {
@@ -264,6 +282,12 @@ ScVbaWorkbook::Activate() throw (uno::Ru
     VbaDocumentBase::Activate();
 }
 
+void
+ScVbaWorkbook::Protect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+    VbaDocumentBase::Protect( aPassword );
+}
+
 ::sal_Bool
 ScVbaWorkbook::getProtectStructure() throw (uno::RuntimeException)
 {
@@ -299,6 +323,24 @@ ScVbaWorkbook::SaveCopyAs( const rtl::OU
     xStor->storeToURL( aURL, storeProps );
 }
 
+//VBA by minz@cn.ibm.com. Add Workbook.SaveAs.
+void 
+ScVbaWorkbook::SaveAs( const rtl::OUString& FileName, const uno::Any& FileFormat, const uno::Any& /*CreateBackup*/ ) throw ( uno::RuntimeException)
+{
+	rtl::OUString aURL;
+	osl::FileBase::getFileURLFromSystemPath( FileName, aURL );
+	uno::Reference< frame::XStorable > xStor( getModel(), uno::UNO_QUERY_THROW );
+
+	sal_Int32 aFileFormat;
+	FileFormat >>= aFileFormat;
+
+	uno::Sequence<  beans::PropertyValue > storeProps(1);
+	storeProps[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "FilterName" ) );
+	storeProps[0].Value <<= convertFileFormat(aFileFormat);
+
+	xStor->storeAsURL( aURL, storeProps );
+}
+
 css::uno::Any SAL_CALL 
 ScVbaWorkbook::Styles( const::uno::Any& Item ) throw (uno::RuntimeException)
 {
--- sc/source/ui/vba/vbaworkbook.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaworkbook.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -44,6 +44,8 @@ class ScVbaWorkbook : public ScVbaWorkbo
     static css::uno::Sequence< sal_Int32 > ColorData;
     void initColorData( const css::uno::Sequence< sal_Int32 >& sColors );
     void init();
+
+	::rtl::OUString convertFileFormat(sal_Int32 aFileFormat);
 protected:
 
     ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext);
@@ -64,6 +66,7 @@ public:
     virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
     // Amelia Wang
     virtual css::uno::Any SAL_CALL Names( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
@@ -72,6 +75,8 @@ public:
     virtual css::uno::Any SAL_CALL Colors( const css::uno::Any& Index ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL FileFormat(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual void SAL_CALL SaveCopyAs( const rtl::OUString& Filename ) throw ( css::uno::RuntimeException);
+	virtual void SAL_CALL SaveAs( const rtl::OUString& FileName, const css::uno::Any& FileFormat, const css::uno::Any& CreateBackup ) throw (css::uno::RuntimeException);
+
     // code name
     virtual ::rtl::OUString SAL_CALL getCodeName() throw ( css::uno::RuntimeException);
     virtual void SAL_CALL setCodeName( const ::rtl::OUString& sGlobCodeName ) throw (css::uno::RuntimeException);
--- sc/source/ui/vba/vbaworksheet.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaworksheet.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -77,7 +77,7 @@
 
 #include "cellsuno.hxx"
 #include "drwlayer.hxx"
-
+#include "tabprotection.hxx"
 #include "scextopt.hxx"
 #include "vbaoutline.hxx"
 #include "vbarange.hxx"
@@ -97,7 +97,7 @@
 using namespace com::sun::star;
 using namespace ooo::vba;
 bool
-nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
+nameExists( const uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, const ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
 {
     if (!xSpreadDoc.is())
         throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "nameExists() xSpreadDoc is null" ) ), uno::Reference< uno::XInterface  >(), 1 );
@@ -409,6 +409,18 @@ ScVbaWorksheet::getProtectContents()thro
 sal_Bool 
 ScVbaWorksheet::getProtectDrawingObjects() throw (uno::RuntimeException) 
 {
+	SCTAB nTab = 0;
+	rtl::OUString aSheetName = getName();
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+	bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
+	if ( bSheetExists )
+	{
+		uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+		ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+		ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+		if ( pProtect )
+			return pProtect->isOptionEnabled( ScTableProtection::OBJECTS ); 
+        }
     return false;
 }
 
@@ -557,13 +569,25 @@ ScVbaWorksheet::getSheetAtOffset(SCTAB o
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getNext() throw (uno::RuntimeException)
 {
-    return getSheetAtOffset(static_cast<SCTAB>(1));
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(static_cast<SCTAB>(1));
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getPrevious() throw (uno::RuntimeException)
 {
-    return getSheetAtOffset(-1);
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(-1);
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 
@@ -647,7 +671,7 @@ ScVbaWorksheet::ChartObjects( const uno:
         uno::Reference< table::XTableChartsSupplier > xChartSupplier( getSheet(), uno::UNO_QUERY_THROW );
         uno::Reference< table::XTableCharts > xTableCharts = xChartSupplier->getCharts();
         
-        uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( getSheet(), uno::UNO_QUERY_THROW ); //VBA, minz@cn.ibm.com.
         mxCharts = new ScVbaChartObjects(  this, mxContext, xTableCharts, xDrawPageSupplier );
     }
     if ( Index.hasValue() )
@@ -885,7 +909,7 @@ ScVbaWorksheet::getServiceNames()
 rtl::OUString SAL_CALL
 ScVbaWorksheet::getCodeName() throw (css::uno::RuntimeException)
 {
-#ifdef VBA_OOBUILD_HACK 
+#if 0
     uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
     SCTAB nTab = 0;
     rtl::OUString aSheetName = getName();
@@ -906,7 +930,7 @@ ScVbaWorksheet::getCodeName() throw (css
     throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 #endif
 }
-#ifdef VBA_OOBUILD_HACK 
+#if 0
 void SAL_CALL
 ScVbaWorksheet::setCodeName( const rtl::OUString& sCodeName ) throw (css::uno::RuntimeException)
 {
@@ -936,7 +960,7 @@ ScVbaWorksheet::setCodeName( const rtl::
 sal_Int16
 ScVbaWorksheet::getSheetID() throw (uno::RuntimeException)
 {
-    uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxSheet, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( getSheet(), uno::UNO_QUERY_THROW ); //VBA. minz@cn.ibm.com. if ActiveSheet, mxSheet is null.
     return xAddressable->getRangeAddress().Sheet;
 }
 
@@ -963,6 +987,50 @@ ScVbaWorksheet::PrintOut( const uno::Any
 	PrintOutHelper( excel::getBestViewShell( xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, bSelection );
 }
 
+uno::Reference< sheet::XDatabaseRange > lcl_getXDatabase( const uno::Reference< frame::XModel >& xModel, const rtl::OUString& aSheetName ) throw ( uno::RuntimeException)
+
+{
+    uno::Reference< sheet::XDatabaseRange > xDBRange;
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+    SCTAB nTab(0);
+    bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
+    if ( bSheetExists )    
+    {
+        rtl::OUString sAutofilterRngName;
+	ScDocShell* pShell = excel::getDocShell( xModel );
+
+        xDBRange = excel::GetAutoFiltRange( pShell, static_cast<  sal_Int16 >( nTab ), sAutofilterRngName );
+            
+    }
+    return xDBRange;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaWorksheet::getAutoFilterMode() throw (uno::RuntimeException)
+{
+    if ( lcl_getXDatabase( getModel(), getName() ).is() )
+        return sal_True; 
+    return sal_False;
+}
+
+void SAL_CALL 
+ScVbaWorksheet::setAutoFilterMode( ::sal_Bool _autofiltermode ) throw (uno::RuntimeException)
+{
+    if ( !_autofiltermode )
+    {
+        uno::Reference< sheet::XDatabaseRange >xAutoFilt = lcl_getXDatabase( getModel(), getName() );
+        
+       if ( xAutoFilt.is() )
+       {
+           uno::Reference< beans::XPropertySet > xProps( xAutoFilt, uno::UNO_QUERY_THROW );
+           xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::makeAny( sal_False ) );
+       }
+    }
+    // Not possible to set to true
+    else
+        throw uno::RuntimeException();
+}
+
 namespace worksheet
 {
 namespace sdecl = comphelper::service_decl;
--- sc/source/ui/vba/vbaworksheet.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/source/ui/vba/vbaworksheet.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -46,6 +46,7 @@
 #include <ooo/vba/excel/XHPageBreaks.hpp>
 #include <ooo/vba/excel/XVPageBreaks.hpp>
 #include <ooo/vba/excel/XChartObjects.hpp>
+#include <com/sun/star/container/XNamed.hpp>
 
 #include <vbahelper/vbahelperinterface.hxx>
 #include "address.hxx"
@@ -81,6 +82,9 @@ public:
     { return mxSheet; }
 
     // Attributes
+    virtual ::sal_Bool SAL_CALL getAutoFilterMode() throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFilterMode( ::sal_Bool _autofiltermode ) throw (::com::sun::star::uno::RuntimeException);
+
     virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setName( const ::rtl::OUString &rName ) throw (css::uno::RuntimeException);
     virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
--- sc/source/ui/vba/vbawsfunction.cxx.old	2009-10-07 15:06:15.000000000 +0200
+++ sc/source/ui/vba/vbawsfunction.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -74,13 +74,58 @@ ScVbaWSFunction::invoke(const rtl::OUStr
 
     for (int i=0; i < Params.getLength();i++) 
     {
+        aArrayTemp[i]= aArray[i];
         uno::Reference<excel::XRange> myRange( aArray[ i ], uno::UNO_QUERY );
         if ( myRange.is() ) 
         {
             aArrayTemp[i] = myRange->getCellRange();
             continue;
         }
-        aArrayTemp[i]= aArray[i];
+                else if (  aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_BOOLEAN )
+		{
+			sal_Bool bValue( sal_False );
+			aArray[ i ] >>= bValue;
+			if ( bValue )
+				aArrayTemp[ i ] <<= double( 1.0 ); 
+			else
+				aArrayTemp[ i ] <<= double( 0.0 ); 
+                        
+		}
+        else if ( aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_SEQUENCE )
+        {
+            // the sheet.FunctionAccess service doesn't deal with Sequences, only Sequences of Sequence
+            uno::Type aType = aArray[ i ].getValueType();
+            if ( aType.equals( getCppuType( (uno::Sequence<sal_Int16>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< sal_Int16 > >  aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<sal_Int32>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< sal_Int32 > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<double>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< double > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<rtl::OUString>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< rtl::OUString > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<uno::Any>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence<uno::Any > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+        }
     }
 
     for ( int count=0; count < aParamTemp.getLength(); ++count )
@@ -88,12 +133,13 @@ ScVbaWSFunction::invoke(const rtl::OUStr
             count, rtl::OUStringToOString( comphelper::anyToString( aParamTemp[count] ), RTL_TEXTENCODING_UTF8 ).getStr()  );
     
     uno::Any aRet = xFunctionAccess->callFunction(FunctionName,aParamTemp);
+
     // MATCH function should alwayse return a double value, but currently if the first argument is XCellRange, MATCH function returns an array instead of a double value. Don't know why?
     // To fix this issue in safe, current solution is to convert this array to a double value just for MATCH function.
     String aUpper( FunctionName );
     ScCompiler aCompiler( NULL, ScAddress() ); 
     OpCode eOp = aCompiler.GetEnglishOpCode( aUpper.ToUpperAscii() );
-    if( eOp == ocMatch )
+	if( eOp == ocMatch || eOp == ocIsError )
     {
         double fVal = 0.0;
         if( aRet >>= fVal )
--- sc/source/ui/view/cellsh2.cxx.old	2010-03-03 16:59:10.000000000 +0100
+++ sc/source/ui/view/cellsh2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -336,6 +336,20 @@ void ScCellShell::ExecuteDB( SfxRequest&
             }
             break;
 
+		case SID_DATA_FORM:
+			{
+				ScAbstractDialogFactory* pFact = ScAbstractDialogFactory::Create();
+	            DBG_ASSERT(pFact, "ScAbstractFactory create fail!");//CHINA001
+
+	            AbstractScDataFormDlg* pDlg = pFact->CreateScDataFormDlg( pTabViewShell->GetDialogParent(),RID_SCDLG_DATAFORM, pTabViewShell);
+	            DBG_ASSERT(pDlg, "Dialog create fail!");//CHINA001
+
+	            pDlg->Execute();
+	            
+				rReq.Done();
+			}
+			break;
+			
         case SID_SUBTOTALS:
             {
                 const SfxItemSet* pArgs = rReq.GetArgs();
--- sc/source/ui/view/gridwin.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/ui/view/gridwin.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -132,7 +132,13 @@
 #include <vcl/svapp.hxx>
 #include <svx/sdr/overlay/overlayselection.hxx>
 
+#include "cellsuno.hxx"
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Any;
 
@@ -374,6 +380,32 @@ void lcl_UnLockComment( ScDrawView* pVie
     }
 }
 
+sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTAB nTab, ScBaseCell*& rpCell )
+{
+	BOOL bFound = FALSE;
+	do
+	{
+		pDoc->GetCell( rPosX, rPosY, nTab, rpCell );
+		if ( !rpCell || rpCell->GetCellType() == CELLTYPE_NOTE )
+		{
+			if ( rPosX <= 0 )
+				return FALSE;							// alles leer bis links
+			else
+				--rPosX;								// weitersuchen
+		}
+                else if ( rpCell->GetCellType() == CELLTYPE_EDIT)
+                    bFound = TRUE;
+                else if (rpCell->GetCellType() == CELLTYPE_FORMULA &&
+                  static_cast<ScFormulaCell*>(rpCell)->IsHyperLinkCell())
+                    bFound = TRUE;
+	    else
+			return FALSE;								// andere Zelle
+	}
+	while ( !bFound );
+
+	return bFound;
+}
+
 // ---------------------------------------------------------------------------
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
 ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhichPos )
@@ -1495,6 +1527,7 @@ void ScGridWindow::HandleMouseButtonDown
     SCCOL	nOldColFBox	  = bWasFilterBox ? pFilterBox->GetCol() : 0;
     SCROW  nOldRowFBox	  = bWasFilterBox ? pFilterBox->GetRow() : 0;
 #endif
+#include "cellsuno.hxx" 
 
     ClickExtern();	// loescht FilterBox, wenn vorhanden
 
@@ -2130,6 +2163,26 @@ void __EXPORT ScGridWindow::MouseButtonU
         {
             nMouseStatus = SC_GM_NONE;				// keinen Doppelklick anfangen
             ScGlobal::OpenURL( aUrl, aTarget );
+			
+			// fire worksheet_followhyperlink event
+			Point aPos = rMEvt.GetPosPixel();
+	        SCsCOL nPosX;
+    	    SCsROW nPosY;
+        	SCTAB nTab = pViewData->GetTabNo();
+        	pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
+			ScBaseCell* pCell = NULL;
+
+			BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+			if( bFound )
+			{
+				ScAddress aCellPos( nPosX, nPosY, nTab );
+				ScCellObj* pObj = new ScCellObj( pViewData->GetDocShell(), aCellPos );
+				uno::Sequence< uno::Any > aArgs(1);
+				aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+                uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+                if( xVbaEventsHelper.is() )
+			        xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_FOLLOWHYPERLINK, aArgs );
+			}
             return;
         }
     }
@@ -2460,7 +2513,7 @@ long ScGridWindow::PreNotify( NotifyEven
                             lcl_InitMouseEvent( aEvent, *rNEvt.GetMouseEvent() );
                             if ( rNEvt.GetWindow() )
                                 aEvent.Source = rNEvt.GetWindow()->GetComponentInterface();
-                            if ( nType == EVENT_MOUSEBUTTONDOWN)
+                            if ( nType == EVENT_MOUSEBUTTONDOWN )
                                 pImp->MousePressed( aEvent );
                             else
                                 pImp->MouseReleased( aEvent );
@@ -4895,26 +4948,9 @@ BOOL ScGridWindow::GetEditUrlOrError( BO
     ScDocument* pDoc = pDocSh->GetDocument();
     ScBaseCell* pCell = NULL;
 
-    BOOL bFound = FALSE;
-    do
-    {
-        pDoc->GetCell( nPosX, nPosY, nTab, pCell );
-        if ( !pCell || pCell->GetCellType() == CELLTYPE_NOTE )
-        {
-            if ( nPosX <= 0 )
-                return FALSE;							// alles leer bis links
-            else
-                --nPosX;								// weitersuchen
-        }
-                else if ( pCell->GetCellType() == CELLTYPE_EDIT)
-                    bFound = TRUE;
-                else if (pCell->GetCellType() == CELLTYPE_FORMULA &&
-                  static_cast<ScFormulaCell*>(pCell)->IsHyperLinkCell())
-                    bFound = TRUE;
-        else
-            return FALSE;								// andere Zelle
-    }
-    while ( !bFound );
+	BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+	if( !bFound )
+		return FALSE;
 
     ScHideTextCursor aHideCursor( pViewData, eWhich );	// before GetEditArea (MapMode is changed)
 
--- sc/source/ui/view/gridwin5.cxx.old	2009-10-08 16:17:09.000000000 +0200
+++ sc/source/ui/view/gridwin5.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -346,14 +346,12 @@ void ScGridWindow::RequestHelp(const Hel
                                     if ( pDrView->PickObj(aMDPos, pDrView->getHitTolLog(), pHit, pPV, SDRSEARCH_DEEP ) )
                                         pObj = pHit;
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
                             if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
                             {
                                 aPixRect = LogicToPixel(aVEvt.pObj->GetLogicRect());
                                 aHelpText = pInfo->GetHlink();
                             }
-#endif
                         }
                     }
                 }
--- sc/source/ui/view/tabview3.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/ui/view/tabview3.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -83,6 +83,10 @@
 #include "formula/FormulaCompiler.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star::document::VbaEventId;
 
 namespace
 {
@@ -1426,10 +1430,15 @@ void ScTabView::MarkRange( const ScRange
     {
         SCCOL nAlignX = rRange.aStart.Col();
         SCROW nAlignY = rRange.aStart.Row();
-        if ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL )
-            nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
-        if ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW )
-            nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
+		bool bCol = ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL );
+		bool bRow = ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW );
+		if ( !bCol && !bRow )
+		{
+			if ( bCol ) 
+				nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
+			if ( bRow )
+				nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
+		}
         AlignToCursor( nAlignX, nAlignY, SC_FOLLOW_JUMP );
     }
     InitBlockMode( rRange.aStart.Col(), rRange.aStart.Row(), nTab );
@@ -1542,6 +1551,17 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
                                         //	nicht InputEnterHandler wegen Referenzeingabe !
 
         ScDocument* pDoc = aViewData.GetDocument();
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_DEACTIVATE, aArgs );
+            }
+		}
+			
         pDoc->MakeTable( nTab );
 
         // Update pending row heights before switching the sheet, so Reschedule from the progress bar
@@ -1646,8 +1666,20 @@ void ScTabView::SetTabNo( SCTAB nTab, BO
                     if ( pGridWin[i]->IsVisible() )
                         pGridWin[i]->UpdateEditViewPos();
         }
+		
+		TabChanged();										// DrawView
 
-        TabChanged();										// DrawView
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_ACTIVATE,  aArgs );
+            }
+		}
+			
         aViewData.GetViewShell()->WindowChanged();			// falls das aktive Fenster anders ist
         if ( !bUnoRefDialog )
             aViewData.GetViewShell()->DisconnectAllClients();   // important for floating frames
--- sc/source/ui/view/viewfun2.cxx.old	2010-03-03 16:59:14.000000000 +0100
+++ sc/source/ui/view/viewfun2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -57,6 +57,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2210,15 +2215,42 @@ BOOL ScViewFunc::DeleteTable( SCTAB nTab
     return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
     ScDocShell* pDocSh	= GetViewData()->GetDocShell();
     ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
     SCTAB		nNewTab = TheTabs[0];
     int			i;
     WaitObject aWait( GetFrameWin() );
     if (bRecord && !pDoc->IsUndoEnabled())
         bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
     while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
         --nNewTab;
@@ -2285,9 +2317,18 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
     for(i=TheTabs.Count()-1;i>=0;i--)
     {
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
         {
             bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
         }
     }
@@ -2315,6 +2356,7 @@ BOOL ScViewFunc::DeleteTables(const SvSh
         pDocSh->PostPaintExtras();
         pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
--- sc/source/ui/view/viewfun3.cxx.old	2010-03-03 16:59:19.000000000 +0100
+++ sc/source/ui/view/viewfun3.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -213,6 +213,7 @@
 #include "drwtrans.hxx"
 #include "docuno.hxx"
 #include "clipparam.hxx"
+#include "undodat.hxx"   // Amelia Wang
 
 using namespace com::sun::star;
 
@@ -1787,6 +1788,85 @@ BOOL ScViewFunc::LinkBlock( const ScRang
     return TRUE;
 }
 
+void ScViewFunc::DataFormPutData( SCROW nCurrentRow ,
+                                  SCROW nStartRow , SCCOL nStartCol ,
+                                  SCROW nEndRow , SCCOL nEndCol ,
+                                  Edit** pEdits ,
+                                  sal_uInt16 aColLength )
+{
+    ScDocument* pDoc = GetViewData()->GetDocument();
+    ScDocShell* pDocSh = GetViewData()->GetDocShell();
+    ScMarkData& rMark = GetViewData()->GetMarkData();
+    ScDocShellModificator aModificator( *pDocSh );
+    SfxUndoManager* pUndoMgr = pDocSh->GetUndoManager();
+    if ( pDoc )
+    {
+        const BOOL bRecord( pDoc->IsUndoEnabled());
+        ScDocument* pUndoDoc = NULL;
+        ScDocument* pRedoDoc = NULL;
+        ScDocument* pRefUndoDoc = NULL;
+        ScRefUndoData* pUndoData = NULL;
+        SCTAB nTab = GetViewData()->GetTabNo();
+        SCTAB nStartTab = nTab;
+        SCTAB nEndTab = nTab;
+        
+        {
+                ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+                if ( pChangeTrack )
+                        pChangeTrack->ResetLastCut();   // kein CutMode mehr
+        }
+        ScRange aUserRange( nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );
+        BOOL bColInfo = ( nStartRow==0 && nEndRow==MAXROW );
+        BOOL bRowInfo = ( nStartCol==0 && nEndCol==MAXCOL );
+        SCCOL nUndoEndCol = nStartCol+aColLength-1;
+        SCROW nUndoEndRow = nCurrentRow;
+        USHORT nUndoFlags = IDF_NONE;
 
+        if ( bRecord )
+        {
+            pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pUndoDoc->InitUndoSelected( pDoc , rMark , bColInfo , bRowInfo );
+            pDoc->CopyToDocument( aUserRange , 1 , FALSE , pUndoDoc );
+        }
+        USHORT nExtFlags = 0;
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nStartRow, nStartTab , nEndCol, nEndRow, nEndTab ); // content before the change
+        //rMark.SetMarkArea( aUserRange );
+        pDoc->BeginDrawUndo();
+        
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+        {
+            if (pEdits[i])
+            {
+                String  aFieldName=pEdits[i]->GetText();
+                pDoc->SetString( nStartCol + i, nCurrentRow, nTab, aFieldName );
+            }
+        }
+        //pDoc->ExtendMergeSel( nStartCol, nStartRow, nEndCol, nEndRow, rMark, TRUE );    // Refresh
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );  // content after the change
+        SfxUndoAction* pUndo = new ScUndoDataForm( pDocSh,
+                                                                nStartCol, nCurrentRow, nStartTab,
+                                                                nUndoEndCol, nUndoEndRow, nEndTab, rMark,
+                                                                pUndoDoc, pRedoDoc, nUndoFlags,
+                                                                pUndoData, NULL, NULL, NULL,
+                                                                FALSE );           // FALSE = Redo data not yet copied
+        pUndoMgr->AddUndoAction( new ScUndoWrapper( pUndo ), TRUE );
+        
+        USHORT nPaint = PAINT_GRID;
+        if (bColInfo)
+        {
+                nPaint |= PAINT_TOP;
+                nUndoEndCol = MAXCOL;                           // nur zum Zeichnen !
+        }
+        if (bRowInfo)
+        {
+                nPaint |= PAINT_LEFT;
+                nUndoEndRow = MAXROW;                           // nur zum Zeichnen !
+        }
+
+        pDocSh->PostPaint( nStartCol, nCurrentRow, nStartTab,
+                                                nUndoEndCol, nUndoEndRow, nEndTab, nPaint, nExtFlags );
+        pDocSh->UpdateOle(GetViewData());
+    }
+}
 
 
--- sc/uiconfig/scalc/menubar/menubar.xml.old	2010-03-03 16:59:24.000000000 +0100
+++ sc/uiconfig/scalc/menubar/menubar.xml	2010-03-03 16:59:35.000000000 +0100
@@ -399,6 +399,7 @@
                     <menu:menuitem menu:id=".uno:DataFilterHideAutoFilter"/>
                 </menu:menupopup>
             </menu:menu>
+			<menu:menuitem menu:id=".uno:DataForm"/>
             <menu:menuitem menu:id=".uno:DataSubTotals"/>
             <menu:menuitem menu:id=".uno:Validation"/>
             <menu:menuseparator/>
--- sc/util/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ sc/util/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -279,6 +279,7 @@ LIB8OBJFILES = \
         $(SLO)$/filldlg.obj			\
         $(SLO)$/delcodlg.obj		\
         $(SLO)$/delcldlg.obj		\
+		$(SLO)$/datafdlg.obj		\
         $(SLO)$/dapitype.obj	\
         $(SLO)$/dapidata.obj	\
         $(SLO)$/crdlg.obj			\
--- scp2/source/ooo/file_library_ooo.scp.old	2010-03-03 16:59:33.000000000 +0100
+++ scp2/source/ooo/file_library_ooo.scp	2010-03-03 16:59:35.000000000 +0100
@@ -70,6 +70,20 @@ File gid_File_Lib_Basprov
   #endif
 End
 
+#ifdef ENABLE_VBA
+File gid_File_Lib_Vbaevent
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT4(vbaevents,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT4(vbaevents,DLLPOSTFIX,.uno,.dll));
+  #endif
+End
+#endif // ENABLE_VBA
+
 STD_UNO_LIB_FILE( gid_File_Lib_Bib , bib)
 
 File gid_File_Lib_Cached1
--- scripting/prj/build.lst.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/prj/build.lst	2010-03-03 16:59:35.000000000 +0100
@@ -1,8 +1,9 @@
-tc	scripting	:	bridges rdbmaker vcl xmlscript basic sfx2 rhino BSH:beanshell javaunohelper NULL
+tc	scripting	:	oovbaapi svx bridges rdbmaker vcl xmlscript basic sfx2 rhino BSH:beanshell javaunohelper NULL
 tc	scripting									usr1	-	all	tc1_mkout NULL
 tc	scripting\inc								nmake	-	all	tc1_inc NULL
 tc	scripting\source\provider				nmake	-	all	tc1_scriptingprovider tc1_inc NULL
 tc	scripting\source\basprov				nmake	-	all	tc1_scriptingbasprov tc1_inc NULL
+tc	scripting\source\vbaevents				nmake	-	all	tc1_scriptingvbaevents tc1_inc NULL
 tc	scripting\source\dlgprov				nmake	-	all	tc1_scriptingdlgprov tc1_inc NULL
 tc	scripting\source\stringresource			nmake	-	all	tc1_scriptingstringresource tc1_inc NULL
 tc	scripting\source\pyprov				nmake	-	all	tc1_scriptingpyprov tc1_inc NULL
@@ -10,4 +11,4 @@ tc	scripting\source\protocolhandler			nm
 tc	scripting\java						nmake	-	all	tc1_scriptingjava tc1_scriptingprovider tc1_scriptingprotocolhandler NULL
 tc	scripting\examples\java				nmake	-	all	tc1_scriptingexamplesjava tc1_scriptingjava  NULL
 tc	scripting\examples				nmake	-	all	tc1_scriptingexamples tc1_scriptingexamplesjava  tc1_inc NULL
-tc	scripting\util						nmake	-	all	tc1_scriptingutil tc1_scriptingprovider tc1_scriptingprotocolhandler tc1_scriptingbasprov tc1_scriptingstringresource tc1_scriptingpyprov tc1_scriptingjava tc1_scriptingexamplesjava tc1_scriptingexamples NULL
+tc	scripting\util						nmake	-	all	tc1_scriptingutil tc1_scriptingprovider tc1_scriptingprotocolhandler tc1_scriptingbasprov tc1_scriptingstringresource tc1_scriptingvbaevents tc1_scriptingpyprov tc1_scriptingjava tc1_scriptingexamplesjava tc1_scriptingexamples NULL
--- scripting/source/basprov/basprov.cxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/basprov/basprov.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -374,7 +374,33 @@ namespace basprov
             ::rtl::OUString::createFromAscii( "location" ) );
 
         sal_Int32 nIndex = 0;
-        ::rtl::OUString aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
+        // In some strange circumstances the Library name can have an 
+        // apparantly illegal '.' in it ( in imported VBA )
+     
+        BasicManager* pBasicMgr =  NULL;
+        if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
+        {
+            pBasicMgr = m_pDocBasicManager;
+        }
+        else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
+        {
+            pBasicMgr = m_pAppBasicManager;
+        }
+        rtl::OUString sProjectName;
+        if (  pBasicMgr )
+            sProjectName = pBasicMgr->GetName();
+
+        ::rtl::OUString aLibrary;
+        if ( sProjectName.getLength() && aDescription.match( sProjectName ) )
+        {
+            OSL_TRACE("LibraryName %s is part of the url %s",
+                rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr(),
+                rtl::OUStringToOString( aDescription, RTL_TEXTENCODING_UTF8 ).getStr() );
+            aLibrary = sProjectName;            
+            nIndex = sProjectName.getLength() + 1;
+        }
+        else
+            aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
         ::rtl::OUString aModule;
         if ( nIndex != -1 )
             aModule = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
@@ -384,15 +410,6 @@ namespace basprov
 
         if ( aLibrary.getLength() != 0 && aModule.getLength() != 0 && aMethod.getLength() != 0 && aLocation.getLength() != 0 )
         {
-            BasicManager* pBasicMgr =  NULL;
-            if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
-            {
-                pBasicMgr = m_pDocBasicManager;
-            }
-            else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
-            {
-                pBasicMgr = m_pAppBasicManager;
-            }
 
             if ( pBasicMgr )
             {
--- scripting/source/basprov/basscript.cxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/basprov/basscript.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -39,7 +39,10 @@
 #include <basic/sbmeth.hxx>
 #include <basic/basmgr.hxx>
 #include <com/sun/star/script/provider/ScriptFrameworkErrorType.hpp>
-
+#include "bcholder.hxx"
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <map>
 
 
@@ -48,6 +51,7 @@ using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
 
 extern ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any& aValue );
@@ -57,6 +61,10 @@ extern void unoToSbxValue( SbxVariable*
 namespace basprov
 {
 //.........................................................................
+#define BASSCRIPT_PROPERTY_ID_CALLER         1
+#define BASSCRIPT_PROPERTY_CALLER            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Caller" ) )
+
+#define BASSCRIPT_DEFAULT_ATTRIBS()       PropertyAttribute::BOUND | PropertyAttribute::TRANSIENT
 
     typedef ::std::map< sal_Int16, Any, ::std::less< sal_Int16 > > OutParamMap;
 
@@ -67,22 +75,28 @@ namespace basprov
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod )
-        :m_xMethod( xMethod )
+        : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( NULL )
         ,m_xDocumentScriptContext()
     {
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod,
-        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext )
-        :m_xMethod( xMethod )
+        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext ) : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( &documentBasicManager )
         ,m_xDocumentScriptContext( documentScriptContext )
     {
+	// 
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
@@ -91,6 +105,48 @@ namespace basprov
     }
 
     // -----------------------------------------------------------------------------
+    // XInterface
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XINTERFACE2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // XTypeProvider
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XTYPEPROVIDER2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // OPropertySetHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper& BasicScriptImpl::getInfoHelper(  )
+    {
+        return *getArrayHelper();
+    }
+
+    // -----------------------------------------------------------------------------
+    // OPropertyArrayUsageHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper* BasicScriptImpl::createArrayHelper(  ) const
+    {
+        Sequence< Property > aProps;
+        describeProperties( aProps );
+        return new ::cppu::OPropertyArrayHelper( aProps );
+    }
+
+    // -----------------------------------------------------------------------------
+    // XPropertySet
+    // -----------------------------------------------------------------------------
+
+    Reference< XPropertySetInfo > BasicScriptImpl::getPropertySetInfo(  ) throw (RuntimeException)
+    {
+        Reference< XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+        return xInfo;
+    }
+
+    // -----------------------------------------------------------------------------
     // XScript
     // -----------------------------------------------------------------------------
 
@@ -169,8 +225,14 @@ namespace basprov
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     aOldThisComponent = m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", makeAny( m_xDocumentScriptContext ) );
 
+            if ( m_caller.getLength() && m_caller[ 0 ].hasValue()  )
+            {
+                SbxVariableRef xCallerVar = new SbxVariable( SbxVARIANT );
+                unoToSbxValue( static_cast< SbxVariable* >( xCallerVar ), m_caller[ 0 ] );
+                nErr = m_xMethod->Call( xReturn, xCallerVar );
+            }
+            else
                 nErr = m_xMethod->Call( xReturn );
-
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", aOldThisComponent );
             }
--- scripting/source/basprov/basscript.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/basprov/basscript.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -31,12 +31,14 @@
 #ifndef SCRIPTING_BASSCRIPT_HXX
 #define SCRIPTING_BASSCRIPT_HXX
 
+#include "bcholder.hxx"
 #include <com/sun/star/script/provider/XScript.hpp>
 #include <com/sun/star/document/XScriptInvocationContext.hpp>
 #include <cppuhelper/implbase1.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
 #include <basic/sbmeth.hxx>
 
-
 class BasicManager;
 
 //.........................................................................
@@ -52,7 +54,11 @@ namespace basprov
         ::com::sun::star::script::provider::XScript > BasicScriptImpl_BASE;
 
 
-    class BasicScriptImpl : public BasicScriptImpl_BASE
+    class BasicScriptImpl : public BasicScriptImpl_BASE,
+                                public ::scripting_helper::OMutexHolder,
+                                public ::scripting_helper::OBroadcastHelperHolder,
+                                public ::comphelper::OPropertyContainer,
+                                public ::comphelper::OPropertyArrayUsageHelper< BasicScriptImpl >
     {
     private:
         SbMethodRef         m_xMethod;
@@ -60,6 +66,16 @@ namespace basprov
         BasicManager*       m_documentBasicManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::document::XScriptInvocationContext >
                             m_xDocumentScriptContext;
+        // hack, OPropertyContainer doesn't allow you to define a property of unknown
+        // type ( I guess because an Any can't contain an Any... I've always wondered why?
+	// as its not unusual to do that in corba )
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > m_caller;
+    protected:
+        // OPropertySetHelper
+        virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+        // OPropertyArrayUsageHelper
+        virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
 
     public:
         BasicScriptImpl(
@@ -74,6 +90,12 @@ namespace basprov
         );
         virtual ~BasicScriptImpl();
 
+        // XInterface
+        DECLARE_XINTERFACE()
+
+        // XTypeProvider
+        DECLARE_XTYPEPROVIDER()
+
         // XScript
         virtual ::com::sun::star::uno::Any SAL_CALL invoke(
             const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
@@ -83,6 +105,9 @@ namespace basprov
                     ::com::sun::star::script::provider::ScriptFrameworkErrorException, 
                     ::com::sun::star::reflection::InvocationTargetException,
                     ::com::sun::star::uno::RuntimeException );               
+        // XPropertySet
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) 
+            throw (::com::sun::star::uno::RuntimeException);
     };
 
 //.........................................................................
--- scripting/source/dlgprov/dlgevtatt.cxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/dlgprov/dlgevtatt.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -112,27 +112,30 @@ namespace dlgprov
     {
         protected:
         rtl::OUString msDialogCodeName;
+        rtl::OUString msDialogLibName;
         Reference<  script::XScriptListener > mxListener;
         virtual void firing_impl( const script::ScriptEvent& aScriptEvent, uno::Any* pRet );
         public:
-        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel );
+        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName );
     };
 
-    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel ) : DialogScriptListenerImpl( rxContext )
+    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName ) : DialogScriptListenerImpl( rxContext ), msDialogLibName( sDialogLibName )
     {
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
+        Sequence< Any > args(1);
         if ( xSMgr.is() )
         {
-            Sequence< Any > args(1);
             args[0] <<= xModel;
             mxListener = Reference< XScriptListener >( xSMgr->createInstanceWithArgumentsAndContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.EventListener" ) ), args, m_xContext ), UNO_QUERY );
         }
         if ( rxControl.is() )
         {
-            Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY );
             try
             {
+                Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY_THROW );
                 xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= msDialogCodeName;
+                xProps.set( mxListener, UNO_QUERY_THROW );
+                xProps->setPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Model") ), args[ 0 ] );
             } 
             catch ( Exception&  ) {}
         }
@@ -144,7 +147,7 @@ namespace dlgprov
         if ( aScriptEvent.ScriptType.equals( rtl::OUString::createFromAscii("VBAInterop") ) && mxListener.is() )
         {
             ScriptEvent aScriptEventCopy( aScriptEvent );
-            aScriptEventCopy.ScriptCode = msDialogCodeName;
+            aScriptEventCopy.ScriptCode = msDialogLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "." ) ) ).concat( msDialogCodeName );
             try
             {
                 mxListener->firing( aScriptEventCopy );
@@ -160,7 +163,7 @@ namespace dlgprov
     // DialogEventsAttacherImpl
     // =============================================================================
 
-    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener   )
+    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener, const rtl::OUString& sDialogLibName  )
         :m_xContext( rxContext )
     {
         // key listeners by protocol when ScriptType = 'Script'
@@ -173,7 +176,7 @@ namespace dlgprov
         listernersForTypes[ rtl::OUString::createFromAscii("vnd.sun.star.UNO") ] = new DialogUnoScriptListenerImpl( rxContext, rxModel, rxControl, rxHandler, rxIntrospect, bProviderMode );
         listernersForTypes[ rtl::OUString::createFromAscii("vnd.sun.star.script") ] = new DialogSFScriptListenerImpl( rxContext, rxModel );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-        listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel );
+        listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel, sDialogLibName );
 #endif
     }
 
@@ -193,7 +196,7 @@ namespace dlgprov
         return it->second; 
     }
 #ifdef FAKE_VBA_EVENT_SUPPORT
-    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl )
+    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl, rtl::OUString& sControlName )
     {
         Reference< XScriptEventsSupplier > xEventsSupplier;
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
@@ -201,7 +204,7 @@ namespace dlgprov
         {
             Reference< ooo::vba::XVBAToOOEventDescGen > xVBAToOOEvtDesc( xSMgr->createInstanceWithContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAToOOEventDesc" ) ), m_xContext ), UNO_QUERY );
             if ( xVBAToOOEvtDesc.is() )
-                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl ), UNO_QUERY );
+                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl, sControlName ), UNO_QUERY );
             
         }
         return xEventsSupplier;
@@ -324,6 +327,20 @@ namespace dlgprov
         // go over all objects
         const Reference< XInterface >* pObjects = Objects.getConstArray();
         sal_Int32 nObjCount = Objects.getLength();
+#ifdef FAKE_VBA_EVENT_SUPPORT
+        Reference< awt::XControl > xDlgControl( Objects[ nObjCount - 1 ], uno::UNO_QUERY ); // last object is the dialog	
+        rtl::OUString sDialogCodeName;
+        if ( xDlgControl.is() )
+        {
+            Reference< XPropertySet > xProps( xDlgControl->getModel(), UNO_QUERY );
+            try
+            {
+                xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sDialogCodeName;  
+            }
+            catch( Exception& ){}
+        }
+#endif
+	
         for ( sal_Int32 i = 0; i < nObjCount; ++i )
         {
             // We know that we have to do with instances of XControl.
@@ -338,7 +355,7 @@ namespace dlgprov
             Reference< XScriptEventsSupplier > xEventsSupplier( xControlModel, UNO_QUERY );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl ) );
+            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl, sDialogCodeName ) );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #endif
         }
@@ -399,7 +416,7 @@ namespace dlgprov
 
     void DialogAllListenerImpl::firing( const AllEventObject& Event ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( Event, NULL );
     }
@@ -409,7 +426,7 @@ namespace dlgprov
     Any DialogAllListenerImpl::approveFiring( const AllEventObject& Event ) 
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( Event, &aReturn );
@@ -653,7 +670,7 @@ namespace dlgprov
 
     void DialogScriptListenerImpl::firing( const ScriptEvent& aScriptEvent ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( aScriptEvent, NULL );
     }
@@ -663,7 +680,7 @@ namespace dlgprov
     Any DialogScriptListenerImpl::approveFiring( const ScriptEvent& aScriptEvent ) 
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( aScriptEvent, &aReturn );
--- scripting/source/dlgprov/dlgevtatt.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/dlgprov/dlgevtatt.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -46,6 +46,9 @@
 #include <com/sun/star/script/XScriptEventsSupplier.hpp>
 
 #include <hash_map>
+
+#define FAKE_VBA_EVENT_SUPPORT 1 
+
 //.........................................................................
 namespace dlgprov
 {
@@ -71,7 +74,7 @@ namespace dlgprov
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XEventAttacher > m_xEventAttacher;
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener > getScriptListenerForKey( const rtl::OUString& sScriptName ) throw ( ::com::sun::star::uno::RuntimeException );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl );
+        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, rtl::OUString& sCodeName );
 #endif
         void  SAL_CALL attachEventsToControl( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier >& events, const ::com::sun::star::uno::Any& Helper  );
     public:
@@ -81,7 +84,7 @@ namespace dlgprov
              const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& xHandler, 
              const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& xIntrospect, 
              bool bProviderMode, 
-             const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener );
+        	 const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener ,const rtl::OUString& sDialogLibName );
         virtual ~DialogEventsAttacherImpl();
 
         // XScriptEventsAttacher
--- scripting/source/dlgprov/dlgprov.cxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/dlgprov/dlgprov.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -196,7 +196,15 @@ static ::rtl::OUString aResourceResolver
         Reference< beans::XPropertySet > xDlgPropSet( xDialogModel, UNO_QUERY );
         xDlgPropSet->setPropertyValue( aDlgSrcUrlPropName, aDialogSourceURL );
 
-        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext );
+        // #TODO we really need to detect the source of the Dialog, is it
+        // located in the document or not. m_xModel need not be the location of
+        // the dialog. E.g. if the dialog was created from basic ( then we just
+        // can't tell  where its from ) 
+        // If we are happy to always substitute the form model for the awt
+        // one then maybe the presence of a document model is enough to trigger
+        // swapping out the models ( or perhaps we only want to do this 
+        // for vba mode ) there are a number of feasible and valid possibilities
+        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext, m_xModel );
         // Set resource property
         if( xStringResourceManager.is() )
         {
@@ -410,6 +418,7 @@ static ::rtl::OUString aResourceResolver
 
             if ( xISP.is() )
                 xInput = xISP->createInputStream();
+            msDialogLibName = sLibName;
         }
 
         // import dialog model
@@ -527,7 +536,7 @@ static ::rtl::OUString aResourceResolver
         const Reference< XControl >& rxControl,
         const Reference< XInterface >& rxHandler,
         const Reference< XIntrospectionAccess >& rxIntrospectionAccess,
-        bool bDialogProviderMode )
+		bool bDialogProviderMode, const rtl::OUString& sDialogLibName )
     {
         if ( rxControl.is() )
         {
@@ -551,7 +560,7 @@ static ::rtl::OUString aResourceResolver
 
                 Reference< XScriptEventsAttacher > xScriptEventsAttacher = new DialogEventsAttacherImpl
                     ( m_xContext, m_xModel, rxControl, rxHandler, rxIntrospectionAccess, 
-                      bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ) );
+					  bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ), msDialogLibName );
 
                 Any aHelper;
                 xScriptEventsAttacher->attachEvents( aObjects, Reference< XScriptListener >(), aHelper );
@@ -656,7 +665,10 @@ static ::rtl::OUString aResourceResolver
             aArguments[0] >>= m_xModel;
             m_BasicInfo.reset( new BasicRTLParams() );
             m_BasicInfo->mxInput.set( aArguments[ 1 ], UNO_QUERY_THROW );
-            m_BasicInfo->mxDlgLib.set( aArguments[ 2 ], UNO_QUERY_THROW );
+            // allow null mxDlgLib, a document dialog instantiated from 
+            // from application basic is unable to provide ( or find ) it's
+            // Library
+            aArguments[ 2 ] >>= m_BasicInfo->mxDlgLib;
             // leave the possibility to optionally allow the old dialog creation
             // to use the new XScriptListener ( which converts the old style macro
             // to a SF url )
@@ -731,7 +743,7 @@ static ::rtl::OUString aResourceResolver
             {
                 //xDialog = Reference< XDialog >( xCtrl, UNO_QUERY );
                 Reference< XIntrospectionAccess > xIntrospectionAccess = inspectHandler( xHandler );
-                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode );
+                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode, msDialogLibName );
             }
         }
 
--- scripting/source/dlgprov/dlgprov.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ scripting/source/dlgprov/dlgprov.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -84,9 +84,9 @@ namespace dlgprov
         ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >        m_xContext;
         ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >                 m_xModel;
 
-
+	rtl::OUString msDialogLibName;
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel > createDialogModel( const ::rtl::OUString& sURL );
-
+     
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl > createDialogControl( 
             const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& rxDialogModel,
             const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer >& xParent );
@@ -94,7 +94,7 @@ namespace dlgprov
         void attachControlEvents( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl >& rxControlContainer,
             const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler,
             const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& rxIntrospectionAccess,
-            bool bDialogProviderMode );
+			bool bDialogProviderMode, const rtl::OUString& );
         ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess > inspectHandler( 
             const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler );
     // helper methods
--- scripting/source/vbaevents/eventhelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ scripting/source/vbaevents/eventhelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,1075 @@
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+
+#include <ooo/vba/XVBAToOOEventDescGen.hpp>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/provider/XScriptProviderSupplier.hpp>
+
+#include <com/sun/star/drawing/XControlShape.hpp>
+
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/awt/KeyEvent.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+#include <com/sun/star/awt/XFixedText.hpp> //liuchen 2009-6-5
+#include <com/sun/star/awt/XTextComponent.hpp> //liuchen 2009-6-5
+#include <com/sun/star/awt/XComboBox.hpp> //liuchen 2009-6-18
+#include <com/sun/star/awt/XRadioButton.hpp> //liuchen 2009-7-30
+
+#include <msforms/ReturnInteger.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbx.hxx>
+#include <svx/msvbahelper.hxx>
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <comphelper/evtmethodhelper.hxx>
+
+#include <set>
+#include <list>
+#include <hash_map>
+#define ASYNC 0
+
+// primitive support for asynchronous handling of 
+// events from controls ( all event will be processed asynchronously 
+// in the application thread )
+#if ASYNC
+#include <vcl/svapp.hxx>
+#endif
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::script;
+using namespace ::com::sun::star::uno;
+using namespace ::ooo::vba;
+
+#define MAP_CHAR_LEN(x) ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(x))//liuchen 2009-6-8
+#define GET_TYPE(x) ::getCppuType((uno::Reference< x > *)0);
+
+// Some constants 
+const static rtl::OUString DELIM = rtl::OUString::createFromAscii( "::" );
+const static sal_Int32 DELIMLEN = DELIM.getLength();
+
+#if 0
+void dumpListeners( const Reference< beans::XIntrospection >& xIntrospection, const Reference<XInterface>& xIfc)
+{
+    Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+    if ( xIntrospection.is() )
+    {
+        xIntrospectionAccess = xIntrospection->inspect( 
+            makeAny( xIfc ) );
+        Sequence< Type > aControlListeners = 
+            xIntrospectionAccess->getSupportedListeners();
+        sal_Int32 nLength = aControlListeners.getLength();
+             
+        for ( sal_Int32 i = 0; i< nLength; ++i )
+        {
+            Type& listType = aControlListeners[ i ];
+            rtl::OUString sFullTypeName = listType.getTypeName();
+            rtl::OUString sTypeName = listType.getTypeName();
+            sal_Int32 lastDotIndex = -1;
+            if ( ( lastDotIndex = sFullTypeName.lastIndexOf( '.' ) ) > -1 )
+            {
+                sTypeName = sFullTypeName.copy( lastDotIndex + 1 );    
+            } 
+            Sequence< ::rtl::OUString > sMeths = comphelper::getEventMethodsForType( listType );    
+            sal_Int32 sMethLen = sMeths.getLength();
+            for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+            {
+                OSL_TRACE("**Listener [%d] Type[%s] Method[%s]",j,
+                    rtl::OUStringToOString( sTypeName, 
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString( sMeths[ j ], 
+                        RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+        }
+       
+    }
+}
+
+void dumpEvent( const ScriptEvent& evt )
+{
+    OSL_TRACE("dumpEvent: Source %s",
+        rtl::OUStringToOString( comphelper::anyToString( makeAny(evt.Source)), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ScriptType %s",
+        rtl::OUStringToOString( evt.ScriptType, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: ScriptCode %s",
+        rtl::OUStringToOString( evt.ScriptCode, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ListenerType %s",
+        rtl::OUStringToOString( evt.ListenerType.getTypeName(), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: Listener methodname %s",
+        rtl::OUStringToOString( evt.MethodName, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: arguments;");
+    sal_Int32 nLen = evt.Arguments.getLength();
+    for ( sal_Int32 index=0; index < nLen; ++index )
+    {
+        OSL_TRACE("\t [%d] %s", index, 
+        rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[ index ] ), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    }
+}
+
+#endif
+
+bool isKeyEventOk( awt::KeyEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !( isMouseEventOk(evt, params)) || 
+        (evt.ClickCount != 2) )
+        return Sequence< Any >(); 
+    // give back orig params, this will signal that the event is good
+    return params;
+}
+
+Sequence< Any > ooMouseEvtToVBAMouseEvt( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !isMouseEventOk(evt, params) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(4);
+
+    // Buttons
+    translatedParams[ 0 ] <<= evt.Buttons;
+    // Shift
+    translatedParams[ 1 ] <<= evt.Modifiers;
+    // X
+    translatedParams[ 2 ] <<= evt.X;
+    // Y
+    translatedParams[ 3 ] <<= evt.Y;
+    return translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    msforms::ReturnInteger keyCode;
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    return  translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(2);
+
+    msforms::ReturnInteger keyCode;
+    sal_Int8 shift = evt.Modifiers;
+
+    // #TODO check whether values from OOO conform to values generated from vba
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    translatedParams[1] <<= shift;
+    return  translatedParams;
+}
+
+typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
+
+//liuchen 2009-6-23
+//expand the "TranslateInfo" struct to support more kinds of events 
+struct TranslateInfo
+{
+    rtl::OUString sVBAName; //vba event name
+    Translator toVBA;       //the method to convert OO event parameters to VBA event parameters	
+	bool (*ApproveRule)(const ScriptEvent& evt, void* pPara); //this method is used to determine which types of controls should execute the event 
+	void *pPara;			//Parameters for the above approve method
+};
+
+
+typedef std::hash_map< rtl::OUString, 
+std::list< TranslateInfo >, 
+::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventInfoHash;
+
+//liuchen 2009-6-23
+struct TranslatePropMap
+{
+	rtl::OUString sEventInfo;   //OO event name
+	TranslateInfo aTransInfo;   
+};
+
+bool ApproveAll(const ScriptEvent& evt, void* pPara); //allow all types of controls to execute the event
+bool ApproveType(const ScriptEvent& evt, void* pPara); //certain types of controls should execute the event, those types are given by pPara
+bool DenyType(const ScriptEvent& evt, void* pPara);    //certain types of controls should not execute the event, those types are given by pPara
+bool DenyMouseDrag(const ScriptEvent& evt, void* pPara); //used for VBA MouseMove event when "Shift" key is pressed
+
+struct TypeList
+{
+	uno::Type* pTypeList;
+	int nListLength;
+};
+
+Type typeXFixedText = GET_TYPE(awt::XFixedText);
+Type typeXTextComponent = GET_TYPE(awt::XTextComponent);
+Type typeXComboBox = GET_TYPE(awt::XComboBox);
+Type typeXRadioButton = GET_TYPE(awt::XRadioButton);
+
+
+TypeList fixedTextList = {&typeXFixedText, 1};
+TypeList textCompList = {&typeXTextComponent, 1};
+TypeList radioButtonList = {&typeXRadioButton, 1};
+TypeList comboBoxList = {&typeXComboBox, 1};
+
+//this array stores the OO event to VBA event translation info
+static TranslatePropMap aTranslatePropMap_Impl[] = 
+{
+	// actionPerformed ooo event
+	{ MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Click"), NULL, ApproveAll, NULL } },	
+	{ MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Change"), NULL, DenyType, (void*)(&radioButtonList) } },  //liuchen 2009-7-30, OptionalButton_Change event is not the same as OptionalButton_Click event
+
+	// itemStateChanged ooo event
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Click"), NULL, ApproveType, (void*)(&comboBoxList) } },  //liuchen, add to support VBA ComboBox_Click event
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveType, (void*)(&radioButtonList) } }, //liuchen 2009-7-30, OptionalButton_Change event should be triggered when the button state is changed
+	
+	// changed ooo event
+	{ MAP_CHAR_LEN("changed"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },	
+
+	// focusGained ooo event
+	{ MAP_CHAR_LEN("focusGained"), { MAP_CHAR_LEN("_GotFocus"), NULL, ApproveAll, NULL } },
+
+	// focusLost ooo event
+	{ MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_LostFocus"), NULL, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_Exit"), NULL, ApproveType, (void*)(&textCompList) } }, //liuchen, add to support VBA TextBox_Exit event
+
+	// adjustmentValueChanged ooo event
+	{ MAP_CHAR_LEN("adjustmentValueChanged"), { MAP_CHAR_LEN("_Scroll"), NULL, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("adjustmentValueChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },
+
+	// textChanged ooo event
+	{ MAP_CHAR_LEN("textChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },
+
+	// keyReleased ooo event
+	{ MAP_CHAR_LEN("keyReleased"), { MAP_CHAR_LEN("_KeyUp"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } },
+
+	// mouseReleased ooo event
+	{ MAP_CHAR_LEN("mouseReleased"), { MAP_CHAR_LEN("_Click"), ooMouseEvtToVBAMouseEvt, ApproveType, (void*)(&fixedTextList) } }, //liuchen, add to support VBA Label_Click event
+	{ MAP_CHAR_LEN("mouseReleased"), { MAP_CHAR_LEN("_MouseUp"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+
+	// mousePressed ooo event
+	{ MAP_CHAR_LEN("mousePressed"), { MAP_CHAR_LEN("_MouseDown"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("mousePressed"), { MAP_CHAR_LEN("_DblClick"), ooMouseEvtToVBADblClick, ApproveAll, NULL } },
+
+	// mouseMoved ooo event	
+	{ MAP_CHAR_LEN("mouseMoved"), { MAP_CHAR_LEN("_MouseMove"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("mouseDragged"), { MAP_CHAR_LEN("_MouseMove"), ooMouseEvtToVBAMouseEvt, DenyMouseDrag, NULL } }, //liuchen, add to support VBA MouseMove event when the "Shift" key is pressed
+
+	// keyPressed ooo event
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyDown"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyPress"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } }
+};
+
+EventInfoHash& getEventTransInfo()
+{
+    static bool initialised = false;
+    static EventInfoHash eventTransInfo;
+    if ( !initialised )
+    {		
+		rtl::OUString sEventInfo = MAP_CHAR_LEN("");
+		TranslatePropMap* pTransProp = aTranslatePropMap_Impl;
+
+		int nCount = sizeof(aTranslatePropMap_Impl) / sizeof(aTranslatePropMap_Impl[0]);
+
+		int i = 0;
+		while (i < nCount)
+		{			
+			if (sEventInfo != pTransProp->sEventInfo)
+			{
+				sEventInfo = pTransProp->sEventInfo;
+				std::list< TranslateInfo > infoList;
+				do
+				{									
+					infoList.push_back( pTransProp->aTransInfo );
+                                        i++;
+					pTransProp++;
+				}
+				while( ( i < nCount ) && ( sEventInfo == pTransProp->sEventInfo ) );
+				eventTransInfo[sEventInfo] = infoList;
+			}
+		}		
+        initialised = true;
+    }
+    return eventTransInfo;
+}
+//liuchen 2009-6-23 end
+
+// Helper class
+
+class ScriptEventHelper
+{
+public:
+    ScriptEventHelper( const Reference< XInterface >& xControl );
+    Sequence< ScriptEventDescriptor > createEvents( const rtl::OUString& sCodeName );   
+    Sequence< rtl::OUString > getEventListeners();
+private:
+    Reference< XComponentContext > m_xCtx;
+    Reference< XInterface > m_xControl;
+};
+
+bool
+eventMethodToDescriptor( const ::rtl::OUString& rEventMethod, ScriptEventDescriptor& evtDesc, const ::rtl::OUString& sCodeName )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        // just fill in CodeName, when the event fires the other 
+	// info is gathered from the event source to determine what
+	// event handler we try to call
+        evtDesc.ScriptCode = sCodeName;
+        evtDesc.ListenerType = sTypeName;
+        evtDesc.EventMethod = sMethodName;
+
+        // set this it VBAInterop, ensures that it doesn't
+        // get persisted or shown in property editors
+        evtDesc.ScriptType = rtl::OUString::createFromAscii(
+            "VBAInterop" );	
+        return true;
+    }
+    return false;
+
+}
+
+ScriptEventHelper::ScriptEventHelper( const Reference< XInterface >& xControl ) : m_xControl( xControl )
+{
+    Reference < beans::XPropertySet > xProps(
+        ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+    m_xCtx.set( xProps->getPropertyValue( rtl::OUString(
+        RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+        uno::UNO_QUERY_THROW );
+}
+
+Sequence< rtl::OUString > 
+ScriptEventHelper::getEventListeners()
+{
+    Reference< lang::XMultiComponentFactory > xMFac( 
+        m_xCtx->getServiceManager(), UNO_QUERY );
+    std::list< rtl::OUString > eventMethods;
+
+    if ( xMFac.is() )
+    {
+        Reference< beans::XIntrospection > xIntrospection( 
+            xMFac->createInstanceWithContext( rtl::OUString( 
+                RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.beans.Introspection"  ) ), m_xCtx ), UNO_QUERY );
+#if 0
+        dumpListeners( xIntrospection, m_xControl );
+        dumpListeners( xIntrospection, m_xControl->getModel() );
+#endif 
+        Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+	if  ( xIntrospection.is() )
+	{
+            xIntrospectionAccess = xIntrospection->inspect( 
+                makeAny( m_xControl ) );
+            Sequence< Type > aControlListeners = 
+                xIntrospectionAccess->getSupportedListeners();
+            sal_Int32 nLength = aControlListeners.getLength();             
+            for ( sal_Int32 i = 0; i< nLength; ++i )
+            {
+                Type& listType = aControlListeners[ i ];
+                rtl::OUString sFullTypeName = listType.getTypeName();
+                Sequence< ::rtl::OUString > sMeths = 
+                    comphelper::getEventMethodsForType( listType );    
+                sal_Int32 sMethLen = sMeths.getLength();
+                for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+                {
+                    rtl::OUString sEventMethod = sFullTypeName;
+                    sEventMethod += DELIM;
+                    sEventMethod += sMeths[ j ];
+                    eventMethods.push_back( sEventMethod );
+                }
+            }
+            
+        }
+    }
+
+    Sequence< rtl::OUString > sEventMethodNames( eventMethods.size() );
+    std::list< rtl::OUString >::const_iterator it = eventMethods.begin();
+    rtl::OUString* pDest = sEventMethodNames.getArray();
+
+    for ( ; it != eventMethods.end(); ++it, ++pDest )
+        *pDest = *it;         
+
+    return sEventMethodNames;
+}
+
+Sequence< ScriptEventDescriptor > 
+ScriptEventHelper::createEvents( const rtl::OUString& sCodeName )
+{
+    Sequence< rtl::OUString > aControlListeners = getEventListeners();
+    rtl::OUString* pSrc = aControlListeners.getArray();
+    sal_Int32 nLength = aControlListeners.getLength();             
+
+    Sequence< ScriptEventDescriptor > aDest( nLength );
+    sal_Int32 nEvts = 0; 
+    for ( sal_Int32 i = 0; i< nLength; ++i, ++pSrc )
+    {
+        // from getListeners eventName is of form
+        // "com.sun.star.awt.XActionListener::actionPerformed"
+        // we need to strip "com.sun.star.awt." from that for form
+        // controls
+    	ScriptEventDescriptor evtDesc;
+        if ( eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            sal_Int32 dIndex = nEvts;
+            ++nEvts;
+            if ( nEvts > aDest.getLength() )
+                aDest.realloc( nEvts );// should never happen
+            aDest[ dIndex ] = evtDesc;
+        }
+    }
+    aDest.realloc( nEvts );
+
+    return aDest;
+}
+
+
+typedef ::cppu::WeakImplHelper1< container::XNameContainer > NameContainer_BASE;
+
+class ReadOnlyEventsNameContainer : public NameContainer_BASE
+{
+public:
+    ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName );
+    // XNameContainer
+
+    virtual void SAL_CALL insertByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::ElementExistException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& ) throw (::com::sun::star::container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+    }
+
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+                                                                                
+    // XNameAccess
+    virtual Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException);
+    virtual Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (RuntimeException);
+
+    // XElementAccess
+    virtual Type SAL_CALL getElementType(  ) throw (RuntimeException)
+    { return getCppuType(static_cast< const rtl::OUString * >(0) ); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (RuntimeException)
+    { return ( ( m_hEvents.size() > 0 ? sal_True : sal_False ) ); }
+private:
+
+typedef std::hash_map< rtl::OUString, Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventSupplierHash;
+
+    EventSupplierHash m_hEvents;
+};
+
+ReadOnlyEventsNameContainer::ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+{
+    const rtl::OUString* pSrc = eventMethods.getConstArray();
+    sal_Int32 nLen = eventMethods.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index, ++pSrc )
+    {
+        Any aDesc;
+        ScriptEventDescriptor evtDesc;
+        if (  eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            aDesc <<= evtDesc; 
+            m_hEvents[ *pSrc ] = aDesc;
+        }
+    }
+}
+
+Any SAL_CALL 
+ReadOnlyEventsNameContainer::getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException){
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        throw container::NoSuchElementException();
+    return it->second;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL 
+ReadOnlyEventsNameContainer::getElementNames(  ) throw (RuntimeException)
+{
+    Sequence< ::rtl::OUString > names(m_hEvents.size());
+    rtl::OUString* pDest = names.getArray();
+    EventSupplierHash::const_iterator it = m_hEvents.begin();
+    EventSupplierHash::const_iterator it_end = m_hEvents.end();
+    for ( sal_Int32 index = 0; it != it_end; ++index, ++pDest, ++it )
+        *pDest = it->first;
+    return names;
+}
+
+sal_Bool SAL_CALL 
+ReadOnlyEventsNameContainer::hasByName( const ::rtl::OUString& aName ) throw (RuntimeException)
+{
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        return sal_False;
+    return sal_True;
+}
+
+typedef ::cppu::WeakImplHelper1< XScriptEventsSupplier > EventsSupplier_BASE;
+
+class ReadOnlyEventsSupplier : public EventsSupplier_BASE
+{
+public:
+    ReadOnlyEventsSupplier( const Sequence< ::rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+    { m_xNameContainer = new ReadOnlyEventsNameContainer( eventMethods, sCodeName ); }
+    
+    // XScriptEventSupplier
+    virtual Reference< container::XNameContainer > SAL_CALL getEvents(  ) throw (RuntimeException){ return m_xNameContainer; }
+private:
+    Reference< container::XNameContainer > m_xNameContainer;
+};
+
+typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+
+#define EVENTLSTNR_PROPERTY_ID_MODEL         1
+#define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
+
+class EventListener : public EventListener_BASE
+    ,public ::comphelper::OMutexAndBroadcastHelper
+    ,public ::comphelper::OPropertyContainer
+    ,public ::comphelper::OPropertyArrayUsageHelper< EventListener >
+
+{
+    
+public:
+    EventListener( const Reference< XComponentContext >& rxContext );
+    // XEventListener
+    virtual void SAL_CALL disposing(const lang::EventObject& Source) throw( RuntimeException );
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
+    // XInitialization
+    virtual void SAL_CALL initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException);
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+    virtual void SAL_CALL setFastPropertyValue( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::beans::PropertyVetoException, ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OPropertyContainer::setFastPropertyValue( nHandle, rValue );
+	if ( nHandle == EVENTLSTNR_PROPERTY_ID_MODEL )
+            setShellFromModel();
+    }
+
+protected:
+    // OPropertySetHelper
+    virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+    // OPropertyArrayUsageHelper
+    virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
+private:
+#if ASYNC
+    DECL_LINK( OnAsyncScriptEvent, ScriptEvent* );
+#endif
+    void setShellFromModel();
+    void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
+
+    Reference< XComponentContext > m_xContext;
+    Reference< frame::XModel > m_xModel;
+    SfxObjectShell* mpShell;
+    
+};
+
+EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), mpShell( 0 )
+{
+    registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
+        beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
+
+}
+
+void
+EventListener::setShellFromModel()
+{
+	// reset mpShell
+	mpShell = 0;
+	SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+	while ( m_xModel.is() && pShell )
+	{
+		if ( pShell->GetModel() == m_xModel )
+		{
+			mpShell = pShell;
+			break;
+		}
+		pShell = SfxObjectShell::GetNext( *pShell );
+	}    
+}
+
+//XEventListener
+void
+EventListener::disposing(const lang::EventObject&)  throw( RuntimeException )
+{
+}
+
+//XScriptListener
+
+void SAL_CALL 
+EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
+{
+#if ASYNC
+    // needs some logic to check if the event handler is oneway or not
+    // if not oneway then firing_Impl otherwise... as below
+    acquire();
+    Application::PostUserEvent( LINK( this, EventListener, OnAsyncScriptEvent ), new ScriptEvent( evt ) );
+#else
+    firing_Impl( evt );
+#endif
+}
+
+#if ASYNC
+IMPL_LINK( EventListener, OnAsyncScriptEvent, ScriptEvent*, _pEvent )
+{
+	if ( !_pEvent )
+		return 1L;
+
+	{
+		// #FIXME if we enable ASYNC we probably need something like 
+		// below
+		//::osl::ClearableMutexGuard aGuard( m_aMutex );
+
+		//if ( !impl_isDisposed_nothrow() )
+		//	impl_doFireScriptEvent_nothrow( aGuard, *_pEvent, NULL );
+		firing_Impl( *_pEvent, NULL );
+	}
+
+	delete _pEvent;
+	// we acquired ourself immediately before posting the event
+	release();
+	return 0L;
+ }
+#endif 
+
+Any SAL_CALL 
+EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
+{
+    Any ret;
+    firing_Impl( evt, &ret );
+    return ret;
+}
+
+// XInitialization
+void SAL_CALL 
+EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
+{
+    if ( aArguments.getLength() == 1 )
+        aArguments[0] >>= m_xModel;
+    OSL_TRACE("EventListener::initialize() args %d m_xModel %d", aArguments.getLength(), m_xModel.is() );
+}
+
+// XInterface
+
+IMPLEMENT_FORWARD_XINTERFACE2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// XTypeProvider
+
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// OPropertySetHelper
+
+::cppu::IPropertyArrayHelper& 
+EventListener::getInfoHelper(  )
+{
+    return *getArrayHelper();
+}
+
+// OPropertyArrayUsageHelper
+
+::cppu::IPropertyArrayHelper* 
+EventListener::createArrayHelper(  ) const
+{
+    Sequence< beans::Property > aProps;
+    describeProperties( aProps );
+    return new ::cppu::OPropertyArrayHelper( aProps );
+}
+
+// XPropertySet
+Reference< beans::XPropertySetInfo > 
+EventListener::getPropertySetInfo(  ) throw (RuntimeException)
+{
+    Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+    return xInfo;
+}
+
+//liuchen 2009-6-23
+//decide if the control should execute the event
+bool ApproveAll(const ScriptEvent& evt, void* pPara)
+{
+	return true;
+}
+
+//for the given control type in evt.Arguments[0], look for if it appears in the type list in pPara
+bool FindControl(const ScriptEvent& evt, void* pPara)
+{
+	lang::EventObject aEvent;
+	evt.Arguments[ 0 ] >>= aEvent;
+	uno::Reference< uno::XInterface > xInterface( aEvent.Source, uno::UNO_QUERY );
+
+	TypeList* pTypeListInfo = static_cast<TypeList*>(pPara);
+	Type* pType = pTypeListInfo->pTypeList;
+	int nLen = pTypeListInfo->nListLength;
+
+	for (int i = 0; i < nLen; i++)
+	{
+		if ( xInterface->queryInterface( *pType ).hasValue() )
+		{
+			return true;
+		}
+		pType++;
+	}
+
+	return false;
+}
+
+//if the the given control type in evt.Arguments[0] appears in the type list in pPara, then approve the execution
+bool ApproveType(const ScriptEvent& evt, void* pPara)
+{
+	return FindControl(evt, pPara);
+}
+
+//if the the given control type in evt.Arguments[0] appears in the type list in pPara, then deny the execution
+bool DenyType(const ScriptEvent& evt, void* pPara)
+{
+	return !FindControl(evt, pPara);
+}
+
+//when mouse is moving, either the mouse button is pressed or some key is pressed can trigger the OO mouseDragged event,
+//the former should be denyed, and the latter allowed, only by doing so can the VBA MouseMove event when the "Shift" key is 
+//pressed can be correctly triggered
+bool DenyMouseDrag(const ScriptEvent& evt, void* pPara)
+{
+	awt::MouseEvent aEvent;
+	evt.Arguments[ 0 ] >>= aEvent;
+	if (aEvent.Buttons == 0 )
+	{
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+}
+
+
+
+//liuchen 2009-6-23
+// EventListener
+
+void
+EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeException)
+{
+	OSL_TRACE("EventListener::firing_Impl( FAKE VBA_EVENTS )");
+    static const ::rtl::OUString vbaInterOp =
+        ::rtl::OUString::createFromAscii("VBAInterop");
+
+    // let default handlers deal with non vba stuff
+    if ( !evt.ScriptType.equals( vbaInterOp ) )
+        return;
+    lang::EventObject aEvent;
+    evt.Arguments[ 0 ] >>= aEvent;
+	OSL_TRACE("evt.MethodName is  %s", rtl::OUStringToOString( evt.MethodName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Argument[0] is  %s", rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[0] ), RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Getting Control");
+    uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY_THROW );
+	OSL_TRACE("Getting properties");
+    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
+
+    rtl::OUString sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm") );
+	OSL_TRACE("Getting Name");
+
+    uno::Reference< awt::XDialog > xDlg( aEvent.Source, uno::UNO_QUERY );
+    if ( !xDlg.is() )
+        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+    //dumpEvent( evt );
+    EventInfoHash& infos = getEventTransInfo();
+    EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+    if ( eventInfo_it == it_end )
+    {
+        OSL_TRACE("Bogus event for %s",
+            rtl::OUStringToOString( evt.ScriptType, RTL_TEXTENCODING_UTF8 ).getStr() );
+        return;
+    }
+
+    uno::Reference< script::provider::XScriptProviderSupplier > xSPS( m_xModel, uno::UNO_QUERY );
+    uno::Reference< script::provider::XScriptProvider > xScriptProvider;
+    if ( xSPS.is() )
+        xScriptProvider =  xSPS->getScriptProvider();
+    if ( xScriptProvider.is() && mpShell )
+    {
+        std::list< TranslateInfo > matchingMethods;
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
+       
+        StarBASIC* pBasic = mpShell->GetBasic();
+        BasicManager* pBasicManager = mpShell->GetBasicManager();
+        rtl::OUString sProject;
+        rtl::OUString sScriptCode( evt.ScriptCode );
+	// dialogs pass their own library, presence of Dot determines that
+	if ( sScriptCode.indexOf( '.' ) == -1 )
+	{
+        	//'Project' is a better default but I want to force failures
+	        //rtl::OUString sMacroLoc = rtl::OUString::createFromAscii("Project");
+        	sProject = rtl::OUString::createFromAscii("Standard");
+
+        	if ( pBasicManager->GetName().Len() > 0 )
+            		sProject =  pBasicManager->GetName();
+	}
+	else
+	{
+		sal_Int32 nIndex = sScriptCode.indexOf( '.' );
+		sProject = sScriptCode.copy( 0, nIndex );
+                sScriptCode = sScriptCode.copy( nIndex + 1 );
+	}
+        rtl::OUString sMacroLoc = sProject;
+        sMacroLoc = sMacroLoc.concat(  rtl::OUString::createFromAscii(".") );
+        sMacroLoc = sMacroLoc.concat( sScriptCode ).concat( rtl::OUString::createFromAscii(".") );
+        
+        OSL_TRACE("sMacroLoc is %s", rtl::OUStringToOString( sMacroLoc, RTL_TEXTENCODING_UTF8 ).getStr() );
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            rtl::OUString sTemp = sName.concat( (*txInfo).sVBAName ); 
+            // see if we have a match for the handlerextension
+            // where ScriptCode is methodname_handlerextension 
+            rtl::OUString sToResolve = sMacroLoc.concat( sTemp );
+            OSL_TRACE("*** trying to invoke %s ",
+                rtl::OUStringToOString( sToResolve, RTL_TEXTENCODING_UTF8 ).getStr() );
+            ooo::vba::VBAMacroResolvedInfo aMacroResolvedInfo = ooo::vba::resolveVBAMacro( mpShell, sToResolve ); 
+            if ( aMacroResolvedInfo.IsResolved() )
+            {
+				//liuchen 2009-6-8
+				if (! txInfo->ApproveRule(evt, txInfo->pPara) )
+				{
+					continue;
+				}
+				//liuchen 2009-6-8
+                // !! translate arguments & emulate events where necessary 
+                Sequence< Any > aArguments;
+                if  ( (*txInfo).toVBA )
+                    aArguments = (*txInfo).toVBA( evt.Arguments );
+                else
+                    aArguments = evt.Arguments;
+                if ( aArguments.getLength() )
+                {
+                    // call basic event handlers for event
+
+                    // create script url
+                    rtl::OUString url = aMacroResolvedInfo.ResolvedMacro();
+                 
+                    OSL_TRACE("resolved script = %s",
+                        rtl::OUStringToOString( url, 
+                            RTL_TEXTENCODING_UTF8 ).getStr() );
+                    try
+                    {
+                        uno::Any aDummyCaller = uno::makeAny( rtl::OUString::createFromAscii("Error") );
+                        if ( pRet )
+                            ooo::vba::executeMacro( mpShell, url, aArguments, *pRet, aDummyCaller ); 
+                        else
+                        {
+                            uno::Any aRet;
+                            ooo::vba::executeMacro( mpShell, url, aArguments, aRet, aDummyCaller ); 
+                        }
+                    }
+                    catch ( uno::Exception& e )
+                    {
+                        OSL_TRACE("event script raised %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    }
+               } 
+           }
+       }
+    }
+}
+
+typedef ::cppu::WeakImplHelper1< XVBAToOOEventDescGen > VBAToOOEventDescGen_BASE;
+
+
+class VBAToOOEventDescGen : public VBAToOOEventDescGen_BASE
+{
+public:
+    VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext );
+
+    // XVBAToOOEventDescGen
+    virtual Sequence< ScriptEventDescriptor > SAL_CALL getEventDescriptions( const Reference< XInterface >& control, const rtl::OUString& sCodeName ) throw (RuntimeException);
+    virtual Reference< XScriptEventsSupplier > SAL_CALL getEventSupplier( const Reference< XInterface >& xControl,  const rtl::OUString& sCodeName ) throw (::com::sun::star::uno::RuntimeException);
+private:
+    Reference< XComponentContext > m_xContext;
+  
+};
+
+VBAToOOEventDescGen::VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext ):m_xContext( rxContext ) {}
+
+Sequence< ScriptEventDescriptor > SAL_CALL 
+VBAToOOEventDescGen::getEventDescriptions( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName ) throw (RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    return evntHelper.createEvents( sCodeName ); 
+}
+
+Reference< XScriptEventsSupplier > SAL_CALL 
+VBAToOOEventDescGen::getEventSupplier( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName  ) throw (::com::sun::star::uno::RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    Reference< XScriptEventsSupplier > xSupplier = 
+        new ReadOnlyEventsSupplier( 
+            evntHelper.getEventListeners(), sCodeName ) ;
+    return xSupplier;
+}
+
+// Component related 
+
+namespace evtlstner
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.EventListener" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+    Reference< XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new EventListener( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::evtlstner::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
+namespace ooevtdescgen 
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAToOOEventDesc" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new VBAToOOEventDescGen( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+    	const ::rtl::OUString strName( ::ooevtdescgen::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
--- scripting/source/vbaevents/makefile.mk.old	2010-03-03 16:59:35.000000000 +0100
+++ scripting/source/vbaevents/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,59 @@
+PRJ=..$/..
+
+PRJNAME=vbaevents
+TARGET=vbaevents
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vbaevents..."
+.ENDIF
+
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+        $(SLOTARGET)
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/eventhelper.obj
+
+SHL1TARGET= $(TARGET)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+
+SHL1VERSIONMAP=$(TARGET).map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                              
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(COMPHELPERLIB) \
+		$(SFXLIB) \
+		$(SVXMSFILTERLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+                                                                              
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
--- scripting/source/vbaevents/service.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ scripting/source/vbaevents/service.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,99 @@
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace evtlstner
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end evtlstner
+
+namespace ooevtdescgen
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end ooevtdescgen
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::evtlstner::create, ::evtlstner::getImplementationName,
+            ::evtlstner::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        {
+            ::ooevtdescgen::create, ::ooevtdescgen::getImplementationName,
+            ::ooevtdescgen::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
--- scripting/source/vbaevents/vbaevents.map.old	2010-03-03 16:59:35.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.map	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
--- scripting/source/vbaevents/vbaevents.xml.old	2010-03-03 16:59:35.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.xml	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>vbaevents</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>ooo.vba.EventListener</name>
+        <description>Event listener to handle ooo events and to translate them to calls to basic macros ala Button_Click etc.</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>ooo.vba.EventListener</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
--- sfx2/inc/sfx2/objsh.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sfx2/inc/sfx2/objsh.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -304,6 +304,7 @@ public:
     sal_Bool                    IsReadOnlyUI() const;
     void                        SetNoName();
     sal_Bool                    IsInModalMode() const;
+    sal_Bool                    IsInPrepareClose() const;
     sal_Bool					HasModalViews() const;
     sal_Bool                    IsHelpDocument() const;
 
@@ -407,8 +408,9 @@ public:
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
-    );
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0 );
 
     static ErrCode  CallXScript(
         const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& _rxScriptContext,
@@ -416,7 +418,9 @@ public:
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     /** adjusts the internal macro mode, according to the current security settings
--- sfx2/inc/sfx2/sfx.hrc.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/inc/sfx2/sfx.hrc	2010-03-03 16:59:35.000000000 +0100
@@ -395,8 +395,10 @@
 #define MID_DOCINFO_ENCRYPTED				 0x2c
 #define MID_DOCINFO_STATISTIC				 0x33
 #define MID_DOCINFO_CHARLOCALE				 0x34
-
-#define MID_LAST_USED_PROPID                 MID_DOCINFO_CHARLOCALE
+#define MID_CATEGORY                                     0x35
+#define MID_COMPANY                                      0x36
+#define MID_MANAGER                                      0x37
+#define MID_LAST_USED_PROPID              MID_MANAGER   
 
 // Config-Ids -----------------------------------------------------------
 
--- sfx2/inc/sfx2/sfxbasemodel.hxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/inc/sfx2/sfxbasemodel.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -1487,6 +1487,7 @@ protected:
     /* returns true if the document signatures are valid, otherwise false */
     sal_Bool hasValidSignatures() const;
 
+    void setDocumentProperties( const ::com::sun::star::uno::Reference< ::com::sun::star::document::XDocumentProperties >& );
 //________________________________________________________________________________________________________
 //	private methods
 //________________________________________________________________________________________________________
--- sfx2/source/appl/app.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/appl/app.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -761,7 +761,7 @@ IMPL_LINK( SfxApplication, GlobalBasicEr
     basicide_handle_basic_error pSymbol = (basicide_handle_basic_error) osl_getFunctionSymbol( handleMod, aSymbol.pData );
 
     // call basicide_handle_basic_error in basctl
-    long nRet = pSymbol( pStarBasic );
+    long nRet = pSymbol ? pSymbol( pStarBasic ) : 0;
 
     return nRet;
 }
--- sfx2/source/appl/appuno.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/appl/appuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -2285,6 +2285,16 @@ SFX2_DLLPUBLIC sal_Bool SAL_CALL compone
     xNewKey = xKey->createKey( aTempStr );
     xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.document.DocumentProperties") );
 
+
+    // writer compatable document properties
+    aImpl = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+    aImpl += comp_CompatWriterDocProps::_getImplementationName();
+
+    aTempStr = aImpl;
+    aTempStr += ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/UNO/SERVICES"));
+    xNewKey = xKey->createKey( aTempStr );
+    xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.writer.DocumentProperties") );
+
     return sal_True;
 }
 
@@ -2344,6 +2354,16 @@ SFX2_DLLPUBLIC void* SAL_CALL component_
             ::comp_SfxDocumentMetaData::_getImplementationName(),
             ::comp_SfxDocumentMetaData::_getSupportedServiceNames());
         }
+        if ( ::comp_CompatWriterDocProps::_getImplementationName().equals(
+                 ::rtl::OUString::createFromAscii( pImplementationName ) ) )
+        {
+            xFactory = ::cppu::createSingleComponentFactory(
+			::comp_CompatWriterDocProps::_create,
+			::comp_CompatWriterDocProps::_getImplementationName(),
+			::comp_CompatWriterDocProps::_getSupportedServiceNames());
+        }
+
+        // Factory is valid - service was found.
 
         // Factory is valid - service was found.
         if ( xFactory.is() )
--- sfx2/source/doc/SfxDocumentMetaData.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/doc/SfxDocumentMetaData.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -89,6 +89,10 @@
 #include <cstring>
 #include <limits>
 
+
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
+
 /**
  * This file contains the implementation of the service
  * com.sun.star.document.DocumentProperties.
@@ -298,12 +302,12 @@ public:
         const css::uno::Sequence< css::beans::StringPair >& i_rNamespaces)
         throw (css::uno::RuntimeException, css::xml::sax::SAXException);
 
-private:
+protected:
     SfxDocumentMetaData(SfxDocumentMetaData &); // not defined
     SfxDocumentMetaData& operator =(SfxDocumentMetaData &); // not defined
 
     virtual ~SfxDocumentMetaData() {}
-
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new SfxDocumentMetaData( context ); };
     const css::uno::Reference< css::uno::XComponentContext > m_xContext;
 
     /// for notification
@@ -378,6 +382,54 @@ private:
     void createUserDefined();
 };
 
+typedef ::cppu::ImplInheritanceHelper1< SfxDocumentMetaData, css::document::XCompatWriterDocProperties > CompatWriterDocPropsImpl_BASE;
+
+class CompatWriterDocPropsImpl : public CompatWriterDocPropsImpl_BASE
+{
+    rtl::OUString msManager;
+    rtl::OUString msCategory;
+    rtl::OUString msCompany;
+protected:
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new CompatWriterDocPropsImpl( context ); };
+public:
+    CompatWriterDocPropsImpl( css::uno::Reference< css::uno::XComponentContext > const & context) : CompatWriterDocPropsImpl_BASE( context ) {}
+// XCompatWriterDocPropsImpl
+    virtual ::rtl::OUString SAL_CALL getManager() throw (::com::sun::star::uno::RuntimeException) { return msManager; }
+    virtual void SAL_CALL setManager( const ::rtl::OUString& _manager ) throw (::com::sun::star::uno::RuntimeException) { msManager = _manager; }
+    virtual ::rtl::OUString SAL_CALL getCategory() throw (::com::sun::star::uno::RuntimeException){ return msCategory; }
+    virtual void SAL_CALL setCategory( const ::rtl::OUString& _category ) throw (::com::sun::star::uno::RuntimeException){ msCategory = _category; }
+    virtual ::rtl::OUString SAL_CALL getCompany() throw (::com::sun::star::uno::RuntimeException){ return msCompany; }
+    virtual void SAL_CALL setCompany( const ::rtl::OUString& _company ) throw (::com::sun::star::uno::RuntimeException){ msCompany = _company; }
+
+// XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getImplementationName();
+    }
+
+    virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        css::uno::Sequence< rtl::OUString > sServiceNames= getSupportedServiceNames();
+        sal_Int32 nLen = sServiceNames.getLength();
+        rtl::OUString* pIt = sServiceNames.getArray();
+        rtl::OUString* pEnd = ( pIt + nLen );
+        sal_Bool bRes = sal_False;
+        for ( ; pIt != pEnd; ++pIt )
+        {
+            if ( pIt->equals( ServiceName ) )
+            {
+                bRes = sal_True;
+                break;
+            }
+        }
+        return bRes;
+    }
+
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getSupportedServiceNames();
+    }
+};
 ////////////////////////////////////////////////////////////////////////////
 
 bool operator== (const css::util::DateTime &i_rLeft,
@@ -2123,7 +2175,7 @@ SfxDocumentMetaData::createClone()
     ::osl::MutexGuard g(m_aMutex);
     checkInit();
 
-    SfxDocumentMetaData *pNew = new SfxDocumentMetaData(m_xContext);
+    SfxDocumentMetaData *pNew = createMe(m_xContext);
 
     // NB: do not copy the modification listeners, only DOM
     css::uno::Reference<css::xml::dom::XDocument> xDoc = createDOM();
@@ -2289,6 +2341,32 @@ void SfxDocumentMetaData::createUserDefi
 
 
 // component helper namespace
+namespace comp_CompatWriterDocProps {
+
+    ::rtl::OUString SAL_CALL _getImplementationName() {
+        return ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
+            "CompatWriterDocPropsImpl"));
+}
+
+   css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames()
+   {
+        static css::uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+            aServiceNames.realloc( 1 );
+            aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.writer.DocumentProperties" ) ); 
+        }
+        return aServiceNames;
+   } 
+    css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        const css::uno::Reference< css::uno::XComponentContext > & context)
+            SAL_THROW((css::uno::Exception))
+    {
+        return static_cast< ::cppu::OWeakObject * >
+                    (new CompatWriterDocPropsImpl(context));
+    }
+
+}
 namespace comp_SfxDocumentMetaData {
 
 ::rtl::OUString SAL_CALL _getImplementationName() {
--- sfx2/source/doc/docinf.cxx.old	2009-10-07 15:07:00.000000000 +0200
+++ sfx2/source/doc/docinf.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -37,6 +37,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyContainer.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 #include <com/sun/star/uno/Exception.hpp>
 
 #include <rtl/ustring.hxx>
@@ -46,7 +47,6 @@
 #include <vcl/gdimtf.hxx>
 
 #include "oleprops.hxx"
-
 // ============================================================================
 
 // stream names
@@ -174,6 +174,28 @@ sal_uInt32 SFX2_DLLPUBLIC LoadOlePropert
             }
         }
     }
+
+    uno::Reference< document::XCompatWriterDocProperties > xWriterProps( i_xDocProps, uno::UNO_QUERY );
+    if ( xWriterProps.is() )
+    {
+        SfxOleSectionRef xBuiltin = aDocSet.GetSection( SECTION_BUILTIN );
+        if ( xBuiltin.get() )
+        {
+            try
+            {
+                String aStrValue;
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_MANAGER ) )
+                    xWriterProps->setManager( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_CATEGORY ) )
+                    xWriterProps->setCategory( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_COMPANY ) )
+                    xWriterProps->setCompany( aStrValue );
+            }
+            catch ( uno::Exception& )
+            {
+            }
+        }
+    }
 
     // return code
     return (nGlobError != ERRCODE_NONE) ? nGlobError : nDocError;
--- sfx2/source/doc/docmacromode.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/doc/docmacromode.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -41,6 +41,7 @@
 #include <com/sun/star/task/DocumentMacroConfirmationRequest.hpp>
 #include <com/sun/star/task/InteractionClassification.hpp>
 #include <com/sun/star/security/XDocumentDigitalSignatures.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
 /** === end UNO includes === **/
 
 #include <comphelper/componentcontext.hxx>
@@ -76,8 +77,10 @@ namespace sfx2
     using ::com::sun::star::document::XEmbeddedScripts;
     using ::com::sun::star::uno::UNO_SET_THROW;
     using ::com::sun::star::script::XLibraryContainer;
+    using ::com::sun::star::script::XLibraryQueryExecutable;
     using ::com::sun::star::container::XNameAccess;
     using ::com::sun::star::uno::UNO_QUERY_THROW;
+    using ::com::sun::star::uno::UNO_QUERY;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
 
@@ -365,11 +368,9 @@ namespace sfx2
                             // rid of the "Standard" thingie - this shouldn't be necessary
                             // anymore, should it?
                             // 2007-01-25 / frank.schoenheit@sun.com
-                            Reference < XNameAccess > xLib;
-                            Any aAny = xContainer->getByName( aStdLibName );
-                            aAny >>= xLib;
+						    Reference < XLibraryQueryExecutable > xLib( xContainer, UNO_QUERY );
                             if ( xLib.is() )
-                                bHasMacroLib = xLib->hasElements();
+							    bHasMacroLib = xLib->HasExecutableCode( aStdLibName );
                         }
                     }
                 }
--- sfx2/source/doc/objmisc.cxx.old	2010-01-21 01:00:49.000000000 +0100
+++ sfx2/source/doc/objmisc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1686,7 +1686,7 @@ namespace
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
     OSL_TRACE( "in CallXScript" );
     ErrCode nErr = ERRCODE_NONE;
@@ -1717,7 +1717,16 @@ ErrCode SfxObjectShell::CallXScript( con
 
         // obtain the script, and execute it
         Reference< provider::XScript > xScript( xScriptProvider->getScript( _rScriptURL ), UNO_QUERY_THROW );
-
+        if ( pCaller && pCaller->hasValue() )
+        {
+            Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY ); 
+            if ( xProps.is() )
+            {
+                Sequence< uno::Any > aArgs( 1 );
+                aArgs[ 0 ] = *pCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii("Caller"), uno::makeAny( aArgs ) );
+            }
+        }
         aRet = xScript->invoke( aParams, aOutParamIndex, aOutParam );
     }
     catch ( const uno::Exception& )
@@ -1727,7 +1736,7 @@ ErrCode SfxObjectShell::CallXScript( con
         nErr = ERRCODE_BASIC_INTERNAL_ERROR;
     }
 
-    if ( bCaughtException )
+	if ( bCaughtException && bRaiseError )
     {
         ::std::auto_ptr< VclAbstractDialog > pScriptErrDlg;
         SfxAbstractDialogFactory* pFact = SfxAbstractDialogFactory::Create();
@@ -1751,9 +1760,9 @@ ErrCode SfxObjectShell::CallXScript( con
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
-            aOutParam)
+            aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError, pCaller );
 }
 
 //-------------------------------------------------------------------------
--- sfx2/source/doc/objserv.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sfx2/source/doc/objserv.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -103,6 +103,7 @@
 #include <com/sun/star/embed/XTransactedObject.hpp>
 #include <com/sun/star/util/XCloneable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 
 #include "helpid.hrc"
 
@@ -507,6 +508,18 @@ void SfxObjectShell::ExecFile_Impl(SfxRe
         case SID_SAVEASDOC:
         case SID_SAVEDOC:
         {
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                        return;
+                    }
+                }
+            }
             //!! detaillierte Auswertung eines Fehlercodes
             SfxObjectShellRef xLock( this );
 
--- sfx2/source/doc/objuno.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/doc/objuno.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,6 +48,7 @@
 #include <com/sun/star/lang/Locale.hpp>
 #include <com/sun/star/util/XModifiable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 
 #include <unotools/configmgr.hxx>
 #include <tools/inetdef.hxx>
@@ -107,6 +108,9 @@ const SfxItemPropertyMapEntry* lcl_GetDo
         { "AutoloadEnabled" , 15, MID_DOCINFO_AUTOLOADENABLED, &::getBooleanCppuType(),   PROPERTY_UNBOUND, 0 },
         { "AutoloadSecs"    , 12, MID_DOCINFO_AUTOLOADSECS, &::getCppuType((const sal_Int32*)0),     PROPERTY_UNBOUND, 0 },
         { "AutoloadURL"     , 11, MID_DOCINFO_AUTOLOADURL, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Category"			, 8	, MID_CATEGORY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Company"			, 7	, MID_COMPANY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Manager"			, 7	, MID_MANAGER,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "CreationDate"    , 12, WID_DATE_CREATED,   &::getCppuType((const ::com::sun::star::util::DateTime*)0),PROPERTY_MAYBEVOID, 0 },
         { "DefaultTarget"   , 13, MID_DOCINFO_DEFAULTTARGET, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "Description"     , 11, MID_DOCINFO_DESCRIPTION, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
@@ -810,6 +814,22 @@ void SAL_CALL  SfxDocumentInfoObject::se
                     _pImp->m_xDocProps->setDefaultTarget(sTemp);
                 break;
 //            case WID_CONTENT_TYPE : // this is readonly!
+               case MID_CATEGORY:
+               case MID_MANAGER:
+               case MID_COMPANY:
+                   {
+                       uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                       if ( xWriterProps.is() ) 
+                       {
+                           if ( nHandle ==  MID_CATEGORY )
+                               xWriterProps->setCategory( sTemp );
+                           else if ( nHandle ==  MID_MANAGER )
+                               xWriterProps->setManager( sTemp );
+                           else
+                               xWriterProps->setCompany( sTemp );
+                           break;
+                       }
+                   }
             default:
                 break;
         }
@@ -1027,6 +1047,23 @@ void SAL_CALL  SfxDocumentInfoObject::se
         case MID_DOCINFO_CHARLOCALE:
             aValue <<= _pImp->m_xDocProps->getLanguage();
             break;
+        case MID_CATEGORY:
+        case MID_MANAGER:
+        case MID_COMPANY:
+            {
+                uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                if ( xWriterProps.is() ) 
+                {
+                    if ( nHandle ==  MID_CATEGORY )
+                        aValue <<= xWriterProps->getCategory();
+                    else if ( nHandle ==  MID_MANAGER )
+                        aValue <<= xWriterProps->getManager();
+                    else
+                        aValue <<= xWriterProps->getCompany();
+                        break;
+               }
+           }
+	
         default:
             aValue <<= ::rtl::OUString();
             break;
--- sfx2/source/doc/objxtor.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/doc/objxtor.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -137,6 +137,40 @@ DBG_NAME(SfxObjectShell)
 extern svtools::AsynchronLink* pPendingCloser;
 static WeakReference< XInterface > s_xCurrentComponent;
 
+void lcl_UpdateAppBasicDocVars(  const Reference< XInterface >& _rxComponent, bool bClear = false )
+{
+    BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
+    if ( pAppMgr )
+    {
+        uno::Reference< beans::XPropertySet > xProps( _rxComponent, uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            try
+            {
+                // ThisVBADocObj contains a PropertyValue
+                // Name  is ( the name of the VBA global to insert )
+                // Value is the Object to insert.
+                // ( note: at the moment the Value is actually the model so
+                // it strictly is not necessary, however we do intend to store
+                // not the model in basic but a custom object, so we keep this
+                // level of indirection for future proofing )
+                beans::PropertyValue aProp;
+                xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisVBADocObj") ) ) >>= aProp;
+                rtl::OString sTmp( rtl::OUStringToOString( aProp.Name, RTL_TEXTENCODING_UTF8 ) );
+                const char* pAscii = sTmp.getStr();
+                if ( bClear )
+                    pAppMgr->SetGlobalUNOConstant( pAscii, uno::makeAny( uno::Reference< uno::XInterface >() ) );
+                else
+                    pAppMgr->SetGlobalUNOConstant( pAscii, aProp.Value );
+    
+            }
+            catch( uno::Exception& e )
+            {
+            }
+        }
+    }
+}
+
 //=========================================================================
 
 
@@ -171,6 +205,7 @@ void SAL_CALL SfxModelListener_Impl::dis
     ::vos::OGuard aSolarGuard( Application::GetSolarMutex() );
     if ( SfxObjectShell::GetCurrentComponent() == _rEvent.Source )
     {
+        lcl_UpdateAppBasicDocVars( SfxObjectShell::GetCurrentComponent(), true );
         // remove ThisComponent reference from AppBasic
         SfxObjectShell::SetCurrentComponent( Reference< XInterface >() );
     }
@@ -539,6 +574,13 @@ SfxObjectShell* SfxObjectShell::Current(
     return pFrame ? pFrame->GetObjectShell() : 0;
 }
 
+//-------------------------------------------------------------------------
+
+sal_Bool SfxObjectShell::IsInPrepareClose() const
+{
+    return pImp->bInPrepareClose;
+}
+
 //------------------------------------------------------------------------
 
 struct BoolEnv_Impl
@@ -971,7 +1013,10 @@ void SfxObjectShell::SetCurrentComponent
     BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
     s_xCurrentComponent = _rxComponent;
     if ( pAppMgr )
+    {
+        lcl_UpdateAppBasicDocVars( _rxComponent );
         pAppMgr->SetGlobalUNOConstant( "ThisComponent", makeAny( _rxComponent ) );
+    }
 
 #if OSL_DEBUG_LEVEL > 0
     const char* pComponentImplName = _rxComponent.get() ? typeid( *_rxComponent.get() ).name() : "void";
--- sfx2/source/doc/oleprops.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ sfx2/source/doc/oleprops.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -83,6 +83,10 @@ const sal_Int32 PROPID_CREATED
 const sal_Int32 PROPID_LASTSAVED        = 13;
 const sal_Int32 PROPID_THUMBNAIL        = 17;
 
+// some Builtin properties
+const sal_Int32 PROPID_CATEGORY         = 0x2;
+const sal_Int32 PROPID_COMPANY          = 0xf;
+const sal_Int32 PROPID_MANAGER          = 0xe;
 // predefined codepages
 const sal_uInt16 CODEPAGE_UNKNOWN       = 0;
 const sal_uInt16 CODEPAGE_UNICODE       = 1200;
--- sfx2/source/doc/sfxbasemodel.cxx.old	2009-10-08 16:17:54.000000000 +0200
+++ sfx2/source/doc/sfxbasemodel.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -888,7 +888,15 @@ uno::Reference< document::XDocumentInfo
 
     return m_pData->m_xDocumentInfo;
 }
-
+void 
+SfxBaseModel::setDocumentProperties( const uno::Reference< document::XDocumentProperties >& rxNewDocProps )
+{
+	// object already disposed?
+    ::vos::OGuard aGuard( Application::GetSolarMutex() );
+    if ( impl_isDisposed() )
+        throw lang::DisposedException();
+    m_pData->m_xDocumentProperties.set(rxNewDocProps, uno::UNO_QUERY_THROW);
+}
 // document::XDocumentPropertiesSupplier:
 uno::Reference< document::XDocumentProperties > SAL_CALL
 SfxBaseModel::getDocumentProperties()
@@ -3608,15 +3616,23 @@ void SAL_CALL SfxBaseModel::switchToStor
         throw IOEXCEPTION(); // TODO:
 
     // the persistence should be switched only if the storage is different
-    if ( xStorage != m_pData->m_pObjectShell->GetStorage()
-      && !m_pData->m_pObjectShell->SwitchPersistance( xStorage ) )
-    {
-        sal_uInt32 nError = m_pData->m_pObjectShell->GetErrorCode();
-        throw task::ErrorCodeIOException( ::rtl::OUString(),
-                                            uno::Reference< uno::XInterface >(),
-                                            nError ? nError : ERRCODE_IO_GENERAL );
-    }
-
+    if ( xStorage != m_pData->m_pObjectShell->GetStorage() )
+	{
+        if ( !m_pData->m_pObjectShell->SwitchPersistance( xStorage ) )
+        {
+            sal_uInt32 nError = m_pData->m_pObjectShell->GetErrorCode();
+            throw task::ErrorCodeIOException( ::rtl::OUString(),
+                                                uno::Reference< uno::XInterface >(),
+                                                nError ? nError : ERRCODE_IO_GENERAL );
+        }
+        else
+        {
+            // UICfgMgr has a reference to the old storage, update it
+            uno::Reference< ui::XUIConfigurationStorage > xUICfgMgrStorage( getUIConfigurationManager(), uno::UNO_QUERY );
+            if ( xUICfgMgrStorage.is() )
+                xUICfgMgrStorage->setStorage( xStorage ); 
+        }
+	}
     m_pData->m_pObjectShell->Get_Impl()->bOwnsStorage = FALSE;
 }
 
--- sfx2/source/inc/SfxDocumentMetaData.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ sfx2/source/inc/SfxDocumentMetaData.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,5 +48,16 @@ css::uno::Reference< css::uno::XInterfac
 
 } // closing component helper namespace
 
+namespace comp_CompatWriterDocProps {
+
+namespace css = ::com::sun::star;
+
+// component and service helper functions:
+::rtl::OUString SAL_CALL _getImplementationName();
+css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames();
+css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        css::uno::Reference< css::uno::XComponentContext > const & context );
+
+}
 #endif
 
--- sfx2/source/view/viewprn.cxx.old	2009-10-08 16:17:55.000000000 +0200
+++ sfx2/source/view/viewprn.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,6 +32,7 @@
 #include "precompiled_sfx2.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <com/sun/star/view/PrintableState.hpp>
 #include <svtools/itempool.hxx>
 #ifndef _MSGBOX_HXX //autogen
@@ -68,6 +69,8 @@
 #include "view.hrc"
 #include "helpid.hrc"
 
+using namespace com::sun::star;
+
 TYPEINIT1(SfxPrintingHint, SfxHint);
 
 // -----------------------------------------------------------------------
@@ -449,6 +452,22 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
         case SID_SETUPPRINTER:
         case SID_PRINTER_NAME :
         {
+            if( nId == SID_PRINTDOC )
+            {
+				SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc )
+                {
+                    uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                    if( xVbaEventHelper.is() )
+                    {
+                        if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                        {
+                            rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                            return;
+                        }
+                    }
+                }
+            }
             // quiet mode (AppEvent, API call)
             SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
             bSilent = pSilentItem && pSilentItem->GetValue();
@@ -761,6 +780,15 @@ void SfxViewShell::ExecPrint_Impl( SfxRe
             if ( SID_PRINTDOCDIRECT == nId )
             {
                 SfxObjectShell* pDoc = GetObjectShell();
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                        return;
+                    }
+                }
                 bool bDetectHidden = ( !bSilent && pDoc );
                 if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
                     return;
--- svtools/inc/bindablecontrolhelper.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svtools/inc/bindablecontrolhelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SVTOOLS_INC_BINDABLECONTROL_HXX
+#define SVTOOLS_INC_BINDABLECONTROL_HXX
+
+#include "svtools/svtdllapi.h"
+
+#include <com/sun/star/frame/XModel.hpp>
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+    //====================================================================
+    //= GraphicAccess
+    //====================================================================
+    /** helper class for obtaining streams (which also can be used with the ImageProducer)
+        from a resource
+    */
+    class BindableControlHelper
+    {
+    private:
+        BindableControlHelper();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  void ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif // DBA14_SVTOOLS_INC_IMAGERESOURCEACCESS_HXX
+
--- svtools/inc/filterutils.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svtools/inc/filterutils.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef SVTOOLS_INC_FILTERUTILS_HXX
+#define SVTOOLS_INC_FILTERUTILS_HXX
+
+#include "svtools/svtdllapi.h"
+#include <com/sun/star/uno/RuntimeException.hpp>
+namespace svt
+{
+    class BinFilterUtils
+    {
+    private:
+        BinFilterUtils();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif 
--- svtools/prj/d.lst.old	2009-10-08 16:17:47.000000000 +0200
+++ svtools/prj/d.lst	2010-03-03 16:59:35.000000000 +0100
@@ -172,6 +172,8 @@ mkdir: %_DEST%\inc%_EXT%\svtools
 ..\inc\svtools\logindlg.hxx %_DEST%\inc%_EXT%\svtools\logindlg.hxx
 ..\inc\svtools\httpcook.hxx %_DEST%\inc%_EXT%\svtools\httpcook.hxx
 ..\inc\imageresourceaccess.hxx %_DEST%\inc%_EXT%\svtools\imageresourceaccess.hxx
+..\inc\bindablecontrolhelper.hxx %_DEST%\inc%_EXT%\svtools\bindablecontrolhelper.hxx
+..\inc\filterutils.hxx %_DEST%\inc%_EXT%\svtools\filterutils.hxx
 ..\inc\svtools\itemprop.hxx %_DEST%\inc%_EXT%\svtools\itemprop.hxx
 ..\inc\addresstemplate.hxx %_DEST%\inc%_EXT%\svtools\addresstemplate.hxx
 ..\inc\svtools\genericunodialog.hxx %_DEST%\inc%_EXT%\svtools\genericunodialog.hxx
--- svtools/source/misc/bindablecontrolhelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svtools/source/misc/bindablecontrolhelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "bindablecontrolhelper.hxx"
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+#ifndef C2U
+#define C2U(cChar)	rtl::OUString::createFromAscii(cChar)
+#endif
+
+    using namespace ::com::sun::star;
+
+bool lcl_isNamedRange( const rtl::OUString& sAddress, const uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
+
+
+void
+BindableControlHelper::ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    else if ( xBindable.is() ) // reset it
+        xBindable->setValueBinding( uno::Reference< form::binding::XValueBinding >() );
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+    else if (  xListEntrySink.is() ) // reset
+         xListEntrySink->setListEntrySource( uno::Reference< form::binding::XListEntrySource >()  );
+
+}
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
--- svtools/source/misc/filterutils.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svtools/source/misc/filterutils.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,56 @@
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "filterutils.hxx"
+#include <rtl/ustrbuf.hxx>
+
+namespace svt
+{
+//........................................................................
+
+    using namespace ::com::sun::star;
+
+    rtl::OUString lcl_createStringFromArray( const char* pcCharArr, sal_uInt32 nBufSize, bool bIsCompressed )
+    {
+        rtl::OUStringBuffer aBuffer;
+        if( bIsCompressed )
+        {
+            // buffer contains compressed Unicode, not encoded bytestring
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
+        }
+        else
+        {
+            // buffer contains Little-Endian Unicode
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
+            {
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
+                cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
+                aBuffer.setCharAt( nChar, cChar );
+            }
+        }
+        return aBuffer.makeStringAndClear();
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, false );
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, true );
+    }    
+//........................................................................
+} // namespace svt
+//........................................................................
+
--- svtools/source/misc/makefile.mk.old	2009-10-07 15:06:52.000000000 +0200
+++ svtools/source/misc/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -85,6 +85,8 @@ SLOFILES=\
     $(SLO)$/lockfilecommon.obj     \
     $(SLO)$/sharecontrolfile.obj   \
     $(SLO)$/documentlockfile.obj   \
+    $(SLO)$/bindablecontrolhelper.obj   \
+    $(SLO)$/filterutils.obj   \
     $(SLO)$/langtab.obj
 
 # --- Targets -------------------------------------------------------
--- svx/inc/svx/escherex.hxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/inc/svx/escherex.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,6 +47,7 @@
 #include <com/sun/star/drawing/Hatch.hpp>
 #include <svx/msdffdef.hxx>
 #include "svx/svxdllapi.h"
+#include <memory>
 
         /*Record Name       FBT-Value   Instance                  Contents                                                          Wrd Exl PPt Ver*/
 // In der Mickysoft-Doku heissen die msofbt... statt ESCHER_...
@@ -1306,6 +1307,19 @@ public:
                                     const Rectangle& rRect ) = 0;
 };
 
+class InteractionInfo
+{
+	bool 			mbHasInteraction;
+	std::auto_ptr<SvMemoryStream>		mpHyperlinkRecord;
+	InteractionInfo();
+public:
+	InteractionInfo( SvMemoryStream* pStream, bool bInteraction ) : mbHasInteraction( bInteraction )
+	{
+		mpHyperlinkRecord.reset( pStream );
+	}
+	bool	hasInteraction() { return mbHasInteraction; }
+	const std::auto_ptr< SvMemoryStream >&	getHyperlinkRecord() { return mpHyperlinkRecord; }
+};
 
 class EscherExHostAppData
 {
@@ -1313,14 +1327,17 @@ private:
         EscherExClientAnchor_Base*	pClientAnchor;
         EscherExClientRecord_Base*	pClientData;
         EscherExClientRecord_Base*	pClientTextbox;
+		InteractionInfo*		pInteractionInfo;
         // ignore single shape if entire pages are written
         BOOL						bDontWriteShape;
 
 public:
         EscherExHostAppData() : pClientAnchor(0), pClientData(0),
-                                pClientTextbox(0), bDontWriteShape(FALSE)
+								pClientTextbox(0), pInteractionInfo(0), bDontWriteShape(FALSE)
         {}
 
+		void SetInteractionInfo( InteractionInfo* p )
+			{ pInteractionInfo = p; }
         void SetClientAnchor( EscherExClientAnchor_Base* p )
             { pClientAnchor = p; }
         void SetClientData( EscherExClientRecord_Base* p )
@@ -1329,6 +1346,8 @@ public:
             { pClientTextbox = p; }
         void SetDontWriteShape( BOOL b )
             { bDontWriteShape = b; }
+		InteractionInfo* GetInteractionInfo() const
+			{ return pInteractionInfo; }
         EscherExClientAnchor_Base* GetClientAnchor() const
             { return pClientAnchor; }
         EscherExClientRecord_Base* GetClientData() const
--- svx/inc/svx/msocximex.hxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/inc/svx/msocximex.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,6 +32,7 @@
 
 #include <sot/storage.hxx>
 #include <tools/debug.hxx>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //!! no such defines in global namespaces - it will break other existing code that uses the same define!!
 //#ifndef C2U
@@ -290,7 +291,10 @@ public:
     bool mbVisible;
     UniString sName;
     UniString msToolTip;
+	UniString msParentName;
     OCX_FontData aFontData;
+    rtl::OUString msCtrlSource;
+    rtl::OUString msRowSource;
         SfxObjectShell *pDocSh;
 protected:
 
@@ -327,14 +331,13 @@ public:
     nMultiState(0), nValueLen(0), nCaptionLen(0), nVertPos(1), nHorzPos(7),
     nSpecialEffect(2), nIcon(0), nPicture(0), nAccelerator(0), nGroupNameLen(0),
     pValue(0), pCaption(0), pGroupName(0), nIconLen(0), pIcon(0),
-    nPictureLen(0), pPicture(0) {}
+    nPictureLen(0) {}
 
     ~OCX_ModernControl() {
         if (pValue) delete[] pValue;
         if (pCaption) delete[] pCaption;
         if (pGroupName) delete[] pGroupName;
         if (pIcon) delete[] pIcon;
-        if (pPicture) delete[] pPicture;
     }
     sal_Bool Read(SotStorageStream *pS);
 
@@ -415,7 +418,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32 nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
 };
 
@@ -464,6 +468,7 @@ public:
 
         bool bAutoSize;
         ::rtl::OUString sImageUrl;
+		com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
         sal_Bool Read(SotStorageStream *pS);
 
     using OCX_Control::Import; // to not hide the other two import methods
@@ -488,6 +493,8 @@ struct ContainerRecord
 
     ::rtl::OUString cName;
     ::rtl::OUString controlTip;
+    ::rtl::OUString sCtrlSource;
+    ::rtl::OUString sRowSource;
 
     sal_uInt32 nTop;
     sal_uInt32 nLeft;
@@ -502,54 +509,8 @@ typedef std::vector<OCX_Control*>::itera
 typedef std::vector<OCX_Control*>::const_iterator CtrlIteratorConst;
 typedef std::vector<OCX_Control*>  CtrlList;
 
-
-
-class RBGroup
-{
-    public:
-    RBGroup():mRBGroupPos(0){}
-    RBGroup(sal_uInt16& groupPos ):mRBGroupPos(groupPos){}
-    sal_Int16 tabPos() const { return mRBGroupPos; }
-    std::vector<OCX_Control*>::size_type numControls()
-    { return mpControls.size(); }
-    std::vector<OCX_Control*>& controls() { return mpControls; }
-
-    void add(OCX_Control* pRB);
-    private:
-    sal_uInt16 mRBGroupPos;
-    std::vector<OCX_Control*> mpControls;
-};
-
-typedef ::std::hash_map < ::rtl::OUString, RBGroup*, ::rtl::OUStringHash,
-    ::std::equal_to< ::rtl::OUString > > RBGroupHash;
-typedef std::vector<RBGroup*>::iterator GroupIterator;
-
 class OCX_OptionButton;
 
-class RBGroupManager
-{
-public:
-    RBGroupManager( String& defaultName );
-    ~RBGroupManager();
-
-    CtrlList insertGroupsIntoControlList( const CtrlList& sourceList );
-    void addRadioButton( OCX_OptionButton* pRButton );
-private:
-
-    void addSeperator( std::vector< OCX_Control* >& dest );
-    void copyList( std::vector< OCX_Control* >& src,
-                  std::vector< OCX_Control* >& dest,
-                  bool addGroupSeperator );
-
-    RBGroupHash rbGroups;
-    String mSDefaultName;
-    std::vector< RBGroup* > groupList;
-    sal_uInt16 numRadioButtons;
-};
-
-
-
-
 class OCX_ContainerControl : public OCX_Control
 {
 public:
@@ -575,8 +536,9 @@ public:
         SotStorageStreamRef getContainerStream() { return mContainerStream; }
 
         virtual void ProcessControl( OCX_Control* pControl, SvStorageStream* pS, ContainerRecord& rec );
-        bool createFromContainerRecord( const ContainerRecord& record,
+        bool createFromContainerRecord( ContainerRecord& record,
             OCX_Control*& );
+        SotStorageStreamRef getContainedControlsStream(){ return mContainedControlsStream; }
 protected:
         // This class not meant to be instantiated
         // needs to be subclassed
@@ -588,10 +550,10 @@ protected:
             OCX_Control* pParent = NULL );
         rtl::OUString createSubStreamName( const sal_uInt32& subStorageID );
 
-        RBGroupManager rbGroupMgr;
         com::sun::star::uno::Reference<
                 com::sun::star::container::XNameContainer > mxParent;
     std::vector<OCX_Control*> mpControls;
+        std::hash_map<sal_uInt16, sal_uInt16> mActiveXIDMap;
         SotStorageRef mContainerStorage;
         SotStorageStreamRef mContainerStream;
         SotStorageStreamRef mContainedControlsStream;
@@ -859,7 +821,6 @@ public:
     {
         delete[] pCaption;
         delete[] pIcon;
-        delete[] pPicture;
     }
 
     virtual sal_Bool Read(SvStorageStream *pS);
@@ -923,7 +884,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 private:
         com::sun::star::uno::Reference<
                 com::sun::star::uno::XComponentContext> mxCtx;
@@ -962,7 +924,8 @@ public:
     OCX_OptionButton() : OCX_ModernControl(rtl::OUString::createFromAscii("OptionButton"))
     {
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
-        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
         mnBackColor = 0x80000005L;
         mnForeColor = 0x80000008L;
         aFontData.SetHasAlign(TRUE);
@@ -1063,7 +1026,7 @@ class OCX_ComboBox : public OCX_ModernCo
 public:
     OCX_ComboBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ComboBox")){
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
-            msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlComboBoxModel");
+	        msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
         mnBackColor = 0x80000005;
         mnForeColor = 0x80000008;
         nBorderColor = 0x80000006;
@@ -1088,7 +1051,8 @@ class OCX_ListBox : public OCX_ModernCon
 public:
     OCX_ListBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ListBox")){
         msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
-        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
         mnBackColor = 0x80000005;
         mnForeColor = 0x80000008;
         nBorderColor = 0x80000006;
@@ -1116,7 +1080,7 @@ public:
     fEnabled(1), fLocked(0), fBackStyle(1), fWordWrap(0), fAutoSize(0),
         nCaptionLen(0), nVertPos(1), nHorzPos(7), nMousePointer(0), nPicture(0),
         nAccelerator(0), nIcon(0), pCaption(0), nIconLen(0), pIcon(0), nPictureLen(0),
-        pPicture(0), mbTakeFocus( true )
+        mbTakeFocus( true )
     {
             msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.CommandButton");
             msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlButtonModel");
@@ -1127,7 +1091,6 @@ public:
     ~OCX_CommandButton() {
         if (pCaption) delete[] pCaption;
         if (pIcon) delete[] pIcon;
-        if (pPicture) delete[] pPicture;
     }
     sal_Bool Read(SotStorageStream *pS);
 
@@ -1170,7 +1133,8 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
     bool        mbTakeFocus;
 
@@ -1288,7 +1252,7 @@ public:
 
     sal_uInt8 pPictureHeader[20];
     sal_uInt32  nPictureLen;
-    sal_uInt8 *pPicture;
+ 	sal_uInt8 *pPicture;
 
     static OCX_Control *Create() { return new OCX_Label;}
 
--- svx/inc/svx/mstoolbar.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svx/inc/svx/mstoolbar.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,334 @@
+#ifndef _MSTOOLBAR_HXX
+#define _MSTOOLBAR_HXX
+#include "svx/svxdllapi.h"
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/ImageType.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vcl/bitmap.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+namespace css = ::com::sun::star;
+
+class TBCHeader;
+
+
+class MSOCommandConvertor
+{
+public:
+    virtual ~MSOCommandConvertor() {}
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd ) = 0; 
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID ) = 0; 
+};
+
+class SfxObjectShell;
+
+class SVX_DLLPUBLIC CustomToolBarImportHelper
+{
+    struct iconcontrolitem
+    {
+        rtl::OUString sCommand;
+        css::uno::Reference< css::graphic::XGraphic > image;
+    };
+    std::vector< iconcontrolitem > iconcommands;
+    std::auto_ptr< MSOCommandConvertor > pMSOCmdConvertor;
+    css::uno::Reference< css::ui::XUIConfigurationManagerSupplier > m_xCfgSupp;
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xAppCfgMgr;
+    SfxObjectShell& mrDocSh;
+    void ScaleImage( css::uno::Reference< css::graphic::XGraphic >& xGraphic, long nNewSize );
+public:
+    CustomToolBarImportHelper( SfxObjectShell& rDocSh, const css::uno::Reference< css::ui::XUIConfigurationManager >& rxAppCfgMgr );
+
+    void setMSOCommandMap( MSOCommandConvertor* pCnvtr ) { pMSOCmdConvertor.reset( pCnvtr ); }
+    css::uno::Reference< css::ui::XUIConfigurationManager > getCfgManager();
+    css::uno::Reference< css::ui::XUIConfigurationManager > getAppCfgManager();
+
+
+    css::uno::Any createCommandFromMacro( const rtl::OUString& sCmd );
+
+    void addIcon( const css::uno::Reference< css::graphic::XGraphic >& xImage, const rtl::OUString& sString );
+    void applyIcons();
+    rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID );
+    SfxObjectShell& GetDocShell() { return mrDocSh; }
+    void showToolbar( const rtl::OUString& rName );
+    bool createMenu( const rtl::OUString& rName, const css::uno::Reference< css::container::XIndexAccess >& xMenuDesc, bool bPersist );
+};
+
+class SVX_DLLPUBLIC TBBase
+{
+friend class Indent;
+    static int nIndent; // num spaces to indent before printing 
+protected:
+    void indent_printf(FILE* fp, const char* format, ... );
+    sal_uInt32 nOffSet; // usually for debug we can store the offset in the stream to this record
+public:
+    TBBase() : nOffSet( 0 ) {}
+    virtual ~TBBase(){}
+    rtl::OUString readUnicodeString( SvStream* pS, sal_Int32 nChars );
+
+    virtual bool Read(SvStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+    sal_uInt32 GetOffset() { return nOffSet; }
+};
+
+class Indent
+{
+public:
+    Indent( bool binit = false ) 
+    { 
+        if ( binit )
+            init();
+        else
+            TBBase::nIndent = TBBase::nIndent + 2; 
+    }
+    ~Indent() { TBBase::nIndent = TBBase::nIndent - 2; }
+    void init() { TBBase::nIndent = 0; }
+};
+
+
+class SVX_DLLPUBLIC WString : public TBBase
+{
+    rtl::OUString sString;
+
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SvStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class SVX_DLLPUBLIC TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString getOnAction();
+};
+
+class SVX_DLLPUBLIC TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControlData( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >& );
+    rtl::OUString CustomText() { return customText.getString(); }
+    rtl::OUString DescriptionText() { return descriptionText.getString(); }
+    rtl::OUString Tooltip() { return tooltip.getString(); }
+};
+
+class SVX_DLLPUBLIC TBCBitMap : public TBBase
+{
+friend class TBCBSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+    Bitmap mBitMap;
+    int size;
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    Bitmap& getBitMap(); 
+};
+
+class SVX_DLLPUBLIC TBCMenuSpecific : public TBBase
+{
+    sal_Int32 tbid;
+    boost::shared_ptr< WString > name; //exist only if tbid equals 0x00000001
+public:
+    TBCMenuSpecific();
+    ~TBCMenuSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString Name();
+};
+
+class SVX_DLLPUBLIC TBCCDData : public TBBase
+{
+    sal_Int16 cwstrItems; //Signed integer that specifies the number of items in wstrList. MUST be positive.
+    std::vector< WString > wstrList;  // Zero-based index array of WString structures. Number of elements MUST be equal to cwstrItems.
+    sal_Int16 cwstrMRU; // Signed integer that specifies the number of most recently used string
+    sal_Int16 iSel ; // Signed integer that specifies the zero-based index of the selected item in the wstrList field. MUST be equal to 0xFFFF (-1) or greater than or equal to 0x0000.
+    sal_Int16 cLines; // Signed integer that specifies the suggested number of lines that the toolbar control will display at any time when displaying the elements of wstrList of available items. 
+    sal_Int16 dxWidth; // Signed integer that specifies the width in pixels that the interior of the dropdown has. This excludes the width of the toolbar control border and scroll bar.
+    WString wstrEdit; //Structure of type WString. Editable text for editable area of the ComboBox toolbar control.
+
+public:
+    TBCCDData();
+    ~TBCCDData();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCComboDropdownSpecific : public TBBase
+{
+    boost::shared_ptr< TBCCDData > data;
+public:
+    TBCComboDropdownSpecific( const TBCHeader& header );
+    TBCComboDropdownSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    boost::shared_ptr< TBCBitMap > icon; // optional
+    boost::shared_ptr< TBCBitMap > iconMask; // optional
+    boost::shared_ptr< sal_uInt16 > iBtnFace; // optional
+    boost::shared_ptr< WString > wstrAcc; // optional
+   
+public:
+    TBCBSpecific();
+    ~TBCBSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    // #TODO just add a getGraphic member here
+    TBCBitMap* getIcon();
+    TBCBitMap* getIconMask();
+    sal_uInt16* getBtnFace() { return iBtnFace.get(); }
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+class SVX_DLLPUBLIC TBCHeader : public TBBase
+{
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    boost::shared_ptr< sal_uInt16 > width;  //optional
+    boost::shared_ptr< sal_uInt16 > height; //optional
+
+public:
+    TBCHeader();
+    ~TBCHeader();
+    sal_uInt8 getTct() const { return tct; }
+    sal_uInt16 getTcID() const { return tcid; }
+    bool isVisible() { return !( bFlagsTCR & 0x1 ); }
+    bool isBeginGroup() { return ( bFlagsTCR & 0x2 ); }
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_uInt32 getTbct() { return tbct; };
+};
+
+class SVX_DLLPUBLIC TBCData : public TBBase
+{
+    TBCHeader rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    boost::shared_ptr< TBBase > controlSpecificInfo; // can be one of TBCBSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header );
+    ~TBCData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >&, bool& bBeginGroup, bool bIsMenuBar );
+    TBCGeneralInfo& getGeneralInfo() { return controlGeneralInfo; }
+    TBCMenuSpecific* getMenuSpecific();
+};
+
+class SVX_DLLPUBLIC TB : public TBBase
+{
+    sal_uInt8 bSignature;// Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_uInt8 bVersion; // Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; // Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid;// Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr;// Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault;// Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name
+public:
+    TB();
+    ~TB(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_Int16 getcCL(){ return cCL; }
+    WString& getName(){ return name; }
+    bool IsEnabled();
+    bool IsMenuToolbar(){ return ( ( ltbtr & 0x2000000 ) == 0x2000000 ); }
+    bool NeedsPositioning();
+};
+
+class SVX_DLLPUBLIC SRECT : public TBBase
+{
+public:
+    SRECT() : left(0), top(0), right(0), bottom(0) {}
+    sal_Int16 left;
+    sal_Int16 top;
+    sal_Int16 right;
+    sal_Int16 bottom;
+    bool Read( SvStream* pS ) { *pS >> left >> top >> right >> bottom; return true; }
+    void Print( FILE* fo );
+};
+
+typedef cppu::WeakImplHelper1< css::container::XIndexContainer > PropertyValueIndexContainer_BASE;
+
+class SVX_DLLPUBLIC TBVisualData : public TBBase
+{
+    sal_Int8 tbds;
+    sal_Int8 tbv;
+    sal_Int8 tbdsDock;
+    sal_Int8 iRow;
+
+    SRECT rcDock;
+    SRECT rcFloat;
+
+public:
+    TBVisualData();
+    ~TBVisualData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+#endif
--- svx/inc/svx/msvbahelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ svx/inc/svx/msvbahelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -56,3 +56,61 @@ namespace ooo { namespace vba
 } }
 
 #endif
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef _MSVBAHELPER_HXX
+#define _MSVBAHELPER_HXX
+
+#include <sfx2/objsh.hxx>
+#include "svx/svxdllapi.h"
+
+namespace ooo { namespace vba 
+{
+    class SVX_DLLPUBLIC VBAMacroResolvedInfo
+    {
+        SfxObjectShell* mpDocContext;
+        bool mbFound;
+        String msResolvedMacro;
+        public:
+        VBAMacroResolvedInfo() : mpDocContext(NULL), mbFound( false ){}
+        void SetResolved( bool bRes ) { mbFound = bRes; }
+        bool IsResolved() { return mbFound; }
+        void SetMacroDocContext(SfxObjectShell* pShell )  { mpDocContext = pShell; }
+        SfxObjectShell* MacroDocContext() { return mpDocContext; }
+        String ResolvedMacro() { return msResolvedMacro; }
+        void SetResolvedMacro(const String& sMacro ) { msResolvedMacro = sMacro; }
+    };
+
+    SVX_DLLPUBLIC String makeMacroURL( const String& sMacroName );
+    SVX_DLLPUBLIC  VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUString& sMod, bool bSearchGlobalTemplates = false );
+    SVX_DLLPUBLIC sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, com::sun::star::uno::Sequence< com::sun::star::uno::Any >& aArgs, com::sun::star::uno::Any& aRet, const com::sun::star::uno::Any& aCaller );
+} }
+
+#endif
--- svx/inc/svxmsbas.hxx.old	2009-10-07 15:07:00.000000000 +0200
+++ svx/inc/svxmsbas.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -35,6 +35,8 @@
 #include "svx/svxdllapi.h"
 
 #include <sot/storage.hxx>
+#include <map>
+#include <hash_map>
 
 class SfxObjectShell;
 
@@ -53,8 +55,17 @@ class SfxObjectShell;
  * probably what the user expects to see when viewing the code
  */
 
+typedef std::hash_map< sal_Int32, String >  ObjIdToName;
+
+typedef std::map< String, ObjIdToName >  ControlAttributeInfo;
+
+class VBA_Impl;
+
 class SVX_DLLPUBLIC SvxImportMSVBasic
-{
+{ 
+	ControlAttributeInfo m_ModuleNameToObjIdHash;
+	void extractAttribute( const String& rAttribute, const String& rModName );
+
 public:
     SvxImportMSVBasic( SfxObjectShell &rDocS, SotStorage &rRoot,
                         BOOL bImportCode = TRUE, BOOL bCopyStorage = TRUE )
@@ -65,20 +76,24 @@ public:
     // 0 - nothing has done
     // bit 0 = 1 -> any code is imported to the SO-Basic
     // bit 1 = 1 -> the VBA - storage is copy to the ObjectShell storage
-    int Import( const String& rStorageName, const String &rSubStorageName,
+	int Import( const String& rStorageName, const String &rSubStorageName, 
                 BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
+	int Import( const String& rStorageName, const String &rSubStorageName, 
+				const std::vector< String >& codeNames, BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
 
     // only for the export - copy or delete the saved VBA-macro-storage
     // form the ObjectShell
     // - returns a warning code if a modified basic exist, in all other
     //   cases return ERRCODE_NONE.
     ULONG SaveOrDelMSVBAStorage( BOOL bSaveInto, const String& rStorageName );
-
     // check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
     // If it exist, then return the WarningId for loosing the information.
+
+        const ControlAttributeInfo& ControlNameForObjectId(){ return m_ModuleNameToObjIdHash; }
     static ULONG GetSaveWarningOfMSVBAStorage( SfxObjectShell &rDocS );
 
     static String GetMSBasicStorageName();
+        rtl::OUString GetVBAProjectName() { return msProjectName; }
 private:
     SotStorageRef xRoot;
     SfxObjectShell &rDocSh;
@@ -86,12 +101,16 @@ private:
     BOOL bCopy;
 
     SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
-                          const String &rSubStorageName,
-                          BOOL bAsComment, BOOL bStripped);
+                                                  const String &rSubStorageName,
+	                                              const std::vector< String >&,
+                                                  BOOL bAsComment, BOOL bStripped );
     SVX_DLLPRIVATE bool ImportForms_Impl(const String& rStorageName, 
-        const String &rSubStorageName);
+		const String &rSubStorageName, BOOL bVBAMode );
     SVX_DLLPRIVATE BOOL CopyStorage_Impl( const String& rStorageName,
                            const String &rSubStorageName);
+        rtl::OUString msProjectName;
+	SVX_DLLPRIVATE BOOL ImportCode_Impl( VBA_Impl&, const std::vector< String >&, BOOL, BOOL );
+	SVX_DLLPRIVATE bool ImportForms_Impl( VBA_Impl&, const String&, const String&, BOOL);
 };
 
 #endif
--- svx/prj/d.lst.old	2010-03-03 16:59:33.000000000 +0100
+++ svx/prj/d.lst	2010-03-03 16:59:35.000000000 +0100
@@ -658,6 +658,8 @@ mkdir: %_DEST%\inc%_EXT%\svx\sdr\table
 ..\inc\svx\selectioncontroller.hxx %_DEST%\inc%_EXT%\svx\selectioncontroller.hxx
 ..\inc\svx\helperhittest3d.hxx %_DEST%\inc%_EXT%\svx\helperhittest3d.hxx
 ..\inc\svx\optimprove.hxx %_DEST%\inc%_EXT%\svx\optimprove.hxx
+..\inc\svx\mstoolbar.hxx %_DEST%\inc%_EXT%\svx\mstoolbar.hxx
+..\inc\svx\msvbahelper.hxx %_DEST%\inc%_EXT%\svx\msvbahelper.hxx
 ..\inc\svx\msvbahelper.hxx %_DEST%\inc%_EXT%\svx\msvbahelper.hxx
 
 ..\%__SRC%\bin\*-layout.zip %_DEST%\pck%_EXT%\*.*
--- svx/source/cui/cfg.cxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/source/cui/cfg.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -5724,7 +5724,7 @@ bool SvxIconSelectorDialog::ReplaceGraph
                 if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
                 {
                     BitmapEx aBitmap = aImage.GetBitmapEx();
-                    BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
                     aImage = Image( aBitmapex);
                 }
                 aTbSymbol.InsertItem( nId,aImage, aURL, 0, 0 ); //modify
@@ -5888,7 +5888,7 @@ bool SvxIconSelectorDialog::ImportGraphi
                 if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
                 {
                     BitmapEx aBitmap = aImage.GetBitmapEx();
-                    BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
                     aImage = Image( aBitmapex);
                 }
                 if ( bOK && !!aImage )
--- svx/source/form/fmscriptingenv.cxx.old	2009-10-07 15:07:01.000000000 +0200
+++ svx/source/form/fmscriptingenv.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -39,6 +39,8 @@
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XInterfaceMethodTypeDescription.hpp>
 #include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/awt/XControl.hpp>
 /** === end UNO includes === **/
 #include <tools/diagnose_ex.h>
 #include <cppuhelper/implbase1.hxx>
@@ -74,6 +76,9 @@ namespace svxform
     using ::com::sun::star::uno::Exception;
     using ::com::sun::star::uno::Sequence;
     using ::com::sun::star::uno::XInterface;
+    using ::com::sun::star::lang::EventObject;
+    using ::com::sun::star::awt::XControl;
+    using ::com::sun::star::beans::XPropertySet;
     /** === end UNO using === **/
 
     class FormScriptingEnvironment;
@@ -236,6 +241,11 @@ namespace svxform
     void SAL_CALL FormScriptListener::firing( const ScriptEvent& _rEvent ) throw (RuntimeException)
     {
         ::osl::ClearableMutexGuard aGuard( m_aMutex );
+       static const ::rtl::OUString vbaInterOp =
+           ::rtl::OUString::createFromAscii("VBAInterop");
+       if ( _rEvent.ScriptType.equals(vbaInterOp) )
+           return; // not handled here
+	
         if ( impl_isDisposed_nothrow() )
             return;
 
@@ -411,8 +421,19 @@ namespace svxform
         {
             Sequence< sal_Int16 > aOutArgsIndex;
             Sequence< Any > aOutArgs;
-
-            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs );
+            EventObject aEvent;
+            Any aCaller;
+            if ( ( _rArguments.getLength() > 0 ) && ( _rArguments[ 0 ] >>= aEvent ) )
+            {
+                try
+                {
+                    Reference< XControl > xControl( aEvent.Source, UNO_QUERY_THROW );
+                    Reference< XPropertySet > xProps( xControl->getModel(), UNO_QUERY_THROW );
+                    aCaller = xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) );
+                }
+                catch( Exception& ) {}
+            }
+            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs, true, aCaller.hasValue() ? &aCaller : 0 );
         }
 
         //................................................................
--- svx/source/form/fmtools.cxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/source/form/fmtools.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -103,7 +103,7 @@
 #include <comphelper/extract.hxx>
 #include <comphelper/uno3.hxx>
 #include <connectivity/dbexception.hxx>
-#include <comphelper/extract.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <cppuhelper/typeprovider.hxx>
 #include <algorithm>
 #include <rtl/logfile.hxx>
@@ -720,37 +720,6 @@ sal_Int16 getControlTypeByObject(const R
     return ::rtl::OUString();
 }
 //------------------------------------------------------------------------------
-Sequence< ::rtl::OUString> getEventMethods(const Type& type)
-{
-    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "svx", "Ocke.Janssen@sun.com", "fmtools::getEventMethods" );
-    typelib_InterfaceTypeDescription *pType=0;
-    type.getDescription( (typelib_TypeDescription**)&pType);
-
-    if(!pType)
-        return Sequence< ::rtl::OUString>();
-
-    Sequence< ::rtl::OUString> aNames(pType->nMembers);
-    ::rtl::OUString* pNames = aNames.getArray();
-    for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
-    {
-        // the decription reference
-        typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-        // the description for the reference
-        typelib_TypeDescription* pMemberDescription = NULL;
-        typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
-        if (pMemberDescription)
-        {
-            typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-                reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-            *pNames = pRealMemberDescription->pMemberName;
-        }
-    }
-    typelib_typedescription_release( (typelib_TypeDescription *)pType );
-    return aNames;
-}
-
-
-//------------------------------------------------------------------------------
 void TransferEventScripts(const Reference< ::com::sun::star::awt::XControlModel>& xModel, const Reference< ::com::sun::star::awt::XControl>& xControl,
     const Sequence< ::com::sun::star::script::ScriptEventDescriptor>& rTransferIfAvailable)
 {
@@ -824,7 +793,8 @@ void TransferEventScripts(const Referenc
                     continue;
 
                 // now check the methods
-                Sequence< ::rtl::OUString> aMethodsNames = getEventMethods(*pCurrentListeners);
+				Sequence< ::rtl::OUString> aMethodsNames = ::comphelper::getEventMethodsForType(*pCurrentListeners);
+
                 const ::rtl::OUString* pMethodsNames = aMethodsNames.getConstArray();
                 for (k=0; k<aMethodsNames.getLength(); ++k, ++pMethodsNames)
                 {
--- svx/source/form/fmundo.cxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/source/form/fmundo.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -87,6 +87,90 @@ using namespace ::com::sun::star::reflec
 using namespace ::com::sun::star::form::binding;
 using namespace ::svxform;
 
+
+#include <com/sun/star/script/XScriptListener.hdl>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef cppu::WeakImplHelper1< XScriptListener > ScriptEventListener_BASE;
+class ScriptEventListenerWrapper : public ScriptEventListener_BASE
+{
+public:
+	ScriptEventListenerWrapper( FmFormModel& _rModel) throw ( RuntimeException ) : pModel(&_rModel) 
+	{
+		Reference < XPropertySet > xProps(
+			::comphelper::getProcessServiceFactory(), UNO_QUERY );
+		if ( xProps.is() )
+		{
+			Reference< XComponentContext > xCtx( xProps->getPropertyValue(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), UNO_QUERY );
+			if ( xCtx.is() )
+			{
+				Reference< XMultiComponentFactory > xMFac( 
+					xCtx->getServiceManager(), UNO_QUERY );
+				if ( xMFac.is() )
+				{
+					m_vbaListener.set( xMFac->createInstanceWithContext( 
+						rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
+							"ooo.vba.EventListener"  ) ), xCtx ), 
+								UNO_QUERY_THROW );
+				}
+			}
+		}
+	}
+    // XEventListener
+    virtual void SAL_CALL disposing(const EventObject& ) throw( RuntimeException ){}
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const  ScriptEvent& evt) throw(RuntimeException)	
+	{
+		setModel();
+		if ( m_vbaListener.is() )
+		{
+			m_vbaListener->firing( evt );	
+		}
+	}
+
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw( com::sun::star::reflection::InvocationTargetException, RuntimeException)
+	{
+		setModel();
+		if ( m_vbaListener.is() )
+		{
+			return m_vbaListener->approveFiring( evt );	
+		}
+		return Any();	
+	}
+    
+private:
+	void setModel()
+	{
+		Reference< XPropertySet > xProps( m_vbaListener, UNO_QUERY );
+		if ( xProps.is() )
+		{
+			try
+			{
+				SfxObjectShellRef xObjSh = pModel->GetObjectShell();
+				if ( xObjSh.Is() && m_vbaListener.is() )
+				{
+					Any aVal;
+					aVal <<= xObjSh->GetModel();
+					xProps->setPropertyValue( 
+						::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) ), 
+						aVal );
+				}
+			}
+			catch( Exception& e )
+			{
+				//swallow any errors
+			}
+		}
+	}
+    FmFormModel* pModel;
+	Reference< XScriptListener > m_vbaListener;
+
+
+};
+
 //------------------------------------------------------------------------------
 // some helper structs for caching property infos
 //------------------------------------------------------------------------------
@@ -130,6 +214,13 @@ FmXUndoEnvironment::FmXUndoEnvironment(F
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "svx", "Ocke.Janssen@sun.com", "FmXUndoEnvironment::FmXUndoEnvironment" );
     DBG_CTOR(FmXUndoEnvironment,NULL);
+	try
+	{
+		m_vbaListener =  new ScriptEventListenerWrapper( _rModel );
+	}
+	catch( Exception& )
+	{
+	}
 }
 
 //------------------------------------------------------------------------------
@@ -771,9 +862,17 @@ void FmXUndoEnvironment::switchListening
         if ( xManager.is() )
         {
             if ( _bStartListening )
+            {
                 m_pScriptingEnv->registerEventAttacherManager( xManager );
+                if ( m_vbaListener.is() )
+                    xManager->addScriptListener( m_vbaListener );
+            }
             else
+            {
                 m_pScriptingEnv->revokeEventAttacherManager( xManager );
+                if ( m_vbaListener.is() )
+                    xManager->removeScriptListener( m_vbaListener );
+            }
         }
 
         // also handle all children of this element
--- svx/source/form/makefile.mk.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/source/form/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -44,6 +44,10 @@ ENABLE_EXCEPTIONS=TRUE
 
 # --- Files --------------------------------------------------------
 
+.IF "$(ENABLE_VBA)"=="YES"
+	CDEFS+=-DENABLE_VBA
+.ENDIF
+
 SRS1NAME=form
 SRC1FILES= \
     fmexpl.src 		\
--- svx/source/inc/fmundo.hxx.old	2009-10-08 16:17:55.000000000 +0200
+++ svx/source/inc/fmundo.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -217,7 +217,7 @@ private:
 
     void    switchListening( const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexContainer >& _rxContainer, bool _bStartListening ) SAL_THROW(());
     void    switchListening( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& _rxObject, bool _bStartListening ) SAL_THROW(());
-
+    ::com::sun::star::uno::Reference< com::sun::star::script::XScriptListener > m_vbaListener;
 public:
     // Methoden zur Zuordnung von Controls zu Forms,
     // werden von der Seite und der UndoUmgebung genutzt
--- svx/source/msfilter/eschesdo.cxx.old	2009-10-08 16:17:56.000000000 +0200
+++ svx/source/msfilter/eschesdo.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -251,6 +251,19 @@ UINT32 ImplEESdrWriter::ImplWriteShape(
         // #i51348# shape name
         if( aShapeName.Len() > 0 )
             aPropOpt.AddOpt( ESCHER_Prop_wzName, aShapeName );
+        if ( InteractionInfo* pInteraction = mpHostAppData->GetInteractionInfo() )
+		{
+			const std::auto_ptr< SvMemoryStream >& pMemStrm = pInteraction->getHyperlinkRecord();
+			if ( pMemStrm.get() )
+			{
+				pMemStrm->ObjectOwnsMemory( FALSE );
+				sal_uInt8* pBuf = (sal_uInt8*) pMemStrm->GetData();
+				sal_uInt32 nSize = pMemStrm->Seek( STREAM_SEEK_TO_END );
+				aPropOpt.AddOpt( ESCHER_Prop_pihlShape, sal_False, nSize, pBuf, nSize );;       
+			}
+			if ( pInteraction->hasInteraction() )
+				aPropOpt.AddOpt( ESCHER_Prop_fPrint, 0x00080008 );       
+        }
 
         if ( rObj.GetType().EqualsAscii( "drawing.Custom" ) )
         {
--- svx/source/msfilter/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ svx/source/msfilter/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -54,7 +54,8 @@ LIB1OBJFILES= \
     $(SLO)$/svxmsbas.obj	\
     $(SLO)$/msocximex.obj	\
     $(SLO)$/mscodec.obj		\
-	$(SLO)$/msfiltertracer.obj \
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
 	$(SLO)$/msvbahelper.obj\
 
 LIB2TARGET= $(SLB)$/$(TARGET)-core.lib
@@ -71,7 +72,8 @@ EXCEPTIONSFILES= \
     $(SLO)$/msocximex.obj	\
     $(SLO)$/msoleexp.obj	\
     $(SLO)$/svxmsbas.obj	\
-	$(SLO)$/msfiltertracer.obj \
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
 	$(SLO)$/msvbahelper.obj\
 
 .INCLUDE :  target.mk
--- svx/source/msfilter/msocximex.cxx.old	2009-10-08 16:17:56.000000000 +0200
+++ svx/source/msfilter/msocximex.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -49,6 +49,10 @@
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
 #include <com/sun/star/form/XForm.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
 #include <com/sun/star/form/FormComponentType.hpp>
 #include <com/sun/star/awt/FontWeight.hpp>
 #include <com/sun/star/awt/FontSlant.hpp>
@@ -79,7 +83,22 @@
 
 #include <algorithm>
 #include <memory>
-
+#include <com/sun/star/graphic/GraphicObject.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <unotools/streamwrap.hxx>
+
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <svtools/filterutils.hxx>
+ 
 #ifndef C2S
 #define C2S(cChar)	String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(cChar))
 #endif
@@ -102,6 +121,7 @@ using namespace cppu;
 
 
 #define WW8_ASCII2STR(s) String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(s))
+#define GRAPHOBJ_URLPREFIX "vnd.sun.star.GraphicObject:"
 
 
 static char sWW8_form[] = "WW-Standard";
@@ -130,126 +150,48 @@ long ReadAlign(SvStorageStream *pS, long
     return 0;
 }
 
-
 // NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
 // referenced externally. On import from ms document try to save images for controls here.
 // Images are stored in directory called temp in the user installation directory. Next version of OO/SO
 // hopefully will address this issue and allow a choice e.g. images for controls to be stored as links
 // or embeded in the document.
-
-// [out]location     path to the stream to where the image is to be stored,
-//               if same name exists in folder then this function calcuates a new name
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-//
-// returns, true if successful
-
-bool storePictureInFileSystem( OUString& location, sal_uInt8* data, sal_uInt32 dataLen )
+uno::Reference< graphic::XGraphicObject> lcl_readGraphicObject( SotStorageStream *pS )
 {
-    bool result = true;
-    OUString origPath = location;
-    try
-    {
-        uno::Reference<lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(),
-                                                      uno::UNO_QUERY_THROW );
-        uno::Reference< com::sun::star::ucb::XSimpleFileAccess> xSFA( xMSF->createInstance(
-                                                       S2U("com.sun.star.ucb.SimpleFileAccess" ) ),
-                                                       uno::UNO_QUERY_THROW );
-        OUString ext;
-        sal_Int32 index = 0;
-        while (  xSFA->exists( location ) )
-        {
-            ext = OUString::valueOf( ++index );
-            location = origPath + ext;
-        }
-
-        SvStream*  pStream = ::utl::UcbStreamHelper::CreateStream( location, STREAM_WRITE | STREAM_TRUNC );
-        if ( pStream )
-        {
-            pStream->Write(data, dataLen);
-            delete pStream;
-        }
-        else
-        {
-            result = false;
-        }
-    }
-    catch( uno::Exception& )
-    {
-        result = false;
-    }
-    return result;
+	uno::Reference< graphic::XGraphicObject > xGrfObj;
+	uno::Reference< lang::XMultiServiceFactory > xServiceManager = ::comphelper::getProcessServiceFactory();
+	if( xServiceManager.is() )
+	{
+		try
+		{
+			// use the GraphicProvider service to get the XGraphic
+			uno::Reference< graphic::XGraphicProvider > xGraphProvider(
+					xServiceManager->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.graphic.GraphicProvider" ) ), uno::UNO_QUERY );
+			if( xGraphProvider.is() )
+			{
+				uno::Reference< io::XInputStream > xStream( new utl::OInputStreamWrapper( *pS ) );
+				if( xStream.is() )
+				{
+					uno::Sequence< beans::PropertyValue > aMediaProps( 1 );
+					aMediaProps[0].Name = ::rtl::OUString::createFromAscii( "InputStream" );
+					aMediaProps[0].Value <<= xStream;
+					uno::Reference< graphic::XGraphic > xGraphic = xGraphProvider->queryGraphic( aMediaProps );
+					if( xGraphic.is() )
+					{
+						// create an XGraphicObject
+						::comphelper::ComponentContext aContext( xServiceManager );
+						xGrfObj = graphic::GraphicObject::create( aContext.getUNOContext() );
+						xGrfObj->setGraphic(xGraphic);
+					}
+				}
+			}
+		}
+		catch( uno::Exception& )
+		{
+		}
+	}
+	return xGrfObj;
 }
 
-// NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
-// referenced externally. On import from ms document try to save images from controls here so this
-// at least a macro programmer has a chance to accessed them manually later. Next version of OO/SO
-// hopefully will address this issue.
-// Images will be stored in a top level folder in the document package, folder is named "MigratedImages"
-
-// [in] pDocSh*  the document shell.
-// [in] name     name of stream image to stored in.
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-
-bool storePictureInDoc( SfxObjectShell* pDocSh, OUString& name, sal_uInt8* data, sal_uInt32 dataLen )
-{
-    uno::Reference < embed::XStorage > xStor;
-    if (pDocSh)
-    {
-        xStor = pDocSh->GetStorage();
-        if( xStor.is() )
-        {
-            try
-            {
-                uno::Reference< embed::XStorage > xPictures = xStor->openStorageElement(
-                    OUString( RTL_CONSTASCII_USTRINGPARAM( "MigratedImages" ) ),
-                    embed::ElementModes::READWRITE );
-                uno::Reference< beans::XPropertySet > xPropSet( xPictures, uno::UNO_QUERY );
-
-                // Set media type of folder MigratedImages to something ( that is unknown ) so that
-                // it will get copied to exported OO/SO format after SaveAs
-                if ( xPropSet.is() )
-                {
-                    OUString aMediaType = C2U("MigrationImages");
-                    uno::Any a;
-                    a <<= aMediaType;
-                    xPropSet->setPropertyValue( C2U("MediaType"), a );
-                }
-
-                uno::Reference< io::XStream > xObjReplStr = xPictures->openStreamElement(
-                        name,
-                        embed::ElementModes::READWRITE | embed::ElementModes::TRUNCATE );
-                uno::Reference< io::XOutputStream > xOutStream( xObjReplStr->getOutputStream(), uno::UNO_QUERY_THROW );
-                uno::Sequence< sal_Int8 > imageBytes( (sal_Int8*)data, dataLen );
-                xOutStream->writeBytes( imageBytes );
-                xOutStream->closeOutput();
-
-                uno::Reference< embed::XTransactedObject > xTransact( xPictures, uno::UNO_QUERY );
-                if ( xTransact.is() )
-                {
-                    xTransact->commit();
-                }
-            }
-            catch( uno::Exception& )
-            {
-                return false;
-            }
-
-        }
-        else
-        {
-            // no storage something wrong
-            return false;
-        }
-    }
-    else
-    {
-        //No doc shell
-        return false;
-    }
-    return true;
-}
 
 long WriteAlign(SvStorageStream *pS, int nAmount)
 {
@@ -413,35 +355,11 @@ void lclReadCharArray( SvStorageStream&
  */
 OUString lclCreateOUString( const char* pcCharArr, sal_uInt32 nLenFld )
 {
-    OUStringBuffer aBuffer;
     sal_uInt32 nBufSize = lclGetBufferSize( nLenFld );
     if( lclIsCompressed( nLenFld ) )
-    {
-        // buffer contains compressed Unicode, not encoded bytestring
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
-    }
-    else
-    {
-        // buffer contains Little-Endian Unicode
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
-        {
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
-            cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
-            aBuffer.setCharAt( nChar, cChar );
-        }
-    }
-    return aBuffer.makeStringAndClear();
+        return svt::BinFilterUtils::CreateOUStringFromStringArray( pcCharArr, nBufSize );
+
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray( pcCharArr, nBufSize );
 }
 
 // export ---------------------------------------------------------------------
@@ -561,8 +479,129 @@ const sal_uInt16 TOGGLEBUTTON = (sal_uIn
 const sal_uInt16 SCROLLBAR = (sal_uInt16)0x2F;
 
 const sal_uInt16 MULTIPAGE = (sal_uInt16)0x39;
+// The IDs with bit 0x8000 set appear to be generated.
+// It looks like these ID's are used with the non-toolbox [1]
+// ActiveX controls that can be present in a Userform
+// ( note: RefEdit seems to be an exception )
+// In UserForm::Read just before the Container record starts
+// you will notice there can be sometimes trailing records, 
+// it seems that these records have a 1:1 relationship with the non-toolbox
+// controls present in the Userform. An id in the trailing record
+// seems to identify the specific ActiveX control and an artificial nTypeIdent
+// e.g. 0x8000, 0x8001 etc. is created so as to be able to associate
+// the ActiveX control when referenced later 
+// [1] Such ActiveX controls are added via Tools/AddionalControls
+// menu
+
+// create a fixed set of those special id(s)
+// ahem, we can only read one Progress bars at the moment so....
 const sal_uInt16 PROGRESSBAR = (sal_uInt16)0x8000;
 
+// A set of IDs from the trailing records mentioned above that seem to
+// identify the following ActiveX controls 
+// Currently we only can process ( in a limited way ) the ProgressBar
+// the other ID's are for reference ( & future )
+
+// RefEdit control {00024512-0000-0000-c000-000000000046}
+const sal_uInt8 aRefEditID[] =
+{
+0x12, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+// Microsoft ProgressBar Control, version 6.0 {35053A22-8589-11D1-B16A-00C0F0283628}
+const sal_uInt8 aProgressID[] =
+{
+0x22, 0x3a, 0x05, 0x35, 0x89, 0x85, 0xd1, 0x11,  0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Calendar Control 10.0 
+const sal_uInt8 aCalendarID[] =
+{
+0x2b, 0xc9, 0x27, 0x8e, 0x64, 0x12, 0x1c, 0x10, 0x8a, 0x2f, 0x04, 0x02, 0x24, 0x00, 0x9c, 0x02,
+};
+
+
+// Microsoft ImageComboxBox Control, version 6.0 {DD9DA666-8594-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageComboID[] =
+{
+0x66, 0xa6, 0x9d, 0xdd, 0x94, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft ImageList Control, version 6.0 {2C247F23-8591-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageListID[] =
+{
+0x23, 0x7f, 0x24, 0x2c, 0x91, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Slider Control, version 6.0 {F08DF954-8592-11D1-B16A-00C0F0283628}
+const sal_uInt8 aSliderID[] =
+{
+0x54, 0xf9, 0x8d, 0xf0, 0x92, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft StatusBar Control, version 6.0 {8E3867A3-8586-11D1-B16A-00C0F0283628}
+const sal_uInt8 aStatusBarID[] =
+{
+0xa3, 0x67, 0x38, 0x8e, 0x86, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Office Chart 10.0
+const sal_uInt8 aChartSpaceID[] =
+{
+0x46, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+const sal_Int16 ActiveXIDLen = 0x10; // CLSID len
+const sal_Int16 ActiveXIDBlockLen = 0x30; // the block len that contains the CLSID
+
+bool lcl_handleActiveXControl(  SvStorageStream *pS, sal_uInt16& nTypeID )
+{
+    nTypeID = 0; // Illegal ActiveX ID 
+    bool bRes = false;
+    sal_uInt16 nIdentifier, nFixedAreaLen;
+    *pS >> nIdentifier;    
+    *pS >> nFixedAreaLen;    
+    pS->SeekRel( ( nFixedAreaLen - ActiveXIDBlockLen ) );
+    sal_uInt8 aID[ ActiveXIDLen ];
+    if ( !pS->IsEof() )
+    {
+        pS->Read( aID, ActiveXIDLen );
+        pS->SeekRel( ActiveXIDBlockLen - ActiveXIDLen ); // read remainer of record
+        if ( memcmp( aID, aProgressID, ActiveXIDLen ) == 0 )
+        {
+            nTypeID = PROGRESSBAR;
+            OSL_TRACE("Found supported ***PROGRESSBAR*** ActiveX control");
+            bRes = true;
+        }
+#if (OSL_DEBUG_LEVEL > 0)
+        // If we really want to process these more controls we should put them in 
+        // a list or array and have a single loop testing each id. For the moment 
+        // as we only can process PROGRESSBAR, not much point doing that until 
+        // we add support for at least another activex control
+
+        else if ( memcmp( aID, aCalendarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CALENDAR*** ActiveX control");
+        else if ( memcmp( aID, aRefEditID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***REFEDIT*** ActiveX control");
+        else if ( memcmp( aID, aImageComboID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGECOMBO*** ActiveX control");
+        else if ( memcmp( aID, aImageListID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGELIST*** ActiveX control");
+        else if ( memcmp( aID, aChartSpaceID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CHARTSPACE*** ActiveX control");
+        else if ( memcmp( aID, aSliderID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***SLIDER*** ActiveX control");
+        else if ( memcmp( aID, aStatusBarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***STATUSBAR*** ActiveX control");
+#endif
+        else
+        {
+            OSL_TRACE("Unknown activeX ID !");
+        }
+    }
+    return bRes;
+}
+
 typedef std::vector< ContainerRecord > ContainerRecordList;
 
 class ContainerRecReader
@@ -637,6 +676,8 @@ class ContainerRecReader
             // control type
             if( nContentFlags & 0x00000080 )
                 *pS >> rec.nTypeIdent;
+            if( nContentFlags & 0x00000200 )
+                pS->SeekRel( 4 ); // Grouping?
             // length of infotip
             sal_uInt32 nTipLen = 0;
             if( nContentFlags & 0x00000800 )
@@ -711,14 +752,22 @@ class ContainerRecReader
             if( nCtrlSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nCtrlSrcBufSize );
+                std::auto_ptr< sal_Char > pCtrlSrcName;
+                pCtrlSrcName.reset( new sal_Char[ nCtrlSrcBufSize ] );
+                pS->Read( pCtrlSrcName.get(), nCtrlSrcBufSize );
+                rec.sCtrlSource = lclCreateOUString( pCtrlSrcName.get(), nCtrlSrcLen );
+                OSL_TRACE("*** *** *** ControlSourceName -> %s ", rtl::OUStringToOString( rec.sCtrlSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
             // row source name
             sal_uInt32 nRowSrcBufSize = lclGetBufferSize( nRowSrcLen );
             if( nRowSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nRowSrcBufSize );
+                std::auto_ptr< sal_Char > pRowSrcName;
+                pRowSrcName.reset( new sal_Char[ nRowSrcBufSize ] );
+                pS->Read( pRowSrcName.get(), nRowSrcBufSize );
+                rec.sRowSource =  lclCreateOUString( pRowSrcName.get(), nRowSrcLen );
+                OSL_TRACE("*** *** *** RowSourceName -> %s ", rtl::OUStringToOString( rec.sRowSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
 
             // seek to end of data
@@ -735,6 +784,13 @@ class ContainerRecReader
                 pControl->pDocSh = pContainerControl->pDocSh;
                 pContainerControl->ProcessControl( pControl, pS, rec );
             }
+            else if ( rec.nTypeIdent & 0x8000 )
+            {
+                // Skip ActiveX Controls we can't import
+                SotStorageStreamRef oStream = pContainerControl->getContainedControlsStream(); 
+                ULONG nStrmPos = oStream->Tell();
+                oStream->Seek( nStrmPos + rec.nSubStreamLen );
+            }  
             else
             {
                 DBG_ERROR("Terminating import, unexpected error");
@@ -755,6 +811,11 @@ class ContainerRecReader
     {
         sal_uInt8 aUnknown11[4];
         pS->Read(aUnknown11, sizeof(aUnknown11));
+        // discovered a dialog with value of 0xFF for aUnknown11 
+        // needed an extra 4 bytes to offset correctly  into the control
+        // records. Valid test or coincidence ?
+        if ( aUnknown11[1] == 0xFF )
+           pS->Read( aUnknown11, sizeof(aUnknown11));
         return true;
     }
 
@@ -829,176 +890,6 @@ class ContainerRecordReaderFac
 
 // ============================================================================
 
-void RBGroup::add(OCX_Control* pRB)
-{
-    // The tab index for the group is calculated as
-    // the lowest tab index found in the list of RadioButtons
-    if ( pRB->mnTabPos < mRBGroupPos )
-    {
-        mRBGroupPos = pRB->mnTabPos;
-        CtrlIterator aEnd = mpControls.end();
-        for (CtrlIterator aIter = mpControls.begin(); aIter != aEnd; ++ aIter )
-        {
-            (*aIter)->mnTabPos = mRBGroupPos;
-        }
-    }
-    mpControls.push_back( pRB );
-}
-
-struct SortGroupByTabPos
-{
-    bool operator()( const RBGroup* a, const RBGroup* b )
-    {
-        return a->tabPos() < b->tabPos();
-    }
-};
-
-RBGroupManager::RBGroupManager( String& defaultName ):mSDefaultName( defaultName ),
-    numRadioButtons(0)
-{
-    groupList.reserve( 8 ); // reserve far more than we expect
-}
-
-RBGroupManager::~RBGroupManager()
-{
-    for ( GroupIterator gIter=groupList.begin(); gIter!=groupList.end(); ++gIter )
-    {
-        delete( *gIter );
-    }
-}
-
-// Loose description of the method below ( I sure there is a better way to do
-// this )
-// In order to "fake" MS grouping behavior for OptionButtons the OptionButtons
-// in the same group need to have consecutive tab indices ( regardless of the
-// imported tab indices of the RadioButtons ). Additionally if two
-// groups of OptionButtons end up having all consecutive indices they
-// will be treated as a single group by OpenOffice. In this case
-// a dummy seperator control needs to be inserted between the groups.
-//
-// This method returns a new list "destinationList" containing the controls
-// passed in "sourceList" and the OptionButtons contained in the various
-// Groups maintained by this  class.
-// Controls are ordered in the destination list by tab index.
-// Each RadioButtonGroup has a tab index associated with it.
-// ( Tab index of a RadioGroup is determined as the tab index of the
-// OptionButton control with the lowest tab index in the group )
-
-
-void RBGroupManager::addRadioButton( OCX_OptionButton* pRButton )
-{
-    if ( pRButton )
-    {
-        OUString groupName = mSDefaultName;
-        if ( pRButton->nGroupNameLen )
-        {
-            groupName =
-                lclCreateOUString(pRButton->pGroupName,
-                    pRButton->nGroupNameLen);
-        }
-        ++numRadioButtons;
-        RBGroupHash::iterator iter = rbGroups.find( groupName );
-        if ( iter != rbGroups.end() )
-        {
-            iter->second->controls().push_back( pRButton );
-        }
-        else
-        {
-            RBGroup* newGroup = new RBGroup(pRButton->mnTabPos);
-            newGroup->controls().push_back( pRButton );
-            rbGroups[ groupName ] = newGroup;
-            groupList.push_back( newGroup );
-        }
-
-    }
-}
-
-CtrlList RBGroupManager::insertGroupsIntoControlList( const CtrlList& sourceList )
-{
-    ::std::sort( groupList.begin(), groupList.end(), SortGroupByTabPos() );
-    std::vector<OCX_Control*> destinationList;
-    if ( groupList.size() )
-    {
-        destinationList.reserve( sourceList.size() + numRadioButtons );
-
-        GroupIterator groupEnd = groupList.end();
-        CtrlIteratorConst sourceEnd = sourceList.end();
-
-        size_t prevGroupListSize = 0;
-
-        CtrlIteratorConst containees = sourceList.begin();
-        GroupIterator groupIter=groupList.begin();
-        while ( containees != sourceEnd ||
-                groupIter != groupEnd )
-        {
-            bool addGroupSeperator = false;
-            if ( containees != sourceEnd )
-            {
-                if ( groupIter != groupEnd )
-                {
-                    sal_Int16 groupTabPos = (*groupIter)->tabPos();
-                    if ( (*containees)->mnTabPos >= groupTabPos )
-                    {
-                       if ( !(destinationList.size() >=  prevGroupListSize ))
-                        {
-                            addGroupSeperator = true;
-                        }
-                        copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                        ++groupIter;
-
-                        prevGroupListSize = destinationList.size();
-                    }
-                }
-                destinationList.push_back(*containees);
-                ++containees;
-            }
-            else
-            {
-               if ( groupIter != groupEnd )
-               {
-                    if ( !(destinationList.size() >  prevGroupListSize ))
-                    {
-                        addGroupSeperator = true;
-                    }
-                    copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                    ++groupIter;
-                    prevGroupListSize = destinationList.size();
-                }
-            }
-        }
-    }
-    else
-    {
-        destinationList = sourceList;
-    }
-    return destinationList;
-
-}
-
-
-void RBGroupManager::addSeperator( std::vector< OCX_Control* >& dest )
-{
-    OCX_Control* seperator = new OCX_CommandButton;
-    seperator->SetInDialog(true);
-    seperator->sName = C2S("GroupSeperator");
-    dest.push_back( seperator );
-}
-
-void RBGroupManager::copyList( std::vector< OCX_Control* >& src,
-    std::vector< OCX_Control* >& dest,
-    bool addGroupSeperator )
-{
-    if ( addGroupSeperator )
-    {
-        addSeperator( dest );
-    }
-
-    for ( CtrlIterator rbIter = src.begin(); rbIter != src.end(); ++rbIter )
-    {
-        dest.push_back( *rbIter );
-    }
-}
-
 class OCX_UserFormLabel : public OCX_Label
 {
 public:
@@ -1165,6 +1056,9 @@ sal_Bool OCX_Control::Import(
 sal_Bool OCX_Control::Import(uno::Reference<container::XNameContainer> &rDialog
     )
 {
+    uno::Reference<beans::XPropertySet > xDlgProps( rDialog, uno::UNO_QUERY);
+
+    
     uno::Reference<lang::XMultiServiceFactory>
         xFactory(rDialog, uno::UNO_QUERY);
 
@@ -1177,11 +1071,15 @@ sal_Bool OCX_Control::Import(uno::Refere
     if (!xModel.is())
         return sal_False;
 
+    sal_Bool bVBA = sal_False;
     /*  #147900# sometimes insertion of a control fails due to existing name,
         do not break entire form import then... */
     try
     {
         rDialog->insertByName(sName, uno::makeAny(xModel));
+        if ( xDlgProps.is() )
+            xDlgProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+
     }
     catch( uno::Exception& )
     {
@@ -1197,16 +1095,32 @@ sal_Bool OCX_Control::Import(uno::Refere
 
     if (!Import(xPropSet))
         return sal_False;
-
+    
     uno::Any aTmp;
-    aTmp <<= sal_Int32((mnLeft * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
-    aTmp <<= sal_Int32((mnTop * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    sal_Int32 nFactor = 3528; 
+
+    if ( !bVBA  )
+    {
+        aTmp <<= sal_Int32((mnLeft * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32((mnTop * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32((nWidth * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32(mnLeft); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32(mnTop); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32(nWidth); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
     if ( msToolTip.Len() > 0 )
         xPropSet->setPropertyValue(WW8_ASCII2STR("HelpText"), uno::Any(OUString(msToolTip)));
 
@@ -1421,6 +1335,12 @@ sal_Bool OCX_CommandButton::Import( com:
     rPropSet->setPropertyValue( WW8_ASCII2STR( "FocusOnClick" ), aTmp );
 
     aFontData.Import(rPropSet);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
     return sal_True;
 }
 
@@ -1668,6 +1588,99 @@ sal_Bool OCX_ImageButton::Export(SvStora
     return WriteContents(xContents,rPropSet,rSize);
 }
 
+bool lcl_isNamedRange( const rtl::OUString& sAddress, uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
+
+void lcl_ApplyListSourceAndBindableStuff( uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& rPropSet, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+}
 
 sal_Bool OCX_OptionButton::Import(com::sun::star::uno::Reference<
         com::sun::star::beans::XPropertySet> &rPropSet)
@@ -1700,12 +1713,51 @@ sal_Bool OCX_OptionButton::Import(com::s
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-    if (pValue && !bSetInDialog)
+	if (pValue)
     {
         INT16 nTmp = pValue[0]-0x30;
         aTmp <<= nTmp;
-        rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
-    }
+		if (!bSetInDialog)
+			rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		{
+			// dialog ( but we might be using the form model )
+			if ( rPropSet->getPropertySetInfo()->hasPropertyByName( WW8_ASCII2STR("DefaultState") ) )
+				rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+			else
+				rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
+		}
+	}
+    // If this is a dialog control then we need to  set a groupname *always*
+    rtl::OUString sGroupName = lclCreateOUString( pGroupName, nGroupNameLen );
+    if ( GetInDialog() ) // Userform/Dialog
+    {
+        // By default groupnames are not set in Excel, it's not unusual to have
+        // a number of groups of radiobuttons located inside frame ( or other container
+        // controls ) where there is *no* specific groupname set for the radiobuttons.
+        // But... there is implicit grouping for radio buttons in seperate containers
+        // e.g. radio buttons in a frame are by default in the same group.
+        // Unfortunately in openoffice there are no containers below the dialog itself :-(
+        // To ensure correct grouping for imported radiobuttons either with no groupname
+        // or identical groupnames that are in separate containers we *must* ensure
+        // that a suitable groupname is applied. 
+        // Because controlNames are unique even across different containers we can use the
+        // controls container (e.g. parent) name as a prefix for a group name
+	rtl::OUString sParentName = msParentName;
+        sGroupName = sParentName.concat( C2U( ":" ) ).concat( sGroupName );
+    }
+    if ( sGroupName.getLength() == 0 )
+        sGroupName = rtl::OUString::createFromAscii("DefaultGroup");
+	OSL_TRACE("RadioButton %s has groupname %s", 
+		rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sGroupName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        try
+        {
+            aTmp <<= sGroupName;
+            rPropSet->setPropertyValue( WW8_ASCII2STR("GroupName"), aTmp);
+        }
+        catch( uno::Exception& )
+        {
+        }
 
     if (pCaption)
     {
@@ -1717,6 +1769,14 @@ sal_Bool OCX_OptionButton::Import(com::s
     aTmp <<= ::com::sun::star::style::VerticalAlignment_MIDDLE;
     rPropSet->setPropertyValue( WW8_ASCII2STR("VerticalAlign"), aTmp );
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
+
     aFontData.Import(rPropSet);
     return sal_True;
 }
@@ -2352,6 +2412,12 @@ sal_Bool OCX_ToggleButton::Import(com::s
     }
 
     aFontData.Import(rPropSet);
+	
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
     return sal_True;
 }
 
@@ -2608,6 +2674,8 @@ sal_Bool OCX_ComboBox::Import(com::sun::
     rPropSet->setPropertyValue( WW8_ASCII2STR("MaxTextLen"), aTmp);
 
     aFontData.Import(rPropSet);
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
     return sal_True;
 }
 
@@ -2827,7 +2895,8 @@ sal_Bool OCX_ListBox::Import(com::sun::s
 
     aTmp <<= ImportColor( nBorderColor );
     rPropSet->setPropertyValue( WW8_ASCII2STR("BorderColor"), aTmp);
-
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
     aFontData.Import(rPropSet);
     return sal_True;
 }
@@ -3205,8 +3274,15 @@ sal_Bool OCX_ModernControl::Read(SvStora
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
     }
 
     return sal_True;
@@ -3296,8 +3372,15 @@ sal_Bool OCX_CommandButton::Read(SvStora
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
     }
 
     return sal_True;
@@ -3418,7 +3501,7 @@ OCX_ContainerControl::OCX_ContainerContr
             const ::rtl::OUString& sN,
             const uno::Reference< container::XNameContainer >  &rParent,
             OCX_Control* pParent ) :
-                OCX_Control(sN, pParent), rbGroupMgr( sName ), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
+                OCX_Control(sN, pParent), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
 {
 
     mContainerStorage = parent->OpenSotStorage(storageName,
@@ -3481,9 +3564,18 @@ OUString OCX_ContainerControl::createSub
     return buf.makeStringAndClear();
 }
 
-bool OCX_ContainerControl::createFromContainerRecord( const ContainerRecord& record, OCX_Control*& pControl )
+
+bool OCX_ContainerControl::createFromContainerRecord( ContainerRecord& record, OCX_Control*& pControl )
 {
     pControl = NULL;
+    if (  record.nTypeIdent & 0x8000 )
+    {
+        std::hash_map<sal_uInt16, sal_uInt16>::iterator it = mActiveXIDMap.find( record.nTypeIdent );
+        if ( it == mActiveXIDMap.end() )
+            return false;
+        // replace the generated id with our hardcoded one
+        record.nTypeIdent = it->second; 
+    }
     switch ( record.nTypeIdent)
         {
             case CMDBUTTON:
@@ -3591,8 +3683,7 @@ void OCX_ContainerControl::ProcessContro
     SotStorageStreamRef oStream = mContainedControlsStream;
 
     // can insert into OO Dialog (e.g is this a supported dialog control)??
-    if ( rec.nTypeIdent == SPINBUTTON ||
-        rec.nTypeIdent == TABSTRIP)
+    if ( rec.nTypeIdent == TABSTRIP )
     {
         // skip the record in the stream, discard the control
         oStream->SeekRel( rec.nSubStreamLen );
@@ -3602,15 +3693,27 @@ void OCX_ContainerControl::ProcessContro
     {
         // A container control needs to read the f stream in
         // the folder ( substorage ) associated with this control
-        if (  rec.nTypeIdent ==  FRAME ||
-            rec.nTypeIdent ==  MULTIPAGE||
-            rec.nTypeIdent ==  PAGE )
+        switch ( rec.nTypeIdent )
         {
-            OCX_ContainerControl* pContainer =
-               static_cast< OCX_ContainerControl* >( pControl );
-            oStream = pContainer->getContainerStream();
+            case FRAME:
+            case MULTIPAGE:
+            case PAGE:
+                {
+                    OCX_ContainerControl* pContainer =
+                        static_cast< OCX_ContainerControl* >( pControl );
+                    oStream = pContainer->getContainerStream();
+                    break;
+                }
+            case LISTBOX:
+            case OPTIONBUTTON:
+            case COMBOBOX:
+			case SPINBUTTON:
+			case SCROLLBAR:
+                {
+                    pControl->msCtrlSource = rec.sCtrlSource;
+                    pControl->msRowSource = rec.sRowSource;
+                }
         }
-
         pControl->sName = rec.cName;
         pControl->msToolTip = rec.controlTip;
         // Position of controls is relative to the container
@@ -3630,6 +3733,7 @@ void OCX_ContainerControl::ProcessContro
             // applied to all containees
             pControl->mnStep = mnStep;
         }
+        pControl->msParentName = sName;
 
         // #117490# DR: container records provide size of substream, use it here...
 
@@ -3640,17 +3744,7 @@ void OCX_ContainerControl::ProcessContro
         // set stream to position behind substream of this control
         oStream->Seek( nStrmPos + rec.nSubStreamLen );
 
-        //need to fake grouping behaviour for radio ( option ) buttons
-        if ( rec.nTypeIdent == OPTIONBUTTON )
-        {
-            OCX_OptionButton* pRButton =
-                static_cast< OCX_OptionButton*>(pControl);
-            rbGroupMgr.addRadioButton( pRButton );
-        }
-        else
-        {
-            mpControls.push_back( pControl );
-        }
+        mpControls.push_back( pControl );
     }
 }
 
@@ -3673,7 +3767,6 @@ sal_Bool OCX_ContainerControl::Read(SvSt
     // this ensures that the default tab index created by Star/Open office
     // reflects the "flattened" ms tab order.
     ::std::sort( mpControls.begin(), mpControls.end(), SortOrderByTabPos() );
-    mpControls = rbGroupMgr.insertGroupsIntoControlList( mpControls );
     return true;
 }
 
@@ -3691,7 +3784,8 @@ OCX_MultiPage::OCX_MultiPage( SotStorage
         nScrollWidth(0), nScrollHeight(0), nIconLen(0), pIcon(0), nPictureLen(0),
         pPicture(0)
 {
-    msDialogType = C2U("NotSupported");
+    //msDialogType = C2U("NotSupported");
+    msDialogType = C2U("com.sun.star.awt.UnoMultiPageModel");
     mnForeColor = 0x80000012L,
     mnBackColor = 0x8000000FL;
     bSetInDialog = true;// UserForm control only
@@ -3755,7 +3849,6 @@ sal_Bool OCX_MultiPage::Read(SvStorageSt
 sal_Bool OCX_MultiPage::Import(com::sun::star::uno::Reference<
     com::sun::star::beans::XPropertySet> &rPropSet)
 {
-    // Calls import on contained controls
     OCX_ContainerControl::Import( rPropSet );
     return sal_True;
 }
@@ -3776,6 +3869,43 @@ sal_Bool OCX_MultiPage::Import(com::sun:
 
     if ( xPropSet.is() )
     {
+        uno::Reference<lang::XMultiServiceFactory>
+            xFactory(rDialog, uno::UNO_QUERY);
+	OSL_TRACE("** MultiPage creating control %s", rtl::OUStringToOString( msDialogType, RTL_TEXTENCODING_UTF8 ).getStr() );
+	uno::Reference<uno::XInterface> xCreate = xFactory->createInstance(msDialogType);
+	if (!xCreate.is())
+		return sal_False;
+
+	uno::Reference<awt::XControlModel> xModel(xCreate, uno::UNO_QUERY);
+	if (!xModel.is())
+		return sal_False;
+
+        try
+        {
+		// we should just call MultiPage::Import( XPropertySet )
+    		OSL_TRACE("********* MULTIPAGE cName %s", rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+		uno::Any aTmp(&sName,getCppuType((OUString *)0));
+		uno::Reference<beans::XPropertySet> xPrps(xModel, uno::UNO_QUERY);
+		xPrps->setPropertyValue( WW8_ASCII2STR("Name"), aTmp );
+		aTmp = uno::makeAny( mnCurrentPageStep );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValueMax"), aTmp );
+		// default current page to 0 ( #FIXME, we need to read this value )
+		aTmp = uno::makeAny( sal_Int32(0) );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValue"), aTmp );
+    		OSL_TRACE("********* MULTIPAGE vomitted out properties");
+
+    // Calls import on contained controls
+            rDialog->insertByName(sName, uno::makeAny(xModel));
+            OSL_TRACE("*** inserted ***");
+        }
+        catch( uno::Exception& )
+        {
+            DBG_ERRORFILE(
+                ByteString( "OCX_Control::Import - cannot insert control \"" ).
+                Append( ByteString( sName, RTL_TEXTENCODING_UTF8 ) ).
+                Append( '"' ).GetBuffer() );
+        }
+
         // Calls import on contained pages
         return OCX_ContainerControl::Import( xPropSet );
     }
@@ -4062,8 +4192,7 @@ OCX_UserForm::OCX_UserForm( SotStorageRe
         nKeepScrollBarsVisible(3), nCycle(0), nBorderStyle(0), nSpecialEffect(0),
         nPicture(0), nPictureAlignment(2), nPictureSizeMode(0),
         bPictureTiling(FALSE), nAccelerator(0), nIcon(0), pCaption(0),
-        nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0),
-        pPicture(0)
+		nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0)
     {
             mnForeColor = 0x80000012;
             mnBackColor = 0x8000000F;
@@ -4193,24 +4322,30 @@ sal_Bool OCX_UserForm::Read(SvStorageStr
         pS->Read(pIcon,nIconLen);
     }
 
+	ReadAlign( pS, pS->Tell() - nStart, 4);
+	if (pBlockFlags[2] & 0x10)
+	{
+		//Font Stuff..
+		pS->SeekRel(0x1a);
+		sal_uInt8 nFontLen;
+		*pS >> nFontLen;
+		pS->SeekRel(nFontLen);
+	}
     if (nPicture)
     {
         pS->Read(pPictureHeader,20);
         *pS >> nPictureLen;
-        pPicture = new sal_uInt8[nPictureLen];
-        pS->Read(pPicture,nPictureLen);
-    }
-
-    ReadAlign( pS, pS->Tell() - nStart, 4);
-
-    if (pBlockFlags[2] & 0x10)
-    {
-        //Font Stuff..
-        pS->SeekRel(0x1a);
-        sal_uInt8 nFontLen;
-        *pS >> nFontLen;
-        pS->SeekRel(nFontLen);
-    }
+		long imagePos = pS->Tell();
+		// great embedded object
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image.
+		pS->Seek( imagePos + nPictureLen );
+	}
 
     sal_Int16 numTrailingRecs = 0;
     *pS >> numTrailingRecs;
@@ -4219,10 +4354,14 @@ sal_Bool OCX_UserForm::Read(SvStorageStr
     // ( unknown what these trailing records are for)
     if ( numTrailingRecs )
     {
-        for ( ; numTrailingRecs ; --numTrailingRecs )
+        for ( sal_Int16 i = 0 ; numTrailingRecs ; --numTrailingRecs, ++i )
         {
-            OCX_Control skip(C2S("dummy")) ;
-            skip.Read( pS );
+            sal_uInt16 nTypeID = 0;
+            if ( lcl_handleActiveXControl( pS, nTypeID ) )
+            {
+                if ( nTypeID & 0x8000 ) // valid ActiveXID
+                    mActiveXIDMap[ ( i | 0x8000 ) ] = nTypeID;
+            }
         }
     }
     return OCX_ContainerControl::Read( pS );
@@ -4233,6 +4372,8 @@ sal_Bool OCX_UserForm::Import(
 {
     uno::Reference<beans::XPropertySet>
         xDialogPropSet(mxParent, uno::UNO_QUERY);
+    if ( !xDialogPropSet.is() )
+        return sal_False;
     uno::Any aTmp(&sName,getCppuType((OUString *)0));
     xDialogPropSet->setPropertyValue(
         OUString(RTL_CONSTASCII_USTRINGPARAM("Name")), aTmp);
@@ -4240,22 +4381,56 @@ sal_Bool OCX_UserForm::Import(
         OUString(RTL_CONSTASCII_USTRINGPARAM("Title")), aTmp);
     aTmp <<= ImportColor(mnBackColor);
     xDialogPropSet->setPropertyValue( WW8_ASCII2STR("BackgroundColor"), aTmp);
+    sal_Bool bVBA = sal_False;
+    // Ok we are importing xls but maybe we aren't in VBA mode
+    // if we are not in VBA mode then we should import sizes etc. ( as before )
+    try
+    {
+        xDialogPropSet->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+    }
+    catch( uno::Exception& e )
+    {
+    }
+    sal_Int32 nFactor( 3528 );
+    if ( !bVBA )
+    {
+        aTmp <<= sal_Int32((nWidth * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32( nWidth + 160 ); // 100thmm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight + 662 - 714); //100th mm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
 
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
 
     uno::Reference<beans::XPropertySet> xPropSet( mxParent, uno::UNO_QUERY );
     OCX_ContainerControl::Import( xPropSet );
 
     uno::Reference<io::XInputStreamProvider> xSource =
-        xmlscript::exportDialogModel(mxParent, mxCtx);
+        xmlscript::exportDialogModel(mxParent, mxCtx, pDocSh->GetModel() );
     uno::Any aSourceAny(uno::makeAny(xSource));
     if (rLib->hasByName(sName))
         rLib->replaceByName(sName, aSourceAny);
     else
         rLib->insertByName(sName, aSourceAny);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+		try
+		{
+        	xDialogPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+		}
+		catch( uno::Exception& )
+		{
+			OSL_TRACE("OCX_UserForm::Import, Image fails to import");
+		}
+    }
     return sal_True;
 }
 
@@ -4780,11 +4955,14 @@ sal_Bool OCX_CheckBox::Import(com::sun::
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-    if (pValue && !bSetInDialog)
+	if (pValue)
     {
         INT16 nTmp=pValue[0]-0x30;
         aTmp <<= nTmp;
-        rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		if ( !bSetInDialog )
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
     }
 
     if (pCaption)
@@ -5194,12 +5372,6 @@ sal_Bool OCX_TabStrip::ReadFontData(SotS
 
 sal_Bool OCX_Image::Read(SotStorageStream *pS)
 {
-    if ( !bSetInDialog )
-    {
-        // preserve the present behavior at the moment.
-        // only import image control for UserForms
-        return sal_False;
-    }
     ULONG nStart = pS->Tell();
     *pS >> nIdentifier;
     DBG_ASSERT(nStandardId==nIdentifier,
@@ -5290,16 +5462,14 @@ sal_Bool OCX_Image::Read(SotStorageStrea
 
         long imagePos = pS->Tell();
 
-        pS->Seek( imagePos );
-
-        sImageUrl =  C2U("vnd.sun.star.expand:${$BRAND_BASE_DIR/program/") + C2U( SAL_CONFIGFILE( "bootstrap" ) ) + C2U("::UserInstallation}/user/temp/") + sName;
-
-        sal_uInt8* pImage = new sal_uInt8[ nImageLen ];
-        pS->Read(pImage, nImageLen);
-        bool result = storePictureInFileSystem( sImageUrl, pImage, nImageLen );
-        OUString pictName = sImageUrl.copy( sImageUrl.lastIndexOf('/') + 1 );
-        result = storePictureInDoc( pDocSh, pictName, pImage, nImageLen );
-        delete pImage;
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nImageLen );
     }
     return sal_True;
 }
@@ -5467,7 +5637,7 @@ OCX_SpinButton::OCX_SpinButton() :
     mbPropThumb( true )
 {
     msFormType = C2U("com.sun.star.form.component.SpinButton");
-    msDialogType = C2U("com.sun.star.awt.UnoControlSpinButtonModel");
+    msDialogType = C2U("com.sun.star.form.component.SpinButton");
     mnBackColor = 0x8000000F;
     mnForeColor = 0x80000012;
 }
@@ -5504,8 +5674,8 @@ sal_Bool OCX_SpinButton::Read( SvStorage
     if( mnBlockFlags & 0x00000080 )     rStrm >> mnValue;
     if( mnBlockFlags & 0x00000100 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00000200 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000400 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000800 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000400 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000800 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00001000 )     rStrm >> mnPageStep;
     if( mnBlockFlags & 0x00002000 )     rStrm >> mnOrient;
     if( mnBlockFlags & 0x00004000 )
@@ -5590,6 +5760,9 @@ sal_Bool OCX_SpinButton::Import(com::sun
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
@@ -5757,7 +5930,7 @@ OCX_ScrollBar::OCX_ScrollBar()
     sName = OUString( RTL_CONSTASCII_USTRINGPARAM( "ScrollBar" ) );
     mnMax = 32767;
     msFormType = C2U("com.sun.star.form.component.ScrollBar");
-    msDialogType = C2U("com.sun.star.awt.UnoControlScrollBarModel");
+    msDialogType = C2U("com.sun.star.form.component.ScrollBar");
 
 }
 
@@ -5823,6 +5996,9 @@ sal_Bool OCX_ScrollBar::Import(com::sun:
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
--- svx/source/msfilter/msoleexp.cxx.old	2009-10-07 15:07:01.000000000 +0200
+++ svx/source/msfilter/msoleexp.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -231,7 +231,12 @@ void SvxMSExportOLEObjects::ExportOLEObj
             aSeq[1].Name = ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "FilterName" ) );
             aSeq[1].Value <<= ::rtl::OUString( pExpFilter->GetName() );
             uno::Reference < frame::XStorable > xStor( rObj->getComponent(), uno::UNO_QUERY );
+        try
+        {
             xStor->storeToURL( ::rtl::OUString::createFromAscii( "private:stream" ), aSeq );
+        }
+        catch( uno::Exception& ) {} // #TODO really handle exceptions - interactionalhandler etc. ? 
+        
             SotStorageRef xOLEStor = new SotStorage( pStream, TRUE );
             xOLEStor->CopyTo( &rDestStg );
             rDestStg.Commit();
--- svx/source/msfilter/mstoolbar.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ svx/source/msfilter/mstoolbar.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,817 @@
+#include <svx/mstoolbar.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <fstream>
+#include <vcl/graph.hxx>
+#include <vcl/bitmapex.hxx>
+#include <vcl/image.hxx>
+#include <map>
+#include <sfx2/objsh.hxx>
+#include <basic/basmgr.hxx>
+#include <svtools/filterutils.hxx>
+#include <boost/scoped_array.hpp>
+#include <svx/msvbahelper.hxx>
+#include <svtools/miscopt.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/window.hxx>
+
+using namespace com::sun::star;
+
+int TBBase::nIndent = 0;
+
+void CustomToolBarImportHelper::showToolbar( const rtl::OUString& rName )
+{
+    try
+    {
+        uno::Reference< frame::XController > xCntrller( mrDocSh.GetModel()->getCurrentController(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xCntrller->getFrame(), uno::UNO_QUERY_THROW );
+        uno::Reference< frame::XLayoutManager > xLayoutMgr( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LayoutManager") ) ), uno::UNO_QUERY_THROW );
+        xLayoutMgr->showElement( rName );
+    }
+    catch( uno::Exception& ) {}
+}
+
+void CustomToolBarImportHelper::ScaleImage( uno::Reference< graphic::XGraphic >& xGraphic, long nNewSize )
+{
+    Graphic aGraphic( xGraphic );
+    Size aSize = aGraphic.GetSizePixel();
+    if ( aSize.Height() && ( aSize.Height() == aSize.Width() ) )
+    {
+        Image aImage( xGraphic );
+        if ( aSize.Height() != nNewSize )
+        {
+            BitmapEx aBitmap = aImage.GetBitmapEx();
+            BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, nNewSize );
+            aImage = Image( aBitmapex);
+            xGraphic = aImage.GetXGraphic();
+        }
+    } 
+}
+
+void CustomToolBarImportHelper::applyIcons()
+{
+    for ( std::vector< iconcontrolitem >::iterator it = iconcommands.begin(); it != iconcommands.end(); ++it )
+    {
+        uno::Sequence< rtl::OUString > commands(1);
+        commands[ 0 ] = it->sCommand;
+        uno::Sequence< uno::Reference< graphic::XGraphic > > images(1);
+        images[ 0 ] = it->image;
+       
+        OSL_TRACE("About to applyIcons for command %s, have image ? %s", rtl::OUStringToOString( commands[ 0 ], RTL_TEXTENCODING_UTF8 ).getStr(), images[ 0 ].is() ? "yes" : "no" );
+        uno::Reference< ui::XImageManager > xImageManager( getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        sal_uInt16 nColor = ui::ImageType::COLOR_NORMAL; 
+
+        Window* topwin = Application::GetActiveTopWindow();
+	if ( topwin != NULL && topwin->GetDisplayBackground().GetColor().IsDark() )
+            nColor = css::ui::ImageType::COLOR_HIGHCONTRAST;
+
+        ScaleImage( images[ 0 ], 16 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_DEFAULT | nColor,  commands, images );
+        ScaleImage( images[ 0 ], 26 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_LARGE | nColor,  commands, images );
+    }
+}
+
+void CustomToolBarImportHelper::addIcon( const uno::Reference< graphic::XGraphic >& xImage, const rtl::OUString& sString )
+{
+    iconcontrolitem item;
+    item.sCommand = sString;
+    item.image = xImage;
+    iconcommands.push_back( item );
+}
+
+CustomToolBarImportHelper::CustomToolBarImportHelper( SfxObjectShell& rDocShell,  const css::uno::Reference< css::ui::XUIConfigurationManager>& rxAppCfgMgr ) : mrDocSh( rDocShell ) 
+{
+    m_xCfgSupp.set( mrDocSh.GetModel(), uno::UNO_QUERY_THROW );
+    m_xAppCfgMgr.set( rxAppCfgMgr, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getCfgManager()
+{
+    return m_xCfgSupp->getUIConfigurationManager();
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getAppCfgManager()
+{
+    return m_xAppCfgMgr;
+}
+
+uno::Any 
+CustomToolBarImportHelper::createCommandFromMacro( const rtl::OUString& sCmd )
+{
+//"vnd.sun.star.script:Standard.Module1.Main?language=Basic&location=document"    
+    static rtl::OUString scheme = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document");
+    // create script url
+    rtl::OUString scriptURL = scheme + sCmd + part2;
+    return uno::makeAny( scriptURL );
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOCommandToOOCommand( sal_Int16 msoCmd )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOCommandToOOCommand( msoCmd );
+    return result;
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOTCIDToOOCommand( sal_Int16 msoTCID )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOTCIDToOOCommand( msoTCID );
+    return result;
+}
+
+bool
+CustomToolBarImportHelper::createMenu( const rtl::OUString& rName, const uno::Reference< container::XIndexAccess >& xMenuDesc, bool bPersist )
+{
+    bool bRes = true;
+    try
+    {
+        uno::Reference< ui::XUIConfigurationManager > xCfgManager( getCfgManager() );
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        sMenuBar += rName;
+        uno::Reference< container::XIndexContainer > xPopup( xCfgManager->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xPopup, uno::UNO_QUERY_THROW ); 
+        // set name for menubar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( rName ) );
+        if ( xPopup.is() )
+        {
+            uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+            aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + rName );
+            aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+            aPopupMenu[1].Value <<= rName;
+            aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+            aPopupMenu[2].Value = uno::makeAny( xMenuDesc );
+            aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+            aPopupMenu[3].Value <<= sal_Int32( 0 );
+            
+            xPopup->insertByIndex( xPopup->getCount(), uno::makeAny( aPopupMenu ) );
+            if ( bPersist )
+            {
+                xCfgManager->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xPopup, uno::UNO_QUERY ) );
+                uno::Reference< ui::XUIConfigurationPersistence > xPersistence( xCfgManager, uno::UNO_QUERY_THROW );
+                xPersistence->store();
+            }
+        }
+    }
+    catch( uno::Exception& )
+    {
+        bRes = false;
+    }
+    return bRes;
+}
+
+void
+TBBase::indent_printf( FILE* fp, const char* format, ... )
+{
+   va_list ap;
+   va_start ( ap, format );
+
+   // indent nIndent spaces
+   for ( int i=0; i<nIndent; ++i)
+      fprintf(fp," ");
+   // append the rest of the message
+   vfprintf( fp, format, ap );
+   va_end( ap );
+}
+
+rtl::OUString TBBase::readUnicodeString( SvStream* pS, sal_Int32 nChars )
+{
+    sal_Int32 nBufSize = nChars * 2;
+    boost::scoped_array< sal_uInt8 > pArray( new sal_uInt8[ nBufSize ] );
+    pS->Read( pArray.get(), nBufSize );
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray(  reinterpret_cast< const char* >( pArray.get() ), nBufSize );
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+}
+
+bool TBCHeader::Read( SvStream* pS )
+{
+    OSL_TRACE("TBCHeader::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width.reset( new sal_uInt16 );
+        height.reset( new sal_uInt16 );
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCHeader -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  bFlagsTCR 0x%x\n", bFlagsTCR );
+    indent_printf(fp,"  tct 0x%x\n", tct );
+    indent_printf(fp,"  tcid 0x%x\n", tcid );
+    indent_printf(fp,"  tbct 0x%x\n", static_cast< unsigned int >( tbct ));
+    indent_printf(fp,"  bPriority 0x%x\n", bPriority );
+    if ( width.get() )
+        indent_printf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height.get() )
+        indent_printf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+TBCData::TBCData( const TBCHeader& Header ) : rHeader( Header )
+{
+}
+
+bool TBCData::Read(SvStream *pS)
+{
+    OSL_TRACE("TBCData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    switch ( rHeader.getTct() )
+    {
+        case 0x01: // (Button control)
+        case 0x10: // (ExpandingGrid control)
+            controlSpecificInfo.reset( new TBCBSpecific() );
+            break;
+        case 0x0A: // (Popup control)
+        case 0x0C: // (ButtonPopup control)
+        case 0x0D: // (SplitButtonPopup control)
+        case 0x0E: // (SplitButtonMRUPopup control)
+            controlSpecificInfo.reset( new TBCMenuSpecific() );
+            break;
+        case 0x02: // (Edit control)
+        case 0x04: // (ComboBox control)
+        case 0x14: // (GraphicCombo control)
+        case 0x03: // (DropDown control)
+        case 0x06: // (SplitDropDown control)
+        case 0x09: // (GraphicDropDown control)
+            controlSpecificInfo.reset( new TBCComboDropdownSpecific( rHeader ) );
+            break;
+        default:
+            break;
+    }
+    if ( controlSpecificInfo.get() )
+        return controlSpecificInfo->Read( pS );
+    //#FIXME I need to be able to handle different controlSpecificInfo types.
+    return true;
+}
+
+TBCMenuSpecific* TBCData::getMenuSpecific()
+{
+    TBCMenuSpecific* pMenu = dynamic_cast< TBCMenuSpecific* >( controlSpecificInfo.get() );
+    return pMenu;
+}
+bool TBCData::ImportToolBarControl( CustomToolBarImportHelper& helper, std::vector< css::beans::PropertyValue >& props, bool& bBeginGroup, bool bIsMenuBar )
+{
+    sal_uInt16  nStyle = 0;
+    bBeginGroup = rHeader.isBeginGroup();
+    controlGeneralInfo.ImportToolBarControlData( helper, props );
+    beans::PropertyValue aProp;
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Visible") ) ;
+    aProp.Value = uno::makeAny( rHeader.isVisible() ); // where is the visible attribute stored
+    props.push_back( aProp );
+    if ( rHeader.getTct() == 0x01
+    || rHeader.getTct() == 0x10 )
+    {
+        TBCBSpecific* pSpecificInfo = dynamic_cast< TBCBSpecific* >( controlSpecificInfo.get() );
+        if ( pSpecificInfo )
+        {
+            // if we have a icon then lets  set it for the command 
+            rtl::OUString sCommand;
+            for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it )
+            {
+                if ( it->Name.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ) )
+                    it->Value >>= sCommand;
+            }
+            if ( TBCBitMap* pIcon = pSpecificInfo->getIcon() )
+            {
+                // Without a command openoffice won't display the icon
+                if ( sCommand.getLength() )
+                {    
+                    BitmapEx aBitEx( pIcon->getBitMap() );
+                    if ( pSpecificInfo->getIconMask() )
+                         // according to the spec:
+                         // "the iconMask is white in all the areas in which the icon is
+                         // displayed as transparent and is black in all other areas."
+                         aBitEx = BitmapEx( aBitEx.GetBitmap(), pSpecificInfo->getIconMask()->getBitMap().CreateMask( Color( COL_WHITE ) ) );
+    
+                    Graphic aGraphic( aBitEx );
+                    helper.addIcon( aGraphic.GetXGraphic(), sCommand );
+                }
+            }
+            else if ( pSpecificInfo->getBtnFace() )
+            {
+               
+                rtl::OUString sBuiltInCmd = helper.MSOTCIDToOOCommand(  *pSpecificInfo->getBtnFace() );
+                if ( sBuiltInCmd.getLength() )
+                {
+                    uno::Sequence< rtl::OUString> sCmds(1);
+                    sCmds[ 0 ] = sBuiltInCmd;
+                    uno::Reference< ui::XImageManager > xImageManager( helper.getAppCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+                    // 0 = default image size
+                    uno::Sequence< uno::Reference< graphic::XGraphic > > sImages = xImageManager->getImages( 0, sCmds );
+                    if ( sImages.getLength() && sImages[0].is() )
+                        helper.addIcon( sImages[0], sCommand );
+                }
+            }
+        }
+    }
+    else if ( rHeader.getTct() == 0x0a )
+    {
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ;
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        
+        TBCMenuSpecific* pMenu = getMenuSpecific();
+        if ( pMenu )
+            aProp.Value = uno::makeAny( sMenuBar += pMenu->Name() ); // name of popup
+        nStyle |= ui::ItemStyle::DROP_DOWN;
+        props.push_back( aProp );
+    }
+
+    short icontext =  ( rHeader.getTbct() & 0x03 );
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Style") ) ;
+    if ( bIsMenuBar )
+    {
+        nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || icontext == 0x3 )
+            // Text And image
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    else 
+    {
+        if ( ( icontext & 0x02 ) == 0x02 )
+            nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || ( icontext & 0x03 ) == 0x03 )
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    aProp.Value <<= nStyle;
+    props.push_back( aProp );
+    return true; // just ignore
+}
+
+void TBCData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCData -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    //if ( rHeader.getTct() == 1 )
+    if ( controlSpecificInfo.get() )
+    {
+        indent_printf(fp,"  dumping controlSpecificInfo( TBCBSpecificInfo )\n");
+        controlSpecificInfo->Print( fp );
+    }
+}
+
+bool
+WString::Read( SvStream *pS )
+{
+    OSL_TRACE("WString::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCExtraInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCExtraInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    indent_printf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tbcu 0x%x\n", tbcu );
+    indent_printf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+rtl::OUString
+TBCExtraInfo::getOnAction()
+{
+    return wstrOnAction.getString();
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCGeneralInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    if ( ( bFlags & 0x1 ) && !customText.Read( pS ) )
+        return false;
+    if ( ( bFlags & 0x2 ) && ( !descriptionText.Read( pS ) ||  !tooltip.Read( pS ) ) )
+        return false;
+    if ( ( bFlags & 0x4 ) && !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCGeneralInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    indent_printf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( bFlags & 0x4 ) 
+        extraInfo.Print( fp );
+}
+
+bool 
+TBCGeneralInfo::ImportToolBarControlData( CustomToolBarImportHelper& helper, std::vector< beans::PropertyValue >& sControlData )
+{
+    if ( ( bFlags & 0x5 ) )
+    {
+        beans::PropertyValue aProp;
+        // probably access to the header would be a better test than seeing if there is an action, e.g.
+        // if ( rHeader.getTct() == 0x01 && rHeader.getTcID() == 0x01 ) // not defined, probably this is a command
+        if ( extraInfo.getOnAction().getLength() )
+        {
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            ooo::vba::VBAMacroResolvedInfo aMacroInf = ooo::vba::resolveVBAMacro( &helper.GetDocShell(), extraInfo.getOnAction(), true );
+            if ( aMacroInf.IsResolved() )
+                aProp.Value = helper.createCommandFromMacro( aMacroInf.ResolvedMacro() );
+            else
+                aProp.Value <<= rtl::OUString::createFromAscii("UnResolvedMacro[").concat( extraInfo.getOnAction() ).concat( rtl::OUString::createFromAscii("]") );
+            sControlData.push_back( aProp );
+        }
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+        aProp.Value = uno::makeAny( customText.getString().replace('&','~') );
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+        aProp.Value = uno::makeAny( ui::ItemType::DEFAULT ); 
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Tooltip") );
+        aProp.Value = uno::makeAny( tooltip.getString() ); 
+        sControlData.push_back( aProp );
+/*
+aToolbarItem(0).Name = "CommandURL" wstrOnAction
+aToolbarItem(0).Value = Command
+aToolbarItem(1).Name = "Label"      customText
+aToolbarItem(1).Value = Label
+aToolbarItem(2).Name = "Type"
+aToolbarItem(2).Value = 0
+aToolbarItem(3).Name = "Visible"
+aToolbarItem(3).Value = true        
+*/
+    }
+    return true;
+}
+
+TBCMenuSpecific::TBCMenuSpecific() : tbid( 0 )
+{
+}
+
+bool
+TBCMenuSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCMenuSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbid;
+    if ( tbid == 1 ) 
+    {
+        name.reset( new WString() );
+        return name->Read( pS );
+    }
+    return true;
+}
+
+void 
+TBCMenuSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCMenuSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  tbid 0x%x\n", static_cast< unsigned int >( tbid ) );
+    if ( tbid == 1 )
+        indent_printf( fp, "  name %s\n", rtl::OUStringToOString( name->getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+rtl::OUString TBCMenuSpecific::Name()
+{
+    rtl::OUString aName;
+    if ( name.get() )
+        aName = name->getString();
+    return aName;
+}
+TBCBSpecific::TBCBSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCBSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCBSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCBSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCBSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    indent_printf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent b;
+        indent_printf( fp, "  icon: \n");
+        icon->Print( fp ); // will dump size
+    }
+    bResult = ( iconMask.get() != NULL );
+    indent_printf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent c;
+        indent_printf( fp, "  icon mask: \n");
+        iconMask->Print( fp ); // will dump size
+    }
+    if ( iBtnFace.get() )
+    {
+        indent_printf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    }
+    bResult = ( wstrAcc.get() != NULL );
+    indent_printf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCBitMap* 
+TBCBSpecific::getIcon()
+{
+    return icon.get();
+}
+
+TBCBitMap* 
+TBCBSpecific::getIconMask()
+{
+    return iconMask.get();
+}
+
+TBCComboDropdownSpecific::TBCComboDropdownSpecific(const TBCHeader& header ) 
+{
+    if ( header.getTcID() == 0x01 )
+        data.reset( new TBCCDData() );
+}
+
+bool TBCComboDropdownSpecific::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    if ( data.get() )
+        return data->Read( pS );
+    return true;
+}
+
+void TBCComboDropdownSpecific::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCComboDropdownSpecific -- dump\n", nOffSet );
+    if ( data.get() )
+        data->Print( fp );
+    else
+        indent_printf(fp," no data " );
+}
+
+TBCCDData::TBCCDData() : cwstrItems( 0 )
+,iSel( 0 )
+,cLines( 0 )
+,dxWidth( 0 )
+{
+}
+
+TBCCDData::~TBCCDData()
+{
+}
+
+bool TBCCDData::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    *pS >> cwstrItems;
+    if ( cwstrItems )
+    {
+        for( sal_Int32 index=0; index < cwstrItems; ++index )
+        {
+            WString aString;
+            if ( !aString.Read( pS ) )
+                return false;
+            wstrList.push_back( aString );
+        } 
+    }
+    *pS >> cwstrMRU >> iSel >> cLines >> dxWidth;
+
+    return wstrEdit.Read( pS );
+}
+
+void TBCCDData::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCCDData -- dump\n", nOffSet );
+    indent_printf(fp,"  cwstrItems items in wstrList 0x%d\n", cwstrItems);
+    for ( sal_Int32 index=0; index < cwstrItems; ++index )
+    {
+        Indent b;
+        indent_printf(fp, "  wstrList[%d] %s", static_cast< int >( index ), rtl::OUStringToOString( wstrList[index].getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    indent_printf(fp,"  cwstrMRU num most recently used string 0x%d item\n", cwstrMRU);
+    indent_printf(fp,"  iSel index of selected item 0x%d item\n", iSel);
+    indent_printf(fp,"  cLines num of suggested lines to display 0x%d", cLines);
+    indent_printf(fp,"  dxWidth width in pixels 0x%d", dxWidth);
+    indent_printf(fp,"  wstrEdit %s", rtl::OUStringToOString( wstrEdit.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), size( 0 )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+}
+
+// #FIXME Const-ness
+Bitmap& 
+TBCBitMap::getBitMap()
+{
+    return mBitMap;
+}
+
+bool TBCBitMap::Read( SvStream* pS)
+{
+    OSL_TRACE("TBCBitMap::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    return mBitMap.Read( *pS, FALSE, TRUE );
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] TBCBitMap -- dump\n", nOffSet );
+    indent_printf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
+
+TB::TB() : bSignature(0x2),
+bVersion(0x1),
+cCL(0),
+ltbid( 0x1 ),
+ltbtr(0),
+cRowsDefault( 0 ),
+bFlags( 0 )
+{
+}
+
+bool TB::Read(SvStream *pS)
+{
+    OSL_TRACE("TB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    name.Read( pS );
+    return true;
+ 
+}
+
+bool TB::IsEnabled()
+{
+    return ( bFlags & 0x01 ) != 0x01;
+}
+
+bool TB::NeedsPositioning()
+{
+    return ( bFlags & 0x10 ) == 0x10;
+}
+
+void TB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TB -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  cCL 0x%x\n", cCL );
+    indent_printf(fp,"  ltbid 0x%x\n", ltbid );
+    indent_printf(fp,"  ltbtr 0x%x\n", ltbtr );
+    indent_printf(fp,"  cRowsDefault 0x%x\n", cRowsDefault );
+    indent_printf(fp,"  bFlags 0x%x\n", bFlags );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBVisualData::TBVisualData() : tbds(0), tbv(0), tbdsDock(0), iRow(0)
+{
+}
+
+bool TBVisualData::Read( SvStream* pS )
+{
+    OSL_TRACE("TBVisualData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbds >> tbv >> tbdsDock >> iRow;
+    rcDock.Read( pS );
+    rcFloat.Read( pS );
+    return true;
+}
+
+void SRECT::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "  left 0x%x\n", left);
+    indent_printf( fp, "  top 0x%x\n", top);
+    indent_printf( fp, "  right 0x%x\n", right);
+    indent_printf( fp, "  bottom 0x%x\n", bottom);
+}
+
+void TBVisualData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBVisualData -- dump\n", nOffSet );
+    indent_printf( fp, "  tbds 0x%x\n", tbds);
+    indent_printf( fp, "  tbv  0x%x\n", tbv);
+    indent_printf( fp, "  tbdsDoc  0x%x\n", tbdsDock);
+    indent_printf( fp, "  iRow  0x%x\n", iRow);
+    rcDock.Print( fp );
+    rcFloat.Print( fp );
+}
+
--- svx/source/msfilter/msvbahelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ svx/source/msfilter/msvbahelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,7 @@
 #include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 #include <tools/urlobj.hxx>
 #include <osl/file.hxx>
+#include <svtools/pathoptions.hxx>
 
 using namespace ::com::sun::star;
 
@@ -99,7 +100,17 @@ SfxObjectShell* findShellForUrl( const r
             }
             else
             {
-                if ( aURL.equals( xModel->getURL() ) )
+                // sometimes just the name of the document ( without the path
+                // is used
+                bool bDocNameNoPathMatch = false;
+                if ( aURL.getLength() && aURL.indexOf( '/' ) == -1 )
+                {
+                    sal_Int32 lastSlashIndex = xModel->getURL().lastIndexOf( '/' );
+                    if ( lastSlashIndex > -1 )
+                        bDocNameNoPathMatch = xModel->getURL().copy( lastSlashIndex + 1 ).equals( aURL );
+                } 
+                             
+                if ( aURL.equals( xModel->getURL() ) || bDocNameNoPathMatch )
                 {
                     pFoundShell = pShell; 
                     break;
@@ -206,9 +217,19 @@ VBAMacroResolvedInfo resolveVBAMacro( Sf
         String sDocUrlOrPath = MacroName.copy( 0, nDocSepIndex );
         sMacroUrl = MacroName.copy( nDocSepIndex + 1 );
         OSL_TRACE("doc search, current shell is 0x%x", pShell );
-        SfxObjectShell* pFoundShell = findShellForUrl( sDocUrlOrPath );
+        SfxObjectShell* pFoundShell = NULL;
+        if( bSearchGlobalTemplates )
+        {
+            SvtPathOptions aPathOpt;
+            String aAddinPath = aPathOpt.GetAddinPath();
+            if( rtl::OUString( sDocUrlOrPath ).indexOf( aAddinPath ) == 0 )
+                pFoundShell = pShell; 
+        }
+        if( pFoundShell == NULL )
+            pFoundShell = findShellForUrl( sDocUrlOrPath );
         OSL_TRACE("doc search, after find, found shell is 0x%x", pFoundShell );
-        aRes = resolveVBAMacro( pFoundShell, sMacroUrl ); 
+        aRes = resolveVBAMacro( pFoundShell, sMacroUrl, bSearchGlobalTemplates ); 
+        return aRes;
     }    
     else
     {
--- svx/source/msfilter/msvbasic.cxx.old	2009-10-07 15:07:01.000000000 +0200
+++ svx/source/msfilter/msvbasic.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,801 @@
 #include <osl/endian.h>
 #include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
 #include "msvbasic.hxx"
+#include <fstream>
+#include <memory>
+#include <rtl/ustrbuf.hxx>
+#include <boost/shared_ptr.hpp>
+#include <boost/scoped_array.hpp>
+#include <boost/shared_array.hpp>
+#include <svtools/filterutils.hxx>
+
+using namespace ::com::sun::star::script;
+
+namespace MSLZSS {
+
+static unsigned int getShift( sal_uInt32 nPos )
+{
+    if (nPos <= 0x80) {
+        if (nPos <= 0x20)
+            return (nPos <= 0x10) ? 12 : 11;
+        else
+            return (nPos <= 0x40) ? 10 : 9;
+    } else {
+    if (nPos <= 0x200)
+        return (nPos <= 0x100) ? 8 : 7;
+    else if (nPos <= 0x800)
+        return (nPos <= 0x400) ? 6 : 5;
+    else
+        return 4;
+    }
+}
+
+SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL )
+{
+    SvMemoryStream *pResult;
+    const sal_Int32 nWINDOWLEN = 4096;
+    pResult = new SvMemoryStream();
+
+    sal_uInt8 nLeadbyte;
+    unsigned int nPos = 0;
+    int nLen, nDistance, nShift, nClean=1;
+    sal_uInt8 aHistory[ nWINDOWLEN ];
+
+    pStream->Seek( nOffset + 3 );
+
+    while( pStream->Read( &nLeadbyte, 1 ) )
+    {
+        for(int nMask=0x01; nMask < 0x100; nMask = nMask<<1)
+        {
+            // we see if the leadbyte has flagged this location as a dataunit
+            // which is actually a token which must be looked up in the history
+            if( nLeadbyte & nMask )
+            {
+                sal_uInt16 nToken;
+            
+                *pStream >> nToken;
+    
+                if (nClean == 0)
+                    nClean=1;
+    
+                //For some reason the division of the token into the length
+                //field of the data to be inserted, and the distance back into
+                //the history differs depending on how full the history is
+                nShift = getShift( nPos % nWINDOWLEN );
+        
+                nLen = (nToken & ((1<<nShift) - 1)) + 3;
+                nDistance = nToken >> nShift;
+        
+                //read the len of data from the history, wrapping around the
+                //nWINDOWLEN boundary if necessary data read from the history
+                //is also copied into the recent part of the history as well.
+                for (int i = 0; i < nLen; i++)
+                {
+                    unsigned char c;
+                    c = aHistory[(nPos-nDistance-1) % nWINDOWLEN];
+                    aHistory[nPos % nWINDOWLEN] = c;
+                    nPos++;
+                }
+            }
+            else
+            {
+                // special boundary case code, not guarantueed to be correct
+                // seems to work though, there is something wrong with the
+                // compression scheme (or maybe a feature) where when the data
+                // ends on a nWINDOWLEN boundary and the excess bytes in the 8
+                // dataunit list are discarded, and not interpreted as tokens
+                // or normal data.
+                if ((nPos != 0) && ((nPos % nWINDOWLEN) == 0) && (nClean))
+                {
+                    pStream->SeekRel(2);
+                    nClean=0;
+                    pResult->Write( aHistory, nWINDOWLEN );
+                    break;
+                }
+                //This is the normal case for when the data unit is not a
+                //token to be looked up, but instead some normal data which
+                //can be output, and placed in the history.
+                if (pStream->Read(&aHistory[nPos % nWINDOWLEN],1))
+                    nPos++;
+                    
+                if (nClean == 0)
+                    nClean=1;
+            }
+        }
+    }
+    if (nPos % nWINDOWLEN)
+        pResult->Write( aHistory, nPos % nWINDOWLEN );
+    pResult->Flush();
+
+    if( pCompressedLength )
+        *pCompressedLength = nPos;
+    
+    if( pLength )
+        *pLength = pResult->Tell();
+
+    pResult->Seek( 0 );
+
+    return pResult;
+} 
+
+} //MSZSS
+
+// also _VBA_PROJECT_VDPI can be used to create a usable 
+// ( and much smaller ) "_VBA_PROJECT" stream
+
+// _VBA_PROJECT Stream Version Dependant Project Information
+// _VBA_PROJECT Stream Version Dependant Project Information
+
+class _VBA_PROJECT_VDPI
+{
+public:
+sal_Int16 Reserved1;
+sal_Int16 Version;
+sal_Int8 Reserved2;
+sal_Int16 Reserved3;
+boost::scoped_array< sal_uInt8 > PerformanceCache;
+sal_Int32 PerformanceCacheSize;
+_VBA_PROJECT_VDPI(): Reserved1( 0x61CC), Version( 0xFFFF ), Reserved2(0x0), Reserved3(0x0), PerformanceCacheSize(0) {}
+~_VBA_PROJECT_VDPI()
+{
+    PerformanceCacheSize = 0;
+}
+void read(){}
+void write( SvStream* pStream )
+{
+    *pStream << Reserved1 << Version << Reserved2 << Reserved3;
+    if ( PerformanceCacheSize )
+    {
+        PerformanceCache.reset( new sal_uInt8[ PerformanceCacheSize ] );
+        pStream->Read( PerformanceCache.get(), PerformanceCacheSize );
+    }
+}
+};
+
+class ProjectSysKindRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 SysKind;
+ProjectSysKindRecord(): Id(0x1), Size(0x4), SysKind( 0x1 ) {}
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> Size >> SysKind;
+}
+};
+
+class ProjectLcidRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 Lcid;
+
+ProjectLcidRecord() : Id( 0x2 ), Size( 0x4 ), Lcid( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> Lcid;
+}
+};
+
+class ProjectLcidInvokeRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 LcidInvoke;
+public:
+ProjectLcidInvokeRecord() : Id( 0x14 ), Size( 0x4 ), LcidInvoke( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidInvokeRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> LcidInvoke;
+}
+};
+
+class ProjectCodePageRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int16 CodePage;
+public:
+// #FIXME get a better default for the CodePage
+ProjectCodePageRecord() : Id( 0x03 ), Size( 0x2 ), CodePage( 0x0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectCodePageRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> CodePage;
+}
+};
+class ProjectNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfProjectName;
+rtl::OUString ProjectName;
+ProjectNameRecord() : Id( 0x04 ), SizeOfProjectName( 0x0 ){}
+~ProjectNameRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectNameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfProjectName;
+
+    if ( SizeOfProjectName ) 
+    {
+        boost::scoped_array< sal_uInt8 > pProjectName( new sal_uInt8[ SizeOfProjectName ] );
+        OSL_TRACE("ProjectNameRecord about to read name from [0x%x], size %d", pStream->Tell(), SizeOfProjectName );
+        pStream->Read( pProjectName.get(), SizeOfProjectName );
+        ProjectName = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pProjectName.get() ), SizeOfProjectName );
+    }
+}
+};
+
+class ProjectDocStringRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfDocString;
+sal_Int16 Reserved;
+sal_Int32 SizeOfDocStringUnicode;
+rtl::OUString DocString;
+rtl::OUString DocStringUnicode; 
+
+ProjectDocStringRecord() : Id( 0x5 ), SizeOfDocString( 0x0 ), Reserved( 0x0 ), SizeOfDocStringUnicode( 0 ){}
+
+~ProjectDocStringRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectDocStringRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfDocString;
+
+
+    boost::scoped_array< sal_uInt8 > pDocString( new sal_uInt8[ SizeOfDocString ] );
+    pStream->Read( pDocString.get(), SizeOfDocString );
+ 
+    DocString = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pDocString.get() ), SizeOfDocString );
+
+    *pStream >> Reserved >> SizeOfDocStringUnicode;
+
+    boost::scoped_array< sal_uInt8 > pDocStringUnicode( new sal_uInt8[ SizeOfDocStringUnicode ] );
+
+    pStream->Read( pDocStringUnicode.get(), SizeOfDocStringUnicode );
+    DocStringUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pDocStringUnicode.get() ), SizeOfDocString );
+
+}
+
+};
+
+class ProjectHelpFilePath
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfHelpFile1;
+boost::scoped_array< sal_uInt8 > HelpFile1;
+sal_Int16 Reserved;
+sal_Int32 SizeOfHelpFile2;
+boost::scoped_array< sal_uInt8 > HelpFile2;
+
+ProjectHelpFilePath() : Id( 0x06 ), SizeOfHelpFile1(0), Reserved(0x0), SizeOfHelpFile2(0) {}
+~ProjectHelpFilePath()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectHelpFilePath [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfHelpFile1;
+
+    HelpFile1.reset( new sal_uInt8[ SizeOfHelpFile1 ] );
+    pStream->Read( HelpFile1.get(), SizeOfHelpFile1 );
+
+    *pStream >> Reserved >> SizeOfHelpFile2;
+
+    HelpFile2.reset( new sal_uInt8[ SizeOfHelpFile2 ] );
+    pStream->Read( HelpFile2.get(), SizeOfHelpFile2 );
+  
+}
+};
+
+class ProjectHelpContextRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;    
+sal_Int32 HelpContext;    
+
+ProjectHelpContextRecord() : Id( 0x7 ), Size( 0x4 ), HelpContext( 0 ) {}
+void read( SvStream* pStream )
+{
+    
+   OSL_TRACE("ProjectHelpContextRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> Size >> HelpContext;
+}
+
+};
+
+class ProjectLibFlagsRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 ProjectLibFlags;
+
+public:
+ProjectLibFlagsRecord() : Id( 0x8 ), Size( 0x4 ), ProjectLibFlags( 0x0 ) {}
+void read( SvStream* pStream ) 
+{
+    OSL_TRACE("ProjectLibFlagsRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> ProjectLibFlags;
+}
+};
+
+class ProjectVersionRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Reserved;
+sal_Int32 VersionMajor;
+sal_Int16 VersionMinor;
+ProjectVersionRecord() : Id( 0x9 ), Reserved( 0x4 ), VersionMajor( 0x1 ), VersionMinor( 0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectVersionRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Reserved >> VersionMajor >> VersionMinor;
+}
+};
+
+class ProjectConstantsRecord
+{
+sal_Int16 Id;
+sal_Int32 SizeOfConstants;
+boost::scoped_array< sal_uInt8 > Constants;
+sal_Int16 Reserved;
+sal_Int32 SizeOfConstantsUnicode;
+boost::scoped_array< sal_uInt8 > ConstantsUnicode;
+public:
+ProjectConstantsRecord() : Id( 0xC ), SizeOfConstants( 0 ), Constants( 0 ), Reserved( 0x3C ), SizeOfConstantsUnicode( 0 ), ConstantsUnicode(0) {}
+
+~ProjectConstantsRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectConstantsRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> SizeOfConstants;
+    Constants.reset( new sal_uInt8[ SizeOfConstants ] );
+
+    pStream->Read( Constants.get(), SizeOfConstants );
+
+    *pStream >> Reserved;
+
+    *pStream >> SizeOfConstantsUnicode;
+
+    ConstantsUnicode.reset( new sal_uInt8[ SizeOfConstantsUnicode ] );
+    pStream->Read( ConstantsUnicode.get(), SizeOfConstantsUnicode );
+}
+
+};
+
+class ReferenceNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfName;
+rtl::OUString Name;
+sal_Int16 Reserved;
+sal_Int32 SizeOfNameUnicode;
+rtl::OUString NameUnicode;
+
+ReferenceNameRecord() : Id( 0x16 ), SizeOfName( 0 ), Reserved( 0x3E ), SizeOfNameUnicode( 0 ){}
+~ReferenceNameRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("NameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfName;
+ 
+    boost::scoped_array< sal_uInt8 > pName( new sal_uInt8[ SizeOfName ] );
+
+    pStream->Read( pName.get(), SizeOfName );
+    Name = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pName.get() ), SizeOfName );
+
+    *pStream >> Reserved >> SizeOfNameUnicode;
+
+    boost::scoped_array< sal_uInt8 > pNameUnicode( new sal_uInt8[ SizeOfNameUnicode ] );
+    pStream->Read( pNameUnicode.get(), SizeOfNameUnicode );
+    NameUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pNameUnicode.get() ), SizeOfName );
+}
+
+};
+
+// Baseclass for ReferenceControlRecord, ReferenceRegisteredRecord, ReferenceProjectRecord
+class DirDumper; 
+
+class BaseReferenceRecord 
+{
+public:
+virtual ~BaseReferenceRecord(){}
+virtual bool read( SvStream* pStream ) = 0;
+virtual void import( VBA_Impl& ){}
+};
+
+
+class ReferenceProjectRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibidAbsolute;
+    sal_uInt32 SizeOfLibidRelative; 
+    sal_uInt32 MajorVersion;
+    sal_uInt16 MinorVersion;
+    rtl::OUString AbsoluteLibid; 
+    rtl::OUString RelativeLibid; 
+
+    virtual bool read( SvStream* pStream );
+    virtual void import( VBA_Impl& rDir );
+    ReferenceProjectRecord();
+    ~ReferenceProjectRecord();
+};
+
+ReferenceProjectRecord::ReferenceProjectRecord() : Id( 0x000E ), Size( 0 ), SizeOfLibidAbsolute( 0 ), SizeOfLibidRelative( 0 ), MajorVersion( 0 ), MinorVersion( 0 )
+{ 
+}
+
+ReferenceProjectRecord::~ReferenceProjectRecord()
+{
+}
+
+bool ReferenceProjectRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceProjectRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibidAbsolute;
+
+    boost::scoped_array< sal_uInt8 > pLibidAbsolute( new sal_uInt8[ SizeOfLibidAbsolute ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidAbsolute at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidAbsolute.get(), SizeOfLibidAbsolute );
+
+    *pStream >> SizeOfLibidRelative; 
+
+    boost::scoped_array< sal_uInt8 > pLibidRelative( new sal_uInt8[ SizeOfLibidRelative ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidRelative at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidRelative.get(), SizeOfLibidRelative );
+
+    *pStream >> MajorVersion >> MinorVersion;
+
+    // array size is ORed with SVX_MSOCX_COMPRESSED to force processing of ascii bytes ( and not 
+    // 16 bit unicode )
+    // the offset of 3 is needed to skip the ProjectReference "*\" and project kind ( 0x4[1-4] ) info.
+
+    AbsoluteLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidAbsolute.get() + 3 ), (SizeOfLibidAbsolute - 3 ) );
+    RelativeLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidRelative.get() + 3 ), ( SizeOfLibidRelative -3 ) );
+
+    OSL_TRACE("ReferenceProjectRecord - absolute path %s", rtl::OUStringToOString( AbsoluteLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    OSL_TRACE("ReferenceProjectRecord - relative path %s", rtl::OUStringToOString( RelativeLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    return true;
+}
+
+void ReferenceProjectRecord::import( VBA_Impl& rDir )
+{
+    rDir.AddProjectReference( AbsoluteLibid );
+}
+
+class ReferenceRegisteredRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibid;
+    boost::scoped_array< sal_uInt8> pLibid;
+    sal_Int32 Reserved1;
+    sal_Int16 Reserved2;
+
+    ReferenceRegisteredRecord();
+    ~ReferenceRegisteredRecord();
+    bool read( SvStream* pStream );
+};
+
+ReferenceRegisteredRecord::ReferenceRegisteredRecord() : Id( 0x000D ), Size( 0 ), SizeOfLibid( 0 ), Reserved1( 0 ), Reserved2( 0 )
+{
+}
+
+ReferenceRegisteredRecord::~ReferenceRegisteredRecord()
+{
+}
+
+bool 
+ReferenceRegisteredRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRegisteredRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibid;
+    if ( SizeOfLibid )
+    {
+        pLibid.reset( new sal_uInt8[ SizeOfLibid] );
+        pStream->Read( pLibid.get(), SizeOfLibid );
+    }
+    *pStream >> Reserved1 >> Reserved2;
+    return true;
+}
+
+class ReferenceOriginalRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 SizeOfLibOriginal;
+    boost::scoped_array< sal_uInt8 > pLibidOriginal;
+
+
+ReferenceOriginalRecord() : Id( 0x033 ), SizeOfLibOriginal( 0 )
+{
+}
+
+~ReferenceOriginalRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> SizeOfLibOriginal;
+    if ( SizeOfLibOriginal )
+    {
+        pLibidOriginal.reset( new sal_uInt8[ SizeOfLibOriginal ] );
+        pStream->Read( pLibidOriginal.get(), SizeOfLibOriginal );
+    }
+}
+
+};
+
+class ReferenceControlRecord : public BaseReferenceRecord
+{
+public:
+std::auto_ptr< ReferenceOriginalRecord > OriginalRecord;
+sal_Int16 Id;
+sal_uInt32 SizeTwiddled;
+sal_uInt32 SizeOfLibidTwiddled;
+boost::shared_array< sal_uInt8 > LibidTwiddled;
+sal_uInt32 Reserved1;
+sal_uInt16 Reserved2;
+std::auto_ptr< ReferenceNameRecord > NameRecordExtended;// Optional
+sal_uInt16 Reserved3;
+sal_uInt32 SizeExtended;
+sal_uInt32 SizeOfLibidExtended;
+boost::shared_array< sal_uInt8 > LibidExtended;
+sal_uInt32 Reserved4;
+sal_uInt16 Reserved5;
+sal_uInt8  OriginalTypeLib[ 16 ];
+sal_uInt32 Cookie;
+
+ReferenceControlRecord() : Id( 0x2F ), SizeTwiddled( 0 ), SizeOfLibidTwiddled( 0 ), Reserved1( 0 ), Reserved2( 0 ), Reserved3( 0x30 ), SizeExtended( 0 ), SizeOfLibidExtended( 0 ), Reserved4( 0 ), Reserved5( 0 ), Cookie( 0 )
+{
+    for( int i = 0; i < 16; ++i )
+        OriginalTypeLib[ i ] = 0;
+}
+
+~ReferenceControlRecord()
+{
+}
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceControlRecord [0x%x]", pStream->Tell() ); 
+    long nPos = pStream->Tell();
+
+    *pStream >> Id;
+    pStream->Seek( nPos ); // point before the peeked Id
+    if ( Id == 0x33 ) // we have an OriginalRecord
+    {
+        OriginalRecord.reset( new ReferenceOriginalRecord() );
+        OriginalRecord->read( pStream );
+    }
+    *pStream >> Id >> SizeTwiddled >> SizeOfLibidTwiddled;
+
+    if ( SizeOfLibidTwiddled )
+    {
+        LibidTwiddled.reset( new sal_uInt8[ SizeOfLibidTwiddled ] );
+        pStream->Read( LibidTwiddled.get(),  SizeOfLibidTwiddled );
+    }
+
+    *pStream >> Reserved1 >> Reserved2;
+
+    nPos = pStream->Tell();
+    // peek at the id for optional NameRecord
+    sal_Int16 nTmpId;
+    *pStream >> nTmpId;
+    if ( nTmpId == 0x30 )
+    {
+        Reserved3 = 0x30;
+    }
+    else
+    {
+        pStream->Seek( nPos );
+        NameRecordExtended.reset( new ReferenceNameRecord() );
+        NameRecordExtended->read( pStream );
+        *pStream >> Reserved3;
+    }
+    *pStream >> SizeExtended >> SizeOfLibidExtended;
+
+    if ( SizeExtended )
+    {
+        LibidExtended.reset( new sal_uInt8[ SizeOfLibidExtended ] ); 
+        pStream->Read( LibidExtended.get(), SizeOfLibidExtended );
+    } 
+
+    *pStream >> Reserved4;
+    *pStream >> Reserved5;
+
+    pStream->Read( OriginalTypeLib, sizeof( OriginalTypeLib ) );
+    *pStream >> Cookie;
+    return true;
+}
+
+};
+
+class ReferenceRecord : public BaseReferenceRecord
+{
+public:
+// NameRecord is Optional
+std::auto_ptr< ReferenceNameRecord > NameRecord;
+std::auto_ptr< BaseReferenceRecord >  aReferenceRecord;
+
+ReferenceRecord(){}
+~ReferenceRecord()
+{
+}
+
+// false return would mean failed to read Record e.g. end of array encountered
+// Note: this read routine will make sure the stream is pointing to where it was the 
+// method was called ) 
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRecord [0x%x]", pStream->Tell() );
+    bool bRead = true;
+    long nStart = pStream->Tell();
+    long nPos = nStart;
+    // Peek at the ID 
+    sal_Int16 Id;
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+    if ( Id == 0x16 ) // Optional NameRecord
+    {
+        NameRecord.reset( new ReferenceNameRecord() );
+        NameRecord->read( pStream ); 
+    }
+    else if ( Id == 0x0f )
+    {
+        pStream->Seek( nStart );
+        bRead = false;
+        return bRead; // start of module, terminate read
+    }
+
+    nPos = pStream->Tell(); // mark position, peek at next Id
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+
+    switch( Id )
+    {
+        case 0x0D:
+            aReferenceRecord.reset( new ReferenceRegisteredRecord() );
+            break; 
+        case 0x0E:
+            aReferenceRecord.reset( new ReferenceProjectRecord() );
+            break; 
+        case 0x2F:
+        case 0x33:
+            aReferenceRecord.reset( new ReferenceControlRecord() );
+            break; 
+        default:
+            bRead = false;
+            OSL_TRACE("Big fat error, unknown ID 0x%x", Id);
+            break;
+    } 
+    if ( bRead )
+        aReferenceRecord->read( pStream );
+    return bRead;
+}
+
+void import( VBA_Impl& rVBA )
+{
+    if ( aReferenceRecord.get() )
+        aReferenceRecord->import( rVBA );
+}
+
+};
+
+class DirDumper
+{
+public:
+ProjectSysKindRecord mSysKindRec;
+ProjectLcidRecord mLcidRec;
+ProjectLcidInvokeRecord mLcidInvokeRec;
+ProjectCodePageRecord mCodePageRec;
+ProjectNameRecord mProjectNameRec;
+ProjectDocStringRecord mDocStringRec;
+ProjectHelpFilePath mHelpFileRec;
+ProjectHelpContextRecord mHelpContextRec;
+ProjectLibFlagsRecord mLibFlagsRec;
+ProjectVersionRecord mVersionRec;
+ProjectConstantsRecord mConstantsRecord;
+std::vector< ReferenceRecord* > ReferenceArray;
+
+DirDumper() {}
+~DirDumper() 
+{
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        delete *it;
+    
+}
+
+void read( SvStream* pStream )
+{
+    sal_Int32 nPos = pStream->Tell();
+#ifdef DEBUG
+    std::ofstream aDump("dir.dump");
+    while ( !pStream->IsEof() ) 
+    {
+        sal_Int8 aByte;
+        *pStream >> aByte;
+        aDump << aByte;
+    }
+    aDump.flush();
+#endif
+    pStream->Seek( nPos );
+    readProjectInformation( pStream );
+    readProjectReferenceInformation( pStream );
+}
+
+void readProjectReferenceInformation( SvStream* pStream )
+{
+    bool bKeepReading = true;
+    while( bKeepReading )
+    {
+        ReferenceRecord* pRef = new ReferenceRecord();
+        bKeepReading = pRef->read( pStream );
+        if ( bKeepReading ) 
+            ReferenceArray.push_back( pRef );
+    }
+}
+
+void readProjectInformation( SvStream* pStream )
+{
+    mSysKindRec.read( pStream );
+    mLcidRec.read( pStream ); 
+    mLcidInvokeRec.read( pStream );
+    mCodePageRec.read( pStream );
+    mProjectNameRec.read( pStream );
+    mDocStringRec.read( pStream );
+    mHelpFileRec.read( pStream );
+    mHelpContextRec.read( pStream );
+    mLibFlagsRec.read( pStream );
+    mVersionRec.read( pStream ); 
+    sal_Int32 nPos = pStream->Tell();
+    sal_uInt16 nTmp;
+    *pStream >> nTmp;
+    if ( nTmp == 0x0C )
+    {
+        pStream->Seek( nPos );
+        mConstantsRecord.read( pStream );
+    }
+    OSL_TRACE("After Information pos is 0x%x", pStream->Tell() );
+}
+
+void import( VBA_Impl& rVBA )
+{
+    // get project references
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        (*it)->import( rVBA );
+    rVBA.SetProjectName( mProjectNameRec.ProjectName );
+    
+}
+};
+
 
 /*
 A few urls which may in the future be of some use
@@ -153,7 +948,21 @@ int VBA_Impl::ReadVBAProject(const SvSto
     xVBAProject = rxVBAStorage->OpenSotStream(
                     String( RTL_CONSTASCII_USTRINGPARAM( "_VBA_PROJECT" ) ),
                     STREAM_STD_READ | STREAM_NOCREATE );
-
+    // read Dir stream
+    SvStorageStreamRef xDir = rxVBAStorage->OpenSotStream(
+                    String( RTL_CONSTASCII_USTRINGPARAM( "dir" ) ),
+					STREAM_STD_READ | STREAM_NOCREATE );
+// disable read and import of Dir stream bits, e.g. project references and
+// project name for 3.1 ( a bit unstable yet )
+#if 1
+    // decompress the stream
+    std::auto_ptr< SvMemoryStream > xCmpDir;
+    xCmpDir.reset( MSLZSS::decompressAsStream( xDir, 0 ) );
+    // try to parse the dir stream
+    DirDumper dDump;
+    dDump.read( xCmpDir.get() );
+    dDump.import( *this );
+#endif
     if( !xVBAProject.Is() || SVSTREAM_OK != xVBAProject->GetError() )
     {
         DBG_WARNING("Not able to find vba project, cannot find macros");
@@ -432,7 +1241,7 @@ int VBA_Impl::ReadVBAProject(const SvSto
  *
 */
 
-ModuleType VBA_Impl::GetModuleType( const UniString& rModuleName )
+ModType VBA_Impl::GetModuleType( const UniString& rModuleName )
 {
     ModuleTypeHash::iterator iter = mhModHash.find( rModuleName );
     ModuleTypeHash::iterator iterEnd = mhModHash.end();
@@ -440,7 +1249,7 @@ ModuleType VBA_Impl::GetModuleType( cons
     {
         return iter->second;
     }
-    return Unknown;
+    return ModuleType::Unknown;
 }
 
 bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
@@ -453,6 +1262,7 @@ bool VBA_Impl::Open( const String &rTopl
     if( !xMacros.Is() || SVSTREAM_OK != xMacros->GetError() )
     {
         DBG_WARNING("No Macros Storage");
+		OSL_TRACE("No Macros Storage");
     }
     else
     {
@@ -462,6 +1272,7 @@ bool VBA_Impl::Open( const String &rTopl
         if( !xVBA.Is() || SVSTREAM_OK != xVBA->GetError() )
         {
             DBG_WARNING("No Visual Basic in Storage");
+			OSL_TRACE("No Visual Basic in Storage");
         }
         else
         {
@@ -476,6 +1287,7 @@ bool VBA_Impl::Open( const String &rTopl
          * ( value ) is either a Class Module, Form Module or a plain VB Module.        */
         SvStorageStreamRef xProject = xMacros->OpenSotStream(
             String( RTL_CONSTASCII_USTRINGPARAM( "PROJECT" ) ) );
+
         SvStorageStream* pStp = xProject;
         UniString tmp;
         static const String sThisDoc(   RTL_CONSTASCII_USTRINGPARAM( "ThisDocument" ) );
@@ -483,7 +1295,7 @@ bool VBA_Impl::Open( const String &rTopl
         static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
         static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
         static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
-        mhModHash[ sThisDoc ] = Class;
+        mhModHash[ sThisDoc ] = ModuleType::Class;
         while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
         {
             xub_StrLen index = tmp.Search( '=' );
@@ -493,14 +1305,14 @@ bool VBA_Impl::Open( const String &rTopl
                 String value = tmp.Copy( index + 1 );
                 if ( key == sClass )
                 {
-                    mhModHash[ value ] = Class;
+                    mhModHash[ value ] = ModuleType::Class;
                     OSL_TRACE("Module %s is of type Class",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sBaseClass )
                 {
-                    mhModHash[ value ] =  Form;
+                    mhModHash[ value ] =  ModuleType::Form;
                     OSL_TRACE("Module %s is of type Form",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
@@ -513,14 +1325,14 @@ bool VBA_Impl::Open( const String &rTopl
                     // value is of form <name>/&H<identifier>, strip the identifier
                     value.Erase( value.Search( '/' ) );
 
-                    mhModHash[ value ] = Document;
+                    mhModHash[ value ] = ModuleType::Document;
                     OSL_TRACE("Module %s is of type Document VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sModule )
                 {
-                    mhModHash[ value ] = Normal;
+                    mhModHash[ value ] = ModuleType::Normal;
                     OSL_TRACE("Module %s is of type Normal VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
--- svx/source/msfilter/msvbasic.hxx.old	2009-10-07 15:07:01.000000000 +0200
+++ svx/source/msfilter/msvbasic.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -45,6 +45,8 @@
 #include <vector>
 #endif
 #include<map>
+#include <com/sun/star/script/ModuleType.hpp>
+using namespace ::com::sun::star::script::ModuleType;
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -68,13 +70,12 @@ DECLARE_DYNARRAY(StringArray,String *)
 // #117718# define internal types to distinguish between
 // module types, form, class & normal
 // #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 // #117718# define map to hold types of module
 //
-
+typedef sal_Int32 ModType;
 typedef ::std::map< UniString,
-    ModuleType > ModuleTypeHash;
+    ModType > ModuleTypeHash;
 
 class VBA_Impl
 {
@@ -95,10 +96,15 @@ public:
     void Output(int len, const sal_uInt8 *data);
     //
     // #117718# member map of module names to types of module
-    ModuleType GetModuleType( const UniString& rModuleName );
-
-    std::vector<String> maReferences;
+    ModType GetModuleType( const UniString& rModuleName );
+    rtl::OUString& ProjectName() { return msProjectName; }
+    void SetProjectName( const rtl::OUString& rPName ) { msProjectName = rPName; }
+    const std::vector<rtl::OUString>& ProjectReferences() { return maPrjReferences; }
+    void AddProjectReference( const rtl::OUString& rProject ) { maPrjReferences.push_back( rProject); }
+    SvStorage* GetStorage() { return xStor; }
 private:
+    std::vector<rtl::OUString> maReferences;
+    std::vector<rtl::OUString> maPrjReferences;
     struct VBAOffset_Impl
     {
         String sName;
@@ -124,6 +130,7 @@ private:
     int ReadVBAProject(const SvStorageRef &rxVBAStorage);
     int DecompressVBA(int index, SvStorageStreamRef &rxVBAStream);
     sal_uInt8 ReadPString(SvStorageStreamRef &xVBAProject, bool bIsUnicode);
+    rtl::OUString msProjectName;
 };
 
 #endif
--- svx/source/msfilter/svxmsbas.cxx.old	2009-10-08 16:17:56.000000000 +0200
+++ svx/source/msfilter/svxmsbas.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -53,6 +53,7 @@ using namespace com::sun::star::awt;
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -61,17 +62,45 @@ using namespace com::sun::star;
 
 using rtl::OUString;
 
+static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
+
+void SvxImportMSVBasic::extractAttribute( const String& rAttribute, const String& rModName )
+{
+    // format of the attribute we are interested in is
+    // Attribute VB_Control = "ControlName", intString, MSForms, ControlTypeAsString
+    // e.g.
+    // Attribute VB_Control = "CommandButton1, 201, 19, MSForms, CommandButton"
+    String sControlAttribute( RTL_CONSTASCII_USTRINGPARAM("Attribute VB_Control = \"") );
+    if ( rAttribute.Search( sControlAttribute ) !=  STRING_NOTFOUND )
+    {
+        String sRest = rAttribute.Copy( sControlAttribute.Len() );
+        xub_StrLen nPos = 0; 
+        String sCntrlName = sRest.GetToken( 0, ',', nPos );
+        
+        sal_Int32 nCntrlId = sRest.GetToken( 0, ',', nPos).ToInt32();
+        m_ModuleNameToObjIdHash[ rModName ][ nCntrlId ] =  sCntrlName;
+    }
+}
 int SvxImportMSVBasic::Import( const String& rStorageName,
                                 const String &rSubStorageName,
                                 BOOL bAsComment, BOOL bStripped )
 {
+    std::vector< String > codeNames;
+    return Import(  rStorageName, rSubStorageName, codeNames, bAsComment, bStripped );
+}
+int SvxImportMSVBasic::Import( const String& rStorageName,
+								const String &rSubStorageName,
+								const std::vector< String >& codeNames,
+								BOOL bAsComment, BOOL bStripped )
+{
+        msProjectName = rtl::OUString();
     int nRet = 0;
-    if( bImport && ImportCode_Impl( rStorageName, rSubStorageName,
+	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName, codeNames, 
                                     bAsComment, bStripped ))
         nRet |= 1;
 
     if (bImport)
-        ImportForms_Impl(rStorageName, rSubStorageName);
+        ImportForms_Impl(rStorageName, rSubStorageName, !bAsComment);
 
     if( bCopy && CopyStorage_Impl( rStorageName, rSubStorageName ))
         nRet |= 2;
@@ -80,9 +109,44 @@ int SvxImportMSVBasic::Import( const Str
 }
 
 bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
-    const String& rSubStorageName)
+    const String& rSubStorageName, BOOL bVBAMode )
 {
-    SvStorageRef xVBAStg(xRoot->OpenSotStorage(rStorageName,
+    BOOL bRet = FALSE;
+    // #FIXME VBA_Impl ( or some other new class ) should handle both userforms
+    // and code 
+	VBA_Impl aVBA( *xRoot, TRUE );
+    // This call is a waste we read the source ( again ) only to get the refereneces
+    // *AGAIN*, we really need to rewrite all of this
+    aVBA.Open( rStorageName, rSubStorageName ); 
+
+    bRet = ImportForms_Impl( aVBA, rStorageName, rSubStorageName, bVBAMode );
+	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+
+	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+    {
+       rtl::OUString sFileName = *it;
+#ifndef WIN 
+#ifdef DEBUG
+       // hacky test code to read referenced projects on linux
+       sal_Int32 nPos = (*it).lastIndexOf('\\');
+       sFileName = (*it).copy( nPos + 1 );
+       sFileName =  rtl::OUString::createFromAscii("~/Documents/") + sFileName;
+#endif
+#endif
+       SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+	   VBA_Impl refVBA( *rRoot, TRUE );        
+       refVBA.Open( rStorageName, rSubStorageName );
+       // The return from ImportForms doesn't indicate and error ( it could )
+       // but also it just means no userforms were imported
+       if ( ImportForms_Impl( refVBA, rStorageName, rSubStorageName, bVBAMode ) )
+           bRet = true; // mark that at least on userform was imported
+    }
+    return bRet;
+}
+
+bool SvxImportMSVBasic::ImportForms_Impl( VBA_Impl& rVBA, const String& rStorageName, const String& rSubStorageName, BOOL bVBAMode )
+{
+    SvStorageRef xVBAStg(rVBA.GetStorage()->OpenSotStorage(rStorageName,
         STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL));
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
@@ -115,6 +179,10 @@ bool SvxImportMSVBasic::ImportForms_Impl
         DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
 
         String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
+        if (rVBA.ProjectName().getLength() )
+            aLibName = rVBA.ProjectName();
+        OSL_TRACE( "userformage lib name %s", rtl::OUStringToOString( aLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
         Reference<XNameContainer> xLib;
         if (xLibContainer.is())
         {
@@ -164,7 +232,17 @@ bool SvxImportMSVBasic::ImportForms_Impl
                     xSF->createInstance(
                        OUString(RTL_CONSTASCII_USTRINGPARAM(
                            "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
-
+                // #FIXME HACK - mark the Model with the VBA mode
+                // In vba mode the imported userform uses 100th mm as units
+                // or geometry 
+                // In non vba mode MAP_APPFONT is used ( same as normal basic
+                // dialogs
+                if ( bVBAMode )
+                {
+                    Reference<XPropertySet> xDlgProps(xDialog, UNO_QUERY); 
+                    if ( xDlgProps.is() )
+                        xDlgProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ), uno::makeAny( sal_True ) );
+                }
                 OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
                 aForm.pDocSh = &rDocSh;
                 sal_Bool bOk = aForm.Read(xTypes);
@@ -228,29 +306,80 @@ BOOL SvxImportMSVBasic::CopyStorage_Impl
 
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
                                         const String &rSubStorageName,
+										const std::vector< String >& codeNames,
                                         BOOL bAsComment, BOOL bStripped )
 {
     BOOL bRet = FALSE;
     VBA_Impl aVBA( *xRoot, bAsComment );
+        
     if( aVBA.Open(rStorageName,rSubStorageName) )
     {
+        msProjectName = aVBA.ProjectName();
+
+        if ( msProjectName.getLength() )
+            rDocSh.GetBasicManager()->SetName( msProjectName ); // set name of Project
+
+        bRet = ImportCode_Impl( aVBA, codeNames, bAsComment, bStripped );
+    	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+    
+    	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+        {
+            rtl::OUString sFileName = *it;
+    		OSL_TRACE("referenced project %s ", rtl::OUStringToOString( sFileName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+    	    VBA_Impl refVBA( *rRoot, bAsComment );
+			std::vector< String > codeNamesNone;
+    	    if( refVBA.Open(rStorageName,rSubStorageName) && ImportCode_Impl( refVBA, codeNamesNone, bAsComment, bStripped ) )
+                bRet = TRUE; // mark that some code was imported
+        }
+    }
+    return bRet;
+}
+
+BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, const std::vector< String >& codeNames, BOOL bAsComment, BOOL bStripped )
+{
+        BOOL bRet = FALSE;
         SFX_APP()->EnterBasicCall();
         Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
         DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
 
         UINT16 nStreamCount = aVBA.GetNoStreams();
         Reference<XNameContainer> xLib;
+
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
         if( xLibContainer.is() && nStreamCount )
         {
-            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+            if ( aVBA.ProjectName().getLength() )
+                aLibName = aVBA.ProjectName();
+
             if( !xLibContainer->hasByName( aLibName ) )
                 xLibContainer->createLibrary( aLibName );
 
             Any aLibAny = xLibContainer->getByName( aLibName );
             aLibAny >>= xLib;
         }
-        if( xLib.is() )
+		if( xLib.is()  )
         {
+            Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+			if ( !bAsComment )
+            {
+                rDocSh.GetBasicManager()->GetLib( aLibName )->SetVBAEnabled( true );
+                Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                if ( xSF.is() )
+                {
+                    try
+                    {
+                        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
+                    }
+                    catch( Exception& ) { }
+                }
+            }
+            typedef  std::hash_map< rtl::OUString, uno::Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameModuleDataHash;
+
+            NameModuleDataHash moduleData;
+
             for( UINT16 i=0; i<nStreamCount;i++)
             {
                 StringArray aDecompressed = aVBA.Decompress(i);
@@ -284,7 +413,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 // is the same as the encoding for the names
                 // that are keys in the map used by GetModuleType method
                 const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+                ModType mType = aVBA.GetModuleType( sOrigVBAModName );
 
                 rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
 
@@ -292,23 +421,23 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 
                 switch( mType )
                 {
-                    case Class:
+                    case ModuleType::Class:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
                         break;
-                    case Form:
+                    case ModuleType::Form:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
                         break;
-                    case Document:
+                    case ModuleType::Document:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
                         break;
-                    case Normal:
+                    case ModuleType::Normal:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
                         break;
-                    case Unknown:
+                    case ModuleType::Unknown:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
                         break;
@@ -316,12 +445,11 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                         DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
                         break;
                 }
-                static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
                 static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-                if ( !bAsComment )
+				if ( !bAsComment /*&& !rDocSh.GetBasic()->isVBAEnabled() */)
                 {
                     modeTypeComment = modeTypeComment + sVBAOption;
-                    if ( mType == Class )
+					if ( mType == ModuleType::Class )
                         modeTypeComment = modeTypeComment + sClassOption;
 
                 }
@@ -369,7 +497,12 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                             if( nEnd == STRING_NOTFOUND )
                                 pStr->Erase();
                             else
+                            {
+								//OSL_TRACE("Erase %s", rtl::OUStringToOString(*pStr, RTL_TEXTENCODING_UTF8 ).getStr() );
+                                String sAttr= pStr->Copy( nBegin, (nEnd-nBegin)+1);
+                                extractAttribute( sAttr, sModule );
                                 pStr->Erase(nBegin, (nEnd-nBegin)+1);
+                            }
                         }
                     }
                     if( aDecompressed.Get(j)->Len() )
@@ -383,24 +516,79 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                         aSource += rtl::OUString::createFromAscii("\nEnd Sub");
                 }
                 ::rtl::OUString aModName( sModule );
-                if ( aSource.getLength() )
-                {
-                    aSource = modeTypeComment + aSource;
+				aSource = modeTypeComment + aSource;
 
-                    Any aSourceAny;
+				Any aSourceAny;
+                OSL_TRACE("erm %d", mType );
+                if (  !bAsComment )
+                {
+                    OSL_TRACE("vba processing  %d", mType );
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = aModName;
+                    sModuleInfo.ModuleSource = aSource;
+                    sModuleInfo.ModuleType = mType;
+                    aSourceAny <<= sModuleInfo;
+                }
+                else
                     aSourceAny <<= aSource;
-                    if( xLib->hasByName( aModName ) )
-                        xLib->replaceByName( aModName, aSourceAny );
-                    else
-                        xLib->insertByName( aModName, aSourceAny );
-                }                                
+                moduleData[ aModName ] = aSourceAny;
+            }
 
-                bRet = true;
+            // Hack for missing codenames ( only know to happen in excel but... )
+            // only makes sense to do this if we are importing non-commented basic
+            if ( !bAsComment )
+            {
+                for ( std::vector< String >::const_iterator it =  codeNames.begin(); it != codeNames.end(); ++it )
+                {
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = *it;
+                    sModuleInfo.ModuleType = ModuleType::Document ;
+                    sModuleInfo.ModuleSource = sVBAOption;
+                    moduleData[ *it ] = uno::makeAny( sModuleInfo );
+                }
             }
+            NameModuleDataHash::iterator it_end = moduleData.end();
+            for ( NameModuleDataHash::iterator it = moduleData.begin(); it != it_end; ++it )
+            {
+                script::ModuleInfo sModuleInfo;
+                if ( it->second >>=sModuleInfo )
+                {
+            
+                    if ( sModuleInfo.ModuleType == ModuleType::Form )
+                        // hack, the module ( imo document basic should...
+                        // know the XModel... ) but it doesn't
+                        sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+                    //  document modules, we should be able to access
+			        //  the api objects at this time
+                    else if ( sModuleInfo.ModuleType == ModuleType::Document )
+			        {
+                        if ( xVBACodeNamedObjectAccess.is() )
+                        {
+                            try
+                            {
+                                sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
+                                OSL_TRACE("** Straight up creation of Module");
+                            }
+                            catch(uno::Exception& e)
+                            {
+    						    OSL_TRACE("Failed to get documument object for %s", rtl::OUStringToOString( sModuleInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    					    }
+    				    }
+    			    }
+                    it->second = uno::makeAny( sModuleInfo );
+                }
+                     
+                if( xLib->hasByName( it->first ) )
+                    xLib->replaceByName( it->first, it->second );
+                else
+                    xLib->insertByName( it->first, it->second );
+                bRet = true;
+            }                                
+
         }
-        SFX_APP()->LeaveBasicCall();
-    }
-    return bRet;
+        if( bRet )
+            SFX_APP()->LeaveBasicCall();
+	    return bRet;
 }
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
--- sw/inc/doc.hxx.old	2009-10-21 11:49:24.000000000 +0200
+++ sw/inc/doc.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -82,6 +82,7 @@ class SwList;
 #include "comphelper/implementationreference.hxx"
 #include <com/sun/star/chart2/data/XDataProvider.hpp>
 #include <com/sun/star/linguistic2/XProofreadingIterator.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 #include <hash_map>
 #include <stringhash.hxx>
@@ -401,6 +402,8 @@ class SW_DLLPUBLIC SwDoc :
 
     // table of forbidden characters of this document
     vos::ORef<SvxForbiddenCharactersTable>	xForbiddenCharsTable;
+   com::sun::star::uno::Reference<com::sun::star::container::XNameContainer> m_xTemplateToProjectCache;
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > mxVbaEventsHelper;
 
     // --> OD 2007-10-26 #i83479#
 public:
@@ -2112,6 +2115,9 @@ public:
     {
         return n32DummyCompatabilityOptions2;
     }
+        void SetVBATemplateToProjectCache( com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xCache ) { m_xTemplateToProjectCache = xCache; };
+        com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > GetVBATemplateToProjectCache() { return m_xTemplateToProjectCache; };
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > GetVbaEventsHelper();
 
     ::sfx2::IXmlIdRegistry& GetXmlIdRegistry();
     ::sw::MetaFieldManager & GetMetaFieldManager();
--- sw/inc/docsh.hxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/inc/docsh.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -85,6 +85,7 @@ class SW_DLLPUBLIC SwDocShell: public Sf
     comphelper::EmbeddedObjectContainer*    pOLEChildList;
     sal_Int16               nUpdateDocMode; // contains the com::sun::star::document::UpdateDocMode
     bool                    bInUpdateFontList; //prevent nested calls of UpdateFontList
+    bool                    bIsATemplate; //prevent nested calls of UpdateFontList
     // Methoden fuer den Zugriff aufs Doc
     SW_DLLPRIVATE void					AddLink();
     SW_DLLPRIVATE void					RemoveLink();
@@ -301,6 +302,8 @@ public:
                                 GetController();
 
     SfxInPlaceClient* GetIPClient( const ::svt::EmbeddedObjectRef& xObjRef );
+    SW_DLLPRIVATE sal_Bool IsTemplate() { return bIsATemplate; }
+    SW_DLLPRIVATE void SetIsTemplate( bool bValue ) { bIsATemplate = bValue; }
 
     virtual const ::sfx2::IXmlIdRegistry* GetXmlIdRegistry() const;
 };
--- sw/inc/unocoll.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/inc/unocoll.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -198,8 +198,11 @@ class SwUnoCollection
 #define SW_SERVICE_TYPE_FIELDMARK                       107
 #define SW_SERVICE_TYPE_FORMFIELDMARK                   108
 #define SW_SERVICE_TYPE_META                            109
+#define SW_SERVICE_VBAOBJECTPROVIDER                    110
+#define SW_SERVICE_VBACODENAMEPROVIDER                  111
+#define SW_SERVICE_VBAPROJECTNAMEPROVIDER               112
 
-#define SW_SERVICE_LAST                 SW_SERVICE_TYPE_META
+#define SW_SERVICE_LAST                 SW_SERVICE_VBAPROJECTNAMEPROVIDER
 
 #define SW_SERVICE_INVALID			USHRT_MAX
 
--- sw/inc/unotbl.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/inc/unotbl.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -323,7 +323,7 @@ public:
     SwXTextTable(SwFrmFmt& rFrmFmt);
 
 
-    static const ::com::sun::star::uno::Sequence< sal_Int8 > & getUnoTunnelId();
+	SW_DLLPUBLIC static const ::com::sun::star::uno::Sequence< sal_Int8 > & getUnoTunnelId();
 
     //XUnoTunnel
     virtual sal_Int64 SAL_CALL getSomething( const ::com::sun::star::uno::Sequence< sal_Int8 >& aIdentifier ) throw(::com::sun::star::uno::RuntimeException);
--- sw/source/core/doc/doc.cxx.old	2009-10-21 11:49:24.000000000 +0200
+++ sw/source/core/doc/doc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -2007,6 +2007,28 @@ void SwDoc::ChkCondColls()
      }
 }
 
+uno::Reference< document::XVbaEventsHelper > 
+SwDoc::GetVbaEventsHelper()
+{
+	if( !mxVbaEventsHelper.is() )
+	{
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pDocShell ? pDocShell->GetModel() : NULL, uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocumentVbaEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            mxVbaEventsHelper.set( xVbaEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+	}
+	return mxVbaEventsHelper;
+}
+
 void SwDoc::setExternalData(::sw::tExternalDataType eType,
                             ::sw::tExternalDataPointer pPayload)
 {
--- sw/source/core/unocore/unocoll.cxx.old	2009-10-19 13:27:30.000000000 +0200
+++ sw/source/core/unocore/unocoll.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -78,7 +78,14 @@
 
 #include "unometa.hxx"
 #include "docsh.hxx"
-
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <vbahelper/vbahelper.hxx>
+#include <basic/basmgr.hxx>
 
 using ::rtl::OUString;
 using namespace ::com::sun::star;
@@ -88,6 +95,184 @@ using namespace ::com::sun::star::text;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::lang;
 
+class SwVbaCodeNameProvider : public ::cppu::WeakImplHelper1< document::XCodeNameQuery >
+{
+    SwDocShell* mpDocShell;
+    rtl::OUString msThisDocumentCodeName;
+public:
+    SwVbaCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+        // XCodeNameQuery
+    rtl::OUString SAL_CALL getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+    {
+        // Initialise the code name
+        if ( msThisDocumentCodeName.getLength() == 0 )
+        {
+            try
+            {
+                uno::Reference< beans::XPropertySet > xProps( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< container::XNameAccess > xLibContainer( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BasicLibraries") ) ), uno::UNO_QUERY_THROW );
+		rtl::OUString sProjectName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) );
+                if ( mpDocShell->GetBasicManager()->GetName().Len() )
+                    sProjectName =  mpDocShell->GetBasicManager()->GetName();
+    
+                uno::Reference< container::XNameAccess > xStandard( xLibContainer->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+                uno::Sequence< rtl::OUString > sModuleNames = xStandard->getElementNames();
+                for ( sal_Int32 i=0; i < sModuleNames.getLength(); ++i )
+                {
+                    script::ModuleInfo mInfo;
+                    if ( xStandard->getByName( sModuleNames[ i ] ) >>= mInfo )
+                    {
+                        if ( mInfo.ModuleType == script::ModuleType::Document )
+                        {
+                            msThisDocumentCodeName = sModuleNames[ i ];
+                            break;
+                        }
+                    } 
+                }
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+        rtl::OUString sCodeName;
+        if ( mpDocShell )
+        {
+            OSL_TRACE( "*** In ScVbaCodeNameProvider::getCodeNameForObject");
+            // need to find the page ( and index )  for this control
+            uno::Reference< drawing::XDrawPageSupplier > xSupplier( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+            sal_Int32 nLen = xIndex->getCount();
+            bool bMatched = false;
+            uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+                try
+                {
+                    uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex, uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                    // get the www-standard container
+                    uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                    sal_Int32 nCntrls = xFormControls->getCount();
+                    for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                    {
+                        uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                        bMatched = ( xControl == xIf );
+                        if ( bMatched )
+                        {
+                            sCodeName = msThisDocumentCodeName;
+                            break;
+                        }
+                    }
+                }
+                catch( uno::Exception& ) {}
+        }
+        // Probably should throw here ( if !bMatched )
+        return sCodeName;
+    }
+};
+
+typedef std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash > StringHashMap;
+class SwVbaProjectNameProvider : public ::cppu::WeakImplHelper1< container::XNameContainer >
+{
+    SwDocShell* mpDocShell;
+    StringHashMap mTemplateToProject; 
+public:
+    SwVbaProjectNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        return ( mTemplateToProject.find( aName ) != mTemplateToProject.end() );
+    }
+    virtual ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        return uno::makeAny( mTemplateToProject.find( aName )->second );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aElements( mTemplateToProject.size() );
+        StringHashMap::iterator it_end = mTemplateToProject.end();
+        sal_Int32 index = 0;
+        for ( StringHashMap::iterator it = mTemplateToProject.begin(); it != it_end; ++it, ++index )
+            aElements[ index ] = it->first;
+        return aElements;
+    }
+
+    virtual void SAL_CALL insertByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::ElementExistException, com::sun::star::lang::WrappedTargetException )
+    {
+        
+        rtl::OUString sProjectName;
+        aElement >>= sProjectName;
+        OSL_TRACE("** Template cache inserting template name %s with project %s"
+            , rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr()
+            , rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mTemplateToProject[ aName ] = sProjectName;
+    }
+
+    virtual void SAL_CALL removeByName( const rtl::OUString& Name ) throw ( com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( Name ) )
+            throw container::NoSuchElementException();
+        mTemplateToProject.erase( Name );
+    }
+    virtual void SAL_CALL replaceByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        insertByName( aName, aElement ); // insert will overwrite
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        return ::getCppuType((const rtl::OUString*)0); 
+    }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) 
+    { 
+        
+        return ( mTemplateToProject.size() > 0 );
+    }
+
+};
+
+class SwVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    SwDocShell* mpDocShell;
+public:
+    SwVbaObjectForCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        // #FIXME #TODO is the code name for ThisDocument read anywhere?
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        // #FIXME #TODO we really need to be checking against the codename for 
+        // ThisDocument 
+        if ( aName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisDocument" ) ) ) )
+            return sal_True;
+        return sal_False;
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+             throw container::NoSuchElementException();
+	uno::Sequence< uno::Any > aArgs( 2 );
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( mpDocShell->GetModel() );
+        uno::Reference< uno::XInterface > xDocObj = ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.word.Document" , aArgs );
+        OSL_TRACE("Creating Object ( ooo.vba.word.Document ) 0x%x", xDocObj.get() );
+        return  uno::makeAny( xDocObj );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aNames;
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
+
 /******************************************************************************
  *
  ******************************************************************************/
@@ -210,6 +395,9 @@ const ProvNamesId_Type __FAR_DATA aProvN
     { "com.sun.star.text.Fieldmark",                          SW_SERVICE_TYPE_FIELDMARK },
     { "com.sun.star.text.FormFieldmark",                      SW_SERVICE_TYPE_FORMFIELDMARK },
     { "com.sun.star.text.InContentMetadata",                  SW_SERVICE_TYPE_META },
+    { "ooo.vba.VBAObjectModuleObjectProvider",                SW_SERVICE_VBAOBJECTPROVIDER },
+    { "ooo.vba.VBACodeNameProvider",                          SW_SERVICE_VBACODENAMEPROVIDER },
+    { "ooo.vba.VBAProjectNameProvider",                       SW_SERVICE_VBAPROJECTNAMEPROVIDER },
 
     // case-correct versions of the service names (see #i67811)
     { CSS_TEXT_TEXTFIELD_DATE_TIME,                   SW_SERVICE_FIELDTYPE_DATETIME },
@@ -390,6 +578,30 @@ uno::Reference< uno::XInterface >   SwXS
             xRet =  (cppu::OWeakObject*)pFieldmark;
         }
         break;
+		case  SW_SERVICE_VBAOBJECTPROVIDER :
+		{
+			SwVbaObjectForCodeNameProvider* pObjProv = new SwVbaObjectForCodeNameProvider( pDoc->GetDocShell() );
+			xRet =  (cppu::OWeakObject*)pObjProv;
+		}
+		break;
+		case  SW_SERVICE_VBACODENAMEPROVIDER :
+		{
+			SwVbaCodeNameProvider* pObjProv = new SwVbaCodeNameProvider( pDoc->GetDocShell() );
+			xRet =  (cppu::OWeakObject*)pObjProv;
+		}
+		break;
+		case  SW_SERVICE_VBAPROJECTNAMEPROVIDER :
+		{
+                        uno::Reference< container::XNameContainer > xProjProv = pDoc->GetVBATemplateToProjectCache();
+                        if ( !xProjProv.is() )
+                        {
+			    xProjProv = new SwVbaProjectNameProvider( pDoc->GetDocShell() );
+                            pDoc->SetVBATemplateToProjectCache( xProjProv );
+                        }
+			//xRet =  (cppu::OWeakObject*)xProjProv;
+			xRet = xProjProv;
+		}
+		break;
         case  SW_SERVICE_TYPE_FOOTNOTE :
             xRet =  (cppu::OWeakObject*)new SwXFootnote(sal_False);
         break;
--- sw/source/core/unocore/unomap.cxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/source/core/unocore/unomap.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1591,11 +1591,13 @@ const SfxItemPropertyMapEntry* SwUnoProp
                     { SW_PROP_NMID(UNO_NAME_CHAR_LOCALE), RES_CHRATR_LANGUAGE ,   CPPU_E2T(CPPUTYPE_LOCALE), PropertyAttribute::MAYBEVOID,  MID_LANG_LOCALE },
                     { SW_PROP_NMID(UNO_NAME_CHARACTER_COUNT), WID_DOC_CHAR_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_DIALOG_LIBRARIES), WID_DOC_DIALOG_LIBRARIES,  CPPU_E2T(CPPUTYPE_REFLIBCONTAINER), PropertyAttribute::READONLY, 0},
+                    { SW_PROP_NMID(UNO_NAME_VBA_DOCOBJ), WID_DOC_VBA_DOCOBJ,  CPPU_E2T(CPPUTYPE_PROPERTYVALUE), PropertyAttribute::READONLY, 0},
                     { SW_PROP_NMID(UNO_NAME_INDEX_AUTO_MARK_FILE_U_R_L), WID_DOC_AUTO_MARK_URL, CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_PARAGRAPH_COUNT), WID_DOC_PARA_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_RECORD_CHANGES), WID_DOC_CHANGES_RECORD,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_SHOW_CHANGES), WID_DOC_CHANGES_SHOW,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_WORD_COUNT), WID_DOC_WORD_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
+					{ SW_PROP_NMID(UNO_NAME_IS_TEMPLATE), WID_DOC_ISTEMPLATEID,			CPPU_E2T(CPPUTYPE_BOOLEAN),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_WORD_SEPARATOR), WID_DOC_WORD_SEPARATOR,		CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_HIDE_FIELD_TIPS), WID_DOC_HIDE_TIPS, 			CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
                     { SW_PROP_NMID(UNO_NAME_REDLINE_DISPLAY_TYPE), WID_DOC_REDLINE_DISPLAY, 	CPPU_E2T(CPPUTYPE_INT16),	PROPERTY_NONE,   0},
--- sw/source/core/unocore/unoprnms.cxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/source/core/unocore/unoprnms.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -781,6 +781,9 @@ const SwPropNameTab aPropNameTab = {
 /* 0736 UNO_NAME_OUTLINE_LEVEL */       {MAP_CHAR_LEN("OutlineLevel")},//#outline level,add<-zhaojianwei Outlinelevel
 /* 0737 UNO_NAME_DESCRIPTION */         {MAP_CHAR_LEN("Description")},
 /* 0738 UNO_NAME_META */        {MAP_CHAR_LEN("InContentMetadata")},
+/* 0739 UNO_NAME_IS_TEMPLATE */       {MAP_CHAR_LEN("IsTemplate")},
+/* 0740 UNO_NAME_VBA_DOCOBJ */       {MAP_CHAR_LEN("ThisVBADocObj")},
+
 };
 
 const SwPropNameLen& SwGetPropName( USHORT nId )
--- sw/source/filter/ww8/makefile.mk.old	2009-10-21 11:49:24.000000000 +0200
+++ sw/source/filter/ww8/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -71,6 +71,7 @@ EXCEPTIONSFILES = \
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
+        $(SLO)$/ww8toolbar.obj \
         $(SLO)$/WW8FibData.obj
 
 
@@ -100,6 +101,7 @@ SLOFILES =	\
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/WW8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
+        $(SLO)$/ww8toolbar.obj \
         $(SLO)$/WW8FibData.obj
 
 
--- sw/source/filter/ww8/ww8par.cxx.old	2010-01-21 01:00:04.000000000 +0100
+++ sw/source/filter/ww8/ww8par.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -132,11 +132,19 @@
 #include <svtools/itemiter.hxx>  //SfxItemIter
 
 #include <stdio.h>
+#include <comphelper/processfactory.hxx>
+#include <basic/basmgr.hxx>
+
+#include "ww8toolbar.hxx"
+#include <osl/file.hxx>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif
+#include <unotools/localfilehelper.hxx>
+#include <comphelper/configurationhelper.hxx>
 
 #include "WW8Sttbf.hxx"
 #include "WW8FibData.hxx"
@@ -148,6 +156,87 @@ using namespace sw::util;
 using namespace sw::types;
 using namespace nsHdFtFlags;
 
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/container/XNameReplace.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <svx/msvbahelper.hxx>
+#include <svtools/pathoptions.hxx>
+#include <com/sun/star/ucb/XSimpleFileAccess.hpp>
+
+class Sttb : TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    SBBItem() : cchData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+
+    std::vector< SBBItem > dataItems;
+
+    Sttb(const Sttb&);
+    Sttb& operator = ( const Sttb&);
+public:
+    Sttb();
+    ~Sttb();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    rtl::OUString getStringAtIndex( sal_uInt32 );
+};
+
+Sttb::Sttb() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+{
+}
+
+Sttb::~Sttb()
+{
+}
+
+bool Sttb::Read( SvStream* pS )
+{
+    OSL_TRACE("Sttb::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            SBBItem aItem;
+            *pS >> aItem.cchData;
+            aItem.data = readUnicodeString( pS, aItem.cchData );
+            dataItems.push_back( aItem );
+        }
+    }
+    return true;
+}
+
+void Sttb::Print( FILE* fp )
+{
+    fprintf( fp, "[ 0x%x ] Sttb - dump\n", nOffSet);
+    fprintf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    fprintf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            fprintf(fp,"   string dataItem[ %d(0x%x) ] has name %s\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+
+}
+
+rtl::OUString 
+Sttb::getStringAtIndex( sal_uInt32 index )
+{
+    rtl::OUString aRet;
+    if ( index < dataItems.size() )
+        aRet = dataItems[ index ].data;
+    return aRet;
+}
 
 SwMSDffManager::SwMSDffManager( SwWW8ImplReader& rRdr )
     : SvxMSDffManager(*rRdr.pTableStream, rRdr.GetBaseURL(), rRdr.pWwFib->fcDggInfo,
@@ -3733,11 +3822,164 @@ void SwWW8ImplReader::ReadDocInfo()
         DBG_ASSERT(xDocProps.is(), "DocumentProperties is null");
 
         if (xDocProps.is()) {
+            if ( pWwFib->fDot )
+            {
+                rtl::OUString sTemplateURL;
+                SfxMedium* pMedium = mpDocShell->GetMedium();
+                if ( pMedium )
+                {
+                    rtl::OUString aName = pMedium->GetName();
+                    INetURLObject aURL( aName );
+                    sTemplateURL = aURL.GetMainURL(INetURLObject::DECODE_TO_IURI);
+                    if ( sTemplateURL.getLength() > 0 )
+                        xDocProps->setTemplateURL( sTemplateURL );
+                }
+            }
+            else // not a template
+            {
+                long nCur = pTableStream->Tell();
+                Sttb aSttb;
+                pTableStream->Seek( pWwFib->fcSttbfAssoc ); // point at tgc record
+                if (!aSttb.Read( pTableStream ) )
+                    OSL_TRACE("** Read of SttbAssoc data failed!!!! ");
+                pTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+                aSttb.Print( stderr );
+#endif
+                String sPath = aSttb.getStringAtIndex( 0x1 );
+                String aURL;
+                // attempt to convert to url ( won't work for obvious reasons on  linux 
+                if ( sPath.Len() )
+	        	::utl::LocalFileHelper::ConvertPhysicalNameToURL( sPath, aURL );
+                if ( aURL.Len() )
+                    xDocProps->setTemplateURL( aURL );
+                else
+                    xDocProps->setTemplateURL( sPath );
+                
+            }
             sfx2::LoadOlePropertySet(xDocProps, pStg);
         }
     }
 }
 
+void lcl_createTemplateToProjectEntry( const uno::Reference< container::XNameContainer >& xPrjNameCache, const rtl::OUString& sTemplatePathOrURL, const rtl::OUString& sVBAProjName )
+{
+    if ( xPrjNameCache.is() )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sTemplatePathOrURL );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+            aURL = sTemplatePathOrURL;
+        else
+        {
+            osl::FileBase::getFileURLFromSystemPath( sTemplatePathOrURL, aURL );
+            aObj.SetURL( aURL );
+        }
+        try
+        {
+            rtl::OUString templateNameWithExt = aObj.GetLastName();
+            rtl::OUString templateName;
+            sal_Int32 nIndex =  templateNameWithExt.lastIndexOf( '.' );
+            //xPrjNameCache->insertByName( templateNameWithExt, uno::makeAny( sVBAProjName ) );    
+            if ( nIndex != -1 )
+            {
+                templateName = templateNameWithExt.copy( 0, nIndex );
+                xPrjNameCache->insertByName( templateName, uno::makeAny( sVBAProjName ) );    
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+}
+
+class WW8Customizations
+{
+    SvStream* mpTableStream;
+    WW8Fib mWw8Fib;
+public:
+    WW8Customizations( SvStream*, WW8Fib& );
+    bool  Import( SwDocShell* pShell );
+};
+
+WW8Customizations::WW8Customizations( SvStream* pTableStream, WW8Fib& rFib ) : mpTableStream(pTableStream), mWw8Fib( rFib )
+{
+}
+
+bool WW8Customizations::Import( SwDocShell* pShell ) 
+{
+    if ( mWw8Fib.lcbCmds == 0 )
+        return false;
+    Tcg aTCG;
+    long nCur = mpTableStream->Tell();
+    mpTableStream->Seek( mWw8Fib.fcCmds ); // point at tgc record
+    if (!aTCG.Read( mpTableStream ) )
+        OSL_TRACE("** Read of Customization data failed!!!! ");
+    mpTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+    aTCG.Print( stderr );
+#endif
+    return aTCG.ImportCustomToolBar( *pShell );
+}
+
+bool SwWW8ImplReader::ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const uno::Reference< container::XNameContainer >& xPrjNameCache )
+{
+    SvtPathOptions aPathOpt;
+    String aAddinPath = aPathOpt.GetAddinPath();
+    uno::Sequence< rtl::OUString > sGlobalTemplates;
+
+    // first get the autoload addins in the directory STARTUP
+    uno::Reference< ucb::XSimpleFileAccess > xSFA( ::comphelper::getProcessServiceFactory()->createInstance( rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), uno::UNO_QUERY_THROW );
+
+    if( xSFA->isFolder( aAddinPath ) )
+        sGlobalTemplates = xSFA->getFolderContents( aAddinPath, sal_False );
+
+    sal_Int32 nEntries = sGlobalTemplates.getLength();
+    bool bRes = true;
+    const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+    for ( sal_Int32 i=0; i<nEntries; ++i )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sGlobalTemplates[ i ] );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+                aURL = sGlobalTemplates[ i ];
+        else
+                osl::FileBase::getFileURLFromSystemPath( sGlobalTemplates[ i ], aURL );        
+        if ( !aURL.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) || ( sCreatedFrom.getLength() && sCreatedFrom.equals( aURL ) ) )
+            continue; // don't try and read the same document as ourselves
+
+        SotStorageRef rRoot = new SotStorage( aURL, STREAM_STD_READWRITE, STORAGE_TRANSACTED ); 
+
+        // Read Macro Projects
+        SvxImportMSVBasic aVBasic(*mpDocShell, *rRoot,
+            pVBAFlags->IsLoadWordBasicCode(),
+            pVBAFlags->IsLoadWordBasicStorage() );
+
+
+        String s1(CREATE_CONST_ASC("Macros"));
+        String s2(CREATE_CONST_ASC("VBA"));
+        int nRet = aVBasic.Import( s1, s2, ! pVBAFlags->IsLoadWordBasicCode() );
+        lcl_createTemplateToProjectEntry( xPrjNameCache, aURL, aVBasic.GetVBAProjectName() );
+        // Read toolbars & menus
+        SvStorageStreamRef refMainStream = rRoot->OpenSotStream( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("WordDocument") ) );
+        refMainStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+        WW8Fib aWwFib( *refMainStream, 8 );       
+        SvStorageStreamRef xTableStream = rRoot->OpenSotStream(String::CreateFromAscii( aWwFib.fWhichTblStm ? SL::a1Table : SL::a0Table), STREAM_STD_READ);
+
+        if (xTableStream.Is() && SVSTREAM_OK == xTableStream->GetError())
+        {
+            xTableStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+            WW8Customizations aGblCustomisations( xTableStream, aWwFib ); 
+            aGblCustomisations.Import( mpDocShell );
+        }
+    }
+    return bRes;
+}
+
 ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
 {
     ULONG nErrRet = 0;
@@ -4021,7 +4263,59 @@ ULONG SwWW8ImplReader::CoreLoad(WW8Gloss
     }
     else //ordinary case
     {
+        if (mbNewDoc && pStg && !pGloss) /*meaningless for a glossary, cmc*/
+        {
+            mpDocShell->SetIsTemplate( pWwFib->fDot ); // point at tgc record
+            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+            maTracer.EnterEnvironment(sw::log::eMacros);
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    
+            rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
+            uno::Reference< container::XNameContainer > xPrjNameCache;
+            uno::Reference< lang::XMultiServiceFactory> xSF(mpDocShell->GetModel(), uno::UNO_QUERY);
+            if ( xSF.is() )
+                xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
+
+            // Read Global templates 
+            ReadGlobalTemplateSettings( sCreatedFrom, xPrjNameCache );
+#endif 
+            // Create and insert Word vba Globals
+            uno::Any aGlobs;
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[ 0 ] <<= mpDocShell->GetModel();
+            aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( ::rtl::OUString::createFromAscii( "ooo.vba.word.Globals"), aArgs );
+            mpDocShell->GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+            
+            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
+                            pVBAFlags->IsLoadWordBasicCode(),
+                            pVBAFlags->IsLoadWordBasicStorage() );
+            String s1(CREATE_CONST_ASC("Macros"));
+            String s2(CREATE_CONST_ASC("VBA"));
+            int nRet = aVBasic.Import( s1, s2, ! pVBAFlags->IsLoadWordBasicCode() );
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            lcl_createTemplateToProjectEntry( xPrjNameCache, sCreatedFrom, aVBasic.GetVBAProjectName() );
+            WW8Customizations aCustomisations( pTableStream, *pWwFib ); 
+            aCustomisations.Import( mpDocShell );
+#endif 
+            if( 2 & nRet )
+            {
+                maTracer.Log(sw::log::eContainsVisualBasic);
+                rDoc.SetContainsMSVBasic(true);
+            }
+
+            StoreMacroCmds();
+
+            maTracer.LeaveEnvironment(sw::log::eMacros);
+        }
         ReadText(0, pWwFib->ccpText, MAN_MAINTEXT);
+
     }
 
     ::SetProgressState(nProgress, mpDocShell);    // Update
@@ -4095,26 +4389,6 @@ ULONG SwWW8ImplReader::CoreLoad(WW8Gloss
             eMode |= nsRedlineMode_t::REDLINE_ON;
         if( pWDop->fRMView )
             eMode |= nsRedlineMode_t::REDLINE_SHOW_DELETE;
-        if (pStg && !pGloss) /*meaningless for a glossary, cmc*/
-        {
-            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
-            maTracer.EnterEnvironment(sw::log::eMacros);
-            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
-                            pVBAFlags->IsLoadWordBasicCode(),
-                            pVBAFlags->IsLoadWordBasicStorage() );
-            String s1(CREATE_CONST_ASC("Macros"));
-            String s2(CREATE_CONST_ASC("VBA"));
-            int nRet = aVBasic.Import( s1, s2 );
-            if( 2 & nRet )
-            {
-                maTracer.Log(sw::log::eContainsVisualBasic);
-                rDoc.SetContainsMSVBasic(true);
-            }
-
-            StoreMacroCmds();
-
-            maTracer.LeaveEnvironment(sw::log::eMacros);
-        }
     }
 
     maInsertedTables.DelAndMakeTblFrms();
--- sw/source/filter/ww8/ww8par.hxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/source/filter/ww8/ww8par.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -1425,7 +1425,7 @@ private:
     // determine object attribute "Layout in Table Cell"
     bool IsObjectLayoutInTableCell( const UINT32 nLayoutInTableCell ) const;
     // <--
-
+    bool ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xPrjNameMap );
     //No copying
     SwWW8ImplReader(const SwWW8ImplReader &);
     SwWW8ImplReader& operator=(const SwWW8ImplReader&);
--- sw/source/filter/ww8/ww8toolbar.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,1288 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+// no. of visual data elements in a CTB ( fixed ) 
+const short nVisualData = 5;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOWordCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOWordCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOWordCommandConvertor::MSOWordCommandConvertor()
+{
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+Customization* CTBWrapper::GetCustomizaton( sal_Int16 index )
+{
+    if ( index < 0 || index >= rCustomizations.size() )
+        return NULL;
+    return &rCustomizations[ index ]; 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        if ( it->GetCustomizationData() && it->GetCustomizationData()->GetName().equals( sTBName ) )
+        {
+            pCTB = it->GetCustomizationData();
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::Read( SvStream* pS )
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        int nStart = pS->Tell();
+
+        int bytesRead = 0;
+        int bytesToRead = cbDTBC - bytesRead; 
+        // cbDTBC specifies the size ( in bytes ) taken by an array ( of unspecified size )
+        // of TBC records ( TBC records have dynamic length, so we need to check our position
+        // after each read )
+        do
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rtbdc.push_back( aTBC );
+            bytesToRead = cbDTBC - ( pS->Tell() - nStart ); 
+        } while ( bytesToRead > 0 );
+    }
+    if ( cCust )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            Customization aCust( this );
+            if ( !aCust.Read( pS ) )
+                return false;
+            rCustomizations.push_back( aCust );
+        } 
+    } 
+    std::vector< sal_Int16 >::iterator it_end = dropDownMenuIndices.end();
+    for ( std::vector< sal_Int16 >::iterator it = dropDownMenuIndices.begin(); it != it_end; ++it )
+    {
+        rCustomizations[ *it ].bIsDroppedMenuTB = true;
+    }
+    return true;
+}
+
+TBC* CTBWrapper::GetTBCAtOffset( sal_uInt32 nStreamOffset )
+{
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it )
+    {
+        if ( (*it).GetOffset() == nStreamOffset )
+            return &(*it);
+    }
+    return NULL;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] CTBWrapper - dump\n", nOffSet );
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        indent_printf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        indent_printf(fp,"    reserved1(0x%x)\n",ch);
+        indent_printf(fp,"    reserved2(0x%x)\n",reserved2);
+        indent_printf(fp,"    reserved3(0x%x)\n",reserved3);
+        indent_printf(fp,"    reserved4(0x%x)\n",reserved4);
+        indent_printf(fp,"    reserved5(0x%x)\n",reserved5);
+        indent_printf(fp,"Quiting dump");
+        return;
+    }
+    indent_printf(fp,"  size of TBDelta structures 0x%x\n", cbTBD );
+    indent_printf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    indent_printf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+
+    sal_Int32 index = 0;
+
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping rtbdc[%d]\n", static_cast< int >( index ));
+        Indent b;
+        it->Print( fp );
+    }
+
+    index = 0;
+
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+        Indent c;
+        it->Print(fp);
+    }
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) );
+        helper.setMSOCommandMap( new MSOWordCommandConvertor() );
+
+        if ( !(*it).ImportCustomToolBar( *this, helper ) )
+            return false;
+    }
+    return false;
+}
+
+Customization::Customization( CTBWrapper* wrapper ) : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, pWrapper( wrapper )
+, bIsDroppedMenuTB( false )
+{
+}
+
+Customization::~Customization()
+{
+}
+
+bool Customization::Read( SvStream *pS)
+{
+    OSL_TRACE("Custimization::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD )
+    {
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+        {
+            TBDelta aTBDelta;
+            if (!aTBDelta.Read( pS ) )
+                return false;
+            customizationDataTBDelta.push_back( aTBDelta );
+            // Only set the drop down for menu's associated with standard toolbar
+            if ( aTBDelta.ControlDropsToolBar() && tbidForTBD == 0x25 )
+                pWrapper->InsertDropIndex( aTBDelta.CustomizationIndex() );
+        }
+    }
+    else
+    {
+        customizationDataCTB.reset( new CTB() );
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] Customization -- dump \n", nOffSet );
+    indent_printf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    indent_printf( fp,"  reserved1 0x%x \n", reserved1);
+    indent_printf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+    {
+        const char* pToolBar = NULL;
+        switch ( tbidForTBD )
+        {
+            case 0x9:
+                pToolBar = "Standard";
+                break;
+            case 0x25:
+                pToolBar = "Builtin-Menu";
+                break;
+            default:
+                pToolBar = "Unknown toolbar";
+                break;
+        }
+        
+        indent_printf( fp,"  TBDelta(s) are associated with %s toolbar.\n", pToolBar);
+        std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin();
+        for ( sal_Int32 index = 0; index < ctbds; ++it,++index )
+            it->Print( fp );
+    }
+    
+}
+
+bool Customization::ImportMenu( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( tbidForTBD == 0x25 )  // we can handle in a limited way additions the built-in menu bar
+    {
+        for ( std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin(); it != customizationDataTBDelta.end(); ++it )
+        {
+            // for each new menu ( control that drops a toolbar )
+            // import a toolbar
+            if ( it->ControlIsInserted() && it->ControlDropsToolBar() )
+            {
+                Customization* pCust = pWrapper->GetCustomizaton( it->CustomizationIndex() );
+                if ( pCust )
+                {
+                    // currently only support built-in menu
+                    rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+
+                    sMenuBar = sMenuBar.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("menubar") ) );
+                    // Get menu name
+                    TBC* pTBC = pWrapper->GetTBCAtOffset( it->TBCStreamOffset() );
+                    if ( !pTBC )
+                        return false;
+                    rtl::OUString sMenuName = pTBC->GetCustomText();
+                    sMenuName = sMenuName.replace('&','~');
+
+                    // see if the document has already setting for the menubar
+                
+                    uno::Reference< container::XIndexContainer > xIndexContainer;
+                    bool bHasSettings = false;
+                    if ( helper.getCfgManager()->hasSettings( sMenuBar ) )
+                    {
+                        xIndexContainer.set( helper.getCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        bHasSettings = true;
+                    }
+                    else
+                    {
+                        if ( helper.getAppCfgManager()->hasSettings( sMenuBar ) )
+                            xIndexContainer.set( helper.getAppCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        else 
+                            xIndexContainer.set( helper.getAppCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+                    }
+               
+                    uno::Reference< lang::XSingleComponentFactory > xSCF( xIndexContainer, uno::UNO_QUERY_THROW );
+                    uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                    uno::Reference< uno::XComponentContext > xContext(  xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+                    // create the popup menu
+                    uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+                    aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                    aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + sMenuName );
+                    aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+                    aPopupMenu[1].Value <<= sMenuName;
+                    aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+                    aPopupMenu[2].Value <<= sal_Int32( 0 );
+                    aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    uno::Reference< container::XIndexContainer > xMenuContainer( xSCF->createInstanceWithContext( xContext ), uno::UNO_QUERY_THROW );
+                    aPopupMenu[3].Value <<= xMenuContainer;
+                    if ( pCust->customizationDataCTB.get() && !pCust->customizationDataCTB->ImportMenuTB( rWrapper, xMenuContainer, helper ) )
+                        return false;
+                    OSL_TRACE("** there are %d menu items on the bar, inserting after that", xIndexContainer->getCount() );
+                    xIndexContainer->insertByIndex( xIndexContainer->getCount(), uno::makeAny( aPopupMenu ) );
+
+                    if ( bHasSettings )
+                        helper.getCfgManager()->replaceSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+                    else
+                        helper.getCfgManager()->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+                }
+            }
+        }
+        return true;
+    }
+    return true;
+}
+
+bool Customization::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( GetTBIDForTB() == 0x25 )
+        return ImportMenu( rWrapper, helper );
+    if ( !customizationDataCTB.get() )
+        return false;
+    if ( !customizationDataCTB->IsMenuToolbar() )
+    {
+        if ( !customizationDataCTB->ImportCustomToolBar( rWrapper, helper ) )
+            return false;
+    }
+    return true;
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::ControlIsModified()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x2 );
+}
+
+bool TBDelta::ControlIsInserted()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlIsChanged()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlDropsToolBar()
+{
+    return !( CiTBDE & 0x8000 );
+}
+
+sal_Int32 TBDelta::TBCStreamOffset()
+{
+    return fc;
+}
+
+sal_Int16 TBDelta::CustomizationIndex()
+{
+    sal_Int16 nIndex = CiTBDE;
+    nIndex = nIndex >> 1;
+    nIndex &= 0x1ff; // only 13 bits are relevant
+    return nIndex;
+}
+
+bool TBDelta::Read(SvStream *pS)
+{
+    OSL_TRACE("TBDelta::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    *pS >> CiTBDE >> cbTBC;
+    return true;
+}
+
+void TBDelta::Print( FILE* fp )
+{
+    // Like most of the debug output, it's raw and little ( no )
+    // interpretation of the data is output ( e.g. flag values etc. )
+    indent_printf( fp, "[ 0x%x ] TBDelta -- dump\n", nOffSet );
+    indent_printf( fp, " doprfatendFlags 0x%x\n",doprfatendFlags );
+    
+    indent_printf( fp, " ibts 0x%x\n",ibts );
+    indent_printf( fp, " cidNext 0x%x\n", static_cast< unsigned int >( cidNext ) );
+    indent_printf( fp, " cid 0x%x\n", static_cast< unsigned int >( cid ) );
+    indent_printf( fp, " fc 0x%x\n", static_cast< unsigned int >( fc ) );
+    indent_printf( fp, " CiTBDE 0x%x\n",CiTBDE );
+    indent_printf( fp, " cbTBC 0x%x\n", cbTBC );
+    if ( ControlDropsToolBar() )
+    {
+        indent_printf( fp, " this delta is associated with a control that drops a menu toolbar\n", cbTBC );
+        indent_printf( fp, " the menu toolbar drops the toolbar defined at index[%d] in the rCustomizations array of the CTBWRAPPER that contains this TBDelta\n", CustomizationIndex() );
+    }
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+{
+}
+
+CTB::~CTB()
+{
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+
+bool CTB::Read( SvStream *pS)
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    if ( !tb.Read( pS ) )
+        return false;
+    for ( short index = 0; index < nVisualData; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rTBC.push_back( aTBC );
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] CTB - dump\n", nOffSet );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    for ( short counter = 0; counter < nVisualData; ++counter )
+    {
+        indent_printf( fp, "  TBVisualData [%d]\n", counter);
+        Indent b;
+        rVisualData[ counter ].Print( fp );
+    } 
+    indent_printf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            indent_printf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            // createToolBar item for control
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+    
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1 // don't think this is necessary
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif
+        bRes = true;
+    }
+    catch( uno::Exception& e )
+    {
+        OSL_TRACE("***** For some reason we have an exception %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+        bRes = false;
+    }
+    return bRes;
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xIndexContainer, CustomToolBarImportHelper& rHelper )
+{
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+    {
+        // createToolBar item for control
+        if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, rHelper, true ) )
+            return false;
+    }
+    return true;
+}
+
+TBC::TBC()
+{
+}
+
+TBC::~TBC()
+{
+}
+
+bool TBC::Read( SvStream *pS )
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.getTcID() != 0x1 && tbch.getTcID() != 0x1051 )
+    {
+        cid.reset( new sal_uInt32 );
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.getTct() != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBC -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid.get() )
+        indent_printf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        indent_printf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+bool
+TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar )
+{
+    // cmtFci       0x1 Command based on a built-in command. See CidFci.
+    // cmtMacro     0x2 Macro command. See CidMacro.
+    // cmtAllocated 0x3 Allocated command. See CidAllocated.
+    // cmtNil       0x7 No command. See Cid.
+    bool bBuiltin = false;
+    sal_uInt16 cmdId = 0;
+    if  ( cid.get() )
+    {
+        sal_uInt16 arg2 = ( *( cid.get() ) & 0xFFFF );
+
+        sal_uInt8 cmt = ( arg2 & 0x7 );
+        arg2 = ( arg2 >> 3 );
+
+        switch ( cmt )
+        {
+            case 1:
+                OSL_TRACE("cmt is cmtFci builtin command 0x%x", arg2);
+                bBuiltin = true;
+                cmdId = arg2;
+                break;
+            case 2:
+                OSL_TRACE("cmt is cmtMacro macro 0x%x", arg2);
+                break;
+            case 3:
+                OSL_TRACE("cmt is cmtAllocated [???] 0x%x", arg2);
+                break;
+            case 7:
+                OSL_TRACE("cmt is cmNill no-phing 0x%x", arg2);
+                break;
+            default:
+                OSL_TRACE("illegal 0x%x", cmt);
+                break;
+        }
+    }
+
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+        }
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuBar ) )
+            return false;
+
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            OSL_TRACE("** control has a menu, name of toolbar with menu items is %s", rtl::OUStringToOString( pMenu->Name(), RTL_TEXTENCODING_UTF8 ).getStr() );
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                if ( !pCustTB->ImportMenuTB( rWrapper,xMenuDesc, helper ) )
+                    return false;     
+                if ( !bIsMenuBar )
+                {
+                    if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                        return false;
+                }
+                else
+                {
+                    beans::PropertyValue aProp;
+                    aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    aProp.Value <<= xMenuDesc;
+                    props.push_back( aProp );
+                }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );       
+        }
+ 
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+rtl::OUString 
+TBC::GetCustomText()
+{
+    rtl::OUString sCustomText;
+    if ( tbcd.get() )
+        sCustomText = tbcd->getGeneralInfo().CustomText();
+    return sCustomText;
+   
+    
+}
+
+bool 
+Xst::Read( SvStream* pS )
+{
+    OSL_TRACE("Xst::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] Xst -- dump\n", nOffSet );
+    indent_printf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    Indent a(true);
+    indent_printf(fp, "[ 0x%x ] Tcg - dump %d\n", nOffSet, nTcgVer);
+    indent_printf(fp,"  nTcgVer %d\n", nTcgVer);
+    tcg->Print( fp );
+}
+
+bool Tcg::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    return tcg->ImportCustomToolBar( rDocSh );
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SvStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    // Find the CTBWrapper
+    for ( std::vector< Tcg255SubStruct* >::const_iterator it = rgtcgData.begin(); it != rgtcgData.end(); ++it )
+    {
+        if ( (*it)->id() == 0x12 )
+        {
+            // not so great, shouldn't really have to do a horror casting    
+            CTBWrapper* pCTBWrapper =  dynamic_cast< CTBWrapper* > ( *it );
+            if ( pCTBWrapper )
+            {
+                if ( !pCTBWrapper->ImportCustomToolBar( rDocSh ) )
+                    return false;
+            }
+        }
+    }
+    return true;
+}
+
+
+bool Tcg255::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] Tcg255 - dump\n", nOffSet );
+    indent_printf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        Indent b;
+        indent_printf(fp, "  [%d] Tcg255SubStruct \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255SubStruct::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SvStream *pS)
+{
+    OSL_TRACE("PffMcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfMcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SvStream *pS)
+{
+    OSL_TRACE("PffAcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfAcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SvStream *pS)
+{
+    OSL_TRACE("PlfKme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfKme ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SvStream *pS) 
+{
+    OSL_TRACE("TcgSttbf::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TcgSttbf - dump\n", nOffSet );
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SvStream* pS )
+{
+    OSL_TRACE("TcgSttbfCore::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TcgSttbfCore - dump\n");
+    indent_printf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    indent_printf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    indent_printf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            indent_printf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SvStream *pS)
+{
+    OSL_TRACE("MacroNames::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] MacroNames ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SvStream *pS)
+{
+    OSL_TRACE("MacroName::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MacroName - dump");
+    indent_printf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SvStream *pS)
+{
+    OSL_TRACE("Xstz::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] Xstz -- dump\n", nOffSet );
+    indent_printf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    indent_printf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SvStream *pS)
+{
+    OSL_TRACE("Kme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> kt >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    Indent a;
+    
+   indent_printf( fp, "[ 0x%x ] Kme - dump\n", nOffSet );
+   indent_printf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   indent_printf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   indent_printf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   indent_printf( fp, " kt 0x%x \n", kt );
+   indent_printf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SvStream *pS)
+{
+    OSL_TRACE("Acd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] ACD - dump\n", nOffSet );
+    // #TODO flesh out interpretation of these values
+    indent_printf( fp,"  ibst 0x%x\n", ibst);
+    indent_printf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SvStream *pS)
+{
+    OSL_TRACE("MCD::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MCD - dump\n", nOffSet );
+    indent_printf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+    indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+    indent_printf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+    indent_printf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+    indent_printf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+    indent_printf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+    indent_printf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+    indent_printf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+    indent_printf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
--- sw/source/filter/ww8/ww8toolbar.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/filter/ww8/ww8toolbar.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,347 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <svx/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SvStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class CTBWrapper;
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr< sal_uInt32 > cid; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper&, bool );
+    rtl::OUString GetCustomText();
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    std::vector< TBC > rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+};
+
+class TBDelta : public TBBase
+{
+    sal_uInt8 doprfatendFlags;
+
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt16 CiTBDE; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ControlIsModified();
+    bool ControlIsInserted();
+    bool ControlIsChanged();
+    bool ControlDropsToolBar();
+    sal_Int32 TBCStreamOffset();
+    sal_Int16 CustomizationIndex();
+    
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() const { return ch; }
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper;
+class Customization : public TBBase
+{
+friend class CTBWrapper;
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+    CTBWrapper* pWrapper;
+    boost::shared_ptr< CTB > customizationDataCTB;
+    std::vector< TBDelta > customizationDataTBDelta; 
+    bool bIsDroppedMenuTB; 
+    bool ImportMenu( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+public:    
+    Customization( CTBWrapper* rapper );
+    ~Customization();
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenu( CTBWrapper&, CustomToolBarImportHelper& );
+    void Print( FILE* );
+    sal_Int32 GetTBIDForTB(){ return tbidForTBD; }
+    CTB*  GetCustomizationData() { return customizationDataCTB.get(); };
+};
+
+class SfxObjectShell; 
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    std::vector< TBC > rtbdc; // 
+    std::vector< Customization > rCustomizations; // array of Customizations
+    std::vector< sal_Int16 > dropDownMenuIndices; // array of indexes of Customization toolbars that are dropped by a menu
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    void InsertDropIndex( sal_Int32 aIndex ) { dropDownMenuIndices.push_back( aIndex ); }
+    TBC* GetTBCAtOffset( sal_uInt32 nStreamOffset );
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+
+    Customization* GetCustomizaton( sal_Int16 index );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macros name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SvStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SvStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    void Print( FILE* );
+};
+
+#endif
--- sw/source/ui/app/docsh.cxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/source/ui/app/docsh.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -495,16 +495,6 @@ sal_Bool SwDocShell::SaveAs( SfxMedium&
             xDocSh->DoClose();
         }
 
-        if( pDoc->ContainsMSVBasic() )
-        {
-            //TODO/MBA: it looks as that this code can be removed!
-            //SvxImportMSVBasic aTmp( *this, pIo->GetStorage() );
-            //aTmp.SaveOrDelMSVBAStorage( FALSE, aEmptyStr );
-            if( SvtFilterOptions::Get()->IsLoadWordBasicStorage() )
-                nVBWarning = SvxImportMSVBasic::
-                                GetSaveWarningOfMSVBAStorage( *this );
-            pDoc->SetContainsMSVBasic( FALSE );
-        }
 
         // TabellenBox Edit beenden!
         if( pWrtShell )
--- sw/source/ui/app/docsh2.cxx.old	2009-10-08 16:17:18.000000000 +0200
+++ sw/source/ui/app/docsh2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -151,6 +151,8 @@
 #include <com/sun/star/ui/dialogs/ListboxControlActions.hpp>
 #include <com/sun/star/ui/dialogs/CommonFilePickerElementIds.hpp>
 #include "com/sun/star/ui/dialogs/TemplateDescription.hpp"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 
 #include <svx/acorrcfg.hxx>
 #include <SwStyleNameMapper.hxx>
@@ -169,6 +171,7 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 using namespace ::sfx2;
+using namespace com::sun::star::document::VbaEventId;
 
 extern BOOL FindPhyStyle( SwDoc& , const String& , SfxStyleFamily );
 
@@ -222,6 +225,31 @@ void SwDocShell::DoFlushDocInfo()
     }
 }
 
+void lcl_processCompatibleSfxHint( const uno::Reference< document::XVbaEventsHelper >& xVbaEventsHelper, const SfxHint& rHint )
+{
+    if ( rHint.ISA( SfxEventHint ) )
+    {
+        uno::Sequence< uno::Any > aArgs;
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch( nEventId )
+        {
+            case SFX_EVENT_CREATEDOC:
+            {
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_DOCUMENT_NEW, aArgs );
+                break;
+            }
+            case SFX_EVENT_OPENDOC:
+            {
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_DOCUMENT_OPEN, aArgs );
+                break;
+            }
+            default:
+            {
+                //do nothing
+            }
+        }
+    }
+}
 
 /*--------------------------------------------------------------------
     Beschreibung: 	Benachrichtigung bei geaenderter DocInfo
@@ -235,6 +263,9 @@ void SwDocShell::Notify( SfxBroadcaster&
 //		ASSERT( !this, "DocShell ist nicht richtig initialisiert!" );
         return ;
     }
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper = pDoc->GetVbaEventsHelper();
+    if( xVbaEventsHelper.is() )
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
 
     USHORT nAction = 0;
     if( rHint.ISA(SfxSimpleHint) )
@@ -317,6 +348,16 @@ USHORT SwDocShell::PrepareClose( BOOL bU
     if( TRUE == nRet ) //Unbedingt auf TRUE abfragen! (RET_NEWTASK)
         EndListening( *this );
 
+    if( pDoc && IsInPrepareClose() )
+    {
+        uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper = pDoc->GetVbaEventsHelper();
+        if( xVbaEventsHelper.is() )
+        {
+            uno::Sequence< uno::Any > aArgs;
+            xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_DOCUMENT_CLOSE, aArgs );
+        }    
+    }    
+     
     return nRet;
 }
 
--- sw/source/ui/uno/unotxdoc.cxx.old	2009-10-08 16:17:19.000000000 +0200
+++ sw/source/ui/uno/unotxdoc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -166,6 +166,7 @@ using ::osl::FileBase;
 #define SW_CREATE_MARKER_TABLE          0x06
 #define SW_CREATE_DRAW_DEFAULTS         0x07
 
+#include <comphelper/processfactory.hxx> 
 
 /******************************************************************************
  *
@@ -220,6 +221,12 @@ sal_Int64 SAL_CALL SwXTextDocument::getS
     {
             return sal::static_int_cast< sal_Int64 >( reinterpret_cast< sal_IntPtr >( this ));
     }
+    if( rId.getLength() == 16
+        && 0 == rtl_compareMemory( SfxObjectShell::getUnoTunnelId().getConstArray(),
+										rId.getConstArray(), 16 ) )
+    {
+        return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(pDocShell ));
+    }
 
     sal_Int64 nRet = SfxBaseModel::getSomething( rId );
     if ( nRet )
@@ -366,6 +373,9 @@ SwXTextDocument::SwXTextDocument(SwDocSh
     pxXRedlines(0),
     m_pHiddenViewFrame(0)
 {
+    uno::Reference< document::XDocumentProperties > xWriterProps( ::comphelper::getProcessServiceFactory()->createInstance( DEFINE_CONST_UNICODE("com.sun.star.writer.DocumentProperties") ), uno::UNO_QUERY_THROW);
+
+    SfxBaseModel::setDocumentProperties( xWriterProps );
 }
 /*-- 18.12.98 11:53:00---------------------------------------------------
 
@@ -2145,6 +2155,9 @@ Any SwXTextDocument::getPropertyValue(co
     Any aAny;
     switch(pEntry->nWID)
     {
+		case WID_DOC_ISTEMPLATEID    :
+			aAny <<= pDocShell->IsTemplate();
+			break;
         case  WID_DOC_CHAR_COUNT     :
         case  WID_DOC_PARA_COUNT     :
         case  WID_DOC_WORD_COUNT     :
@@ -2253,6 +2266,14 @@ Any SwXTextDocument::getPropertyValue(co
         case WID_DOC_DIALOG_LIBRARIES:
             aAny <<= pDocShell->GetDialogContainer();
         break;
+        case WID_DOC_VBA_DOCOBJ:
+        {
+            beans::PropertyValue aProp;
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWordDoc") );
+            aProp.Value <<= pDocShell->GetModel();
+            aAny <<= aProp;
+        }
+        break;
         case WID_DOC_RUNTIME_UID:
             aAny <<= getRuntimeUID();
         break;
@@ -2902,6 +2923,7 @@ uno::Sequence< lang::Locale > SAL_CALL S
 {
     ::vos::OGuard aGuard(Application::GetSolarMutex());
 
+
     // possible canonical values for nScriptTypes
     // any bit wise combination is allowed
     const sal_Int16 nLatin   = 0x001;
--- sw/source/ui/vba/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -86,6 +86,7 @@ SLOFILES= \
 				$(SLO)$/vbaborders.obj \
 				$(SLO)$/vbadocuments.obj \
 				$(SLO)$/vbaheaderfooter.obj \
+				$(SLO)$/vbaheadersfooters.obj \
 				$(SLO)$/vbaheaderfooterhelper.obj \
 				$(SLO)$/vbaaddin.obj \
 				$(SLO)$/vbaaddins.obj \
@@ -95,6 +96,30 @@ SLOFILES= \
 				$(SLO)$/vbapagesetup.obj \
 				$(SLO)$/vbasection.obj \
 				$(SLO)$/vbasections.obj \
+				$(SLO)$/vbarow.obj \
+				$(SLO)$/vbarows.obj \
+				$(SLO)$/vbacolumn.obj \
+				$(SLO)$/vbacolumns.obj \
+				$(SLO)$/vbatablehelper.obj \
+				$(SLO)$/vbacell.obj \
+				$(SLO)$/vbacells.obj \
+				$(SLO)$/vbatabstop.obj \
+				$(SLO)$/vbatabstops.obj \
+				$(SLO)$/vbatableofcontents.obj \
+				$(SLO)$/vbatablesofcontents.obj \
+				$(SLO)$/vbalistgallery.obj \
+				$(SLO)$/vbalistgalleries.obj \
+				$(SLO)$/vbalisthelper.obj \
+				$(SLO)$/vbalisttemplate.obj \
+				$(SLO)$/vbalisttemplates.obj \
+				$(SLO)$/vbalistlevel.obj \
+				$(SLO)$/vbalistlevels.obj \
+				$(SLO)$/vbalistformat.obj \
+				$(SLO)$/vbarevision.obj \
+				$(SLO)$/vbarevisions.obj \
+				$(SLO)$/vbaframe.obj \
+				$(SLO)$/vbaframes.obj \
+				$(SLO)$/vbaeventshelper.obj \
 
 # --- Targets ------------------------------------------------------
 
--- sw/source/ui/vba/service.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/service.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -55,6 +55,11 @@ namespace wrapformat
 extern sdecl::ServiceDecl const serviceDecl;
 }
 
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
 extern "C"
 {
     void SAL_CALL component_getImplementationEnvironment( 
@@ -71,7 +76,7 @@ extern "C"
 
 	// Component registration
         return component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl  ); 
+		globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl, vbaeventshelper::serviceDecl ); 
     }
 
     void * SAL_CALL component_getFactory( 
@@ -80,7 +85,7 @@ extern "C"
     {
 		OSL_TRACE("In component_getFactory for %s", pImplName );
 	void* pRet =  component_getFactoryHelper(
-        	pImplName, pServiceManager, pRegistryKey, globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl );
+        	pImplName, pServiceManager, pRegistryKey, globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl, vbaeventshelper::serviceDecl );
 	OSL_TRACE("Ret is 0x%x", pRet);
 	return pRet;
     }
--- sw/source/ui/vba/vbaapplication.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaapplication.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -43,6 +43,7 @@
 #include <svx/acorrcfg.hxx>
 #include "wordvbahelper.hxx"
 #include <docsh.hxx>
+#include "vbalistgalleries.hxx"
 
 using namespace ::ooo;
 using namespace ::ooo::vba;
@@ -154,6 +155,16 @@ SwVbaApplication::Dialogs( const uno::An
     return uno::makeAny( xCol );
 }
 
+uno::Any SAL_CALL
+SwVbaApplication::ListGalleries( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextDocument > xTextDoc( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaListGalleries( this, mxContext, xTextDoc ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
 sal_Bool SAL_CALL SwVbaApplication::getDisplayAutoCompleteTips() throw (css::uno::RuntimeException)
 {
     return SvxAutoCorrCfg::Get()->IsAutoTextTip();
--- sw/source/ui/vba/vbaapplication.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaapplication.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -63,6 +63,7 @@ public:
     virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL ListGalleries( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual sal_Bool SAL_CALL getDisplayAutoCompleteTips() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setDisplayAutoCompleteTips( sal_Bool _displayAutoCompleteTips ) throw (css::uno::RuntimeException);
     virtual sal_Int32 SAL_CALL getEnableCancelKey() throw (css::uno::RuntimeException);
--- sw/source/ui/vba/vbaautotextentry.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaautotextentry.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -29,7 +29,9 @@
  ************************************************************************/
 #include "vbaautotextentry.hxx"
 #include <vbahelper/vbahelper.hxx>
+#include <com/sun/star/text/XParagraphCursor.hpp>
 #include <tools/diagnose_ex.h>
+#include "wordvbahelper.hxx"
 #include "vbarange.hxx"
 
 using namespace ::ooo::vba;
@@ -44,7 +46,7 @@ SwVbaAutoTextEntry::~SwVbaAutoTextEntry(
 {
 }
 
-uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::Reference< word::XRange >& _where, const uno::Any& /*_richtext*/ ) throw ( uno::RuntimeException )
+uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::Reference< word::XRange >& _where, const uno::Any& _richtext ) throw ( uno::RuntimeException )
 {
     SwVbaRange* pWhere = dynamic_cast<SwVbaRange*>( _where.get() );
     if( pWhere )
@@ -58,8 +60,28 @@ uno::Reference< word::XRange > SAL_CALL
         uno::Reference< text::XTextCursor > xTC = xText->createTextCursorByRange( xTextRange->getStart() );
         xTC->goRight( 1, sal_True );
         xTC->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
+        // remove the blank paragraph if it is a rich text
+        sal_Bool bRich = sal_False;
+        _richtext >>= bRich;
+        if( bRich )
+        {
+            // check if it is a blank paragraph
+            uno::Reference< text::XParagraphCursor > xParaCursor( xTC, uno::UNO_QUERY_THROW );
+            if( xParaCursor->isStartOfParagraph() && xParaCursor->isEndOfParagraph() )
+            {
+                //remove the blank paragraph
+                uno::Reference< frame::XModel > xModel( getCurrentWordDoc( mxContext ), uno::UNO_QUERY_THROW );
+                uno::Reference< text::XTextViewCursor > xTVCursor = word::getXTextViewCursor( xModel );
+                uno::Reference< text::XTextRange > xCurrentRange( xTC->getEnd(), uno::UNO_QUERY_THROW );
+                xTVCursor->gotoRange( xCurrentRange, sal_False );
+                rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Delete"));
+                dispatchRequests( xModel,url );
+                xTVCursor->gotoRange( xEndMarker->getEnd(), sal_False );
+            }
+        }
         xEndMarker->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
-        xTC->gotoRange( xEndMarker, sal_True );
+        //xTC->gotoRange( xEndMarker, sal_True );
+        xTC = xText->createTextCursorByRange( xEndMarker->getEnd() );
         pWhere->setXTextCursor( xTC );
     }
     return uno::Reference< word::XRange >( pWhere );
@@ -98,8 +120,9 @@ SwVbaAutoTextEntries::getElementType() t
 uno::Reference< container::XEnumeration >
 SwVbaAutoTextEntries::createEnumeration() throw (uno::RuntimeException)
 {
-    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
-    return xEnumerationAccess->createEnumeration();
+    //uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    //return xEnumerationAccess->createEnumeration();
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 }
 
 uno::Any
--- sw/source/ui/vba/vbabookmark.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbabookmark.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,9 +32,12 @@
 #include <tools/diagnose_ex.h>
 #include <com/sun/star/text/XTextDocument.hpp>
 #include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
 #include "vbarange.hxx"
+#include "wordvbahelper.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -68,8 +71,8 @@ void SAL_CALL SwVbaBookmark::Delete() th
 void SAL_CALL SwVbaBookmark::Select() throw ( uno::RuntimeException )
 {
     checkVality();
-    uno::Reference< text::XTextViewCursorSupplier > xViewCursorSupplier( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    xViewCursorSupplier->getViewCursor()->gotoRange( mxBookmark->getAnchor(),sal_False );
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( mxBookmark ) );
 }
 
 rtl::OUString SAL_CALL SwVbaBookmark::getName() throw ( uno::RuntimeException )
--- sw/source/ui/vba/vbabookmarks.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbabookmarks.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -123,7 +123,7 @@ SwVbaBookmarks::SwVbaBookmarks( const un
     uno::Reference< text::XTextDocument > xDocument( mxModel, uno::UNO_QUERY_THROW );
     // use view cursor to insert bookmark, or it will fail if insert bookmark in table
     // mxText = xDocument->getText();
-    mxText = word::getXTextViewCursor( mxModel )->getText();
+    //mxText = word::getXTextViewCursor( mxModel )->getText();
 }
 // XEnumerationAccess
 uno::Type
@@ -149,16 +149,16 @@ SwVbaBookmarks::createCollectionObject(
 void SwVbaBookmarks::removeBookmarkByName( const rtl::OUString& rName ) throw (uno::RuntimeException)
 {
     uno::Reference< text::XTextContent > xBookmark( m_xNameAccess->getByName( rName ), uno::UNO_QUERY_THROW );
-    mxText->removeTextContent( xBookmark );
+    word::getXTextViewCursor( mxModel )->getText()->removeTextContent( xBookmark );
 }
 
-void SwVbaBookmarks::addBookmarkByName( const rtl::OUString& rName, const uno::Reference< text::XTextRange >& rTextRange ) throw (uno::RuntimeException)
+void SwVbaBookmarks::addBookmarkByName( const uno::Reference< frame::XModel >& xModel, const rtl::OUString& rName, const uno::Reference< text::XTextRange >& rTextRange ) throw (uno::RuntimeException)
 {
-    uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< lang::XMultiServiceFactory > xDocMSF( xModel, uno::UNO_QUERY_THROW );
     uno::Reference< text::XTextContent > xBookmark( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Bookmark")) ), uno::UNO_QUERY_THROW );
     uno::Reference< container::XNamed > xNamed( xBookmark, uno::UNO_QUERY_THROW );
     xNamed->setName( rName );
-    mxText->insertTextContent( rTextRange, xBookmark, sal_False );
+    rTextRange->getText()->insertTextContent( rTextRange, xBookmark, sal_False );
 }
 
 uno::Any SAL_CALL
@@ -184,7 +184,7 @@ SwVbaBookmarks::Add( const rtl::OUString
     if( m_xNameAccess->hasByName( aName ) )
         removeBookmarkByName( aName );
     
-    addBookmarkByName( aName, xTextRange );
+    addBookmarkByName( mxModel, aName, xTextRange );
 
     return uno::makeAny( uno::Reference< word::XBookmark >( new SwVbaBookmark( getParent(), mxContext, mxModel, aName ) ) );
 }
--- sw/source/ui/vba/vbabookmarks.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbabookmarks.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -50,12 +50,12 @@ private:
 
 private:
     void removeBookmarkByName( const rtl::OUString& rName ) throw (css::uno::RuntimeException);
-    void addBookmarkByName( const rtl::OUString& rName, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw (css::uno::RuntimeException);
 
 public:
 	SwVbaBookmarks( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xBookmarks, const css::uno::Reference< css::frame::XModel >& xModel );
 	virtual ~SwVbaBookmarks() {}
 
+    static void addBookmarkByName( const css::uno::Reference< css::frame::XModel >& xModel, const rtl::OUString& rName, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw (css::uno::RuntimeException);
 	// XEnumerationAccess
 	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
--- sw/source/ui/vba/vbaborders.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaborders.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -351,14 +351,19 @@ SwVbaBorders::getItemByIntIndex( const s
 
 sal_Bool SAL_CALL SwVbaBorders::getShadow() throw (uno::RuntimeException)
 {
+    /*
     table::ShadowFormat aShadowFormat;
     m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShadowFormat") ) ) >>= aShadowFormat;
     return ( aShadowFormat.Location != table::ShadowLocation_NONE );
+    */
+    // always return False for table border in MS Word
+    return sal_False;
 }
 
 void SAL_CALL SwVbaBorders::setShadow( sal_Bool /*_shadow*/ ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    // not support in Table border in Word
+    // TODO: 
 }
 
 rtl::OUString& 
--- sw/source/ui/vba/vbacell.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacell.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacell.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbatable.hxx"
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+#include "vbarow.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaCell::SwVbaCell( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nColumn, sal_Int32 nRow ) throw ( uno::RuntimeException ) :
+    SwVbaCell_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnColumn( nColumn ), mnRow( nRow )
+{
+}
+
+SwVbaCell::~SwVbaCell()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaCell::getWidth() throw (css::uno::RuntimeException)
+{
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    return aTableHelper.GetColWidth( mnColumn, mnRow, sal_True );
+}
+
+void SAL_CALL SwVbaCell::setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException)
+{
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    aTableHelper.SetColWidth( _width, mnColumn, mnRow, sal_True );
+}
+
+uno::Any SAL_CALL SwVbaCell::getHeight() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    return xRow->getHeight();
+}
+
+void SAL_CALL SwVbaCell::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    xRow->setHeight( _height );
+}
+
+::sal_Int32 SAL_CALL SwVbaCell::getHeightRule() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    return xRow->getHeightRule();
+}
+
+void SAL_CALL SwVbaCell::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnRow ) );
+    xRow->setHeightRule( _heightrule );
+}
+
+void SAL_CALL SwVbaCell::SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException)
+{
+    // FIXME: handle the argument: rulestyle
+    setWidth( width );
+}
+
+void SAL_CALL SwVbaCell::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    // FIXME: handle the argument: heightrule 
+    setHeightRule( heightrule );
+    setHeight( uno::makeAny( height ) );
+}
+
+rtl::OUString& 
+SwVbaCell::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCell") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaCell::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Cell" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbacell.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacell.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CELL_HXX
+#define SW_VBA_CELL_HXX
+
+#include <ooo/vba/word/XCell.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XCell > SwVbaCell_BASE;
+
+class SwVbaCell : public SwVbaCell_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnColumn;
+    sal_Int32 mnRow;
+
+public:
+	SwVbaCell( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nColumn, sal_Int32 nRow ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCell();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_CELL_HXX */
--- sw/source/ui/vba/vbacells.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacells.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,223 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacells.hxx"
+#include "vbacell.hxx"
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+#include "vbarow.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > CellCollectionHelper_Base;
+
+class CellsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	CellsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class CellCollectionHelper : public CellCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnLeft;
+    sal_Int32 mnTop;
+    sal_Int32 mnRight;
+    sal_Int32 mnBottom;
+
+public:
+	CellCollectionHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw ( css::uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), mnLeft( nLeft ), mnTop( nTop ), mnRight( nRight ), mnBottom( nBottom )
+    {
+    }
+	virtual ~CellCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return ( mnRight - mnLeft + 1 ) * ( mnBottom - mnTop + 1 );
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw css::lang::IndexOutOfBoundsException();
+        
+        for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+        {
+            for( sal_Int32 col = mnLeft; col <= mnRight; col++ )
+            {
+                if( Index == ( ( row - mnTop ) * ( mnRight - mnLeft + 1 ) + ( col - mnLeft ) ) )
+                    return uno::makeAny( uno::Reference< word::XCell >( new SwVbaCell( mxParent, mxContext, mxTextTable, col, row ) ) );
+            }
+        }
+        throw css::lang::IndexOutOfBoundsException();
+        
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XCell::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new CellsEnumWrapper( this );
+    }
+};
+
+SwVbaCells::SwVbaCells( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw (uno::RuntimeException) : SwVbaCells_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new CellCollectionHelper( xParent, xContext, xTextTable, nLeft, nTop, nRight, nBottom ) ) ), mxTextTable( xTextTable ), mnLeft( nLeft ), mnTop( nTop ), mnRight( nRight ), mnBottom( nBottom )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaCells::getWidth() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+    return xCell->getWidth();
+}
+
+void SAL_CALL SwVbaCells::setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    while( nIndex < m_xIndexAccess->getCount() )
+    {
+        uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( nIndex++ ), uno::UNO_QUERY_THROW );
+        xCell->setWidth( _width );
+    }
+}
+
+uno::Any SAL_CALL SwVbaCells::getHeight() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnTop ) );
+    return xRow->getHeight();
+}
+
+void SAL_CALL SwVbaCells::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->setHeight( _height );
+    }    
+}
+
+::sal_Int32 SAL_CALL SwVbaCells::getHeightRule() throw (css::uno::RuntimeException)
+{
+    uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, mnTop ) );
+    return xRow->getHeightRule();
+}
+
+void SAL_CALL SwVbaCells::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->setHeightRule( _heightrule );
+    }    
+}
+
+void SAL_CALL SwVbaCells::SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    while( nIndex < m_xIndexAccess->getCount() )
+    {
+        uno::Reference< word::XCell > xCell( m_xIndexAccess->getByIndex( nIndex++ ), uno::UNO_QUERY_THROW );
+        xCell->SetWidth( width, rulestyle );
+    }
+}
+
+void SAL_CALL SwVbaCells::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    for( sal_Int32 row = mnTop; row <= mnBottom; row++ )
+    {
+        uno::Reference< word::XRow > xRow( new SwVbaRow( getParent(), mxContext, mxTextTable, row ) );
+        xRow->SetHeight( height, heightrule );
+    }    
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaCells::getElementType() throw (uno::RuntimeException)
+{
+	return word::XCell::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaCells::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaCells::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaCells::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCells") );
+	return sImplName;
+} 
+
+uno::Sequence<rtl::OUString> 
+SwVbaCells::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Cells") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbacells.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacells.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CELLS_HXX
+#define SW_VBA_CELLS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XCells.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XCells > SwVbaCells_BASE;
+
+class SwVbaCells : public SwVbaCells_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    sal_Int32 mnLeft;
+    sal_Int32 mnTop;
+    sal_Int32 mnRight;
+    sal_Int32 mnBottom;
+
+public:
+	SwVbaCells( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nLeft, sal_Int32 nTop, sal_Int32 nRight, sal_Int32 nBottom ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCells() {}
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( ::sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL SetWidth( float width, sal_Int32 rulestyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaCells_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_CELLS_HXX */
--- sw/source/ui/vba/vbacheckbox.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacheckbox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacheckbox.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <ecmaflds.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaCheckBox::SwVbaCheckBox( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& rModel, const uno::Reference< text::XFormField >& xFormField ) throw ( uno::RuntimeException ) : SwVbaCheckBox_BASE( rParent, rContext ), mxModel( rModel ), mxFormField( xFormField )
+{
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( !sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        throw uno::RuntimeException( rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("It is not a CheckBox")), uno::Reference< uno::XInterface >() );
+    }
+}
+
+SwVbaCheckBox::~SwVbaCheckBox()
+{
+}
+
+sal_Bool SAL_CALL SwVbaCheckBox::getValue() throw ( uno::RuntimeException )
+{
+    sal_Bool bValue = sal_False;
+    sal_Int32 nCount = mxFormField->getParamCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        if( mxFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX_CHECKED ) )
+        {
+            if( mxFormField->getParamValue(i).equalsIgnoreAsciiCaseAscii("on") )
+                bValue = sal_True;
+            else
+                bValue = sal_False;
+            break;    
+        }
+    }
+    return bValue;
+}
+
+void SAL_CALL SwVbaCheckBox::setValue( sal_Bool value ) throw ( uno::RuntimeException )
+{
+    rtl::OUString sValue = rtl::OUString::createFromAscii( value ? "on" : "off" );
+    mxFormField->addParam( rtl::OUString::createFromAscii( ECMA_FORMCHECKBOX_CHECKED ), sValue, sal_True );
+}
+
+rtl::OUString& 
+SwVbaCheckBox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCheckBox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaCheckBox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.CheckBox" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbacheckbox.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacheckbox.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_CHECKBOX_HXX
+#define SW_VBA_CHECKBOX_HXX
+
+#include <ooo/vba/word/XCheckBox.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XFormField.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XCheckBox > SwVbaCheckBox_BASE;
+
+class SwVbaCheckBox : public SwVbaCheckBox_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XFormField > mxFormField;
+
+public:
+	SwVbaCheckBox( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XFormField >& xFormField ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaCheckBox();
+
+    // Methods
+    sal_Bool SAL_CALL getValue() throw ( css::uno::RuntimeException );
+    void SAL_CALL setValue( sal_Bool value ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_CHECKBOX_HXX */
--- sw/source/ui/vba/vbacolumn.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacolumn.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,201 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacolumn.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbatable.hxx"
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+#define RELATIVE_TABLE_WIDTH 10000
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaColumn::SwVbaColumn( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( uno::RuntimeException ) :
+    SwVbaColumn_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnIndex( nIndex )
+{
+    mxTableColumns = mxTextTable->getColumns();
+}
+
+SwVbaColumn::~SwVbaColumn()
+{
+}
+
+void SwVbaColumn::calculateAbsoluteColumnWidth( sal_Int32 nTableWidth, const css::uno::Sequence< css::text::TableColumnSeparator >& aSeparators, double* pAbsWidth )
+{
+    const text::TableColumnSeparator* pArray = aSeparators.getConstArray();
+    sal_Int32 nSepCount = aSeparators.getLength();
+    for( sal_Int32 i = 0; i <= nSepCount; i++ )
+    {
+        sal_Int32 nRelColWidth = 0;
+        if( i == 0 )
+        {
+            if( nSepCount != 0 )
+            {
+                nRelColWidth = pArray[0].Position;
+            }
+            else
+            {
+                nRelColWidth = RELATIVE_TABLE_WIDTH;
+            }
+        }
+        else
+        {
+            if( i == nSepCount )
+            {
+                nRelColWidth = RELATIVE_TABLE_WIDTH - pArray[i-1].Position;
+            }
+            else
+            {
+                nRelColWidth = pArray[i].Position - pArray[i-1].Position;
+            }
+        }
+        pAbsWidth[i] = ( (double)nRelColWidth / RELATIVE_TABLE_WIDTH ) * (double) nTableWidth;
+    }
+}
+
+void SwVbaColumn::calculateRelativeColumnWidth( const double* pAbsWidth, double* pRelWidth, sal_Int32 nCount )
+{
+    double tableWidth = 0.0;
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        tableWidth += pAbsWidth[i];
+    }
+
+    pRelWidth[ nCount - 1 ] = tableWidth;
+    for( sal_Int32 i = 0; i < nCount - 1; i++ )
+    {
+        if( i == 0 )
+        {
+            pRelWidth[i] = ( pAbsWidth[i] * RELATIVE_TABLE_WIDTH ) / tableWidth;
+        }
+        else
+        {
+            pRelWidth[i] = pRelWidth[i-1] + ( pAbsWidth[i] * RELATIVE_TABLE_WIDTH ) / tableWidth;
+        }
+    }
+}
+
+sal_Int32 SAL_CALL
+SwVbaColumn::getWidth( ) throw ( css::uno::RuntimeException )
+{
+   /* uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Sequence< text::TableColumnSeparator > aSeparators;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ) ) >>= aSeparators;
+    sal_Int32 nTableWidth = SwVbaTable::getTableWidth( xTableProps );
+    sal_Int32 nColCont = aSeparators.getLength() + 1;
+    double dAbsColWidth[ nColCont ];
+    calculateAbsoluteColumnWidth( nTableWidth, aSeparators, dAbsColWidth );
+    return Millimeter::getInPoints( (sal_Int32)( dAbsColWidth[ mnIndex ] ) );
+   */ 
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    return aTableHelper.GetColWidth( mnIndex );
+}
+
+void SAL_CALL
+SwVbaColumn::setWidth( sal_Int32 _width ) throw ( css::uno::RuntimeException )
+{
+/*    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Sequence< text::TableColumnSeparator > aSeparators;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ) ) >>= aSeparators;
+    sal_Int32 nTableWidth = SwVbaTable::getTableWidth( xTableProps );
+    sal_Int32 nColCont = aSeparators.getLength() + 1;
+    double dAbsColWidth[ nColCont ];
+    calculateAbsoluteColumnWidth( nTableWidth, aSeparators, dAbsColWidth );
+    dAbsColWidth[ mnIndex ] = Millimeter::getInHundredthsOfOneMillimeter( _width );
+    double tableWidth = 0.0;
+    for( sal_Int32 i = 0; i < nColCont; i++ )
+    {
+        tableWidth += dAbsColWidth[i];
+    }
+    
+    double dRelColWidth[ nColCont ];
+    calculateRelativeColumnWidth( dAbsColWidth, dRelColWidth, nColCont);
+
+    text::TableColumnSeparator* pArray = aSeparators.getArray();
+    for( sal_Int32 i = 0; i < nColCont - 1; i++ )
+    {
+        pArray[i].Position = (sal_Int16)(dRelColWidth[i]);
+    }
+
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TableColumnSeparators") ), uno::makeAny( aSeparators ) );
+    SwVbaTable::setTableWidth( xTableProps, (sal_Int32)( tableWidth ) );
+    */
+
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    aTableHelper.SetColWidth( _width, mnIndex );
+}
+
+void SAL_CALL
+SwVbaColumn::Select( ) throw ( uno::RuntimeException )
+{
+    SelectColumn( getCurrentWordDoc(mxContext), mxTextTable, mnIndex, mnIndex );
+}
+
+void SwVbaColumn::SelectColumn( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nStartColumn, sal_Int32 nEndColumn ) throw ( uno::RuntimeException )
+{
+    rtl::OUStringBuffer aRangeName;
+    rtl::OUString sStartCol = SwVbaTableHelper::getColumnStr( nStartColumn );
+    aRangeName.append(sStartCol).append(sal_Int32( 1 ) );
+    rtl::OUString sEndCol = SwVbaTableHelper::getColumnStr( nEndColumn );
+    sal_Int32 nRowCount = xTextTable->getRows()->getCount();
+    aRangeName.appendAscii(":").append( sEndCol ).append( sal_Int32( nRowCount ) );
+
+    uno::Reference< table::XCellRange > xCellRange( xTextTable, uno::UNO_QUERY_THROW );
+    rtl::OUString sSelRange = aRangeName.makeStringAndClear();
+    uno::Reference< table::XCellRange > xSelRange = xCellRange->getCellRangeByName( sSelRange );
+
+    uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelection->select( uno::makeAny( xSelRange ) );
+}
+
+rtl::OUString& 
+SwVbaColumn::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaColumn") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaColumn::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Column" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbacolumn.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacolumn.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_COLUMN_HXX
+#define SW_VBA_COLUMN_HXX
+
+#include <ooo/vba/word/XColumn.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/TableColumnSeparator.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XColumn > SwVbaColumn_BASE;
+
+class SwVbaColumn : public SwVbaColumn_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableColumns > mxTableColumns;
+    sal_Int32 mnIndex;
+
+private:
+    void calculateAbsoluteColumnWidth( sal_Int32 nTableWidth, const css::uno::Sequence< css::text::TableColumnSeparator >& aSeparators, double* pAbsWidth );
+    void calculateRelativeColumnWidth( const double* pAbsWidth, double* pRelWidth, sal_Int32 nCount );
+
+public:
+	SwVbaColumn( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaColumn();
+
+    // Methods
+    virtual sal_Int32 SAL_CALL getWidth() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    static void SelectColumn( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nStartColumn, sal_Int32 nEndColumn ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_COLUMN_HXX */
--- sw/source/ui/vba/vbacolumns.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacolumns.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,160 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacolumns.hxx"
+#include "vbacolumn.hxx"
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <ooo/vba/word/WdRulerStyle.hpp>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ColumnsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< text::XTextTable > mxTextTable;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    uno::WeakReference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+	sal_Int32 nIndex;
+
+public:
+	ColumnsEnumWrapper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< text::XTextTable >& xTextTable ) : mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), nIndex( 0 ) 
+    {
+        mxIndexAccess.set( mxTextTable->getColumns(), uno::UNO_QUERY );
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return uno::makeAny( uno::Reference< word::XColumn > ( new SwVbaColumn( mxParent, mxContext, mxTextTable, nIndex++ ) ) );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaColumns::SwVbaColumns( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableColumns >& xTableColumns ) throw (uno::RuntimeException) : SwVbaColumns_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableColumns, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableColumns( xTableColumns ) 
+{
+    mnStartColumnIndex = 0;
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    mnEndColumnIndex = aTableHelper.getTabColumnsMaxCount( ) - 1;
+}
+
+SwVbaColumns::SwVbaColumns( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableColumns >& xTableColumns, sal_Int32 nStartCol, sal_Int32 nEndCol ) throw (uno::RuntimeException) : SwVbaColumns_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableColumns, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableColumns( xTableColumns ), mnStartColumnIndex( nStartCol ), mnEndColumnIndex( nEndCol ) 
+{
+    if( mnEndColumnIndex < mnStartColumnIndex )
+        throw uno::RuntimeException();
+}
+
+uno::Reference< word::XColumn > SwVbaColumns::getColumnAtIndex( sal_Int32 index ) throw (uno::RuntimeException)
+{
+    return uno::Reference< word::XColumn >( new SwVbaColumn( this, mxContext, mxTextTable, index ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaColumns::getWidth() throw (uno::RuntimeException)
+{
+    return getColumnAtIndex( mnStartColumnIndex )->getWidth();
+}
+
+void SAL_CALL SwVbaColumns::setWidth( ::sal_Int32 _width ) throw (uno::RuntimeException)
+{
+    for( sal_Int32 index = mnStartColumnIndex; index <= mnEndColumnIndex; index++ )
+    {
+        getColumnAtIndex( index )->setWidth( _width );
+    }
+}
+
+void SAL_CALL SwVbaColumns::Select(  ) throw (uno::RuntimeException)
+{
+    SwVbaColumn::SelectColumn( getCurrentWordDoc(mxContext), mxTextTable, mnStartColumnIndex, mnEndColumnIndex );
+}
+
+::sal_Int32 SAL_CALL SwVbaColumns::getCount() throw (uno::RuntimeException)
+{
+    return ( mnEndColumnIndex - mnStartColumnIndex + 1 );
+}
+
+uno::Any SAL_CALL SwVbaColumns::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex <= 0 || nIndex > getCount() )
+        {
+            throw  lang::IndexOutOfBoundsException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        }
+        return uno::makeAny( uno::Reference< word::XColumn >( new SwVbaColumn( this, mxContext, mxTextTable, nIndex - 1 ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaColumns::getElementType() throw (uno::RuntimeException)
+{
+	return word::XColumn::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaColumns::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ColumnsEnumWrapper( this, mxContext, mxTextTable );
+}
+
+uno::Any
+SwVbaColumns::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaColumns::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaColumns") );
+	return sImplName;
+} 
+
+uno::Sequence<rtl::OUString> 
+SwVbaColumns::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Columns") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbacolumns.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbacolumns.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_COLUMNS_HXX
+#define SW_VBA_COLUMNS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XColumns.hpp>
+#include <ooo/vba/word/XColumn.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XColumns > SwVbaColumns_BASE;
+
+class SwVbaColumns : public SwVbaColumns_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableColumns > mxTableColumns;
+    sal_Int32 mnStartColumnIndex;
+    sal_Int32 mnEndColumnIndex;
+
+private:
+    css::uno::Reference< ooo::vba::word::XColumn > getColumnAtIndex( sal_Int32 index ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaColumns( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableColumns >& xTableColumns ) throw ( css::uno::RuntimeException );
+	SwVbaColumns( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableColumns >& xTableColumns, sal_Int32 nStartCol, sal_Int32 nEndCol ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaColumns() {}
+
+    virtual sal_Int32 SAL_CALL getWidth(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    //XCollection
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaColumns_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_COLUMNS_HXX */
--- sw/source/ui/vba/vbadocument.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbadocument.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -41,7 +41,9 @@
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
 #include <ooo/vba/XControlProvider.hpp>
+#include <ooo/vba/word/WdProtectionType.hpp>
 
 #include <vbahelper/helperdecl.hxx>
 #include <wordvbahelper.hxx>
@@ -53,7 +55,13 @@
 #include "vbafield.hxx"
 #include "vbapagesetup.hxx"
 #include "vbasections.hxx"
+#include "vbatablesofcontents.hxx"
 #include <vbahelper/vbashapes.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include "vbarevisions.hxx"
+#include "vbaframes.hxx"
+#include "vbaformfields.hxx"
+#include <osl/file.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -223,6 +231,28 @@ SwVbaDocument::Sections( const uno::Any&
 }
 
 uno::Any SAL_CALL
+SwVbaDocument::TablesOfContents( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaTablesOfContents( this, mxContext, mxTextDocument ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::FormFields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+#ifdef FIELDPATCH
+    uno::Reference< XCollection > xCol( new SwVbaFormFields( this, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+#else
+    uno::Reference< XCollection > xCol;
+#endif
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
 SwVbaDocument::PageSetup( ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xPageProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
@@ -242,16 +272,35 @@ SwVbaDocument::getAttachedTemplate() thr
     uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( getModel(), uno::UNO_QUERY_THROW );
     uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
     uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
-    rtl::OUString sTemplateName = xDocProps->getTemplateName();
+    rtl::OUString sTemplateUrl = xDocProps->getTemplateURL();
 
-    xTemplate = new SwVbaTemplate( this, mxContext, getModel(), sTemplateName );
+    xTemplate = new SwVbaTemplate( this, mxContext, getModel(), sTemplateUrl );
     return uno::makeAny( xTemplate );
 }
 
 void SAL_CALL 
-SwVbaDocument::setAttachedTemplate( const css::uno::Any& /*_attachedtemplate*/ ) throw (uno::RuntimeException)
+SwVbaDocument::setAttachedTemplate( const css::uno::Any& _attachedtemplate ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException();
+    rtl::OUString sTemplate;
+    if( !( _attachedtemplate >>= sTemplate ) )
+    {
+        throw uno::RuntimeException();
+    }
+    rtl::OUString aURL;
+    INetURLObject aObj;
+    aObj.SetURL( sTemplate );
+    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+    if ( bIsURL )
+        aURL = sTemplate;
+    else
+        osl::FileBase::getFileURLFromSystemPath( sTemplate, aURL );
+
+    SwDocShell* pDocShell = word::getDocShell( getModel() );
+    uno::Reference< word::XTemplate > xTemplate;
+    uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( getModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    xDocProps->setTemplateURL( aURL );
 }
 
 uno::Any SAL_CALL 
@@ -270,6 +319,116 @@ void SAL_CALL SwVbaDocument::Activate()
     VbaDocumentBase::Activate();
 }
 
+::sal_Int32 SAL_CALL SwVbaDocument::getProtectionType() throw (css::uno::RuntimeException)
+{
+    //TODO
+    return word::WdProtectionType::wdNoProtection;
+}
+
+void SAL_CALL SwVbaDocument::setProtectionType( ::sal_Int32 _protectiontype ) throw (css::uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Bool SAL_CALL SwVbaDocument::getUpdateStylesOnOpen() throw (css::uno::RuntimeException)
+{
+    //TODO
+    return sal_False;
+}
+
+void SAL_CALL SwVbaDocument::setUpdateStylesOnOpen( ::sal_Bool _updatestylesonopen ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Bool SAL_CALL SwVbaDocument::getAutoHyphenation() throw (uno::RuntimeException)
+{
+    // check this property only in default paragraph style
+    sal_Bool IsAutoHyphenation = sal_False;
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation")) ) >>= IsAutoHyphenation;
+    return IsAutoHyphenation;
+}
+
+void SAL_CALL SwVbaDocument::setAutoHyphenation( ::sal_Bool _autohyphenation ) throw (uno::RuntimeException)
+{
+    //TODO
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation")), uno::makeAny( _autohyphenation ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaDocument::getHyphenationZone() throw (uno::RuntimeException)
+{
+    //TODO
+    return 0;
+}
+
+void SAL_CALL SwVbaDocument::setHyphenationZone( ::sal_Int32 _hyphenationzone ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+::sal_Int32 SAL_CALL SwVbaDocument::getConsecutiveHyphensLimit() throw (uno::RuntimeException)
+{
+    //TODO
+    sal_Int16 nHyphensLimit = 0;
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaHyphenationMaxHyphens")) ) >>= nHyphensLimit;
+    return nHyphensLimit;
+}
+
+void SAL_CALL SwVbaDocument::setConsecutiveHyphensLimit( ::sal_Int32 _consecutivehyphenslimit ) throw (uno::RuntimeException)
+{
+    sal_Int16 nHyphensLimit = static_cast< sal_Int16 >( _consecutivehyphenslimit );
+    uno::Reference< beans::XPropertySet > xParaProps( word::getDefaultParagraphStyle( getModel() ), uno::UNO_QUERY_THROW );
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaHyphenationMaxHyphens")), uno::makeAny( nHyphensLimit ) );
+}
+
+void SAL_CALL SwVbaDocument::Protect( ::sal_Int32 Type, const uno::Any& NOReset, const uno::Any& Password, const uno::Any& UseIRM, const uno::Any& EnforceStyleLock ) throw (uno::RuntimeException)
+{
+    // Seems not support in Writer
+    // VbaDocumentBase::Protect( Password );
+}
+
+void SAL_CALL SwVbaDocument::PrintOut( const uno::Any& Background, const uno::Any& Append, const uno::Any& Range, const uno::Any& OutputFileName, const uno::Any& From, const uno::Any& To, const uno::Any& Item, const uno::Any& Copies, const uno::Any& Pages, const uno::Any& PageType, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& FileName, const uno::Any& ActivePrinterMacGX, const uno::Any& ManualDuplexPrint, const uno::Any& PrintZoomColumn, const uno::Any& PrintZoomRow, const uno::Any& PrintZoomPaperWidth, const uno::Any& PrintZoomPaperHeight ) throw (uno::RuntimeException)
+{
+    //TODO
+}
+
+void SAL_CALL SwVbaDocument::PrintPreview(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PrintPreview"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaDocument::ClosePrintPreview(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ClosePreview"));
+    dispatchRequests( mxModel,url );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Revisions( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRevisions( this, mxContext, getModel(), xRedlines ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Frames( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextFramesSupplier > xTextFramesSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xFrames( xTextFramesSupp->getTextFrames(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaFrames( this, mxContext, xFrames, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
 uno::Any
 SwVbaDocument::getControlShape( const ::rtl::OUString& sName )
 {
--- sw/source/ui/vba/vbadocument.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbadocument.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -68,6 +68,25 @@ public:
     virtual css::uno::Any SAL_CALL Sections( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL PageSetup() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL TablesOfContents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL FormFields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getProtectionType() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setProtectionType( ::sal_Int32 _protectiontype ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUpdateStylesOnOpen() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUpdateStylesOnOpen( ::sal_Bool _updatestylesonopen ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoHyphenation() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoHyphenation( ::sal_Bool _autohyphenation ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHyphenationZone() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHyphenationZone( ::sal_Int32 _hyphenationzone ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getConsecutiveHyphensLimit() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setConsecutiveHyphensLimit( ::sal_Int32 _consecutivehyphenslimit ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Protect( ::sal_Int32 Type, const css::uno::Any& NOReset, const css::uno::Any& Password, const css::uno::Any& UseIRM, const css::uno::Any& EnforceStyleLock ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL PrintOut( const css::uno::Any& Background, const css::uno::Any& Append, const css::uno::Any& Range, const css::uno::Any& OutputFileName, const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Item, const css::uno::Any& Copies, const css::uno::Any& Pages, const css::uno::Any& PageType, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& FileName, const css::uno::Any& ActivePrinterMacGX, const css::uno::Any& ManualDuplexPrint, const css::uno::Any& PrintZoomColumn, const css::uno::Any& PrintZoomRow, const css::uno::Any& PrintZoomPaperWidth, const css::uno::Any& PrintZoomPaperHeight ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL PrintPreview(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ClosePrintPreview(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Revisions( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Frames( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
 	// XInvocation
 	virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
--- sw/source/ui/vba/vbadocumentproperties.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbadocumentproperties.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -206,16 +206,16 @@ public:
     
     static DocPropInfo createDocPropInfo( const rtl::OUString& sDesc, const rtl::OUString& sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
     {
-        return createDocPropInfo( rtl::OUStringToOString( sDesc, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( sPropName, RTL_TEXTENCODING_UTF8 ).getStr(), rHelper );
+        DocPropInfo aItem;
+        aItem.msMSODesc = sDesc;
+        aItem.msOOOPropName = sPropName;
+        aItem.mpPropGetSetHelper = rHelper;
+        return aItem;
     }
 
     static DocPropInfo createDocPropInfo( const sal_Char* sDesc, const sal_Char* sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
     {
-        DocPropInfo aItem;
-        aItem.msMSODesc = rtl::OUString::createFromAscii( sDesc );
-        aItem.msOOOPropName = rtl::OUString::createFromAscii( sPropName );
-        aItem.mpPropGetSetHelper = rHelper;
-        return aItem;
+        return createDocPropInfo( rtl::OUString::createFromAscii( sDesc ), rtl::OUString::createFromAscii( sPropName ), rHelper );
     }
     uno::Any getValue() 
     {
--- sw/source/ui/vba/vbaeventshelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaeventshelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include <vbahelper/helperdecl.hxx>
+#include <sfx2/objsh.hxx> 
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <svx/msvbahelper.hxx>
+#include "wordvbahelper.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+using namespace com::sun::star::document::VbaEventId;
+
+const static String sThisDocument( RTL_CONSTASCII_USTRINGPARAM("ThisDocument"));
+
+SwVbaEventsHelper::SwVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext ) : VbaEventsHelperBase( xContext )
+{
+    Initilize();
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    pDocShell = word::getDocShell( xModel );
+}
+
+SwVbaEventsHelper::~SwVbaEventsHelper()
+{
+}
+
+void SwVbaEventsHelper::Initilize()
+{
+    insert( VBAEVENT_DOCUMENT_NEW, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Document_New") ) );
+    insert( VBAEVENT_DOCUMENT_AUTONEW, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoNew") ) );
+    insert( VBAEVENT_DOCUMENT_OPEN, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Document_Open") ) );
+    insert( VBAEVENT_DOCUMENT_AUTOOPEN, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoOpen") ) );
+    insert( VBAEVENT_DOCUMENT_CLOSE, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Document_Close") ) );
+}
+
+rtl::OUString
+SwVbaEventsHelper::getMacroPath( const sal_Int32 nEventId )
+{
+    String sMacroName = getEventName( nEventId );
+    VBAMacroResolvedInfo sMacroResolvedInfo;
+    switch( nEventId )
+    {
+        // Document events
+    	case VBAEVENT_DOCUMENT_NEW:
+    	case VBAEVENT_DOCUMENT_OPEN:
+    	case VBAEVENT_DOCUMENT_CLOSE:
+        {
+            sMacroName.Insert( '.', 0 ).Insert( sThisDocument, 0);
+            sMacroResolvedInfo = resolveVBAMacro( pDocShell, sMacroName );
+            break;
+        }
+    	case VBAEVENT_DOCUMENT_AUTONEW:
+    	case VBAEVENT_DOCUMENT_AUTOOPEN:
+        {
+            sMacroResolvedInfo = resolveVBAMacro( pDocShell, sMacroName );
+            break;
+        }
+        default:
+            break;
+    }
+    return sMacroResolvedInfo.ResolvedMacro();
+}
+
+sal_Bool SwVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& rArgs )
+{
+	sal_Bool result = sal_False;
+	uno::Sequence< uno::Any > aArgs;
+	uno::Any aRet;
+	uno::Any aDummyCaller;
+    
+    // For most cases, there is no corresponsible event macro in the document. 
+    // It is better fo check if the event macro exists before process the arguments to improve performance.
+    rtl::OUString sMacroPath = getMacroPath( nEventId );
+	if( sMacroPath.getLength() )
+	{
+        // excute the macro
+        result = executeMacro( pDocShell, sMacroPath, aArgs, aRet, aDummyCaller );
+	}
+    
+	return result;
+}
+
+sal_Bool SAL_CALL 
+SwVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 nEventId, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+	if( !pDocShell || mbIgnoreEvents)
+		return sal_False;
+    
+    // In order to better support "withevents" in the future, 
+    // it is better to process a event at a time
+    switch( nEventId )
+    {
+    	case VBAEVENT_DOCUMENT_NEW:
+        {
+            processVbaEvent( VBAEVENT_DOCUMENT_AUTONEW, aArgs );
+            processVbaEvent( nEventId, aArgs );
+            break;
+        }
+    	case VBAEVENT_DOCUMENT_OPEN:
+        {
+            processVbaEvent( VBAEVENT_DOCUMENT_AUTOOPEN, aArgs );
+            processVbaEvent( nEventId, aArgs );
+            break;
+        }
+    	case VBAEVENT_DOCUMENT_CLOSE:
+        {
+            return processVbaEvent( nEventId, aArgs );
+        }
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+::sal_Bool SAL_CALL 
+SwVbaEventsHelper::getIgnoreEvents() throw (uno::RuntimeException)
+{
+    return VbaEventsHelperBase::getIgnoreEvents();
+}
+
+void SAL_CALL 
+SwVbaEventsHelper::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (uno::RuntimeException)
+{
+    VbaEventsHelperBase::setIgnoreEvents( _ignoreevents );
+}
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<SwVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SwVbaEventsHelper",
+    "com.sun.star.text.TextDocumentVbaEventsHelper" );
+}
--- sw/source/ui/vba/vbaeventshelper.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaeventshelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SW_VBAEVENTS_HXX
+#define SW_VBAEVENTS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <vbahelper/vbaeventshelperbase.hxx>
+#include <doc.hxx>
+#include <docsh.hxx>
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::document::XVbaEventsHelper > VBADocumentEvent_BASE;
+
+class SwVbaEventsHelper : public VBADocumentEvent_BASE, public VbaEventsHelperBase
+{
+private:
+	SwDocShell* pDocShell;
+
+    rtl::OUString getMacroPath( const sal_Int32 nEventId );
+    sal_Bool processVbaEvent( const sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& rArgs );
+    void Initilize();
+
+public:
+    SwVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~SwVbaEventsHelper();
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+};
+
+#endif
+
--- sw/source/ui/vba/vbafield.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbafield.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -36,6 +36,7 @@
 #include <ooo/vba/word/WdFieldType.hpp>
 #include <com/sun/star/text/FilenameDisplayFormat.hpp>
 #include <com/sun/star/util/XRefreshable.hpp>
+#include <com/sun/star/util/XUpdatable.hpp>
 #include <swtypes.hxx>
 
 using namespace ::ooo::vba;
@@ -48,6 +49,17 @@ SwVbaField::SwVbaField(  const uno::Refe
     mxTextField.set( xTextField, uno::UNO_QUERY_THROW );
 }
 
+sal_Bool SAL_CALL SwVbaField::Update() throw (uno::RuntimeException)
+{
+    uno::Reference< util::XUpdatable > xUpdatable( mxTextField, uno::UNO_QUERY );
+    if( xUpdatable.is() )
+    {
+        xUpdatable->update();
+        return sal_True;
+    }
+    return sal_False;
+}
+
 // XHelperInterface
 rtl::OUString& 
 SwVbaField::getServiceImplName()
@@ -371,6 +383,7 @@ SwVbaFields::Add( const css::uno::Refere
     {
         _ReadFieldParams aReadParam(sText);
         sFieldName = aReadParam.GetFieldName();
+        OSL_TRACE("SwVbaFields::Add, the field name is %s ",rtl::OUStringToOString( sFieldName, RTL_TEXTENCODING_UTF8 ).getStr() );
     }
 
     uno::Reference< text::XTextContent > xTextField;
@@ -378,6 +391,10 @@ SwVbaFields::Add( const css::uno::Refere
     {
         xTextField.set( Create_Field_FileName( sText ), uno::UNO_QUERY_THROW );
     }
+    else if( nType == word::WdFieldType::wdFieldDocProperty || sFieldName.EqualsIgnoreCaseAscii("DOCPROPERTY") )
+    {
+        xTextField.set( Create_Field_DocProperty( sText ), uno::UNO_QUERY_THROW );
+    }    
     else
     {
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
@@ -422,6 +439,104 @@ uno::Reference< text::XTextField > SwVba
     return xTextField;
 }
 
+struct DocPropertyTable
+{
+    const char* sDocPropertyName;
+    const char* sFieldService;
+};
+
+static const DocPropertyTable aDocPropertyTables[] = 
+{ 
+    { "Author", "com.sun.star.text.textfield.docinfo.CreateAuthor" }, 
+    { "Bytes", NULL },
+    { "Category", NULL },
+    { "Characters",NULL },
+    { "CharactersWithSpaces", NULL },
+    { "Comments", "com.sun.star.text.textfield.docinfo.Description" },
+    { "Company", NULL },
+    { "CreateTime", "com.sun.star.text.textfield.docinfo.CreateDateTime" },
+    { "HyperlinkBase", NULL },
+    { "Keywords", "com.sun.star.text.textfield.docinfo.Keywords" },
+    { "LastPrinted", "com.sun.star.text.textfield.docinfo.PrintDateTime" },
+    { "LastSavedBy", "com.sun.star.text.textfield.docinfo.ChangeAuthor" },
+    { "LastSavedTime", "com.sun.star.text.textfield.docinfo.ChangeDateTime" },
+    { "Lines", NULL },
+    { "Manager", NULL },
+    { "NameofApplication", NULL },
+    { "ODMADocID", NULL },
+    { "Pages", "com.sun.star.text.textfield.PageCount" },
+    { "Paragraphs", "com.sun.star.text.textfield.ParagraphCount" },
+    { "RevisionNumber", "com.sun.star.text.textfield.docinfo.Revision" },
+    { "Security", NULL },
+    { "Subject", "com.sun.star.text.textfield.docinfo.Subject" },
+    { "Template", "com.sun.star.text.textfield.TemplateName" },
+    { "Title", "com.sun.star.text.textfield.docinfo.Title" },
+    { "TotalEditingTime", "com.sun.star.text.textfield.docinfo.EditTime" },
+    { "Words", "com.sun.star.text.textfield.WordCount" },
+    { NULL, NULL }
+};
+
+uno::Reference< text::XTextField > SwVbaFields::Create_Field_DocProperty( const rtl::OUString _text ) throw (uno::RuntimeException)
+{
+    String aDocProperty;
+    _ReadFieldParams aReadParam( _text );
+    long nRet;
+    while( -1 != ( nRet = aReadParam.SkipToNextToken() ))
+    {
+        switch( nRet )
+        {
+            case -2:
+                if( !aDocProperty.Len() )
+                    aDocProperty = aReadParam.GetResult();
+                break;
+            case '*':
+                //Skip over MERGEFORMAT
+                aReadParam.SkipToNextToken();
+                break;
+        }
+    }
+    aDocProperty.EraseAllChars('"');
+    OSL_TRACE("SwVbaFields::Create_Field_DocProperty, the document property name is %s ",rtl::OUStringToOString( aDocProperty, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( aDocProperty.Len() == 0 )
+    {
+        throw uno::RuntimeException();
+    }
+
+    sal_Bool bCustom = sal_True;
+    rtl::OUString sFieldService;
+    // find the build in document properties
+    for( const DocPropertyTable* pTable = aDocPropertyTables; pTable->sDocPropertyName != NULL; pTable++ )
+    {
+        if( aDocProperty.EqualsIgnoreCaseAscii( pTable->sDocPropertyName ) )
+        {
+            if( pTable->sFieldService != NULL )
+                sFieldService = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( pTable->sFieldService ) );
+            bCustom = sal_False;
+            break;
+        }
+    }
+
+    if( bCustom )
+    {
+        sFieldService = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.text.textfield.docinfo.Custom" ) );
+    }    
+    else if( sFieldService.getLength() == 0 )
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+
+    uno::Reference< text::XTextField > xTextField( mxMSF->createInstance( sFieldService ), uno::UNO_QUERY_THROW );
+
+    if( bCustom )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xTextField, uno::UNO_QUERY_THROW );
+        rtl::OUString sDocPropertyName( aDocProperty );
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ), uno::makeAny( sDocPropertyName ) );
+    }
+    
+    return xTextField;
+}
+
 uno::Reference< container::XEnumeration > SAL_CALL 
 SwVbaFields::createEnumeration() throw (uno::RuntimeException)
 {
--- sw/source/ui/vba/vbafield.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbafield.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -44,7 +44,8 @@ class SwVbaField : public SwVbaField_BAS
     css::uno::Reference< css::text::XTextField > mxTextField;
 public:
     SwVbaField( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const css::uno::Reference< css::text::XTextField >& xTextField) throw ( css::uno::RuntimeException);
-
+  
+    virtual sal_Bool SAL_CALL Update() throw ( css::uno::RuntimeException);
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
@@ -60,6 +61,7 @@ class SwVbaFields : public SwVbaFields_B
     css::uno::Reference< css::lang::XMultiServiceFactory > mxMSF;
 private:
     css::uno::Reference< css::text::XTextField > Create_Field_FileName( const rtl::OUString _text ) throw (css::uno::RuntimeException);
+    css::uno::Reference< css::text::XTextField > Create_Field_DocProperty( const rtl::OUString _text ) throw (css::uno::RuntimeException);
 
 public:
     SwVbaFields( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
--- sw/source/ui/vba/vbaformfield.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaformfield.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,139 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaformfield.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <ecmaflds.hxx>
+#include "vbacheckbox.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaFormField::SwVbaFormField( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& rModel, const uno::Reference< text::XFormField >& xFormField ) throw ( uno::RuntimeException ) : SwVbaFormField_BASE( rParent, rContext ), mxModel( rModel ), mxFormField( xFormField )
+{
+}
+
+SwVbaFormField::~SwVbaFormField()
+{
+}
+
+rtl::OUString SAL_CALL SwVbaFormField::getResult() throw ( uno::RuntimeException )
+{
+    rtl::OUString sResult;
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMTEXT ) )
+    {
+        uno::Reference< text::XTextContent > xTextContent( mxFormField, uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xTextRange = xTextContent->getAnchor();
+        sResult = xTextRange->getString();
+    }
+    else if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        sal_Int32 nValue = 0;
+        sal_Int32 nCount = mxFormField->getParamCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            if( mxFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX_CHECKED ) )
+            {
+                if( mxFormField->getParamValue(i).equalsIgnoreAsciiCaseAscii("on") )
+                    nValue = 1;
+                else
+                    nValue = 0;
+                break;    
+            }
+
+        }
+        sResult = rtl::OUString::valueOf( nValue );
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+    return sResult;
+}
+
+void SAL_CALL SwVbaFormField::setResult( const rtl::OUString& result ) throw ( uno::RuntimeException )
+{
+    rtl::OUString sType = mxFormField->getFieldType();
+    if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMTEXT ) )
+    {
+        uno::Reference< text::XTextContent > xTextContent( mxFormField, uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xTextRange = xTextContent->getAnchor();
+        xTextRange->setString( result );
+    }
+    else if( sType.equalsIgnoreAsciiCaseAscii( ECMA_FORMCHECKBOX ) )
+    {
+        // do nothing
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+sal_Bool SAL_CALL SwVbaFormField::getEnabled() throw ( uno::RuntimeException )
+{
+    //allways return true
+    return sal_True;
+}
+
+void SAL_CALL SwVbaFormField::setEnabled( sal_Bool/* enabled */ ) throw ( uno::RuntimeException )
+{
+    // not support in Writer
+}
+
+uno::Any SAL_CALL SwVbaFormField::CheckBox() throw ( uno::RuntimeException )
+{
+    return uno::makeAny( uno::Reference< word::XCheckBox >( new SwVbaCheckBox( this, mxContext, mxModel, mxFormField ) ) );
+}
+
+rtl::OUString& 
+SwVbaFormField::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFormField") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaFormField::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.FormField" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbaformfield.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaformfield.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FORMFIELD_HXX
+#define SW_VBA_FORMFIELD_HXX
+
+#include <ooo/vba/word/XFormField.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XFormField.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XFormField > SwVbaFormField_BASE;
+
+class SwVbaFormField : public SwVbaFormField_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XFormField > mxFormField;
+
+public:
+	SwVbaFormField( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XFormField >& xFormField ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFormField();
+
+    // Methods
+    rtl::OUString SAL_CALL getResult() throw ( css::uno::RuntimeException );
+    void SAL_CALL setResult( const rtl::OUString& result ) throw ( css::uno::RuntimeException );
+    sal_Bool SAL_CALL getEnabled() throw ( css::uno::RuntimeException );
+    void SAL_CALL setEnabled( sal_Bool enabled ) throw ( css::uno::RuntimeException );
+    css::uno::Any SAL_CALL CheckBox() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_FORMFIELD_HXX */
--- sw/source/ui/vba/vbaformfields.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaformfields.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,205 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaformfields.hxx"
+#include "vbaformfield.hxx"
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include "wordvbahelper.hxx"
+#include <cppuhelper/implbase3.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef std::vector< uno::Reference< text::XFormField > > XFormFieldVec;
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > FormFiledEnumeration_BASE;
+typedef ::cppu::WeakImplHelper3< container::XNameAccess, container::XIndexAccess, container::XEnumerationAccess > FormFieldCollectionHelper_BASE;
+
+rtl::OUString lcl_getFormFieldName( const uno::Reference< text::XFormField >& xFormField )
+{
+    rtl::OUString sName;
+    sal_Int32 nCount = xFormField->getParamCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        if( xFormField->getParamName(i).equalsIgnoreAsciiCaseAscii( "Name" ) )
+        {
+            sName = xFormField->getParamValue(i);
+            OSL_TRACE("lcl_getFormFieldName: %s", rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            break;
+        }
+    }
+    return sName;
+}
+
+class FormFieldsEnumeration : public FormFiledEnumeration_BASE
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    XFormFieldVec mxFormFields;
+    XFormFieldVec::iterator cachePos;
+public:
+    FormFieldsEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const XFormFieldVec& xFormFiels ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ), mxFormFields( xFormFiels ), cachePos( mxFormFields.begin() )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return ( cachePos != mxFormFields.end() );
+    }
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+        uno::Reference< text::XFormField > xFormField( *cachePos++ );    
+		return uno::makeAny( uno::Reference< word::XFormField > ( new SwVbaFormField( mxParent, mxContext, mxModel, xFormField ) ) );
+	}
+
+};
+
+class FormFieldCollectionHelper : public FormFieldCollectionHelper_BASE
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    XFormFieldVec mxFormFields;
+    XFormFieldVec::iterator cachePos;
+public:
+    FormFieldCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( xModel,uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+        sal_Int32 nCount = xIndexAccess->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XFormField > xFormField( xIndexAccess->getByIndex( i ), uno::UNO_QUERY );
+            if( xFormField.is() )
+                mxFormFields.push_back( xFormField );
+        }
+        cachePos = mxFormFields.begin();
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  word::XFormField::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0 ; }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+        uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< word::XFormField >( new SwVbaFormField( mxParent, mxContext, mxModel, xFormField ) ) );
+    }
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+        uno::Sequence< rtl::OUString > sNames( mxFormFields.size() );
+        rtl::OUString* pString = sNames.getArray();
+        XFormFieldVec::iterator it = mxFormFields.begin();
+        XFormFieldVec::iterator it_end = mxFormFields.end();
+        for ( ; it != it_end; ++it, ++pString )
+        {
+            uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+            *pString =  lcl_getFormFieldName( xFormField );
+        }
+        return sNames;
+    }
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        cachePos = mxFormFields.begin();
+        XFormFieldVec::iterator it_end = mxFormFields.end();
+        for ( ; cachePos != it_end; ++cachePos )
+        {
+            //uno::Reference< container::XNamed > xName( *cachePos, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XFormField > xFormField( *cachePos, uno::UNO_QUERY_THROW );
+            if ( aName.equalsIgnoreAsciiCase( lcl_getFormFieldName( xFormField )) )
+                break;
+        }
+        return ( cachePos != it_end );
+    }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxFormFields.size();
+    }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+        if ( Index < 0 || Index >= getCount() )
+            throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( uno::Reference< word::XFormField >( new SwVbaFormField( mxParent, mxContext, mxModel, mxFormFields[ Index ] ) ) );
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new FormFieldsEnumeration( mxParent, mxContext, mxModel, mxFormFields );
+    }
+};
+
+SwVbaFormFields::SwVbaFormFields( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ): SwVbaFormFields_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new FormFieldCollectionHelper( xParent, xContext, xModel ) ) ), mxModel( xModel ) 
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaFormFields::getElementType() throw (uno::RuntimeException)
+{
+	return word::XFormField::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaFormFields::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return xEnumAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaFormFields::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaFormFields::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFormFields") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaFormFields::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.FormFields") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbaformfields.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaformfields.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FORMFIELDS_HXX
+#define SW_VBA_FORMFIELDS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XFormFields.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XFormFields > SwVbaFormFields_BASE;
+
+class SwVbaFormFields : public SwVbaFormFields_BASE
+{
+private:
+	css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaFormFields( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaFormFields() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaFormFields_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_FORMFIELDS_HXX */
--- sw/source/ui/vba/vbaframe.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaframe.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaframe.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaFrame::SwVbaFrame( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< frame::XModel >& rModel, const css::uno::Reference< text::XTextFrame >& xTextFrame ) throw ( css::uno::RuntimeException ) :
+    SwVbaFrame_BASE( rParent, rContext ), mxModel( rModel ), mxTextFrame( xTextFrame )
+{
+}
+
+SwVbaFrame::~SwVbaFrame()
+{
+}
+
+void SAL_CALL SwVbaFrame::Select() throw ( uno::RuntimeException )
+{
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( mxTextFrame ) );
+}
+
+rtl::OUString& 
+SwVbaFrame::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFrame") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaFrame::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Frame" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbaframe.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaframe.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FRAME_HXX
+#define SW_VBA_FRAME_HXX
+
+#include <ooo/vba/word/XFrame.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextFrame.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XFrame > SwVbaFrame_BASE;
+
+class SwVbaFrame : public SwVbaFrame_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextFrame > mxTextFrame;
+
+public:
+	SwVbaFrame( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const css::uno::Reference< css::text::XTextFrame >& xTextFrame ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFrame();
+
+   // Methods
+    virtual void SAL_CALL Select() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_FRAME_HXX */
--- sw/source/ui/vba/vbaframes.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaframes.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaframes.hxx"
+#include "vbaframe.hxx"
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include "wordvbahelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > FramesEnumeration_Base;
+class FramesEnumeration : public FramesEnumeration_Base 
+{
+private:
+	uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< container::XIndexAccess> mxIndexAccess;
+	uno::Reference< frame::XModel > mxModel;
+    sal_Int32 nCurrentPos;
+public:
+	FramesEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : mxParent( xParent ), mxContext( xContext), mxIndexAccess( xIndexAccess ), mxModel( xModel ), nCurrentPos(0)
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return ( nCurrentPos < mxIndexAccess->getCount() );
+    }
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+		uno::Reference< text::XTextFrame > xTextFrame( mxIndexAccess->getByIndex( nCurrentPos++ ), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< word::XFrame > ( new SwVbaFrame( mxParent, mxContext, mxModel, xTextFrame ) ) );
+	}
+
+};
+
+SwVbaFrames::SwVbaFrames( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xFrames, const uno::Reference< frame::XModel >& xModel ): SwVbaFrames_BASE( xParent, xContext, xFrames ), mxModel( xModel ) 
+{
+    mxFramesSupplier.set( mxModel, uno::UNO_QUERY_THROW );
+}
+// XEnumerationAccess
+uno::Type
+SwVbaFrames::getElementType() throw (uno::RuntimeException)
+{
+	return word::XFrame::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaFrames::createEnumeration() throw (uno::RuntimeException)
+{
+	return new FramesEnumeration( this, mxContext,m_xIndexAccess, mxModel );
+}
+
+uno::Any
+SwVbaFrames::createCollectionObject( const css::uno::Any& aSource )
+{
+	uno::Reference< text::XTextFrame > xTextFrame( aSource, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XFrame > ( new SwVbaFrame( this, mxContext, mxModel, xTextFrame ) ) );
+}
+
+rtl::OUString& 
+SwVbaFrames::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFrames") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaFrames::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Frames") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbaframes.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaframes.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FRAMES_HXX
+#define SW_VBA_FRAMES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XFrames.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextFramesSupplier.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XFrames > SwVbaFrames_BASE;
+
+class SwVbaFrames : public SwVbaFrames_BASE
+{
+private:
+	css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextFramesSupplier > mxFramesSupplier;
+
+public:
+	SwVbaFrames( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xFrames, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaFrames() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaFrames_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+};    
+
+#endif /* SW_VBA_FRAMES_HXX */
--- sw/source/ui/vba/vbaglobals.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaglobals.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -132,6 +132,12 @@ SwVbaGlobals::Dialogs( const uno::Any& i
     return getApplication()->Dialogs( index );
 }
 
+uno::Any SAL_CALL
+SwVbaGlobals::ListGalleries( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    return getApplication()->ListGalleries( index );
+}
+
 uno::Reference<word::XSelection > SAL_CALL
 SwVbaGlobals::getSelection() throw (uno::RuntimeException)
 {
--- sw/source/ui/vba/vbaglobals.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaglobals.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -72,6 +72,7 @@ public:
     virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL ListGalleries( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
     virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
     // XMultiServiceFactory
     virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getAvailableServiceNames(  ) throw (css::uno::RuntimeException);
--- sw/source/ui/vba/vbaheaderfooter.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaheaderfooter.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -84,6 +84,7 @@ uno::Reference< word::XRange > SAL_CALL
 uno::Any SAL_CALL
 SwVbaHeaderFooter::Shapes( const uno::Any& index ) throw (uno::RuntimeException)
 {
+    // #FIXME: only get the shapes in the current header/footer 
     uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
     //uno::Reference< drawing::XShapes > xShapes( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
     uno::Reference< container::XIndexAccess > xIndexAccess( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
--- sw/source/ui/vba/vbaheaderfooterhelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaheaderfooterhelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,8 +32,12 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/frame/XController.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/IllegalArgumentException.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -41,41 +45,61 @@ using namespace ::ooo::vba;
 #define FIRST_PAGE 1;
 
 // Class HeaderFooterHelper 
+sal_Bool HeaderFooterHelper::isHeaderFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    return isHeaderFooter( word::getCurrentXText( xModel ) );
+}
 
-sal_Bool HeaderFooterHelper::isHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isHeaderFooter( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
 {
-    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
-    
-    sal_Bool isOn = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isOn;
-    if( !isOn )
-        return sal_False;
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xText, uno::UNO_QUERY_THROW );
+    rtl::OUString aImplName = xServiceInfo->getImplementationName();
+    if( aImplName.equalsAscii("SwXHeadFootText") )
+        return sal_True;
+    return sal_False;     
+}
 
-    sal_Bool isShared = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared"))) >>= isShared;
+sal_Bool HeaderFooterHelper::isHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    const uno::Reference< text::XText > xCurrentText = word::getCurrentXText( xModel );
+    if( !isHeaderFooter( xCurrentText ) )
+        return sal_False;
 
+    rtl::OUString aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared") );
     rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderText") );
+    uno::Reference< style::XStyle > xPageStyle = word::getCurrentPageStyle( xModel );
+    uno::Reference< beans::XPropertySet > xPageProps( xPageStyle, uno::UNO_QUERY_THROW );
+    sal_Bool isShared = sal_True;
+    xPageProps->getPropertyValue( aPropIsShared ) >>= isShared;
     if( !isShared )
     {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         if( 0 == xPageCursor->getPage() % 2 )
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextLeft") );
-        }
         else
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextRight") );
-        }
     }
-    
-    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
-    //FIXME: can not compare in this way?
-    return ( xText == xCurrentText );
+
+    uno::Reference< text::XText > xHeaderText( xPageProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRangeCompare > xTRC( xHeaderText, uno::UNO_QUERY_THROW ); 
+    uno::Reference< text::XTextRange > xTR1( xCurrentText, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTR2( xHeaderText, uno::UNO_QUERY_THROW );
+    try
+    {
+        if( xTRC->compareRegionStarts( xTR1, xTR2 ) == 0 )
+            return sal_True;
+    }
+    catch( lang::IllegalArgumentException& )
+    {
+        return sal_False;
+    }
+
+    return sal_False;    
 }
 
-sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
         uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         // FIXME: getPage allways returns 1
@@ -85,9 +109,9 @@ sal_Bool HeaderFooterHelper::isFirstPage
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
         uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
         sal_Bool isShared = sal_False;
@@ -101,40 +125,47 @@ sal_Bool HeaderFooterHelper::isEvenPages
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
-    
-    sal_Bool isOn = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn"))) >>= isOn;
-    if( !isOn )
+    const uno::Reference< text::XText > xCurrentText = word::getCurrentXText( xModel );
+    if( !isHeaderFooter( xCurrentText ) )
         return sal_False;
 
-    sal_Bool isShared = sal_False;
-    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared"))) >>= isShared;
-
+    rtl::OUString aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared") );
     rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterText") );
+    uno::Reference< style::XStyle > xPageStyle = word::getCurrentPageStyle( xModel );
+    uno::Reference< beans::XPropertySet > xPageProps( xPageStyle, uno::UNO_QUERY_THROW );
+    sal_Bool isShared = sal_True;
+    xPageProps->getPropertyValue( aPropIsShared ) >>= isShared;
     if( !isShared )
     {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         if( 0 == xPageCursor->getPage() % 2 )
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextLeft") );
-        }
         else
-        {
             aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextRight") );
-        }
     }
-    
-    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
 
-    return ( xText == xCurrentText );
+    uno::Reference< text::XText > xFooterText( xPageProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRangeCompare > xTRC( xFooterText, uno::UNO_QUERY_THROW ); 
+    uno::Reference< text::XTextRange > xTR1( xCurrentText, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTR2( xFooterText, uno::UNO_QUERY_THROW );
+    try
+    {
+        if( xTRC->compareRegionStarts( xTR1, xTR2 ) == 0 )
+            return sal_True;
+    }
+    catch( lang::IllegalArgumentException& )
+    {
+        return sal_False;
+    }
+
+    return sal_False;    
 }
 
-sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isFooter( xModel, xCurrentText ) )
+    if( isFooter( xModel ) )
     {
         uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
         sal_Int32 nPage = xPageCursor->getPage();
@@ -143,9 +174,9 @@ sal_Bool HeaderFooterHelper::isFirstPage
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isFooter( xModel, xCurrentText ) )
+    if( isFooter( xModel ) )
     {
         uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
         sal_Bool isShared = sal_False;
@@ -159,20 +190,20 @@ sal_Bool HeaderFooterHelper::isEvenPages
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isPrimaryHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isPrimaryHeader( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
-        return( !( isFirstPageHeader( xModel, xCurrentText ) && isEvenPagesHeader( xModel, xCurrentText ) ) );
+        return( !( isFirstPageHeader( xModel ) && isEvenPagesHeader( xModel ) ) );
     }
     return sal_False;
 }
 
-sal_Bool HeaderFooterHelper::isPrimaryFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+sal_Bool HeaderFooterHelper::isPrimaryFooter( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
-    if( isHeader( xModel, xCurrentText ) )
+    if( isHeader( xModel ) )
     {
-        return( !( isFirstPageFooter( xModel, xCurrentText ) && isEvenPagesFooter( xModel, xCurrentText ) ) );
+        return( !( isFirstPageFooter( xModel ) && isEvenPagesFooter( xModel ) ) );
     }
     return sal_False;
 }
--- sw/source/ui/vba/vbaheaderfooterhelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaheaderfooterhelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -39,14 +39,16 @@
 class HeaderFooterHelper
 {
 public:
-    static sal_Bool isHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFirstPageHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isEvenPagesHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isFirstPageFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isEvenPagesFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isPrimaryHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
-    static sal_Bool isPrimaryFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeaderFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeaderFooter( const css::uno::Reference< css::text::XText >& xText ) throw (css::uno::RuntimeException);
+    static sal_Bool isHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryHeader( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryFooter( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
 };
 
 #endif
--- sw/source/ui/vba/vbaheadersfooters.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaheadersfooters.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,150 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaheadersfooters.hxx"
+#include "vbaheaderfooter.hxx"
+#include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// I assume there is only one headersfooters in Writer
+typedef ::cppu::WeakImplHelper1<container::XIndexAccess > HeadersFootersIndexAccess_Base;
+class HeadersFootersIndexAccess : public HeadersFootersIndexAccess_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    uno::Reference< beans::XPropertySet > mxPageStyleProps;
+    sal_Bool mbHeader;
+
+public:
+    HeadersFootersIndexAccess( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xPageStyleProps, sal_Bool bHeader ) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ), mxPageStyleProps( xPageStyleProps ), mbHeader( bHeader ) {}
+    ~HeadersFootersIndexAccess(){}
+
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        // first page, evenpages and primary page
+        return 3;
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if( Index < 1 || Index > 3 )
+            throw container::NoSuchElementException();
+        return uno::makeAny( uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( mxParent,  mxContext, mxModel, mxPageStyleProps, mbHeader, Index ) ) );    
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XHeaderFooter::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+};
+
+class HeadersFootersEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaHeadersFooters* pHeadersFooters;
+	sal_Int32 nIndex;
+public:
+	HeadersFootersEnumWrapper( SwVbaHeadersFooters* _pHeadersFooters ) : pHeadersFooters( _pHeadersFooters ), nIndex( 0 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < pHeadersFooters->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex < pHeadersFooters->getCount() )
+			return pHeadersFooters->Item( uno::makeAny( ++nIndex ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaHeadersFooters::SwVbaHeadersFooters( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xPageStyleProps, sal_Bool isHeader ): SwVbaHeadersFooters_BASE( xParent, xContext, new HeadersFootersIndexAccess( xParent, xContext, xModel, xPageStyleProps, isHeader ) ),  mxModel( xModel ), mxPageStyleProps( xPageStyleProps ), mbHeader( isHeader )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaHeadersFooters::getCount() throw (uno::RuntimeException)
+{
+    // wdHeaderFooterFirstPage, wdHeaderFooterPrimary and wdHeaderFooterEvenPages
+    return 3;
+}
+
+uno::Any SAL_CALL SwVbaHeadersFooters::Item( const uno::Any& Index1, const uno::Any& ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    Index1 >>= nIndex;
+    if( ( nIndex < 1 ) || ( nIndex > 3 ) )
+    {
+        throw container::NoSuchElementException();
+    }
+    return uno::makeAny( uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( this,  mxContext, mxModel, mxPageStyleProps, mbHeader, nIndex ) ) );    
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaHeadersFooters::getElementType() throw (uno::RuntimeException)
+{
+	return word::XHeaderFooter::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+
+SwVbaHeadersFooters::createEnumeration() throw (uno::RuntimeException)
+{
+    return new HeadersFootersEnumWrapper( this );
+}
+
+uno::Any
+SwVbaHeadersFooters::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaHeadersFooters::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaHeadersFooters") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaHeadersFooters::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.HeadersFooters") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbaheadersfooters.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbaheadersfooters.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_HEADERSFOOTERS_HXX
+#define SW_VBA_HEADERSFOOTERS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XHeadersFooters.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XHeadersFooters > SwVbaHeadersFooters_BASE;
+
+class SwVbaHeadersFooters : public SwVbaHeadersFooters_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxPageStyleProps;
+    sal_Bool mbHeader;
+
+public:
+	SwVbaHeadersFooters( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps, sal_Bool isHeader );
+	virtual ~SwVbaHeadersFooters() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& )throw (css::uno::RuntimeException);
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaHeadersFooters_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_HEADERSFOOTERS_HXX */
--- sw/source/ui/vba/vbalistformat.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistformat.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistformat.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdListApplyTo.hpp>
+#include <ooo/vba/word/WdDefaultListBehavior.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XEnumeration.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include "vbalisttemplate.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListFormat::SwVbaListFormat( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextRange >& xTextRange ) throw ( uno::RuntimeException ) : SwVbaListFormat_BASE( rParent, rContext ), mxTextRange( xTextRange )
+{
+}
+
+SwVbaListFormat::~SwVbaListFormat()
+{
+}
+
+void SAL_CALL SwVbaListFormat::ApplyListTemplate( const css::uno::Reference< word::XListTemplate >& ListTemplate, const css::uno::Any& ContinuePreviousList, const css::uno::Any& ApplyTo, const css::uno::Any& DefaultListBehavior ) throw (css::uno::RuntimeException)
+{
+    sal_Bool bContinuePreviousList = sal_True;
+    if( ContinuePreviousList.hasValue() )
+        ContinuePreviousList >>= bContinuePreviousList;
+    
+    // "applyto" must be current selection
+    sal_Int32 bApplyTo = word::WdListApplyTo::wdListApplyToSelection;
+    if( ApplyTo.hasValue() )
+        ApplyTo >>= bApplyTo;
+    if( bApplyTo != word::WdListApplyTo::wdListApplyToSelection )
+        throw uno::RuntimeException();
+
+    // default behaviour must be wdWord8ListBehavior
+    sal_Int32 nDefaultListBehavior = word::WdDefaultListBehavior::wdWord8ListBehavior;
+    if( DefaultListBehavior.hasValue() )
+        DefaultListBehavior >>= nDefaultListBehavior;
+    if( nDefaultListBehavior != word::WdDefaultListBehavior::wdWord8ListBehavior )
+        throw uno::RuntimeException();
+    
+    SwVbaListTemplate* pListTemplate = dynamic_cast< SwVbaListTemplate* >( ListTemplate.get() );
+
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( mxTextRange, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration > xEnum = xEnumAccess->createEnumeration();
+    sal_Bool isFirstElement = sal_True;
+    while( xEnum->hasMoreElements() )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xEnum->nextElement(), uno::UNO_QUERY_THROW );
+        if( isFirstElement )
+        {
+            sal_Bool isNumberingRestart = !bContinuePreviousList;
+            xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsNumberingRestart") ), uno::makeAny( isNumberingRestart ) );
+            if( isNumberingRestart )
+            {
+                sal_Int16 nStartValue = 1;
+                xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStartValue") ), uno::makeAny( nStartValue ) );
+            }
+            isFirstElement = sal_False;
+        }
+        else
+        {
+            xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsNumberingRestart") ), uno::makeAny( sal_False ) );
+        }
+        pListTemplate->applyListTemplate( xProps );
+    }
+}
+
+void SAL_CALL SwVbaListFormat::ConvertNumbersToText(  ) throw (css::uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+rtl::OUString& 
+SwVbaListFormat::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListFormat") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListFormat::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListFormat" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbalistformat.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistformat.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTFORMAT_HXX
+#define SW_VBA_LISTFORMAT_HXX
+
+#include <ooo/vba/word/XListFormat.hpp>
+#include <ooo/vba/word/XListTemplate.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListFormat > SwVbaListFormat_BASE;
+
+class SwVbaListFormat : public SwVbaListFormat_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextRange > mxTextRange;
+
+public:
+	SwVbaListFormat( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListFormat();
+
+    // Methods
+    virtual void SAL_CALL ApplyListTemplate( const css::uno::Reference< ::ooo::vba::word::XListTemplate >& ListTemplate, const css::uno::Any& ContinuePreviousList, const css::uno::Any& ApplyTo, const css::uno::Any& DefaultListBehavior ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ConvertNumbersToText(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTFORMAT_HXX */
--- sw/source/ui/vba/vbalistgalleries.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistgalleries.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,115 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistgalleries.hxx"
+#include "vbalistgallery.hxx"
+#include <ooo/vba/word/WdListGalleryType.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListGalleriesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListGalleries* pListGalleries;
+	sal_Int32 nIndex;
+public:
+	ListGalleriesEnumWrapper( SwVbaListGalleries* pGalleries ) : pListGalleries( pGalleries ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListGalleries->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListGalleries->getCount() )
+			return pListGalleries->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListGalleries::SwVbaListGalleries( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xTextDoc ) throw (uno::RuntimeException) : SwVbaListGalleries_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ),  mxTextDocument( xTextDoc )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListGalleries::getCount() throw (uno::RuntimeException)
+{
+    // 3 types of list( bullet, numbered and outline )
+    return 3;
+}
+
+uno::Any SAL_CALL SwVbaListGalleries::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex == word::WdListGalleryType::wdBulletGallery
+            || nIndex == word::WdListGalleryType::wdNumberGallery
+            || nIndex == word::WdListGalleryType::wdOutlineNumberGallery )
+            return uno::makeAny( uno::Reference< word::XListGallery >( new SwVbaListGallery( this, mxContext, mxTextDocument, nIndex ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListGalleries::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListGallery::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListGalleries::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListGalleriesEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListGalleries::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListGalleries::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListGalleries") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListGalleries::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListGalleries") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbalistgalleries.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistgalleries.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTGALLERIES_HXX
+#define SW_VBA_LISTGALLERIES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListGalleries.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XListGalleries > SwVbaListGalleries_BASE;
+
+class SwVbaListGalleries : public SwVbaListGalleries_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+
+public:
+	SwVbaListGalleries( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaListGalleries() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListGalleries_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTGALLERIES_HXX */
--- sw/source/ui/vba/vbalistgallery.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistgallery.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistgallery.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbalisttemplates.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListGallery::SwVbaListGallery( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw ( uno::RuntimeException ) : SwVbaListGallery_BASE( rParent, rContext ), mxTextDocument( xTextDoc ), mnType( nType )
+{
+}
+
+SwVbaListGallery::~SwVbaListGallery()
+{
+}
+
+uno::Any SAL_CALL
+SwVbaListGallery::ListTemplates( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaListTemplates( mxParent, mxContext, mxTextDocument, mnType ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+rtl::OUString& 
+SwVbaListGallery::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListGallery") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListGallery::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListGallery" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbalistgallery.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistgallery.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTGALLERY_HXX
+#define SW_VBA_LISTGALLERY_HXX
+
+#include <ooo/vba/word/XListGallery.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListGallery > SwVbaListGallery_BASE;
+
+class SwVbaListGallery : public SwVbaListGallery_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    sal_Int32 mnType;
+
+public:
+	SwVbaListGallery( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListGallery();
+
+    // Methods
+    virtual css::uno::Any SAL_CALL ListTemplates( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTGALLERY_HXX */
--- sw/source/ui/vba/vbalisthelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisthelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,707 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisthelper.hxx"
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdListGalleryType.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <com/sun/star/container/XIndexReplace.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const sal_Int32 LIST_LEVEL_COUNT = 9;
+
+static const char WORD_BULLET_GALLERY[] = "WdBullet";
+static const char WORD_NUMBER_GALLERY[] = "WdNumber";
+static const char WORD_OUTLINE_NUMBER_GALLERY[] = "WdOutlineNumber";
+
+static const char UNO_NAME_ADJUST[] = "Adjust";
+static const char UNO_NAME_PARENT_NUMBERING[] = "ParentNumbering";
+static const char UNO_NAME_PREFIX[] = "Prefix";
+static const char UNO_NAME_SUFFIX[] = "Suffix";
+static const char UNO_NAME_CHAR_STYLE_NAME[] = "CharStyleName";
+static const char UNO_NAME_START_WITH[] = "StartWith";
+static const char UNO_NAME_POSITION_AND_SPACE_MODE[] = "PositionAndSpaceMode";
+static const char UNO_NAME_LABEL_FOLLOWED_BY[] = "LabelFollowedBy";
+static const char UNO_NAME_LIST_TAB_STOP_POSITION[] = "ListtabStopPosition";
+static const char UNO_NAME_FIRST_LINE_INDENT[] = "FirstLineIndent";
+static const char UNO_NAME_INDENT_AT[] = "IndentAt";
+static const char UNO_NAME_NUMBERING_TYPE[] = "NumberingType";
+static const char UNO_NAME_BULLET_ID[] = "BulletId";
+static const char UNO_NAME_BULLET_CHAR[] = "BulletChar";
+static const char UNO_NAME_BULLET_FONT_NAME[] = "BulletFontName";
+static const char UNO_NAME_BULLET_FONT[] = "BulletFont";
+
+static const sal_Int16 CHAR_CLOSED_DOT = 8226;
+static const sal_Int16 CHAR_EMPTY_DOT = 111;
+static const sal_Int16 CHAR_SQUARE = 9632;
+static const sal_Int16 CHAR_STAR_SYMBOL = 10026;
+static const sal_Int16 CHAR_FOUR_DIAMONDS = 10070;
+static const sal_Int16 CHAR_DIAMOND = 10022;
+static const sal_Int16 CHAR_ARROW = 10146;
+static const sal_Int16 CHAR_CHECK_MARK = 10003;
+
+SwVbaListHelper::SwVbaListHelper( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw( css::uno::RuntimeException ) : mxTextDocument( xTextDoc ), mnGalleryType( nGalleryType ), mnTemplateType( nTemplateType )
+{
+    Init();
+}
+
+void SwVbaListHelper::Init() throw( css::uno::RuntimeException )
+{
+    // set the numbering style name
+    switch( mnGalleryType )
+    {
+        case word::WdListGalleryType::wdBulletGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_BULLET_GALLERY );
+            break;
+        }
+        case word::WdListGalleryType::wdNumberGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_NUMBER_GALLERY );
+            break;
+        }
+        case word::WdListGalleryType::wdOutlineNumberGallery:
+        {
+            msStyleName = rtl::OUString::createFromAscii( WORD_OUTLINE_NUMBER_GALLERY );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    msStyleName += rtl::OUString::valueOf( mnTemplateType );
+
+    // get the numbering style 
+    uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+    mxStyleFamily.set( xStyleSupplier->getStyleFamilies()->getByName(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") ) ), uno::UNO_QUERY_THROW );
+    OSL_TRACE("SwVbaListHelper::Init: numbering style name: %s", rtl::OUStringToOString( msStyleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( mxStyleFamily->hasByName( msStyleName ) )
+    {
+        mxStyleProps.set( mxStyleFamily->getByName( msStyleName ), uno::UNO_QUERY_THROW );
+        mxNumberingRules.set( mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) ), uno::UNO_QUERY_THROW );
+    }    
+    else
+    {
+        // create new numbering style
+        uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxTextDocument, uno::UNO_QUERY_THROW );
+        mxStyleProps.set( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.NumberingStyle") ) ), uno::UNO_QUERY_THROW );
+        // insert this style into style family, or the property NumberingRules doesn't exist.
+        mxStyleFamily->insertByName( msStyleName, uno::makeAny( mxStyleProps ) );
+        mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) ) >>= mxNumberingRules;
+        //mxNumberingRules.set( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingRules") ) ), uno::UNO_QUERY_THROW );
+
+        CreateListTemplate();
+
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( mxNumberingRules ) );
+    }
+}
+
+void SwVbaListHelper::CreateListTemplate() throw( css::uno::RuntimeException )
+{
+    switch( mnGalleryType )
+    {
+        case word::WdListGalleryType::wdBulletGallery:
+        {
+            CreateBulletListTemplate();
+            break;
+        }
+        case word::WdListGalleryType::wdNumberGallery:
+        {
+            CreateNumberListTemplate();
+            break;
+        }
+        case word::WdListGalleryType::wdOutlineNumberGallery:
+        {
+            CreateOutlineNumberListTemplate();
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+}
+
+void SwVbaListHelper::CreateBulletListTemplate() throw( css::uno::RuntimeException )
+{
+    // there is only 1 level for each bullet list in MSWord
+    sal_Int32 nLevel = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    rtl::OUString sCharStyleName( RTL_CONSTASCII_USTRINGPARAM("Bullet Symbols") );
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_CHAR_STYLE_NAME ), uno::makeAny( sCharStyleName ) );
+    sal_Int16 nNumberingType = style::NumberingType::CHAR_SPECIAL;
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+
+    rtl::OUString aBulletChar;
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_CLOSED_DOT ) );
+            break;
+        }
+        case 2:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_EMPTY_DOT ) );
+            break;
+        }
+        case 3:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_SQUARE ) );
+            break;
+        }
+        case 4:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_STAR_SYMBOL ) );
+            break;
+        }
+        case 5:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_FOUR_DIAMONDS ) );
+            break;
+        }
+        case 6:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_ARROW ) );
+            break;
+        }
+        case 7:
+        {
+            aBulletChar = rtl::OUString( sal_Unicode( CHAR_CHECK_MARK ) );
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_BULLET_CHAR ), uno::makeAny( aBulletChar ) );
+
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+}
+
+void SwVbaListHelper::CreateNumberListTemplate() throw( css::uno::RuntimeException )
+{
+    // there is only 1 level for each bullet list in MSWord
+    sal_Int32 nLevel = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sSuffix;
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 2:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+            break;
+        }
+        case 3:
+        {
+            nNumberingType = style::NumberingType::ROMAN_UPPER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 4:
+        {
+            nNumberingType = style::NumberingType::CHARS_UPPER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 5:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+            break;
+        }
+        case 6:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        case 7:
+        {
+            nNumberingType = style::NumberingType::ROMAN_LOWER;
+            sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+    setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+}
+
+void SwVbaListHelper::CreateOutlineNumberListTemplate() throw( css::uno::RuntimeException )
+{
+    switch( mnTemplateType )
+    {
+        case 1:
+        {
+            CreateOutlineNumberForType1();
+            break;
+        }
+        case 2:
+        {
+            CreateOutlineNumberForType2();
+            break;
+        }
+        case 3:
+        {
+            CreateOutlineNumberForType3();
+            break;
+        }
+        case 4:
+        {
+            CreateOutlineNumberForType4();
+            break;
+        }
+        case 5:
+        {
+            CreateOutlineNumberForType5();
+            break;
+        }
+        case 6:
+        {
+            CreateOutlineNumberForType6();
+            break;
+        }
+        case 7:
+        {
+            CreateOutlineNumberForType7();
+            break;
+        }
+        default:
+        {
+            // we only support 7 types template now
+            throw css::uno::RuntimeException();
+        }
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType1() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            case 1:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType2() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    sal_Int16 nParentNumbering = 0;
+    rtl::OUString sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        if( nLevel != 0 )
+        {
+            nParentNumbering = sal_Int16( nLevel - 1 );
+            setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+        }
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType3() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::CHAR_SPECIAL;
+    rtl::OUString sCharStyleName( RTL_CONSTASCII_USTRINGPARAM("Bullet Symbols") );
+    rtl::OUString aBulletChar;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_CHAR_STYLE_NAME ), uno::makeAny( sCharStyleName ) );
+        switch( nLevel )
+        {
+            case 0:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_FOUR_DIAMONDS ) );
+                break;
+            }
+            case 1:
+            case 5:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_ARROW ) );
+                break;
+            }
+            case 2:
+            case 6:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_SQUARE ) );
+                break;
+            }
+            case 3:
+            case 7:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_CLOSED_DOT ) );
+                break;
+            }
+            case 4:
+            case 8:
+            {
+                aBulletChar = rtl::OUString( sal_Unicode( CHAR_DIAMOND ) );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_BULLET_CHAR ), uno::makeAny( aBulletChar ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType4() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            {
+                nNumberingType = style::NumberingType::ROMAN_UPPER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 1:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                sal_Int16 nParentNumbering = 0;
+                setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType5() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    sal_Int16 nParentNumbering = 0;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        if( nLevel != 0 )
+        {
+            nParentNumbering = sal_Int16( nLevel - 1 );
+            setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PARENT_NUMBERING ), uno::makeAny( nParentNumbering ) );
+        }
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType6() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = 0;
+    rtl::OUString sPrefix;
+    rtl::OUString sSuffix;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        switch( nLevel )
+        {
+            case 0:
+            {
+                nNumberingType = style::NumberingType::ROMAN_UPPER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 1:
+            {
+                nNumberingType = style::NumberingType::CHARS_UPPER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 2:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 3:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString();
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 4:
+            {
+                nNumberingType = style::NumberingType::ARABIC;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 5:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 6:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode(')') );
+                break;
+            }
+            case 7:
+            {
+                nNumberingType = style::NumberingType::CHARS_LOWER_LETTER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            case 8:
+            {
+                nNumberingType = style::NumberingType::ROMAN_LOWER;
+                sPrefix = rtl::OUString::valueOf( sal_Unicode('(') );
+                sSuffix = rtl::OUString::valueOf( sal_Unicode('.') );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException();
+            }
+        }
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_SUFFIX ), uno::makeAny( sSuffix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }
+}
+
+void SwVbaListHelper::CreateOutlineNumberForType7() throw( css::uno::RuntimeException )
+{
+    sal_Int16 nNumberingType = style::NumberingType::ARABIC;
+    uno::Sequence< beans::PropertyValue > aPropertyValues;
+    rtl::OUString sPrefix = rtl::OUString::createFromAscii("Chapter ");
+
+    for( sal_Int32 nLevel = 0; nLevel < LIST_LEVEL_COUNT; nLevel++ )
+    {
+        mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_NUMBERING_TYPE ), uno::makeAny( nNumberingType ) );
+        setOrAppendPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( UNO_NAME_PREFIX ), uno::makeAny( sPrefix ) );
+        mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    }    
+}
+
+uno::Any SwVbaListHelper::getPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName ) throw( css::uno::RuntimeException )
+{
+    uno::Sequence< beans::PropertyValue > aPropertyValues;   
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    return getPropertyValue( aPropertyValues, sName );
+}
+
+void SwVbaListHelper::setPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName, const css::uno::Any& aValue ) throw( css::uno::RuntimeException )
+{
+    uno::Sequence< beans::PropertyValue > aPropertyValues;   
+    mxNumberingRules->getByIndex( nLevel ) >>= aPropertyValues;
+    setOrAppendPropertyValue( aPropertyValues, sName, aValue );
+    mxNumberingRules->replaceByIndex( nLevel, uno::makeAny( aPropertyValues ) );
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( mxNumberingRules ) );
+}
+
--- sw/source/ui/vba/vbalisthelper.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisthelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTHELPER_HXX
+#define SW_VBA_LISTHELPER_HXX
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/container/XIndexReplace.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <boost/shared_ptr.hpp>
+
+
+class SwVbaListHelper;
+typedef ::boost::shared_ptr< SwVbaListHelper > SwVbaListHelperRef;
+
+class SwVbaListHelper
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::container::XIndexReplace > mxNumberingRules;
+    css::uno::Reference< css::container::XNameContainer > mxStyleFamily;
+    css::uno::Reference< css::beans::XPropertySet > mxStyleProps;
+    sal_Int32 mnGalleryType;
+    sal_Int32 mnTemplateType;
+    rtl::OUString msStyleName;
+
+    void Init() throw( css::uno::RuntimeException );
+    void CreateListTemplate() throw( css::uno::RuntimeException );
+    void CreateBulletListTemplate() throw( css::uno::RuntimeException );
+    void CreateNumberListTemplate() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberListTemplate() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType1() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType2() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType3() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType4() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType5() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType6() throw( css::uno::RuntimeException );
+    void CreateOutlineNumberForType7() throw( css::uno::RuntimeException );
+
+public:
+    SwVbaListHelper( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw( css::uno::RuntimeException );
+
+    sal_Int32 getGalleryType() { return mnGalleryType; }
+    css::uno::Reference< css::container::XIndexReplace > getNumberingRules() { return mxNumberingRules; }
+    css::uno::Any getPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName ) throw( css::uno::RuntimeException );
+    void setPropertyValueWithNameAndLevel( sal_Int32 nLevel, const rtl::OUString& sName, const css::uno::Any& aValue ) throw( css::uno::RuntimeException );
+
+};
+
+#endif//SW_VBA_LISTHELPER_HXX
--- sw/source/ui/vba/vbalistlevel.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistlevel.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,401 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistlevel.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/style/NumberingType.hpp>
+#include <ooo/vba/word/WdListNumberStyle.hpp>
+#include <ooo/vba/word/WdTrailingCharacter.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <ooo/vba/word/WdListLevelAlignment.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListLevel::SwVbaListLevel( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper, sal_Int32 nLevel ) throw ( uno::RuntimeException ) : SwVbaListLevel_BASE( rParent, rContext ), pListHelper( pHelper ), mnLevel( nLevel )
+{
+}
+
+SwVbaListLevel::~SwVbaListLevel()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getAlignment() throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Adjust") ) ) >>= nAlignment;
+    switch( nAlignment )
+    {
+        case text::HoriOrientation::LEFT:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignLeft;
+            break;
+        }
+        case text::HoriOrientation::RIGHT:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignRight;
+            break;
+        }
+        case text::HoriOrientation::CENTER:
+        {
+            nAlignment = word::WdListLevelAlignment::wdListLevelAlignCenter;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    return nAlignment;
+}
+
+void SAL_CALL SwVbaListLevel::setAlignment( ::sal_Int32 _alignment ) throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    switch( _alignment )
+    {
+        case word::WdListLevelAlignment::wdListLevelAlignLeft:
+        {
+            nAlignment = text::HoriOrientation::LEFT;
+            break;
+        }
+        case word::WdListLevelAlignment::wdListLevelAlignRight:
+        {
+            nAlignment = text::HoriOrientation::RIGHT;
+            break;
+        }
+        case word::WdListLevelAlignment::wdListLevelAlignCenter:
+        {
+            nAlignment = text::HoriOrientation::CENTER;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException();
+        }
+    }
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Adjust") ), uno::makeAny( nAlignment ) );
+}
+
+uno::Reference< ::ooo::vba::word::XFont > SAL_CALL SwVbaListLevel::getFont() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return uno::Reference< word::XFont >();
+}
+
+void SAL_CALL SwVbaListLevel::setFont( const uno::Reference< ::ooo::vba::word::XFont >& /*_font*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getIndex() throw (uno::RuntimeException)
+{
+    return mnLevel + 1;
+}
+
+::rtl::OUString SAL_CALL SwVbaListLevel::getLinkedStyle() throw (uno::RuntimeException)
+{
+    // TODO: 
+    return rtl::OUString();
+}
+
+void SAL_CALL SwVbaListLevel::setLinkedStyle( const ::rtl::OUString& _linkedstyle ) throw (uno::RuntimeException)
+{
+    // TODO: 
+}
+
+::rtl::OUString SAL_CALL SwVbaListLevel::getNumberFormat() throw (uno::RuntimeException)
+{
+    // TODO::
+    return rtl::OUString();
+}
+
+void SAL_CALL SwVbaListLevel::setNumberFormat( const ::rtl::OUString& _numberformat ) throw (uno::RuntimeException)
+{
+    // TODO::
+}
+
+float SAL_CALL SwVbaListLevel::getNumberPosition() throw (uno::RuntimeException)
+{
+    // indentAt + firstlineindent
+    sal_Int32 nIndentAt = 0;
+    sal_Int32 nFirstLineIndent = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ) ) >>= nFirstLineIndent;
+
+    sal_Int32 nResult = nIndentAt + nFirstLineIndent;
+
+    return static_cast< float >( Millimeter::getInPoints( nResult ) );
+}
+
+void SAL_CALL SwVbaListLevel::setNumberPosition( float _numberposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nNumberPosition = Millimeter::getInHundredthsOfOneMillimeter( _numberposition );
+
+    sal_Int32 nIndentAt = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+
+    sal_Int32 nFirstLineIndent = nNumberPosition - nIndentAt;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ), uno::makeAny( nFirstLineIndent ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getNumberStyle() throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingType = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingType") ) ) >>= nNumberingType;
+    switch( nNumberingType )
+    {
+        case style::NumberingType::CHAR_SPECIAL:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleBullet;
+            break;
+        }
+        case style::NumberingType::CHARS_UPPER_LETTER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleUppercaseLetter;
+            break;
+        }
+        case style::NumberingType::CHARS_LOWER_LETTER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleLowercaseLetter;
+            break;
+        }
+        case style::NumberingType::ROMAN_UPPER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleUppercaseRoman;
+            break;
+        }
+        case style::NumberingType::ROMAN_LOWER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleLowercaseRoman;
+            break;
+        }
+        case style::NumberingType::ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleArabic;
+            break;
+        }
+        case style::NumberingType::NUMBER_NONE:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleNone;
+            break;
+        }
+        case style::NumberingType::FULLWIDTH_ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleArabicFullWidth;
+            break;
+        }
+        case style::NumberingType::CIRCLE_NUMBER:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleNumberInCircle;
+            break;
+        }
+        case style::NumberingType::CHARS_ARABIC:
+        {
+            nNumberingType = word::WdListNumberStyle::wdListNumberStyleCardinalText;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+        }
+    }
+    return nNumberingType;
+}
+
+void SAL_CALL SwVbaListLevel::setNumberStyle( ::sal_Int32 _numberstyle ) throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingType = 0;
+    switch( _numberstyle )
+    {
+        case word::WdListNumberStyle::wdListNumberStyleBullet:
+        {
+            nNumberingType = style::NumberingType::CHAR_SPECIAL;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleUppercaseLetter:
+        {
+            nNumberingType = style::NumberingType::CHARS_UPPER_LETTER_N;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleLowercaseLetter:
+        {
+            nNumberingType = style::NumberingType::CHARS_LOWER_LETTER_N;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleUppercaseRoman:
+        {
+            nNumberingType = style::NumberingType::ROMAN_UPPER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleLowercaseRoman:
+        {
+            nNumberingType = style::NumberingType::ROMAN_LOWER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleArabic:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleNone:
+        {
+            nNumberingType = style::NumberingType::NUMBER_NONE;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleArabicFullWidth:
+        {
+            nNumberingType = style::NumberingType::FULLWIDTH_ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleNumberInCircle:
+        {
+            nNumberingType = style::NumberingType::CIRCLE_NUMBER;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleCardinalText:
+        {
+            nNumberingType = style::NumberingType::CHARS_ARABIC;
+            break;
+        }
+        case word::WdListNumberStyle::wdListNumberStyleOrdinal:
+        case word::WdListNumberStyle::wdListNumberStyleOrdinalText:
+        case word::WdListNumberStyle::wdListNumberStyleKanji:
+        case word::WdListNumberStyle::wdListNumberStyleKanjiDigit:
+        case word::WdListNumberStyle::wdListNumberStyleAiueoHalfWidth:
+        case word::WdListNumberStyle::wdListNumberStyleIrohaHalfWidth:
+        {
+            nNumberingType = style::NumberingType::ARABIC;
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+        }
+    }
+
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingType") ), uno::makeAny( nNumberingType ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getResetOnHigher() throw (uno::RuntimeException)
+{
+    //seems not support?
+    return 0;
+}
+
+void SAL_CALL SwVbaListLevel::setResetOnHigher( ::sal_Int32 _resetonhigher ) throw (uno::RuntimeException)
+{
+    //seems not support?
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getStartAt() throw (uno::RuntimeException)
+{
+    sal_Int16 nStartWith = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("StartWith") ) ) >>= nStartWith;
+    return nStartWith;
+}
+
+void SAL_CALL SwVbaListLevel::setStartAt( ::sal_Int32 _startat ) throw (uno::RuntimeException)
+{
+    sal_Int16 nStartWith = (sal_Int16)_startat;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("StartWith") ), uno::makeAny( nStartWith ) );
+}
+
+float SAL_CALL SwVbaListLevel::getTabPosition() throw (uno::RuntimeException)
+{
+    sal_Int32 nTabPosition = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition") ) ) >>= nTabPosition;
+
+    return static_cast< float >( Millimeter::getInPoints( nTabPosition ) );
+}
+
+void SAL_CALL SwVbaListLevel::setTabPosition( float _tabposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nTabPosition = Millimeter::getInHundredthsOfOneMillimeter( _tabposition );
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ListtabStopPosition") ), uno::makeAny( nTabPosition ) );
+}
+
+float SAL_CALL SwVbaListLevel::getTextPosition() throw (uno::RuntimeException)
+{
+    // indentAt
+    sal_Int32 nIndentAt = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+
+    return static_cast< float >( Millimeter::getInPoints( nIndentAt ) );
+}
+
+void SAL_CALL SwVbaListLevel::setTextPosition( float _textposition ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndentAt = 0;
+    sal_Int32 nFirstLineIndent = 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ) ) >>= nIndentAt;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ) ) >>= nFirstLineIndent;
+
+    sal_Int32 nAlignedAt = nIndentAt + nFirstLineIndent;
+
+    nIndentAt = Millimeter::getInHundredthsOfOneMillimeter( _textposition );
+    nFirstLineIndent = nAlignedAt - nIndentAt;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IndentAt") ), uno::makeAny( nIndentAt ) );
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FirstLineIndent") ), uno::makeAny( nFirstLineIndent ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevel::getTrailingCharacter() throw (uno::RuntimeException)
+{
+    sal_Int16 nLabelFollowedBy= 0;
+    pListHelper->getPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LabelFollowedBy") ) ) >>= nLabelFollowedBy;
+
+    return nLabelFollowedBy;
+}
+
+void SAL_CALL SwVbaListLevel::setTrailingCharacter( ::sal_Int32 _trailingcharacter ) throw (uno::RuntimeException)
+{
+    sal_Int16 nLabelFollowedBy = (sal_Int16)_trailingcharacter;
+    pListHelper->setPropertyValueWithNameAndLevel( mnLevel, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LabelFollowedBy") ), uno::makeAny( nLabelFollowedBy ) );
+}
+
+rtl::OUString& 
+SwVbaListLevel::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListLevel") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListLevel::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListLevel" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbalistlevel.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistlevel.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTLEVEL_HXX
+#define SW_VBA_LISTLEVEL_HXX
+
+#include <ooo/vba/word/XListLevel.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListLevel > SwVbaListLevel_BASE;
+
+class SwVbaListLevel : public SwVbaListLevel_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+    sal_Int32 mnLevel;
+
+public:
+	SwVbaListLevel( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper, sal_Int32 nLevel ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListLevel();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getAlignment() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAlignment( ::sal_Int32 _alignment ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFont( const css::uno::Reference< ::ooo::vba::word::XFont >& _font ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getIndex() throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getLinkedStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLinkedStyle( const ::rtl::OUString& _linkedstyle ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getNumberFormat() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberFormat( const ::rtl::OUString& _numberformat ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getNumberPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberPosition( float _numberposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getNumberStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNumberStyle( ::sal_Int32 _numberstyle ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getResetOnHigher() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setResetOnHigher( ::sal_Int32 _resetonhigher ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getStartAt() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStartAt( ::sal_Int32 _startat ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getTabPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTabPosition( float _tabposition ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getTextPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTextPosition( float _textposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getTrailingCharacter() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTrailingCharacter( ::sal_Int32 _trailingcharacter ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTLEVEL_HXX */
--- sw/source/ui/vba/vbalistlevels.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistlevels.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalistlevels.hxx"
+#include "vbalistlevel.hxx"
+#include <ooo/vba/word/WdListGalleryType.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListLevelsEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListLevels* pListLevels;
+	sal_Int32 nIndex;
+public:
+	ListLevelsEnumWrapper( SwVbaListLevels* pLevels ) : pListLevels( pLevels ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListLevels->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListLevels->getCount() )
+			return pListLevels->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListLevels::SwVbaListLevels( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, SwVbaListHelperRef pHelper ) throw (uno::RuntimeException) : SwVbaListLevels_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ), pListHelper( pHelper ) 
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListLevels::getCount() throw (uno::RuntimeException)
+{
+    sal_Int32 nGalleryType = pListHelper->getGalleryType();
+    if( nGalleryType == word::WdListGalleryType::wdBulletGallery
+        || nGalleryType == word::WdListGalleryType::wdNumberGallery )
+        return 1;
+    else if( nGalleryType == word::WdListGalleryType::wdOutlineNumberGallery )
+        return 9;
+    return 0;    
+}
+
+uno::Any SAL_CALL SwVbaListLevels::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_False )
+        throw uno::RuntimeException();
+    if( nIndex <=0 || nIndex > getCount() )    
+        throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        
+    return uno::makeAny( uno::Reference< word::XListLevel >( new SwVbaListLevel( this, mxContext, pListHelper, nIndex - 1 ) ) );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListLevels::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListLevel::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListLevels::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListLevelsEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListLevels::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListLevels::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListLevels") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListLevels::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListLevels") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbalistlevels.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalistlevels.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTLEVELS_HXX
+#define SW_VBA_LISTLEVELS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListLevels.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbalisthelper.hxx"
+
+
+typedef CollTestImplHelper< ooo::vba::word::XListLevels > SwVbaListLevels_BASE;
+
+class SwVbaListLevels : public SwVbaListLevels_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+
+public:
+	SwVbaListLevels( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, SwVbaListHelperRef pHelper ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListLevels() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListLevels_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTLEVELS_HXX */
--- sw/source/ui/vba/vbalisttemplate.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisttemplate.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisttemplate.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbalistlevels.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaListTemplate::SwVbaListTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw ( uno::RuntimeException ) : SwVbaListTemplate_BASE( rParent, rContext )
+{
+    pListHelper.reset( new SwVbaListHelper( xTextDoc, nGalleryType, nTemplateType ) );
+}
+
+SwVbaListTemplate::~SwVbaListTemplate()
+{
+}
+
+uno::Any SAL_CALL
+SwVbaListTemplate::ListLevels( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaListLevels( mxParent, mxContext, pListHelper ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+void SwVbaListTemplate::applyListTemplate( uno::Reference< beans::XPropertySet >& xProps ) throw (uno::RuntimeException)
+{
+    uno::Reference< container::XIndexReplace > xNumberingRules = pListHelper->getNumberingRules();
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingRules") ) , uno::makeAny( xNumberingRules ) );
+}
+
+rtl::OUString& 
+SwVbaListTemplate::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListTemplate") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaListTemplate::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListTemplate" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbalisttemplate.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisttemplate.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTTEMPLATE_HXX
+#define SW_VBA_LISTTEMPLATE_HXX
+
+#include <ooo/vba/word/XListTemplate.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include "vbalisthelper.hxx"
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XListTemplate > SwVbaListTemplate_BASE;
+
+class SwVbaListTemplate : public SwVbaListTemplate_BASE
+{
+private:
+    SwVbaListHelperRef pListHelper;
+
+public:
+	SwVbaListTemplate( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nGalleryType, sal_Int32 nTemplateType ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaListTemplate();
+
+    void applyListTemplate( css::uno::Reference< css::beans::XPropertySet >& xProps ) throw ( css::uno::RuntimeException );
+
+    // Methods
+    virtual css::uno::Any SAL_CALL ListLevels( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_LISTTEMPLATE_HXX */
--- sw/source/ui/vba/vbalisttemplates.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisttemplates.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalisttemplates.hxx"
+#include "vbalisttemplate.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class ListTemplatesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaListTemplates* pListTemplates;
+	sal_Int32 nIndex;
+public:
+	ListTemplatesEnumWrapper( SwVbaListTemplates* pTemplates ) : pListTemplates( pTemplates ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pListTemplates->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pListTemplates->getCount() )
+			return pListTemplates->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaListTemplates::SwVbaListTemplates( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw (uno::RuntimeException) : SwVbaListTemplates_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >() ),  mxTextDocument( xTextDoc ), mnGalleryType( nType )
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaListTemplates::getCount() throw (uno::RuntimeException)
+{
+    // 3 types of list( bullet, numbered and outline )
+    return 7;
+}
+
+uno::Any SAL_CALL SwVbaListTemplates::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_False )
+        throw uno::RuntimeException();
+    if( nIndex <=0 || nIndex > getCount() )    
+        throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        
+    return uno::makeAny( uno::Reference< word::XListTemplate >( new SwVbaListTemplate( this, mxContext, mxTextDocument, mnGalleryType, nIndex ) ) );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaListTemplates::getElementType() throw (uno::RuntimeException)
+{
+	return word::XListTemplate::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaListTemplates::createEnumeration() throw (uno::RuntimeException)
+{
+    return new ListTemplatesEnumWrapper( this );
+}
+
+uno::Any
+SwVbaListTemplates::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaListTemplates::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaListTemplates") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaListTemplates::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ListTemplates") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbalisttemplates.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbalisttemplates.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_LISTTEMPLATES_HXX
+#define SW_VBA_LISTTEMPLATES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XListTemplates.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XListTemplates > SwVbaListTemplates_BASE;
+
+class SwVbaListTemplates : public SwVbaListTemplates_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    sal_Int32 mnGalleryType;
+
+public:
+	SwVbaListTemplates( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xTextDoc, sal_Int32 nType ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaListTemplates() {}
+
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaListTemplates_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_LISTTEMPLATES_HXX */
--- sw/source/ui/vba/vbaparagraph.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaparagraph.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -51,6 +51,20 @@ SwVbaParagraph::getRange( ) throw ( uno:
     return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, mxTextDocument, mxTextRange->getStart(), mxTextRange->getEnd(), mxTextRange->getText(), sal_True ) );
 }
 
+uno::Any SAL_CALL
+SwVbaParagraph::getStyle( ) throw ( uno::RuntimeException )
+{
+    uno::Reference< word::XRange > xRange = getRange();
+    return xRange->getStyle();
+}
+
+void SAL_CALL
+SwVbaParagraph::setStyle( const uno::Any& style ) throw ( uno::RuntimeException )
+{
+    uno::Reference< word::XRange > xRange = getRange();
+    xRange->setStyle( style );
+}
+
 rtl::OUString& 
 SwVbaParagraph::getServiceImplName()
 {
--- sw/source/ui/vba/vbaparagraph.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaparagraph.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -53,6 +53,8 @@ public:
 
     // XParagraph
     virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL getRange() throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL getStyle() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setStyle( const css::uno::Any& style ) throw ( css::uno::RuntimeException );
 
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
--- sw/source/ui/vba/vbaparagraphformat.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaparagraphformat.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -37,6 +37,7 @@
 #include <ooo/vba/word/WdOutlineLevel.hpp>
 #include <com/sun/star/style/ParagraphAdjust.hpp>
 #include <com/sun/star/style/BreakType.hpp>
+#include "vbatabstops.hxx"
 
 
 using namespace ::ooo::vba;
@@ -203,9 +204,12 @@ sal_Int32 SAL_CALL SwVbaParagraphFormat:
     return nLevel;
 }
 
-void SAL_CALL SwVbaParagraphFormat::setOutlineLevel( sal_Int32 /*_outlinelevel*/ ) throw (uno::RuntimeException)
+void SAL_CALL SwVbaParagraphFormat::setOutlineLevel( sal_Int32 _outlinelevel ) throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    if( _outlinelevel != getOutlineLevel() )
+    {
+        // TODO: in my test in msword, there is no effect for this function.
+    }
 }
 
 uno::Any SAL_CALL SwVbaParagraphFormat::getPageBreakBefore() throw (uno::RuntimeException)
@@ -299,7 +303,7 @@ void SAL_CALL SwVbaParagraphFormat::setR
 
 uno::Any SAL_CALL SwVbaParagraphFormat::getTabStops() throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return uno::makeAny( uno::Reference< word::XTabStops >( new SwVbaTabStops( this, mxContext, mxParaProps ) ) );
 }
 
 void SAL_CALL SwVbaParagraphFormat::setTabStops( const uno::Any& /*_tabstops*/ ) throw (uno::RuntimeException)
--- sw/source/ui/vba/vbarange.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbarange.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -35,12 +35,21 @@
 #include <com/sun/star/style/BreakType.hpp>
 #include <com/sun/star/text/ControlCharacter.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
-#include "wordvbahelper.hxx"
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XWordCursor.hpp>
+#include <com/sun/star/text/XParagraphCursor.hpp>
+#include <ooo/vba/word/WdUnits.hpp>
+#include <ooo/vba/word/WdMovementType.hpp>
 #include "vbaparagraphformat.hxx"
 #include "vbastyle.hxx"
 #include "vbafont.hxx"
 #include "vbapalette.hxx"
 #include "vbapagesetup.hxx"
+#include "vbalistformat.hxx"
+#include "vbarevisions.hxx"
+#include "vbabookmarks.hxx"
+#include "vbasections.hxx"
+#include "vbafield.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -73,6 +82,8 @@ void SwVbaRange::initialize( const uno::
     }    
     
     mxTextCursor = SwVbaRangeHelper::initCursor( rStart, mxText );
+    if( !mxTextCursor.is() )
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Fails to create text cursor") ), uno::Reference< uno::XInterface >() );
     mxTextCursor->collapseToStart();
 
     if( rEnd.is() )
@@ -94,6 +105,67 @@ void SwVbaRange::setXTextRange( const un
     mxTextCursor->gotoRange( xRange->getEnd(), sal_True );
 }
 
+void
+SwVbaRange::Move( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+
+    sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdParagraph:
+        {
+            if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< text::XParagraphCursor > xParagraphCursor( mxTextCursor, uno::UNO_QUERY_THROW );
+            for( sal_Int32 i=0; i<nCount; i++ )
+            {
+                if( ( eDirection == word::MOVE_UP ) && ( xParagraphCursor->gotoPreviousParagraph( bExpand ) == sal_False ) )
+					break;
+                else if( ( eDirection == word::MOVE_DOWN ) && ( xParagraphCursor->gotoNextParagraph( bExpand ) == sal_False ) )
+					break;
+            }
+            break;
+        }
+        case word::WdUnits::wdWord:
+        {
+            if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< text::XWordCursor > xWordCursor( mxTextCursor, uno::UNO_QUERY_THROW );
+            for( sal_Int32 i=0; i<nCount; i++ )
+            {
+                if( (eDirection == word::MOVE_LEFT ) && ( xWordCursor->gotoPreviousWord( bExpand ) == sal_False ) )
+					break;
+				else if( ( eDirection == word::MOVE_RIGHT ) && ( xWordCursor->gotoNextWord( bExpand ) == sal_False ) )
+					break;
+            }
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
+
 /**
 * The complexity in this method is because we need to workaround
 * an issue that the last paragraph in a document does not have a trailing CRLF.
@@ -131,17 +203,46 @@ SwVbaRange::getText() throw ( uno::Runti
 void SAL_CALL
 SwVbaRange::setText( const rtl::OUString& rText ) throw ( uno::RuntimeException )
 {
+    // Emulate the MSWord behavior, Don't delete the bookmark
+    // which contains no text string in current inserting position, 
+    rtl::OUString sName;
+    uno::Reference< text::XTextRange > xRange( mxTextCursor, uno::UNO_QUERY_THROW );
+    try
+    {
+        uno::Reference< text::XTextContent > xBookmark = SwVbaRangeHelper::findBookmarkByPosition( mxTextDocument, xRange->getStart() );
+        if( xBookmark.is() )
+        {
+            uno::Reference< container::XNamed > xNamed( xBookmark, uno::UNO_QUERY_THROW );
+            sName = xNamed->getName();
+        }
+    }
+    catch( uno::Exception& )
+    {
+        // do nothing
+    }
+    
     if( rText.indexOf( '\n' )  != -1 )
     {
         mxTextCursor->setString( rtl::OUString() );
         // process CR in strings
-        uno::Reference< text::XTextRange > xRange( mxTextCursor, uno::UNO_QUERY_THROW );
         SwVbaRangeHelper::insertString( xRange, mxText, rText, sal_True );
     }
     else
     {
         mxTextCursor->setString( rText );
     }
+
+    // insert the bookmark if the bookmark is deleted during setting text string
+    if( sName.getLength() )
+    {
+        uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNameAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+        if( !xNameAccess->hasByName( sName ) )
+        {
+            uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+            SwVbaBookmarks::addBookmarkByName( xModel, sName, xRange->getStart() );
+        }
+    }
 }
 
 // FIXME: test is not pass
@@ -232,11 +333,8 @@ SwVbaRange::setParagraphFormat( const un
     throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 }
 
-uno::Reference< word::XStyle > SAL_CALL
-SwVbaRange::getStyle() throw ( uno::RuntimeException )
+void SwVbaRange::GetStyleInfo(rtl::OUString& aStyleName, rtl::OUString& aStyleType ) throw ( uno::RuntimeException )
 {
-    rtl::OUString aStyleName;
-    rtl::OUString aStyleType;
     uno::Reference< beans::XPropertySet > xProp( mxTextCursor, uno::UNO_QUERY_THROW );
     if( ( xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharStyleName") ) ) >>= aStyleName ) && aStyleName.getLength() )
     {
@@ -250,14 +348,23 @@ SwVbaRange::getStyle() throw ( uno::Runt
     {
         DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
     }
+}
+
+uno::Any SAL_CALL
+SwVbaRange::getStyle() throw ( uno::RuntimeException )
+{
+    rtl::OUString aStyleName;
+    rtl::OUString aStyleType;
+    GetStyleInfo( aStyleName, aStyleType );
     uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxTextDocument, uno::UNO_QUERY_THROW);
     uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
     uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
-    return uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ); 
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xModel, xStyleProps ) ) );
 }
 
 void SAL_CALL
-SwVbaRange::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+SwVbaRange::setStyle( const uno::Any& rStyle ) throw ( uno::RuntimeException )
 {
     uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
     SwVbaStyle::setStyle( xParaProps, rStyle );
@@ -270,6 +377,12 @@ SwVbaRange::getFont() throw ( uno::Runti
     return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), uno::Reference< beans::XPropertySet >( getXTextRange(), uno::UNO_QUERY_THROW ) );
 }
 
+uno::Reference< word::XListFormat > SAL_CALL
+SwVbaRange::getListFormat() throw ( uno::RuntimeException )
+{
+    return uno::Reference< word::XListFormat >( new SwVbaListFormat( this, mxContext, getXTextRange() ) );
+}
+
 ::sal_Int32 SAL_CALL SwVbaRange::getLanguageID() throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
@@ -327,6 +440,50 @@ void SAL_CALL SwVbaRange::setEnd( ::sal_
     mxTextCursor->gotoRange( xEnd, sal_True );
 }
 
+::sal_Bool SAL_CALL SwVbaRange::InRange( const uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (uno::RuntimeException)
+{
+    SwVbaRange* pRange = dynamic_cast< SwVbaRange* >( Range.get() );
+    if( !pRange )
+        throw uno::RuntimeException();
+    uno::Reference< text::XTextRange > xTextRange = pRange->getXTextRange();    
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextCursor->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( xTextRange, getXTextRange() ) >= 0 && xTRC->compareRegionEnds( xTextRange, getXTextRange() ) <= 0 )
+        return sal_True;
+    return sal_False;    
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Revisions( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange = getXTextRange();
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRevisions( mxParent, mxContext, xModel, xTextRange ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Sections( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange = getXTextRange();
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaSections( mxParent, mxContext, xModel, xTextRange ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaRange::Fields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    //FIXME: should be get the field in current range
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaFields( mxParent, mxContext, xModel ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
 rtl::OUString& 
 SwVbaRange::getServiceImplName()
 {
--- sw/source/ui/vba/vbarange.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbarange.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,6 +38,8 @@
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextDocument.hpp>
 #include <ooo/vba/word/XStyle.hpp>
+#include <ooo/vba/word/XListFormat.hpp>
+#include "wordvbahelper.hxx"
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRange > SwVbaRange_BASE;
 
@@ -51,6 +53,7 @@ private:
 
 private:
     void initialize( const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd ) throw (css::uno::RuntimeException);
+    void GetStyleInfo(rtl::OUString& aStyleName, rtl::OUString& aStyleType ) throw ( css::uno::RuntimeException );
 public:
 	SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
 	SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
@@ -62,16 +65,18 @@ public:
     void setXTextRange( const css::uno::Reference< css::text::XTextRange >& xRange ) throw (css::uno::RuntimeException);
     css::uno::Reference< css::text::XText > getXText() { return mxText; }
     void setXTextCursor( const css::uno::Reference< css::text::XTextCursor >& xTextCursor ) { mxTextCursor = xTextCursor; }
+    void Move( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend, ooo::vba::word::E_DIRECTION eDirection ) throw (css::uno::RuntimeException);
 
 	// Attribute
     virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setText( const rtl::OUString& rText ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Any& _xStyle ) throw (css::uno::RuntimeException);
 
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XListFormat > SAL_CALL getListFormat() throw (css::uno::RuntimeException);
     // Methods
     virtual void SAL_CALL InsertBreak( const css::uno::Any& _breakType ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
@@ -85,6 +90,10 @@ public:
     virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL InRange( const css::uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Revisions( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Sections( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Fields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
--- sw/source/ui/vba/vbarangehelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbarangehelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -30,6 +30,7 @@
 #include "vbarangehelper.hxx"
 #include <com/sun/star/text/ControlCharacter.hpp>
 #include <com/sun/star/text/XTextRangeCompare.hpp>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -114,7 +115,7 @@ uno::Reference< text::XTextCursor > SwVb
         DebugHelper::exception(e);
     }
 
-    if( !bGotTextCursor )
+    if( !bGotTextCursor || !xTextCursor.is() )
     {
         try
         {
@@ -128,7 +129,7 @@ uno::Reference< text::XTextCursor > SwVb
         }
     }
 
-    if( !bGotTextCursor )
+    if( !bGotTextCursor || !xTextCursor.is() )
     {
         try
         {
@@ -172,3 +173,29 @@ sal_Int32 SwVbaRangeHelper::getPosition(
 
     return nPosition;
 }
+
+uno::Reference< text::XTextContent > SwVbaRangeHelper::findBookmarkByPosition( const uno::Reference< text::XTextDocument >& xTextDoc, const uno::Reference< text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException )
+{
+    uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( xTextDoc, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = 0; index < xIndexAccess->getCount(); index++ )
+    {
+        uno::Reference< text::XTextContent > xBookmark( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        uno::Reference< text::XTextRange > xBkAnchor = xBookmark->getAnchor();
+        uno::Reference< text::XTextRangeCompare > xCompare( xBkAnchor->getText(), uno::UNO_QUERY_THROW );
+        if( xCompare->compareRegionStarts( xBkAnchor->getStart(), xBkAnchor->getEnd() ) == 0 )
+        {
+            try
+            {
+                if( xCompare->compareRegionStarts( xTextRange, xBkAnchor->getStart() ) == 0 )
+                    return xBookmark;
+            }
+            catch( uno::Exception& )
+            {
+                continue;
+            }
+        }
+    }
+    return uno::Reference< text::XTextContent >();
+}
+
--- sw/source/ui/vba/vbarangehelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbarangehelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -33,6 +33,8 @@
 #include <vbahelper/vbahelperinterface.hxx>
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
 
 class SwVbaRangeHelper
 {
@@ -41,6 +43,7 @@ public:
     static void insertString( css::uno::Reference< css::text::XTextRange >& rTextRange, css::uno::Reference< css::text::XText >& rText, const rtl::OUString& rStr, sal_Bool _bAbsorb ) throw ( css::uno::RuntimeException );
     static css::uno::Reference< css::text::XTextCursor > initCursor( const css::uno::Reference< css::text::XTextRange >& rTextRange, const css::uno::Reference< css::text::XText >& rText ) throw ( css::uno::RuntimeException );
     static sal_Int32 getPosition( const css::uno::Reference< css::text::XText >& rText, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw ( css::uno::RuntimeException );
+    static css::uno::Reference< css::text::XTextContent > findBookmarkByPosition( const css::uno::Reference< css::text::XTextDocument >& xTextDoc, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
 
 };
 #endif /* SW_VBA_RANGEHELPER_HXX */
--- sw/source/ui/vba/vbareplacement.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbareplacement.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -53,6 +53,12 @@ void SAL_CALL SwVbaReplacement::setText(
     mxPropertyReplace->setReplaceString( _text );
 }
 
+void SAL_CALL SwVbaReplacement::ClearFormatting( ) throw (uno::RuntimeException)
+{
+    uno::Sequence< beans::PropertyValue > aPropValues;
+    mxPropertyReplace->setReplaceAttributes( aPropValues );
+}
+
 rtl::OUString& 
 SwVbaReplacement::getServiceImplName()
 {
--- sw/source/ui/vba/vbareplacement.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbareplacement.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -50,6 +50,9 @@ public:
     virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
 
+    //Methods
+    virtual void SAL_CALL ClearFormatting() throw (css::uno::RuntimeException);
+
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- sw/source/ui/vba/vbarevision.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarevision.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarevision.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
+#include "wordvbahelper.hxx"
+#include <docsh.hxx>
+#include <doc.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaRevision::SwVbaRevision( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xRedlineProps ) throw ( uno::RuntimeException ) : SwVbaRevision_BASE( rParent, rContext ), mxModel( xModel ), mxRedlineProps( xRedlineProps )
+{
+}
+
+SwVbaRevision::~SwVbaRevision()
+{
+}
+
+sal_Int32 SwVbaRevision::GetPosition() throw (css::uno::RuntimeException)
+{
+    sal_Int32 nPos = -1;
+    uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+    sal_Int32 nCount = xRedlines->getCount();
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        uno::Reference< beans::XPropertySet > xProps( xRedlines->getByIndex( i ), uno::UNO_QUERY_THROW );
+        if( xProps == mxRedlineProps )
+        {
+            nPos = i;
+            OSL_TRACE(" SwVbaRevision::SwVbaRevision, the redline position is %d, ", nPos );
+            break;
+        }
+    }
+    if( nPos == -1 )
+        throw uno::RuntimeException();
+    
+    return nPos;
+}
+
+void SAL_CALL
+SwVbaRevision::Accept() throw ( css::uno::RuntimeException )
+{
+    SwDoc* pDoc = word::getDocShell( mxModel )->GetDoc();
+    if( pDoc )
+        pDoc->AcceptRedline( GetPosition(), sal_True );
+}
+
+void SAL_CALL
+SwVbaRevision::Reject( ) throw ( css::uno::RuntimeException )
+{
+    SwDoc* pDoc = word::getDocShell( mxModel )->GetDoc();
+    if( pDoc )
+        pDoc->RejectRedline( GetPosition(), sal_True );
+}
+
+rtl::OUString& 
+SwVbaRevision::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRevision") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaRevision::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Revision" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbarevision.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarevision.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_REVISION_HXX
+#define SW_VBA_REVISION_HXX
+
+#include <ooo/vba/word/XRevision.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRevision > SwVbaRevision_BASE;
+
+class SwVbaRevision : public SwVbaRevision_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxRedlineProps;
+
+private:
+    sal_Int32 GetPosition() throw (css::uno::RuntimeException);
+
+public:
+	SwVbaRevision( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xRedlineProps ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRevision();
+
+    // Methods
+    virtual void SAL_CALL Accept(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Reject(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_REVISION_HXX */
--- sw/source/ui/vba/vbarevisions.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarevisions.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarevisions.hxx"
+#include "vbarevision.hxx"
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/document/XRedlinesSupplier.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > RevisionEnumeration_BASE;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > RevisionCollectionHelper_BASE;
+typedef std::vector< uno::Reference< beans::XPropertySet > > RevisionMap;
+
+class RedlinesEnumeration : public RevisionEnumeration_BASE
+{
+	RevisionMap mRevisionMap;
+	RevisionMap::iterator mIt;
+public:
+	RedlinesEnumeration( const RevisionMap& sMap ) : mRevisionMap( sMap ), mIt( mRevisionMap.begin() ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( mIt != mRevisionMap.end() );
+	}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		uno::Reference< beans::XPropertySet > xRevision( *mIt++ );
+		return uno::makeAny( xRevision ) ;
+	}
+};
+
+class RevisionCollectionHelper : public RevisionCollectionHelper_BASE
+{
+	RevisionMap mRevisionMap;
+public:
+RevisionCollectionHelper( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException);
+    
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  beans::XPropertySet::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return ( mRevisionMap.size() > 0 ); }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) { return mRevisionMap.size(); }	
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+		if ( Index < 0 || Index >= getCount() )
+			throw lang::IndexOutOfBoundsException();
+	
+		return uno::makeAny( mRevisionMap[ Index ] );
+
+	}
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new RedlinesEnumeration( mRevisionMap );
+	}
+};
+
+RevisionCollectionHelper::RevisionCollectionHelper( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException)
+    {
+        uno::Reference< text::XTextRangeCompare > xTRC( xTextRange->getText(), uno::UNO_QUERY_THROW );
+        uno::Reference< document::XRedlinesSupplier > xRedlinesSupp( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xRedlines( xRedlinesSupp->getRedlines(), uno::UNO_QUERY_THROW );
+        sal_Int32 nCount = xRedlines->getCount();
+        for( sal_Int32 index = 0; index < nCount; index++ )
+        {
+            uno::Reference< text::XTextRange > xRedlineRange( xRedlines->getByIndex( index ), uno::UNO_QUERY_THROW );
+            if( xTRC->compareRegionStarts( xTextRange, xRedlineRange ) >= 0 && xTRC->compareRegionEnds( xTextRange, xRedlineRange ) <= 0 )
+            {
+                uno::Reference< beans::XPropertySet > xRedlineProps( xRedlineRange, uno::UNO_QUERY_THROW );
+                mRevisionMap.push_back( xRedlineProps );
+            }
+        }
+    }
+class RevisionsEnumeration : public EnumerationHelperImpl
+{
+	uno::Reference< frame::XModel > m_xModel;
+	uno::WeakReference< XHelperInterface > m_xParent;
+public:
+	RevisionsEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), m_xModel( xModel ), m_xParent( xParent ){}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< beans::XPropertySet > xRevision( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< word::XRevision > ( new SwVbaRevision( m_xParent, m_xContext, m_xModel, xRevision ) ) );
+	}
+
+};
+
+SwVbaRevisions::SwVbaRevisions( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ): SwVbaRevisions_BASE( xParent, xContext, new RevisionCollectionHelper( xModel, xTextRange ) ),  mxModel( xModel )
+{
+}
+
+SwVbaRevisions::SwVbaRevisions( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< container::XIndexAccess >& xIndexAccess ): SwVbaRevisions_BASE( xParent, xContext, xIndexAccess ),  mxModel( xModel )
+{
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaRevisions::getElementType() throw (uno::RuntimeException)
+{
+	return word::XRevision::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaRevisions::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return new RevisionsEnumeration( this, mxContext, xEnumAccess->createEnumeration(), mxModel );
+}
+
+uno::Any
+SwVbaRevisions::createCollectionObject( const css::uno::Any& aSource )
+{
+    uno::Reference< beans::XPropertySet > xRevision( aSource, uno::UNO_QUERY_THROW );
+	return uno::makeAny( uno::Reference< word::XRevision > ( new SwVbaRevision( this, mxContext, mxModel, xRevision ) ) );
+}
+
+void SAL_CALL SwVbaRevisions::AcceptAll(  ) throw (css::uno::RuntimeException)
+{
+    // First we need to put all the redline into a vector, because if the redline is accepted,
+    // it will auto delete in the document.
+    std::vector< uno::Reference< word::XRevision > > aRevisions;
+    uno::Reference< container::XEnumeration > xEnumeration = createEnumeration();
+    while( xEnumeration->hasMoreElements() )
+    {
+        uno::Reference< word::XRevision > xRevision( xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+        aRevisions.push_back( xRevision );
+    }
+
+    std::vector< uno::Reference< word::XRevision > >::iterator it = aRevisions.begin();
+    for( ; it != aRevisions.end(); it++ )
+    {
+        uno::Reference< word::XRevision > xRevision( *it );
+        xRevision->Accept();
+    }
+}
+
+void SAL_CALL SwVbaRevisions::RejectAll(  ) throw (css::uno::RuntimeException)
+{
+    throw uno::RuntimeException();
+}
+
+rtl::OUString& 
+SwVbaRevisions::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRevisions") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaRevisions::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Revisions") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbarevisions.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarevisions.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PANES_HXX
+#define SW_VBA_PANES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XRevisions.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+
+
+typedef CollTestImplHelper< ooo::vba::word::XRevisions > SwVbaRevisions_BASE;
+
+class SwVbaRevisions : public SwVbaRevisions_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaRevisions( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextRange >& xTextRange );
+
+	SwVbaRevisions( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+	virtual ~SwVbaRevisions() {}
+
+    // Methods
+    virtual void SAL_CALL AcceptAll(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL RejectAll(  ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaRevisions_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_PANES_HXX */
--- sw/source/ui/vba/vbarow.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarow.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,136 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarow.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <ooo/vba/word/WdRowHeightRule.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <rtl/ustrbuf.hxx>
+#include "wordvbahelper.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaRow::SwVbaRow( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( uno::RuntimeException ) :
+    SwVbaRow_BASE( rParent, rContext ), mxTextTable( xTextTable ), mnIndex( nIndex )
+{
+    mxTableRows = mxTextTable->getRows();
+    mxRowProps.set( mxTableRows->getByIndex( mnIndex ), uno::UNO_QUERY_THROW );
+}
+
+SwVbaRow::~SwVbaRow()
+{
+}
+
+uno::Any SAL_CALL SwVbaRow::getHeight() throw (css::uno::RuntimeException)
+{
+    if( getHeightRule() == word::WdRowHeightRule::wdRowHeightAuto )
+        return uno::makeAny( sal_Int32( word::WdConstants::wdUndefined ) );
+
+    sal_Int32 nHeight = 0;
+    mxRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ) ) >>= nHeight;
+    return uno::makeAny( (float)Millimeter::getInPoints( nHeight ) );
+}
+
+void SAL_CALL SwVbaRow::setHeight( const uno::Any& _height ) throw (css::uno::RuntimeException)
+{
+    float height = 0;
+    _height >>= height;
+
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( height );
+    mxRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ), uno::makeAny( nHeight ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaRow::getHeightRule() throw (css::uno::RuntimeException)
+{
+    sal_Bool isAutoHeight = sal_False;
+    mxRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoHeight") ) ) >>= isAutoHeight;
+    return isAutoHeight ? word::WdRowHeightRule::wdRowHeightAuto : word::WdRowHeightRule::wdRowHeightExactly;
+}
+
+void SAL_CALL SwVbaRow::setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException)
+{
+    sal_Bool isAutoHeight = ( _heightrule == word::WdRowHeightRule::wdRowHeightAuto );
+    mxRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoHeight") ), uno::makeAny( isAutoHeight ) );
+}
+
+void SAL_CALL
+SwVbaRow::Select( ) throw ( uno::RuntimeException )
+{
+    SelectRow( getCurrentWordDoc(mxContext), mxTextTable, mnIndex, mnIndex );
+}
+
+void SwVbaRow::SelectRow( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextTable >& xTextTable, sal_Int32 nStartRow, sal_Int32 nEndRow ) throw ( uno::RuntimeException )
+{
+    rtl::OUStringBuffer aRangeName;
+    aRangeName.appendAscii("A").append(sal_Int32( nStartRow + 1 ) );
+    SwVbaTableHelper aTableHelper( xTextTable );
+    sal_Int32 nColCount = aTableHelper.getTabColumnsCount( nEndRow );
+    // FIXME: the column count > 26
+    //sal_Char cCol = 'A' + nColCount - 1;
+    rtl::OUString sCol = aTableHelper.getColumnStr( nColCount - 1);
+    aRangeName.appendAscii(":").append( sCol ).append( sal_Int32( nEndRow + 1 ) );
+
+    uno::Reference< table::XCellRange > xCellRange( xTextTable, uno::UNO_QUERY_THROW );
+    rtl::OUString sSelRange = aRangeName.makeStringAndClear();
+    uno::Reference< table::XCellRange > xSelRange = xCellRange->getCellRangeByName( sSelRange );
+
+    uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelection->select( uno::makeAny( xSelRange ) );
+}
+
+void SAL_CALL SwVbaRow::SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException)
+{
+    setHeightRule( heightrule );
+    setHeight( uno::makeAny( height ) );
+}
+
+rtl::OUString& 
+SwVbaRow::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRow") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaRow::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Row" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbarow.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarow.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ROW_HXX
+#define SW_VBA_ROW_HXX
+
+#include <ooo/vba/word/XRow.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRow > SwVbaRow_BASE;
+
+class SwVbaRow : public SwVbaRow_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableRows > mxTableRows;
+    css::uno::Reference< css::beans::XPropertySet > mxRowProps;
+    sal_Int32 mnIndex;
+
+public:
+	SwVbaRow( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRow();
+
+    // Attributes
+    virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( const css::uno::Any& _height ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getHeightRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeightRule( ::sal_Int32 _heightrule ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetHeight( float height, sal_Int32 heightrule ) throw (css::uno::RuntimeException);
+
+    static void SelectRow( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextTable >& xTextTable, sal_Int32 nStartRow, sal_Int32 nEndRow ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_ROW_HXX */
--- sw/source/ui/vba/vbarows.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarows.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,368 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarows.hxx"
+#include "vbarow.hxx"
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <ooo/vba/word/WdRowAlignment.hpp>
+#include <ooo/vba/word/WdConstants.hpp>
+#include <ooo/vba/word/WdRulerStyle.hpp>
+#include "wordvbahelper.hxx"
+#include "vbacolumns.hxx"
+#include "vbatablehelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class RowsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< text::XTextTable > mxTextTable;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    uno::WeakReference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+	sal_Int32 nIndex;
+
+public:
+	RowsEnumWrapper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< text::XTextTable >& xTextTable ) : mxParent( xParent ), mxContext( xContext ), mxTextTable( xTextTable ), nIndex( 0 ) 
+    {
+        mxIndexAccess.set( mxTextTable->getRows(), uno::UNO_QUERY );
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return uno::makeAny( uno::Reference< word::XRow > ( new SwVbaRow( mxParent, mxContext, mxTextTable, nIndex++ ) ) );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaRows::SwVbaRows( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableRows >& xTableRows ) throw (uno::RuntimeException) : SwVbaRows_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableRows, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableRows( xTableRows ) 
+{
+    mnStartRowIndex = 0;
+    mnEndRowIndex = m_xIndexAccess->getCount() - 1;
+}
+
+SwVbaRows::SwVbaRows( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextTable >& xTextTable, const uno::Reference< table::XTableRows >& xTableRows, sal_Int32 nStarIndex, sal_Int32 nEndIndex ) throw (uno::RuntimeException) : SwVbaRows_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( xTableRows, uno::UNO_QUERY_THROW ) ), mxTextTable( xTextTable ), mxTableRows( xTableRows ), mnStartRowIndex( nStarIndex ), mnEndRowIndex( nEndIndex ) 
+{
+    if( mnEndRowIndex < mnStartRowIndex )
+        throw uno::RuntimeException();
+}
+
+/**
+ * get the alignment of the rows: SO format com.sun.star.text.HoriOrientation
+ * is mapped to WdRowAlignment in Word
+ * @return the alignment
+ */
+::sal_Int32 SAL_CALL SwVbaRows::getAlignment() throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrient") ) ) >>= nAlignment;
+    sal_Int32 nRet = 0;
+    switch( nAlignment )
+    {
+        case text::HoriOrientation::CENTER:
+        {
+           nRet = word::WdRowAlignment::wdAlignRowCenter;
+           break;
+        }
+        case text::HoriOrientation::RIGHT:
+        {
+            nRet = word::WdRowAlignment::wdAlignRowRight;
+            break;
+        }
+        default:
+        {
+            nRet = word::WdRowAlignment::wdAlignRowLeft;
+        }
+    }
+    return nRet;
+}
+
+void SAL_CALL SwVbaRows::setAlignment( ::sal_Int32 _alignment ) throw (uno::RuntimeException)
+{
+    sal_Int16 nAlignment = text::HoriOrientation::LEFT;
+    switch( _alignment )
+    {
+        case word::WdRowAlignment::wdAlignRowCenter:
+        {
+            nAlignment = text::HoriOrientation::CENTER;
+            break;
+        }
+        case word::WdRowAlignment::wdAlignRowRight:
+        {
+            nAlignment = text::HoriOrientation::RIGHT;
+            break;
+        }
+        default:
+        {
+            nAlignment = text::HoriOrientation::LEFT;
+        }
+    }
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrient") ), uno::makeAny( nAlignment ) );
+}
+
+uno::Any SAL_CALL SwVbaRows::getAllowBreakAcrossPages() throw (uno::RuntimeException)
+{
+    sal_Bool bAllowBreak = sal_False;
+    uno::Reference< container::XIndexAccess > xRowsAccess( mxTableRows, uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = mnStartRowIndex; index <= mnEndRowIndex; ++index )
+    {
+        uno::Reference< beans::XPropertySet > xRowProps( xRowsAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        sal_Bool bSplit = sal_False;
+        xRowProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsSplitAllowed") ) ) >>= bSplit;
+        if( index == 0 )
+        {
+            bAllowBreak = bSplit;
+        }
+        if( bSplit != bAllowBreak )
+        {
+            sal_Int32 nRet = word::WdConstants::wdUndefined;
+            return uno::makeAny( nRet );
+        }
+    }
+    return uno::makeAny( bAllowBreak );
+}
+
+void SAL_CALL SwVbaRows::setAllowBreakAcrossPages( const uno::Any& _allowbreakacrosspages ) throw (uno::RuntimeException)
+{
+    sal_Bool bAllowBreak = sal_False;
+    _allowbreakacrosspages >>= bAllowBreak;
+    uno::Reference< container::XIndexAccess > xRowsAccess( mxTableRows, uno::UNO_QUERY_THROW );
+    for( sal_Int32 index = mnStartRowIndex; index <= mnEndRowIndex; ++index )
+    {
+        uno::Reference< beans::XPropertySet > xRowProps( xRowsAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+        xRowProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsSplitAllowed") ), uno::makeAny( bAllowBreak ) );
+    }    
+}
+
+float SAL_CALL SwVbaRows::getSpaceBetweenColumns() throw (uno::RuntimeException)
+{
+    // just get the first spacing of the first cell
+    uno::Reference< table::XCellRange > xCellRange( mxTextTable, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xCellProps( xCellRange->getCellByPosition( 0, mnStartRowIndex ), uno::UNO_QUERY_THROW );
+    sal_Int32 nLeftBorderDistance = 0;
+    sal_Int32 nRightBorderDistance = 0;
+    xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftBorderDistance") ) ) >>= nLeftBorderDistance;
+    xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightBorderDistance") ) ) >>= nRightBorderDistance;
+    return static_cast< float >( Millimeter::getInPoints( nLeftBorderDistance + nRightBorderDistance ) );
+}
+
+void SAL_CALL SwVbaRows::setSpaceBetweenColumns( float _spacebetweencolumns ) throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = Millimeter::getInHundredthsOfOneMillimeter( _spacebetweencolumns ) / 2;
+    uno::Reference< container::XIndexAccess > xColumnAccess( mxTextTable->getColumns(), uno::UNO_QUERY_THROW );
+    uno::Reference< table::XCellRange > xCellRange( mxTextTable, uno::UNO_QUERY_THROW );
+    SwVbaTableHelper aTableHelper( mxTextTable );
+    for( sal_Int32 row = mnStartRowIndex; row <= mnEndRowIndex; ++row )
+    {
+        sal_Int32 nColumns = aTableHelper.getTabColumnsCount( row );
+        for( sal_Int32 column = 0; column < nColumns; ++column )
+        {
+            uno::Reference< beans::XPropertySet > xCellProps( xCellRange->getCellByPosition( column, row ), uno::UNO_QUERY_THROW );
+            xCellProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftBorderDistance") ), uno::makeAny( nSpace ) );
+            xCellProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightBorderDistance") ), uno::makeAny( nSpace ) );
+        }
+    }
+}
+
+void SAL_CALL SwVbaRows::Delete(  ) throw (uno::RuntimeException)
+{
+    mxTableRows->removeByIndex( mnStartRowIndex, getCount() );
+}
+
+void SAL_CALL SwVbaRows::SetLeftIndent( float LeftIndent, ::sal_Int32 RulerStyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XColumns > xColumns( new SwVbaColumns( getParent(), mxContext, mxTextTable, mxTextTable->getColumns() ) );
+    sal_Int32 nIndent = (sal_Int32)( LeftIndent );
+    switch( RulerStyle )
+    {
+        case word::WdRulerStyle::wdAdjustFirstColumn:
+        {
+            setIndentWithAdjustFirstColumn( xColumns, nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustNone:
+        {
+            setIndentWithAdjustNone( nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustProportional:
+        {
+            setIndentWithAdjustProportional( xColumns, nIndent );
+            break;
+        }
+        case word::WdRulerStyle::wdAdjustSameWidth:
+        {
+            setIndentWithAdjustSameWidth( xColumns, nIndent );
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+        }
+    }
+}
+
+void SwVbaRows::setIndentWithAdjustNone( sal_Int32 indent ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nMargin = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ) ) >>= nMargin;
+    nMargin += indent;
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ), uno::makeAny( nMargin ) );
+}
+
+ void SwVbaRows::setIndentWithAdjustFirstColumn( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    sal_Int32 nIndex = 1;
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( nIndex ), uno::Any() ), uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = xColumn->getWidth();
+    nWidth -= indent;
+    xColumn->setWidth( nWidth );
+    setIndentWithAdjustNone( indent );
+ }
+
+ void SwVbaRows::setIndentWithAdjustProportional( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    // calculate the new width and get the proportion between old and new
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    sal_Int32 nNewWidth = nWidth - indent;
+    double propFactor = (double)nNewWidth/(double)nWidth;
+
+    // get all columns, calculate and set the new width of the columns
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    sal_Int32 nColCount = xCol->getCount();
+    for( sal_Int32 i = 0; i < nColCount; i++ )
+    {
+        uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( i ), uno::Any() ), uno::UNO_QUERY_THROW );
+        sal_Int32 nColWidth = xColumn->getWidth();
+        sal_Int32 nNewColWidth = ( sal_Int32 )( propFactor * nColWidth );
+        xColumn->setWidth( nNewColWidth );
+    }
+
+    // set the width and position of the table
+    setIndentWithAdjustNone( indent );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( nNewWidth ) );
+ }
+
+ void SwVbaRows::setIndentWithAdjustSameWidth( const uno::Reference< word::XColumns >& xColumns, sal_Int32 indent ) throw (uno::RuntimeException)
+ {
+    // calculate the new width and get the width of all columns
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    sal_Int32 nWidth = 0;
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    sal_Int32 nNewWidth = nWidth - indent;
+
+    // get all columns, calculate and set the new width of the columns
+    uno::Reference< XCollection > xCol( xColumns, uno::UNO_QUERY_THROW );
+    sal_Int32 nColCount = xCol->getCount();
+    sal_Int32 nNewColWidth = (sal_Int32)( double( nNewWidth )/nColCount );
+    for( sal_Int32 i = 0; i < nColCount; i++ )
+    {
+        uno::Reference< word::XColumn > xColumn( xCol->Item( uno::makeAny( i ), uno::Any() ), uno::UNO_QUERY_THROW );
+        xColumn->setWidth( nNewColWidth );
+    }
+
+    // set the width and position of the table
+    setIndentWithAdjustNone( indent );
+    xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( nNewWidth ) );
+ }
+
+void SAL_CALL SwVbaRows::Select(  ) throw (uno::RuntimeException)
+{
+    SwVbaRow::SelectRow( getCurrentWordDoc(mxContext), mxTextTable, mnStartRowIndex, mnEndRowIndex ); 
+}
+
+::sal_Int32 SAL_CALL SwVbaRows::getCount() throw (uno::RuntimeException)
+{
+    return ( mnEndRowIndex - mnStartRowIndex + 1 );
+}
+
+uno::Any SAL_CALL SwVbaRows::Item( const uno::Any& Index1, const uno::Any& /*not processed in this base class*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) == sal_True )
+    {
+        if( nIndex <= 0 || nIndex > getCount() )
+        {
+            throw  lang::IndexOutOfBoundsException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+        }
+        return uno::makeAny( uno::Reference< word::XRow >( new SwVbaRow( this, mxContext, mxTextTable, nIndex - 1 ) ) );
+    }
+    throw  uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Index out of bounds") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaRows::getElementType() throw (uno::RuntimeException)
+{
+	return word::XRow::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaRows::createEnumeration() throw (uno::RuntimeException)
+{
+    return new RowsEnumWrapper( this, mxContext, mxTextTable );
+}
+
+uno::Any
+SwVbaRows::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaRows::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRows") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaRows::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Rows") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbarows.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbarows.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ROWS_HXX
+#define SW_VBA_ROWS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XRows.hpp>
+#include <ooo/vba/word/XColumns.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XRows > SwVbaRows_BASE;
+
+class SwVbaRows : public SwVbaRows_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    css::uno::Reference< css::table::XTableRows > mxTableRows;
+    sal_Int32 mnStartRowIndex;
+    sal_Int32 mnEndRowIndex;
+
+private:
+    void setIndentWithAdjustNone( sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustFirstColumn( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustProportional( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+    void setIndentWithAdjustSameWidth( const css::uno::Reference< ooo::vba::word::XColumns >& xColumns, sal_Int32 indent ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaRows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableRows >& xTableRows ) throw ( css::uno::RuntimeException );
+	SwVbaRows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextTable >& xTextTable, const css::uno::Reference< css::table::XTableRows >& xTableRows, sal_Int32 nStarIndex, sal_Int32 nEndIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaRows() {}
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getAlignment() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAlignment( ::sal_Int32 _alignment ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getAllowBreakAcrossPages() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAllowBreakAcrossPages( const css::uno::Any& _allowbreakacrosspages ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getSpaceBetweenColumns() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSpaceBetweenColumns( float _spacebetweencolumns ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetLeftIndent( float LeftIndent, ::sal_Int32 RulerStyle ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+
+    //XCollection
+    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw ( css::uno::RuntimeException );
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaRows_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_ROWS_HXX */
--- sw/source/ui/vba/vbasection.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbasection.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -31,6 +31,7 @@
 #include <vbahelper/vbahelper.hxx>
 #include <tools/diagnose_ex.h>
 #include "vbapagesetup.hxx"
+#include "vbaheadersfooters.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -53,14 +54,20 @@ void SAL_CALL SwVbaSection::setProtected
 {
 }
 
-uno::Any SAL_CALL SwVbaSection::Headers(  ) throw (uno::RuntimeException)
+uno::Any SAL_CALL SwVbaSection::Headers( const uno::Any& index ) throw (uno::RuntimeException)
 {
-    return uno::Any();
+    uno::Reference< XCollection > xCol( new SwVbaHeadersFooters( this, mxContext, mxModel, mxPageProps, sal_True ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
 }
 
-uno::Any SAL_CALL SwVbaSection::Footers(  ) throw (uno::RuntimeException)
+uno::Any SAL_CALL SwVbaSection::Footers( const uno::Any& index ) throw (uno::RuntimeException)
 {
-    return uno::Any();
+    uno::Reference< XCollection > xCol( new SwVbaHeadersFooters( this, mxContext, mxModel, mxPageProps, sal_False ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
 }
 
 uno::Any SAL_CALL
--- sw/source/ui/vba/vbasection.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbasection.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -51,8 +51,8 @@ public:
     virtual void SAL_CALL setProtectedForForms( ::sal_Bool _protectedforforms ) throw (css::uno::RuntimeException);
 
     // Methods
-    virtual css::uno::Any SAL_CALL Headers(  ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Footers(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Headers( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Footers( const css::uno::Any& index ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL PageSetup(  ) throw (css::uno::RuntimeException);
 
 	// XHelperInterface
--- sw/source/ui/vba/vbasections.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbasections.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -90,6 +90,15 @@ public:
         }
     }
 
+    SectionCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        // Hacky implementation of Range.Sections, only support 1 secction
+        uno::Reference< beans::XPropertySet > xRangeProps( xTextRange, uno::UNO_QUERY_THROW );
+        uno::Reference< style::XStyle > xStyle = word::getCurrentPageStyle( mxModel, xRangeProps );
+        uno::Reference< beans::XPropertySet > xPageProps( xStyle, uno::UNO_QUERY_THROW );
+        mxSections.push_back( xPageProps );
+    }
+
     ~SectionCollectionHelper(){}
 
     // XIndexAccess
@@ -138,6 +147,10 @@ SwVbaSections::SwVbaSections( const uno:
 {
 }
 
+SwVbaSections::SwVbaSections( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ): SwVbaSections_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new SectionCollectionHelper( xParent, xContext, xModel, xTextRange ) ) ),  mxModel( xModel )
+{
+}
+
 uno::Any SAL_CALL
 SwVbaSections::PageSetup( ) throw (uno::RuntimeException)
 {
--- sw/source/ui/vba/vbasections.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbasections.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -34,6 +34,7 @@
 #include <ooo/vba/word/XSections.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
 #include <vbahelper/vbahelperinterface.hxx>
 
 typedef CollTestImplHelper< ooo::vba::word::XSections > SwVbaSections_BASE;
@@ -45,6 +46,7 @@ private:
 
 public:
 	SwVbaSections( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	SwVbaSections( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextRange >& xTextRange );
 	virtual ~SwVbaSections() {}
 
 	// XEnumerationAccess
--- sw/source/ui/vba/vbaselection.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaselection.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,7 +32,6 @@
 #include <tools/diagnose_ex.h>
 #include "vbarange.hxx"
 #include "vbafind.hxx"
-#include "wordvbahelper.hxx"
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/text/XTextTable.hpp>
 #include <com/sun/star/text/XTextTableCursor.hpp>
@@ -44,14 +43,19 @@
 #include <ooo/vba/word/WdGoToDirection.hpp>
 #include <ooo/vba/word/XBookmark.hpp>
 #include <ooo/vba/word/XApplication.hpp>
+#include <ooo/vba/word/WdCollapseDirection.hpp>
 #include <com/sun/star/text/XPageCursor.hpp>
 #include "unotbl.hxx"
 #include "unocoll.hxx"
 #include "vbatable.hxx"
 #include <com/sun/star/view/XSelectionSupplier.hpp>
 #include <com/sun/star/view/XViewCursor.hpp>
+#include <com/sun/star/view/XLineCursor.hpp>
+#include <com/sun/star/text/XWordCursor.hpp>
+#include <com/sun/star/text/XParagraphCursor.hpp>
 #include <ooo/vba/word/WdInformation.hpp>
 #include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+#include <ooo/vba/word/WdSeekView.hpp>
 #include "vbainformationhelper.hxx"
 #include "vbafield.hxx"
 #include "vbaheaderfooter.hxx"
@@ -59,6 +63,17 @@
 #include <vbahelper/vbashaperange.hxx>
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/text/ControlCharacter.hpp>
+#include "vbarows.hxx"
+#include "vbacolumns.hxx"
+#include "vbatablehelper.hxx"
+#include "vbacells.hxx"
+#include "vbaview.hxx"
+#include "vbaparagraph.hxx"
+#include "vbastyle.hxx"
+#include <docsh.hxx>
+#include <tblenum.hxx>
+#include <fesh.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
@@ -126,23 +141,25 @@ SwVbaSelection::HomeKey( const uno::Any&
     sal_Int32 nExtend = word::WdMovementType::wdMove;
     _unit >>= nUnit;
     _extend >>= nExtend;
+    sal_Bool bExtend = ( nExtend == word::WdMovementType::wdExtend ) ? sal_True : sal_False;
 
     switch( nUnit )
     {
         case word::WdUnits::wdStory:
         {
+			// go to the valid text first so that the current view cursor is valid to call gotoRange.
+			word::gotoSelectedObjectAnchor(mxModel);
             // go to the begin of the document
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfDoc"));
-            dispatchRequests( mxModel,url );
-            // If something is selected, it needs to go twice
-            dispatchRequests( mxModel,url );
+            uno::Reference< text::XText > xCurrentText = word::getCurrentXText( mxModel );
+            uno::Reference< text::XTextRange > xFirstRange = word::getFirstObjectPosition( xCurrentText );
+            mxTextViewCursor->gotoRange( xFirstRange, bExtend );
             break;
         }
         case word::WdUnits::wdLine:
         {
             // go to the begin of the Line
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfLine"));
-            dispatchRequests( mxModel,url );
+            uno::Reference< view::XLineCursor > xLineCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            xLineCursor->gotoStartOfLine( bExtend );
             break;
         }
         default:
@@ -160,23 +177,25 @@ SwVbaSelection::EndKey( const uno::Any&
     sal_Int32 nExtend = word::WdMovementType::wdMove;
     _unit >>= nUnit;
     _extend >>= nExtend;
+    sal_Bool bExtend = ( nExtend == word::WdMovementType::wdExtend ) ? sal_True : sal_False;
 
     switch( nUnit )
     {
         case word::WdUnits::wdStory:
         {
-            // go to the end of the document
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfDoc"));
-            dispatchRequests( mxModel,url );
-            // If something is selected, it needs to go twice
-            dispatchRequests( mxModel,url );
+			// go to the valid text first so that the current view cursor is valid to call gotoRange.
+			word::gotoSelectedObjectAnchor(mxModel);
+            // go to the end of the document			
+            uno::Reference< text::XText > xCurrentText = word::getCurrentXText( mxModel );
+            uno::Reference< text::XTextRange > xEnd = xCurrentText->getEnd();
+            mxTextViewCursor->gotoRange( xEnd, bExtend );
             break;
         }
         case word::WdUnits::wdLine:
         {
             // go to the end of the Line
-            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfLine"));
-            dispatchRequests( mxModel,url );
+            uno::Reference< view::XLineCursor > xLineCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            xLineCursor->gotoEndOfLine( bExtend );
             break;
         }
         default:
@@ -188,14 +207,161 @@ SwVbaSelection::EndKey( const uno::Any&
 }
 
 void SAL_CALL
-SwVbaSelection::Delete( const uno::Any& /*_unit*/, const uno::Any& /*_count*/ ) throw ( uno::RuntimeException )
+SwVbaSelection::Delete( const uno::Any& _unit, const uno::Any& _count ) throw ( uno::RuntimeException )
 {
-    // FIXME: handle the arguments: _unit and _count 
+    sal_Int32 nUnit = word::WdUnits::wdLine;
+    sal_Int32 nCount = 0;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _unit.hasValue() && ( nCount > 0 ) )
+    {
+        _unit >>= nUnit;
+        switch( nUnit )
+        {
+            case word::WdUnits::wdCharacter:
+            {
+                if( HasSelection() )
+                    nCount--;
+                mxTextViewCursor->goRight( nCount, sal_True );
+                break;
+            }
+            default:
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }    
+        }
+    }
     rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Delete"));
     dispatchRequests( mxModel,url );
 }
 
-void SwVbaSelection::NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+void
+SwVbaSelection::Move( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+
+    sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdCell:
+        {
+            if(  nExtend == word::WdMovementType::wdExtend )
+            {
+                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+                return;
+            }
+            NextCell( nCount, eDirection );
+            break;
+        }
+        case word::WdUnits::wdLine:
+        {
+            if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            if( eDirection == word::MOVE_UP )
+                xViewCursor->goUp( nCount, bExpand );
+            else if( eDirection == word::MOVE_DOWN )
+                xViewCursor->goDown( nCount, bExpand );
+            break;
+        }
+        case word::WdUnits::wdCharacter:
+        {
+            if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+            {
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            }
+            if( word::gotoSelectedObjectAnchor( mxModel ) )
+            {
+                nCount--;
+            }
+            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            if( eDirection == word::MOVE_LEFT )
+            {
+                // if current select is a cellrange or table, 
+                // the first count of move should move to the first selected cell.
+                uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+                if ( xTextTableCursor.is() )
+                {
+                    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+                    uno::Reference< text::XTextTable > xTextTable;
+                    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+                    if( xTextTable.is() )
+                    {
+                        uno::Reference< text::XTextRange > xRange( xTextTable->getCellByName( xTextTableCursor->getRangeName()), uno::UNO_QUERY_THROW );
+                        mxTextViewCursor->gotoRange( xRange->getStart(), bExpand );
+                        nCount--;
+                    }
+                }
+                xViewCursor->goLeft( nCount, bExpand );
+            }    
+            else if( eDirection == word::MOVE_RIGHT )
+                xViewCursor->goRight( nCount, bExpand );
+            break;
+        }
+        case word::WdUnits::wdWord:
+        case word::WdUnits::wdParagraph:
+        {
+			uno::Reference< text::XTextRange > xRange = GetSelectedRange();
+			uno::Reference< text::XText > xText = xRange->getText();
+			uno::Reference< text::XTextCursor > xTextCursor = xText->createTextCursorByRange( xRange );
+			if( nUnit == word::WdUnits::wdParagraph )
+			{
+				if( eDirection == word::MOVE_LEFT || eDirection == word::MOVE_RIGHT )
+				{
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+				}
+				uno::Reference< text::XParagraphCursor > xParagraphCursor( xTextCursor, uno::UNO_QUERY_THROW );
+				for( sal_Int32 i=0; i<nCount; i++ )
+				{
+					if( ( eDirection == word::MOVE_UP ) && ( xParagraphCursor->gotoPreviousParagraph( bExpand ) == sal_False ) )
+						break;
+					else if( ( eDirection == word::MOVE_DOWN ) && ( xParagraphCursor->gotoNextParagraph( bExpand ) == sal_False ) )
+						break;
+				}
+			}
+			else if( nUnit == word::WdUnits::wdWord )
+			{
+				if( eDirection == word::MOVE_UP || eDirection == word::MOVE_DOWN )
+				{
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+				}
+				uno::Reference< text::XWordCursor > xWordCursor( xTextCursor, uno::UNO_QUERY_THROW );
+				for( sal_Int32 i=0; i<nCount; i++ )
+				{
+					if( (eDirection == word::MOVE_LEFT ) && ( xWordCursor->gotoPreviousWord( bExpand ) == sal_False ) )
+						break;
+					else if( ( eDirection == word::MOVE_RIGHT ) && ( xWordCursor->gotoNextWord( bExpand ) == sal_False ) )
+						break;
+				}
+			}
+			mxTextViewCursor->gotoRange( xTextCursor->getStart(), sal_False );
+			mxTextViewCursor->gotoRange( xTextCursor->getEnd(), sal_True );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
+
+void SwVbaSelection::NextCell( sal_Int32 nCount, word::E_DIRECTION eDirection ) throw ( uno::RuntimeException )
 {
     uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
     uno::Reference< text::XTextTable > xTextTable;
@@ -214,22 +380,22 @@ void SwVbaSelection::NextCell( sal_Int32
     // move the table cursor 
     switch( eDirection )
     {
-        case MOVE_LEFT:
+        case word::MOVE_LEFT:
         {
             xTextTableCursor->goLeft( nCount, sal_False );
             break;
         }
-        case MOVE_RIGHT:
+        case word::MOVE_RIGHT:
         {
             xTextTableCursor->goRight( nCount, sal_False );
             break;
         }
-        case MOVE_UP:
+        case word::MOVE_UP:
         {
             xTextTableCursor->goUp( nCount, sal_False );
             break;
         }
-        case MOVE_DOWN:
+        case word::MOVE_DOWN:
         {
             xTextTableCursor->goDown( nCount, sal_False );
             break;
@@ -248,61 +414,29 @@ void SwVbaSelection::NextCell( sal_Int32
 void SAL_CALL
 SwVbaSelection::MoveRight( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
 
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
     
     if( nCount < 0 )
     {
-        // TODO: call MoveLeft;
         MoveLeft( _unit, uno::makeAny( -nCount ), _extend );
         return;
     }
-    
-    switch( nUnit )
-    {
-        case word::WdUnits::wdCell:
-        {
-            if(  nExtend == word::WdMovementType::wdExtend )
-            {
-                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
-                return;
-            }
-            NextCell( nCount, MOVE_RIGHT );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
-    }
 
+    Move( _unit, _count, _extend, word::MOVE_RIGHT );
 }
 
 void SAL_CALL
 SwVbaSelection::MoveLeft( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
-
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
@@ -313,67 +447,47 @@ SwVbaSelection::MoveLeft( const uno::Any
         return;
     }
     
-    switch( nUnit )
-    {
-        case word::WdUnits::wdCell:
-        {
-            if(  nExtend == word::WdMovementType::wdExtend )
-            {
-                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
-                return;
-            }
-            NextCell( nCount, MOVE_LEFT );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
-    }
-
+    Move( _unit, _count, _extend, word::MOVE_LEFT );
 }
 
 void SAL_CALL
 SwVbaSelection::MoveDown( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
 {
-    sal_Int32 nUnit = word::WdUnits::wdCharacter;
     sal_Int32 nCount = 1;
-    sal_Int32 nExtend = word::WdMovementType::wdMove;
 
-    if( _unit.hasValue() )
-        _unit >>= nUnit;
     if( _count.hasValue() )
         _count >>= nCount;
-    if( _extend.hasValue() )
-        _extend >>= nExtend;
     
     if( nCount == 0 )
         return;
     
     if( nCount < 0 )
     {
-        // TODO: call MoveLeft;
-        //MoveUp( _unit, uno::makeAny( -nCount ), _extend );
+        MoveUp( _unit, uno::makeAny( -nCount ), _extend );
         return;
     }
     
-    switch( nUnit )
+    Move( _unit, _count, _extend, word::MOVE_DOWN );
+}
+
+void SAL_CALL
+SwVbaSelection::MoveUp( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nCount = 1;
+
+    if( _count.hasValue() )
+        _count >>= nCount;
+    
+    if( nCount == 0 )
+        return;
+    
+    if( nCount < 0 )
     {
-        case word::WdUnits::wdLine:
-        {
-            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
-            sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
-            xViewCursor->goDown( nCount, bExpand );
-            break;
-        }
-        default:
-        {
-            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
-            break;
-        }
+        MoveDown( _unit, uno::makeAny( -nCount ), _extend );
+        return;
     }
-
+    
+    Move( _unit, _count, _extend, word::MOVE_UP );
 }
 
 void SAL_CALL
@@ -425,16 +539,17 @@ SwVbaSelection::getFind() throw ( uno::R
     return uno::Reference< word::XFind >( new SwVbaFind( this, mxContext, mxModel, xTextRange ) );
 }
 
-uno::Reference< word::XStyle > SAL_CALL
+uno::Any SAL_CALL
 SwVbaSelection::getStyle() throw ( uno::RuntimeException )
 {
     return getRange()->getStyle();
 }
 
 void SAL_CALL
-SwVbaSelection::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+SwVbaSelection::setStyle( const uno::Any& rStyle ) throw ( uno::RuntimeException )
 {
-    return getRange()->setStyle( rStyle );
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    return SwVbaStyle::setStyle( xParaProps, rStyle );
 }
 
 uno::Reference< word::XFont > SAL_CALL
@@ -477,39 +592,79 @@ uno::Reference< word::XRange > SAL_CALL
             sal_Int32 nWhich = 0;
             if( _which.hasValue() )
                 _which >>= nWhich;
-             sal_Int32 nPage = 0;
-             switch( nWhich )
-             {
-                case word::WdGoToDirection::wdGoToLast:
-                {
-                    nPage = nLastPage;
-                    break;
-                }
-                case word::WdGoToDirection::wdGoToNext:
-                {
-                    nPage = nCurrPage + 1;
-                    break;
-                }
-                case word::WdGoToDirection::wdGoToPrevious:
-                {
-                    nPage = nCurrPage - 1;
-                    break;
-                }
-                default:
-                {
-                    nPage = nCount;
-                }
-             }
-             if( nPage <= 0 )
-                nPage = 1;
-             if( nPage > nLastPage )
-                nPage = nLastPage;
-             xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
-             break;
+            sal_Int32 nPage = 0;
+            switch( nWhich )
+            {
+               case word::WdGoToDirection::wdGoToLast:
+               {
+                   nPage = nLastPage;
+                   break;
+               }
+               case word::WdGoToDirection::wdGoToNext:
+               {
+                   if( nCount !=0 )
+                       nPage = nCurrPage + nCount;
+                   else    
+                       nPage = nCurrPage + 1;
+                   break;
+               }
+               case word::WdGoToDirection::wdGoToPrevious:
+               {
+                   if( nCount !=0 )
+                       nPage = nCurrPage - nCount;
+                   else    
+                       nPage = nCurrPage - 1;
+                   break;
+               }
+               default:
+               {
+                   nPage = nCount;
+               }
+            }
+            if( _name.hasValue() )
+            {
+                rtl::OUString sName;
+                _name >>= sName;
+                sal_Int32 nName = sName.toInt32();
+                if( nName !=0 )
+                    nPage = nName;
+            }
+            if( nPage <= 0 )
+               nPage = 1;
+            if( nPage > nLastPage )
+               nPage = nLastPage;
+            xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
+            break;
         }
         case word::WdGoToItem::wdGoToSection:
         {
-            // TODO: implement Section object
+            uno::Reference< text::XPageCursor > xPageCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            sal_Int32 nCount = 0;
+            if( _count.hasValue() )
+                _count >>= nCount;
+            sal_Int32 nWhich = 0;
+            if( _which.hasValue() )
+                _which >>= nWhich;
+            sal_Int32 nPage = 0;    
+            switch( nWhich )
+            {
+               case word::WdGoToDirection::wdGoToAbsolute:
+               {
+                    // currently only support this type
+                    if( nCount == 1 )
+                        nPage = 1;
+                    break;
+               }
+               default:
+               {
+                    nPage = 0;
+               }
+            }   
+            if( nPage != 0 )
+                xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
+            else    
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;    
         }
         default:
             throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
@@ -549,6 +704,82 @@ uno::Any SAL_CALL SwVbaSelection::Inform
             result = uno::makeAny( SwVbaInformationHelper::handleWdVerticalPositionRelativeToPage( mxModel, mxTextViewCursor ) );
             break;
         }
+        case word::WdInformation::wdWithInTable:
+        {
+            uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XTextTable > xTextTable;
+            xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+            if( xTextTable.is() )
+                result = uno::makeAny( sal_True );
+            else
+                result = uno::makeAny( sal_False );
+            break;
+        }
+        case word::WdInformation::wdHeaderFooterType:
+        {
+            uno::Reference< word::XView > xView( new SwVbaView( this, mxContext, mxModel ) );
+            sal_Int32 nView = xView->getSeekView();
+            sal_Int32 nHeaderFooterType = 0;
+            switch( nView )
+            {
+                case word::WdSeekView::wdSeekMainDocument:
+                {
+                    nHeaderFooterType = -1; // not in a header or footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekEvenPagesHeader:
+                {
+                    nHeaderFooterType = 0; // even page header
+                    break;
+                }
+                case word::WdSeekView::wdSeekPrimaryHeader:
+                {
+                    nHeaderFooterType = 1; // odd page header
+                    break;
+                }
+                case word::WdSeekView::wdSeekEvenPagesFooter:
+                {
+                    nHeaderFooterType = 2; // even page footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekPrimaryFooter:
+                {
+                    nHeaderFooterType = 3; // odd page footer
+                    break;
+                }
+                case word::WdSeekView::wdSeekFirstPageHeader:
+                case word::WdSeekView::wdSeekFirstPageFooter:
+                {
+                    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+                    rtl::OUString aPageStyleName;
+                    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+                    sal_Bool bFirstPage = sal_False;
+                    if( aPageStyleName.equalsAscii( "First Page" ) )
+                        bFirstPage = sal_True;
+                    if( nView == word::WdSeekView::wdSeekFirstPageHeader )
+                    {
+                        if( bFirstPage )
+                            nHeaderFooterType = 4; 
+                        else
+                            nHeaderFooterType = 1;
+                    }        
+                    else        
+                    {
+                        if( bFirstPage )
+                            nHeaderFooterType = 5; 
+                        else
+                            nHeaderFooterType = 3;
+                    }        
+                    break;
+                }
+                default:
+                {
+                    nHeaderFooterType = -1;
+                }
+            }
+            result = uno::makeAny( nHeaderFooterType );
+            break;
+        }
         default:
             throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
     }
@@ -569,11 +800,6 @@ SwVbaSelection::Tables( const uno::Any&
     // we can only support a selection that is a single table
     if ( !aIndex.hasValue() ) // currently we can't support multiple tables in a selection
        throw uno::RuntimeException(); 
-    // if the current selection is a XTextTableCursor and the index is 1 then we can service this request, otherwise we just have to throw
-    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
-
-    if ( !xTextTableCursor.is() )
-       throw uno::RuntimeException(); 
 
     sal_Int32 nIndex = 0;
     aIndex >>= nIndex;
@@ -582,6 +808,24 @@ SwVbaSelection::Tables( const uno::Any&
 
     if ( nIndex != 1 )
        throw uno::RuntimeException(); 
+
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    if( xTextTable.is() )
+    {
+            uno::Reference< css::text::XTextDocument > xTextDoc( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< word::XTable > xVBATbl = new SwVbaTable( mxParent, mxContext, xTextDoc, xTextTable ); 
+            aRet <<= xVBATbl;
+            return aRet;
+    }
+
+    // if the current selection is a XTextTableCursor and the index is 1 then we can service this request, otherwise we just have to throw
+    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+
+    if ( !xTextTableCursor.is() )
+       throw uno::RuntimeException(); 
+
     SwXTextTableCursor* pTTCursor = dynamic_cast< SwXTextTableCursor* >( xTextTableCursor.get() );
     if ( pTTCursor )
     {
@@ -611,15 +855,14 @@ SwVbaSelection::Fields( const uno::Any&
 uno::Reference< word::XHeaderFooter > SAL_CALL
 SwVbaSelection::getHeaderFooter() throw ( uno::RuntimeException )
 {
-    uno::Reference< text::XText > xCurrentText = word::getXTextViewCursor( mxModel )->getText();
-    if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFooter( mxModel, xCurrentText ) )
+    if( HeaderFooterHelper::isHeaderFooter( mxModel ) )
     {
         uno::Reference< beans::XPropertySet > xPageStyleProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
         sal_Int32 nIndex = word::WdHeaderFooterIndex::wdHeaderFooterPrimary;
-        sal_Bool isHeader = HeaderFooterHelper::isHeader( mxModel, xCurrentText );
-        if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+        sal_Bool isHeader = HeaderFooterHelper::isHeader( mxModel );
+        if( HeaderFooterHelper::isEvenPagesHeader( mxModel ) || HeaderFooterHelper::isEvenPagesFooter( mxModel ) )
             nIndex = word::WdHeaderFooterIndex::wdHeaderFooterEvenPages;
-        else if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+        else if( HeaderFooterHelper::isFirstPageHeader( mxModel ) || HeaderFooterHelper::isFirstPageFooter( mxModel ) )
             nIndex = word::WdHeaderFooterIndex::wdHeaderFooterFirstPage;
         
         return uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( this, mxContext, mxModel, xPageStyleProps, isHeader, nIndex ) );
@@ -632,9 +875,13 @@ uno::Any SAL_CALL
 SwVbaSelection::ShapeRange( ) throw (uno::RuntimeException)
 {
     uno::Reference< drawing::XShapes > xShapes( mxModel->getCurrentSelection(), uno::UNO_QUERY );
-
     if ( !xShapes.is() )
-       throw uno::RuntimeException(); 
+    {
+        uno::Reference< drawing::XShape > xShape( mxModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
+        uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+        xShapes.set( xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.drawing.ShapeCollection" ) ), uno::UNO_QUERY_THROW );
+        xShapes->add( xShape );
+    }   
 
     uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
     uno::Reference< drawing::XDrawPage > xDrawPage = xDrawPageSupplier->getDrawPage();
@@ -661,6 +908,281 @@ void SAL_CALL SwVbaSelection::setEnd( ::
     getRange()->setEnd( _end );
 }
 
+void SAL_CALL SwVbaSelection::SelectRow() throw (uno::RuntimeException)
+{
+    uno::Reference< word::XRows > xRows( Rows( uno::Any() ), uno::UNO_QUERY_THROW );
+    xRows->Select();
+}
+
+void SAL_CALL SwVbaSelection::SelectColumn() throw (uno::RuntimeException)
+{
+    uno::Reference< word::XColumns > xColumns( Columns( uno::Any() ), uno::UNO_QUERY_THROW );
+    xColumns->Select();
+}
+
+uno::Any SAL_CALL SwVbaSelection::Rows( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    
+    sal_Int32 nStartRow = 0;
+    sal_Int32 nEndRow = 0;
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nStartRow = aTableHelper.getTabRowIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nEndRow = aTableHelper.getTabRowIndex( sBRName );
+    }
+    else
+    {
+        nEndRow = nStartRow;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaRows( this, mxContext, xTextTable, xTextTable->getRows(), nStartRow, nEndRow ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL SwVbaSelection::Columns( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    sal_Int32 nStartColumn = 0;
+    sal_Int32 nEndColumn = 0;
+
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nStartColumn = aTableHelper.getTabColIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nEndColumn = aTableHelper.getTabColIndex( sBRName );
+    }
+    else
+    {
+        nEndColumn = nStartColumn;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaColumns( this, mxContext, xTextTable, xTextTable->getColumns(), nStartColumn, nEndColumn ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Reference< text::XTextTable > SwVbaSelection::GetXTextTable() throw( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    return xTextTable;
+}
+
+sal_Bool SwVbaSelection::IsInTable() throw( uno::RuntimeException )
+{
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    if( xTextTable.is() )
+        return sal_True;
+    return sal_False;    
+}
+
+sal_Bool SwVbaSelection::HasSelection() throw( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xStart = mxTextViewCursor->getStart();
+    uno::Reference< text::XTextRange > xEnd = mxTextViewCursor->getEnd();
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextViewCursor->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( xStart, xEnd ) == 0 && xTRC->compareRegionEnds( xStart, xEnd ) == 0 )
+        return sal_False;
+    return sal_True;    
+}
+
+void SwVbaSelection::GetSelectedCellRange( rtl::OUString& sTLName, rtl::OUString& sBRName ) throw( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    if( !xTextTable.is() )
+        throw uno::RuntimeException( );
+
+    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( xTextTableCursor.is() )
+    {
+        String sRange( xTextTableCursor->getRangeName() );
+        if( sRange.GetTokenCount(':') > 0 )
+        {
+            sTLName = sRange.GetToken(0, ':');
+            sBRName = sRange.GetToken(1, ':');
+        }
+    }    
+    if( !sTLName.getLength() )
+    {
+        uno::Reference< table::XCell > xCell;
+        xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Cell") ) ) >>= xCell;
+        if( !xCell.is() )
+        {
+            throw uno::RuntimeException( );
+        }
+        uno::Reference< beans::XPropertySet > xCellProps( xCell, uno::UNO_QUERY_THROW );
+        xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CellName") ) ) >>= sTLName;
+    }
+}
+
+uno::Any SAL_CALL SwVbaSelection::Cells( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    rtl::OUString sTLName;
+    rtl::OUString sBRName;
+    GetSelectedCellRange( sTLName, sBRName );
+    sal_Int32 nLeft = 0;
+    sal_Int32 nTop = 0;
+    sal_Int32 nRight = 0;
+    sal_Int32 nBottom = 0;
+
+    uno::Reference< text::XTextTable > xTextTable = GetXTextTable();
+    SwVbaTableHelper aTableHelper( xTextTable );
+    nLeft = aTableHelper.getTabColIndex( sTLName );
+    nTop = aTableHelper.getTabRowIndex( sTLName );
+    if( sBRName.getLength() > 0 )
+    {
+        nRight = aTableHelper.getTabColIndex( sBRName );
+        nBottom = aTableHelper.getTabRowIndex( sBRName );
+    }
+    else
+    {
+        nRight = nLeft;
+        nBottom = nTop;
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaCells( this, mxContext, xTextTable, nLeft, nTop, nRight, nBottom ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+void SAL_CALL SwVbaSelection::Copy(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Copy"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaSelection::CopyAsPicture(  ) throw (uno::RuntimeException)
+{
+    // seems not support in Writer
+    Copy();
+}
+
+void SAL_CALL SwVbaSelection::Paste(  ) throw (uno::RuntimeException)
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Paste"));
+    dispatchRequests( mxModel,url );
+}
+
+void SAL_CALL SwVbaSelection::Collapse( const uno::Any& Direction ) throw (uno::RuntimeException)
+{
+    if( word::gotoSelectedObjectAnchor( mxModel ) )
+        return;
+
+    sal_Int32 nDirection = word::WdCollapseDirection::wdCollapseStart;
+    if( Direction.hasValue() )
+        Direction >>= nDirection;
+    
+    uno::Reference< text::XTextViewCursor > xTextViewCursor = word::getXTextViewCursor( mxModel );
+    if( nDirection == word::WdCollapseDirection::wdCollapseStart )
+    {
+        // it is inaccurate if current seleciton is multipul cells, so it needs to go to start
+        uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getStart();
+        xTextViewCursor->gotoRange( xTextRange, sal_False );
+        xTextViewCursor->collapseToStart();
+    }
+    else if( nDirection == word::WdCollapseDirection::wdCollapseEnd )
+    {
+        uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getEnd();
+        xTextViewCursor->gotoRange( xTextRange, sal_False );
+        xTextViewCursor->collapseToEnd();
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+void SAL_CALL SwVbaSelection::WholeStory(  ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = word::getCurrentXText( mxModel );
+    // FIXME: for i#7747,if the first line is a table, it fails to select all the contents in the story.
+    // Temporary solution, insert an empty line before the table so that it could select all the contents.
+    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
+    if( xParaEnum->hasMoreElements() )
+    {
+        uno::Reference< text::XTextTable > xTextTable( xParaEnum->nextElement(), uno::UNO_QUERY );
+        if( xTextTable.is() )
+        {
+            // insert an empty line
+            uno::Reference< text::XTextRange > xFirstCellRange = word::getFirstObjectPosition( xText );
+            mxTextViewCursor->gotoRange( xFirstCellRange, sal_False );
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertPara"));
+            dispatchRequests( mxModel,url );
+        }
+    }
+    uno::Reference< text::XTextRange > xStart = xText->getStart();
+    uno::Reference< text::XTextRange > xEnd = xText->getEnd();
+    mxTextViewCursor->gotoRange( xStart, sal_False );
+    mxTextViewCursor->gotoRange( xEnd, sal_True );
+}
+
+::sal_Bool SAL_CALL SwVbaSelection::InRange( const uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (uno::RuntimeException)
+{
+    return getRange()->InRange( Range );
+}
+
+void SAL_CALL SwVbaSelection::SplitTable(  ) throw (uno::RuntimeException)
+{
+    if( !IsInTable() )
+        throw uno::RuntimeException();
+
+    SwDocShell* pDocShell = word::getDocShell( mxModel );
+    if( pDocShell )
+    {
+        SwFEShell* pFEShell = pDocShell->GetFEShell();
+        if( pFEShell )
+        {
+            pFEShell->SplitTable( HEADLINE_CNTNTCOPY );
+        }
+    }
+}
+
+uno::Any SAL_CALL
+SwVbaSelection::Paragraphs( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    // Hacky implementation due to missing api ( and lack of knowledge )
+    // we can only support a selection that is a single paragraph 
+    if ( !aIndex.hasValue() ) // currently we can't support multiple paragraphs in a selection
+       throw uno::RuntimeException(); 
+
+    sal_Int32 nIndex = 0;
+    aIndex >>= nIndex;
+
+    uno::Any aRet;
+
+    if ( nIndex != 1 )
+       throw uno::RuntimeException(); 
+
+    uno::Reference< text::XTextRange > xTextRange = mxTextViewCursor->getStart();
+    uno::Reference< text::XText > xText = xTextRange->getText();
+    uno::Reference< text::XParagraphCursor > xParaCursor( xText->createTextCursor(), uno::UNO_QUERY_THROW );
+    xParaCursor->gotoStartOfParagraph( sal_False );
+    xParaCursor->gotoStartOfParagraph( sal_True );
+
+    uno::Reference< text::XTextDocument > xTextDoc( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xParaRange( xParaCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XParagraph > xParagraph = new SwVbaParagraph( mxParent, mxContext, xTextDoc, xParaRange );
+
+    aRet <<= xParagraph;
+    return aRet;
+}
+
 rtl::OUString& 
 SwVbaSelection::getServiceImplName()
 {
--- sw/source/ui/vba/vbaselection.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaselection.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -34,11 +34,13 @@
 #include <ooo/vba/word/XRange.hpp>
 #include <vbahelper/vbahelperinterface.hxx>
 #include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
 #include <ooo/vba/word/XParagraphFormat.hpp>
 #include <ooo/vba/word/XFind.hpp>
 #include <ooo/vba/word/XStyle.hpp>
 #include <ooo/vba/word/XFont.hpp>
 #include <ooo/vba/word/XHeaderFooter.hpp>
+#include "wordvbahelper.hxx"
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XSelection > SwVbaSelection_BASE;
 
@@ -49,17 +51,14 @@ private:
     css::uno::Reference< css::text::XTextViewCursor > mxTextViewCursor;
     css::uno::Reference< ooo::vba::word::XRange > mxRange;
 
-    enum E_DIRECTION
-    {
-        MOVE_LEFT = 1,
-        MOVE_RIGHT,
-        MOVE_UP,
-        MOVE_DOWN
-    };
-
 private:
-    void NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( css::uno::RuntimeException );
+    void Move( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend, ooo::vba::word::E_DIRECTION eDirection ) throw (css::uno::RuntimeException);
+    void NextCell( sal_Int32 nCount, ooo::vba::word::E_DIRECTION eDirection ) throw ( css::uno::RuntimeException );
     css::uno::Reference< css::text::XTextRange > GetSelectedRange() throw ( css::uno::RuntimeException );
+    void GetSelectedCellRange( rtl::OUString& sTLName, rtl::OUString& sBRName ) throw ( css::uno::RuntimeException );
+    css::uno::Reference< css::text::XTextTable > GetXTextTable() throw ( css::uno::RuntimeException );
+    sal_Bool IsInTable() throw ( css::uno::RuntimeException );
+    sal_Bool HasSelection() throw ( css::uno::RuntimeException );
 
 public:
 	SwVbaSelection( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel ) throw ( css::uno::RuntimeException );
@@ -76,6 +75,7 @@ public:
     virtual void SAL_CALL MoveRight( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL MoveLeft( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL MoveDown( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL MoveUp( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL TypeParagraph() throw (css::uno::RuntimeException);
     virtual void SAL_CALL InsertParagraph() throw (css::uno::RuntimeException);
     virtual void SAL_CALL InsertParagraphBefore() throw (css::uno::RuntimeException);
@@ -83,8 +83,8 @@ public:
     virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFind > SAL_CALL getFind() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Any& _xStyle ) throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
     virtual void SAL_CALL TypeBackspace() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL GoTo( const css::uno::Any& _what, const css::uno::Any& _which, const css::uno::Any& _count, const css::uno::Any& _name ) throw (css::uno::RuntimeException);
@@ -100,6 +100,19 @@ public:
     virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SelectRow() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SelectColumn() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Rows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Columns( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Cells( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Copy(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL CopyAsPicture(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Paste(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Collapse( const css::uno::Any& Direction ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL WholeStory(  ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL InRange( const css::uno::Reference< ::ooo::vba::word::XRange >& Range ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SplitTable(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Paragraphs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
--- sw/source/ui/vba/vbastyle.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbastyle.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -31,15 +31,18 @@
 #include "vbastyle.hxx"
 #include <ooo/vba/word/WdStyleType.hpp>
 #include <com/sun/star/lang/Locale.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
 #include <i18npool/mslangid.hxx>
 #include "vbafont.hxx"
 #include "vbapalette.hxx"
+#include "vbaparagraphformat.hxx"
+#include "vbastyles.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
 
-SwVbaStyle::SwVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& _xPropertySet ) throw ( script::BasicErrorException, uno::RuntimeException ) : SwVbaStyle_BASE( xParent, xContext ) , mxStyleProps( _xPropertySet )
+SwVbaStyle::SwVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel>& xModel, const uno::Reference< beans::XPropertySet >& _xPropertySet ) throw ( script::BasicErrorException, uno::RuntimeException ) : SwVbaStyle_BASE( xParent, xContext ) , mxModel( xModel ), mxStyleProps( _xPropertySet )
 {
     mxStyle.set( _xPropertySet, uno::UNO_QUERY_THROW );
 }
@@ -87,7 +90,7 @@ void SAL_CALL SwVbaStyle::setLanguageID(
         nType = word::WdStyleType::wdStyleTypeParagraph;
     else if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.CharacterStyle") ) ) )    
         nType = word::WdStyleType::wdStyleTypeCharacter;
-    else // if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingStyle") ) ) )    
+    else
         nType = word::WdStyleType::wdStyleTypeList;
     return nType;
 }
@@ -99,10 +102,31 @@ SwVbaStyle::getFont() throw ( uno::Runti
     return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), mxStyleProps );
 }
 
-void SwVbaStyle::setStyle( const uno::Reference< beans::XPropertySet >& xTCProps, const uno::Reference< ooo::vba::word::XStyle >& xStyle )throw (uno::RuntimeException)
+
+void SAL_CALL SwVbaStyle::LinkToListTemplate( const uno::Reference< word::XListTemplate >& /*ListTemplate*/, const uno::Any& /*ListLevelNumber*/ ) throw (uno::RuntimeException)
+{
+}
+
+void SwVbaStyle::setStyle( const uno::Reference< beans::XPropertySet >& xParaProps, const uno::Any& rStyle )throw (uno::RuntimeException)
 {
-    rtl::OUString aStyleType = getOOoStyleTypeFromMSWord( xStyle->getType() );
-    xTCProps->setPropertyValue( aStyleType, uno::makeAny( xStyle->getName() ) );
+    rtl::OUString sStyle;
+    uno::Reference< word::XStyle > xStyle;
+    if( rStyle >>= xStyle )
+    {
+        sStyle = xStyle->getName();
+    }
+    else
+    {
+        rStyle >>= sStyle;
+    }
+
+    if( sStyle.getLength() )
+    {
+        xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaStyleName") ), uno::makeAny( sStyle ) );
+        return;
+    }
+
+    throw uno::RuntimeException();
 }
 
 rtl::OUString SwVbaStyle::getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType )
@@ -132,6 +156,115 @@ rtl::OUString SwVbaStyle::getOOoStyleTyp
     return aStyleType;
 }
 
+::rtl::OUString SAL_CALL SwVbaStyle::getNameLocal() throw (uno::RuntimeException)
+{
+    rtl::OUString sNameLocal;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DisplayName") ) ) >>= sNameLocal;
+    return sNameLocal;
+}
+
+void SAL_CALL SwVbaStyle::setNameLocal( const ::rtl::OUString& _namelocal ) throw (uno::RuntimeException)
+{
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DisplayName") ), uno::makeAny( _namelocal ) );
+}
+
+uno::Reference< word::XParagraphFormat > SAL_CALL SwVbaStyle::getParagraphFormat() throw (uno::RuntimeException)
+{
+    if( word::WdStyleType::wdStyleTypeParagraph == getType() )
+    {
+        uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
+        return uno::Reference< word::XParagraphFormat >( new SwVbaParagraphFormat( this, mxContext, xTextDocument, mxStyleProps ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Reference< word::XParagraphFormat >();
+}
+
+::sal_Bool SAL_CALL SwVbaStyle::getAutomaticallyUpdate() throw (uno::RuntimeException)
+{
+    sal_Bool isAutoUpdate = sal_False;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoUpdate") ) ) >>= isAutoUpdate;
+    return isAutoUpdate;
+}
+
+void SAL_CALL SwVbaStyle::setAutomaticallyUpdate( ::sal_Bool _automaticallyupdate ) throw (uno::RuntimeException)
+{
+    mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsAutoUpdate") ), uno::makeAny( _automaticallyupdate ) );
+}
+
+uno::Any SAL_CALL SwVbaStyle::getBaseStyle() throw (uno::RuntimeException)
+{
+    // ParentStyle
+    rtl::OUString sBaseStyle;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParentStyle") ) ) >>= sBaseStyle;
+    if( sBaseStyle.getLength() > 0 )
+    {
+        uno::Reference< XCollection > xCol( new SwVbaStyles( this, mxContext, mxModel ) );
+        return xCol->Item( uno::makeAny( sBaseStyle ), uno::Any() );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Any();
+}
+
+void SAL_CALL SwVbaStyle::setBaseStyle( const uno::Any& _basestyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XStyle > xStyle;
+    _basestyle >>= xStyle;
+    if( xStyle.is() )
+    {
+        rtl::OUString sBaseStyle = xStyle->getName();
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParentStyle") ), uno::makeAny( sBaseStyle ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+uno::Any SAL_CALL SwVbaStyle::getNextParagraphStyle() throw (uno::RuntimeException)
+{
+    //FollowStyle
+    rtl::OUString sFollowStyle;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FollowStyle") ) ) >>= sFollowStyle;
+    if( sFollowStyle.getLength() > 0 )
+    {
+        uno::Reference< XCollection > xCol( new SwVbaStyles( this, mxContext, mxModel ) );
+        return xCol->Item( uno::makeAny( sFollowStyle ), uno::Any() );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+    return uno::Any();
+}
+
+void SAL_CALL SwVbaStyle::setNextParagraphStyle( const uno::Any& _nextparagraphstyle ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XStyle > xStyle;
+    _nextparagraphstyle >>= xStyle;
+    if( xStyle.is() )
+    {
+        rtl::OUString sFollowStyle = xStyle->getName();
+        mxStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FollowStyle") ), uno::makeAny( sFollowStyle ) );
+    }
+    else
+    {
+        throw uno::RuntimeException();
+    }
+}
+
+::sal_Int32 SAL_CALL SwVbaStyle::getListLevelNumber() throw (uno::RuntimeException)
+{
+    sal_Int16 nNumberingLevel = 0;
+    mxStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingLevel") ) ) >>= nNumberingLevel;
+    return nNumberingLevel;
+}
+
 rtl::OUString&
 SwVbaStyle::getServiceImplName()
 {
--- sw/source/ui/vba/vbastyle.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbastyle.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -36,6 +36,7 @@
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/style/XStyle.hpp>
 #include <ooo/vba/word/XFont.hpp>
+#include <ooo/vba/word/XListTemplate.hpp>
 
 
 typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XStyle > SwVbaStyle_BASE;
@@ -43,13 +44,14 @@ typedef InheritedHelperInterfaceImpl1< o
 class SwVbaStyle : public SwVbaStyle_BASE
 {
 private:
+	css::uno::Reference< css::frame::XModel > mxModel;
 	css::uno::Reference< css::beans::XPropertySet > mxStyleProps;
 	css::uno::Reference< css::style::XStyle > mxStyle;
 public:
-	SwVbaStyle( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& _xPropertySet ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
+	SwVbaStyle( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& _xPropertySet ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
 	virtual ~SwVbaStyle(){}
 
-    static void setStyle( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, const css::uno::Reference< ooo::vba::word::XStyle >& xStyle ) throw (css::uno::RuntimeException);
+    static void setStyle( const css::uno::Reference< css::beans::XPropertySet >& xParaProps, const css::uno::Any& xStyle ) throw (css::uno::RuntimeException);
     static rtl::OUString getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType );
     static sal_Int32 getLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps ) throw (css::uno::RuntimeException);
     static void setLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, sal_Int32 _languageid ) throw (css::uno::RuntimeException);
@@ -61,6 +63,20 @@ public:
     virtual void SAL_CALL setLanguageID( ::sal_Int32 _languageid ) throw (css::uno::RuntimeException);
     virtual ::sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL LinkToListTemplate( const css::uno::Reference< ooo::vba::word::XListTemplate >& ListTemplate, const css::uno::Any& ListLevelNumber ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getNameLocal() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNameLocal( const ::rtl::OUString& _namelocal ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutomaticallyUpdate() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutomaticallyUpdate( ::sal_Bool _automaticallyupdate ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getBaseStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBaseStyle( const css::uno::Any& _basestyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getNextParagraphStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNextParagraphStyle( const css::uno::Any& _nextparagraphstyle ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getListLevelNumber() throw (css::uno::RuntimeException);
+
+    //XDefaultProperty
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return rtl::OUString::createFromAscii("Name"); }
 
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
--- sw/source/ui/vba/vbastyles.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbastyles.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,7 +47,7 @@ struct BuiltinStyleTable
     sal_Int32 wdStyleType;
 };
 
-const BuiltinStyleTable aBuiltinStyleTable[] =
+static const BuiltinStyleTable aBuiltinStyleTable[] =
 {
     { word::WdBuiltinStyle::wdStyleBlockQuotation, "", word::WdStyleType::wdStyleTypeParagraph },
     { word::WdBuiltinStyle::wdStyleBodyText, "Text body", word::WdStyleType::wdStyleTypeParagraph },
@@ -155,6 +155,18 @@ const BuiltinStyleTable aBuiltinStyleTab
     { 0, 0, 0 }
 };
 
+struct MSOStyleNameTable
+{
+    const sal_Char* pMSOStyleName;
+    const sal_Char* pOOoStyleName;
+    const sal_Char* pOOoStyleType;
+};
+
+static const MSOStyleNameTable aMSOStyleNameTable[] =
+{
+    { "Normal", "Default", "ParagraphStyles" },
+    { 0, 0, 0 }
+};
 
 static uno::Sequence< rtl::OUString > getStyleTypes()
 {
@@ -168,38 +180,21 @@ static uno::Sequence< rtl::OUString > ge
 
 typedef ::cppu::WeakImplHelper1< container::XEnumeration > StyleEnumeration_BASE;
 typedef ::cppu::WeakImplHelper3< container::XNameAccess, container::XIndexAccess, container::XEnumerationAccess > StyleCollectionHelper_BASE;
-/*
-class StylesEnumeration : public StyleEnumeration_BASE
-{
-public:
-	StylesEnumeration( const SheetMap& sMap ) : mSheetMap( sMap ), mIt( mSheetMap.begin() ) {}
-	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
-	{
-		return ( mIt != mSheetMap.end() );
-	}
-	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-	{
-		if ( !hasMoreElements() )
-			throw container::NoSuchElementException();
-		uno::Reference< sheet::XSpreadsheet > xSheet( *mIt++ );
-		return uno::makeAny( xSheet ) ;
-	}
-};
-*/
+
 class StyleCollectionHelper : public StyleCollectionHelper_BASE
 {
 private:
     uno::Reference< frame::XModel > mxModel;
-    uno::Reference< container::XNameAccess > mxStyleFamilies;
-    uno::Reference< container::XNameContainer > mxCurrentStyleFamily;
+    uno::Reference< container::XNameAccess > mxParaStyles;
     uno::Any cachePos;
 public:
 	StyleCollectionHelper( const uno::Reference< frame::XModel >& _xModel ) : mxModel( _xModel )
     {
+        // we only concern about the Paragraph styles
         uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( _xModel, uno::UNO_QUERY_THROW);
-        mxStyleFamilies = xStyleSupplier->getStyleFamilies();
+        uno::Reference< container::XNameAccess > xStyleFamilies = xStyleSupplier->getStyleFamilies();
+        mxParaStyles.set( xStyleFamilies->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") ) ), uno::UNO_QUERY_THROW  );
     }
-    uno::Reference< container::XNameContainer > getCurrentStyleFamily(){ return mxCurrentStyleFamily; }
 	// XElementAccess
 	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  style::XStyle::static_type(0); }
 	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0; }
@@ -212,32 +207,42 @@ public:
 	}
 	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
 	{
-		uno::Sequence< rtl::OUString > sNames( getCount() );
-		rtl::OUString* pString = sNames.getArray();
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        sal_Int32 nCount = 0;
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        return mxParaStyles->getElementNames();
+	}
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        // search in the MSOStyleName table first
+        for( const MSOStyleNameTable* pTable = aMSOStyleNameTable; pTable->pMSOStyleName != NULL; pTable++ )
         {
-            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            uno::Sequence< rtl::OUString > sElementNames = xNameAccess->getElementNames();
-            for( sal_Int32 j = 0; j < sElementNames.getLength(); j++ )
+            if( aName.equalsIgnoreAsciiCaseAscii( pTable->pMSOStyleName ) )
             {
-                pString[nCount++] = sElementNames[j];
+                //Found it
+                rtl::OUString sStyleName = rtl::OUString::createFromAscii( pTable->pOOoStyleName );
+                if( mxParaStyles->hasByName( sStyleName ) )
+                {
+                    cachePos = mxParaStyles->getByName( sStyleName );
+                    return sal_True;
+                }
+                return sal_False;
             }
         }
-		return sNames;
-	}
-	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
-	{
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+
+        if( mxParaStyles->hasByName( aName ) )
+        {
+            cachePos = mxParaStyles->getByName( aName );
+            return sal_True;
+        }
+        else
         {
-            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            if( xNameAccess->hasByName( aName ) )
+            uno::Sequence< rtl::OUString > sElementNames = mxParaStyles->getElementNames();
+            for( sal_Int32 j = 0; j < sElementNames.getLength(); j++ )
             {
-                cachePos = xNameAccess->getByName( aName );
-                mxCurrentStyleFamily.set( xNameAccess, uno::UNO_QUERY_THROW );
-                return sal_True;
+                rtl::OUString aStyleName = sElementNames[j];
+                if( aStyleName.equalsIgnoreAsciiCase( aName ) )
+                {
+                    cachePos = mxParaStyles->getByName( aStyleName );
+                    return sal_True;
+                }
             }
         }
         return sal_False;
@@ -246,44 +251,43 @@ public:
 	// XIndexAccess
 	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
     { 
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        sal_Int32 nCount = 0;
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
-        {
-            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            nCount += xIndexAccess->getCount();
-        }
-        return nCount;
+        uno::Reference< container::XIndexAccess > xIndexAccess( mxParaStyles, uno::UNO_QUERY_THROW );
+        return xIndexAccess->getCount();
     }	
 	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
 	{
 		if ( Index < 0 || Index >= getCount() )
 			throw lang::IndexOutOfBoundsException();
 	
-        // FIXME: need to make a alphabetically sorted list of style names
-        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
-        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
-        {
-            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
-            sal_Int32 nCount = xIndexAccess->getCount();
-            if( Index >= nCount )
-                Index -= nCount;
-            else
-            {
-                mxCurrentStyleFamily.set( xIndexAccess, uno::UNO_QUERY_THROW );
-                return xIndexAccess->getByIndex( Index );
-            }
-        }
-		throw lang::IndexOutOfBoundsException();
+        uno::Reference< container::XIndexAccess > xIndexAccess( mxParaStyles, uno::UNO_QUERY_THROW );
+        return xIndexAccess->getByIndex( Index );
 	}
 	// XEnumerationAccess
 	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
 	{
-        // FIXME:
         throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 	}
 };
 
+class StylesEnumWrapper : public EnumerationHelper_BASE
+{
+    SwVbaStyles* pStyles;
+	sal_Int32 nIndex;
+public:
+	StylesEnumWrapper( SwVbaStyles* _pStyles ) : pStyles( _pStyles ), nIndex( 1 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex <= pStyles->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex <= pStyles->getCount() )
+			return pStyles->Item( uno::makeAny( nIndex++ ), uno::Any() );
+		throw container::NoSuchElementException();
+	}
+};
+
 SwVbaStyles::SwVbaStyles( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< css::uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ) throw ( script::BasicErrorException ) : SwVbaStyles_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new StyleCollectionHelper( xModel )  ) ), mxModel( xModel )
 {
     mxMSF.set( mxModel, uno::UNO_QUERY_THROW );
@@ -293,7 +297,7 @@ uno::Any
 SwVbaStyles::createCollectionObject(const uno::Any& aObject)
 {
     uno::Reference< beans::XPropertySet > xStyleProp( aObject, uno::UNO_QUERY_THROW );
-    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProp ) ) );
+    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, mxModel, xStyleProp ) ) );
 }
 
 uno::Type SAL_CALL 
@@ -305,7 +309,7 @@ SwVbaStyles::getElementType() throw (uno
 uno::Reference< container::XEnumeration > SAL_CALL 
 SwVbaStyles::createEnumeration() throw (uno::RuntimeException)
 {
-    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    return new StylesEnumWrapper( this );
 }
 
 uno::Any SAL_CALL
@@ -322,7 +326,8 @@ SwVbaStyles::Item( const uno::Any& Index
                 rtl::OUString aStyleName = rtl::OUString::createFromAscii( pTable->pOOoStyleName );
                 if( aStyleName.getLength() > 0 )
                 {
-                    rtl::OUString aStyleType = SwVbaStyle::getOOoStyleTypeFromMSWord( pTable->wdStyleType );
+                    //rtl::OUString aStyleType = SwVbaStyle::getOOoStyleTypeFromMSWord( pTable->wdStyleType );
+                    rtl::OUString aStyleType;
                     switch( pTable->wdStyleType )
                     {
                         case word::WdStyleType::wdStyleTypeParagraph:
@@ -338,7 +343,8 @@ SwVbaStyles::Item( const uno::Any& Index
                         }
                         case word::WdStyleType::wdStyleTypeList:
                         {
-                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") );
+                            // should use Paragraph style and set the property "NumberingStyleName"
+                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") );
                             break;
                         }
                         default:
@@ -347,7 +353,12 @@ SwVbaStyles::Item( const uno::Any& Index
                     uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxModel, uno::UNO_QUERY_THROW);
                     uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
                     uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
-                    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ) );
+                    // set the property "NumberingStyleName" if it is a listbullet
+                    if( pTable->wdStyleType == word::WdStyleType::wdStyleTypeList )
+                    {
+                        xStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyleName") ), uno::makeAny( aStyleName ) );
+                    }
+                    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, mxModel, xStyleProps ) ) );
                 }
                 else
                 {
--- sw/source/ui/vba/vbasystem.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbasystem.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -37,6 +37,13 @@
 #include <tools/urlobj.hxx>
 #include <tools/string.hxx>
 
+#ifdef WNT
+#include <tools/prewin.h>
+#include <windows.h>
+#include <tools/postwin.h>
+#include <tchar.h>
+#endif
+
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
@@ -55,13 +62,79 @@ void PrivateProfileStringListener::Initi
     maGroupName = rGroupName;
     maKey = rKey;
 }
+#ifdef WNT
+void lcl_getRegKeyInfo( const ByteString& sKeyInfo, HKEY& hBaseKey, ByteString& sSubKey )
+{
+    sal_Int32 nBaseKeyIndex = sKeyInfo.Search('\\');
+    if( nBaseKeyIndex > 0 )
+    {
+        ByteString sBaseKey = sKeyInfo.Copy( 0, nBaseKeyIndex );
+        sSubKey = sKeyInfo.Copy( nBaseKeyIndex + 1 );        
+        if( sBaseKey.Equals("HKEY_CURRENT_USER") )
+        {
+            hBaseKey = HKEY_CURRENT_USER;
+        }
+        else if( sBaseKey.Equals("HKEY_LOCAL_MACHINE") )
+        {
+            hBaseKey = HKEY_LOCAL_MACHINE;
+        }
+        else if( sBaseKey.Equals("HKEY_CLASSES_ROOT") )
+        {
+            hBaseKey = HKEY_CLASSES_ROOT;
+        }
+        else if( sBaseKey.Equals("HKEY_USERS") )
+        {
+            hBaseKey = HKEY_USERS;
+        }
+        else if( sBaseKey.Equals("HKEY_CURRENT_CONFIG") )
+        {
+            hBaseKey = HKEY_CURRENT_CONFIG;
+        }
+    }
+}
+#endif
 
 uno::Any PrivateProfileStringListener::getValueEvent()
 {
     // get the private profile string
-    Config aCfg( maFileName );
-    aCfg.SetGroup( maGroupName );
-    rtl::OUString sValue = String( aCfg.ReadKey( maKey ), RTL_TEXTENCODING_DONTKNOW );
+    rtl::OUString sValue;
+    if(maFileName.getLength())
+    {
+        // get key/value from a file
+        Config aCfg( maFileName );
+        aCfg.SetGroup( maGroupName );
+        sValue = String( aCfg.ReadKey( maKey ), RTL_TEXTENCODING_DONTKNOW );
+    }
+    else
+    {
+        // get key/value from windows register
+#ifdef WNT
+        HKEY hBaseKey = NULL;
+        ByteString sSubKey;
+        sal_Int32 nBaseKeyIndex = maGroupName.Search('\\');
+        lcl_getRegKeyInfo( maGroupName, hBaseKey, sSubKey );
+        if( hBaseKey != NULL )
+        {
+            HKEY hKey = NULL;
+            LONG lResult;
+            LPCTSTR lpSubKey = TEXT( sSubKey.GetBuffer());
+            TCHAR szBuffer[1024];
+            DWORD cbData = sizeof( szBuffer );
+            lResult = RegOpenKeyEx( hBaseKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKey );
+            if( ERROR_SUCCESS == lResult )
+            {
+                LPCTSTR lpValueName = TEXT(maKey.GetBuffer());
+                lResult = RegQueryValueEx( hKey, lpValueName, NULL, NULL, (LPBYTE)szBuffer, &cbData );
+                RegCloseKey( hKey );
+                sValue = rtl::OUString::createFromAscii(szBuffer);
+            }
+        }
+        
+        return uno::makeAny( sValue );
+#endif
+        throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Only support on Windows")), uno::Reference< uno::XInterface >() );
+    }    
 
     return uno::makeAny( sValue );
 }
@@ -69,12 +142,44 @@ uno::Any PrivateProfileStringListener::g
 void PrivateProfileStringListener::setValueEvent( const css::uno::Any& value )
 {
     // set the private profile string
-    Config aCfg( maFileName );
-    aCfg.SetGroup( maGroupName );
-
     rtl::OUString aValue;
     value >>= aValue;
-    aCfg.WriteKey( maKey, ByteString( aValue.getStr(), RTL_TEXTENCODING_DONTKNOW ) );
+    if(maFileName.getLength())
+    {
+        // set value into a file
+        Config aCfg( maFileName );
+        aCfg.SetGroup( maGroupName );    
+        aCfg.WriteKey( maKey, ByteString( aValue.getStr(), RTL_TEXTENCODING_DONTKNOW ) );
+    }
+    else
+    {
+        //set value into windows register
+#ifdef WNT
+        HKEY hBaseKey = NULL;
+        ByteString sSubKey;
+        sal_Int32 nBaseKeyIndex = maGroupName.Search('\\');
+        lcl_getRegKeyInfo( maGroupName, hBaseKey, sSubKey );
+        if( hBaseKey != NULL )
+        {
+            HKEY hKey = NULL;
+            LONG lResult;
+            LPCTSTR lpSubKey = TEXT( sSubKey.GetBuffer());            
+            lResult = RegCreateKeyEx( hBaseKey, lpSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL );
+            if( ERROR_SUCCESS == lResult )
+            {
+                LPCTSTR szValue = TEXT( rtl::OUStringToOString( aValue, RTL_TEXTENCODING_UTF8 ).getStr() );
+                DWORD cbData = sizeof(TCHAR) * (_tcslen(szValue) + 1);
+                LPCTSTR lpValueName = TEXT(maKey.GetBuffer());                 
+                lResult = RegSetValueEx( hKey, lpValueName, NULL, REG_SZ, (LPBYTE)szValue, cbData );
+                RegCloseKey( hKey );
+            }
+        }
+        return;
+#endif
+        throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Not implemented")), uno::Reference< uno::XInterface >() );
+    }
+    
 }
 
 SwVbaSystem::SwVbaSystem( uno::Reference<uno::XComponentContext >& xContext ): SwVbaSystem_BASE( uno::Reference< XHelperInterface >(), xContext )
@@ -154,19 +259,19 @@ SwVbaSystem::setCursor( sal_Int32 _curso
 uno::Any SAL_CALL 
 SwVbaSystem::PrivateProfileString( const rtl::OUString& rFilename, const rtl::OUString& rSection, const rtl::OUString& rKey ) throw ( uno::RuntimeException )
 {
-    if( rFilename.getLength() == 0 )
-        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
-
     // FIXME: need to detect whether it is a relative file path
     // we need to detect if this is a URL, if not then assume its a file path
     rtl::OUString sFileUrl;
-    INetURLObject aObj;
-	aObj.SetURL( rFilename );
-	bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
-	if ( bIsURL )
-		sFileUrl = rFilename;
-	else
-		osl::FileBase::getFileURLFromSystemPath( rFilename, sFileUrl);
+    if( rFilename.getLength() )
+    {
+        INetURLObject aObj;
+	    aObj.SetURL( rFilename );
+	    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+	    if ( bIsURL )
+		    sFileUrl = rFilename;
+	    else
+		    osl::FileBase::getFileURLFromSystemPath( rFilename, sFileUrl);
+    }    
 
     ByteString aGroupName = ByteString( rSection.getStr(), RTL_TEXTENCODING_DONTKNOW);
     ByteString aKey = ByteString( rKey.getStr(), RTL_TEXTENCODING_DONTKNOW);
--- sw/source/ui/vba/vbatable.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbatable.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -9,11 +9,13 @@
 #include <com/sun/star/container/XNamed.hpp>
 #include "vbaborders.hxx"
 #include "vbapalette.hxx"
+#include "vbarows.hxx"
+#include "vbacolumns.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-SwVbaTable::SwVbaTable(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const  uno::Reference< css::text::XTextTable >& xTextTable) throw ( uno::RuntimeException ) : SwVbaTable_BASE( rParent, rContext ), mxTextDocument( rDocument )
+SwVbaTable::SwVbaTable(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rDocument, const  uno::Reference< text::XTextTable >& xTextTable) throw ( uno::RuntimeException ) : SwVbaTable_BASE( rParent, rContext ), mxTextDocument( rDocument )
 {
     mxTextTable.set( xTextTable, uno::UNO_QUERY_THROW );
 }
@@ -73,6 +75,26 @@ SwVbaTable::Borders( const uno::Any& ind
     if ( index.hasValue() )
         return xCol->Item( index, uno::Any() );
     return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaTable::Rows( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< table::XTableRows > xTableRows( mxTextTable->getRows(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaRows( this, mxContext, mxTextTable, xTableRows ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaTable::Columns( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< table::XTableColumns > xTableColumns( mxTextTable->getColumns(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new SwVbaColumns( this, mxContext, mxTextTable, xTableColumns ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
 }
 
 // XHelperInterface
--- sw/source/ui/vba/vbatable.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbatable.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -21,6 +21,9 @@ public:
     virtual css::uno::Reference< ::ooo::vba::word::XRange > SAL_CALL ConvertToText( const css::uno::Any& Separator, const css::uno::Any& NestedTables ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getName( ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL Borders( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Rows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Columns( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
     // XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
--- sw/source/ui/vba/vbatablehelper.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatablehelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,306 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatablehelper.hxx"
+#include <swtable.hxx>
+#include <unotbl.hxx>
+#include <docsh.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+#define UNO_TABLE_COLUMN_SUM    10000
+
+SwVbaTableHelper::SwVbaTableHelper( const uno::Reference< text::XTextTable >& xTextTable ) throw (uno::RuntimeException) : mxTextTable( xTextTable ), pDoc( NULL )
+{
+    pTable = GetSwTable( mxTextTable );
+}
+
+SwTable* SwVbaTableHelper::GetSwTable( const uno::Reference< text::XTextTable >& xTextTable ) throw (uno::RuntimeException)
+{
+	uno::Reference< lang::XUnoTunnel > xTunnel( xTextTable, uno::UNO_QUERY_THROW );
+    SwXTextTable* pXTextTable = reinterpret_cast< SwXTextTable * >( sal::static_int_cast< sal_IntPtr >(xTunnel->getSomething(SwXTextTable::getUnoTunnelId())));
+    if( !pXTextTable )
+        throw uno::RuntimeException();
+        
+    SwFrmFmt* pFrmFmt = pXTextTable->GetFrmFmt();
+    if( !pFrmFmt )
+        throw uno::RuntimeException();
+    
+    SwTable* pTable = SwTable::FindTable( pFrmFmt );
+    return pTable;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColumnsCount( sal_Int32 nRowIndex ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    if(!pTable->IsTblComplex())
+    {
+        SwTableLines& rLines = pTable->GetTabLines();
+        SwTableLine* pLine = rLines.GetObject( nRowIndex );
+        nRet = pLine->GetTabBoxes().Count();
+    }    
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColumnsMaxCount( ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    //sal_Int32 nRowCount = mxTextTable->getRows()->getCount();
+    sal_Int32 nRowCount = pTable->GetTabLines().Count();
+    for( sal_Int32 index = 0; index < nRowCount; index++ )
+    {
+        sal_Int32 nColCount = getTabColumnsCount( index );
+        if( nRet < nColCount )
+            nRet = nColCount;
+    }
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabRowIndex( const rtl::OUString& CellName ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    String sCellName(CellName);
+    SwTableBox* pBox = (SwTableBox*)pTable->GetTblBox( sCellName );
+    if( !pBox )
+        throw uno::RuntimeException();
+        
+    const SwTableLine* pLine = pBox->GetUpper();
+    const SwTableLines* pLines = pLine->GetUpper()
+                     ? &pLine->GetUpper()->GetTabLines() : &pTable->GetTabLines();
+    nRet = pLines->GetPos( pLine );
+    return nRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTabColIndex( const rtl::OUString& CellName ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRet = 0;
+    String sCellName(CellName);
+    const SwTableBox* pBox = (SwTableBox*)pTable->GetTblBox( sCellName );
+    if( !pBox )
+        throw uno::RuntimeException();
+    const SwTableBoxes* pBoxes = &pBox->GetUpper()->GetTabBoxes();
+    nRet = pBoxes->GetPos( pBox );
+    return nRet;
+}
+
+rtl::OUString SwVbaTableHelper::getColumnStr( sal_Int32 nCol )
+{
+    const sal_Int32 coDiff = 52; // 'A'-'Z' 'a' - 'z'
+    sal_Int32 nCalc = 0;
+
+    String sRet;
+    do{
+        nCalc = nCol % coDiff;
+        if( nCalc >= 26 )
+            sRet.Insert( sal_Unicode('a' - 26 + nCalc ), 0 );
+        else    
+            sRet.Insert( sal_Unicode('A' + nCalc ), 0 );
+        
+        if( 0 == ( nCol = nCol - nCalc ) )
+            break;
+        nCol /= coDiff;
+        --nCol;
+    }while(1);
+    return sRet;
+}
+
+sal_Int32 SwVbaTableHelper::getTableWidth( ) throw (uno::RuntimeException)
+{
+    sal_Int32 nWidth = 0;
+    sal_Bool isWidthRelatvie = sal_False; 
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsWidthRelative") ) ) >>= isWidthRelatvie;
+    if( isWidthRelatvie )
+    {
+        xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RelativeWidth") ) ) >>= nWidth;
+    }
+    else
+    {
+        xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nWidth;
+    }
+    return nWidth;
+}
+
+void SwVbaTableHelper::setTableWidth( sal_Int32 _width ) throw (uno::RuntimeException)
+{
+    sal_Bool isWidthRelatvie = sal_False;
+    uno::Reference< beans::XPropertySet > xTableProps( mxTextTable, uno::UNO_QUERY_THROW );
+    xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsWidthRelative") ) ) >>= isWidthRelatvie;
+    if( isWidthRelatvie )
+    {
+        xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RelativeWidth") ), uno::makeAny( _width ));
+    }
+    else
+    {
+        xTableProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ), uno::makeAny( _width ) );
+    }
+}
+
+SwTableBox* SwVbaTableHelper::GetTabBox( sal_Int32 nCol, sal_Int32 nRow ) throw (css::uno::RuntimeException)
+{
+    SwTableLines& rLines = pTable->GetTabLines();
+    sal_Int32 nRowCount = rLines.Count();
+    if( nRowCount < nRow )
+        throw uno::RuntimeException();
+
+    SwTableBox* pStart = NULL;
+    SwTableLine* pLine = rLines.GetObject( nRow );
+    if( pLine->GetTabBoxes().Count() < nCol )
+        throw uno::RuntimeException();
+        
+    pStart = pLine->GetTabBoxes()[ nCol ];
+
+    if( !pStart )
+        throw uno::RuntimeException();
+    
+    return pStart;
+}
+
+void SwVbaTableHelper::InitTabCols( SwTabCols& rCols, const SwTableBox *pStart, BOOL bCurRowOnly )
+{
+	rCols.SetLeftMin ( 0 );
+	rCols.SetLeft    ( 0 );
+	rCols.SetRight   ( UNO_TABLE_COLUMN_SUM );
+	rCols.SetRightMax( UNO_TABLE_COLUMN_SUM );
+
+    //if( !pDoc )
+   // {
+     //   pDoc = word::getDocShell( getCurrentDocument() )->GetDoc();
+   // }
+	pTable->GetTabCols( rCols, pStart, sal_False, sal_False );
+}
+
+sal_Int32 SwVbaTableHelper::GetColCount( SwTabCols& rCols ) const
+{
+	sal_Int32 nCount = 0;
+    for(sal_Int32 i = 0; i < rCols.Count(); i++ )
+		if(rCols.IsHidden(i))
+			nCount ++;
+	return rCols.Count() - nCount;
+}
+
+sal_Int32 SwVbaTableHelper::GetRightSeparator( SwTabCols& rCols, sal_Int32 nNum) const
+{
+	DBG_ASSERT( nNum < (sal_Int32)GetColCount( rCols ) ,"Index out of range");
+	sal_Int32 i = 0;
+	while( nNum >= 0 )
+	{
+        if( !rCols.IsHidden( static_cast< USHORT >(i)) )
+			nNum--;
+		i++;
+	}
+	return i - 1;
+}
+
+sal_Int32 SwVbaTableHelper::GetColWidth( sal_Int32 nCol, sal_Int32 nRow, sal_Bool bCurRowOnly ) throw (uno::RuntimeException)
+{
+    SwTableBox* pStart = GetTabBox( nCol, nRow );
+	SwTabCols aCols;
+    InitTabCols( aCols, pStart, bCurRowOnly );
+    sal_Int32 nWidth = GetColWidth( aCols, nCol );
+
+    sal_Int32 nTableWidth = getTableWidth( );
+    double dAbsWidth = ( (double)nWidth / UNO_TABLE_COLUMN_SUM ) * (double) nTableWidth;
+    return ( sal_Int32 )Millimeter::getInPoints( dAbsWidth );
+}
+
+sal_Int32 SwVbaTableHelper::GetColWidth( SwTabCols& rCols, sal_Int32 nNum ) throw (uno::RuntimeException)
+{
+	SwTwips nWidth = 0;
+
+	if( rCols.Count() > 0 )
+	{
+		if(rCols.Count() == GetColCount( rCols ))
+		{
+			nWidth = (SwTwips)((nNum == rCols.Count()) ?
+					rCols.GetRight() - rCols[nNum-1] :
+					nNum == 0 ? rCols[nNum] - rCols.GetLeft() :
+								rCols[nNum] - rCols[nNum-1]);
+		}
+		else
+		{
+			SwTwips nRValid = nNum < GetColCount( rCols ) ?
+							rCols[(USHORT)GetRightSeparator( rCols, nNum)]:
+									rCols.GetRight();
+			SwTwips nLValid = nNum ?
+							rCols[(USHORT)GetRightSeparator( rCols, nNum - 1)]:
+									rCols.GetLeft();
+			nWidth = nRValid - nLValid;
+		}
+	}
+	else
+		nWidth = rCols.GetRight();
+
+	return nWidth;
+}
+
+void SwVbaTableHelper::SetColWidth( sal_Int32 _width, sal_Int32 nCol, sal_Int32 nRow, sal_Bool bCurRowOnly ) throw (css::uno::RuntimeException)
+{
+    double dAbsWidth = Millimeter::getInHundredthsOfOneMillimeter( _width );
+    sal_Int32 nTableWidth = getTableWidth( );
+    sal_Int32 nNewWidth = (sal_Int32)( dAbsWidth/nTableWidth * UNO_TABLE_COLUMN_SUM );
+
+    SwTableBox* pStart = GetTabBox( nCol, nRow );
+	SwTabCols aOldCols;
+    InitTabCols( aOldCols, pStart, bCurRowOnly );
+
+	//BOOL bCurRowOnly = FALSE;
+	SwTwips nWidth = 0;
+
+    SwTabCols aCols( aOldCols );
+	if ( aCols.Count() > 0 )
+	{
+	//	if(aCols.Count() != GetColCount( aCols ))
+	//		bCurRowOnly = TRUE;
+		nWidth = GetColWidth( aCols, nCol);
+
+		int nDiff = (int)(nNewWidth - nWidth);
+		if( !nCol )
+            aCols[ static_cast< USHORT >(GetRightSeparator(aCols, 0)) ] += nDiff;
+		else if( nCol < GetColCount( aCols )  )
+		{
+			if(nDiff < GetColWidth( aCols, nCol + 1) - MINLAY)
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol)) ] += nDiff;
+			else
+			{
+				int nDiffLeft = nDiff - (int)GetColWidth( aCols, nCol + 1) + (int)MINLAY;
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol)) ] += (nDiff - nDiffLeft);
+                aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol - 1)) ] -= nDiffLeft;
+			}
+		}
+		else
+            aCols[ static_cast< USHORT >(GetRightSeparator( aCols, nCol-1)) ] -= nDiff;
+	}
+	else
+		aCols.SetRight( Min( (long)nNewWidth, aCols.GetRightMax()) );
+
+    //pDoc->SetTabCols(*pTable, aCols, aOldCols, pStartBox, bCurRowOnly );
+    pTable->SetTabCols(aCols, aOldCols, pStart, bCurRowOnly );
+}
--- sw/source/ui/vba/vbatablehelper.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatablehelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_WORD_VBA_TABLEHELPER_HXX
+#define SW_WORD_VBA_TABLEHELPER_HXX
+
+#include <com/sun/star/text/XTextTable.hpp>
+#include "wordvbahelper.hxx"
+#include <swtable.hxx>
+#include <tabcol.hxx>
+#include <doc.hxx>
+
+class SwVbaTableHelper 
+{
+private:
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+    SwTable* pTable;
+    SwDoc* pDoc;
+
+private:
+    SwTableBox* GetTabBox( sal_Int32 nCol, sal_Int32 nRow ) throw (css::uno::RuntimeException);
+	void    InitTabCols( SwTabCols& rCols, const SwTableBox *pStart, sal_Bool bCurRowOnly  = FALSE );
+    sal_Int32 GetRightSeparator( SwTabCols& rCols, sal_Int32 nNum) const;
+	sal_Int32 GetColCount( SwTabCols& rCols ) const;
+    sal_Int32 GetColWidth( SwTabCols& rCols, sal_Int32 nNum ) throw (css::uno::RuntimeException);
+    
+public:
+    SwVbaTableHelper( const css::uno::Reference< css::text::XTextTable >& xTextTable ) throw (css::uno::RuntimeException);
+    ~SwVbaTableHelper() {}
+    sal_Int32 getTabColumnsCount( sal_Int32 nRowIndex ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabColumnsMaxCount( ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabRowIndex( const rtl::OUString& sCellName ) throw (css::uno::RuntimeException);
+    sal_Int32 getTabColIndex( const rtl::OUString& sCellName ) throw (css::uno::RuntimeException);
+    sal_Int32 getTableWidth( ) throw (css::uno::RuntimeException);
+    void  setTableWidth( sal_Int32 _width ) throw (css::uno::RuntimeException);
+
+    sal_Int32 GetColWidth( sal_Int32 nCol, sal_Int32 nRow = 0, sal_Bool bCurRowOnly  = FALSE ) throw (css::uno::RuntimeException);
+    void SetColWidth( sal_Int32 _width, sal_Int32 nCol, sal_Int32 nRow = 0, sal_Bool bCurRowOnly  = FALSE ) throw (css::uno::RuntimeException);
+
+    static SwTable* GetSwTable( const css::uno::Reference< css::text::XTextTable >& xTextTable ) throw (css::uno::RuntimeException);
+    static rtl::OUString getColumnStr( sal_Int32 nCol );
+};
+
+#endif
--- sw/source/ui/vba/vbatableofcontents.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatableofcontents.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatableofcontents.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdTabLeader.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTableOfContents::SwVbaTableOfContents( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xDoc, const uno::Reference< text::XDocumentIndex >& xDocumentIndex ) throw ( uno::RuntimeException ) :
+    SwVbaTableOfContents_BASE( rParent, rContext ), mxTextDocument( xDoc ), mxDocumentIndex( xDocumentIndex )
+{
+    mxTocProps.set( mxDocumentIndex, uno::UNO_QUERY_THROW );
+}
+
+
+SwVbaTableOfContents::~SwVbaTableOfContents()
+{
+}
+
+::sal_Int32 SAL_CALL SwVbaTableOfContents::getLowerHeadingLevel() throw (uno::RuntimeException)
+{
+    sal_Int16 nLevel = 0;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Level") ) ) >>= nLevel;
+    return nLevel;
+}
+
+void SAL_CALL SwVbaTableOfContents::setLowerHeadingLevel( ::sal_Int32 _lowerheadinglevel ) throw (uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Level") ), uno::makeAny( sal_Int8( _lowerheadinglevel ) ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaTableOfContents::getTabLeader() throw (uno::RuntimeException)
+{
+    // not support in Writer
+    return word::WdTabLeader::wdTabLeaderDots;
+}
+
+void SAL_CALL SwVbaTableOfContents::setTabLeader( ::sal_Int32 /*_tableader*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaTableOfContents::getUseFields() throw (css::uno::RuntimeException)
+{
+    sal_Bool bUseFields = sal_False;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromMarks") ) ) >>= bUseFields;
+    return bUseFields;
+}
+
+void SAL_CALL SwVbaTableOfContents::setUseFields( ::sal_Bool _useFields ) throw (css::uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromMarks") ), uno::makeAny( _useFields ) );
+}
+
+::sal_Bool SAL_CALL SwVbaTableOfContents::getUseOutlineLevels() throw (css::uno::RuntimeException)
+{
+    sal_Bool bUseOutlineLevels = sal_False;
+    mxTocProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromOutline") ) ) >>= bUseOutlineLevels;
+    return bUseOutlineLevels;
+}
+
+void SAL_CALL SwVbaTableOfContents::setUseOutlineLevels( ::sal_Bool _useOutlineLevels ) throw (css::uno::RuntimeException)
+{
+    mxTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CreateFromOutline") ), uno::makeAny( _useOutlineLevels ) );
+}
+
+void SAL_CALL SwVbaTableOfContents::Delete(  ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextContent > xTextContent( mxDocumentIndex, uno::UNO_QUERY_THROW );
+    mxTextDocument->getText()->removeTextContent( xTextContent );
+}
+
+void SAL_CALL SwVbaTableOfContents::Update(  ) throw (uno::RuntimeException)
+{
+    mxDocumentIndex->update();
+}
+
+rtl::OUString& 
+SwVbaTableOfContents::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTableOfContents") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaTableOfContents::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TableOfContents" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbatableofcontents.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatableofcontents.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABLEOFCONTENTS_HXX
+#define SW_VBA_TABLEOFCONTENTS_HXX
+
+#include <ooo/vba/word/XTableOfContents.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XDocumentIndex.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTableOfContents > SwVbaTableOfContents_BASE;
+
+class SwVbaTableOfContents : public SwVbaTableOfContents_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XDocumentIndex > mxDocumentIndex;
+    css::uno::Reference< css::beans::XPropertySet > mxTocProps;
+
+public:
+	SwVbaTableOfContents( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xDoc, const css::uno::Reference< css::text::XDocumentIndex >& xDocumentIndex ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTableOfContents();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getLowerHeadingLevel() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLowerHeadingLevel( ::sal_Int32 _lowerheadinglevel ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getTabLeader() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTabLeader( ::sal_Int32 _tableader ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUseFields() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUseFields( ::sal_Bool _useFields ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getUseOutlineLevels() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUseOutlineLevels( ::sal_Bool _useOutlineLevels ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Update(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_TABLEOFCONTENTS_HXX */
--- sw/source/ui/vba/vbatables.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbatables.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -4,6 +4,9 @@
 #include <com/sun/star/text/XTextTable.hpp>
 #include <com/sun/star/text/XTextTablesSupplier.hpp>
 #include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
 #include <comphelper/componentcontext.hxx>
 
 using namespace ::ooo::vba;
@@ -26,7 +29,89 @@ uno::Any lcl_createTable( const uno::Ref
     return uno::makeAny( xTable );
 }
 
+sal_Bool lcl_isInHeaderFooter( const uno::Reference< text::XTextTable >& xTable )
+{
+    uno::Reference< text::XTextContent > xTextContent( xTable, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XText > xText = xTextContent->getAnchor()->getText();
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xText, uno::UNO_QUERY_THROW );
+    rtl::OUString aImplName = xServiceInfo->getImplementationName();
+    if( aImplName.equalsAscii("SwXHeadFootText") )
+        return sal_True;
+    return sal_False;    
+}
+
 typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumBase;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XNameAccess > TableCollectionHelper_Base;
+typedef std::vector< uno::Reference< text::XTextTable > > XTextTableVec;
+
+class TableCollectionHelper : public TableCollectionHelper_Base
+{
+    XTextTableVec mxTables;
+    XTextTableVec::iterator cachePos;
+
+public:
+    TableCollectionHelper( const uno::Reference< frame::XModel >& xDocument )
+    {
+        // only count the tables in the body text, not in the header/footer
+        uno::Reference< container::XIndexAccess > xTables = lcl_getTables( xDocument );
+        sal_Int32 nCount = xTables->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XTextTable > xTable( xTables->getByIndex( i ) , uno::UNO_QUERY_THROW );
+            if( !lcl_isInHeaderFooter( xTable ) )
+                mxTables.push_back( xTable );
+        }
+        cachePos = mxTables.begin();
+    }
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxTables.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )
+            throw lang::IndexOutOfBoundsException();
+        uno::Reference< text::XTextTable > xTable( mxTables[ Index ], uno::UNO_QUERY_THROW );
+        return uno::makeAny( xTable );
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  text::XTextTable::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0 ; }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+        uno::Reference< text::XTextTable > xTable( *cachePos, uno::UNO_QUERY_THROW );
+        return uno::makeAny( xTable );
+    }
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+        uno::Sequence< rtl::OUString > sNames( mxTables.size() );
+        rtl::OUString* pString = sNames.getArray();
+        XTextTableVec::iterator it = mxTables.begin();
+        XTextTableVec::iterator it_end = mxTables.end();
+        for ( ; it != it_end; ++it, ++pString )
+        {
+            uno::Reference< container::XNamed > xName( *it, uno::UNO_QUERY_THROW );
+            *pString = xName->getName();
+        }
+        return sNames;
+    }
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        cachePos = mxTables.begin();
+        XTextTableVec::iterator it_end = mxTables.end();
+        for ( ; cachePos != it_end; ++cachePos )
+        {
+            uno::Reference< container::XNamed > xName( *cachePos, uno::UNO_QUERY_THROW );
+            if ( aName.equalsIgnoreAsciiCase( xName->getName() ) )
+                break;
+        }
+        return ( cachePos != it_end );
+    }
+};
 
 class TableEnumerationImpl : public EnumBase
 {
@@ -52,7 +137,7 @@ public:
     
 };
  
-SwVbaTables::SwVbaTables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument ) : SwVbaTables_BASE( xParent, xContext , lcl_getTables( xDocument ) ), mxDocument( xDocument )
+SwVbaTables::SwVbaTables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument ) : SwVbaTables_BASE( xParent, xContext , uno::Reference< container::XIndexAccess >( new TableCollectionHelper( xDocument ) ) ), mxDocument( xDocument )
 {
 }
 
@@ -85,6 +170,12 @@ SwVbaTables::Add( const uno::Reference<
     uno::Reference< text::XTextContent > xContext( xTable, uno::UNO_QUERY_THROW );     
     
     xText->insertTextContent( xTextRange, xContext, true );
+
+	// move the current cursor to the first table cell
+	uno::Reference< table::XCellRange > xCellRange( xTable, uno::UNO_QUERY_THROW );
+	uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	word::getXTextViewCursor( mxDocument )->gotoRange( xFirstCellText->getStart(), sal_False ); 
+    
     uno::Reference< word::XTable > xVBATable( new SwVbaTable( mxParent, mxContext,  pVbaRange->getDocument(), xTable ) );
     return xVBATable;
 }
--- sw/source/ui/vba/vbatablesofcontents.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatablesofcontents.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,197 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatablesofcontents.hxx"
+#include "vbatableofcontents.hxx"
+#include "vbarange.hxx"
+#include <com/sun/star/text/XDocumentIndexesSupplier.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > TableOfContentsCollectionHelper_Base;
+typedef std::vector< uno::Reference< text::XDocumentIndex > > XTocVec;
+
+class TablesOfContentsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	TablesOfContentsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class TableOfContentsCollectionHelper : public TableOfContentsCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< text::XTextDocument > mxTextDocument;
+    XTocVec maToc;
+
+public:
+	TableOfContentsCollectionHelper( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xDoc ) throw ( uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxTextDocument( xDoc )
+    {
+        uno::Reference< text::XDocumentIndexesSupplier > xDocIndexSupp( mxTextDocument, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xDocIndexes = xDocIndexSupp->getDocumentIndexes();
+        sal_Int32 nCount = xDocIndexes->getCount();
+        for( sal_Int32 i = 0; i < nCount; i++ )
+        {
+            uno::Reference< text::XDocumentIndex > xToc( xDocIndexes->getByIndex(i), uno::UNO_QUERY_THROW );
+            if( xToc->getServiceName().equalsAscii("com.sun.star.text.ContentIndex") )
+            {
+                maToc.push_back( xToc );
+            }
+        }
+    }
+
+	virtual ~TableOfContentsCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return maToc.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw lang::IndexOutOfBoundsException();
+        
+        uno::Reference< text::XDocumentIndex > xToc( maToc[Index], uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< word::XTableOfContents >( new SwVbaTableOfContents( mxParent, mxContext, mxTextDocument, xToc ) ) );
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XTableOfContents::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new TablesOfContentsEnumWrapper( this );
+    }
+};
+
+SwVbaTablesOfContents::SwVbaTablesOfContents( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xDoc ) throw (uno::RuntimeException) : SwVbaTablesOfContents_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new TableOfContentsCollectionHelper( xParent, xContext, xDoc ) ) ),  mxTextDocument( xDoc )
+{
+}
+
+uno::Reference< word::XTableOfContents > SAL_CALL 
+SwVbaTablesOfContents::Add( const uno::Reference< word::XRange >& Range, const uno::Any& UseHeadingStyles, const uno::Any& UpperHeadingLevel, const uno::Any& LowerHeadingLevel, const uno::Any& UseFields, const uno::Any& TableID, const uno::Any& RightAlignPageNumbers, const uno::Any& IncludePageNumbers, const uno::Any& AddedStyles, const uno::Any& UseHyperlinks, const uno::Any& HidePageNumbersInWeb, const uno::Any& UseOutlineLevels ) throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XDocumentIndex > xDocumentIndex( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.ContentIndex")) ), uno::UNO_QUERY_THROW );
+
+    uno::Reference< beans::XPropertySet > xTocProps( xDocumentIndex, uno::UNO_QUERY_THROW );
+    sal_Bool isProtected = sal_False;
+    xTocProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsProtected") ), uno::makeAny( isProtected ) );
+
+    uno::Reference< word::XTableOfContents > xToc( new SwVbaTableOfContents( this, mxContext, mxTextDocument, xDocumentIndex ) );
+    
+    sal_Int32 nLowerHeadingLevel = 9;
+    if( LowerHeadingLevel.hasValue() )
+        LowerHeadingLevel >>= nLowerHeadingLevel;
+    xToc->setLowerHeadingLevel( nLowerHeadingLevel );
+
+    sal_Bool bUseFields = sal_False;
+    if( UseFields.hasValue() )
+        UseFields >>= bUseFields;
+    xToc->setUseFields( bUseFields );
+
+    sal_Bool bUseOutlineLevels = sal_True;
+    //if( UseOutlineLevels.hasValue() )
+    //    UseOutlineLevels >>= bUseOutlineLevels;
+    xToc->setUseOutlineLevels( bUseOutlineLevels );
+
+    SwVbaRange* pVbaRange = dynamic_cast<SwVbaRange*>( Range.get() );
+    if( !pVbaRange )
+        throw uno::RuntimeException();
+    
+    uno::Reference< text::XTextRange > xTextRange = pVbaRange->getXTextRange();
+    uno::Reference< text::XText > xText = pVbaRange->getXText();
+    uno::Reference< text::XTextContent > xTextContent( xDocumentIndex, uno::UNO_QUERY_THROW );
+    xText->insertTextContent( xTextRange, xTextContent, sal_False );
+    xToc->Update();
+
+    return xToc;
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaTablesOfContents::getElementType() throw (uno::RuntimeException)
+{
+	return word::XTableOfContents::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaTablesOfContents::createEnumeration() throw (uno::RuntimeException)
+{
+    return new TablesOfContentsEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaTablesOfContents::createCollectionObject( const uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaTablesOfContents::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTablesOfContents") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaTablesOfContents::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TablesOfContents") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbatablesofcontents.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatablesofcontents.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABLESOFCONTENTS_HXX
+#define SW_VBA_TABLESOFCONTENTS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XTablesOfContents.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <ooo/vba/word/XTableOfContents.hpp>
+#include <ooo/vba/word/XRange.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XTablesOfContents > SwVbaTablesOfContents_BASE;
+
+class SwVbaTablesOfContents : public SwVbaTablesOfContents_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+
+public:
+	SwVbaTablesOfContents( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xDoc ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTablesOfContents() {}
+
+    // Methods
+    virtual css::uno::Reference< ::ooo::vba::word::XTableOfContents > SAL_CALL Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range, const css::uno::Any& UseHeadingStyles, const css::uno::Any& UpperHeadingLevel, const css::uno::Any& LowerHeadingLevel, const css::uno::Any& UseFields, const css::uno::Any& TableID, const css::uno::Any& RightAlignPageNumbers, const css::uno::Any& IncludePageNumbers, const css::uno::Any& AddedStyles, const css::uno::Any& UseHyperlinks, const css::uno::Any& HidePageNumbersInWeb, const css::uno::Any& UseOutlineLevels ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaTablesOfContents_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_TABLESOFCONTENTS_HXX */
--- sw/source/ui/vba/vbatabstop.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatabstop.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatabstop.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTabStop::SwVbaTabStop( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< beans::XPropertySet >& xParaProps, const style::TabStop& aTabStop ) throw ( uno::RuntimeException ) : SwVbaTabStop_BASE( rParent, rContext ), mxParaProps( xParaProps ), maTabStop( aTabStop )
+{
+}
+
+SwVbaTabStop::~SwVbaTabStop()
+{
+}
+
+rtl::OUString& 
+SwVbaTabStop::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTabStop") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaTabStop::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TabStop" ) );
+	}
+	return aServiceNames;
+}
+
--- sw/source/ui/vba/vbatabstop.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatabstop.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABSTOP_HXX
+#define SW_VBA_TABSTOP_HXX
+
+#include <ooo/vba/word/XTabStop.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/style/TabStop.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTabStop > SwVbaTabStop_BASE;
+
+class SwVbaTabStop : public SwVbaTabStop_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertySet > mxParaProps;
+    css::style::TabStop maTabStop;
+
+public:
+	SwVbaTabStop( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps, const css::style::TabStop& aTabStop ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTabStop();
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_TABSTOP_HXX */
--- sw/source/ui/vba/vbatabstops.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatabstops.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,280 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatabstops.hxx"
+#include "vbatabstop.hxx"
+#include <com/sun/star/style/TabAlign.hpp>
+#include <ooo/vba/word/WdTabLeader.hpp>
+#include <ooo/vba/word/WdTabAlignment.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+uno::Sequence< style::TabStop > lcl_getTabStops( const uno::Reference< beans::XPropertySet >& xParaProps ) throw (uno::RuntimeException)
+{
+    uno::Sequence< style::TabStop > aSeq;
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTabStops") ) ) >>= aSeq;
+    return aSeq;
+}
+
+void lcl_setTabStops( const uno::Reference< beans::XPropertySet >& xParaProps, const uno::Sequence< style::TabStop >& aSeq ) throw (uno::RuntimeException)
+{
+    xParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTabStops") ), uno::makeAny( aSeq ) );
+}
+
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > TabStopCollectionHelper_Base;
+
+class TabStopsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 nIndex;
+
+public:
+	TabStopsEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxIndexAccess( xIndexAccess ), nIndex( 0 )
+    {
+    }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < mxIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if( nIndex < mxIndexAccess->getCount() )
+        {
+            return mxIndexAccess->getByIndex( nIndex++ );
+        }
+		throw container::NoSuchElementException();
+	}
+};
+
+class TabStopCollectionHelper : public TabStopCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< beans::XPropertySet > mxParaProps;
+    uno::Sequence< style::TabStop > maTabStops;
+
+public:
+	TabStopCollectionHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps ) throw ( css::uno::RuntimeException ): mxParent( xParent ), mxContext( xContext ), mxParaProps( xParaProps )
+    {
+        maTabStops = lcl_getTabStops( xParaProps );
+    }
+
+	virtual ~TabStopCollectionHelper() {}
+
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return maTabStops.getLength();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw css::lang::IndexOutOfBoundsException();
+        
+        const style::TabStop* pTabs = maTabStops.getConstArray();
+        return uno::makeAny( uno::Reference< word::XTabStop >( new SwVbaTabStop( mxParent, mxContext, mxParaProps, pTabs[ Index ] ) ) );
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XTabStop::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new TabStopsEnumWrapper( this );
+    }
+};
+
+SwVbaTabStops::SwVbaTabStops( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& xParaProps ) throw (uno::RuntimeException) : SwVbaTabStops_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new TabStopCollectionHelper( xParent, xContext, xParaProps ) ) ), mxParaProps( xParaProps ) 
+{
+}
+
+uno::Reference< word::XTabStop > SAL_CALL SwVbaTabStops::Add( float Position, const uno::Any& Alignment, const uno::Any& Leader ) throw (uno::RuntimeException)
+{
+    sal_Int32 nPosition = Millimeter::getInHundredthsOfOneMillimeter( Position );
+
+    style::TabAlign nAlign = style::TabAlign_LEFT;
+    if( Alignment.hasValue() )
+    {
+        sal_Int32 wdAlign = word::WdTabAlignment::wdAlignTabLeft;
+        Alignment >>= wdAlign;
+        switch( wdAlign )
+        {
+            case word::WdTabAlignment::wdAlignTabLeft:
+            {
+                nAlign = style::TabAlign_LEFT;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabRight:
+            {
+                nAlign = style::TabAlign_RIGHT;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabCenter:
+            {
+                nAlign = style::TabAlign_CENTER;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabDecimal:
+            {
+                nAlign = style::TabAlign_DECIMAL;
+                break;
+            }
+            case word::WdTabAlignment::wdAlignTabBar:
+            case word::WdTabAlignment::wdAlignTabList:
+            {
+                DebugHelper::exception( SbERR_NOT_IMPLEMENTED, rtl::OUString() );
+                break;
+            }
+            default:
+            {
+                //left
+            }
+        }
+    }
+
+    sal_Char cLeader = ' '; // default is space
+    if( Leader.hasValue() )
+    {
+        sal_Int32 wdLeader = word::WdTabLeader::wdTabLeaderSpaces;
+        Leader >>= wdLeader;
+        switch( wdLeader )
+        {
+            case word::WdTabLeader::wdTabLeaderSpaces:
+            {
+                cLeader = ' ';
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderMiddleDot:
+            {
+                cLeader = 183;
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderDots:
+            {
+                cLeader = '.';
+                break;
+            }
+            case word::WdTabLeader::wdTabLeaderDashes:
+            case word::WdTabLeader::wdTabLeaderHeavy:
+            case word::WdTabLeader::wdTabLeaderLines:
+            {
+                cLeader = '_';
+                break;
+            }
+            default:
+            {
+                //left
+            }
+        }
+    }
+
+    sal_Char cDecimal = '.'; // default value
+
+    style::TabStop aTab;
+    aTab.Position = nPosition;
+    aTab.Alignment = nAlign;
+    aTab.DecimalChar = cDecimal;
+    aTab.FillChar = cLeader;
+
+    uno::Sequence< style::TabStop > aOldTabs = lcl_getTabStops( mxParaProps );
+    sal_Bool bOverWriter = sal_False;
+
+    sal_Int32 nTabs = aOldTabs.getLength();
+    uno::Sequence< style::TabStop > aNewTabs( nTabs + 1 );
+
+    style::TabStop* pOldTab = aOldTabs.getArray();
+    style::TabStop* pNewTab = aNewTabs.getArray();
+    pNewTab[0] = aTab;
+    for( sal_Int32 nIndex = 0; nIndex < nTabs && !bOverWriter; nIndex++ )
+    {
+        if( pOldTab[nIndex].Position == nPosition )
+        {
+            bOverWriter = sal_True;
+            pOldTab[nIndex] = aTab;
+            break;
+        }
+        pNewTab[ nIndex+1 ] = pOldTab[ nIndex ];
+    }
+    if( bOverWriter )
+        lcl_setTabStops( mxParaProps, aOldTabs );
+    else    
+        lcl_setTabStops( mxParaProps, aNewTabs );
+    
+    return uno::Reference< word::XTabStop >( new SwVbaTabStop( this, mxContext, mxParaProps, aTab ) );
+}
+
+void SAL_CALL SwVbaTabStops::ClearAll() throw (uno::RuntimeException)
+{
+    uno::Sequence< style::TabStop > aSeq;
+    lcl_setTabStops( mxParaProps, aSeq );
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaTabStops::getElementType() throw (uno::RuntimeException)
+{
+	return word::XTabStop::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaTabStops::createEnumeration() throw (uno::RuntimeException)
+{
+    return new TabStopsEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaTabStops::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaTabStops::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTabStops") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaTabStops::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.TabStops") );
+	}
+	return sNames;
+}
--- sw/source/ui/vba/vbatabstops.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ sw/source/ui/vba/vbatabstops.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,65 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TABSTOPS_HXX
+#define SW_VBA_TABSTOPS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XTabStops.hpp>
+#include <ooo/vba/word/XTabStop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XTabStops > SwVbaTabStops_BASE;
+
+class SwVbaTabStops : public SwVbaTabStops_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertySet > mxParaProps;
+
+public:
+	SwVbaTabStops( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& xParaProps ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaTabStops() {}
+
+    // Methods
+    virtual css::uno::Reference< ::ooo::vba::word::XTabStop > SAL_CALL Add( float Position, const css::uno::Any& Alignment, const css::uno::Any& Leader ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ClearAll(  ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaTabStops_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_TABSTOPS_HXX */
--- sw/source/ui/vba/vbatemplate.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbatemplate.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -33,12 +33,35 @@
 #include "vbaautotextentry.hxx"
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/text/XAutoTextContainer.hpp>
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-SwVbaTemplate::SwVbaTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rName )
-    : SwVbaTemplate_BASE( rParent, rContext ), mxModel( rModel ), msName( rName )
+String lcl_CheckGroupName( const String& rGroupName )
+{
+    String sRet;
+    //group name should contain only A-Z and a-z and spaces
+    for( xub_StrLen i = 0; i < rGroupName.Len(); i++ )
+    {
+        sal_Unicode cChar = rGroupName.GetChar(i);
+        if(	(cChar >= 'A' && cChar <= 'Z') ||
+            (cChar >= 'a' && cChar <= 'z') ||
+            (cChar >= '0' && cChar <= '9') ||
+            cChar == '_' || cChar == 0x20 )
+        {
+            sRet += cChar;
+        }
+    }
+    sRet.EraseLeadingChars();
+    sRet.EraseTrailingChars();
+	return sRet;
+}
+
+
+SwVbaTemplate::SwVbaTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rFullUrl )
+    : SwVbaTemplate_BASE( rParent, rContext ), mxModel( rModel ), msFullUrl( rFullUrl )
 {
 }
 
@@ -50,7 +73,27 @@ SwVbaTemplate::~SwVbaTemplate()
 rtl::OUString
 SwVbaTemplate::getName() throw ( css::uno::RuntimeException )
 {
-    return msName;
+    rtl::OUString sName;
+    if( msFullUrl.getLength() )
+    {
+        INetURLObject aURL( msFullUrl );
+        ::osl::File::getSystemPathFromFileURL( aURL.GetLastName(), sName );
+    }
+    return sName;
+}
+
+rtl::OUString
+SwVbaTemplate::getPath() throw ( css::uno::RuntimeException )
+{
+    rtl::OUString sPath;
+    if( msFullUrl.getLength() )
+    {
+        INetURLObject aURL( msFullUrl );
+        rtl::OUString sURL( aURL.GetMainURL( INetURLObject::DECODE_TO_IURI ) );
+        sURL = sURL.copy( 0, sURL.getLength() - aURL.GetLastName().getLength() - 1 );
+        ::osl::File::getSystemPathFromFileURL( sURL, sPath );
+    }
+    return sPath;
 }
 
 uno::Any SAL_CALL
@@ -61,17 +104,18 @@ SwVbaTemplate::AutoTextEntries( const un
 
     // the default template is "Normal.dot" in Word.
     rtl::OUString sGroup( RTL_CONSTASCII_USTRINGPARAM("Normal") );
-    sal_Int32 nIndex = msName.lastIndexOf( sal_Unicode('.') );
+    rtl::OUString sName = getName();
+    sal_Int32 nIndex = sName.lastIndexOf( sal_Unicode('.') );
     if( nIndex > 0 )
     {
-        sGroup = msName.copy( 0, msName.lastIndexOf( sal_Unicode('.') ) );
-       // OSL_TRACE("SwVbaTemplate::AutoTextEntries: %s", rtl::OUStringToOString( sGroup, RTL_TEXTENCODING_UTF8 ).getStr() );
+        sGroup = sName.copy( 0, sName.lastIndexOf( sal_Unicode('.') ) );
     }
-    
+	String sNewGroup = lcl_CheckGroupName( sGroup );
+
     uno::Reference< container::XIndexAccess > xGroup;
-    if( xAutoTextContainer->hasByName( sGroup ) )
+    if( xAutoTextContainer->hasByName( sNewGroup ) )
     {
-        xGroup.set( xAutoTextContainer->getByName( sGroup ), uno::UNO_QUERY_THROW );
+        xGroup.set( xAutoTextContainer->getByName( sNewGroup ), uno::UNO_QUERY_THROW );
     }
     else
     {
--- sw/source/ui/vba/vbatemplate.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbatemplate.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -39,7 +39,7 @@ class SwVbaTemplate : public SwVbaTempla
 {
 private:
     css::uno::Reference< css::frame::XModel > mxModel;
-    rtl::OUString msName;
+    rtl::OUString msFullUrl;
 public:
 	SwVbaTemplate( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
         const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& );
@@ -47,6 +47,7 @@ public:
 
    // XTemplate
     virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL AutoTextEntries( const css::uno::Any& index ) throw (css::uno::RuntimeException);
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
--- sw/source/ui/vba/vbaview.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbaview.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -95,20 +95,20 @@ SwVbaView::getSeekView() throw (css::uno
     }
     else if( aImplName.equalsAscii("SwXHeadFootText") )
     {
-        if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) )
+        if( HeaderFooterHelper::isHeader( mxModel ) )
         {
-            if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) )
+            if( HeaderFooterHelper::isFirstPageHeader( mxModel ) )
                 return word::WdSeekView::wdSeekFirstPageHeader;
-            else if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) )
+            else if( HeaderFooterHelper::isEvenPagesHeader( mxModel ) )
                 return word::WdSeekView::wdSeekEvenPagesHeader;
             else
                 return word::WdSeekView::wdSeekPrimaryHeader;
         }
         else
         {
-            if( HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+            if( HeaderFooterHelper::isFirstPageFooter( mxModel ) )
                 return word::WdSeekView::wdSeekFirstPageFooter;
-            else if( HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+            else if( HeaderFooterHelper::isEvenPagesFooter( mxModel ) )
                 return word::WdSeekView::wdSeekEvenPagesFooter;
             else
                 return word::WdSeekView::wdSeekPrimaryFooter;
@@ -135,6 +135,7 @@ SwVbaView::setSeekView( ::sal_Int32 _see
     // if( _seekview == getSeekView() )
     //    return;
 
+    word::gotoSelectedObjectAnchor( mxModel );
     switch( _seekview )
     {
         case word::WdSeekView::wdSeekFirstPageFooter:
@@ -184,7 +185,7 @@ SwVbaView::setSeekView( ::sal_Int32 _see
         {
             uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
             uno::Reference< text::XText > xText = xTextDocument->getText();
-            mxViewCursor->gotoRange( getFirstObjectPosition( xText ), sal_False );
+            mxViewCursor->gotoRange( word::getFirstObjectPosition( xText ), sal_False );
             break;
         }
     }
@@ -379,28 +380,7 @@ uno::Reference< text::XTextRange > SwVba
     {
         DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
     }
-    uno::Reference< text::XTextRange > xTextRange = getFirstObjectPosition( xText );
-    return xTextRange;
-}
-
-uno::Reference< text::XTextRange > SwVbaView::getFirstObjectPosition( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
-{
-    // if the first object is table, get the position of first cell 
-    uno::Reference< text::XTextRange > xTextRange;
-    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
-    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
-    if( xParaEnum->hasMoreElements() )
-    {
-        uno::Reference< lang::XServiceInfo > xServiceInfo( xParaEnum->nextElement(), uno::UNO_QUERY_THROW );
-        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ) ) )
-        {
-            uno::Reference< table::XCellRange > xCellRange( xServiceInfo, uno::UNO_QUERY_THROW );
-            uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
-            xTextRange = xFirstCellText->getStart();
-        }
-    }
-    if( !xTextRange.is() )
-        xTextRange = xText->getStart();
+    uno::Reference< text::XTextRange > xTextRange = word::getFirstObjectPosition( xText );
     return xTextRange;
 }
 
--- sw/source/ui/vba/vbawindow.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbawindow.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -28,12 +28,16 @@
  *
  ************************************************************************/
 #include <vbahelper/helperdecl.hxx>
+#include <ooo/vba/word/WdWindowState.hpp>
 #include "vbawindow.hxx"
 #include "vbaglobals.hxx"
 #include "vbadocument.hxx"
 #include "vbaview.hxx"
 #include "vbapanes.hxx"
 #include "vbapane.hxx"
+#include "wordvbahelper.hxx"
+#include <view.hxx>
+#include <sfx2/topfrm.hxx>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -81,6 +85,52 @@ void SAL_CALL SwVbaWindow::setView( cons
 }
 
 uno::Any SAL_CALL 
+SwVbaWindow::getWindowState() throw (uno::RuntimeException)
+{	
+    sal_Int32 nwindowState = word::WdWindowState::wdWindowStateNormal;
+    SwView* pView = word::getView( m_xModel );
+    SfxViewFrame* pViewFrame = pView -> GetViewFrame();
+    SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
+    if ( pTop )
+    {
+        WorkWindow* pWork = (WorkWindow*) pTop->GetTopFrame_Impl()->GetSystemWindow();
+        if ( pWork )
+        {
+            if ( pWork -> IsMaximized())
+                nwindowState = word::WdWindowState::wdWindowStateMaximize;
+            else if (pWork -> IsMinimized())
+                nwindowState = word::WdWindowState::wdWindowStateMinimize;
+        }
+    }
+    return uno::makeAny( nwindowState );
+}
+
+void SAL_CALL 
+SwVbaWindow::setWindowState( const uno::Any& _windowstate ) throw (uno::RuntimeException)
+{
+    sal_Int32 nwindowState = word::WdWindowState::wdWindowStateMaximize;
+    _windowstate >>= nwindowState;
+    SwView* pView = word::getView( m_xModel );
+    SfxViewFrame* pViewFrame = pView -> GetViewFrame();
+    SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
+    if ( pTop )
+    {
+        WorkWindow* pWork = (WorkWindow*) pTop->GetTopFrame_Impl()->GetSystemWindow();
+        if ( pWork )
+        {
+            if ( nwindowState == word::WdWindowState::wdWindowStateMaximize )
+                pWork -> Maximize();
+            else if (nwindowState == word::WdWindowState::wdWindowStateMinimize)
+                pWork -> Minimize();
+            else if (nwindowState == word::WdWindowState::wdWindowStateNormal)
+                pWork -> Restore();
+            else
+                throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Invalid Parameter" ) ), uno::Reference< uno::XInterface >() );
+        }
+    }
+}
+
+uno::Any SAL_CALL 
 SwVbaWindow::Panes( const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
     uno::Reference< XCollection > xPanes( new SwVbaPanes( this,  mxContext, m_xModel ) );
--- sw/source/ui/vba/vbawindow.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/vbawindow.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,6 +48,8 @@ public:
     // Attributes
     virtual css::uno::Any SAL_CALL getView() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setView( const css::uno::Any& _view ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getWindowState() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWindowState( const css::uno::Any& _windowstate ) throw (css::uno::RuntimeException);
 	// Methods
 	virtual void SAL_CALL Activate(  ) throw (css::uno::RuntimeException);
 	virtual void SAL_CALL Close( const css::uno::Any& SaveChanges, const css::uno::Any& RouteDocument ) throw (css::uno::RuntimeException);
--- sw/source/ui/vba/wordvbahelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/wordvbahelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,11 +32,16 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/frame/XController.hpp>
 #include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/lang/XUnoTunnel.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
 #include <unotxdoc.hxx>
 #include <doc.hxx>
+#include <view.hxx>
 
 using namespace ::com::sun::star;
 using namespace ::ooo::vba;
@@ -74,8 +79,13 @@ uno::Reference< text::XTextViewCursor >
 uno::Reference< style::XStyle > getCurrentPageStyle( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
 {
     uno::Reference< beans::XPropertySet > xCursorProps( getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+    return getCurrentPageStyle( xModel, xCursorProps );
+}
+
+uno::Reference< style::XStyle > getCurrentPageStyle( const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xProps ) throw (uno::RuntimeException)
+{
     rtl::OUString aPageStyleName;
-    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+    xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
     uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
     uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
     uno::Reference< container::XNameAccess > xPageStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles") ) ), uno::UNO_QUERY_THROW );
@@ -90,6 +100,92 @@ sal_Int32 getPageCount( const uno::Refer
     return pDocShell ? pDocShell->GetDoc()->GetPageCount() : 0;
 }
 
+uno::Reference< style::XStyle > getDefaultParagraphStyle( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xParaStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") ) ), uno::UNO_QUERY_THROW );
+    uno::Reference< style::XStyle > xStyle( xParaStyles->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) ), uno::UNO_QUERY_THROW );
+
+    return xStyle;
+}
+
+uno::Reference< text::XTextRange > getFirstObjectPosition( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
+{
+    // if the first object is table, get the position of first cell 
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
+    if( xParaEnum->hasMoreElements() )
+    {
+        uno::Reference< lang::XServiceInfo > xServiceInfo( xParaEnum->nextElement(), uno::UNO_QUERY_THROW );
+        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ) ) )
+        {
+            uno::Reference< table::XCellRange > xCellRange( xServiceInfo, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+            xTextRange = xFirstCellText->getStart();
+        }
+    }
+    if( !xTextRange.is() )
+        xTextRange = xText->getStart();
+    return xTextRange;
+}
+
+uno::Reference< text::XText > getCurrentXText( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< text::XTextContent > xTextContent( xModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( !xTextContent.is() )
+    {
+        uno::Reference< container::XIndexAccess > xIndexAccess( xModel->getCurrentSelection(), uno::UNO_QUERY );
+        if( xIndexAccess.is() )
+        {
+            xTextContent.set( xIndexAccess->getByIndex(0), uno::UNO_QUERY );
+        }
+    }    
+
+    if( xTextContent.is() )
+        xTextRange.set( xTextContent->getAnchor(), uno::UNO_QUERY );
+
+    if( !xTextRange.is() )    
+        xTextRange.set( getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW ); 
+        
+    uno::Reference< text::XText > xText;
+    try
+    {
+        xText.set( xTextRange->getText(), uno::UNO_QUERY );
+    }
+    catch( uno::RuntimeException& )
+    {
+        //catch exception "no text selection" 
+    }
+    uno::Reference< beans::XPropertySet > xVCProps( xTextRange, uno::UNO_QUERY_THROW );
+    while( xVCProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextContent )
+    {
+        xText = xTextContent->getAnchor()->getText();
+        xVCProps.set( xText->createTextCursor(), uno::UNO_QUERY_THROW );
+    }
+
+    if( !xText.is() )
+        throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "no text selection" ) ), uno::Reference< uno::XInterface >() );
+
+    return xText;
+}
+
+sal_Bool gotoSelectedObjectAnchor( const uno::Reference< frame::XModel>& xModel ) throw (uno::RuntimeException)
+{
+    sal_Bool isObjectSelected = sal_False;
+    uno::Reference< text::XTextContent > xTextContent( xModel->getCurrentSelection(), uno::UNO_QUERY );
+    if( xTextContent.is() )
+    {
+        uno::Reference< text::XTextRange > xTextRange( xTextContent->getAnchor(), uno::UNO_QUERY_THROW );
+        uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+        xSelectSupp->select( uno::makeAny( xTextRange ) );
+        isObjectSelected = sal_True;
+    }
+    return isObjectSelected;
+}
+
 } // word
 } // 
 } //
--- sw/source/ui/vba/wordvbahelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/source/ui/vba/wordvbahelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -35,6 +35,8 @@
 #include <com/sun/star/text/XTextViewCursor.hpp>
 #include <com/sun/star/text/XPageCursor.hpp>
 #include <com/sun/star/style/XStyle.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
 
 class SwDocShell;
 class SwView;
@@ -49,7 +51,20 @@ namespace ooo
         SwView* getView( const css::uno::Reference< css::frame::XModel>& xModel );
         css::uno::Reference< css::text::XTextViewCursor > getXTextViewCursor( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
         css::uno::Reference< css::style::XStyle > getCurrentPageStyle( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::style::XStyle > getCurrentPageStyle( const css::uno::Reference< css::frame::XModel>& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps ) throw (css::uno::RuntimeException);
         sal_Int32 getPageCount( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::style::XStyle > getDefaultParagraphStyle( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::text::XTextRange > getFirstObjectPosition( const css::uno::Reference< css::text::XText >& xText ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::text::XText > getCurrentXText( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+        sal_Bool gotoSelectedObjectAnchor( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+
+    enum E_DIRECTION
+    {
+        MOVE_LEFT = 1,
+        MOVE_RIGHT,
+        MOVE_UP,
+        MOVE_DOWN
+    };
 
 } // word
 } // vba
--- sw/util/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ sw/util/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -373,6 +373,10 @@ SHL5STDLIBS= \
 	            $(SVXCORELIB) \
                 $(SVXMSFILTERLIB) \
 
+.IF "$(GUI)"=="WNT"
+SHL5STDLIBS+=$(SHELLLIB)
+.ENDIF #WNT
+
 SHL5DEPN=$(SHL1TARGETN)
 SHL5LIBS=$(SLB)$/$(TARGET_VBA).lib
 
--- toolkit/inc/toolkit/awt/vclxmenu.hxx.old	2009-10-07 15:06:52.000000000 +0200
+++ toolkit/inc/toolkit/awt/vclxmenu.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,6 +48,7 @@
 class Menu;
 class MenuBar;
 class VclSimpleEvent;
+class PopupMenu;
 
 DECLARE_LIST( PopupMenuRefList, ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu >* )
 
@@ -184,6 +185,7 @@ class TOOLKIT_DLLPUBLIC VCLXPopupMenu :
 {
 public:
         VCLXPopupMenu();
+		VCLXPopupMenu( PopupMenu* pPopMenu );
 };
 
 #endif // _TOOLKIT_AWT_VCLXMENU_HXX_
--- toolkit/inc/toolkit/awt/vclxwindows.hxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/inc/toolkit/awt/vclxwindows.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -96,6 +96,7 @@
 #include <vcl/imgcons.hxx>
 #include <vcl/image.hxx>
 
+#include <com/sun/star/document/XVbaMethodParameter.hpp>  //liuchen 2009-6-22, add the support of input/output parameters to VBA Dialog_QueryClose event
 class Button;
 class CheckBox;
 class RadioButton;
@@ -391,6 +392,7 @@ public:
 //	class VCLXDialog
 //	----------------------------------------------------
 class VCLXDialog :	public ::com::sun::star::awt::XDialog,
+						public ::com::sun::star::document::XVbaMethodParameter, //liuchen 2009-6-22, add the support of input/output parameters to VBA UserForm_QueryClose event
                     public VCLXTopWindow
 {
 public:
@@ -424,6 +426,10 @@ public:
     // ::com::sun::star::awt::XVclWindowPeer
     void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
 
+	//liuchen 2009-6-23, support Excel VBA UserForm_QueryClose event
+	// ::com::sun::star::document::XVBAMethodParameter
+	void SAL_CALL setVbaMethodParameter( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+	::com::sun::star::uno::Any SAL_CALL getVbaMethodParameter( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException); 
 };
 
 //	----------------------------------------------------
--- toolkit/inc/toolkit/controls/dialogcontrol.hxx.old	2009-10-07 15:06:52.000000000 +0200
+++ toolkit/inc/toolkit/controls/dialogcontrol.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -51,6 +51,8 @@
 #include <cppuhelper/propshlp.hxx>
 #include <cppuhelper/basemutex.hxx>
 #include <list>
+#include <map>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //	----------------------------------------------------
 //	class UnoControlDialogModel
@@ -91,7 +93,9 @@ private:
 
     AllGroups							maGroups;
     sal_Bool							mbGroupsUpToDate;
-
+        
+	::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
+	bool mbAdjustingGraphic;
 protected:	
     ::com::sun::star::uno::Any			ImplGetDefaultValue( sal_uInt16 nPropId ) const;
     ::cppu::IPropertyArrayHelper&		SAL_CALL getInfoHelper();
@@ -178,10 +182,20 @@ public:
 protected:
     void startControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
     void stopControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
+    // ::cppu::OPropertySetHelper
+	void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception);
 
     void implNotifyTabModelChange( const ::rtl::OUString& _rAccessor );
 
     void implUpdateGroupStructure();
+private:
+    void AddRadioButtonToGroup (
+            const ::com::sun::star::uno::Reference< XControlModel >& rControlModel,
+            const ::rtl::OUString& rPropertyName,
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups,
+            ModelGroup*& rpCurrentGroup );
+    void AddRadioButtonGroup (
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups );
 };
 
 //	----------------------------------------------------
--- toolkit/inc/toolkit/controls/unocontrols.hxx.old	2009-10-07 15:06:52.000000000 +0200
+++ toolkit/inc/toolkit/controls/unocontrols.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -225,7 +225,6 @@ private:
     bool                                                                                    mbAdjustingGraphic;
     
     ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
-    ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphic > getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL );
 protected:
     ImageProducerControlModel() : mbAdjustingImagePosition( false ), mbAdjustingGraphic( false ) { }
     ImageProducerControlModel( const ImageProducerControlModel& _rSource ) : com::sun::star::awt::XImageProducer(), UnoControlModel( _rSource ), mbAdjustingImagePosition( false ), mbAdjustingGraphic( false ) { }
@@ -670,6 +669,44 @@ public:
 
 };
 
+class UnoMultiPageModel : public UnoControlModel
+{
+protected:
+	::com::sun::star::uno::Any 		ImplGetDefaultValue( sal_uInt16 nPropId ) const;
+	::cppu::IPropertyArrayHelper& 	SAL_CALL getInfoHelper();
+
+public:
+						UnoMultiPageModel();
+						UnoMultiPageModel( const UnoMultiPageModel& rModel ) : UnoControlModel( rModel ) {;}
+
+	UnoControlModel*	Clone() const { return new UnoMultiPageModel( *this ); }
+
+	// ::com::sun::star::io::XPersistObject
+    ::rtl::OUString SAL_CALL getServiceName() throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::beans::XMultiPropertySet
+    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageModel, UnoControlModel, szServiceName_UnoMultiPageModel )
+
+};
+//	----------------------------------------------------
+//	class UnoGroupBoxControl
+//	----------------------------------------------------
+class UnoMultiPageControl :	public UnoControlBase
+{
+public:
+						UnoMultiPageControl();
+	::rtl::OUString		GetComponentServiceName();
+
+    sal_Bool SAL_CALL isTransparent(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageControl, UnoControlBase, szServiceName_UnoMultiPageControl )
+
+};
+
 //  ----------------------------------------------------
 //  class UnoFixedTextControl
 //  ----------------------------------------------------
--- toolkit/inc/toolkit/helper/property.hxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/inc/toolkit/helper/property.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -197,6 +197,8 @@ namespace rtl {
 #define BASEPROPERTY_GRID_COLUMNMODEL               143
 #define BASEPROPERTY_GRID_SELECTIONMODE             144
 #define BASEPROPERTY_ENABLEVISIBLE                  145  // sal_Bool
+#define BASEPROPERTY_GROUPNAME                      146  // ::rtl::OUString
+#define BASEPROPERTY_VBAFORM                        147  // sal_Boo
 
 
 // Keine gebundenen Properties, werden immer aus der Property BASEPROPERTY_FONTDESCRIPTOR entnommen.
--- toolkit/inc/toolkit/helper/servicenames.hxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/inc/toolkit/helper/servicenames.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,8 @@ extern const sal_Char __FAR_DATA szServi
 extern const sal_Char __FAR_DATA szServiceName_MenuBar[], szServiceName2_MenuBar[];
 extern const sal_Char __FAR_DATA szServiceName_Pointer[], szServiceName2_Pointer[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainer[], szServiceName2_UnoControlContainer[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[], szServiceName2_UnoMultiPageControl[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[], szServiceName2_UnoMultiPageModel[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[], szServiceName2_UnoControlContainerModel[];
 extern const sal_Char __FAR_DATA szServiceName_TabController[], szServiceName2_TabController[];
 extern const sal_Char __FAR_DATA szServiceName_TabControllerModel[], szServiceName2_TabControllerModel[];
--- toolkit/source/awt/vclxmenu.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/awt/vclxmenu.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -529,6 +529,14 @@ void VCLXMenu::setPopupMenu( sal_Int16 n
                 break;
             }
         }
+        // it seems the popup menu is not insert into maPopupMenueRefs
+        // if the popup men is not created by stardiv.Toolkit.VCLXPopupMenu
+        if( !aRef.is() )
+        {
+		    ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > * pNewRef = new ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > ;
+            *pNewRef = new VCLXPopupMenu( (PopupMenu*)pMenu );
+            aRef = *pNewRef;
+        }
     }
     return aRef;
 }
@@ -1060,3 +1068,8 @@ VCLXPopupMenu::VCLXPopupMenu()
     DBG_CTOR( VCLXPopupMenu, 0 );
     ImplCreateMenu( TRUE );
 }
+
+VCLXPopupMenu::VCLXPopupMenu( PopupMenu* pPopMenu ) : VCLXMenu( (Menu *)pPopMenu )
+{
+    DBG_CTOR( VCLXPopupMenu, 0 );
+}
--- toolkit/source/awt/vclxwindows.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/awt/vclxwindows.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -680,6 +680,7 @@ void VCLXImageControl::ImplGetPropertyId
                      BASEPROPERTY_TABSTOP,
                      BASEPROPERTY_WRITING_MODE,
                      BASEPROPERTY_CONTEXT_WRITING_MODE,
+                     BASEPROPERTY_GROUPNAME,
                      0);
     VCLXImageConsumer::ImplGetPropertyIds( rIds );
 }
@@ -1116,6 +1117,7 @@ void VCLXRadioButton::ImplGetPropertyIds
                      BASEPROPERTY_VERTICALALIGN,
                      BASEPROPERTY_WRITING_MODE,
                      BASEPROPERTY_CONTEXT_WRITING_MODE,
+                     BASEPROPERTY_GROUPNAME,
                      0);
     VCLXImageConsumer::ImplGetPropertyIds( rIds );
 }
@@ -1180,6 +1182,16 @@ void VCLXRadioButton::setProperty( const
                         pButton->Check( b );
                     else
                         pButton->SetState( b );
+					// If VBA - need to be able to test
+					// simulate click event
+					if ( maActionListeners.getLength() )
+					{
+						::com::sun::star::awt::ActionEvent aEvent;
+						aEvent.Source = (::cppu::OWeakObject*)this;
+						aEvent.ActionCommand = maActionCommand;
+						maActionListeners.actionPerformed( aEvent );
+					}
+					
                 }
             }
             break;
@@ -1942,8 +1954,11 @@ void VCLXListBox::setProperty( const ::r
                 ::com::sun::star::uno::Sequence< ::rtl::OUString> aItems;
                 if ( Value >>= aItems )
                 {
+					sal_Int16 nElem  = pListBox->GetEntryCount();
                     pListBox->Clear();
                     addItems( aItems, 0 );
+					if ( aItems.getLength() == 0 && nElem && maItemListeners.getLength() )
+						ImplCallItemListeners();
                 }
             }
             break;
@@ -1956,7 +1971,11 @@ void VCLXListBox::setProperty( const ::r
                         pListBox->SelectEntryPos( --n, sal_False );
 
                     if ( aItems.getLength() )
+                    {			
                         selectItemsPos( aItems, sal_True );
+                       if ( maItemListeners.getLength() )
+                           ImplCallItemListeners();
+                    }
                     else
                         pListBox->SetNoSelection();
 
@@ -2207,12 +2226,14 @@ VCLXDialog::~VCLXDialog()
 ::com::sun::star::uno::Any VCLXDialog::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
 {
     ::com::sun::star::uno::Any aRet = ::cppu::queryInterface( rType,
+										SAL_STATIC_CAST( ::com::sun::star::document::XVbaMethodParameter*, this ), //liuchen 2009-6-23
                                         SAL_STATIC_CAST( ::com::sun::star::awt::XDialog*, this ) );
     return (aRet.hasValue() ? aRet : VCLXTopWindow::queryInterface( rType ));
 }
 
 // ::com::sun::star::lang::XTypeProvider
 IMPL_XTYPEPROVIDER_START( VCLXDialog )
+	getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::document::XVbaMethodParameter>* ) NULL ), //liuchen 2009-6-23
     getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDialog>* ) NULL ),
     VCLXTopWindow::getTypes()
 IMPL_XTYPEPROVIDER_END
@@ -2300,6 +2321,40 @@ void SAL_CALL VCLXDialog::draw( sal_Int3
     return aInfo;
 }
 
+//liuchen 2009-7-22
+// ::com::sun::star::document::XVbaMethodParameter
+void SAL_CALL VCLXDialog::setVbaMethodParameter(
+	const ::rtl::OUString& PropertyName,
+	const ::com::sun::star::uno::Any& Value )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	if (rtl::OUString::createFromAscii( "Cancel" ) == PropertyName)
+	{
+		::vos::OGuard aGuard( GetMutex() ); 
+		if ( GetWindow() )
+		{
+			sal_Int8 nCancel;
+			Value >>= nCancel;
+		
+			Dialog* pDlg = (Dialog*) GetWindow();
+			pDlg->SetCloseFlag(nCancel);
+		}
+	}
+}
+
+::com::sun::star::uno::Any SAL_CALL VCLXDialog::getVbaMethodParameter(
+	const ::rtl::OUString& PropertyName )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	::vos::OGuard aGuard( GetMutex() );
+
+	::com::sun::star::uno::Any aRet;	
+	return aRet;
+}
+//liuchen 2009-7-22
+
+
+
 
 void SAL_CALL VCLXDialog::setProperty(
     const ::rtl::OUString& PropertyName,
--- toolkit/source/controls/dialogcontrol.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/controls/dialogcontrol.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -81,6 +81,7 @@ using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::script;
 using namespace toolkit;
 
 #define PROPERTY_RESOURCERESOLVER ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ResourceResolver" ))
@@ -91,6 +92,8 @@ using namespace toolkit;
 //HELPER
 ::rtl::OUString getPhysicalLocation( const ::com::sun::star::uno::Any& rbase, const ::com::sun::star::uno::Any& rUrl );
 
+uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL );
+
 struct LanguageDependentProp
 {
     const char* pPropName;
@@ -116,7 +119,7 @@ namespace
         }
         return s_aLanguageDependentProperties;
     }
-
+ 
     static uno::Reference< graphic::XGraphic > lcl_getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
@@ -143,6 +146,18 @@ namespace
         return xGraphic;
     }
 
+    static ::rtl::OUString lcl_GetStringProperty( const ::rtl::OUString& sProperty, const Reference< XPropertySet >& xSet )
+    {
+        ::rtl::OUString sValue;
+        Reference< XPropertySetInfo > xPSI;
+        if (xSet.is() && (xPSI = xSet->getPropertySetInfo()).is() && 
+                xPSI->hasPropertyByName( sProperty ) )
+        {
+            xSet->getPropertyValue( sProperty ) >>= sValue;
+        }
+        return sValue;
+    }
+
 }
 
 // ----------------------------------------------------------------------------
@@ -254,7 +269,7 @@ static const ::rtl::OUString& getStepPro
 UnoControlDialogModel::UnoControlDialogModel()
     :maContainerListeners( *this )
     ,maChangeListeners ( GetMutex() )
-    ,mbGroupsUpToDate( sal_False )
+	,mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
     ImplRegisterProperty( BASEPROPERTY_BACKGROUNDCOLOR );
 //	ImplRegisterProperty( BASEPROPERTY_BORDER );
@@ -276,6 +291,8 @@ UnoControlDialogModel::UnoControlDialogM
     aBool <<= (sal_Bool) sal_True;
     ImplRegisterProperty( BASEPROPERTY_MOVEABLE, aBool );
     ImplRegisterProperty( BASEPROPERTY_CLOSEABLE, aBool );
+	aBool <<= (sal_Bool) sal_False;
+	ImplRegisterProperty( BASEPROPERTY_VBAFORM, aBool );
 }
 
 UnoControlDialogModel::UnoControlDialogModel( const UnoControlDialogModel& rModel )
@@ -283,7 +300,7 @@ UnoControlDialogModel::UnoControlDialogM
     , UnoControlDialogModel_Base( rModel )
     , maContainerListeners( *this )
     , maChangeListeners ( GetMutex() )
-    , mbGroupsUpToDate( sal_False )
+	, mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
 }
 
@@ -314,6 +331,40 @@ Sequence< Type > UnoControlDialogModel::
     return ::rtl::OUString::createFromAscii( szServiceName_UnoControlDialogModel );
 }
 
+void SAL_CALL UnoControlDialogModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception)
+{
+    UnoControlModel::setFastPropertyValue_NoBroadcast( nHandle, rValue );
+    try
+    {
+        switch ( nHandle )
+        {
+        case BASEPROPERTY_IMAGEURL:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_GRAPHIC ) )
+            {
+                mbAdjustingGraphic = true;
+                ::rtl::OUString sImageURL;
+                OSL_VERIFY( rValue >>= sImageURL );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+
+        case BASEPROPERTY_GRAPHIC:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_IMAGEURL ) )
+            {
+                mbAdjustingGraphic = true;
+                setPropertyValue( GetPropertyName( BASEPROPERTY_IMAGEURL ), uno::makeAny( ::rtl::OUString() ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+	}
+    }
+    catch( const ::com::sun::star::uno::Exception& )
+    {
+        OSL_ENSURE( sal_False, "UnoControlDialogModel::setFastPropertyValue_NoBroadcast: caught an exception while setting Graphic/ImageURL properties!" );
+    }
+}
+
 Any UnoControlDialogModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
 {
     Any aAny;
@@ -901,6 +952,63 @@ void UnoControlDialogModel::implNotifyTa
     }
 }
 
+// ----------------------------------------------------------------------------
+void UnoControlDialogModel::AddRadioButtonGroup ( 
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups )
+{
+    if ( rNamedGroups.size() == 0 )
+        return;
+
+    size_t nGroups = maGroups.size();
+    maGroups.reserve( nGroups + rNamedGroups.size() );
+    ::std::map< ::rtl::OUString, ModelGroup >::const_iterator i = rNamedGroups.begin(), e = rNamedGroups.end();
+    for( ; i != e; ++i)
+    {
+            maGroups.push_back( i->second );
+    }
+
+    rNamedGroups.clear();
+}
+
+void UnoControlDialogModel::AddRadioButtonToGroup ( 
+        const Reference< XControlModel >& rControlModel,
+        const ::rtl::OUString& rPropertyName,
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups,
+        ModelGroup*& rpCurrentGroup )
+{
+    Reference< XPropertySet > xCurProps( rControlModel, UNO_QUERY );
+    ::rtl::OUString sGroup = lcl_GetStringProperty( rPropertyName, xCurProps );
+    const sal_Int32 nControlModelStep = lcl_getDialogStep( rControlModel );
+
+    if ( sGroup.getLength() == 0 )
+    {
+        // Create a new group if:
+        if ( maGroups.size() == 0 ||                // no groups
+                rpCurrentGroup == NULL ||           // previous group was closed
+                (nControlModelStep != 0 &&          // control step matches current group
+                 maGroups.back().size() > 0 &&      //  (group 0 == display everywhere)
+                 nControlModelStep != lcl_getDialogStep( maGroups.back().back() ) ) )
+        {
+            size_t nGroups = maGroups.size();
+            maGroups.resize( nGroups + 1 );
+        }
+        rpCurrentGroup = &maGroups.back();
+    }
+    else
+    {
+        // Different steps get different sets of named groups
+        if ( rNamedGroups.size() > 0 &&
+                rNamedGroups.begin()->second.size() > 0 )
+        {
+            const sal_Int32 nPrevStep = lcl_getDialogStep( rNamedGroups.begin()->second.front() );
+            if ( nControlModelStep != nPrevStep )
+                AddRadioButtonGroup( rNamedGroups );
+        }
+
+        rpCurrentGroup = &rNamedGroups[ sGroup ];
+    }
+    rpCurrentGroup->push_back( rControlModel );
+}
 
 // ----------------------------------------------------------------------------
 void UnoControlDialogModel::implUpdateGroupStructure()
@@ -925,10 +1033,13 @@ void UnoControlDialogModel::implUpdateGr
 
     GroupingMachineState eState = eLookingForGroup;		// the current state of our machine
     Reference< XServiceInfo > xModelSI;					// for checking for a radion button
-    AllGroups::iterator aCurrentGroup = maGroups.end();	// the group which we're currently building
-    sal_Int32	nCurrentGroupStep = -1;					// the step which all controls of the current group belong to
+	ModelGroup* aCurrentGroup = NULL;                   // the group which we're currently building
     sal_Bool	bIsRadioButton;							// is it a radio button?
 
+    const ::rtl::OUString GROUP_NAME( RTL_CONSTASCII_USTRINGPARAM( "GroupName" ) );
+
+    ::std::map< ::rtl::OUString, ModelGroup > aNamedGroups;
+
 #if OSL_DEBUG_LEVEL > 1
     ::std::vector< ::rtl::OUString > aCurrentGroupLabels;
 #endif
@@ -949,14 +1060,8 @@ void UnoControlDialogModel::implUpdateGr
                 // the current model is a radio button
                 // -> we found the beginning of a new group
                 // create the place for this group
-                size_t nGroups = maGroups.size();
-                maGroups.resize( nGroups + 1 );
-                aCurrentGroup = maGroups.begin() + nGroups;
-                // and add the (only, til now) member
-                aCurrentGroup->push_back( *pControlModels );
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
 
-                // get the step which all controls of this group now have to belong to
-                nCurrentGroupStep = lcl_getDialogStep( *pControlModels );
                 // new state: looking for further members
                 eState = eExpandingGroup;
 
@@ -974,7 +1079,7 @@ void UnoControlDialogModel::implUpdateGr
             {
                 if ( !bIsRadioButton )
                 {	// no radio button -> the group is done
-                    aCurrentGroup = maGroups.end();
+					aCurrentGroup = NULL;
                     eState = eLookingForGroup;
 #if OSL_DEBUG_LEVEL > 1
                     aCurrentGroupLabels.clear();
@@ -982,47 +1087,8 @@ void UnoControlDialogModel::implUpdateGr
                     continue;
                 }
 
-                // it is a radio button - is it on the proper page?
-                const sal_Int32 nThisModelStep = lcl_getDialogStep( *pControlModels );
-                if	(	( nThisModelStep == nCurrentGroupStep )	// the current button is on the same dialog page
-                    ||	( 0 == nThisModelStep )					// the current button appears on all pages
-                    )
-                {
-                    // -> it belongs to the same group
-                    aCurrentGroup->push_back( *pControlModels );
-                    // state still is eExpandingGroup - we're looking for further elements
-                    eState = eExpandingGroup;
-
-#if OSL_DEBUG_LEVEL > 1
-                    Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
-                    ::rtl::OUString sLabel;
-                    if ( xModelProps.is() && xModelProps->getPropertySetInfo().is() && xModelProps->getPropertySetInfo()->hasPropertyByName( ::rtl::OUString::createFromAscii( "Label" ) ) )
-                        xModelProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Label" ) ) >>= sLabel;
-                    aCurrentGroupLabels.push_back( sLabel );
-#endif
-                    continue;
-                }
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
 
-                // it's a radio button, but on a different page
-                // -> we open a new group for it
-
-                // close the old group
-                aCurrentGroup = maGroups.end();
-#if OSL_DEBUG_LEVEL > 1
-                aCurrentGroupLabels.clear();
-#endif
-
-                // open a new group
-                size_t nGroups = maGroups.size();
-                maGroups.resize( nGroups + 1 );
-                aCurrentGroup = maGroups.begin() + nGroups;
-                // and add the (only, til now) member
-                aCurrentGroup->push_back( *pControlModels );
-
-                nCurrentGroupStep = nThisModelStep;
-
-                // state is the same: we still are looking for further elements of the current group
-                eState = eExpandingGroup;
 #if OSL_DEBUG_LEVEL > 1
                 Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
                 ::rtl::OUString sLabel;
@@ -1035,6 +1101,7 @@ void UnoControlDialogModel::implUpdateGr
         }
     }
 
+    AddRadioButtonGroup( aNamedGroups );
     mbGroupsUpToDate = sal_True;
 }
 
@@ -1415,17 +1482,32 @@ void UnoDialogControl::ImplSetPosSize( R
     xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Width" ) ) ) >>= nWidth;
     xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) >>= nHeight;
 
-    // Currentley we are simply using MAP_APPFONT
+	// Currentley we are simply using MAP_APPFONT ( for normal Dialogs )
+	// and MAP_100TH_MM for imported Userforms
+	MapMode aMode( MAP_APPFONT );
+	sal_Bool bVBAForm = sal_False;
+	Reference< XPropertySet > xDlgModelProps( getModel(), UNO_QUERY );
+	if ( xDlgModelProps.is() )
+	{
+		try
+		{
+			xDlgModelProps->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAForm" ) ) ) >>= bVBAForm;
+		}
+		catch( Exception& )
+		{
+		}
+	} 
+	if ( bVBAForm )
+		aMode = MapMode( MAP_100TH_MM );
     OutputDevice*pOutDev = Application::GetDefaultDevice();
-    DBG_ASSERT( pOutDev, "Missing Default Device!" );
     if ( pOutDev )
     {
         ::Size aTmp( nX, nY );
-        aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
         nX = aTmp.Width();
         nY = aTmp.Height();
         aTmp = ::Size( nWidth, nHeight );
-        aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
         nWidth = aTmp.Width();
         nHeight = aTmp.Height();
     }
@@ -1644,17 +1726,16 @@ void UnoDialogControl::PrepareWindowDesc
     // can lead to overwrites we have to set the graphic property
     // before the propertiesChangeEvents are sent!
     ::rtl::OUString aImageURL;
-    Reference< graphic::XGraphic > xGraphic;
     if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
         ( aImageURL.getLength() > 0 ))
     {
-        ::rtl::OUString absoluteUrl =
+        aImageURL = 
             getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                  ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-        xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
-        ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
     }
+    if ( aImageURL.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+        ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
 }
 
 void UnoDialogControl::elementInserted( const ContainerEvent& Event ) throw(RuntimeException)
@@ -1886,18 +1967,16 @@ void UnoDialogControl::ImplModelProperti
         if ( bOwnModel && rEvt.PropertyName.equalsAsciiL( "ImageURL", 8 ))
         {
             ::rtl::OUString aImageURL;
-            Reference< graphic::XGraphic > xGraphic;
             if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
                 ( aImageURL.getLength() > 0 ))
             {
-                ::rtl::OUString absoluteUrl =
+                aImageURL =
                     getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                          ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-                xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
             }
 
-            ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
+            ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
             break;
         }
     }
@@ -2096,10 +2175,17 @@ throw (RuntimeException)
 
     if ( url.getLength() > 0 )
     {
-        INetURLObject urlObj(baseLocation);
-        urlObj.removeSegment();
-        baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
-        ::osl::FileBase::getAbsoluteFileURL( baseLocation, url, ret );
+		// Don't adjust GraphicObject url(s)
+		if ( url.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+		{
+			INetURLObject urlObj(baseLocation);
+			urlObj.removeSegment();
+			baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
+			::osl::FileBase::getAbsoluteFileURL( baseLocation, url, ret );
+		}
+		else
+			ret = url;
+
     }
 
     return ret;
--- toolkit/source/controls/unocontrolmodel.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/controls/unocontrolmodel.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -349,6 +349,7 @@ void UnoControlModel::ImplPropertyChange
             case BASEPROPERTY_ENABLEVISIBLE:
             case BASEPROPERTY_DECORATION:           aDefault <<= (sal_Bool) sal_True; break;
 
+            case BASEPROPERTY_GROUPNAME:
             case BASEPROPERTY_HELPTEXT:
             case BASEPROPERTY_HELPURL:
             case BASEPROPERTY_IMAGEURL:
--- toolkit/source/controls/unocontrols.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/controls/unocontrols.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -571,7 +571,7 @@ uno::Any ImageProducerControlModel::Impl
 
     return UnoControlModel::ImplGetDefaultValue( nPropId );
 }
-    uno::Reference< graphic::XGraphic > ImageProducerControlModel::getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
+    uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
 
@@ -581,10 +581,10 @@ uno::Any ImageProducerControlModel::Impl
             rtl::OUString sID = _rURL.copy( sizeof( UNO_NAME_GRAPHOBJ_URLPREFIX ) - 1 );
             // get the DefaultContext
             ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
-            mxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
+            rxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
         }
         else // linked
-            mxGrfObj = NULL; // release the GraphicObject
+            rxGrfObj = NULL; // release the GraphicObject
 
         if ( !_rURL.getLength() )
             return xGraphic;
@@ -625,7 +625,7 @@ void SAL_CALL ImageProducerControlModel:
                 mbAdjustingGraphic = true;
                 ::rtl::OUString sImageURL;
                 OSL_VERIFY( rValue >>= sImageURL );
-                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( sImageURL ) ) );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
                 mbAdjustingGraphic = false;
             }
             break;
@@ -1842,6 +1842,77 @@ sal_Bool UnoGroupBoxControl::isTranspare
     return sal_True;
 }
 
+// MultiPage
+
+UnoMultiPageModel::UnoMultiPageModel()
+{
+	ImplRegisterProperty( BASEPROPERTY_DEFAULTCONTROL );
+	ImplRegisterProperty( BASEPROPERTY_ENABLED );
+	ImplRegisterProperty( BASEPROPERTY_FONTDESCRIPTOR );
+	ImplRegisterProperty( BASEPROPERTY_HELPTEXT );
+	ImplRegisterProperty( BASEPROPERTY_HELPURL );
+	ImplRegisterProperty( BASEPROPERTY_LABEL );
+	ImplRegisterProperty( BASEPROPERTY_PRINTABLE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE_MAX );
+}
+
+::rtl::OUString UnoMultiPageModel::getServiceName() throw(::com::sun::star::uno::RuntimeException)
+{
+	return ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageModel );
+}
+
+uno::Any UnoMultiPageModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
+{
+	if ( nPropId == BASEPROPERTY_DEFAULTCONTROL )
+	{
+		uno::Any aAny;
+		aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoControlGroupBox );
+		//aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageControl );
+		return aAny;
+	}
+	return UnoControlModel::ImplGetDefaultValue( nPropId );
+}
+
+::cppu::IPropertyArrayHelper& UnoMultiPageModel::getInfoHelper()
+{
+	static UnoPropertyArrayHelper* pHelper = NULL;
+	if ( !pHelper )
+	{
+		uno::Sequence<sal_Int32>	aIDs = ImplGetPropertyIds();
+		pHelper = new UnoPropertyArrayHelper( aIDs );
+	}
+	return *pHelper;
+}
+
+// beans::XMultiPropertySet
+uno::Reference< beans::XPropertySetInfo > UnoMultiPageModel::getPropertySetInfo(  ) throw(uno::RuntimeException)
+{
+	static uno::Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+	return xInfo;
+}
+
+//	----------------------------------------------------
+//	class MultiPageControl
+//	----------------------------------------------------
+UnoMultiPageControl::UnoMultiPageControl()
+{
+	maComponentInfos.nWidth = 100;
+	maComponentInfos.nHeight = 100;
+}
+
+::rtl::OUString UnoMultiPageControl::GetComponentServiceName()
+{
+	return ::rtl::OUString::createFromAscii( "multipage" );
+}
+
+sal_Bool UnoMultiPageControl::isTransparent() throw(uno::RuntimeException)
+{
+	return sal_True;
+}
+
+
+
 //	----------------------------------------------------
 //	class UnoControlListBoxModel
 //	----------------------------------------------------
--- toolkit/source/helper/property.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/helper/property.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -183,6 +183,7 @@ ImplPropertyInfo* ImplGetPropertyInfos(
             DECL_PROP_3     ( "FormatsSupplier",        FORMATSSUPPLIER,    Reference< ::com::sun::star::util::XNumberFormatsSupplier >, BOUND, MAYBEVOID, TRANSIENT ),
 
             DECL_PROP_2     ( "Graphic",                GRAPHIC,            Reference< ::com::sun::star::graphic::XGraphic >, BOUND, TRANSIENT ),
+            DECL_PROP_2     ( "GroupName",              GROUPNAME,          ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpText",               HELPTEXT,           ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpURL",                HELPURL,            ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HideInactiveSelection",  HIDEINACTIVESELECTION, bool,            BOUND, MAYBEDEFAULT ),
@@ -280,7 +281,8 @@ ImplPropertyInfo* ImplGetPropertyInfos(
             DECL_PROP_3     ( "GridDataModel",		GRID_DATAMODEL,   Reference< ::com::sun::star::awt::grid::XGridDataModel >,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "ColumnModel",		GRID_COLUMNMODEL,   Reference< ::com::sun::star::awt::grid::XGridColumnModel >,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "SelectionModel",		GRID_SELECTIONMODE,   ::com::sun::star::view::SelectionType,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
-            DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,           BOUND, MAYBEDEFAULT )
+            DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,           BOUND, MAYBEDEFAULT ),
+            DECL_PROP_2     ( "VBAForm",                VBAFORM,                sal_Bool,           BOUND, MAYBEDEFAULT )
             };
             pPropertyInfos = aImplPropertyInfos;
             nElements = sizeof( aImplPropertyInfos ) / sizeof( ImplPropertyInfo );
--- toolkit/source/helper/registerservices.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/helper/registerservices.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -168,6 +168,7 @@ IMPL_CREATEINSTANCE( UnoControlTimeField
 IMPL_CREATEINSTANCE( UnoControlProgressBarModel )
 IMPL_CREATEINSTANCE( UnoControlScrollBarModel )
 IMPL_CREATEINSTANCE( UnoSpinButtonModel )
+IMPL_CREATEINSTANCE( UnoMultiPageModel )
 IMPL_CREATEINSTANCE( UnoControlFixedLineModel )
 IMPL_CREATEINSTANCE( UnoCurrencyFieldControl )
 IMPL_CREATEINSTANCE( UnoDateFieldControl )
@@ -187,6 +188,7 @@ IMPL_CREATEINSTANCE( UnoTimeFieldControl
 IMPL_CREATEINSTANCE( UnoProgressBarControl )
 IMPL_CREATEINSTANCE( UnoScrollBarControl )
 IMPL_CREATEINSTANCE( UnoSpinButtonControl )
+IMPL_CREATEINSTANCE( UnoMultiPageControl )
 IMPL_CREATEINSTANCE( UnoFixedLineControl )
 IMPL_CREATEINSTANCE( VCLXMenuBar )
 IMPL_CREATEINSTANCE( VCLXPointer )
@@ -279,6 +281,8 @@ TOOLKIT_DLLPUBLIC sal_Bool SAL_CALL comp
         registerServices( xRegistryKey, "UnoControlScrollBarModel", szServiceName_UnoControlScrollBarModel, szServiceName2_UnoControlScrollBarModel );
         registerServices( xRegistryKey, "UnoSpinButtonModel", szServiceName_UnoSpinButtonModel );
         registerServices( xRegistryKey, "UnoSpinButtonControl", szServiceName_UnoSpinButtonControl );
+        registerServices( xRegistryKey, "UnoMultiPageModel", szServiceName_UnoMultiPageModel );
+        registerServices( xRegistryKey, "UnoMultiPageControl", szServiceName_UnoMultiPageControl );
         registerServices( xRegistryKey, "UnoFixedLineControl", szServiceName_UnoControlFixedLine, szServiceName2_UnoControlFixedLine );
         registerServices( xRegistryKey, "UnoControlFixedLineModel", szServiceName_UnoControlFixedLineModel, szServiceName2_UnoControlFixedLineModel );
         registerServices( xRegistryKey, "VCLXPrinterServer", szServiceName_PrinterServer, szServiceName2_PrinterServer );
@@ -369,6 +373,8 @@ TOOLKIT_DLLPUBLIC void* SAL_CALL compone
         CHECKANDCREATEFACTORY( VCLXPrinterServer, szServiceName_PrinterServer, szServiceName2_PrinterServer )
         CHECKANDCREATEFACTORY( UnoRoadmapControl, szServiceName_UnoControlRoadmap, szServiceName2_UnoControlRoadmap )
         CHECKANDCREATEFACTORY( UnoControlRoadmapModel, szServiceName_UnoControlRoadmapModel, szServiceName2_UnoControlRoadmapModel )
+        CHECKANDCREATEFACTORY( UnoMultiPageModel, szServiceName_UnoMultiPageModel, NULL )
+        CHECKANDCREATEFACTORY( UnoMultiPageControl, szServiceName_UnoMultiPageControl, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonModel, szServiceName_UnoSpinButtonModel, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonControl, szServiceName_UnoSpinButtonControl, NULL )
         CHECKANDCREATEFACTORY( TreeControl, szServiceName_TreeControl, NULL )
--- toolkit/source/helper/servicenames.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ toolkit/source/helper/servicenames.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,8 @@ const sal_Char __FAR_DATA szServiceName_
 const sal_Char __FAR_DATA szServiceName_MenuBar[] = "stardiv.vcl.MenuBar", szServiceName2_MenuBar[] = "com.sun.star.awt.MenuBar";
 const sal_Char __FAR_DATA szServiceName_Pointer[] = "stardiv.vcl.Pointer", szServiceName2_Pointer[] = "com.sun.star.awt.Pointer";
 const sal_Char __FAR_DATA szServiceName_UnoControlContainer[] = "stardiv.vcl.control.ControlContainer", szServiceName2_UnoControlContainer[] = "com.sun.star.awt.UnoControlContainer";
+
+
 const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[] = "stardiv.vcl.controlmodel.ControlContainer", szServiceName2_UnoControlContainerModel[] = "com.sun.star.awt.UnoControlContainerModel";
 const sal_Char __FAR_DATA szServiceName_TabController[] = "stardiv.vcl.control.TabController", szServiceName2_TabController[] = "com.sun.star.awt.TabController";
 const sal_Char __FAR_DATA szServiceName_TabControllerModel[] = "stardiv.vcl.controlmodel.TabController", szServiceName2_TabControllerModel[] = "com.sun.star.awt.TabControllerModel";
@@ -92,6 +94,8 @@ const sal_Char __FAR_DATA szServiceName_
 const sal_Char __FAR_DATA szServiceName_UnoControlRoadmapModel[] = "stardiv.vcl.controlmodel.Roadmap", szServiceName2_UnoControlRoadmapModel[] = "com.sun.star.awt.UnoControlRoadmapModel";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonControl[] = "com.sun.star.awt.UnoControlSpinButton";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonModel[] = "com.sun.star.awt.UnoControlSpinButtonModel";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[] = "com.sun.star.awt.UnoControlMultiPage";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[] = "com.sun.star.awt.UnoMultiPageModel";
 const sal_Char __FAR_DATA szServiceName_TreeControl[] = "com.sun.star.awt.tree.TreeControl";
 const sal_Char __FAR_DATA szServiceName_TreeControlModel[] = "com.sun.star.awt.tree.TreeControlModel";
 const sal_Char __FAR_DATA szServiceName_MutableTreeDataModel[] = "com.sun.star.awt.tree.MutableTreeDataModel";
--- udkapi/com/sun/star/script/ModuleInfo.idl.old	2010-03-03 16:59:35.000000000 +0100
+++ udkapi/com/sun/star/script/ModuleInfo.idl	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	com::sun::star::uno::XInterface ModuleObject; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- udkapi/com/sun/star/script/ModuleType.idl.old	2010-03-03 16:59:35.000000000 +0100
+++ udkapi/com/sun/star/script/ModuleType.idl	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleType.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleType_idl__
+#define __com_sun_star_script_ModuleType_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+published constants ModuleType
+{
+    const long Unknown = 0;
+    const long Normal = 1;  
+    const long Class = 2;
+    const long Form = 3;
+    const long Document = 4;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- udkapi/com/sun/star/script/XAutomationInvocation.idl.old	2010-03-03 16:59:35.000000000 +0100
+++ udkapi/com/sun/star/script/XAutomationInvocation.idl	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XInvocation2.idl,v $
+ * $Revision: 1.10 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XAutomationInvocation_idl__ 
+#define __com_sun_star_script_XAutomationInvocation_idl__
+ 
+#ifndef __com_sun_star_script_XInvocation_idl__ 
+#include <com/sun/star/script/XInvocation.idl> 
+#endif 
+ 
+ 
+ module com {  module sun {  module star {  module script {  
+ 
+interface XAutomationInvocation: com::sun::star::script::XInvocation
+{ 
+    any invokeGetProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+    any invokePutProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+ 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
--- udkapi/com/sun/star/script/XErrorQuery.idl.old	2010-03-03 16:59:35.000000000 +0100
+++ udkapi/com/sun/star/script/XErrorQuery.idl	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,25 @@
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#define __com_sun_star_script_XErrorQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+
+interface XErrorQuery : ::com::sun::star::uno::XInterface
+{
+  //-----------------------------------------------------------------------
+  /**
+    Returns whether this object has an error
+
+    @return
+    <atom>boolean</atom> indicating an error or not
+  */
+  boolean hasError();
+
+};
+
+};  };  };  };
+#endif
--- udkapi/com/sun/star/script/makefile.mk.old	2009-10-07 15:06:10.000000000 +0200
+++ udkapi/com/sun/star/script/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -85,6 +85,10 @@ IDLFILES=\
     XScriptEventsAttacher.idl\
     XDefaultMethod.idl\
     XDefaultProperty.idl\
+	XAutomationInvocation.idl\
+    ModuleInfo.idl\
+    ModuleType.idl\
+    XErrorQuery.idl\
 
 # ------------------------------------------------------------------
 
--- vbahelper/inc/vbahelper/vbacollectionimpl.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/inc/vbahelper/vbacollectionimpl.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -161,12 +161,25 @@ typedef InheritedHelperInterfaceImpl< If
 protected:
 	css::uno::Reference< css::container::XIndexAccess > m_xIndexAccess;
 	css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
+    sal_Bool mbIgnoreCase;
 
 	virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException)
 	{
 		if ( !m_xNameAccess.is() )
 			throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase string index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
 	
+        if( mbIgnoreCase )
+        {
+            css::uno::Sequence< rtl::OUString > sElementNames = m_xNameAccess->getElementNames();
+            for( sal_Int32 i = 0; i < sElementNames.getLength(); i++ )
+            {
+                rtl::OUString aName = sElementNames[i];
+                if( aName.equalsIgnoreAsciiCase( sIndex ) )
+                {
+                    return createCollectionObject( m_xNameAccess->getByName( aName ) );
+                }
+            }
+        }
 		return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
 	}		
 
@@ -185,7 +198,7 @@ protected:
 		return createCollectionObject( m_xIndexAccess->getByIndex( nIndex - 1 ) );		
 	}
 public:
-	ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ){ m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
+	ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, sal_Bool bIgnoreCase = sal_False ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ), mbIgnoreCase( bIgnoreCase ) { m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
 	//XCollection
 	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException)
 	{
@@ -250,7 +263,7 @@ class VBAHELPER_DLLPUBLIC CollTestImplHe
 typedef ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc >  > ImplBase1;
 
 public:
-	CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess ) {}
+	CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, sal_Bool bIgnoreCase = sal_False ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess, bIgnoreCase ) {}
 };
 
 
--- vbahelper/inc/vbahelper/vbadocumentbase.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/inc/vbahelper/vbadocumentbase.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -60,7 +60,7 @@ public:
 	virtual void SAL_CALL Close( const css::uno::Any &bSaveChanges,
 								 const css::uno::Any &aFileName,
 								 const css::uno::Any &bRouteWorkbook ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
 	virtual void SAL_CALL Unprotect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
 	virtual void SAL_CALL Save() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
--- vbahelper/inc/vbahelper/vbaeventshelperbase.hxx.old	2010-03-03 16:59:35.000000000 +0100
+++ vbahelper/inc/vbahelper/vbaeventshelperbase.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBAEVENTS_HELPER_BASE_HXX
+#define VBAEVENTS_HELPER_BASE_HXX
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <map>
+
+class VBAHELPER_DLLPUBLIC VbaEventsHelperBase
+{
+protected:
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    sal_Bool mbIgnoreEvents;
+    std::map< sal_Int32, rtl::OUString > m_aEventNameMap;
+
+protected:    
+    void insert( const sal_Int32 nId, const rtl::OUString& sEventName );
+    rtl::OUString getEventName( const sal_Int32 nEventId );
+
+public:    
+    VbaEventsHelperBase( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+};
+
+#endif /* VBAEVENTS_HELPER_BASE_HXX */
--- vbahelper/inc/vbahelper/vbahelper.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/inc/vbahelper/vbahelper.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -97,6 +97,7 @@ namespace ooo
         VBAHELPER_DLLPUBLIC void setDefaultPropByIntrospection( const css::uno::Any& aObj, const css::uno::Any& aValue  ) throw ( css::uno::RuntimeException );
         VBAHELPER_DLLPUBLIC css::uno::Any getPropertyValue( const css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName );
         VBAHELPER_DLLPUBLIC sal_Bool setPropertyValue( css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName, const css::uno::Any& aValue );
+        VBAHELPER_DLLPUBLIC void setOrAppendPropertyValue( css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName, const css::uno::Any& aValue );
 
 class VBAHELPER_DLLPUBLIC Millimeter
 {
--- vbahelper/inc/vbahelper/vbashaperange.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/inc/vbahelper/vbashaperange.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -59,6 +59,8 @@ public:
     virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
     virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException) ;
     virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
     virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
     virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
@@ -79,6 +81,7 @@ public:
     virtual void SAL_CALL setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL SAL_CALL TextFrame(  ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL SAL_CALL WrapFormat(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ZOrder( sal_Int32 ZOrderCmd ) throw (css::uno::RuntimeException);
     //XEnumerationAccess
     virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
     virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException); 
--- vbahelper/prj/d.lst.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/prj/d.lst	2010-03-03 16:59:35.000000000 +0100
@@ -25,3 +25,4 @@ mkdir: %_DEST%\inc%_EXT%\basic
 ..\inc\vbahelper\vbatextframe.hxx %_DEST%\inc%_EXT%\vbahelper\vbatextframe.hxx
 ..\inc\vbahelper\vbashaperange.hxx %_DEST%\inc%_EXT%\vbahelper\vbashaperange.hxx
 ..\inc\vbahelper\vbapagesetupbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbapagesetupbase.hxx
+..\inc\vbahelper\vbaeventshelperbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbaeventshelperbase.hxx
--- vbahelper/source/msforms/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -40,6 +40,8 @@ VISIBILITY_HIDDEN=TRUE
 
 .INCLUDE :  settings.mk
 
+CDEFS+=-DVBA_OOBUILD_HACK
+
 SLOFILES=\
     $(SLO)$/vbacontrol.obj \
     $(SLO)$/vbacontrols.obj \
--- vbahelper/source/msforms/vbacheckbox.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbacheckbox.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -35,12 +35,12 @@
 #ifndef SC_VBA_CHECKBOX_HXX
 #define SC_VBA_CHECKBOX_HXX
 #include <cppuhelper/implbase2.hxx>
-#include <ooo/vba/msforms/XRadioButton.hpp>
+#include <ooo/vba/msforms/XCheckBox.hpp>
 
 #include "vbacontrol.hxx"
 #include <vbahelper/vbahelper.hxx>
 
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > CheckBoxImpl_BASE;
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XCheckBox, css::script::XDefaultProperty > CheckBoxImpl_BASE;
 
 class ScVbaCheckbox : public CheckBoxImpl_BASE
 {
--- vbahelper/source/msforms/vbacombobox.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbacombobox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -29,6 +29,9 @@
  ************************************************************************/
 #include "vbacombobox.hxx"
 #include <vector>
+#include <svx/msvbahelper.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
 
 using namespace com::sun::star;
 using namespace ooo::vba;
@@ -66,12 +69,41 @@ ScVbaComboBox::setListIndex( const uno::
     sal_Int16 nIndex = 0;
     if( _value >>= nIndex )
     {
+        sal_Int32 nOldIndex = -1;
+        getListIndex() >>= nOldIndex;
 	    uno::Sequence< rtl::OUString > sItems;
     	m_xProps->getPropertyValue( ITEMS ) >>= sItems;
         if( ( nIndex >= 0 ) && ( sItems.getLength() > nIndex ) )
         {
             rtl::OUString sText = sItems[ nIndex ];
             m_xProps->setPropertyValue( TEXT, uno::makeAny( sText ) );
+
+            // fire the _Change event
+            if( nOldIndex != nIndex )
+            {
+                rtl::OUString sControlName = getName();
+                // get active module
+                SbModule* pModule = StarBASIC::GetActiveModule();
+                StarBASIC* pLib = pModule ? dynamic_cast< StarBASIC* >( pModule->GetParent() ) : NULL;
+                if( pModule && pLib )
+                {
+                    rtl::OUString sMacroName = pModule->GetParent()->GetName();
+                    rtl::OUString sModuleName = pModule->GetName();
+                    sMacroName = sMacroName.concat(  rtl::OUString::createFromAscii(".") ).concat( sModuleName ).concat(  rtl::OUString::createFromAscii(".") ).concat( sControlName ).concat( rtl::OUString::createFromAscii("_Change") );
+                    OSL_TRACE("ScVbaComboBox::setListIndex, fire the event %s", 
+                        rtl::OUStringToOString( sMacroName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    //static const rtl::OUString sThisComponent( RTL_CONSTASCII_USTRINGPARAM("ThisComponent" ) );
+                    //uno::Reference< frame::XModel > xModel = getCurrentDoc( sThisComponent );
+                    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( m_xModel ), sMacroName );
+                    if( aMacroInfo.IsResolved() )
+                    {
+                        uno::Sequence< uno::Any > aArgs;
+                        uno::Any aRet;
+                        uno::Any aDummyCaller;
+                        executeMacro( aMacroInfo.MacroDocContext(), aMacroInfo.ResolvedMacro(), aArgs, aRet, aDummyCaller );
+                    }
+                }
+            }
         }
     }
 }
--- vbahelper/source/msforms/vbacontrol.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbacontrol.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -371,6 +371,18 @@ ScVbaControl::setControlTipText( const r
 	m_xProps->setPropertyValue
             (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "HelpText" ) ), uno::makeAny( rsToolTip ) );
 }
+
+::sal_Int32 SAL_CALL ScVbaControl::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	sal_Int32 nForeColor;
+	m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "TextColor" ) ) ) >>= nForeColor; 
+	return OORGBToXLRGB( nForeColor );
+}
+
+void SAL_CALL ScVbaControl::setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException)
+{	
+	 m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "TextColor" ) ), uno::makeAny( XLRGBToOORGB( _forecolor ) ) );
+}
 //ScVbaControlFactory
 
 ScVbaControlFactory::ScVbaControlFactory( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel ): m_xContext( xContext ), m_xControl( xControl ), m_xModel( xModel )
@@ -400,16 +412,25 @@ ScVbaControl* ScVbaControlFactory::creat
     const static rtl::OUString sClassId( RTL_CONSTASCII_USTRINGPARAM("ClassId") );
     xProps->getPropertyValue( sClassId ) >>= nClassId;
     uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
-    switch( nClassId )
+    sal_Bool bToggle = sal_False;  //liuchen 2009-8-11,  
+	switch( nClassId )
     {
         case form::FormComponentType::COMBOBOX:
             return new ScVbaComboBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::COMMANDBUTTON:
-            return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::FIXEDTEXT:
+			//liuchen 2009-8-11
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toggle") ) ) >>= bToggle;
+			if ( bToggle )
+				return new ScVbaToggleButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			else
+				return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			//liuchen 2009-8-11
+		case form::FormComponentType::FIXEDTEXT:
             return new ScVbaLabel( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::TEXTFIELD:
             return new ScVbaTextBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::CHECKBOX:
+            return new ScVbaCheckbox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::RADIOBUTTON:
             return new ScVbaRadioButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
         case form::FormComponentType::LISTBOX:
--- vbahelper/source/msforms/vbacontrol.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbacontrol.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -90,6 +90,8 @@ public:
     virtual void SAL_CALL setControlTipText( const rtl::OUString& ) throw (css::uno::RuntimeException);
     //remove resouce because ooo.vba.excel.XControl is a wrapper of com.sun.star.drawing.XControlShape
     virtual void removeResouce() throw( css::uno::RuntimeException );
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- vbahelper/source/msforms/vbaframe.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbaframe.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -72,6 +72,30 @@ ScVbaFrame::setValue( const uno::Any& _v
     _value >>= sCaption;
     setCaption( sCaption ); 
 }
+//liuchen 2009-7-6 
+::sal_Int32 SAL_CALL ScVbaFrame::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	return 0;
+}
+
+void SAL_CALL ScVbaFrame::setForeColor( ::sal_Int32 /*_forecolor*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	return;
+}
+//liuchen 2009-7-6 end
+
+rtl::OUString SAL_CALL 
+ScVbaFrame::getAccelerator() throw (css::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+	return rtl::OUString();
+}
+
+void SAL_CALL 
+ScVbaFrame::setAccelerator( const rtl::OUString& /*_accelerator*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+}
 
 rtl::OUString& 
 ScVbaFrame::getServiceImplName()
--- vbahelper/source/msforms/vbaframe.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbaframe.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -51,6 +51,12 @@ public:
     virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	//liuchen 2009-7-6 
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
+	//liuchen 2009-7-6 end
+	virtual rtl::OUString SAL_CALL getAccelerator() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAccelerator( const rtl::OUString& _accelerator ) throw (css::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- vbahelper/source/msforms/vbalabel.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbalabel.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -67,6 +67,18 @@ ScVbaLabel::setValue( const uno::Any& _v
     setCaption( sCaption ); 
 }
 
+rtl::OUString SAL_CALL 
+ScVbaLabel::getAccelerator() throw (css::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+	return rtl::OUString();
+}
+
+void SAL_CALL 
+ScVbaLabel::setAccelerator( const rtl::OUString& /*_accelerator*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	//FIXME: seems not support?
+}
 
 rtl::OUString& 
 ScVbaLabel::getServiceImplName()
--- vbahelper/source/msforms/vbalabel.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbalabel.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -47,6 +47,8 @@ public:
     virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
     virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	virtual rtl::OUString SAL_CALL getAccelerator() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAccelerator( const rtl::OUString& _accelerator ) throw (css::uno::RuntimeException);
     //XHelperInterface
     virtual rtl::OUString& getServiceImplName();
     virtual css::uno::Sequence<rtl::OUString> getServiceNames();
--- vbahelper/source/msforms/vbalistbox.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbalistbox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -113,7 +113,7 @@ ScVbaListBox::setValue( const uno::Any&
     uno::Sequence< sal_Int16 > nSelectedIndices(1);
     nSelectedIndices[ 0 ] = nValue;
     m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nSelectedIndices ) ); 
-    m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) ); 
+	//m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) );   //liuchen 2009-8-12 solve the problem that ListBox.Text and ListBox.Value cannot be set
 }
 
 ::rtl::OUString SAL_CALL 
@@ -130,20 +130,22 @@ ScVbaListBox::setText( const ::rtl::OUSt
 	setValue( uno::makeAny( _text ) ); // seems the same
 }
 
-sal_Bool SAL_CALL 
+sal_Int32 SAL_CALL 
 ScVbaListBox::getMultiSelect() throw (css::uno::RuntimeException)
 {
     sal_Bool bMultiSelect = sal_False;
     m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ) ) >>= bMultiSelect;
-    return bMultiSelect;
+    return bMultiSelect ? 1 : 0 ;
 }
 
 void SAL_CALL 
-ScVbaListBox::setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException)
+ScVbaListBox::setMultiSelect( sal_Int32 _multiselect ) throw (css::uno::RuntimeException)
 {
-    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( _multiselect ) );
+	sal_Bool bMultiSelect = _multiselect == 1 ? 1 : 0;
+    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( bMultiSelect ) );
 }
 
+
 css::uno::Any SAL_CALL 
 ScVbaListBox::Selected( sal_Int32 index ) throw (css::uno::RuntimeException)
 {
--- vbahelper/source/msforms/vbalistbox.hxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbalistbox.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -61,8 +61,8 @@ public:
 	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
 	virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);  //liuchen 2009-7-31
+    virtual void SAL_CALL setMultiSelect( ::sal_Int32 _multiselect ) throw (css::uno::RuntimeException); //liuchen 2009-7-31
     virtual css::uno::Any SAL_CALL Selected( ::sal_Int32 index ) throw (css::uno::RuntimeException);
 
 	// Methods
--- vbahelper/source/msforms/vbalistcontrolhelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbalistcontrolhelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1,11 +1,69 @@
 #include <vbalistcontrolhelper.hxx>
 #include <vector>
+#include <vbahelper/vbapropvalue.hxx>
 
 using namespace com::sun::star;
 using namespace ooo::vba;
 
 const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
 
+class ListPropListener : public PropListener
+{
+private:
+    uno::Reference< beans::XPropertySet > m_xProps;
+    uno::Any m_pvargIndex; 
+    uno::Any m_pvarColumn;
+
+public:
+    ListPropListener( const uno::Reference< beans::XPropertySet >& xProps, const uno::Any& pvargIndex, const uno::Any& pvarColumn );
+    virtual void setValueEvent( const css::uno::Any& value );
+    virtual css::uno::Any getValueEvent();
+};
+
+ListPropListener::ListPropListener( const uno::Reference< beans::XPropertySet >& xProps, const uno::Any& pvargIndex, const uno::Any& pvarColumn ) : m_xProps( xProps ), m_pvargIndex( pvargIndex ), m_pvarColumn( pvarColumn )
+{
+}
+
+void ListPropListener::setValueEvent( const uno::Any& value )
+{
+    if( m_pvargIndex.hasValue() || m_pvarColumn.hasValue() )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                "Bad argument" ), uno::Reference< uno::XInterface >() );       
+
+    m_xProps->setPropertyValue( ITEMS, value );
+}
+
+uno::Any ListPropListener::getValueEvent()
+{
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
+    uno::Any aRet;
+    if ( m_pvargIndex.hasValue() )
+    {
+        sal_Int16 nIndex = -1;
+        m_pvargIndex >>= nIndex;
+        if( nIndex < 0 || nIndex >= nLength )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
+        aRet <<= sList[ nIndex ];
+    }
+    else if ( m_pvarColumn.hasValue() ) // pvarColumn on its own would be bad
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
+    else // List() ( e.g. no args )
+    {
+        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
+        for ( sal_Int32 i = 0; i < nLength; ++i )
+        {
+            sReturnArray[ i ].realloc( 10 );
+            sReturnArray[ i ][ 0 ] = sList[ i ];
+        }        
+        aRet = uno::makeAny( sReturnArray );
+    }
+    return aRet;
+}
+
 void SAL_CALL 
 ListControlHelper::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
 {
@@ -116,31 +174,5 @@ ListControlHelper::getListCount() throw
 uno::Any SAL_CALL 
 ListControlHelper::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
 {
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
-    uno::Any aRet;
-    if ( pvargIndex.hasValue() )
-    {
-        sal_Int16 nIndex = -1;
-        pvargIndex >>= nIndex;
-        if( nIndex < 0 || nIndex >= nLength )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
-        aRet <<= sList[ nIndex ];
-    }
-    else if ( pvarColumn.hasValue() ) // pvarColumn on its own would be bad
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
-    else // List() ( e.g. no args )
-    {
-        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
-        for ( sal_Int32 i = 0; i < nLength; ++i )
-        {
-            sReturnArray[ i ].realloc( 10 );
-            sReturnArray[ i ][ 0 ] = sList[ i ];
-        }        
-        aRet = uno::makeAny( sReturnArray );
-    }
-    return aRet;
+    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( new ListPropListener( m_xProps, pvargIndex, pvarColumn ) ) ) );
 }
--- vbahelper/source/msforms/vbatextbox.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbatextbox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -93,7 +93,8 @@ ScVbaTextBox::getMaxLength() throw (css:
 void SAL_CALL 
 ScVbaTextBox::setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException)
 {
-    uno::Any aValue( _maxlength );
+	sal_Int16 _maxlength16 = static_cast<sal_Int16> (_maxlength); //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
+    uno::Any aValue( _maxlength16 );                              //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
     m_xProps->setPropertyValue
             (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ), aValue);
 }
--- vbahelper/source/msforms/vbatogglebutton.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/msforms/vbatogglebutton.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -76,16 +76,33 @@ ScVbaToggleButton::getValue() throw (uno
  	return uno::makeAny( nState ? sal_Int16( -1 ) : sal_Int16( 0 ) );
 }
 
+//liuchen 2009-7-23, resolve the defect that ToggleButton.Value cannot be set correctly
 void SAL_CALL 
 ScVbaToggleButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
 {
 	sal_Int16 nState = 0;
-	_value >>= nState;
+	if (_value.getValueTypeClass() == typelib_TypeClass_BOOLEAN)
+	{
+		sal_Bool bValue;
+		_value >>= bValue;
+		nState = static_cast< sal_Int16 >(bValue);
+	}
+	else if (_value.getValueTypeClass() == typelib_TypeClass_BYTE)
+	{
+		sal_Int8 nValue;
+		_value >>= nValue;
+		nState = ( nValue == 1) ? 1 : 0;
+	}
+	else
+	{
+		_value >>= nState;
         OSL_TRACE( "nState - %d", nState );
-	nState = ( nState == -1 ) ?  1 : 0;
+		nState = ( nState == -1 ) ?  1 : 0;
         OSL_TRACE( "nState - %d", nState );
+	}
 	m_xProps->setPropertyValue( STATE, uno::makeAny(  nState ) );
 }
+//liuchen 2009-7-23
 
 rtl::OUString& 
 ScVbaToggleButton::getServiceImplName()
--- vbahelper/source/vbahelper/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -64,6 +64,7 @@ SLOFILES=\
     $(SLO)$/vbashaperange.obj \
     $(SLO)$/vbatextframe.obj \
     $(SLO)$/vbapagesetupbase.obj \
+    $(SLO)$/vbaeventshelperbase.obj \
 
 # --- Targets -------------------------------------------------------
 
--- vbahelper/source/vbahelper/vbaapplicationbase.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbaapplicationbase.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -76,6 +76,8 @@ void SAL_CALL
 VbaApplicationBase::setScreenUpdating(sal_Bool bUpdate) throw (uno::RuntimeException)
 {
 	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	if( bUpdate != xModel->hasControllersLocked() )
+		return;
 	if (bUpdate)
 		xModel->unlockControllers();
 	else
@@ -141,7 +143,8 @@ VbaApplicationBase::getVersion() throw (
 
 void SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const uno::Any& varg1, const uno::Any& varg2, const uno::Any& varg3, const uno::Any& varg4, const uno::Any& varg5, const uno::Any& varg6, const uno::Any& varg7, const uno::Any& varg8, const uno::Any& varg9, const uno::Any& varg10, const uno::Any& varg11, const uno::Any& varg12, const uno::Any& varg13, const uno::Any& varg14, const uno::Any& varg15, const uno::Any& varg16, const uno::Any& varg17, const uno::Any& varg18, const uno::Any& varg19, const uno::Any& varg20, const uno::Any& varg21, const uno::Any& varg22, const uno::Any& varg23, const uno::Any& varg24, const uno::Any& varg25, const uno::Any& varg26, const uno::Any& varg27, const uno::Any& varg28, const uno::Any& varg29, const uno::Any& varg30 ) throw (uno::RuntimeException)
 {
-    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( getCurrentDocument() ), MacroName );
+    // search the global tempalte
+    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( getCurrentDocument() ), MacroName, sal_True );
     if( aMacroInfo.IsResolved() )
     {
         // handle the arguments
--- vbahelper/source/vbahelper/vbadocumentbase.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbadocumentbase.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -36,6 +36,7 @@
 #include <com/sun/star/util/XCloseable.hpp>
 #include <com/sun/star/frame/XStorable.hpp>
 #include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XTitle.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 
 #include <tools/urlobj.hxx>
@@ -69,13 +70,8 @@ VbaDocumentBase::getName() throw (uno::R
 	}
 	else
 	{
-		const static rtl::OUString sTitle( RTL_CONSTASCII_USTRINGPARAM("Title" ) );
-		// process "UntitledX - $(PRODUCTNAME)"
-		uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-		uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
-		xProps->getPropertyValue(sTitle ) >>= sName;
-		sal_Int32 pos = 0;
-		sName = sName.getToken(0,' ',pos);	
+		uno::Reference< frame::XTitle > xTitle( getModel(), uno::UNO_QUERY_THROW );
+		sName = xTitle->getTitle();
 	}
 	return sName;
 }
@@ -131,12 +127,20 @@ VbaDocumentBase::Close( const uno::Any &
 	uno::Reference< util::XCloseable > xCloseable( getModel(), uno::UNO_QUERY );
 
 	if( xCloseable.is() )
+	{
 		// use close(boolean DeliverOwnership)
 	
 		// The boolean parameter DeliverOwnership tells objects vetoing the close process that they may
 		// assume ownership if they object the closure by throwing a CloseVetoException
 		// Here we give up ownership. To be on the safe side, catch possible veto exception anyway.
-		xCloseable->close(sal_True);
+		try{
+			xCloseable->close(sal_True);
+		}
+		catch( util::CloseVetoException )
+		{
+			//close is cancelled, nothing to do
+		}
+	}
 	// If close is not supported by this model - try to dispose it.
 	// But if the model disagree with a reset request for the modify state
 	// we shouldn't do so. Otherwhise some strange things can happen.
@@ -144,7 +148,16 @@ VbaDocumentBase::Close( const uno::Any &
 	{
 		uno::Reference< lang::XComponent > xDisposable ( getModel(), uno::UNO_QUERY );
 		if ( xDisposable.is() )
-			xDisposable->dispose();
+        {
+            // To be on the safe side, catch possible veto exception anyway.
+            try
+            {
+			    xDisposable->dispose();
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }    
 	}
 }
 
--- vbahelper/source/vbahelper/vbadocumentsbase.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbadocumentsbase.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -37,6 +37,7 @@
 #include <com/sun/star/lang/XComponent.hpp>
 #include <com/sun/star/frame/XModel.hpp>
 #include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XTitle.hpp>
 #include <com/sun/star/frame/FrameSearchFlag.hpp>
 #include <com/sun/star/util/XModifiable.hpp>
 #include <com/sun/star/frame/XStorable.hpp>
@@ -146,8 +147,18 @@ public:
 			{
 				uno::Reference< frame::XModel > xModel( xServiceInfo, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
 				m_documents.push_back( xModel );
-				INetURLObject aURL( xModel->getURL() );
-				namesToIndices[ aURL.GetLastName() ] = nIndex++;
+                rtl::OUString sName = xModel->getURL();
+                if( sName.getLength() )
+                {
+				    INetURLObject aURL( xModel->getURL() );
+				    namesToIndices[ aURL.GetLastName() ] = nIndex++;
+                }    
+                else
+                {
+                    uno::Reference< frame::XTitle > xTitle( xModel, uno::UNO_QUERY_THROW );
+                    sName = xTitle->getTitle();
+                    namesToIndices[ sName ] = nIndex++;
+                }
 			}
 		}
 			
--- vbahelper/source/vbahelper/vbaeventshelperbase.cxx.old	2010-03-03 16:59:35.000000000 +0100
+++ vbahelper/source/vbahelper/vbaeventshelperbase.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbaeventshelperbase.hxx>
+
+using namespace ::com::sun::star;
+
+VbaEventsHelperBase::VbaEventsHelperBase( const css::uno::Reference< css::uno::XComponentContext >& xContext ) : m_xContext( xContext ), mbIgnoreEvents( sal_False )
+{
+}
+
+void VbaEventsHelperBase::insert( const sal_Int32 nId, const rtl::OUString& sEventName )
+{
+    m_aEventNameMap.insert( std::make_pair( nId, sEventName ) );
+}
+
+rtl::OUString VbaEventsHelperBase::getEventName( const sal_Int32 nId )
+{
+    std::map< sal_Int32, rtl::OUString >::iterator iter = m_aEventNameMap.find( nId );
+    if( iter != m_aEventNameMap.end() )
+        return iter->second;
+    return rtl::OUString();    
+}
+
+void SAL_CALL VbaEventsHelperBase::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException)
+{
+    mbIgnoreEvents = _ignoreevents;
+}
+
+::sal_Bool SAL_CALL VbaEventsHelperBase::getIgnoreEvents() throw (css::uno::RuntimeException)
+{
+    return mbIgnoreEvents;
+}
+
--- vbahelper/source/vbahelper/vbahelper.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbahelper.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -970,6 +970,18 @@ sal_Bool setPropertyValue( uno::Sequence
     return sal_False;
 }
 
+void setOrAppendPropertyValue( uno::Sequence< beans::PropertyValue >& aProp, const rtl::OUString& aName, const uno::Any& aValue )
+{
+   if( setPropertyValue( aProp, aName, aValue ) )
+    return;
+  
+  // append the property
+  sal_Int32 nLength = aProp.getLength();
+  aProp.realloc( nLength + 1 );
+  aProp[ nLength ].Name = aName;
+  aProp[ nLength ].Value = aValue;
+}
+
 #define VBA_LEFT "PositionX"
 #define VBA_TOP "PositionY"
 UserFormGeometryHelper::UserFormGeometryHelper( const uno::Reference< uno::XComponentContext >& /*xContext*/, const uno::Reference< awt::XControl >& xControl )
--- vbahelper/source/vbahelper/vbapictureformat.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbapictureformat.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -115,13 +115,14 @@ ScVbaPictureFormat::IncrementContrast( d
 {
     double nContrast = getContrast();
     nContrast += increment;
-    if( increment < 0 )
+	//VBA, minz@cn.ibm.com.
+    if( nContrast < 0 )
     {
-        increment = 0.0;
+        nContrast = 0.0;
     }
-    if( increment > 1 )
+    if( nContrast > 1 )
     {
-        increment = 1.0;
+        nContrast = 1.0;
     }
     setContrast( nContrast );
 }
--- vbahelper/source/vbahelper/vbashape.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbashape.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -38,6 +38,7 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/text/TextContentAnchorType.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
 #include <ooo/vba/word/WdRelativeHorizontalPosition.hpp>
 #include <ooo/vba/word/WdRelativeVerticalPosition.hpp>
 
@@ -222,25 +223,66 @@ ScVbaShape::setWidth( double _width ) th
 double SAL_CALL 
 ScVbaShape::getLeft() throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->getLeft();
+    double left = 0;
+    try
+    {
+        left = m_pShapeHelper->getLeft();
+    }
+    catch( uno::Exception& )
+    {
+        // fail to get position by using XShape::getPosition()
+        sal_Int32 nLeft = 0;
+        m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientPosition") ) ) >>= nLeft;
+        left = Millimeter::getInPoints( nLeft );
+    }
+    return left;
 }
 
 void SAL_CALL 
 ScVbaShape::setLeft( double _left ) throw (uno::RuntimeException)
 {
-    m_pShapeHelper->setLeft( _left );
+    try
+    {
+        m_pShapeHelper->setLeft( _left );
+    }
+    catch( uno::Exception& )
+    {
+        sal_Int32 nLeft = 0;
+        nLeft = Millimeter::getInHundredthsOfOneMillimeter( _left );
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "HoriOrientPosition" ), uno::makeAny( nLeft ) );
+    }
 }
 
 double SAL_CALL 
 ScVbaShape::getTop() throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->getTop();
+    double top = 0;
+    try
+    {
+        top = m_pShapeHelper->getTop();
+    }
+    catch( uno::Exception& )
+    {
+        sal_Int32 nTop = 0;
+        m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientPosition") ) ) >>= nTop;
+        top = Millimeter::getInPoints( nTop );
+    }    
+    return top;
 }
 
 void SAL_CALL 
 ScVbaShape::setTop( double _top ) throw (uno::RuntimeException)
 {
-    return m_pShapeHelper->setTop( _top );
+    try
+    {
+        m_pShapeHelper->setTop( _top );
+    }    
+    catch( uno::Exception& )
+    {
+        sal_Int32 nTop = 0;
+        nTop = Millimeter::getInHundredthsOfOneMillimeter( _top );
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "VertOrientPosition" ), uno::makeAny( nTop ) );
+    }
 }
 
 sal_Bool SAL_CALL 
@@ -507,35 +549,34 @@ sal_Int32 SAL_CALL
 ScVbaShape::getRelativeHorizontalPosition() throw (uno::RuntimeException)
 {
     sal_Int32 nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
-    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    sal_Int16 nType = text::RelOrientation::PAGE_LEFT;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientRelation") ) ) >>= nType;
     
-    switch( eType )
+    switch( nType )
     {
-        case text::TextContentAnchorType_AT_PARAGRAPH:
+        case text::RelOrientation::FRAME:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn;
             break;
         }
-        case text::TextContentAnchorType_AT_PAGE:
+        case text::RelOrientation::PAGE_FRAME:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage;
             break;
         }
-        case text::TextContentAnchorType_AT_CHARACTER:
+        case text::RelOrientation::CHAR:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter;
             break;
         }
-        case text::TextContentAnchorType_AT_FRAME:
-        case text::TextContentAnchorType_AS_CHARACTER:
+        case text::RelOrientation::PAGE_PRINT_AREA:
         {
             nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
             break;
         }
         default:
         {
-            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
+            throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Shape::RelativeHorizontalPosition: not implemented" ) ), uno::Reference< uno::XInterface >() );
         }
     }
     return nRelativeHorizontalPosition;
@@ -544,23 +585,27 @@ ScVbaShape::getRelativeHorizontalPositio
 void SAL_CALL 
 ScVbaShape::setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (uno::RuntimeException)
 {
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
     switch( _relativehorizontalposition )
     {
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter:
         {
-            eType = text::TextContentAnchorType_AT_CHARACTER;
+            nType = text::RelOrientation::CHAR;
             break;
         }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn:
+        {
+            nType = text::RelOrientation::PAGE_FRAME;
+            break;
+        }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin:
         {
-            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            nType = text::RelOrientation::PAGE_PRINT_AREA;
             break;
         }
         case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage:
         {
-            eType = text::TextContentAnchorType_AT_PAGE;
+            nType = text::RelOrientation::PAGE_FRAME;
             break;
         }
         default:
@@ -568,42 +613,41 @@ ScVbaShape::setRelativeHorizontalPositio
             DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
         }
     }
-    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HoriOrientRelation") ), uno::makeAny( nType ) );
 }
 
 sal_Int32 SAL_CALL 
 ScVbaShape::getRelativeVerticalPosition() throw (uno::RuntimeException)
 {
     sal_Int32 nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
-    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientRelation") ) ) >>= nType;
     
-    switch( eType )
+    switch( nType )
     {
-        case text::TextContentAnchorType_AT_PARAGRAPH:
+        case text::RelOrientation::FRAME:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph;
             break;
         }
-        case text::TextContentAnchorType_AT_PAGE:
+        case text::RelOrientation::PAGE_FRAME:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage;
             break;
         }
-        case text::TextContentAnchorType_AT_CHARACTER:
+        case text::RelOrientation::TEXT_LINE:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine;
             break;
         }
-        case text::TextContentAnchorType_AT_FRAME:
-        case text::TextContentAnchorType_AS_CHARACTER:
+        case text::RelOrientation::PAGE_PRINT_AREA:
         {
             nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
             break;
         }
         default:
         {
-            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
+            throw  uno::RuntimeException( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Shape::RelativeVerticalPosition: not implemented" ) ), uno::Reference< uno::XInterface >() );
         }
     }
     return nRelativeVerticalPosition;
@@ -612,23 +656,27 @@ ScVbaShape::getRelativeVerticalPosition(
 void SAL_CALL 
 ScVbaShape::setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (uno::RuntimeException)
 {
-    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    sal_Int16 nType = text::RelOrientation::PAGE_FRAME;
     switch( _relativeverticalposition )
     {
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine:
         {
-            eType = text::TextContentAnchorType_AT_CHARACTER;
+            nType = text::RelOrientation::TEXT_LINE;
             break;
         }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph:
+        {
+            nType = text::RelOrientation::FRAME;
+            break;
+        }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin:
         {
-            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            nType = text::RelOrientation::PAGE_PRINT_AREA;
             break;
         }
         case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage:
         {
-            eType = text::TextContentAnchorType_AT_PAGE;
+            nType = text::RelOrientation::PAGE_FRAME;
             break;
         }
         default:
@@ -636,7 +684,7 @@ ScVbaShape::setRelativeVerticalPosition(
             DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
         }
     }
-    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VertOrientRelation") ), uno::makeAny( nType ) );
 }
 
 uno::Any SAL_CALL 
--- vbahelper/source/vbahelper/vbashaperange.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbashaperange.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -128,6 +128,27 @@ ScVbaShapeRange::IncrementTop( double In
 	}
 }
 
+rtl::OUString SAL_CALL ScVbaShapeRange::getName() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getName( );
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setName( _name );
+	}
+}
+
 double SAL_CALL ScVbaShapeRange::getHeight() throw (uno::RuntimeException)
 {
 	sal_Int32 nLen = getCount();
@@ -340,6 +361,16 @@ uno::Any SAL_CALL ScVbaShapeRange::WrapF
     throw uno::RuntimeException();
 }
 
+void SAL_CALL ScVbaShapeRange::ZOrder( sal_Int32 ZOrderCmd ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->ZOrder( ZOrderCmd );
+	}
+}
+
 uno::Type SAL_CALL
 ScVbaShapeRange::getElementType() throw (uno::RuntimeException)
 {
--- vbahelper/source/vbahelper/vbashapes.cxx.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/source/vbahelper/vbashapes.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -89,7 +89,7 @@ void ScVbaShapes::initBaseCollection()
 	m_xNameAccess.set( xShapes, uno::UNO_QUERY );
 }
 
-ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const uno::Reference< frame::XModel>& xModel ): ScVbaShapes_BASE( xParent, xContext, xShapes ), m_nNewShapeCount(0), m_xModel( xModel )
+ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const uno::Reference< frame::XModel>& xModel ): ScVbaShapes_BASE( xParent, xContext, xShapes, sal_True ), m_nNewShapeCount(0), m_xModel( xModel )
 {
     m_xShapes.set( xShapes, uno::UNO_QUERY_THROW );
     m_xDrawPage.set( xShapes, uno::UNO_QUERY_THROW ); 
--- vbahelper/util/makefile.mk.old	2010-03-03 16:59:33.000000000 +0100
+++ vbahelper/util/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -95,6 +95,7 @@ SHL2STDLIBS= \
         $(VCLLIB) \
         $(TKLIB) \
                 $(BASICLIB) \
+		$(SVXMSFILTERLIB) \
 
 SHL2DEPN=$(SHL1TARGETN)
 SHL2LIBS=$(SLB)$/$(TARGET_MSFORMS).lib
--- vcl/inc/vcl/bitmap.hxx.old	2009-10-07 15:06:53.000000000 +0200
+++ vcl/inc/vcl/bitmap.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -270,9 +270,9 @@ public:
     SAL_DLLPRIVATE void                 ImplSetImpBitmap( ImpBitmap* pImpBmp );
     SAL_DLLPRIVATE void                 ImplAssignWithSize( const Bitmap& rBitmap );
 
-    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bMSOFormat=FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBFileHeader( SvStream& rIStm, ULONG& rOffset );
-    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, BOOL bMSOFormat = FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBPalette( SvStream& rIStm, BitmapWriteAccess& rAcc, BOOL bQuad );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBBits( SvStream& rIStm, DIBInfoHeader& rHeader, BitmapWriteAccess& rAcc, sal_Bool bTopDown );
     SAL_DLLPRIVATE BOOL                 ImplWriteDIB( SvStream& rOStm, BitmapReadAccess& rAcc, BOOL bCompressed ) const;
@@ -767,7 +767,7 @@ public:
 
 public:
 
-    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE );
+    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE, BOOL bMSOFormat = FALSE );
     BOOL                    Write( SvStream& rOStm, BOOL bCompressed = TRUE, BOOL bFileHeader = TRUE ) const;
 
     friend VCL_DLLPUBLIC SvStream&        operator>>( SvStream& rIStm, Bitmap& rBitmap );
--- vcl/inc/vcl/bitmapex.hxx.old	2009-11-20 11:38:57.000000000 +0100
+++ vcl/inc/vcl/bitmapex.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -398,6 +398,7 @@ public:
 
     friend VCL_DLLPUBLIC SvStream&	operator<<( SvStream& rOStm, const BitmapEx& rBitmapEx );
     friend VCL_DLLPUBLIC SvStream&	operator>>( SvStream& rIStm, BitmapEx& rBitmapEx );
+	static BitmapEx AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize);
 };
 
 #endif // _SV_BITMAPEX_HXX
--- vcl/inc/vcl/dialog.hxx.old	2009-10-07 15:06:53.000000000 +0200
+++ vcl/inc/vcl/dialog.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -56,6 +56,7 @@ private:
     BOOL			mbOldSaveBack;
     BOOL			mbInClose;
     BOOL			mbModalMode;
+	sal_Int8		mnCancelClose;  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
 
     SAL_DLLPRIVATE void    ImplInitDialogData();
     SAL_DLLPRIVATE void    ImplInitSettings();
@@ -93,6 +94,9 @@ public:
     virtual short	Execute();
     BOOL			IsInExecute() const { return mbInExecute; }
 
+	sal_Int8		GetCloseFlag() const { return mnCancelClose; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	void			SetCloseFlag( sal_Int8 nCancel ) { mnCancelClose = nCancel; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+
     ////////////////////////////////////////
     // Dialog::Execute replacement API
 public:
--- vcl/inc/vcl/menu.hxx.old	2009-10-07 15:06:53.000000000 +0200
+++ vcl/inc/vcl/menu.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -93,6 +93,8 @@ typedef USHORT MenuItemBits;
 #define MIB_POPUPSELECT 		((MenuItemBits)0x0020)
 // not in rsc/vclsrc.hxx because only a prelimitary solution
 #define MIB_NOSELECT 		    ((MenuItemBits)0x0040)
+#define MIB_ICON 		    ((MenuItemBits)0x0080)
+#define MIB_TEXT 		    ((MenuItemBits)0x0100)
 
 #define MENU_FLAG_NOAUTOMNEMONICS		0x0001
 #define MENU_FLAG_HIDEDISABLEDENTRIES	0x0002
--- vcl/inc/vcl/toolbox.hxx.old	2009-10-08 16:17:47.000000000 +0200
+++ vcl/inc/vcl/toolbox.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -124,6 +124,9 @@ typedef USHORT ToolBoxItemBits;
 #define TIB_DROPDOWN            ((ToolBoxItemBits)0x0020)
 #define TIB_REPEAT              ((ToolBoxItemBits)0x0040)
 #define TIB_DROPDOWNONLY        ((ToolBoxItemBits)0x0080 | TIB_DROPDOWN)    // this button has only drop down functionality
+#define TIB_TEXT_ONLY           ((ToolBoxItemBits)0x0100)
+#define TIB_ICON_ONLY           ((ToolBoxItemBits)0x0200)
+#define TIB_TEXTICON            ((ToolBoxItemBits) TIB_TEXT_ONLY | TIB_ICON_ONLY )
 
 // -----------------
 // - ToolBox-Types -
--- vcl/source/control/combobox.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ vcl/source/control/combobox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -471,8 +471,11 @@ IMPL_LINK( ComboBox, ImplSelectHdl, void
         mpSubEdit->SetModifyFlag();
         mbSyntheticModify = TRUE;
         Modify();
-        mbSyntheticModify = FALSE;
-        Select();
+		mbSyntheticModify = FALSE;		
+		if (ImplGetWindowImpl() != NULL) //liuchen 2009-7-28, resolve the problem that soffice get crashed if in ComboBox_Change event a Worksheets("SheetX").Activate sentence needs to be executed 
+		{
+			Select();
+		}
     }
 
     return 0;
--- vcl/source/gdi/bitmap2.cxx.old	2010-03-03 16:59:29.000000000 +0100
+++ vcl/source/gdi/bitmap2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -49,6 +49,8 @@
 
 #define DIBCOREHEADERSIZE			( 12UL )
 #define DIBINFOHEADERSIZE			( sizeof( DIBInfoHeader ) )
+#define BITMAPINFOHEADER                        0x28
+
 #define SETPIXEL4( pBuf, nX, cChar )( (pBuf)[ (nX) >> 1 ] |= ( (nX) & 1 ) ? ( cChar ): (cChar) << 4 );
 
 // ----------------------
@@ -132,7 +134,7 @@ SvStream& operator<<( SvStream& rOStm, c
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader )
+BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader, BOOL bIsMSOFormat )
 {
     const USHORT	nOldFormat = rIStm.GetNumberFormatInt();
     const ULONG 	nOldPos = rIStm.Tell();
@@ -147,7 +149,7 @@ BOOL Bitmap::Read( SvStream& rIStm, BOOL
             bRet = ImplReadDIB( rIStm, *this, nOffset );
     }
     else
-        bRet = ImplReadDIB( rIStm, *this, nOffset );
+		bRet = ImplReadDIB( rIStm, *this, nOffset, bIsMSOFormat );
 
     if( !bRet )
     {
@@ -164,14 +166,14 @@ BOOL Bitmap::Read( SvStream& rIStm, BOOL
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset )
+BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bIsMSOFormat )
 {
     DIBInfoHeader	aHeader;
     const ULONG 	nStmPos = rIStm.Tell();
     BOOL			bRet = FALSE;
     sal_Bool		bTopDown = sal_False;
 
-    if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
+	if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown, bIsMSOFormat ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
     {
         const USHORT nBitCount( discretizeBitcount(aHeader.nBitCount) );
 
@@ -302,20 +304,36 @@ BOOL Bitmap::ImplReadDIBFileHeader( SvSt
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown )
+BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, sal_Bool bIsMSOFormat )
 {
     // BITMAPINFOHEADER or BITMAPCOREHEADER
     rIStm >> rHeader.nSize;
 
     // BITMAPCOREHEADER
+	sal_Int16 nTmp16 = 0;
+	sal_uInt8 nTmp8 = 0;
     if ( rHeader.nSize == DIBCOREHEADERSIZE )
     {
-        sal_Int16 nTmp16;
 
         rIStm >> nTmp16; rHeader.nWidth = nTmp16;
         rIStm >> nTmp16; rHeader.nHeight = nTmp16;
         rIStm >> rHeader.nPlanes;
         rIStm >> rHeader.nBitCount;
+	}
+	else if ( bIsMSOFormat && ( rHeader.nSize == BITMAPINFOHEADER ) )
+	{
+		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
+		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
+		rIStm >> nTmp8; rHeader.nPlanes = nTmp8;
+		rIStm >> nTmp8; rHeader.nBitCount = nTmp8;
+		rIStm >> nTmp16; rHeader.nSizeImage = nTmp16;
+		rIStm >> nTmp16; rHeader.nCompression = nTmp16;
+		if ( !rHeader.nSizeImage ) // uncompressed?
+			rHeader.nSizeImage = ((rHeader.nWidth * rHeader.nBitCount + 31) & ~31) / 8 * rHeader.nHeight;
+		rIStm >> rHeader.nXPelsPerMeter;
+		rIStm >> rHeader.nYPelsPerMeter;
+		rIStm >> rHeader.nColsUsed;
+		rIStm >> rHeader.nColsImportant;
     }
     else
     {
--- vcl/source/gdi/bitmapex.cxx.old	2009-11-20 11:38:57.000000000 +0100
+++ vcl/source/gdi/bitmapex.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -48,6 +48,7 @@
 #endif
 #include <vcl/svapp.hxx>
 #include <vcl/bmpacc.hxx>
+#include <vcl/virdev.hxx>
 
 // ------------
 // - BitmapEx -
@@ -760,6 +761,61 @@ void BitmapEx::Draw( OutputDevice* pOutD
     pOutDev->DrawBitmapEx( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, *this );
 }
 
+BitmapEx BitmapEx:: AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize)
+{
+	Point aEmptyPoint(0,0);
+	sal_Int32 imgNewWidth = 0;
+	sal_Int32 imgNewHeight = 0;
+	double imgposX = 0;
+	double imgposY = 0;
+    BitmapEx  aRet = aBitmap;
+	double imgOldWidth = aRet.GetSizePixel().Width();
+	double imgOldHeight =aRet.GetSizePixel().Height();
+
+    Size aScaledSize;
+    if (imgOldWidth >= aStandardSize || imgOldHeight >= aStandardSize)
+	{
+		if (imgOldWidth >= imgOldHeight)
+		{
+			imgNewWidth = aStandardSize;
+			imgNewHeight = sal_Int32(imgOldHeight / (imgOldWidth / aStandardSize) + 0.5);
+			imgposX = 0;
+			imgposY = (aStandardSize - (imgOldHeight / (imgOldWidth / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+		else
+		{
+			imgNewHeight = aStandardSize;
+			imgNewWidth = sal_Int32(imgOldWidth / (imgOldHeight / aStandardSize) + 0.5);
+			imgposY = 0;
+			imgposX = (aStandardSize - (imgOldWidth / (imgOldHeight / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+
+		aScaledSize = Size( imgNewWidth, imgNewHeight );
+        aRet.Scale( aScaledSize, BMP_SCALE_INTERPOLATE );
+	}
+	else
+	{
+		imgposX = (aStandardSize - imgOldWidth) / 2 + 0.5;
+		imgposY = (aStandardSize - imgOldHeight) / 2 + 0.5;
+	}
+
+    Size aBmpSize = aRet.GetSizePixel();
+    Size aStdSize( aStandardSize, aStandardSize );
+    Rectangle aRect(aEmptyPoint, aStdSize );
+
+    VirtualDevice aVirDevice( *Application::GetDefaultDevice(), 0, 1 );
+	aVirDevice.SetOutputSizePixel( aStdSize );
+	aVirDevice.SetFillColor( COL_TRANSPARENT );
+    aVirDevice.SetLineColor( COL_TRANSPARENT );
+
+    //draw a rect into virDevice
+	aVirDevice.DrawRect( aRect );
+	Point aPointPixel( (long)imgposX, (long)imgposY );
+	aVirDevice.DrawBitmapEx( aPointPixel, aRet );
+	aRet = aVirDevice.GetBitmapEx( aEmptyPoint, aStdSize );
+
+	return aRet;
+}
 // ------------------------------------------------------------------
 
 sal_uInt8 BitmapEx::GetTransparency(sal_Int32 nX, sal_Int32 nY) const
--- vcl/source/window/dialog.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ vcl/source/window/dialog.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -550,7 +550,14 @@ BOOL Dialog::Close()
 {
     ImplDelData aDelData;
     ImplAddDel( &aDelData );
-    ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );
+	//liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	mnCancelClose = 0;
+	ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );	
+	if (mnCancelClose == 1)
+	{
+		return FALSE;
+	}
+	//liuchen 2009-7-22
     if ( aDelData.IsDelete() )
         return FALSE;
     ImplRemoveDel( &aDelData );
--- vcl/source/window/toolbox.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ vcl/source/window/toolbox.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -229,6 +229,22 @@ int ToolBox::ImplGetDragWidth( ToolBox*
     }
     return width;
 }
+
+ButtonType determineButtonType( ImplToolItem* pItem, ButtonType defaultType )
+{
+    ButtonType tmpButtonType = defaultType;
+    ToolBoxItemBits nBits( pItem->mnBits & 0x300 );
+    if ( nBits & TIB_TEXTICON ) // item has custom setting
+    {
+        tmpButtonType = BUTTON_SYMBOLTEXT; 
+        if ( nBits == TIB_TEXT_ONLY )
+            tmpButtonType = BUTTON_TEXT; 
+        else if ( nBits == TIB_ICON_ONLY )
+            tmpButtonType = BUTTON_SYMBOL; 
+    }
+    return tmpButtonType;
+}
+
 // -----------------------------------------------------------------------
 
 void ToolBox::ImplUpdateDragArea( ToolBox *pThis )
@@ -1992,12 +2008,13 @@ BOOL ToolBox::ImplCalcItem()
                     bText = FALSE;
                 else
                     bText = TRUE;
-
+                ButtonType tmpButtonType = determineButtonType( &(*it), meButtonType ); // default to toolbox setting 
                 if ( bImage || bText )
                 {
+
                     it->mbEmptyBtn = FALSE;
 
-                    if ( meButtonType == BUTTON_SYMBOL )
+                    if ( tmpButtonType == BUTTON_SYMBOL )
                     {
                         // we're drawing images only
                         if ( bImage || !bText )
@@ -2011,7 +2028,7 @@ BOOL ToolBox::ImplCalcItem()
                             it->mbVisibleText = TRUE;
                         }
                     }
-                    else if ( meButtonType == BUTTON_TEXT )
+                    else if ( tmpButtonType == BUTTON_TEXT )
                     {
                         // we're drawing text only
                         if ( bText || !bImage )
@@ -3625,7 +3642,8 @@ void ToolBox::ImplDrawItem( USHORT nPos,
     // determine what has to be drawn on the button: image, text or both
     BOOL bImage;
     BOOL bText;
-    pItem->DetermineButtonDrawStyle( meButtonType, bImage, bText );
+    ButtonType tmpButtonType = determineButtonType( pItem, meButtonType ); // default to toolbox setting 
+    pItem->DetermineButtonDrawStyle( tmpButtonType, bImage, bText );
 
     // compute output values
     long    nBtnWidth = aBtnSize.Width()-SMALLBUTTON_HSIZE;
--- vcl/source/window/toolbox2.cxx.old	2009-10-08 16:17:47.000000000 +0200
+++ vcl/source/window/toolbox2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -59,6 +59,8 @@ using namespace rtl;
 
 #define TB_SEP_SIZE 			8
 
+ButtonType determineButtonType( ImplToolItem* pItem, ButtonType defaultType );
+
 // -----------------------------------------------------------------------
 
 ImplToolBoxPrivateData::ImplToolBoxPrivateData() :
--- xmloff/inc/xmlnmspe.hxx.old	2010-03-03 16:44:01.000000000 +0100
+++ xmloff/inc/xmlnmspe.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -105,6 +105,7 @@ XML_OLD_NAMESPACE( META,	6U )
 
 // experimental namespaces
 XML_NAMESPACE( FIELD,			100U )
+XML_NAMESPACE( FORMX,           101U )      // form interop extensions
 
 
 #endif	//  _XMLOFF_XMLNMSPE_HXX
--- xmloff/inc/xmloff/shapeexport.hxx.old	2009-10-07 15:07:04.000000000 +0200
+++ xmloff/inc/xmloff/shapeexport.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -197,11 +197,6 @@ private:
     const rtl::OUString							msStartShape;
     const rtl::OUString							msEndShape;
     const rtl::OUString							msOnClick;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    const rtl::OUString							msOnAction;
-    const rtl::OUString							msAction;
-    const rtl::OUString							msURL;
-#endif
     const rtl::OUString							msEventType;
     const rtl::OUString							msPresentation;
     const rtl::OUString							msMacroName;
--- xmloff/inc/xmloff/xmltoken.hxx.old	2010-03-03 16:59:15.000000000 +0100
+++ xmloff/inc/xmloff/xmltoken.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -151,6 +151,10 @@ namespace xmloff { namespace token {
         XML_NP_TABLE_EXT,
         XML_N_TABLE_EXT,
         
+        // jonp: 2008-09-24 Excel Interop
+        XML_NP_FORMX,
+        XML_N_FORMX,
+
         // units
         XML_UNIT_MM,
         XML_UNIT_M,
--- xmloff/source/core/xmlexp.cxx.old	2010-03-03 16:44:01.000000000 +0100
+++ xmloff/source/core/xmlexp.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -345,6 +345,7 @@ void SvXMLExport::_InitCtor()
         mpNamespaceMap->Add( GetXMLToken(XML_NP_XSD), GetXMLToken(XML_N_XSD), XML_NAMESPACE_XSD );
         mpNamespaceMap->Add( GetXMLToken(XML_NP_XSI), GetXMLToken(XML_N_XSI), XML_NAMESPACE_XSI );
         mpNamespaceMap->Add( GetXMLToken(XML_NP_FIELD), GetXMLToken(XML_N_FIELD), XML_NAMESPACE_FIELD );
+		mpNamespaceMap->Add( GetXMLToken(XML_NP_FORMX), GetXMLToken(XML_N_FORMX), XML_NAMESPACE_FORMX );
     }
     // RDFa: needed for content and header/footer styles
     if( (getExportFlags() & (EXPORT_STYLES|EXPORT_AUTOSTYLES|EXPORT_MASTERSTYLES|EXPORT_CONTENT) ) != 0 )
--- xmloff/source/core/xmlimp.cxx.old	2010-03-03 16:44:01.000000000 +0100
+++ xmloff/source/core/xmlimp.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -117,6 +117,7 @@ sal_Char __READONLY_DATA sXML_np__script
 sal_Char __READONLY_DATA sXML_np__config[] = "_config";
 sal_Char __READONLY_DATA sXML_np__db[] = "_db";
 sal_Char __READONLY_DATA sXML_np__xforms[] = "_xforms";
+sal_Char __READONLY_DATA sXML_np__formx[] = "_formx";
 sal_Char __READONLY_DATA sXML_np__xsd[] = "_xsd";
 sal_Char __READONLY_DATA sXML_np__xsi[] = "_xsi";
 sal_Char __READONLY_DATA sXML_np__field[] = "_field";
@@ -308,6 +309,9 @@ void SvXMLImport::_InitCtor()
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xforms) ),
                             GetXMLToken(XML_N_XFORMS_1_0),
                             XML_NAMESPACE_XFORMS );
+        mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__formx) ),
+                            GetXMLToken( XML_N_FORMX ),
+                            XML_NAMESPACE_FORMX );
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xsd) ),
                             GetXMLToken(XML_N_XSD),
                             XML_NAMESPACE_XSD );
--- xmloff/source/core/xmltoken.cxx.old	2010-03-03 16:59:15.000000000 +0100
+++ xmloff/source/core/xmltoken.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -156,6 +156,10 @@ namespace xmloff { namespace token {
         TOKEN( "officeooo", XML_NP_OFFICE_EXT ),
         TOKEN( "http://openoffice.org/2009/office", XML_N_OFFICE_EXT ),
 
+        // jonp: 2008-09-24 Excel Interop
+        TOKEN( "formx",                           XML_NP_FORMX ),
+        TOKEN( "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0", XML_N_FORMX ),
+
         TOKEN( "tableooo", XML_NP_TABLE_EXT ),
         TOKEN( "http://openoffice.org/2009/table", XML_N_TABLE_EXT ),
 
--- xmloff/source/draw/eventimp.cxx.old	2009-10-07 15:07:04.000000000 +0200
+++ xmloff/source/draw/eventimp.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -104,9 +104,6 @@ public:
 
     sal_Bool mbValid;
     sal_Bool mbScript;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    sal_Bool mbActionEvent;
-#endif
     ClickAction meClickAction;
     XMLEffect meEffect;
     XMLEffectDirection meDirection;
@@ -118,9 +115,6 @@ public:
     OUString msMacroName;
     OUString msBookmark;
     OUString msLanguage;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    OUString msHyperURL;
-#endif
 };
 
 ///////////////////////////////////////////////////////////////////////
@@ -179,18 +173,11 @@ TYPEINIT1( SdXMLEventContext, SvXMLImpor
 
 SdXMLEventContext::SdXMLEventContext( SvXMLImport& rImp,  sal_uInt16 nPrfx, const OUString& rLocalName,  const Reference< XAttributeList >& xAttrList, const Reference< XShape >& rxShape )
 :	SvXMLImportContext(rImp, nPrfx, rLocalName),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    mxShape( rxShape ), mbScript( sal_False ), mbActionEvent( sal_False ), meClickAction( ClickAction_NONE ),
-#else
     mxShape( rxShape ), mbScript( sal_False ), meClickAction( ClickAction_NONE ),
-#endif
     meEffect( EK_none ), meDirection( ED_none ), mnStartScale( 100 ),
     meSpeed( AnimationSpeed_MEDIUM ), mnVerb(0), mbPlayFull( sal_False )
 {
     static const OUString sXMLClickName( RTL_CONSTASCII_USTRINGPARAM( "click" ) );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    static const OUString sXMLActionName( RTL_CONSTASCII_USTRINGPARAM( "action" ) );
-#endif
 
     if( nPrfx == XML_NAMESPACE_PRESENTATION && IsXMLToken( rLocalName, XML_EVENT_LISTENER ) )
     {
@@ -261,12 +248,7 @@ SdXMLEventContext::SdXMLEventContext( Sv
                 sEventName = sValue;
                 sal_uInt16 nScriptPrefix =
                     GetImport().GetNamespaceMap().GetKeyByAttrName( sValue, &sEventName );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                mbValid = XML_NAMESPACE_DOM == nScriptPrefix && ( sEventName == sXMLClickName || sEventName == sXMLActionName );
-                mbActionEvent = mbValid && (sEventName == sXMLActionName);
-#else
                 mbValid = XML_NAMESPACE_DOM == nScriptPrefix && sEventName == sXMLClickName;
-#endif
             }
             else if( IsXMLToken( aAttrLocalName, XML_LANGUAGE ) )
             {
@@ -295,12 +277,6 @@ SdXMLEventContext::SdXMLEventContext( Sv
                 {
                     msMacroName = sValue;
                 }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                else if ( mbActionEvent )
-                {
-                    msHyperURL = sValue;
-                }
-#endif
                 else
                 {
                     const rtl::OUString &rTmp =
@@ -346,26 +322,6 @@ void SdXMLEventContext::EndElement()
         OUString sAPIEventName;
         uno::Sequence< beans::PropertyValue > aProperties;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        if( mbActionEvent )
-        {
-            sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) );
-            aProperties.realloc( 2 );
-            beans::PropertyValue* pProperty = aProperties.getArray();
-
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) );
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-            ++pProperty;
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= msHyperURL;
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-        }
-        else
-#endif
-        {
             sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) );
 
             if( mbScript )
@@ -550,8 +506,6 @@ void SdXMLEventContext::EndElement()
                     break;
                 }
             }
-        }
-
         xEvents->replaceByName( sAPIEventName, uno::Any( aProperties ) );
 
     } while(0);
--- xmloff/source/draw/shapeexport.cxx.old	2009-10-07 15:07:04.000000000 +0200
+++ xmloff/source/draw/shapeexport.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -87,11 +87,6 @@ XMLShapeExport::XMLShapeExport(SvXMLExpo
     msStartShape( RTL_CONSTASCII_USTRINGPARAM("StartShape") ),
     msEndShape( RTL_CONSTASCII_USTRINGPARAM("EndShape") ),
     msOnClick( RTL_CONSTASCII_USTRINGPARAM("OnClick") ),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    msOnAction( RTL_CONSTASCII_USTRINGPARAM("OnAction") ),
-    msAction( RTL_CONSTASCII_USTRINGPARAM("Action") ),
-    msURL( RTL_CONSTASCII_USTRINGPARAM("URL") ),
-#endif
     msEventType( RTL_CONSTASCII_USTRINGPARAM("EventType") ),
     msPresentation( RTL_CONSTASCII_USTRINGPARAM("Presentation") ),
     msMacroName( RTL_CONSTASCII_USTRINGPARAM("MacroName") ),
--- xmloff/source/draw/shapeexport2.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/draw/shapeexport2.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -297,9 +297,6 @@ const sal_Int32 FOUND_CLICKEVENTTYPE
 const sal_Int32 FOUND_MACRO             = 0x00000100;
 const sal_Int32 FOUND_LIBRARY           = 0x00000200;
 const sal_Int32 FOUND_ACTIONEVENTTYPE   = 0x00000400;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-const sal_Int32 FOUND_URL               = 0x00000800;
-#endif
 
 } // namespace
 
@@ -389,33 +386,6 @@ void XMLShapeExport::ImpExportEvents( co
         }
     }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    // extract properties from "OnAction" event -------------------------------
-
-    OUString aActionEventType;
-    OUString aHyperURL;
-
-    uno::Sequence< beans::PropertyValue > aActionProperties;
-    if( xEvents->hasByName( msOnAction ) && (xEvents->getByName( msOnAction ) >>= aActionProperties) )
-    {
-        const beans::PropertyValue* pProperty = aActionProperties.getConstArray();
-        const beans::PropertyValue* pPropertyEnd = pProperty + aActionProperties.getLength();
-        for( ; pProperty != pPropertyEnd; ++pProperty )
-        {
-            if( ( ( nFound & FOUND_ACTIONEVENTTYPE ) == 0 ) && pProperty->Name == msEventType )
-            {
-                if( pProperty->Value >>= aActionEventType )
-                    nFound |= FOUND_ACTIONEVENTTYPE;
-            }
-            else if( ( ( nFound & FOUND_URL ) == 0 ) && ( pProperty->Name == msURL  ) )
-            {
-                if( pProperty->Value >>= aHyperURL )
-                    nFound |= FOUND_URL;
-            }
-        }
-    }
-#endif
-
     // create the XML elements
 
     if( aClickEventType == msPresentation )
@@ -567,15 +537,9 @@ void XMLShapeExport::ImpExportEvents( co
             SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
         }
     }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    else if( aClickEventType == msScript || aActionEventType == msAction )
-    {
-        if( nFound & ( FOUND_MACRO | FOUND_URL ) )
-#else
     else if( aClickEventType == msScript )
     {
         if( nFound & FOUND_MACRO )
-#endif
         {
             SvXMLElementExport aEventsElemt(mrExport, XML_NAMESPACE_OFFICE, XML_EVENT_LISTENERS, sal_True, sal_True);
             if ( nFound & FOUND_MACRO )
@@ -590,18 +554,6 @@ void XMLShapeExport::ImpExportEvents( co
 
                 SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( nFound & FOUND_URL )
-            {
-                OUString aEventQName(
-                    mrExport.GetNamespaceMap().GetQNameByKey(
-                            XML_NAMESPACE_DOM, OUString( RTL_CONSTASCII_USTRINGPARAM( "action" ) ) ) );
-                mrExport.AddAttribute( XML_NAMESPACE_SCRIPT, XML_EVENT_NAME, aEventQName );
-                mrExport.AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, aHyperURL );
-
-                SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_PRESENTATION, XML_EVENT_LISTENER, sal_True, sal_True);
-            }
-#endif
         }
     }
 }
--- xmloff/source/draw/ximpshap.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/draw/ximpshap.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -375,6 +375,11 @@ void SdXMLShapeContext::EndElement()
 
     if( msHyperlink.getLength() != 0 ) try
     {
+		uno::Reference< beans::XPropertySet > xProp( mxShape, uno::UNO_QUERY );
+
+		rtl::OUString sLink( RTL_CONSTASCII_USTRINGPARAM( "Hyperlink" ) );
+		if ( xProp.is() && xProp->getPropertySetInfo()->hasPropertyByName( sLink ) )
+			xProp->setPropertyValue( sLink, uno::Any( msHyperlink ) );
         Reference< XEventsSupplier > xEventsSupplier( mxShape, UNO_QUERY_THROW );
         Reference< XNameReplace > xEvents( xEventsSupplier->getEvents(), UNO_QUERY_THROW );
 
@@ -3230,9 +3235,16 @@ SvXMLImportContext *SdXMLFrameShapeConte
 
     if( !mxImplContext.Is() )
     {
-        pContext = GetImport().GetShapeImport()->CreateFrameChildContext(
+
+		SvXMLShapeContext* pShapeContext= GetImport().GetShapeImport()->CreateFrameChildContext(
                         GetImport(), nPrefix, rLocalName, xAttrList, mxShapes, mxAttrList );
 
+		pContext = pShapeContext;
+
+		// propagate the hyperlink to child context
+		if ( msHyperlink.getLength() > 0 )
+			pShapeContext->setHyperlink( msHyperlink );
+ 
         mxImplContext = pContext;
         mbSupportsReplacement = IsXMLToken( rLocalName, XML_OBJECT ) ||
                                 IsXMLToken( rLocalName, XML_OBJECT_OLE );
--- xmloff/source/forms/elementexport.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/forms/elementexport.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1113,6 +1113,39 @@ namespace xmloff
         }
 
         // ----------------------------------
+		// the string properties
+		{
+			static sal_Int32 nStringPropertyAttributeIds[] =
+			{	// attribute flags
+				SCA_GROUP_NAME
+			};
+			static const ::rtl::OUString* pStringPropertyNames[] =
+			{	// property names
+				&PROPERTY_GROUP_NAME
+			};
+
+			sal_Int32 nIdCount = sizeof( nStringPropertyAttributeIds ) / sizeof( nStringPropertyAttributeIds[0] );
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof( pStringPropertyNames ) / sizeof( pStringPropertyNames[0] );
+			OSL_ENSURE( ( nIdCount == nNameCount ),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (2)!" );
+		#endif
+			for ( i = 0; i < nIdCount; ++i )
+				if ( nStringPropertyAttributeIds[i] & m_nIncludeSpecial )
+				{
+					exportStringPropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( nStringPropertyAttributeIds[i] ),
+						OAttributeMetaData::getSpecialAttributeName( nStringPropertyAttributeIds[i] ),
+						*( pStringPropertyNames[i] )
+					);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~nStringPropertyAttributeIds[i];
+			#endif
+				}
+		}
+
+		// ----------------------------------
         if ((SCA_MIN_VALUE | SCA_MAX_VALUE) & m_nIncludeSpecial)
         {
             // need to export the min value and the max value as attributes
@@ -1570,6 +1603,8 @@ namespace xmloff
                 }
                 if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_IMAGE_POSITION ) )
                     m_nIncludeSpecial |= SCA_IMAGE_POSITION;
+                if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_GROUP_NAME ) )
+                    m_nIncludeSpecial |= SCA_GROUP_NAME;
                 m_nIncludeDatabase = DA_DATA_FIELD | DA_INPUT_REQUIRED;
                 m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE;
                 break;
--- xmloff/source/forms/formattributes.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/forms/formattributes.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -195,6 +195,7 @@ namespace xmloff
             case SCA_MAX_VALUE:				return "max-value";
             case SCA_MIN_VALUE:				return "min-value";
             case SCA_VALIDATION:			return "validation";
+            case SCA_GROUP_NAME:            return "group-name";
             case SCA_MULTI_LINE:			return "multi-line";
             case SCA_AUTOMATIC_COMPLETION:	return "auto-complete";
             case SCA_MULTIPLE: 				return "multiple";
@@ -215,9 +216,12 @@ namespace xmloff
     }
 
     //---------------------------------------------------------------------
-    sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 /*_nId*/)
+	sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 _nId)
     {
-        // nothing special here
+        switch( _nId )
+        {
+            case SCA_GROUP_NAME:            return XML_NAMESPACE_FORMX;
+        }
         return XML_NAMESPACE_FORM;
     }
 
--- xmloff/source/forms/formattributes.hxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/forms/formattributes.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -126,6 +126,7 @@ namespace xmloff
     #define SCA_MAX_VALUE				0x00000002
     #define SCA_MIN_VALUE				0x00000004
     #define SCA_VALIDATION				0x00000008
+    #define SCA_GROUP_NAME              0x00000010
     #define SCA_MULTI_LINE				0x00000020
     #define SCA_AUTOMATIC_COMPLETION	0x00000080
     #define SCA_MULTIPLE				0x00000100
--- xmloff/source/forms/layerimport.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/forms/layerimport.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -98,6 +98,8 @@ OFormLayerXMLImport_Impl::OFormLayerXMLI
     m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_NAME), PROPERTY_NAME);
     m_aAttributeMetaData.addStringProperty(
+			OAttributeMetaData::getSpecialAttributeName(SCA_GROUP_NAME), PROPERTY_GROUP_NAME);
+		m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_IMAGE_DATA), PROPERTY_IMAGEURL);
     m_aAttributeMetaData.addStringProperty(
         OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL), PROPERTY_LABEL);
--- xmloff/source/forms/strings.hxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmloff/source/forms/strings.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -208,6 +208,7 @@ namespace xmloff
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_POSITION,     "ImagePosition");
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_ALIGN,        "ImageAlign");
     XMLFORM_CONSTASCII_STRING( PROPERTY_SCALE_IMAGE,        "ScaleImage");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_GROUP_NAME,         "GroupName");
 
     XMLFORM_CONSTASCII_STRING( PROPERTY_BOUND_CELL,		    "BoundCell");
     XMLFORM_CONSTASCII_STRING( PROPERTY_LIST_CELL_RANGE,    "CellRange");
--- xmlscript/inc/xmlscript/xmldlg_imexp.hxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/inc/xmlscript/xmldlg_imexp.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -30,6 +30,8 @@
 #ifndef _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 #define _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 
+#include <com/sun/star/frame/XModel.hpp>
+
 #ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HXX_
 #include <com/sun/star/container/XNameContainer.hpp>
 #endif
@@ -54,7 +56,9 @@ void SAL_CALL exportDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::xml::sax::XExtendedDocumentHandler > const & xOut,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::container::XNameContainer > const & xDialogModel )
+    ::com::sun::star::container::XNameContainer > const & xDialogModel, 
+	::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -63,7 +67,9 @@ SAL_CALL importDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 // additional functions for convenience
@@ -74,7 +80,9 @@ SAL_CALL exportDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -84,7 +92,9 @@ void SAL_CALL importDialogModel(
     ::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (::com::sun::star::uno::Exception) );
 
 }
--- xmlscript/source/xmldlg_imexp/exp_share.hxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/exp_share.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -174,15 +174,17 @@ public:
     //
     void readDialogModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
+    void readMultiPageModel( StyleBag * all_styles )
+        SAL_THROW( (css::uno::Exception) );
     void readButtonModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readEditModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readCheckBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readRadioButtonModel( StyleBag * all_styles )
+    void readRadioButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
-    void readComboBoxModel( StyleBag * all_styles )
+    void readComboBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readCurrencyFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -196,9 +198,9 @@ public:
         SAL_THROW( (css::uno::Exception) );
     void readGroupBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readImageControlModel( StyleBag * all_styles )
+    void readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument  )
         SAL_THROW( (css::uno::Exception) );
-    void readListBoxModel( StyleBag * all_styles )
+    void readListBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readNumericFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -212,7 +214,9 @@ public:
         SAL_THROW( (css::uno::Exception) );
     void readProgressBarModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readScrollBarModel( StyleBag * all_styles )
+    void readScrollBarModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
+        SAL_THROW( (css::uno::Exception) );
+    void readSpinButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readFixedHyperLinkModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
--- xmlscript/source/xmldlg_imexp/imp_share.hxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/imp_share.hxx	2010-03-03 16:59:35.000000000 +0100
@@ -45,6 +45,7 @@
 #include <com/sun/star/awt/FontEmphasisMark.hpp>
 #include <com/sun/star/awt/FontRelief.hpp>
 #include <com/sun/star/xml/input/XRoot.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 #include <vector>
 
 
@@ -131,6 +132,8 @@ struct DialogImport
     
     css::uno::Reference< css::container::XNameContainer > _xDialogModel;
     css::uno::Reference< css::lang::XMultiServiceFactory > _xDialogModelFactory;
+    css::uno::Reference< css::frame::XModel > _xDoc;
+    css::uno::Reference< css::script::XLibraryContainer > _xScriptLibraryContainer;
 
     sal_Int32 XMLNS_DIALOGS_UID, XMLNS_SCRIPT_UID;
     
@@ -164,16 +167,20 @@ public:
     inline DialogImport(
         css::uno::Reference<css::uno::XComponentContext> const & xContext,
         css::uno::Reference<css::container::XNameContainer>
-        const & xDialogModel )
+        const & xDialogModel,
+        css::uno::Reference<css::frame::XModel> const & xDoc )
         SAL_THROW( () )
         : _xContext( xContext )
         , _xDialogModel( xDialogModel )
-        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW )
+        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW ), _xDoc( xDoc )
         { OSL_ASSERT( _xDialogModel.is() && _xDialogModelFactory.is() &&
                       _xContext.is() ); }
     virtual ~DialogImport()
         SAL_THROW( () );
     
+    inline css::uno::Reference< css::frame::XModel > getDocOwner() { return _xDoc; }
+
+	css::uno::Reference< css::script::XLibraryContainer > getScriptLibraryContainer();
     // XRoot
     virtual void SAL_CALL startDocument(
         css::uno::Reference< css::xml::input::XNamespaceMapping >
@@ -999,6 +1006,49 @@ public:
 };
 
 //==============================================================================
+class SpinButtonElement
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline SpinButtonElement(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
+//==============================================================================
+class MultiPage
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline MultiPage(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
 class ProgressBarElement
     : public ControlElement
 {
--- xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -44,6 +44,7 @@
 using namespace ::rtl;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 
 namespace xmlscript
 {
@@ -73,7 +74,8 @@ Reference< io::XInputStream > InputStrea
 //==================================================================================================
 Reference< io::XInputStreamProvider > SAL_CALL exportDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -98,7 +100,7 @@ Reference< io::XInputStreamProvider > SA
     
     Reference< io::XActiveDataSource > xSource( xHandler, UNO_QUERY );
     xSource->setOutputStream( createOutputStream( &aBytes ) );
-    exportDialogModel( xHandler, xDialogModel );
+	exportDialogModel( xHandler, xDialogModel, xDocument );
     
     return new InputStreamProvider( aBytes );
 }
@@ -107,7 +109,8 @@ Reference< io::XInputStreamProvider > SA
 void SAL_CALL importDialogModel(
     Reference< io::XInputStream > xInput,
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -129,7 +132,7 @@ void SAL_CALL importDialogModel(
     }
     
     // error handler, entity resolver omitted for this helper function
-    xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext ) );
+	xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext, xDocument ) );
     
     xml::sax::InputSource source;
     source.aInputStream = xInput;
--- xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -32,7 +32,16 @@
 #include "precompiled_xmlscript.hxx"
 #include "exp_share.hxx"
 
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 
 
 using namespace ::com::sun::star;
@@ -42,6 +51,66 @@ using ::rtl::OUString;
 namespace xmlscript
 {
 
+void lclExportBindableAndListSourceBits( Reference< frame::XModel > const & xDocument, const Reference< beans::XPropertySet >& _xProps, ElementDescriptor& rModel )
+{
+    Reference< lang::XMultiServiceFactory > xFac;
+    if ( xDocument.is() )
+        xFac.set( xDocument, uno::UNO_QUERY );
+
+    Reference< form::binding::XBindableValue > xBinding( _xProps, UNO_QUERY );
+
+    if ( xFac.is() && xBinding.is() )
+    {
+        try
+        {
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );  
+        Reference< beans::XPropertySet > xBindable( xBinding->getValueBinding(), UNO_QUERY );
+            if ( xBindable.is() )
+            {
+                table::CellAddress aAddress; 
+                xBindable->getPropertyValue( OUSTR("BoundCell") ) >>= aAddress; 
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                rtl::OUString sAddress;
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                if ( sAddress.getLength() > 0 )
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":linked-cell"), sAddress );
+                
+                OSL_TRACE( "*** Bindable value %s", rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+               
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+    Reference< form::binding::XListEntrySink > xEntrySink( _xProps, UNO_QUERY );
+    if ( xEntrySink.is() )
+    {
+        Reference< beans::XPropertySet > xListSource( xEntrySink->getListEntrySource(), UNO_QUERY );
+        if ( xListSource.is() )
+        {
+            try
+            {
+                Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );  
+
+                table::CellRangeAddress aAddress; 
+                xListSource->getPropertyValue( OUSTR( "CellRange" ) ) >>= aAddress;
+
+                rtl::OUString sAddress;
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                OSL_TRACE("**** cell range source list %s",
+                    rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+                if ( sAddress.getLength() > 0 );
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":source-cell-range"), sAddress );
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+    }
+
+}
 static inline bool readBorderProps(
     ElementDescriptor * element, Style & style )
 {
@@ -68,6 +137,42 @@ static inline bool readFontProps( Elemen
 }
 
 //__________________________________________________________________________________________________
+void ElementDescriptor::readMultiPageModel( StyleBag * all_styles )
+{
+    // collect styles
+    Style aStyle( 0x2 | 0x8 | 0x20 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextColor") ) ) >>= aStyle._textColor)
+        aStyle._set |= 0x2;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextLineColor") ) ) >>= aStyle._textLineColor)
+        aStyle._set |= 0x20;
+    if (readFontProps( this, aStyle ))
+        aStyle._set |= 0x8;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+
+    // collect elements
+    readDefaults();
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value-max") ) );
+
+    OUString aTitle;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("Label") ) ) >>= aTitle)
+    {
+        ElementDescriptor * title = new ElementDescriptor(
+            _xProps, _xPropState,
+            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":title") ) );
+        title->addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ),
+                             aTitle );
+        addSubElement( title );
+    }
+
+    readEvents();
+}
 void ElementDescriptor::readButtonModel( StyleBag * all_styles )
     SAL_THROW( (Exception) )
 {
@@ -209,7 +314,7 @@ void ElementDescriptor::readCheckBoxMode
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readComboBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readComboBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -250,7 +355,8 @@ void ElementDescriptor::readComboBoxMode
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxlength") ) );
     readShortAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("LineCount") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
-
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -276,7 +382,7 @@ void ElementDescriptor::readComboBoxMode
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readListBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readListBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -311,7 +417,7 @@ void ElementDescriptor::readListBoxModel
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
     readAlignAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );
-
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -351,7 +457,7 @@ void ElementDescriptor::readListBoxModel
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles )
+void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -388,6 +494,8 @@ void ElementDescriptor::readRadioButtonM
                            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":image-position") ) );
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multiline") ) );
+    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":group-name") ) );
 
     sal_Int16 nState = 0;
     if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ) ) >>= nState)
@@ -407,6 +515,7 @@ void ElementDescriptor::readRadioButtonM
             break;
         }
     }
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
@@ -579,7 +688,7 @@ void ElementDescriptor::readEditModel( S
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readImageControlModel( StyleBag * all_styles )
+void ElementDescriptor::readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -598,8 +707,31 @@ void ElementDescriptor::readImageControl
     readDefaults();
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scale-image") ) );
-    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":src") ) );
+    rtl::OUString sURL;
+    _xProps->getPropertyValue( OUSTR("ImageURL") ) >>= sURL;
+    
+    if ( sURL.indexOf( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.GraphicObject:"  ) ) ) == 0 )
+    {
+        Reference< document::XStorageBasedDocument > xDocStorage( xDocument, UNO_QUERY );
+
+        if ( xDocStorage.is() )
+        {
+            uno::Sequence< Any > aArgs( 1 );
+            aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+            ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+            uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+            aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicExportHelper" ), aArgs, xGraphicResolver );
+            if ( xGraphicResolver.is() )
+            {
+                sURL = xGraphicResolver->resolveGraphicObjectURL( sURL );
+            }
+        }     
+    }
+    if ( sURL.getLength() > 0 )
+    {
+        addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":src"), sURL );
+    }
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
     readEvents();
@@ -1074,7 +1206,7 @@ void ElementDescriptor::readProgressBarM
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readScrollBarModel( StyleBag * all_styles )
+void ElementDescriptor::readScrollBarModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -1112,6 +1244,47 @@ void ElementDescriptor::readScrollBarMod
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":live-scroll") ) );
     readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
                      OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
+    readEvents();
+}
+//__________________________________________________________________________________________________
+void ElementDescriptor::readSpinButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
+    SAL_THROW( (Exception) )
+{
+    // collect styles
+    Style aStyle( 0x1 | 0x4 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("BackgroundColor") ) ) >>= aStyle._backgroundColor)
+        aStyle._set |= 0x1;
+    if (readBorderProps( this, aStyle ))
+        aStyle._set |= 0x4;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+    
+    // collect elements
+    readDefaults();
+    readOrientationAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                         OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );  
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":increment") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":curval") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxval") ) );
+    readLongAttr( OUSTR("SpinValueMin"),
+                  OUSTR(XMLNS_DIALOGS_PREFIX ":minval") );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Repeat") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":repeat") ) );
+    readLongAttr( OUSTR("RepeatDelay"), OUSTR(XMLNS_DIALOGS_PREFIX ":repeat-delay") );
+    readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
+    readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
--- xmlscript/source/xmldlg_imexp/xmldlg_export.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/xmldlg_export.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -1328,7 +1328,8 @@ void StyleBag::dump( Reference< xml::sax
 //==================================================================================================
 void SAL_CALL exportDialogModel(
     Reference< xml::sax::XExtendedDocumentHandler > const & xOut,
-    Reference< container::XNameContainer > const & xDialogModel )
+    Reference< container::XNameContainer > const & xDialogModel,
+    Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     StyleBag all_styles;
@@ -1376,7 +1377,7 @@ void SAL_CALL exportDialogModel(
                 xProps, xPropState,
                 OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":radio") ) );
             xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-            pElem->readRadioButtonModel( &all_styles );
+            pElem->readRadioButtonModel( &all_styles, xDocument  );
             pRadioGroup->addSubElement( xElem );
         }
         else // no radio
@@ -1405,7 +1406,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":combobox") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readComboBoxModel( &all_styles );
+                pElem->readComboBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) ) )
             {
@@ -1413,7 +1414,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":menulist") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readListBoxModel( &all_styles );
+                pElem->readListBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) ) )
             {
@@ -1423,6 +1424,14 @@ void SAL_CALL exportDialogModel(
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
                 pElem->readGroupBoxModel( &all_styles );
             }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multipage") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readMultiPageModel( &all_styles );
+            }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFixedTextModel") ) ) )
             {
                 pElem = new ElementDescriptor(
@@ -1454,7 +1463,7 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":img") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readImageControlModel( &all_styles );
+                pElem->readImageControlModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFileControlModel") ) ) )
             {
@@ -1534,7 +1543,15 @@ void SAL_CALL exportDialogModel(
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scrollbar") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readScrollBarModel( &all_styles );
+                pElem->readScrollBarModel( &all_styles, xDocument );
+            }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlSpinButtonModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":spinbutton") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readSpinButtonModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlProgressBarModel") ) ) )
             {
--- xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx.old	2009-10-07 15:07:05.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -31,17 +31,195 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_xmlscript.hxx"
 #include "imp_share.hxx"
-
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyState.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
-
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using ::rtl::OUString;
 
 namespace xmlscript
 {
+Reference< xml::input::XElement > MultiPage::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+rtl::OUString _label = rtl::OUString::createFromAscii("foo");
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement(
+            nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("title") ))
+	{
+		getStringAttr( &_label,
+                       OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                       xAttributes,
+                       _pImport->XMLNS_DIALOGS_UID );
+		
+		return new ElementBase(
+            _pImport->XMLNS_DIALOGS_UID,
+            rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
+
+void MultiPage::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) );
+//		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) );
+	Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		pStyle->importTextColorStyle( xControlModel );
+		pStyle->importTextLineColorStyle( xControlModel );
+		pStyle->importFontStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( 0, 0, _xAttributes ); // inherited from BulletinBoardElement
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value-max") ),
+                            _xAttributes );
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+// #FIXME cut'n'pasted from xmloff/source/core/xmlimp.cxx:1251 
+// of course we need to find a common home for this helper
+
+bool IsPackageURL( const ::rtl::OUString& rURL )
+{
+    // Some quick tests: Some may rely on the package structure!
+    sal_Int32 nLen = rURL.getLength();
+    if( (nLen > 0 && '/' == rURL[0]) )
+        // RFC2396 net_path or abs_path
+        return false;
+    else if( nLen > 1 && '.' == rURL[0] )
+    {
+        if( '.' == rURL[1] )
+            // ../: We are never going up one level, so we know
+            // it's not an external URI
+            return false;
+        else if( '/' == rURL[1] )
+            // we are remaining on a level, so it's an package URI
+            return true;
+    }
+
+    // Now check for a RFC2396 schema
+    sal_Int32 nPos = 1;
+    while( nPos < nLen )
+    {
+        switch( rURL[nPos] )
+        {
+            case '/':
+                // a relative path segement
+                return true;
+            case ':':
+                // a schema
+                return false;
+            default:
+                break;
+                // we don't care about any other characters
+        }
+        ++nPos;
+    }
+
+    return true;
+}
+
+void importBindableAndListRangeBits( DialogImport* _pImport, const rtl::OUString sLinkedCell, const rtl::OUString & sCellRange, ControlImportContext& ctx )
+{
+    Reference< lang::XMultiServiceFactory > xFac( _pImport->getDocOwner(), UNO_QUERY );
+    if ( xFac.is() && ( sLinkedCell.getLength() ||  sCellRange.getLength() ) )
+    {
+        // Set up Celllink
+        if ( sLinkedCell.getLength() )
+        {
+            Reference< form::binding::XBindableValue > xBindable( ctx.getControlModel(), uno::UNO_QUERY );
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+            if ( xBindable.is() && xConvertor.is() )
+            {
+                table::CellAddress aAddress;
+                xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sLinkedCell ) );
+                xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+                beans::NamedValue aArg1;
+                aArg1.Name = OUSTR("BoundCell");
+                aArg1.Value <<= aAddress;
+           
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[ 0 ]  <<= aArg1;
+           
+                uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+                xBindable->setValueBinding( xBinding );
+ 
+            }
+        }
+        // Set up CelllRange
+        if ( sCellRange.getLength() )
+        {
+           Reference< form::binding::XListEntrySink  > xListEntrySink( ctx.getControlModel(), uno::UNO_QUERY );
+           Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+           if ( xListEntrySink.is() && xConvertor.is() )
+           {
+               table::CellRangeAddress aAddress;
+               xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sCellRange ) );
+               xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+               beans::NamedValue aArg1;
+               aArg1.Name = OUSTR("CellRange");
+               aArg1.Value <<= aAddress;
+           
+               uno::Sequence< uno::Any > aArgs(1);
+               aArgs[ 0 ]  <<= aArg1;
+           
+               uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+               xListEntrySink->setListEntrySource( xSource );
+ 
+           }
+       }
+   }
+}
+
+sal_Bool isVBACompatModeOn( DialogImport* _pImport )
+{
+	sal_Bool bVBAMode = sal_False;
+	Reference< script::XVBACompat > xVBACompat( _pImport->getScriptLibraryContainer(), UNO_QUERY );
+	if( xVBACompat.is() )
+	{
+		bVBAMode = xVBACompat->getVBACompatModeOn();
+	}
+	return bVBAMode;
+}
 
 // progessmeter
 //__________________________________________________________________________________________________
@@ -122,10 +300,24 @@ Reference< xml::input::XElement > Scroll
 void ScrollBarElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+	OUString sService( OUSTR("com.sun.star.awt.UnoControlScrollBarModel") );
+	// we should probably limit this to vba mode also ( leave for now )
+	if ( isVBACompatModeOn( _pImport ) )
+		sService = OUSTR("com.sun.star.form.component.ScrollBar");
+
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlScrollBarModel") ) );
-    
+		sService );	
+
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
     if (xStyle.is())
     {
@@ -168,6 +360,92 @@ void ScrollBarElement::endElement()
                                OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
                                _xAttributes );
     
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+//##################################################################################################
+
+// spinbutton
+//__________________________________________________________________________________________________
+Reference< xml::input::XElement > SpinButtonElement::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement( nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
+void SpinButtonElement::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.form.component.SpinButton") ) );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+        pStyle->importBackgroundColorStyle( xControlModel );
+		pStyle->importBorderStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( _nBasePosX, _nBasePosY, _xAttributes );
+	ctx.importOrientationProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                                   OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
+                                   _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("increment") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("curval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("maxval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("SpinValueMin"), OUSTR("minval"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("Repeat"), OUSTR("repeat"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("RepeatDelay"), OUSTR("repeat-delay"),
+                            _xAttributes );
+    ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
+                               _xAttributes );
+    ctx.importHexLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
+                               _xAttributes );
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+    
     ctx.importEvents( _events );
     // avoid ring-reference:
     // vector< event elements > holding event elements holding this (via _pParent)
@@ -1003,9 +1281,37 @@ void ImageControlElement::endElement()
     ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
                                OUString( RTL_CONSTASCII_USTRINGPARAM("scale-image") ),
                                _xAttributes );
-    ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-                              OUString( RTL_CONSTASCII_USTRINGPARAM("src") ),
-                              _xAttributes );
+    rtl::OUString sURL = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "src" ) );
+    Reference< document::XStorageBasedDocument > xDocStorage( _pImport->getDocOwner(), UNO_QUERY );
+
+    if ( xDocStorage.is() && IsPackageURL( sURL ) )
+    {
+        uno::Sequence< Any > aArgs( 1 );
+        aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+        ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+        uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+        aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicImportHelper" ), aArgs, xGraphicResolver );
+
+        if ( xGraphicResolver.is() )
+        {
+            rtl::OUString aTmp( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.Package:" ) );
+            aTmp += sURL;
+            sURL = xGraphicResolver->resolveGraphicObjectURL( aTmp );
+            Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+            // we must set the url while the graphic object ( held by the resolver is in scope )
+            if ( xProps.is() )
+                xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+        }
+    }
+    
+    else if ( sURL.getLength() > 0 )
+    {
+        Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+        if ( xProps.is() )
+            xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+    }
+
     ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                                OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
                                _xAttributes );
@@ -1338,10 +1644,24 @@ void TitledBoxElement::endElement()
         Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
         Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatModeOn( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
+
         
         ControlImportContext ctx(
             _pImport, getControlId( xAttributes ),
-            OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
         Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
         
         Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1377,6 +1697,9 @@ void TitledBoxElement::endElement()
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
         
         sal_Int16 nVal = 0;
         sal_Bool bChecked = sal_False;
@@ -1390,7 +1713,7 @@ void TitledBoxElement::endElement()
         }
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
                                          makeAny( nVal ) );
-        
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
         ctx.importEvents( *radioEvents );
@@ -1466,10 +1789,23 @@ void RadioGroupElement::endElement()
         Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
         Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatModeOn( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
         
         ControlImportContext ctx(
             _pImport, getControlId( xAttributes ),
-            OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
         Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
         
         Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1505,6 +1841,9 @@ void RadioGroupElement::endElement()
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
         sal_Int16 nVal = 0;
         sal_Bool bChecked = sal_False;
         if (getBoolAttr( &bChecked,
@@ -1518,6 +1857,7 @@ void RadioGroupElement::endElement()
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
                                          makeAny( nVal ) );
         
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
         ctx.importEvents( *radioEvents );
@@ -1638,9 +1978,26 @@ Reference< xml::input::XElement > MenuLi
 void MenuListElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sLinkedCell;
+        OUString sCellRange;
+        OUString sListBoxService( OUSTR("com.sun.star.awt.UnoControlListBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatModeOn( _pImport ) )
+            sListBoxService = OUSTR("com.sun.star.form.component.ListBox");
+
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		//OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		sListBoxService );
     Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
     
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1673,13 +2030,16 @@ void MenuListElement::endElement()
     ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
-    
+        // import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
     if (_popup.is())
     {
         MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
-        xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
+        if (  !sCellRange.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
                                          makeAny( p->getItemValues() ) );
-        xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
+        if (  !sLinkedCell.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
                                          makeAny( p->getSelectedItems() ) );
     }
     ctx.importEvents( _events );
@@ -1725,9 +2085,26 @@ Reference< xml::input::XElement > ComboB
 void ComboBoxElement::endElement()
     throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sService( OUSTR("com.sun.star.awt.UnoControlComboBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatModeOn( _pImport ) )
+            sService = OUSTR("com.sun.star.form.component.ComboBox");
+
+        OUString sLinkedCell;
+        OUString sCellRange;
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
+
     ControlImportContext ctx(
         _pImport, getControlId( _xAttributes ),
-        OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlComboBoxModel") ) );
+		sService );
     Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
     
     Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1769,8 +2146,10 @@ void ComboBoxElement::endElement()
     ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
+	// import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
     
-    if (_popup.is())
+	if (_popup.is() && !sCellRange.getLength() )
     {
         MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
         xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
@@ -2096,10 +2475,19 @@ Reference< xml::input::XElement > Bullet
     {
         return new ScrollBarElement( rLocalName, xAttributes, this, _pImport );
     }
+	// spinbutton
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("spinbutton") ) && isVBACompatModeOn( _pImport ) )
+	{
+		return new SpinButtonElement( rLocalName, xAttributes, this, _pImport );
+	}
     // progressmeter
     else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("progressmeter") ))
     {
         return new ProgressBarElement( rLocalName, xAttributes, this, _pImport );
+	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("multipage") ))
+	{
+		return new MultiPage( rLocalName, xAttributes, this, _pImport );
     }
     // bulletinboard
     else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("bulletinboard") ))
--- xmlscript/source/xmldlg_imexp/xmldlg_import.cxx.old	2009-10-08 16:17:57.000000000 +0200
+++ xmlscript/source/xmldlg_imexp/xmldlg_import.cxx	2010-03-03 16:59:35.000000000 +0100
@@ -60,9 +60,13 @@
 #include <com/sun/star/script/ScriptEventDescriptor.hpp>
 
 #include <com/sun/star/view/SelectionType.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/script/DocumentScriptLibraryContainer.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 using ::rtl::OUString;
 
 namespace xmlscript
@@ -1891,18 +1895,44 @@ Reference< xml::input::XElement > Dialog
     }
     return 0;
 }
+//__________________________________________________________________________________________________
+Reference< script::XLibraryContainer > DialogImport::getScriptLibraryContainer()
+{
+	if( !_xScriptLibraryContainer.is() )
+	{
+		try
+		{
+			Reference< document::XStorageBasedDocument > xStorageDoc( _xDoc, UNO_QUERY );
+			if( xStorageDoc.is() )
+				_xScriptLibraryContainer.set(
+									script::DocumentScriptLibraryContainer::create( comphelper_getProcessComponentContext(), xStorageDoc ), 
+									UNO_QUERY );
+		}
+		catch( const Exception& )
+		{
+		}
+	}
+
+	return _xScriptLibraryContainer;
+}
 
 //##################################################################################################
 
 //==================================================================================================
 Reference< xml::sax::XDocumentHandler > SAL_CALL importDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
+    DialogImport* pImport = new DialogImport( xContext, xDialogModel, xDocument );
+    uno::Reference< script::XVBACompat > xVBAModeSource( pImport->getScriptLibraryContainer(), uno::UNO_QUERY );
+    
+    uno::Reference< beans::XPropertySet > xDlgProps( xDialogModel, uno::UNO_QUERY );
+    if ( xVBAModeSource.is() && xDlgProps.is() && xVBAModeSource->getVBACompatModeOn() )
+        xDlgProps->setPropertyValue( OUSTR("VBAForm"), uno::makeAny( sal_True ) );
     return ::xmlscript::createDocumentHandler(
-        static_cast< xml::input::XRoot * >(
-            new DialogImport( xContext, xDialogModel ) ) );
+        static_cast< xml::input::XRoot * >( pImport ) );
 }
 
 }
--- xmlscript/util/makefile.mk.old	2009-10-08 16:17:57.000000000 +0200
+++ xmlscript/util/makefile.mk	2010-03-03 16:59:35.000000000 +0100
@@ -58,6 +58,7 @@ SHL1LIBS= \
         $(LIB1TARGET)
 
 SHL1STDLIBS= \
+		$(COMPHELPERLIB)                \
         $(CPPUHELPERLIB)		\
         $(CPPULIB) 			\
         $(SALLIB)
