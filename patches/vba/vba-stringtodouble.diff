diff -ruNp basic/source/sbx/sbxdbl.cxx basic/source/sbx/sbxdbl.cxx
--- basic/source/sbx/sbxdbl.cxx	2007-11-13 23:22:39.000000000 +0800
+++ basic/source/sbx/sbxdbl.cxx	2008-02-27 15:30:35.000000000 +0800
@@ -41,6 +41,7 @@
 #endif
 #include <basic/sbx.hxx>
 #include "sbxconv.hxx"
+#include "runtime.hxx"
 
 double ImpGetDouble( const SbxValues* p )
 {
@@ -87,13 +88,21 @@ double ImpGetDouble( const SbxValues* p 
 		case SbxSTRING:
 		case SbxLPSTR:
 			if( !p->pString )
+			{	
 				nRes = 0;
+				if ( SbiRuntime::isVBAEnabled() )// VBA only behaviour
+					SbxBase::SetError( SbxERR_CONVERSION );
+			}		
 			else
 			{
 				double d;
 				SbxDataType t;
 				if( ImpScan( *p->pString, d, t, NULL ) != SbxERR_OK )
+				{
 					nRes = 0;
+					if ( SbiRuntime::isVBAEnabled() )// VBA only behaviour
+						SbxBase::SetError( SbxERR_CONVERSION );
+				}
 				else
 					nRes = d;
 			}
diff -ruNp basic/source/sbx/sbxscan.cxx basic/source/sbx/sbxscan.cxx
--- basic/source/sbx/sbxscan.cxx	2008-01-18 20:59:08.000000000 +0800
+++ basic/source/sbx/sbxscan.cxx	2008-02-26 11:40:57.000000000 +0800
@@ -61,6 +61,7 @@
 #include <svtools/svtools.hrc>
 
 #include "basrid.hxx"
+#include "runtime.hxx"
 
 #include <svtools/zforlist.hxx>
 #include <comphelper/processfactory.hxx>
@@ -239,6 +240,11 @@ SbxError ImpScan( const XubString& rWSrc
 		if( l >= SbxMININT && l <= SbxMAXINT )
 			eScanType = SbxINTEGER;
 	}
+	else if ( SbiRuntime::isVBAEnabled() )
+	{
+		OSL_TRACE("Reporting error converting");
+		return SbxERR_CONVERSION;
+	}
 	if( pLen )
 		*pLen = (USHORT) ( p - pStart );
 	if( !bRes )
diff -ruNp basic/source/sbx/sbxvalue.cxx basic/source/sbx/sbxvalue.cxx
--- basic/source/sbx/sbxvalue.cxx	2008-02-20 10:15:01.000000000 +0800
+++ source/sbx/sbxvalue.cxx	2008-02-27 16:01:24.000000000 +0800
@@ -1175,7 +1175,17 @@ BOOL SbxValue::Compute( SbxOperator eOp,
 		bool bDecimal = false;
 		if( eThisType == SbxSTRING || eOp == SbxCAT || ( bVBAInterop && ( eOpType == SbxSTRING ) && (  eOp == SbxPLUS ) ) )
 		{
-			if( eOp == SbxCAT || eOp == SbxPLUS )
+			if( bVBAInterop && eOp == SbxPLUS && ( eThisType != SbxSTRING || eOpType != SbxSTRING ) )
+			{
+				// if string + (not string), I supposed that the result is treated as double? 
+				aL.eType = aR.eType = SbxDOUBLE;
+				rOp.Get( aR ); 
+				if( rOp.GetType() == SbxEMPTY )
+					goto Lbl_OpIsEmpty;
+				Get( aL );
+				aL.nDouble += aR.nDouble;
+			}
+			else if( eOp == SbxCAT || eOp == SbxPLUS )
 			{
 				// AB 5.11.1999, OUString beruecksichtigen
 				aL.eType = aR.eType = SbxSTRING;
