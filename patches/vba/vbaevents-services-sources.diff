--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/makefile.mk	2008-04-28 16:07:24.000000000 +0100
@@ -0,0 +1,58 @@
+PRJ=..$/..
+
+PRJNAME=vbaevents
+TARGET=vbaevents
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vbaevents..."
+.ENDIF
+
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+        $(SLOTARGET)
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/eventhelper.obj
+
+SHL1TARGET= $(TARGET)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+
+SHL1VERSIONMAP=$(TARGET).map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                              
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(COMPHELPERLIB) \
+		$(SFXLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+                                                                              
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/eventhelper.cxx	2008-05-09 12:06:59.000000000 +0100
@@ -0,0 +1,919 @@
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/provider/XScriptProviderSupplier.hpp>
+
+#include <com/sun/star/drawing/XControlShape.hpp>
+
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/awt/KeyEvent.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+
+#include <msforms/ReturnInteger.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbx.hxx>
+
+
+
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <comphelper/evtmethodhelper.hxx>
+
+#include <set>
+#include <list>
+#include <hash_map>
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::script;
+using namespace ::com::sun::star::uno;
+using namespace ::org::openoffice::vba;
+
+
+// Some constants 
+const static rtl::OUString DELIM = rtl::OUString::createFromAscii( "::" );
+const static sal_Int32 DELIMLEN = DELIM.getLength();
+
+#if 0
+void dumpListeners( const Reference< beans::XIntrospection >& xIntrospection, const Reference<XInterface>& xIfc)
+{
+    Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+    if ( xIntrospection.is() )
+    {
+        xIntrospectionAccess = xIntrospection->inspect( 
+            makeAny( xIfc ) );
+        Sequence< Type > aControlListeners = 
+            xIntrospectionAccess->getSupportedListeners();
+        sal_Int32 nLength = aControlListeners.getLength();
+             
+        for ( sal_Int32 i = 0; i< nLength; ++i )
+        {
+            Type& listType = aControlListeners[ i ];
+            rtl::OUString sFullTypeName = listType.getTypeName();
+            rtl::OUString sTypeName = listType.getTypeName();
+            sal_Int32 lastDotIndex = -1;
+            if ( ( lastDotIndex = sFullTypeName.lastIndexOf( '.' ) ) > -1 )
+            {
+                sTypeName = sFullTypeName.copy( lastDotIndex + 1 );    
+            } 
+            Sequence< ::rtl::OUString > sMeths = comphelper::getEventMethodsForType( listType );    
+            sal_Int32 sMethLen = sMeths.getLength();
+            for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+            {
+                OSL_TRACE("**Listener [%d] Type[%s] Method[%s]",j,
+                    rtl::OUStringToOString( sTypeName, 
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString( sMeths[ j ], 
+                        RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+        }
+       
+    }
+}
+
+void dumpEvent( const ScriptEvent& evt )
+{
+    OSL_TRACE("dumpEvent: Source %s",
+        rtl::OUStringToOString( comphelper::anyToString( makeAny(evt.Source)), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ScriptType %s",
+        rtl::OUStringToOString( evt.ScriptType, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: ScriptCode %s",
+        rtl::OUStringToOString( evt.ScriptCode, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ListenerType %s",
+        rtl::OUStringToOString( evt.ListenerType.getTypeName(), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: Listener methodname %s",
+        rtl::OUStringToOString( evt.MethodName, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: arguments;");
+    sal_Int32 nLen = evt.Arguments.getLength();
+    for ( sal_Int32 index=0; index < nLen; ++index )
+    {
+        OSL_TRACE("\t [%d] %s", index, 
+        rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[ index ] ), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    }
+}
+
+#endif
+
+bool isKeyEventOk( awt::KeyEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !( isMouseEventOk(evt, params)) || 
+        (evt.ClickCount != 2) )
+        return Sequence< Any >(); 
+    // give back orig params, this will signal that the event is good
+    return params;
+}
+
+Sequence< Any > ooMouseEvtToVBAMouseEvt( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !isMouseEventOk(evt, params) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(4);
+
+    // Buttons
+    translatedParams[ 0 ] <<= evt.Buttons;
+    // Shift
+    translatedParams[ 1 ] <<= evt.Modifiers;
+    // X
+    translatedParams[ 2 ] <<= evt.X;
+    // Y
+    translatedParams[ 3 ] <<= evt.Y;
+    return translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    msforms::ReturnInteger keyCode;
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    return  translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(2);
+
+    msforms::ReturnInteger keyCode;
+    sal_Int8 shift = evt.Modifiers;
+
+    // #TODO check whether values from OOO conform to values generated from vba
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    translatedParams[1] <<= shift;
+    return  translatedParams;
+}
+
+typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
+
+struct TranslateInfo
+{
+    rtl::OUString sVBAName;
+    Translator toVBA;
+};
+
+
+typedef std::hash_map< rtl::OUString, 
+std::list< TranslateInfo >, 
+::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventInfoHash;
+
+
+EventInfoHash& getEventTransInfo()
+{
+    static bool initialised = false;
+    static EventInfoHash eventTransInfo;
+    if ( !initialised )
+    {
+        TranslateInfo  info;
+        // actionPerformed ooo event
+        std::list< TranslateInfo > actionInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Click");
+        info.toVBA = NULL;
+        actionInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        actionInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("actionPerformed") ] = actionInfos;
+        // changed ooo event
+        std::list< TranslateInfo > changeInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        changeInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("changed") ] = changeInfos;
+        // focusGained ooo event
+        std::list< TranslateInfo > focusGainedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_GotFocus");
+        info.toVBA = NULL;
+        focusGainedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusGainedInfos;
+        // focusLost ooo event
+        std::list< TranslateInfo > focusLostInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_LostFocus");
+        info.toVBA = NULL;
+        focusLostInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusLostInfos;
+        // adjustmentValueChanged ooo event
+        std::list< TranslateInfo > adjustInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Scroll");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("adjustmentValueChanged") ] = adjustInfos;
+        // textChanged ooo event
+        std::list< TranslateInfo > txtChangedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        txtChangedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("textChanged") ] = txtChangedInfos;
+
+        // keyReleased ooo event
+        std::list< TranslateInfo > keyReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyUp");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyReleased") ] = keyReleasedInfos;
+        // mouseReleased ooo event
+        std::list< TranslateInfo > mouseReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseUp");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseReleased") ] = mouseReleasedInfos;
+        // mousePressed ooo event
+        std::list< TranslateInfo > mousePressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseDown");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mousePressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_DblClick");
+        // emulate double click event
+        info.toVBA = ooMouseEvtToVBADblClick;
+        mousePressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mousePressed") ] = mousePressedInfos;
+        // mouseMoved ooo event
+        std::list< TranslateInfo > mouseMovedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseMove");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseMovedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseMoved") ] = mouseMovedInfos;
+        // keyPressed ooo event
+        std::list< TranslateInfo > keyPressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyDown");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyPressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyPress");
+        info.toVBA = ooKeyPressedToVBAKeyPressed;
+        keyPressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyPressed") ] = keyPressedInfos;
+        initialised = true;
+    }
+    return eventTransInfo;
+}
+
+// Helper class
+
+class ScriptEventHelper
+{
+public:
+    ScriptEventHelper( const Reference< XInterface >& xControl );
+    Sequence< ScriptEventDescriptor > createEvents( const rtl::OUString& sCodeName );   
+    Sequence< rtl::OUString > getEventListeners();
+private:
+    Reference< XComponentContext > m_xCtx;
+    Reference< XInterface > m_xControl;
+};
+
+bool
+eventMethodToDescriptor( const ::rtl::OUString& rEventMethod, ScriptEventDescriptor& evtDesc, const ::rtl::OUString& sCodeName )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        // just fill in CodeName, when the event fires the other 
+	// info is gathered from the event source to determine what
+	// event handler we try to call
+        evtDesc.ScriptCode = sCodeName;
+        evtDesc.ListenerType = sTypeName;
+        evtDesc.EventMethod = sMethodName;
+
+        // set this it VBAInterop, ensures that it doesn't
+        // get persisted or shown in property editors
+        evtDesc.ScriptType = rtl::OUString::createFromAscii(
+            "VBAInterop" );	
+        return true;
+    }
+    return false;
+
+}
+
+ScriptEventHelper::ScriptEventHelper( const Reference< XInterface >& xControl ) : m_xControl( xControl )
+{
+    Reference < beans::XPropertySet > xProps(
+        ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+    m_xCtx.set( xProps->getPropertyValue( rtl::OUString(
+        RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+        uno::UNO_QUERY_THROW );
+}
+
+Sequence< rtl::OUString > 
+ScriptEventHelper::getEventListeners()
+{
+    Reference< lang::XMultiComponentFactory > xMFac( 
+        m_xCtx->getServiceManager(), UNO_QUERY );
+    std::list< rtl::OUString > eventMethods;
+
+    if ( xMFac.is() )
+    {
+        Reference< beans::XIntrospection > xIntrospection( 
+            xMFac->createInstanceWithContext( rtl::OUString( 
+                RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.beans.Introspection"  ) ), m_xCtx ), UNO_QUERY );
+#if 0
+        dumpListeners( xIntrospection, m_xControl );
+        dumpListeners( xIntrospection, m_xControl->getModel() );
+#endif 
+        Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+	if  ( xIntrospection.is() )
+	{
+            xIntrospectionAccess = xIntrospection->inspect( 
+                makeAny( m_xControl ) );
+            Sequence< Type > aControlListeners = 
+                xIntrospectionAccess->getSupportedListeners();
+            sal_Int32 nLength = aControlListeners.getLength();             
+            for ( sal_Int32 i = 0; i< nLength; ++i )
+            {
+                Type& listType = aControlListeners[ i ];
+                rtl::OUString sFullTypeName = listType.getTypeName();
+                Sequence< ::rtl::OUString > sMeths = 
+                    comphelper::getEventMethodsForType( listType );    
+                sal_Int32 sMethLen = sMeths.getLength();
+                for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+                {
+                    rtl::OUString sEventMethod = sFullTypeName;
+                    sEventMethod += DELIM;
+                    sEventMethod += sMeths[ j ];
+                    eventMethods.push_back( sEventMethod );
+                }
+            }
+            
+        }
+    }
+
+    Sequence< rtl::OUString > sEventMethodNames( eventMethods.size() );
+    std::list< rtl::OUString >::const_iterator it = eventMethods.begin();
+    rtl::OUString* pDest = sEventMethodNames.getArray();
+
+    for ( ; it != eventMethods.end(); ++it, ++pDest )
+        *pDest = *it;         
+
+    return sEventMethodNames;
+}
+
+Sequence< ScriptEventDescriptor > 
+ScriptEventHelper::createEvents( const rtl::OUString& sCodeName )
+{
+    Sequence< rtl::OUString > aControlListeners = getEventListeners();
+    rtl::OUString* pSrc = aControlListeners.getArray();
+    sal_Int32 nLength = aControlListeners.getLength();             
+
+    Sequence< ScriptEventDescriptor > aDest( nLength );
+    sal_Int32 nEvts = 0; 
+    for ( sal_Int32 i = 0; i< nLength; ++i, ++pSrc )
+    {
+        // from getListeners eventName is of form
+        // "com.sun.star.awt.XActionListener::actionPerformed"
+        // we need to strip "com.sun.star.awt." from that for form
+        // controls
+    	ScriptEventDescriptor evtDesc;
+        if ( eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            sal_Int32 dIndex = nEvts;
+            ++nEvts;
+            if ( nEvts > aDest.getLength() )
+                aDest.realloc( nEvts );// should never happen
+            aDest[ dIndex ] = evtDesc;
+        }
+    }
+    aDest.realloc( nEvts );
+
+    return aDest;
+}
+
+
+typedef ::cppu::WeakImplHelper1< container::XNameContainer > NameContainer_BASE;
+
+class ReadOnlyEventsNameContainer : public NameContainer_BASE
+{
+public:
+    ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName );
+    // XNameContainer
+
+    virtual void SAL_CALL insertByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::ElementExistException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& ) throw (::com::sun::star::container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+    }
+
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+                                                                                
+    // XNameAccess
+    virtual Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException);
+    virtual Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (RuntimeException);
+
+    // XElementAccess
+    virtual Type SAL_CALL getElementType(  ) throw (RuntimeException)
+    { return getCppuType(static_cast< const rtl::OUString * >(0) ); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (RuntimeException)
+    { return ( ( m_hEvents.size() > 0 ? sal_True : sal_False ) ); }
+private:
+
+typedef std::hash_map< rtl::OUString, Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventSupplierHash;
+
+    EventSupplierHash m_hEvents;
+};
+
+ReadOnlyEventsNameContainer::ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+{
+    const rtl::OUString* pSrc = eventMethods.getConstArray();
+    sal_Int32 nLen = eventMethods.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index, ++pSrc )
+    {
+        Any aDesc;
+        ScriptEventDescriptor evtDesc;
+        if (  eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            aDesc <<= evtDesc; 
+            m_hEvents[ *pSrc ] = aDesc;
+        }
+    }
+}
+
+Any SAL_CALL 
+ReadOnlyEventsNameContainer::getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException){
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        throw container::NoSuchElementException();
+    return it->second;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL 
+ReadOnlyEventsNameContainer::getElementNames(  ) throw (RuntimeException)
+{
+    Sequence< ::rtl::OUString > names(m_hEvents.size());
+    rtl::OUString* pDest = names.getArray();
+    EventSupplierHash::const_iterator it = m_hEvents.begin();
+    EventSupplierHash::const_iterator it_end = m_hEvents.end();
+    for ( sal_Int32 index = 0; it != it_end; ++index, ++pDest, ++it )
+        *pDest = it->first;
+    return names;
+}
+
+sal_Bool SAL_CALL 
+ReadOnlyEventsNameContainer::hasByName( const ::rtl::OUString& aName ) throw (RuntimeException)
+{
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        return sal_False;
+    return sal_True;
+}
+
+typedef ::cppu::WeakImplHelper1< XScriptEventsSupplier > EventsSupplier_BASE;
+
+class ReadOnlyEventsSupplier : public EventsSupplier_BASE
+{
+public:
+    ReadOnlyEventsSupplier( const Sequence< ::rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+    { m_xNameContainer = new ReadOnlyEventsNameContainer( eventMethods, sCodeName ); }
+    
+    // XScriptEventSupplier
+    virtual Reference< container::XNameContainer > SAL_CALL getEvents(  ) throw (RuntimeException){ return m_xNameContainer; }
+private:
+    Reference< container::XNameContainer > m_xNameContainer;
+};
+
+typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+
+#define EVENTLSTNR_PROPERTY_ID_MODEL         1
+#define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
+
+class EventListener : public EventListener_BASE
+    ,public ::comphelper::OMutexAndBroadcastHelper
+    ,public ::comphelper::OPropertyContainer
+    ,public ::comphelper::OPropertyArrayUsageHelper< EventListener >
+
+{
+    
+public:
+    EventListener( const Reference< XComponentContext >& rxContext );
+    // XEventListener
+    virtual void SAL_CALL disposing(const lang::EventObject& Source) throw( RuntimeException );
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
+    // XInitialization
+    virtual void SAL_CALL initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException);
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+    virtual void SAL_CALL setFastPropertyValue( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::beans::PropertyVetoException, ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OPropertyContainer::setFastPropertyValue( nHandle, rValue );
+	if ( nHandle == EVENTLSTNR_PROPERTY_ID_MODEL )
+            setShellFromModel();
+    }
+
+protected:
+    // OPropertySetHelper
+    virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+    // OPropertyArrayUsageHelper
+    virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
+private:
+    void setShellFromModel();
+    void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
+
+    Reference< XComponentContext > m_xContext;
+    Reference< frame::XModel > m_xModel;
+    SfxObjectShell* mpShell;
+    
+};
+
+EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), mpShell( 0 )
+{
+    registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
+        beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
+
+}
+
+void
+EventListener::setShellFromModel()
+{
+	// reset mpShell
+	mpShell = 0;
+	SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+	while ( m_xModel.is() && pShell )
+	{
+		if ( pShell->GetModel() == m_xModel )
+		{
+			mpShell = pShell;
+			break;
+		}
+		pShell = SfxObjectShell::GetNext( *pShell );
+	}    
+}
+
+//XEventListener
+void
+EventListener::disposing(const lang::EventObject&)  throw( RuntimeException )
+{
+}
+
+//XScriptListener
+
+void SAL_CALL 
+EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
+{
+    firing_Impl( evt );
+}
+
+Any SAL_CALL 
+EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
+{
+    Any ret;
+    firing_Impl( evt, &ret );
+    return ret;
+}
+
+// XInitialization
+void SAL_CALL 
+EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
+{
+    if ( aArguments.getLength() == 1 )
+        aArguments[0] >>= m_xModel;
+    OSL_TRACE("EventListener::initialize() args %d m_xModel %d", aArguments.getLength(), m_xModel.is() );
+}
+
+// XInterface
+
+IMPLEMENT_FORWARD_XINTERFACE2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// XTypeProvider
+
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// OPropertySetHelper
+
+::cppu::IPropertyArrayHelper& 
+EventListener::getInfoHelper(  )
+{
+    return *getArrayHelper();
+}
+
+// OPropertyArrayUsageHelper
+
+::cppu::IPropertyArrayHelper* 
+EventListener::createArrayHelper(  ) const
+{
+    Sequence< beans::Property > aProps;
+    describeProperties( aProps );
+    return new ::cppu::OPropertyArrayHelper( aProps );
+}
+
+// XPropertySet
+Reference< beans::XPropertySetInfo > 
+EventListener::getPropertySetInfo(  ) throw (RuntimeException)
+{
+    Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+    return xInfo;
+}
+
+
+// EventListener
+
+void
+EventListener::firing_Impl(const ScriptEvent& evt, Any* /*pRet*/ ) throw(RuntimeException)
+{
+	OSL_TRACE("EventListener::firing_Impl( FAKE VBA_EVENTS )");
+    static const ::rtl::OUString vbaInterOp =
+        ::rtl::OUString::createFromAscii("VBAInterop");
+
+    // let default handlers deal with non vba stuff
+    if ( !evt.ScriptType.equals( vbaInterOp ) )
+        return;
+    lang::EventObject aEvent;
+    evt.Arguments[ 0 ] >>= aEvent;
+	OSL_TRACE("Argument[0] is  %s", rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[0] ), RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Getting Control");
+    uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY_THROW );
+	OSL_TRACE("Getting properties");
+    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
+
+    rtl::OUString sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm") );
+	OSL_TRACE("Getting Name");
+
+    uno::Reference< awt::XDialog > xDlg( aEvent.Source, uno::UNO_QUERY );
+    if ( !xDlg.is() )
+        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+    //dumpEvent( evt );
+    EventInfoHash& infos = getEventTransInfo();
+    EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+    if ( eventInfo_it == it_end )
+    {
+        OSL_TRACE("Bogus event for %s",
+            rtl::OUStringToOString( evt.ScriptType, RTL_TEXTENCODING_UTF8 ).getStr() );
+        return;
+    }
+
+    uno::Reference< script::provider::XScriptProviderSupplier > xSPS( m_xModel, uno::UNO_QUERY );
+    uno::Reference< script::provider::XScriptProvider > xScriptProvider;
+    if ( xSPS.is() )
+        xScriptProvider =  xSPS->getScriptProvider();
+    if ( xScriptProvider.is() && mpShell )
+    {
+        std::list< TranslateInfo > matchingMethods;
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
+        rtl::OUString sMacroLoc = rtl::OUString::createFromAscii("Standard.").concat( evt.ScriptCode ).concat( rtl::OUString::createFromAscii(".") );
+       
+        StarBASIC* pBasic = mpShell->GetBasic();
+        SbModule* pModule = pBasic->FindModule( evt.ScriptCode );
+        for ( ; pModule && txInfo != txInfo_end; ++txInfo )
+        {
+            // see if we have a match for the handlerextension
+            // where ScriptCode is methodname_handlerextension 
+            rtl::OUString sTemp = sName.concat( (*txInfo).sVBAName ); 
+            
+            OSL_TRACE("*** trying to invoke %s ",
+                rtl::OUStringToOString( sTemp, RTL_TEXTENCODING_UTF8 ).getStr() );
+            SbMethod* pMeth = static_cast< SbMethod* >( pModule->Find( sTemp, SbxCLASS_METHOD ) );
+            if ( pMeth )
+            {
+                // !! translate arguments & emulate events where necessary 
+                Sequence< Any > aArguments;
+                if  ( (*txInfo).toVBA )
+                    aArguments = (*txInfo).toVBA( evt.Arguments );
+                else
+                    aArguments = evt.Arguments;
+                if ( aArguments.getLength() )
+                {
+                    // call basic event handlers for event
+
+                    static rtl::OUString part1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+                    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document"); 
+
+                    // create script url
+                    rtl::OUString url = part1 + sMacroLoc + sTemp + part2;
+                 
+                    OSL_TRACE("script url = %s",
+                        rtl::OUStringToOString( url, 
+                            RTL_TEXTENCODING_UTF8 ).getStr() );
+                    Sequence< sal_Int16 > aOutArgsIndex;
+                    Sequence< Any > aOutArgs;
+                    try
+                    {
+                        uno::Reference< script::provider::XScript > xScript = xScriptProvider->getScript( url );
+                        if ( xScript.is() )
+                           xScript->invoke( aArguments, aOutArgsIndex, aOutArgs  );
+                    }
+                    catch ( uno::Exception& e )
+                    {
+                        OSL_TRACE("event script raised %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    }
+               } 
+           }
+       }
+    }
+}
+
+typedef ::cppu::WeakImplHelper1< XVBAToOOEventDescGen > VBAToOOEventDescGen_BASE;
+
+
+class VBAToOOEventDescGen : public VBAToOOEventDescGen_BASE
+{
+public:
+    VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext );
+
+    // XVBAToOOEventDescGen
+    virtual Sequence< ScriptEventDescriptor > SAL_CALL getEventDescriptions( const Reference< XInterface >& control, const rtl::OUString& sCodeName ) throw (RuntimeException);
+    virtual Reference< XScriptEventsSupplier > SAL_CALL getEventSupplier( const Reference< XInterface >& xControl,  const rtl::OUString& sCodeName ) throw (::com::sun::star::uno::RuntimeException);
+private:
+    Reference< XComponentContext > m_xContext;
+  
+};
+
+VBAToOOEventDescGen::VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext ):m_xContext( rxContext ) {}
+
+Sequence< ScriptEventDescriptor > SAL_CALL 
+VBAToOOEventDescGen::getEventDescriptions( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName ) throw (RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    return evntHelper.createEvents( sCodeName ); 
+}
+
+Reference< XScriptEventsSupplier > SAL_CALL 
+VBAToOOEventDescGen::getEventSupplier( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName  ) throw (::com::sun::star::uno::RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    Reference< XScriptEventsSupplier > xSupplier = 
+        new ReadOnlyEventsSupplier( 
+            evntHelper.getEventListeners(), sCodeName ) ;
+    return xSupplier;
+}
+
+// Component related 
+
+namespace evtlstner
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.EventListener" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+    Reference< XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new EventListener( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::evtlstner::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
+namespace ooevtdescgen 
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAToOOEventDesc" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new VBAToOOEventDescGen( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+    	const ::rtl::OUString strName( ::ooevtdescgen::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/service.cxx	2008-04-28 16:07:24.000000000 +0100
@@ -0,0 +1,99 @@
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace evtlstner
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end evtlstner
+
+namespace ooevtdescgen
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end ooevtdescgen
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::evtlstner::create, ::evtlstner::getImplementationName,
+            ::evtlstner::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        {
+            ::ooevtdescgen::create, ::ooevtdescgen::getImplementationName,
+            ::ooevtdescgen::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.map	2008-04-28 16:07:24.000000000 +0100
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.xml	2008-04-28 16:07:24.000000000 +0100
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>vbaevents</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>org.openoffice.vba.EventListener</name>
+        <description>Event listener to handle ooo events and to translate them to calls to basic macros ala Button_Click etc.</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>org.openoffice.vba.EventListener</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
diff -rup scripting/source/dlgprov/dlgevtatt.cxx scripting/source/dlgprov/dlgevtatt.cxx
--- scripting/source/dlgprov/dlgevtatt.cxx	2008-04-29 13:37:12.000000000 +0100
+++ scripting/source/dlgprov/dlgevtatt.cxx	2008-04-28 22:20:38.000000000 +0100
@@ -121,18 +121,20 @@ namespace dlgprov
     DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel ) : DialogScriptListenerImpl( rxContext )
     {
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
+        Sequence< Any > args(1);
         if ( xSMgr.is() )
         {
-            Sequence< Any > args(1);
             args[0] <<= xModel;
             mxListener = Reference< XScriptListener >( xSMgr->createInstanceWithArgumentsAndContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.EventListener" ) ), args, m_xContext ), UNO_QUERY );
         }
         if ( rxControl.is() )
         {
-            Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY );
             try
             {
+                Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY_THROW );
                 xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= msDialogCodeName;
+                xProps.set( mxListener, UNO_QUERY_THROW );
+                xProps->setPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Model") ), args[ 0 ] );
             } 
             catch ( Exception&  ) {}
         }
@@ -232,7 +232,7 @@ namespace dlgprov
         return it->second; 
     }
 #ifdef FAKE_VBA_EVENT_SUPPORT
-    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl )
+    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl, rtl::OUString& sControlName )
             {
         Reference< XScriptEventsSupplier > xEventsSupplier;
                 Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
@@ -240,7 +240,7 @@ namespace dlgprov
                 {
             Reference< org::openoffice::vba::XVBAToOOEventDescGen > xVBAToOOEvtDesc( xSMgr->createInstanceWithContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAToOOEventDesc" ) ), m_xContext ), UNO_QUERY );
             if ( xVBAToOOEvtDesc.is() )
-                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl ), UNO_QUERY );
+                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl, sControlName ), UNO_QUERY );
 
             }
         return xEventsSupplier;
@@ -363,6 +363,20 @@ namespace dlgprov
         // go over all objects
         const Reference< XInterface >* pObjects = Objects.getConstArray();
         sal_Int32 nObjCount = Objects.getLength();
+#ifdef FAKE_VBA_EVENT_SUPPORT
+        Reference< awt::XControl > xDlgControl( Objects[ nObjCount - 1 ], uno::UNO_QUERY ); // last object is the dialog	
+        rtl::OUString sDialogCodeName;
+        if ( xDlgControl.is() )
+        {
+            Reference< XPropertySet > xProps( xDlgControl->getModel(), UNO_QUERY );
+            try
+            {
+                xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sDialogCodeName;  
+            }
+            catch( Exception& ){}
+        }
+#endif
+	
         for ( sal_Int32 i = 0; i < nObjCount; ++i )
         {
             // We know that we have to do with instances of XControl.
@@ -377,7 +391,7 @@ namespace dlgprov
             Reference< XScriptEventsSupplier > xEventsSupplier( xControlModel, UNO_QUERY );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl ) );
+            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl, sDialogCodeName ) );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #endif
         }
diff -rup scripting/source/dlgprov/dlgevtatt.hxx scripting/source/dlgprov/dlgevtatt.hxx
--- scripting/source/dlgprov/dlgevtatt.hxx	2008-04-29 13:37:12.000000000 +0100
+++ scripting/source/dlgprov/dlgevtatt.hxx	2008-04-28 22:17:30.000000000 +0100
@@ -68,6 +68,9 @@
 #include <com/sun/star/script/XScriptEventsSupplier.hpp>
 
 #include <hash_map>
+
+#define FAKE_VBA_EVENT_SUPPORT 1 
+
 //.........................................................................
 namespace dlgprov
 {
@@ -93,7 +96,7 @@ namespace dlgprov
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XEventAttacher > m_xEventAttacher;
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener > getScriptListenerForKey( const rtl::OUString& sScriptName ) throw ( ::com::sun::star::uno::RuntimeException );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl );
+        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, rtl::OUString& sCodeName );
 #endif
         void  SAL_CALL attachEventsToControl( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier >& events, const ::com::sun::star::uno::Any& Helper  );
     public:
diff -rup sc/inc/document.hxx sc/inc/document.hxx
--- sc/inc/document.hxx	2008-04-29 13:37:35.000000000 +0100
+++ sc/inc/document.hxx	2008-04-28 18:04:55.000000000 +0100
@@ -311,6 +311,7 @@ private:
 
 	com::sun::star::uno::Sequence<sal_Int8>	aProtectPass;
 	String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
 	ScRangePairListRef	xRowNameRanges;
 
@@ -463,6 +464,8 @@ public:
 
 	const String& 	GetName() const { return aDocName; }
 	void			SetName( const String& r ) { aDocName = r; }
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
 
 	void			GetDocStat( ScDocStat& rDocStat );
 
@@ -550,6 +553,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 
 	BOOL			HasTable( SCTAB nTab ) const;
 	SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
 	BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
 	inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
diff -rup sc/inc/docuno.hxx sc/inc/docuno.hxx
--- sc/inc/docuno.hxx	2008-03-05 17:29:55.000000000 +0000
+++ sc/inc/docuno.hxx	2008-04-28 17:52:17.000000000 +0100
@@ -144,6 +144,8 @@ class ScTableSheetObj;
 class SvxFmDrawPage;
 class SvxDrawPage;
 
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+
 class SC_DLLPUBLIC ScModelObj : public SfxBaseModel,
 					public com::sun::star::sheet::XSpreadsheetDocument,
 					public com::sun::star::document::XActionLockable,
@@ -157,6 +159,7 @@ class SC_DLLPUBLIC ScModelObj : public S
 					public com::sun::star::view::XRenderable,
 					public com::sun::star::document::XLinkTargetSupplier,
 					public com::sun::star::beans::XPropertySet,
+					public com::sun::star::document::XCodeNameQuery,
 					public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo
 {
@@ -369,6 +372,8 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
 	virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getImplementationId()
 								throw(::com::sun::star::uno::RuntimeException);
+ 	virtual rtl::OUString SAL_CALL getCodeNameForObject( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& aObj )
+								throw(::com::sun::star::uno::RuntimeException);
 };
 
 
diff -rup sc/inc/scextopt.hxx sc/inc/scextopt.hxx
--- sc/inc/scextopt.hxx	2008-04-29 13:37:35.000000000 +0100
+++ sc/inc/scextopt.hxx	2008-04-28 15:44:25.000000000 +0100
@@ -142,6 +142,8 @@ public:
     const String&       GetCodeName( size_t nIdx ) const;
     /** Appends a codename for a sheet. */
     void                AppendCodeName( const String& rCodeName );
+    void                SetCodeName( const String& rCodeName, size_t nIdx );
+    void                DeleteCodeName( size_t nIdx );
 
 private:
     ::std::auto_ptr< ScExtDocOptionsImpl > mxImpl;
diff -rup sc/inc/table.hxx sc/inc/table.hxx
--- sc/inc/table.hxx	2008-04-29 13:37:25.000000000 +0100
+++ sc/inc/table.hxx	2008-04-28 18:04:55.000000000 +0100
@@ -103,6 +103,7 @@ private:
 	ScColumn		aCol[MAXCOLCOUNT];
 
 	String			aName;
+	String			aCodeName;
 	String			aComment;
 	BOOL			bScenario;
 	BOOL			bLayoutRTL;
@@ -233,6 +234,9 @@ public:
 	void		GetName( String& rName ) const;
 	void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
 	const String&	GetPageStyle() const					{ return aPageStyle; }
diff -rup sc/source/core/data/document.cxx sc/source/core/data/document.cxx
--- sc/source/core/data/document.cxx	2008-04-29 13:37:25.000000000 +0100
+++ sc/source/core/data/document.cxx	2008-04-28 18:04:55.000000000 +0100
@@ -154,6 +156,32 @@ BOOL ScDocument::GetName( SCTAB nTab, St
 	return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
+
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
 
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
@@ -292,6 +320,7 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 		if (nPos == SC_TAB_APPEND || nPos == nTabCount)
 		{
 			pTab[nTabCount] = new ScTable(this, nTabCount, rName);
+            pTab[nTabCount]->SetCodeName( rName );
 			++nMaxTableNumber;
 			if ( bExternalDocument )
 				pTab[nTabCount]->SetVisible( FALSE );
@@ -322,10 +351,16 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 				for (i = 0; i <= MAXTAB; i++)
 					if (pTab[i])
 						pTab[i]->UpdateInsertTab(nPos);
+
 				for (i = nTabCount; i > nPos; i--)
+				{
 					pTab[i] = pTab[i - 1];
+				}
+
 				pTab[nPos] = new ScTable(this, nPos, rName);
+                pTab[nPos]->SetCodeName( rName );
 				++nMaxTableNumber;
+
 				for (i = 0; i <= MAXTAB; i++)
 					if (pTab[i])
 						pTab[i]->UpdateCompile();
@@ -411,7 +447,10 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 									pRefUndoDoc ? pRefUndoDoc->pTab[i] : 0);
 				delete pTab[nTab];
 				for (i=nTab + 1; i < nTabCount; i++)
+				{
 					pTab[i - 1] = pTab[i];
+				}
+
 				pTab[nTabCount - 1] = NULL;
 				--nMaxTableNumber;
 				for (i = 0; i <= MAXTAB; i++)
diff -rup sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
--- sc/source/core/data/table1.cxx	2008-04-29 13:37:36.000000000 +0100
+++ sc/source/core/data/table1.cxx	2008-04-28 18:04:55.000000000 +0100
@@ -129,6 +129,7 @@ extern BOOL bIsOlk, bOderSo;
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 					BOOL bColInfo, BOOL bRowInfo ) :
 	aName( rNewName ),
+	aCodeName( rNewName ),
 	bScenario( FALSE ),
 	bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
diff -rup sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
--- sc/source/filter/excel/excimp8.cxx	2008-04-29 13:37:21.000000000 +0100
+++ sc/source/filter/excel/excimp8.cxx	2008-04-28 18:04:55.000000000 +0100
@@ -152,7 +152,7 @@ using namespace com::sun::star;
 
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
 	delete pFormConv;
 
@@ -288,9 +288,15 @@ void ImportExcel8::Codename( BOOL bWorkb
         if( aName.Len() )
         {
             if( bWorkbookGlobals )
+            {
                 GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
+            {
                 GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( mnTab++, aName );
+            }
         }
 	}
 }
diff -rup sc/source/filter/inc/excimp8.hxx sc/source/filter/inc/excimp8.hxx
--- sc/source/filter/inc/excimp8.hxx	2008-04-29 13:37:21.000000000 +0100
+++ sc/source/filter/inc/excimp8.hxx	2008-04-28 18:04:55.000000000 +0100
@@ -69,6 +69,7 @@ class XclImpStream;
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
 	protected:
         ExcScenarioList         aScenList;
 
diff -rup sc/source/ui/unoobj/docuno.cxx sc/source/ui/unoobj/docuno.cxx
--- sc/source/ui/unoobj/docuno.cxx	2008-03-05 17:33:11.000000000 +0000
+++ sc/source/ui/unoobj/docuno.cxx	2008-04-29 00:10:59.000000000 +0100
@@ -108,6 +108,7 @@ using namespace com::sun::star;
 //	alles ohne Which-ID, Map nur fuer PropertySetInfo
 
 //!	umbenennen, sind nicht mehr nur Options
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
 const SfxItemPropertyMap* lcl_GetDocOptPropertyMap()
 {
 	static SfxItemPropertyMap aDocOptPropertyMap_Impl[] =
@@ -336,6 +337,7 @@ uno::Any SAL_CALL ScModelObj::queryInter
 	SC_QUERYINTERFACE( view::XRenderable )
 	SC_QUERYINTERFACE( document::XLinkTargetSupplier )
 	SC_QUERYINTERFACE( beans::XPropertySet )
+	SC_QUERYINTERFACE( document::XCodeNameQuery )
 	SC_QUERYINTERFACE( lang::XMultiServiceFactory )
 	SC_QUERYINTERFACE( lang::XServiceInfo )
 
@@ -1694,7 +1696,49 @@ uno::Sequence<rtl::OUString> SAL_CALL Sc
 
 	return concatServiceNames( aMyServices, aDrawServices );
 }
-
+// XCodeNameQuery
+rtl::OUString SAL_CALL 
+ScModelObj::getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+{
+    rtl::OUString sCodeName;
+    if ( pDocShell )
+    {
+        OSL_TRACE( "*** In ScModelObj::getCodeNameForObject");
+        // need to find the page ( and index )  for this control
+        uno::Reference< drawing::XDrawPagesSupplier > xSupplier( pDocShell->GetModel(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPages(), uno::UNO_QUERY_THROW );
+        sal_Int32 nLen = xIndex->getCount();
+        bool bMatched = false;
+        uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+        for ( sal_Int32 index = 0; index < nLen; ++index )
+        {
+            try
+            {
+                uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex->getByIndex( index ), uno::UNO_QUERY_THROW );
+                uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                // get the www-standard container
+                uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                sal_Int32 nCntrls = xFormControls->getCount();
+                for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                {
+                    uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                    bMatched = ( xControl == xIf );
+                    if ( bMatched )
+                    {
+                        String sName;
+                        pDocShell->GetDocument()->GetCodeName( index, sName );
+                        sCodeName = sName;
+                    }
+                }
+            }
+            catch( uno::Exception& ) {}
+            if ( bMatched )
+                break;
+        }
+    }
+    // Probably should throw here ( if !bMatched )
+     return sCodeName;
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
diff -rup oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl
--- oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl	2007-04-27 08:32:41.000000000 +0100
+++ oovbaapi/org/openoffice/vba/XVBAToOOEventDescGen.idl	2008-04-28 16:14:51.000000000 +0100
@@ -46,8 +46,8 @@
 module org {  module openoffice {  module vba { 
 interface XVBAToOOEventDescGen : com::sun::star::uno::XInterface
 {
-	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sLibModName, [in] sequence< string > handlerExts );
-	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl );
+	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
+	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
 };
 
 }; }; };
--- /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/offapi/com/sun/star/document/makefile.mk	2008-03-07 12:31:01.000000000 +0000
+++ offapi/com/sun/star/document/makefile.mk	2008-04-28 17:25:31.000000000 +0100
@@ -111,7 +111,9 @@ IDLFILES=\
     LinkUpdateModes.idl\
     XDocumentRevisionListPersistence.idl\
     DocumentRevisionListPersistence.idl \
-    XDocumentLanguages.idl	\
+    XDocumentLanguages.idl \
+    XCodeNameQuery.idl \
+
 
 # ------------------------------------------------------------------
 
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ offapi/com/sun/star/document/XCodeNameQuery.idl	2008-04-28 17:39:33.000000000 +0100
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDocumentPropertiesSupplier.idl,v $
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCodeNameQuery_idl__
+#define __com_sun_star_document_XCodeNameQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+//=============================================================================
+interface XCodeNameQuery
+{
+	//-------------------------------------------------------------------------
+    string getCodeNameForObject( [in] com::sun::star::uno::XInterface aObj );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff -rup /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/forms/source/misc/InterfaceContainer.cxx forms/source/misc/InterfaceContainer.cxx
--- /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/forms/source/misc/InterfaceContainer.cxx	2008-01-29 17:06:59.000000000 +0000
+++ forms/source/misc/InterfaceContainer.cxx	2008-04-29 00:24:31.000000000 +0100
@@ -106,12 +106,19 @@
 
 //.........................................................................
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+#include <comphelper/processfactory.hxx>
+
 namespace frm
 {
 //.........................................................................
 
+using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::document;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::io;
@@ -127,6 +134,88 @@ namespace
 	}
 }
 
+bool
+lcl_hasVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents  )
+{
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+			return true;
+	}
+	return false;
+}
+
+Sequence< ScriptEventDescriptor >
+lcl_stripVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents )
+{
+	Sequence< ScriptEventDescriptor > sStripped( sEvents.getLength() );
+	
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	sal_Int32 nCopied = 0;
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( !pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+		{
+			sStripped[ nCopied++ ] = *pDesc;
+		}
+	}
+	if ( nCopied )
+		sStripped.realloc( nCopied );
+	return sStripped;
+}
+
+void
+OInterfaceContainer::fakeVbaEventsHack(  sal_Int32 _nIndex )
+{
+	// we are dealing with form controls
+	try
+	{
+		Reference< XFormComponent > xForm( static_cast< XContainer* >(this), UNO_QUERY_THROW );
+		// grand-parent should be the model, no parent ? if not
+		// we'll ignore,  we'll get called back here  anyway )
+		Reference< XChild > xChild(  xForm->getParent(), UNO_QUERY_THROW );
+		Reference< XModel > xDocOwner( xChild->getParent(), UNO_QUERY );
+		Reference< XCodeNameQuery > xNameQuery( xDocOwner, UNO_QUERY );
+		OSL_TRACE(" Is DOC ????? %s", xDocOwner.is() ? "true" : "false" );
+		if ( xDocOwner.is() && xNameQuery.is() )
+		{
+			bool hasVBABindings = lcl_hasVbaEvents( m_xEventAttacher->getScriptEvents( _nIndex ) );  
+			if ( hasVBABindings )
+			{
+				OSL_TRACE("Has VBA bindings already, returning ");
+				return;
+			}
+			Reference< XMultiServiceFactory > xFac(  comphelper::getProcessServiceFactory(), UNO_QUERY );
+			if ( xFac.is() )
+			{
+				try
+				{
+					Reference< org::openoffice::vba::XVBAToOOEventDescGen > xDescSupplier( xFac->createInstance( rtl::OUString::createFromAscii( "org.openoffice.vba.VBAToOOEventDesc" ) ), UNO_QUERY_THROW );
+					Reference< XInterface > xIf( getByIndex( _nIndex ) , UNO_QUERY_THROW );
+					rtl::OUString sCodeName;	
+					sCodeName = xNameQuery->getCodeNameForObject( xIf );
+					Reference< XPropertySet > xProps( xIf, UNO_QUERY );
+					rtl::OUString sServiceName;
+					xProps->getPropertyValue( rtl::OUString::createFromAscii("DefaultControl" ) ) >>= sServiceName;
+
+					Sequence< ScriptEventDescriptor > vbaEvents = xDescSupplier->getEventDescriptions( xFac->createInstance( sServiceName ), sCodeName );
+					// register the vba script events
+					if ( m_xEventAttacher.is() )
+						m_xEventAttacher->registerScriptEvents( _nIndex, vbaEvents );
+				}
+				catch( Exception& e ){ OSL_TRACE("lcl_fakevbaevents - Caught Exception trying to create control eventstuff "); }
+			}
+
+		}
+	}
+	catch( Exception& e )
+	{
+	}
+
+}
 //==================================================================
 //= ElementDescription
 //==================================================================
@@ -726,6 +815,7 @@ void OInterfaceContainer::approveNewElem
 void OInterfaceContainer::implInsert(sal_Int32 _nIndex, const Reference< XPropertySet >& _rxElement,
 	sal_Bool _bEvents, ElementDescription* _pApprovalResult, sal_Bool _bFire ) throw( IllegalArgumentException )
 {
+        OSL_TRACE("OInterfaceContainer::implInsert( %d)", _nIndex );
 	RTL_LOGFILE_CONTEXT( aLogger, "forms::OInterfaceContainer::implInsert" );
 
 	::osl::ClearableMutexGuard aGuard( m_rMutex );
@@ -775,6 +865,23 @@ void OInterfaceContainer::implInsert(sal
 	{
 		m_xEventAttacher->insertEntry(_nIndex);
 		m_xEventAttacher->attach( _nIndex, pElementMetaData->xInterface, makeAny( _rxElement ) );
+		// insert fake events?
+		Reference< XEventAttacherManager > xMgr ( pElementMetaData->xInterface, UNO_QUERY );
+		if ( xMgr.is() )
+		{ 
+			OInterfaceContainer* pIfcMgr = dynamic_cast< OInterfaceContainer* >( xMgr.get() );
+			sal_Int32 nLen = pIfcMgr->getCount();
+			for ( sal_Int32 i = 0; (i < nLen) && pIfcMgr ; ++i )
+			{	
+				// add fake events to the control at index i
+				pIfcMgr->fakeVbaEventsHack( i );
+			}	
+		}
+		else
+		{
+			// add fake events to the control at index i
+			fakeVbaEventsHack(  _nIndex );	
+		}
 	}
 
 	// notify derived classes
@@ -1054,20 +1161,29 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvent( sal_Int32 nIndex, const ScriptEventDescriptor& aScriptEvent ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
 	    m_xEventAttacher->registerScriptEvent( nIndex, aScriptEvent );
+            fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvents( sal_Int32 nIndex, const Sequence< ScriptEventDescriptor >& aScriptEvents ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent(s) %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
     	m_xEventAttacher->registerScriptEvents( nIndex, aScriptEvents );
+        fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::revokeScriptEvent( sal_Int32 nIndex, const ::rtl::OUString& aListenerType, const ::rtl::OUString& aEventMethod, const ::rtl::OUString& aRemoveListenerParam ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** revokeScriptEvent %d listenertype %s, eventMethod %s", nIndex, rtl::OUStringToOString( aListenerType, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( aEventMethod, RTL_TEXTENCODING_UTF8 ).getStr());
     if ( m_xEventAttacher.is() )
     	m_xEventAttacher->revokeScriptEvent( nIndex, aListenerType, aEventMethod, aRemoveListenerParam );
 }
@@ -1096,9 +1212,16 @@ void SAL_CALL OInterfaceContainer::remov
 //------------------------------------------------------------------------
 Sequence< ScriptEventDescriptor > SAL_CALL OInterfaceContainer::getScriptEvents( sal_Int32 nIndex ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("getScriptEvents");
     Sequence< ScriptEventDescriptor > aReturn;
     if ( m_xEventAttacher.is() )
+    {
 	    aReturn = m_xEventAttacher->getScriptEvents( nIndex );
+            if ( lcl_hasVbaEvents( aReturn ) )
+            {
+                aReturn = lcl_stripVbaEvents( aReturn );
+            }
+    }
     return aReturn;
 }
 
--- /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/forms/source/inc/InterfaceContainer.hxx	2007-01-29 15:46:36.000000000 +0000
+++ forms/source/inc/InterfaceContainer.hxx	2008-04-28 18:13:48.000000000 +0100
@@ -319,6 +319,9 @@ protected:
 	void implCheckIndex( const sal_Int32 _nIndex ) SAL_THROW( ( ::com::sun::star::lang::IndexOutOfBoundsException ) );
 
 private:
+	// hack for Vba Events
+	void fakeVbaEventsHack( sal_Int32 _nIndex );
+
 	// the runtime event format has changed from version SO5.2 to OOo
 	enum EventFormat
 	{
diff -rup /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/forms/source/misc/makefile.mk forms/source/misc/makefile.mk
--- /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/forms/source/misc/makefile.mk	2005-09-09 00:01:56.000000000 +0100
+++ forms/source/misc/makefile.mk	2008-04-28 18:13:48.000000000 +0100
@@ -48,6 +48,7 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Types -------------------------------------
 
 INCPRE+=$(SOLARINCDIR)$/offuh
+INCPRE*=$(INCCOM)$/$(TARGET)
 
 # --- Files -------------------------------------
 
@@ -65,3 +66,12 @@ SLOFILES=	$(SLO)$/limitedformats.obj \
 
 .INCLUDE : target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
--- /data4/OOOBuildDEVM4-source-only/ooo-build/build/dev300-m4/sc/source/ui/vba/vbaworksheet.cxx	2008-04-29 17:54:53.000000000 +0100
+++ sc/source/ui/vba/vbaworksheet.cxx	2008-04-29 17:52:06.000000000 +0100
@@ -771,7 +771,7 @@ ScVbaWorksheet::getServiceNames()
 rtl::OUString SAL_CALL
 ScVbaWorksheet::getCodeName() throw (css::uno::RuntimeException)
 {
-#ifdef VBA_OOBUILD_HACK 
+#if 0
     uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
     SCTAB nTab = 0;
     rtl::OUString aSheetName = getName();
@@ -792,7 +792,7 @@ ScVbaWorksheet::getCodeName() throw (css
 	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 #endif
 }
-#ifdef VBA_OOBUILD_HACK 
+#if 0
 void SAL_CALL
 ScVbaWorksheet::setCodeName( const rtl::OUString& sCodeName ) throw (css::uno::RuntimeException)
 {
+++ extensions/source/propctrlr/eventhandler.cxx	2008-05-09 15:08:21.000000000 +0100
@@ -62,6 +62,7 @@
 /** === end UNO includes === **/
 
 #include <comphelper/namedvaluecollection.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <comphelper/types.hxx>
 #include <cppuhelper/implbase1.hxx>
 #include <rtl/ref.hxx>
@@ -165,36 +166,6 @@ namespace pcr
     namespace
     {
         //....................................................................
-        Sequence< ::rtl::OUString > lcl_getListenerMethodsForType( const Type& type )
-        {
-            typelib_InterfaceTypeDescription *pType=0;
-            type.getDescription( (typelib_TypeDescription**)&pType);
-
-            if ( !pType )
-                return Sequence< ::rtl::OUString>();
-
-            Sequence< ::rtl::OUString > aNames( pType->nMembers );
-            ::rtl::OUString* pNames = aNames.getArray();
-            for ( sal_Int32 i = 0; i < pType->nMembers; ++i, ++pNames)
-            {
-                // the decription reference
-                typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-                // the description for the reference
-                typelib_TypeDescription* pMemberDescription = NULL;
-                typelib_typedescriptionreference_getDescription( &pMemberDescription, pMemberDescriptionReference );
-                if ( pMemberDescription )
-                {
-                    typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-                        reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-                    *pNames = pRealMemberDescription->pMemberName;
-                }
-            }
-
-            typelib_typedescription_release( (typelib_TypeDescription*)pType );
-            return aNames;
-        }
-
-        //....................................................................
         #define DESCRIBE_EVENT( asciinamespace, asciilistener, asciimethod, id_postfix ) \
             s_aKnownEvents.insert( EventMap::value_type( \
                 ::rtl::OUString::createFromAscii( asciimethod ), \
@@ -762,7 +733,7 @@ namespace pcr
                         continue;
 
                     // loop through all methods
-                    Sequence< ::rtl::OUString > aMethods( lcl_getListenerMethodsForType( *pListeners ) );
+                    Sequence< ::rtl::OUString > aMethods( comphelper::getEventMethodsForType( *pListeners ) );
 
                     const ::rtl::OUString* pMethods = aMethods.getConstArray();
                     sal_uInt32 methodCount = aMethods.getLength();
--- svx/source/form/fmtools.cxx	2008-04-11 02:13:38.000000000 +0100
+++ svx/source/form/fmtools.cxx	2008-05-09 15:17:26.000000000 +0100
@@ -105,6 +105,7 @@
 #include <comphelper/uno3.hxx>
 #include <connectivity/dbexception.hxx>
 #include <comphelper/extract.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <cppuhelper/typeprovider.hxx>
 #include <algorithm>
 
@@ -719,36 +720,6 @@ sal_Int16 getControlTypeByObject(const R
 	return ::rtl::OUString();
 }
 //------------------------------------------------------------------------------
-Sequence< ::rtl::OUString> getEventMethods(const Type& type)
-{
-	typelib_InterfaceTypeDescription *pType=0;
-	type.getDescription( (typelib_TypeDescription**)&pType);
-
-	if(!pType)
-		return Sequence< ::rtl::OUString>();
-
-	Sequence< ::rtl::OUString> aNames(pType->nMembers);
-	::rtl::OUString* pNames = aNames.getArray();
-	for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
-	{
-		// the decription reference
-		typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-		// the description for the reference
-		typelib_TypeDescription* pMemberDescription = NULL;
-		typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
-		if (pMemberDescription)
-		{
-			typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-				reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-			*pNames = pRealMemberDescription->pMemberName;
-		}
-	}
-	typelib_typedescription_release( (typelib_TypeDescription *)pType );
-	return aNames;
-}
-
-
-//------------------------------------------------------------------------------
 void TransferEventScripts(const Reference< ::com::sun::star::awt::XControlModel>& xModel, const Reference< ::com::sun::star::awt::XControl>& xControl,
 	const Sequence< ::com::sun::star::script::ScriptEventDescriptor>& rTransferIfAvailable)
 {
@@ -821,7 +792,8 @@ void TransferEventScripts(const Referenc
 					continue;
 
 				// now check the methods
-				Sequence< ::rtl::OUString> aMethodsNames = getEventMethods(*pCurrentListeners);
+				Sequence< ::rtl::OUString> aMethodsNames = ::comphelper::getEventMethodsForType(*pCurrentListeners);
+
 				const ::rtl::OUString* pMethodsNames = aMethodsNames.getConstArray();
 				for (k=0; k<aMethodsNames.getLength(); ++k, ++pMethodsNames)
 				{
--- comphelper.orig/source/misc/makefile.mk	2008-04-11 12:11:33.000000000 +0100
+++ comphelper/source/misc/makefile.mk	2008-05-15 18:08:56.703125000 +0100
@@ -58,6 +58,7 @@
             $(SLO)$/componentmodule.obj \
             $(SLO)$/configurationhelper.obj \
             $(SLO)$/documentinfo.obj \
+	    $(SLO)$/evtmethodhelper.obj \
             $(SLO)$/evtlistenerhlp.obj \
             $(SLO)$/facreg.obj \
             $(SLO)$/ihwrapnofilter.obj \
--- /dev/null	2008-05-15 18:17:31.156250000 +0100
+++ comphelper/inc/comphelper/evtmethodhelper.hxx	2008-05-15 18:07:14.781250000 +0100
@@ -0,0 +1,41 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.hxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef COMPHELPER_EVENTMEHODHELPER_HXX
+#define COMPHELPER_EVENMETHODHELPER_HXX
+#include <comphelper/sequence.hxx>
+//........................................................................
+namespace comphelper
+{
+	COMPHELPER_DLLPUBLIC ::com::sun::star::uno::Sequence< ::rtl::OUString> getEventMethodsForType(const ::com::sun::star::uno::Type& type);
+//........................................................................
+
+}	// namespace comphelper
+//........................................................................
+#endif // COMPHELPER_EVENTMEHODHELPER_HXX
--- /dev/null	2008-05-15 18:18:04.703125000 +0100
+++ comphelper/source/misc/evtmethodhelper.cxx	2008-05-15 18:08:38.968750000 +0100
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.cxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_comphelper.hxx"
+#include "comphelper/evtmethodhelper.hxx"
+#include "cppuhelper/typeprovider.hxx"
+
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Type;
+
+namespace comphelper
+{
+
+	Sequence< ::rtl::OUString> getEventMethodsForType(const Type& type)
+	{
+		typelib_InterfaceTypeDescription *pType=0;
+		type.getDescription( (typelib_TypeDescription**)&pType);
+	
+		if(!pType)
+			return Sequence< ::rtl::OUString>();
+	    
+		Sequence< ::rtl::OUString> aNames(pType->nMembers);
+		::rtl::OUString* pNames = aNames.getArray();
+		for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
+		{
+			// the decription reference
+			typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
+			// the description for the reference
+			typelib_TypeDescription* pMemberDescription = NULL;
+			typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
+			if (pMemberDescription)
+			{
+				typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
+				reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
+				*pNames = pRealMemberDescription->pMemberName;
+			}
+		}
+		typelib_typedescription_release( (typelib_TypeDescription *)pType );
+		return aNames;
+	}
+
+}
+
+
+
+
+
+
+
