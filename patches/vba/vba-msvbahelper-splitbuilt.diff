diff --git filter/inc/filter/msfilter/msvbahelper.hxx filter/inc/filter/msfilter/msvbahelper.hxx
deleted file mode 100644
index 1e2032e..0000000
--- filter/inc/filter/msfilter/msvbahelper.hxx
+++ /dev/null
@@ -1,55 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef _MSVBAHELPER_HXX
-#define _MSVBAHELPER_HXX
-
-#include <sfx2/objsh.hxx>
-#include "filter/msfilter/msfilterdllapi.h"
-
-namespace ooo { namespace vba 
-{
-    class MSFILTER_DLLPUBLIC VBAMacroResolvedInfo
-    {
-        SfxObjectShell* mpDocContext;
-        bool mbFound;
-        String msResolvedMacro;
-        public:
-        VBAMacroResolvedInfo() : mpDocContext(NULL), mbFound( false ){}
-        void SetResolved( bool bRes ) { mbFound = bRes; }
-        bool IsResolved() { return mbFound; }
-        void SetMacroDocContext(SfxObjectShell* pShell )  { mpDocContext = pShell; }
-        SfxObjectShell* MacroDocContext() { return mpDocContext; }
-        String ResolvedMacro() { return msResolvedMacro; }
-        void SetResolvedMacro(const String& sMacro ) { msResolvedMacro = sMacro; }
-    };
-
-    MSFILTER_DLLPUBLIC String makeMacroURL( const String& sMacroName );
-    MSFILTER_DLLPUBLIC  VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUString& sMod, bool bSearchGlobalTemplates = false );
-    MSFILTER_DLLPUBLIC sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, com::sun::star::uno::Sequence< com::sun::star::uno::Any >& aArgs, com::sun::star::uno::Any& aRet, const com::sun::star::uno::Any& aCaller );
-} }
-
-#endif
diff --git filter/source/msfilter/makefile.mk filter/source/msfilter/makefile.mk
index c59a126..b37dc7b 100644
--- filter/source/msfilter/makefile.mk
+++ filter/source/msfilter/makefile.mk
@@ -52,7 +52,6 @@ SLOFILES= \
     $(SLO)$/msfiltertracer.obj \
     $(SLO)$/svdfppt.obj		\
     $(SLO)$/svxmsbas2.obj \
-    $(SLO)$/msvbahelper.obj \
 	$(SLO)$/mstoolbar.obj\
 
 SHL1TARGET= msfilter$(DLLPOSTFIX)
diff --git filter/source/msfilter/mstoolbar.cxx filter/source/msfilter/mstoolbar.cxx
index eead43c..3b92f80 100644
--- filter/source/msfilter/mstoolbar.cxx
+++ filter/source/msfilter/mstoolbar.cxx
@@ -5,6 +5,7 @@
 #include <com/sun/star/ui/XImageManager.hpp>
 #include <com/sun/star/ui/ItemType.hpp>
 #include <com/sun/star/ui/ItemStyle.hpp>
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
 #include <com/sun/star/frame/XLayoutManager.hpp>
 #include <fstream>
 #include <vcl/graph.hxx>
@@ -15,10 +16,10 @@
 #include <basic/basmgr.hxx>
 #include <svtools/filterutils.hxx>
 #include <boost/scoped_array.hpp>
-#include <filter/msfilter/msvbahelper.hxx>
 #include <svtools/miscopt.hxx>
 #include <vcl/svapp.hxx>
 #include <vcl/window.hxx>
+#include <comphelper/processfactory.hxx>
 
 using namespace com::sun::star;
 
@@ -488,9 +489,18 @@ TBCGeneralInfo::ImportToolBarControlData( CustomToolBarImportHelper& helper, std
         if ( extraInfo.getOnAction().getLength() )
         {
             aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
-            ooo::vba::VBAMacroResolvedInfo aMacroInf = ooo::vba::resolveVBAMacro( &helper.GetDocShell(), extraInfo.getOnAction(), true );
-            if ( aMacroInf.IsResolved() )
-                aProp.Value = helper.createCommandFromMacro( aMacroInf.ResolvedMacro() );
+            uno::Reference< script::XVBAMacroResolvedInfo > xMacroInf;
+            try
+            {
+                uno::Reference< script::XVBAMacroHelper > xMacroHelper =  script::theVBAMacroHelper::get( comphelper::getProcessComponentContext() );
+                xMacroInf = xMacroHelper->resolveVBAMacro( helper.GetDocShell().GetModel(), extraInfo.getOnAction(), sal_True );
+            }
+            catch( uno::Exception& e )
+            {
+            }
+
+            if ( xMacroInf.is() && xMacroInf->getResolved() )
+                aProp.Value = helper.createCommandFromMacro( xMacroInf->getResolvedMacro() );
             else
                 aProp.Value <<= rtl::OUString::createFromAscii("UnResolvedMacro[").concat( extraInfo.getOnAction() ).concat( rtl::OUString::createFromAscii("]") );
             sControlData.push_back( aProp );
diff --git filter/source/msfilter/msvbahelper.cxx filter/source/msfilter/msvbahelper.cxx
deleted file mode 100644
index ef8a242..0000000
--- filter/source/msfilter/msvbahelper.cxx
+++ /dev/null
@@ -1,394 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2000, 2010 Oracle and/or its affiliates.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_filter.hxx"
-
-#include <filter/msfilter/msvbahelper.hxx>
-#include <basic/sbx.hxx>
-#include <basic/sbstar.hxx>
-#include <basic/basmgr.hxx>
-#include <basic/sbmod.hxx>
-#include <basic/sbmeth.hxx>
-#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
-#include <com/sun/star/document/XDocumentProperties.hpp>
-#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
-#include <com/sun/star/script/XVBACompat.hpp>
-#include <tools/urlobj.hxx>
-#include <osl/file.hxx>
-#include <unotools/pathoptions.hxx>
-
-using namespace ::com::sun::star;
-
-const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
-const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
-
-namespace ooo { namespace vba {
-
-String makeMacroURL( const String& sMacroName )
-{
-    return sUrlPart0.concat( sMacroName ).concat( sUrlPart1 ) ;
-}
-
-SfxObjectShell* findShellForUrl( const rtl::OUString& sMacroURLOrPath )
-{
-    SfxObjectShell* pFoundShell=NULL;
-    SfxObjectShell* pShell = SfxObjectShell::GetFirst();
-    INetURLObject aObj;
-    aObj.SetURL( sMacroURLOrPath );
-    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
-    rtl::OUString aURL;
-    if ( bIsURL )
-        aURL = sMacroURLOrPath;
-    else
-    {
-        osl::FileBase::getFileURLFromSystemPath( sMacroURLOrPath, aURL );
-        aObj.SetURL( aURL );
-    }    
-    OSL_TRACE("Trying to find shell for url %s", rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() );
-    while ( pShell )
-    {
-
-        uno::Reference< frame::XModel > xModel = pShell->GetModel();
-        // are we searching for a template? if so we have to cater for the
-        // fact that in openoffice a document opened from a template is always
-        // a new document :/
-        if ( xModel.is() )
-        {
-            OSL_TRACE("shell 0x%x has model with url %s and we look for %s", pShell
-                , rtl::OUStringToOString( xModel->getURL(), RTL_TEXTENCODING_UTF8 ).getStr() 
-                , rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() 
-            );
-            if ( sMacroURLOrPath.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) )
-            {
-                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( xModel, uno::UNO_QUERY );
-                if( xDocInfoSupp.is() )
-                {
-                    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
-                    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
-                    rtl::OUString sCurrName = xDocProps->getTemplateName();
-                    if( sMacroURLOrPath.lastIndexOf( sCurrName ) >= 0 )
-                    {
-                        pFoundShell = pShell; 
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                // sometimes just the name of the document ( without the path
-                // is used
-                bool bDocNameNoPathMatch = false;
-                if ( aURL.getLength() && aURL.indexOf( '/' ) == -1 )
-                {
-                    sal_Int32 lastSlashIndex = xModel->getURL().lastIndexOf( '/' );
-                    if ( lastSlashIndex > -1 )
-                    {
-                        bDocNameNoPathMatch = xModel->getURL().copy( lastSlashIndex + 1 ).equals( aURL );
-                        if ( !bDocNameNoPathMatch )
-                        {
-                            rtl::OUString aTmpName = rtl::OUString::createFromAscii("'") + xModel->getURL().copy( lastSlashIndex + 1 ) + rtl::OUString::createFromAscii("'");
-                            bDocNameNoPathMatch = aTmpName.equals( aURL );
-                        }
-                    }
-                } 
-                             
-                if ( aURL.equals( xModel->getURL() ) || bDocNameNoPathMatch )
-                {
-                    pFoundShell = pShell; 
-                    break;
-                }
-            }
-        }
-        pShell = SfxObjectShell::GetNext( *pShell );
-    }
-    return pFoundShell;
-}
-
-// sMod can be empty ( but we really need the library to search in )
-// if sMod is empty and a macro is found then sMod is updated
-bool hasMacro( SfxObjectShell* pShell, const String& sLibrary, String& sMod, const String& sMacro )
-{
-    bool bFound = false;
-    if ( sLibrary.Len() && sMacro.Len() )
-    {
-        OSL_TRACE("** Searching for %s.%s in library %s"
-            ,rtl::OUStringToOString( sMod, RTL_TEXTENCODING_UTF8 ).getStr()
-            ,rtl::OUStringToOString( sMacro, RTL_TEXTENCODING_UTF8 ).getStr()
-            ,rtl::OUStringToOString( sLibrary, RTL_TEXTENCODING_UTF8 ).getStr() );
-        BasicManager* pBasicMgr = pShell-> GetBasicManager();
-        if ( pBasicMgr )
-        {
-            StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
-            if ( !pBasic )
-            {
-                USHORT nId = pBasicMgr->GetLibId( sLibrary );
-                pBasicMgr->LoadLib( nId );
-                pBasic = pBasicMgr->GetLib( sLibrary );
-            }
-            if ( pBasic )
-            {
-                if ( sMod.Len() ) // we wish to find the macro is a specific module
-                {
-                    SbModule* pModule = pBasic->FindModule( sMod );
-                    if ( pModule )
-                    {
-                        SbxArray* pMethods = pModule->GetMethods();
-                        if ( pMethods )
-                        {
-                            SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
-                            if ( pMethod )
-                              bFound = true;
-                        }
-                    }
-                }
-                else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
-                {
-                    if( SbModule* pModule = pMethod->GetModule() )
-                    {
-                        sMod = pModule->GetName();
-                        bFound = true;
-                    }
-                }
-            }
-        }
-    }
-    return bFound;
-}
-void parseMacro( const rtl::OUString& sMacro, String& sContainer, String& sModule, String& sProcedure )
-{
-    sal_Int32 nMacroDot = sMacro.lastIndexOf( '.' );
-    
-    if ( nMacroDot != -1 )
-    {
-        sProcedure = sMacro.copy( nMacroDot + 1 );
- 
-        sal_Int32 nContainerDot = sMacro.lastIndexOf( '.',  nMacroDot - 1 );
-        if ( nContainerDot != -1 )
-        {
-            sModule = sMacro.copy( nContainerDot + 1, nMacroDot - nContainerDot - 1 );
-            sContainer = sMacro.copy( 0, nContainerDot );
-        }
-        else
-            sModule = sMacro.copy( 0, nMacroDot );
-    }
-    else
-       sProcedure = sMacro;
-}
-
-VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUString& MacroName, bool bSearchGlobalTemplates )
-{
-    VBAMacroResolvedInfo aRes;
-    if ( !pShell )
-        return aRes;
-    aRes.SetMacroDocContext( pShell );
-    // parse the macro name
-    sal_Int32 nDocSepIndex = MacroName.indexOfAsciiL( "!", 1 );
-    String sMacroUrl = MacroName;
-
-    String sContainer;
-    String sModule;
-    String sProcedure;
-    
-    if( nDocSepIndex > 0 )
-    {
-        // macro specified by document name
-        // find document shell for document name and call ourselves 
-        // recursively
-
-        // assume for now that the document name is *this* document
-        String sDocUrlOrPath = MacroName.copy( 0, nDocSepIndex );
-        sMacroUrl = MacroName.copy( nDocSepIndex + 1 );
-        OSL_TRACE("doc search, current shell is 0x%x", pShell );
-        SfxObjectShell* pFoundShell = NULL;
-        if( bSearchGlobalTemplates )
-        {
-            SvtPathOptions aPathOpt;
-            String aAddinPath = aPathOpt.GetAddinPath();
-            if( rtl::OUString( sDocUrlOrPath ).indexOf( aAddinPath ) == 0 )
-                pFoundShell = pShell; 
-        }
-        if( pFoundShell == NULL )
-            pFoundShell = findShellForUrl( sDocUrlOrPath );
-        OSL_TRACE("doc search, after find, found shell is 0x%x", pFoundShell );
-        aRes = resolveVBAMacro( pFoundShell, sMacroUrl, bSearchGlobalTemplates ); 
-        return aRes;
-    }    
-    else
-    {
-        // macro is contained in 'this' document ( or code imported from a template
-        // where that template is a global template or perhaps the template this
-        // document is created from ) 
-    
-        // macro format = Container.Module.Procedure
-        parseMacro( MacroName, sContainer, sModule, sProcedure ); 
-        uno::Reference< lang::XMultiServiceFactory> xSF( pShell->GetModel(), uno::UNO_QUERY);
-        uno::Reference< container::XNameContainer > xPrjNameCache;
-        if ( xSF.is() )
-            xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
-    
-        std::vector< rtl::OUString > sSearchList; 
-
-        if ( sContainer.Len() > 0 )
-        { 
-            // get the Project associated with the Container
-            if ( xPrjNameCache.is() )
-            {
-                if ( xPrjNameCache->hasByName( sContainer ) )
-                {
-                    rtl::OUString sProject;
-                    xPrjNameCache->getByName( sContainer ) >>= sProject;
-                    sContainer = sProject;
-                }
-            }
-            sSearchList.push_back( sContainer ); // First Lib to search
-        }
-        else
-        {
-            // Ok, if we have no Container specified then we need to search them in order, this document, template this document created from, global templates, 
-            // get the name of Project/Library for 'this' document
-            rtl::OUString sThisProject = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") );
-            try
-            {
-                uno::Reference< beans::XPropertySet > xProps( pShell->GetModel(), uno::UNO_QUERY_THROW );
-                uno::Reference< script::XVBACompat > xVBAMode( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BasicLibraries") ) ), uno::UNO_QUERY_THROW );
-                sThisProject = xVBAMode->getProjectName();
-            }
-            catch( uno::Exception& /*e*/) {}
-
-            sSearchList.push_back( sThisProject ); // First Lib to search
-            if ( xPrjNameCache.is() )
-            {
-                // is this document created from a template?
-                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( pShell->GetModel(), uno::UNO_QUERY_THROW );
-                uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
-                uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
-            
-                rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
-                if ( sCreatedFrom.getLength() )
-                {
-                    INetURLObject aObj;
-                    aObj.SetURL( sCreatedFrom );
-                    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
-                    rtl::OUString aURL;
-                    if ( bIsURL )
-                        aURL = sCreatedFrom;
-                    else
-                    {
-                        osl::FileBase::getFileURLFromSystemPath( sCreatedFrom, aURL );
-                        aObj.SetURL( aURL );
-                    }        
-                    sCreatedFrom =  aObj.GetLastName();
-                } 
-                
-                sal_Int32 nIndex =  sCreatedFrom.lastIndexOf( '.' );
-                if ( nIndex != -1 )
-                    sCreatedFrom = sCreatedFrom.copy( 0, nIndex );
-        
-                rtl::OUString sPrj;
-                if ( sCreatedFrom.getLength() && xPrjNameCache->hasByName( sCreatedFrom ) )
-                {
-                    xPrjNameCache->getByName( sCreatedFrom ) >>= sPrj;
-                    // Make sure we don't double up with this project
-                    if ( !sPrj.equals( sThisProject ) )
-                        sSearchList.push_back( sPrj );
-                }
-        
-                // get list of global template Names
-                uno::Sequence< rtl::OUString > sTemplateNames = xPrjNameCache->getElementNames();
-                sal_Int32 nLen = sTemplateNames.getLength();
-                for ( sal_Int32 index = 0; ( bSearchGlobalTemplates && index < nLen ); ++index )
-                {
-                    
-                    if ( !sCreatedFrom.equals( sTemplateNames[ index ] ) )
-                    {
-                        if ( xPrjNameCache->hasByName( sTemplateNames[ index ] ) )
-                        {
-                            xPrjNameCache->getByName( sTemplateNames[ index ] ) >>= sPrj;
-                            // Make sure we don't double up with this project
-                            if ( !sPrj.equals( sThisProject ) )
-                                sSearchList.push_back( sPrj );
-                        }
-                    }
-        
-                }
-            }
-        }
-        std::vector< rtl::OUString >::iterator it_end = sSearchList.end();
-        for ( std::vector< rtl::OUString >::iterator it = sSearchList.begin(); it != it_end; ++it )
-        {
-            bool bRes = hasMacro( pShell, *it, sModule, sProcedure );
-            if ( bRes )
-            {
-                aRes.SetResolved( true );
-                aRes.SetMacroDocContext( pShell );
-                sContainer = *it;
-                break;
-            }
-        }
-        aRes.SetResolvedMacro( sProcedure.Insert( '.', 0 ).Insert( sModule, 0).Insert( '.', 0 ).Insert( sContainer, 0 ) );
-    }
-
-    return aRes;
-}
-
-// Treat the args as possible inouts ( convertion at bottom of method )
-sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet, const uno::Any& aCaller )
-{
-    sal_Bool bRes = sal_False;
-    if ( !pShell )
-        return bRes;
-    rtl::OUString sUrl = makeMacroURL( sMacroName );
-
-    uno::Sequence< sal_Int16 > aOutArgsIndex;
-    uno::Sequence< uno::Any > aOutArgs;
-
-    try
-    {   ErrCode nErr( ERRCODE_BASIC_INTERNAL_ERROR );
-        if ( pShell )
-        {
-            nErr = pShell->CallXScript( sUrl,
-                               aArgs, aRet, aOutArgsIndex, aOutArgs, false, &aCaller ); 
-            sal_Int32 nLen = aOutArgs.getLength();
-            // convert any out params to seem like they were inouts
-            if ( nLen )
-            {
-                for ( sal_Int32 index=0; index < nLen; ++index )
-                {
-                    sal_Int32 nOutIndex = aOutArgsIndex[ index ];
-                    aArgs[ nOutIndex ] = aOutArgs[ index ];
-                }
-            } 
-        }
-        bRes = ( nErr == ERRCODE_NONE );
-    }
-    catch ( uno::Exception& e )
-    {
-       bRes = sal_False;
-    }
-    return bRes; 
-}
-} } // vba // ooo
diff --git offapi/com/sun/star/script/VBAMacroHelper.idl offapi/com/sun/star/script/VBAMacroHelper.idl
new file mode 100644
index 0000000..e971b8c
--- /dev/null
+++ offapi/com/sun/star/script/VBAMacroHelper.idl
@@ -0,0 +1,15 @@
+#ifndef com_sun_star_script_VBAMacroHelper_idl
+#define com_sun_star_script_VBAMacroHelper_idl
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl>
+#endif 
+#ifndef __com_sun_star_script_XVBAMacroHelper_idl__ 
+#include <com/sun/star/script/XVBAMacroHelper.idl>
+#endif 
+#ifndef __com_sun_star_frame_XModel_idl__ 
+#include <com/sun/star/frame/XModel.idl>
+#endif 
+module com { module sun {  module star {  module script {
+singleton theVBAMacroHelper : ::com::sun::star::script::XVBAMacroHelper;
+}; }; }; };
+#endif
diff --git offapi/com/sun/star/script/XVBAMacroHelper.idl offapi/com/sun/star/script/XVBAMacroHelper.idl
new file mode 100644
index 0000000..a240259
--- /dev/null
+++ offapi/com/sun/star/script/XVBAMacroHelper.idl
@@ -0,0 +1,21 @@
+#ifndef com_sun_star_script_XVBAMacroHelper_idl
+#define com_sun_star_script_XVBAMacroHelper_idl
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl>
+#endif 
+#ifndef __com_sun_star_script_XVBAMacroResolvedInfo_idl__ 
+#include <com/sun/star/script/XVBAMacroResolvedInfo.idl>
+#endif 
+#ifndef __com_sun_star_frame_XModel_idl__ 
+#include <com/sun/star/frame/XModel.idl>
+#endif 
+
+module com {  module sun {  module star {  module script {
+interface XVBAMacroHelper : com::sun::star::uno::XInterface
+{
+    string makeMacroURL( [in] string sMacroName );
+    com::sun::star::script::XVBAMacroResolvedInfo resolveVBAMacro( [in] com::sun::star::frame::XModel model, [in] string moduleName, [in] boolean bSearchGlobalTemplates );
+    boolean executeMacro( [in] com::sun::star::frame::XModel model, [in] string smacroName, [inout] sequence< any > aArgs, [inout] any aRet, [in] any aCaller );
+};
+}; }; }; };
+#endif
diff --git offapi/com/sun/star/script/XVBAMacroResolvedInfo.idl offapi/com/sun/star/script/XVBAMacroResolvedInfo.idl
new file mode 100644
index 0000000..7d4b37e
--- /dev/null
+++ offapi/com/sun/star/script/XVBAMacroResolvedInfo.idl
@@ -0,0 +1,18 @@
+#ifndef com_sun_star_script_XVBAMacroResolvedInfo_idl
+#define com_sun_star_script_XVBAMacroResolvedInfo_idl
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl>
+#endif 
+#ifndef __com_sun_star_frame_XModel_idl__ 
+#include <com/sun/star/frame/XModel.idl>
+#endif 
+
+module com {  module sun {  module star {  module script {
+interface XVBAMacroResolvedInfo
+{
+    [attribute] boolean Resolved;
+    [attribute] string ResolvedMacro;
+    [attribute] com::sun::star::frame::XModel DocumentContext;
+};
+}; }; }; };
+#endif
diff --git offapi/com/sun/star/script/makefile.mk offapi/com/sun/star/script/makefile.mk
index c6c6416..2cdca88 100644
--- offapi/com/sun/star/script/makefile.mk
+++ offapi/com/sun/star/script/makefile.mk
@@ -53,6 +53,10 @@ IDLFILES=\
         XVBAModuleInfo.idl\
     ModuleInfo.idl\
     ModuleType.idl\
+    XVBAMacroHelper.idl\
+    XVBAMacroResolvedInfo.idl\
+    VBAMacroHelper.idl\
+    ModuleType.idl\
 
 # ------------------------------------------------------------------
 
diff --git oox/util/.makefile.mk.swp oox/util/.makefile.mk.swp
deleted file mode 100644
index ad7e40f..0000000
Binary files oox/util/.makefile.mk.swp and /dev/null differ
diff --git sc/source/filter/excel/makefile.mk sc/source/filter/excel/makefile.mk
index a84f4aa..e8b170e 100644
--- sc/source/filter/excel/makefile.mk
+++ sc/source/filter/excel/makefile.mk
@@ -146,6 +146,7 @@ EXCEPTIONSFILES = \
         $(SLO)$/xistring.obj				\
         $(SLO)$/xistyle.obj					\
         $(SLO)$/xladdress.obj				\
+        $(SLO)$/xlescher.obj				\
         $(SLO)$/xiescher.obj				\
         $(SLO)$/xlchart.obj					\
         $(SLO)$/xlformula.obj				\
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index fab4df4..23bfc24 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -30,6 +30,8 @@
 
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
+
 #include <svx/unoapi.hxx>
 #include "xestream.hxx"
 #include "document.hxx"
@@ -42,7 +44,7 @@
 #include <basic/sbmod.hxx>
 #include <basic/sbmeth.hxx>
 #include <basic/basmgr.hxx>
-#include <filter/msfilter/msvbahelper.hxx>
+#include <comphelper/processfactory.hxx>
 
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
@@ -51,6 +53,9 @@ using ::com::sun::star::drawing::XShape;
 using ::com::sun::star::drawing::XControlShape;
 using ::com::sun::star::awt::XControlModel;
 using ::com::sun::star::script::ScriptEventDescriptor;
+using ::com::sun::star::script::XVBAMacroHelper;
+using ::com::sun::star::script::XVBAMacroResolvedInfo;
+using ::com::sun::star::script::theVBAMacroHelper;
 
 // Structs and classes ========================================================
 
@@ -339,11 +344,19 @@ Reference< XControlModel > XclControlHelper::GetControlModel( Reference< XShape
 OUString XclControlHelper::GetScMacroName( const String& rXclMacroName, SfxObjectShell* pDocShell )
 {
     String sTmp( rXclMacroName );
-    if( rXclMacroName.Len() > 0 )
+    Reference< XVBAMacroHelper > xMacroHelper;
+    try
+    {
+        xMacroHelper =  theVBAMacroHelper::get( comphelper::getProcessComponentContext() );
+    }
+    catch( com::sun::star::uno::Exception& )
+    {
+    }
+    if( xMacroHelper.is() && ( rXclMacroName.Len() > 0 ) )
     {
-        ooo::vba::VBAMacroResolvedInfo aMacro = ooo::vba::resolveVBAMacro( pDocShell, rXclMacroName, false );
-        if ( aMacro.IsResolved() )
-            return ooo::vba::makeMacroURL( aMacro.ResolvedMacro() );
+       Reference< XVBAMacroResolvedInfo > xResolvedMacro = xMacroHelper->resolveVBAMacro( pDocShell->GetModel(), rXclMacroName, sal_False );
+        if ( xResolvedMacro->getResolved() )
+            return xMacroHelper->makeMacroURL( xResolvedMacro->getResolvedMacro() );
 
     }
     return OUString();
diff --git sc/source/ui/vba/vbaeventshelper.cxx sc/source/ui/vba/vbaeventshelper.cxx
index db7340e..346c05d 100644
--- sc/source/ui/vba/vbaeventshelper.cxx
+++ sc/source/ui/vba/vbaeventshelper.cxx
@@ -48,6 +48,7 @@
 #include <com/sun/star/table/XCell.hpp> 
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
+
 #include <com/sun/star/container/XNamed.hpp>
 #include <com/sun/star/awt/WindowEvent.hpp>
 #include <com/sun/star/lang/EventObject.hpp>
@@ -62,7 +63,6 @@
 #include <cellsuno.hxx> 
 #include <convuno.hxx>
 #include <map>
-#include <filter/msfilter/msvbahelper.hxx>
 #include <vcl/svapp.hxx>
 #include <basic/basmgr.hxx>
 #include <ooo/vba/XHelperInterface.hpp>
@@ -586,7 +586,11 @@ ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
 {
 	SfxObjectShell* pShell = pDoc->GetDocumentShell();
     String sMacroName = getEventName( nEventId );
-    VBAMacroResolvedInfo sMacroResolvedInfo;
+   
+    if ( !m_xMacroHelper.is() )
+        return rtl::OUString(); // no singleton ( fatal error ) #FIXME can we handle this better ? 
+    uno::Reference< script::XVBAMacroResolvedInfo > xResolvedMacroInfo;
+
     switch( nEventId )
     {
         // Worksheet
@@ -602,7 +606,7 @@ ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
         {
             String  aSheetModuleName = getSheetModuleName( nTab );
             sMacroName.Insert( '.', 0 ).Insert( aSheetModuleName, 0);
-            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            xResolvedMacroInfo = m_xMacroHelper->resolveVBAMacro( pShell->GetModel(), sMacroName, sal_False );
             break;
         }
         // Workbook
@@ -636,18 +640,18 @@ ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
             }
            
             sMacroName.Insert( '.', 0 ).Insert( sWorkbookModuleName, 0);
-            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            xResolvedMacroInfo = m_xMacroHelper->resolveVBAMacro( pShell->GetModel(), sMacroName, sal_False );
             break;
         }
     	case VBAEVENT_WORKBOOK_AUTOOPEN                       :
         {
-            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            xResolvedMacroInfo = m_xMacroHelper->resolveVBAMacro( pShell->GetModel(), sMacroName, sal_False );
             break;
         }
         default:
             break;
     }
-    return sMacroResolvedInfo.ResolvedMacro();
+    return xResolvedMacroInfo->getResolvedMacro();
 }
 
 sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& rArgs, const SCTAB nTab )
@@ -663,7 +667,7 @@ sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno
     // For most cases, there is no corresponsible event macro in the document. 
     // It is better fo check if the event macro exists before process the arguments to improve performance.
     rtl::OUString sMacroPath = getMacroPath( nEventId, nTab );
-	if( sMacroPath.getLength() )
+	if( m_xMacroHelper.is() && sMacroPath.getLength() )
 	{
 		switch( nEventId )
 		{
@@ -756,7 +760,7 @@ sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno
                 // process Cancel argument
                 aArgs = uno::Sequence< uno::Any >(1);
                 aArgs[0] <<= bCancel;
-                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                m_xMacroHelper->executeMacro( pShell->GetModel(), sMacroPath, aArgs, aRet, aDummyCaller );
                 aArgs[0] >>= bCancel;
                 return bCancel;
             }
@@ -766,7 +770,7 @@ sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno
                 aArgs = uno::Sequence< uno::Any >(2);
                 aArgs[0] = rArgs[0];
                 aArgs[1] <<= bCancel;
-                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                m_xMacroHelper->executeMacro( pShell->GetModel(), sMacroPath, aArgs, aRet, aDummyCaller );
                 aArgs[1] >>= bCancel;
                 return bCancel;
             }
@@ -784,7 +788,7 @@ sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno
 		}
     
         // excute the macro
-        result = executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+        result = m_xMacroHelper->executeMacro( pShell->GetModel(), sMacroPath, aArgs, aRet, aDummyCaller );
 	}
     
 	return result;
diff --git scripting/source/vbaevents/eventhelper.cxx scripting/source/vbaevents/eventhelper.cxx
index 8411b09..caf2324 100644
--- scripting/source/vbaevents/eventhelper.cxx
+++ scripting/source/vbaevents/eventhelper.cxx
@@ -78,10 +78,7 @@
 #include <basic/sbmeth.hxx>
 #include <basic/sbmod.hxx>
 #include <basic/sbx.hxx>
-#include <filter/msfilter/msvbahelper.hxx>
-
-
-
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
 
 // for debug
 #include <comphelper/anytostring.hxx>
@@ -762,6 +759,7 @@ private:
 
     Reference< XComponentContext > m_xContext;
     Reference< frame::XModel > m_xModel;
+    Reference< script::XVBAMacroHelper > m_xMacroHelper;
     SfxObjectShell* mpShell;
     sal_Bool m_bDocClosed;
     rtl::OUString msProject; 
@@ -773,6 +771,13 @@ OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), m_bDocClosed(
     registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
         beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
     msProject = rtl::OUString::createFromAscii("Standard");
+    try
+    {
+        m_xMacroHelper =  script::theVBAMacroHelper::get( m_xContext );
+    }
+    catch( Exception& )
+    {
+    }
 }
 
 void
@@ -1000,7 +1005,7 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeExce
         ::rtl::OUString::createFromAscii("VBAInterop");
 
     // let default handlers deal with non vba stuff
-    if ( !evt.ScriptType.equals( vbaInterOp ) )
+    if ( !evt.ScriptType.equals( vbaInterOp ) || !m_xMacroHelper.is() )
         return;
     lang::EventObject aEvent;
     evt.Arguments[ 0 ] >>= aEvent;
@@ -1097,8 +1102,8 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeExce
             
             OSL_TRACE("*** trying to invoke %s ",
                 rtl::OUStringToOString( sToResolve, RTL_TEXTENCODING_UTF8 ).getStr() );
-            ooo::vba::VBAMacroResolvedInfo aMacroResolvedInfo = ooo::vba::resolveVBAMacro( mpShell, sToResolve ); 
-            if ( aMacroResolvedInfo.IsResolved() )
+            Reference< script::XVBAMacroResolvedInfo > xMacroResolvedInfo = m_xMacroHelper->resolveVBAMacro( m_xModel, sToResolve, sal_False ); 
+            if ( xMacroResolvedInfo->getResolved() )
             {
                 //liuchen 2009-6-8
                 if (! txInfo->ApproveRule(evt, txInfo->pPara) )
@@ -1117,7 +1122,7 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeExce
                     // call basic event handlers for event
 
                     // create script url
-                    rtl::OUString url = aMacroResolvedInfo.ResolvedMacro();
+                    rtl::OUString url = xMacroResolvedInfo->getResolvedMacro();
                  
                     OSL_TRACE("resolved script = %s",
                         rtl::OUStringToOString( url, 
@@ -1126,11 +1131,11 @@ EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeExce
                     {
                         uno::Any aDummyCaller = uno::makeAny( rtl::OUString::createFromAscii("Error") );
                         if ( pRet )
-                            ooo::vba::executeMacro( mpShell, url, aArguments, *pRet, aDummyCaller ); 
+                            m_xMacroHelper->executeMacro( m_xModel, url, aArguments, *pRet, aDummyCaller ); 
                         else
                         {
                             uno::Any aRet;
-                            ooo::vba::executeMacro( mpShell, url, aArguments, aRet, aDummyCaller ); 
+                            m_xMacroHelper->executeMacro( m_xModel, url, aArguments, aRet, aDummyCaller ); 
                         }
                     }
                     catch ( uno::Exception& e )
diff --git svx/source/unodraw/makefile.mk svx/source/unodraw/makefile.mk
index 6815f28..8ea6b81 100644
--- svx/source/unodraw/makefile.mk
+++ svx/source/unodraw/makefile.mk
@@ -41,6 +41,7 @@ ENABLE_EXCEPTIONS=TRUE
 
 LIB1TARGET= $(SLB)$/$(TARGET)-core.lib
 LIB1OBJFILES= \
+        $(SLO)$/msvbahelper.obj \
         $(SLO)$/UnoGraphicExporter.obj \
         $(SLO)$/XPropertyTable.obj \
         $(SLO)$/UnoNameItemTable.obj \
diff --git svx/source/unodraw/msvbahelper.cxx svx/source/unodraw/msvbahelper.cxx
new file mode 100644
index 0000000..f6d0fa3
--- /dev/null
+++ svx/source/unodraw/msvbahelper.cxx
@@ -0,0 +1,509 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svx.hxx"
+
+#include "msvbahelper.hxx"
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
+#include <com/sun/star/script/XVBAMacroHelper.hpp>
+
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+#include <unotools/pathoptions.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/lang/XUnoTunnel.hpp>
+
+using namespace ::com::sun::star;
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+namespace svx { 
+
+// old code from msvbahelper ( was in filter ), we need to define an uno service to break some 
+// compile time dependencies for the split build. Additionally the location of this service has 
+// been just chosen for // convenience, really putting the service in any library that is 
+// generally available/loaded is good. The decision to not to put this service in an existing 
+// vba library is intentional as we already call the resolve macro stuff from the binary filters 
+// ( even if the vba functionality is not enabled ) - but... calling this ( service ) could be 
+// determined at runtime so I guess. So, in theory we could put this code in a vba specific 
+// library. ( anyway, lets leave it here for the moment )
+
+class VBAMacroResolvedInfo
+{
+    SfxObjectShell* mpDocContext;
+    bool mbFound;
+    String msResolvedMacro;
+
+    public:
+    VBAMacroResolvedInfo() : mpDocContext(NULL), mbFound( false ){}
+    void SetResolved( bool bRes ) { mbFound = bRes; }
+    bool IsResolved() const { return mbFound; }
+    void SetMacroDocContext(SfxObjectShell* pShell )  { mpDocContext = pShell; }
+    SfxObjectShell* MacroDocContext() const { return mpDocContext; }
+    String ResolvedMacro() const { return msResolvedMacro; }
+    void SetResolvedMacro(const String& sMacro ) { msResolvedMacro = sMacro; }
+};
+
+String makeMacroURLImpl( const String& sMacroName )
+{
+    return sUrlPart0.concat( sMacroName ).concat( sUrlPart1 ) ;
+}
+
+SfxObjectShell* findShellForUrl( const rtl::OUString& sMacroURLOrPath )
+{
+    SfxObjectShell* pFoundShell=NULL;
+    SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+    INetURLObject aObj;
+    aObj.SetURL( sMacroURLOrPath );
+    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+    rtl::OUString aURL;
+    if ( bIsURL )
+        aURL = sMacroURLOrPath;
+    else
+    {
+        osl::FileBase::getFileURLFromSystemPath( sMacroURLOrPath, aURL );
+        aObj.SetURL( aURL );
+    }    
+    OSL_TRACE("Trying to find shell for url %s", rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() );
+    while ( pShell )
+    {
+
+        uno::Reference< frame::XModel > xModel = pShell->GetModel();
+        // are we searching for a template? if so we have to cater for the
+        // fact that in openoffice a document opened from a template is always
+        // a new document :/
+        if ( xModel.is() )
+        {
+            OSL_TRACE("shell 0x%x has model with url %s and we look for %s", pShell
+                , rtl::OUStringToOString( xModel->getURL(), RTL_TEXTENCODING_UTF8 ).getStr() 
+                , rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() 
+            );
+            if ( sMacroURLOrPath.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) )
+            {
+                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( xModel, uno::UNO_QUERY );
+                if( xDocInfoSupp.is() )
+                {
+                    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+                    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+                    rtl::OUString sCurrName = xDocProps->getTemplateName();
+                    if( sMacroURLOrPath.lastIndexOf( sCurrName ) >= 0 )
+                    {
+                        pFoundShell = pShell; 
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                // sometimes just the name of the document ( without the path
+                // is used
+                bool bDocNameNoPathMatch = false;
+                if ( aURL.getLength() && aURL.indexOf( '/' ) == -1 )
+                {
+                    sal_Int32 lastSlashIndex = xModel->getURL().lastIndexOf( '/' );
+                    if ( lastSlashIndex > -1 )
+                    {
+                        bDocNameNoPathMatch = xModel->getURL().copy( lastSlashIndex + 1 ).equals( aURL );
+                        if ( !bDocNameNoPathMatch )
+                        {
+                            rtl::OUString aTmpName = rtl::OUString::createFromAscii("'") + xModel->getURL().copy( lastSlashIndex + 1 ) + rtl::OUString::createFromAscii("'");
+                            bDocNameNoPathMatch = aTmpName.equals( aURL );
+                        }
+                    }
+                } 
+                             
+                if ( aURL.equals( xModel->getURL() ) || bDocNameNoPathMatch )
+                {
+                    pFoundShell = pShell; 
+                    break;
+                }
+            }
+        }
+        pShell = SfxObjectShell::GetNext( *pShell );
+    }
+    return pFoundShell;
+}
+
+// sMod can be empty ( but we really need the library to search in )
+// if sMod is empty and a macro is found then sMod is updated
+bool hasMacro( SfxObjectShell* pShell, const String& sLibrary, String& sMod, const String& sMacro )
+{
+    bool bFound = false;
+    if ( sLibrary.Len() && sMacro.Len() )
+    {
+        OSL_TRACE("** Searching for %s.%s in library %s"
+            ,rtl::OUStringToOString( sMod, RTL_TEXTENCODING_UTF8 ).getStr()
+            ,rtl::OUStringToOString( sMacro, RTL_TEXTENCODING_UTF8 ).getStr()
+            ,rtl::OUStringToOString( sLibrary, RTL_TEXTENCODING_UTF8 ).getStr() );
+        BasicManager* pBasicMgr = pShell-> GetBasicManager();
+        if ( pBasicMgr )
+        {
+            StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+            if ( !pBasic )
+            {
+                USHORT nId = pBasicMgr->GetLibId( sLibrary );
+                pBasicMgr->LoadLib( nId );
+                pBasic = pBasicMgr->GetLib( sLibrary );
+            }
+            if ( pBasic )
+            {
+                if ( sMod.Len() ) // we wish to find the macro is a specific module
+                {
+                    SbModule* pModule = pBasic->FindModule( sMod );
+                    if ( pModule )
+                    {
+                        SbxArray* pMethods = pModule->GetMethods();
+                        if ( pMethods )
+                        {
+                            SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+                            if ( pMethod )
+                              bFound = true;
+                        }
+                    }
+                }
+                else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+                {
+                    if( SbModule* pModule = pMethod->GetModule() )
+                    {
+                        sMod = pModule->GetName();
+                        bFound = true;
+                    }
+                }
+            }
+        }
+    }
+    return bFound;
+}
+void parseMacro( const rtl::OUString& sMacro, String& sContainer, String& sModule, String& sProcedure )
+{
+    sal_Int32 nMacroDot = sMacro.lastIndexOf( '.' );
+    
+    if ( nMacroDot != -1 )
+    {
+        sProcedure = sMacro.copy( nMacroDot + 1 );
+ 
+        sal_Int32 nContainerDot = sMacro.lastIndexOf( '.',  nMacroDot - 1 );
+        if ( nContainerDot != -1 )
+        {
+            sModule = sMacro.copy( nContainerDot + 1, nMacroDot - nContainerDot - 1 );
+            sContainer = sMacro.copy( 0, nContainerDot );
+        }
+        else
+            sModule = sMacro.copy( 0, nMacroDot );
+    }
+    else
+       sProcedure = sMacro;
+}
+
+VBAMacroResolvedInfo resolveVBAMacroImpl( SfxObjectShell* pShell, const rtl::OUString& MacroName, sal_Bool bSearchGlobalTemplates )
+{
+    VBAMacroResolvedInfo aRes;
+    if ( !pShell )
+        return aRes;
+    aRes.SetMacroDocContext( pShell );
+    // parse the macro name
+    sal_Int32 nDocSepIndex = MacroName.indexOfAsciiL( "!", 1 );
+    String sMacroUrl = MacroName;
+
+    String sContainer;
+    String sModule;
+    String sProcedure;
+    
+    if( nDocSepIndex > 0 )
+    {
+        // macro specified by document name
+        // find document shell for document name and call ourselves 
+        // recursively
+
+        // assume for now that the document name is *this* document
+        String sDocUrlOrPath = MacroName.copy( 0, nDocSepIndex );
+        sMacroUrl = MacroName.copy( nDocSepIndex + 1 );
+        OSL_TRACE("doc search, current shell is 0x%x", pShell );
+        SfxObjectShell* pFoundShell = NULL;
+        if( bSearchGlobalTemplates )
+        {
+            SvtPathOptions aPathOpt;
+            String aAddinPath = aPathOpt.GetAddinPath();
+            if( rtl::OUString( sDocUrlOrPath ).indexOf( aAddinPath ) == 0 )
+                pFoundShell = pShell; 
+        }
+        if( pFoundShell == NULL )
+            pFoundShell = findShellForUrl( sDocUrlOrPath );
+        OSL_TRACE("doc search, after find, found shell is 0x%x", pFoundShell );
+        aRes = resolveVBAMacroImpl( pFoundShell, sMacroUrl, bSearchGlobalTemplates ); 
+        return aRes;
+    }    
+    else
+    {
+        // macro is contained in 'this' document ( or code imported from a template
+        // where that template is a global template or perhaps the template this
+        // document is created from ) 
+    
+        // macro format = Container.Module.Procedure
+        parseMacro( MacroName, sContainer, sModule, sProcedure ); 
+        uno::Reference< lang::XMultiServiceFactory> xSF( pShell->GetModel(), uno::UNO_QUERY);
+        uno::Reference< container::XNameContainer > xPrjNameCache;
+        if ( xSF.is() )
+            xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
+    
+        std::vector< rtl::OUString > sSearchList; 
+
+        if ( sContainer.Len() > 0 )
+        { 
+            // get the Project associated with the Container
+            if ( xPrjNameCache.is() )
+            {
+                if ( xPrjNameCache->hasByName( sContainer ) )
+                {
+                    rtl::OUString sProject;
+                    xPrjNameCache->getByName( sContainer ) >>= sProject;
+                    sContainer = sProject;
+                }
+            }
+            sSearchList.push_back( sContainer ); // First Lib to search
+        }
+        else
+        {
+            // Ok, if we have no Container specified then we need to search them in order, this document, template this document created from, global templates, 
+            // get the name of Project/Library for 'this' document
+            rtl::OUString sThisProject = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+            try
+            {
+                uno::Reference< beans::XPropertySet > xProps( pShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< script::XVBACompat > xVBAMode( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BasicLibraries") ) ), uno::UNO_QUERY_THROW );
+                sThisProject = xVBAMode->getProjectName();
+            }
+            catch( uno::Exception& /*e*/) {}
+
+            sSearchList.push_back( sThisProject ); // First Lib to search
+            if ( xPrjNameCache.is() )
+            {
+                // is this document created from a template?
+                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( pShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+                uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+            
+                rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
+                if ( sCreatedFrom.getLength() )
+                {
+                    INetURLObject aObj;
+                    aObj.SetURL( sCreatedFrom );
+                    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+                    rtl::OUString aURL;
+                    if ( bIsURL )
+                        aURL = sCreatedFrom;
+                    else
+                    {
+                        osl::FileBase::getFileURLFromSystemPath( sCreatedFrom, aURL );
+                        aObj.SetURL( aURL );
+                    }        
+                    sCreatedFrom =  aObj.GetLastName();
+                } 
+                
+                sal_Int32 nIndex =  sCreatedFrom.lastIndexOf( '.' );
+                if ( nIndex != -1 )
+                    sCreatedFrom = sCreatedFrom.copy( 0, nIndex );
+        
+                rtl::OUString sPrj;
+                if ( sCreatedFrom.getLength() && xPrjNameCache->hasByName( sCreatedFrom ) )
+                {
+                    xPrjNameCache->getByName( sCreatedFrom ) >>= sPrj;
+                    // Make sure we don't double up with this project
+                    if ( !sPrj.equals( sThisProject ) )
+                        sSearchList.push_back( sPrj );
+                }
+        
+                // get list of global template Names
+                uno::Sequence< rtl::OUString > sTemplateNames = xPrjNameCache->getElementNames();
+                sal_Int32 nLen = sTemplateNames.getLength();
+                for ( sal_Int32 index = 0; ( bSearchGlobalTemplates && index < nLen ); ++index )
+                {
+                    
+                    if ( !sCreatedFrom.equals( sTemplateNames[ index ] ) )
+                    {
+                        if ( xPrjNameCache->hasByName( sTemplateNames[ index ] ) )
+                        {
+                            xPrjNameCache->getByName( sTemplateNames[ index ] ) >>= sPrj;
+                            // Make sure we don't double up with this project
+                            if ( !sPrj.equals( sThisProject ) )
+                                sSearchList.push_back( sPrj );
+                        }
+                    }
+        
+                }
+            }
+        }
+        std::vector< rtl::OUString >::iterator it_end = sSearchList.end();
+        for ( std::vector< rtl::OUString >::iterator it = sSearchList.begin(); it != it_end; ++it )
+        {
+            bool bRes = hasMacro( pShell, *it, sModule, sProcedure );
+            if ( bRes )
+            {
+                aRes.SetResolved( true );
+                aRes.SetMacroDocContext( pShell );
+                sContainer = *it;
+                break;
+            }
+        }
+        aRes.SetResolvedMacro( sProcedure.Insert( '.', 0 ).Insert( sModule, 0).Insert( '.', 0 ).Insert( sContainer, 0 ) );
+    }
+
+    return aRes;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+sal_Bool executeMacroImpl( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet, const uno::Any& aCaller )
+{
+    sal_Bool bRes = sal_False;
+    if ( !pShell )
+        return bRes;
+    rtl::OUString sUrl = makeMacroURLImpl( sMacroName );
+
+    uno::Sequence< sal_Int16 > aOutArgsIndex;
+    uno::Sequence< uno::Any > aOutArgs;
+
+    try
+    {   ErrCode nErr( ERRCODE_BASIC_INTERNAL_ERROR );
+        if ( pShell )
+        {
+            nErr = pShell->CallXScript( sUrl,
+                               aArgs, aRet, aOutArgsIndex, aOutArgs, false, &aCaller ); 
+            sal_Int32 nLen = aOutArgs.getLength();
+            // convert any out params to seem like they were inouts
+            if ( nLen )
+            {
+                for ( sal_Int32 index=0; index < nLen; ++index )
+                {
+                    sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+                    aArgs[ nOutIndex ] = aOutArgs[ index ];
+                }
+            } 
+        }
+        bRes = ( nErr == ERRCODE_NONE );
+    }
+    catch ( uno::Exception& e )
+    {
+       bRes = sal_False;
+    }
+    return bRes; 
+}
+
+SfxObjectShell* getShellFromModel( const uno::Reference< frame::XModel >& rxModel )
+{
+    SfxObjectShell* pFoundShell = NULL;
+    try
+    {
+        uno::Reference< lang::XUnoTunnel >  xObjShellTunnel( rxModel, uno::UNO_QUERY );
+        if ( xObjShellTunnel.is() )
+            pFoundShell = reinterpret_cast<SfxObjectShell*>( xObjShellTunnel->getSomething(SfxObjectShell::getUnoTunnelId()));
+    }
+    catch( uno::Exception& )
+    {
+    }
+    return pFoundShell;
+}
+//wrapper service(s)
+
+class VBAMacroResolvedInfoWrapper : public ::cppu::WeakImplHelper1< script::XVBAMacroResolvedInfo >
+{
+    sal_Bool mbResolved;
+    rtl::OUString msResolvedMacro;
+    uno::Reference< frame::XModel > mxDocCtx;
+    public:
+    VBAMacroResolvedInfoWrapper( const VBAMacroResolvedInfo& rInfo ) : mbResolved( rInfo.IsResolved() ), msResolvedMacro( rInfo.ResolvedMacro() ), mxDocCtx( rInfo.MacroDocContext() ? rInfo.MacroDocContext()->GetModel() : NULL )
+    {
+    }
+    // Attributes
+    virtual ::sal_Bool SAL_CALL getResolved() throw (uno::RuntimeException) { return mbResolved; }
+    virtual void SAL_CALL setResolved( ::sal_Bool _resolved ) throw (uno::RuntimeException){ mbResolved = _resolved; }
+    virtual ::rtl::OUString SAL_CALL getResolvedMacro() throw (uno::RuntimeException) { return msResolvedMacro; }
+    virtual void SAL_CALL setResolvedMacro( const ::rtl::OUString& _resolvedmacro ) throw (uno::RuntimeException) { msResolvedMacro = _resolvedmacro; }
+    virtual uno::Reference< frame::XModel > SAL_CALL getDocumentContext() throw (uno::RuntimeException) { return mxDocCtx; }
+    virtual void SAL_CALL setDocumentContext( const uno::Reference< frame::XModel >& _documentcontext ) throw (uno::RuntimeException) { mxDocCtx = _documentcontext; }
+};
+
+class VBAMacroHelper : public ::cppu::WeakImplHelper1< script::XVBAMacroHelper >
+{
+    
+    public:
+    VBAMacroHelper() {}
+    // Methods
+    virtual ::rtl::OUString SAL_CALL makeMacroURL( const ::rtl::OUString& sMacroName ) throw (uno::RuntimeException);
+    virtual uno::Reference< script::XVBAMacroResolvedInfo > SAL_CALL resolveVBAMacro( const uno::Reference< frame::XModel >& model, const ::rtl::OUString& moduleName, ::sal_Bool bSearchGlobalTemplates ) throw (uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL executeMacro( const uno::Reference< frame::XModel >& model, const ::rtl::OUString& smacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet, const uno::Any& aCaller ) throw (uno::RuntimeException);
+};
+
+::rtl::OUString SAL_CALL 
+VBAMacroHelper::makeMacroURL( const ::rtl::OUString& sMacroName ) throw (uno::RuntimeException)
+{
+    rtl::OUString sMacro = makeMacroURLImpl( sMacroName );
+    return sMacro;
+}
+
+uno::Reference< script::XVBAMacroResolvedInfo > SAL_CALL 
+VBAMacroHelper::resolveVBAMacro( const uno::Reference< frame::XModel >& model, const ::rtl::OUString& moduleName, ::sal_Bool bSearchGlobalTemplates ) throw (uno::RuntimeException)
+{
+    VBAMacroResolvedInfo tmpInfo =  resolveVBAMacroImpl( getShellFromModel( model ), moduleName, bSearchGlobalTemplates );
+    uno::Reference< script::XVBAMacroResolvedInfo > xMacro = new VBAMacroResolvedInfoWrapper( tmpInfo );
+    return xMacro;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+::sal_Bool SAL_CALL 
+VBAMacroHelper::executeMacro( const uno::Reference< frame::XModel >& model, const ::rtl::OUString& smacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& aRet, const uno::Any& aCaller ) throw (uno::RuntimeException)
+{
+    return executeMacroImpl( getShellFromModel( model ), smacroName, aArgs, aRet, aCaller );
+}
+
+uno::Reference< uno::XInterface > SAL_CALL VBAMacroHelper_createInstance(const uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > & /*rSMgr*/ ) throw( uno::Exception )
+{
+    uno::Reference< script::XVBAMacroHelper > xHelper( new  VBAMacroHelper() );
+    return xHelper;
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL VBAMacroHelper_getSupportedServiceNames() throw()
+{
+    uno::Sequence< rtl::OUString > aSupportedServiceNames( 1 );
+    aSupportedServiceNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.VBAMacroHelper" ) );
+    return aSupportedServiceNames;
+}
+
+::rtl::OUString VBAMacroHelper_getImplementationName() throw()
+{
+     return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.VBAMacroHelper" ) );
+}
+
+} // svx
diff --git svx/source/unodraw/msvbahelper.hxx svx/source/unodraw/msvbahelper.hxx
new file mode 100644
index 0000000..59abd2f
--- /dev/null
+++ svx/source/unodraw/msvbahelper.hxx
@@ -0,0 +1,39 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2000, 2010 Oracle and/or its affiliates.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef _MSVBAHELPER_HXX
+#define _MSVBAHELPER_HXX
+
+#include <sfx2/objsh.hxx>
+#include "svx/svxdllapi.h"
+
+namespace svx {
+    SVX_DLLPUBLIC ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL VBAMacroHelper_createInstance(const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > & rSMgr) throw( ::com::sun::star::uno::Exception );
+    SVX_DLLPUBLIC ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL VBAMacroHelper_getSupportedServiceNames() throw();
+    SVX_DLLPUBLIC ::rtl::OUString SAL_CALL VBAMacroHelper_getImplementationName() throw();
+} //svx
+
+#endif
diff --git svx/source/unodraw/unoctabl.cxx svx/source/unodraw/unoctabl.cxx
index 060ab89..6503abc 100644
--- svx/source/unodraw/unoctabl.cxx
+++ svx/source/unodraw/unoctabl.cxx
@@ -40,6 +40,7 @@
 #include "xmlgrhlp.hxx"
 #include "tbunocontroller.hxx"
 #include "tbunosearchcontrollers.hxx"
+#include "msvbahelper.hxx"
 
 using namespace ::com::sun::star;
 using namespace ::rtl;
@@ -274,6 +275,17 @@ static void writeInfo (
         xNewKey->createKey( rServices.getConstArray()[i]);
 }
 
+static void writeSingletonInfo (
+    registry::XRegistryKey * pRegistryKey,
+    const OUString& rImplementationName,
+    const OUString& rSingletonName )
+{
+    uno::Reference< registry::XRegistryKey > xNewKey(
+        pRegistryKey->createKey(
+            OUString(  rImplementationName + OUString( RTL_CONSTASCII_USTRINGPARAM("/UNO/SINGLETONS/") ) + rSingletonName ) ) );
+
+    xNewKey->setStringValue( rImplementationName );
+}
 SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL component_writeInfo (
     void * , void * pRegistryKey)
 {
@@ -288,6 +300,8 @@ SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL component_writeInfo (
             writeInfo( pKey, EnhancedCustomShapeEngine_getImplementationName(), EnhancedCustomShapeEngine_getSupportedServiceNames() );
             writeInfo( pKey, svx::RecoveryUI::st_getImplementationName(), svx::RecoveryUI::st_getSupportedServiceNames() );
             writeInfo( pKey, svx::GraphicExporter_getImplementationName(), svx::GraphicExporter_getSupportedServiceNames() );
+            writeInfo( pKey, svx::VBAMacroHelper_getImplementationName(), svx::VBAMacroHelper_getSupportedServiceNames() );
+            writeSingletonInfo( pKey, svx::VBAMacroHelper_getImplementationName(), rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.theVBAMacroHelper" )  ) );
             writeInfo( pKey, svx::FontHeightToolBoxControl::getImplementationName_Static(), svx::FontHeightToolBoxControl::getSupportedServiceNames_Static() );
 
             writeInfo( pKey, svx::FindTextToolbarController::getImplementationName_Static(), svx::FindTextToolbarController::getSupportedServiceNames_Static() );
@@ -358,6 +372,13 @@ SAL_DLLPUBLIC_EXPORT void * SAL_CALL component_getFactory (
                 svx::GraphicExporter_createInstance,
                 svx::GraphicExporter_getSupportedServiceNames() );
         }
+        else if( svx::VBAMacroHelper_getImplementationName().equalsAscii( pImplName ) )
+        {
+            xFactory = ::cppu::createSingleFactory( reinterpret_cast< lang::XMultiServiceFactory * >( pServiceManager ),
+                svx::VBAMacroHelper_getImplementationName(),
+                svx::VBAMacroHelper_createInstance,
+                svx::VBAMacroHelper_getSupportedServiceNames() );
+        }
         else if ( svx::FontHeightToolBoxControl::getImplementationName_Static().equalsAscii( pImplName ) )
         {
             xFactory = createSingleFactory( reinterpret_cast< lang::XMultiServiceFactory * >( pServiceManager ),
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index bda7b26..622f7e0 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -155,7 +155,6 @@ using namespace nsHdFtFlags;
 #include <com/sun/star/document/XEventsSupplier.hpp>
 #include <com/sun/star/container/XNameReplace.hpp>
 #include <com/sun/star/frame/XModel.hpp>
-#include <filter/msfilter/msvbahelper.hxx>
 #include <unotools/pathoptions.hxx>
 #include <com/sun/star/ucb/XSimpleFileAccess.hpp>
 
diff --git sw/source/ui/vba/vbaeventshelper.cxx sw/source/ui/vba/vbaeventshelper.cxx
index 2c6f212..3008c73 100644
--- sw/source/ui/vba/vbaeventshelper.cxx
+++ sw/source/ui/vba/vbaeventshelper.cxx
@@ -37,7 +37,7 @@
 #include <sfx2/objsh.hxx> 
 #include <comphelper/processfactory.hxx>
 #include <cppuhelper/implbase1.hxx>
-#include <filter/msfilter/msvbahelper.hxx>
+
 #include "wordvbahelper.hxx"
 
 using namespace com::sun::star;
@@ -70,7 +70,11 @@ rtl::OUString
 SwVbaEventsHelper::getMacroPath( const sal_Int32 nEventId )
 {
     String sMacroName = getEventName( nEventId );
-    VBAMacroResolvedInfo sMacroResolvedInfo;
+
+    if ( !m_xMacroHelper.is() )
+        return rtl::OUString(); // failed to get helper singleton, #FIXME can we handle this more elegantly
+    uno::Reference< script::XVBAMacroResolvedInfo > xMacroResolvedInfo;
+
     switch( nEventId )
     {
         // Document events
@@ -79,19 +83,19 @@ SwVbaEventsHelper::getMacroPath( const sal_Int32 nEventId )
     	case VBAEVENT_DOCUMENT_CLOSE:
         {
             sMacroName.Insert( '.', 0 ).Insert( sThisDocument, 0);
-            sMacroResolvedInfo = resolveVBAMacro( pDocShell, sMacroName );
+            xMacroResolvedInfo = m_xMacroHelper->resolveVBAMacro( pDocShell->GetModel(), sMacroName, sal_False );
             break;
         }
     	case VBAEVENT_DOCUMENT_AUTONEW:
     	case VBAEVENT_DOCUMENT_AUTOOPEN:
         {
-            sMacroResolvedInfo = resolveVBAMacro( pDocShell, sMacroName );
+            xMacroResolvedInfo = m_xMacroHelper->resolveVBAMacro( pDocShell->GetModel(), sMacroName, sal_False );
             break;
         }
         default:
             break;
     }
-    return sMacroResolvedInfo.ResolvedMacro();
+    return xMacroResolvedInfo->getResolvedMacro();
 }
 
 sal_Bool SwVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& /*rArgs*/ )
@@ -107,7 +111,7 @@ sal_Bool SwVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno
 	if( sMacroPath.getLength() )
 	{
         // excute the macro
-        result = executeMacro( pDocShell, sMacroPath, aArgs, aRet, aDummyCaller );
+        result = m_xMacroHelper->executeMacro( pDocShell->GetModel(), sMacroPath, aArgs, aRet, aDummyCaller );
 	}
     
 	return result;
diff --git vbahelper/inc/vbahelper/vbaeventshelperbase.hxx vbahelper/inc/vbahelper/vbaeventshelperbase.hxx
index 461cfbc..5f0568f 100644
--- vbahelper/inc/vbahelper/vbaeventshelperbase.hxx
+++ vbahelper/inc/vbahelper/vbaeventshelperbase.hxx
@@ -32,12 +32,15 @@
 
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/script/XVBAMacroHelper.hpp>
+
 #include <map>
 
 class VBAHELPER_DLLPUBLIC VbaEventsHelperBase
 {
 protected:
     css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    css::uno::Reference< css::script::XVBAMacroHelper > m_xMacroHelper;
     sal_Bool mbIgnoreEvents;
     std::map< sal_Int32, rtl::OUString > m_aEventNameMap;
 
diff --git vbahelper/source/msforms/vbacombobox.cxx vbahelper/source/msforms/vbacombobox.cxx
index 5c05894..f7346f4 100644
--- vbahelper/source/msforms/vbacombobox.cxx
+++ vbahelper/source/msforms/vbacombobox.cxx
@@ -26,7 +26,6 @@
  ************************************************************************/
 #include "vbacombobox.hxx"
 #include <vector>
-#include <filter/msfilter/msvbahelper.hxx>
 #include <basic/sbstar.hxx>
 #include <basic/sbmod.hxx>
 
diff --git vbahelper/source/vbahelper/vbaapplicationbase.cxx vbahelper/source/vbahelper/vbaapplicationbase.cxx
index d84f400..94ef0da 100644
--- vbahelper/source/vbahelper/vbaapplicationbase.cxx
+++ vbahelper/source/vbahelper/vbaapplicationbase.cxx
@@ -32,9 +32,10 @@
 #include <com/sun/star/document/XDocumentInfoSupplier.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
+#include <comphelper/processfactory.hxx>
 
 #include "vbacommandbars.hxx"
-#include <filter/msfilter/msvbahelper.hxx>
 
 // start basic includes
 #include <basic/sbx.hxx>
@@ -136,8 +137,9 @@ VbaApplicationBase::getVersion() throw (uno::RuntimeException)
 uno::Any SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const uno::Any& varg1, const uno::Any& varg2, const uno::Any& varg3, const uno::Any& varg4, const uno::Any& varg5, const uno::Any& varg6, const uno::Any& varg7, const uno::Any& varg8, const uno::Any& varg9, const uno::Any& varg10, const uno::Any& varg11, const uno::Any& varg12, const uno::Any& varg13, const uno::Any& varg14, const uno::Any& varg15, const uno::Any& varg16, const uno::Any& varg17, const uno::Any& varg18, const uno::Any& varg19, const uno::Any& varg20, const uno::Any& varg21, const uno::Any& varg22, const uno::Any& varg23, const uno::Any& varg24, const uno::Any& varg25, const uno::Any& varg26, const uno::Any& varg27, const uno::Any& varg28, const uno::Any& varg29, const uno::Any& varg30 ) throw (uno::RuntimeException)
 {
     // search the global tempalte
-    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( getCurrentDocument() ), MacroName, sal_True );
-    if( aMacroInfo.IsResolved() )
+    uno::Reference< script::XVBAMacroHelper > xMacroHelper =  script::theVBAMacroHelper::get( comphelper::getProcessComponentContext() );
+    uno::Reference< script::XVBAMacroResolvedInfo > xMacroInfo = xMacroHelper->resolveVBAMacro( getCurrentDocument(), MacroName, sal_True );
+    if( xMacroInfo->getResolved() )
     {
         // handle the arguments
         const uno::Any* aArgsPtrArray[] = { &varg1, &varg2, &varg3, &varg4, &varg5, &varg6, &varg7, &varg8, &varg9, &varg10, &varg11, &varg12, &varg13, &varg14, &varg15, &varg16, &varg17, &varg18, &varg19, &varg20, &varg21, &varg22, &varg23, &varg24, &varg25, &varg26, &varg27, &varg28, &varg29, &varg30 };
@@ -163,7 +165,7 @@ uno::Any SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, con
 
         uno::Any aRet;
         uno::Any aDummyCaller;
-        executeMacro( aMacroInfo.MacroDocContext(), aMacroInfo.ResolvedMacro(), aArgs, aRet, aDummyCaller );
+        xMacroHelper->executeMacro( xMacroInfo->getDocumentContext(), xMacroInfo->getResolvedMacro(), aArgs, aRet, aDummyCaller );
 
         return aRet;
     }
diff --git vbahelper/source/vbahelper/vbacommandbarcontrol.cxx vbahelper/source/vbahelper/vbacommandbarcontrol.cxx
index 8cb9f49..39ae22d 100644
--- vbahelper/source/vbahelper/vbacommandbarcontrol.cxx
+++ vbahelper/source/vbahelper/vbacommandbarcontrol.cxx
@@ -27,7 +27,8 @@
 #include "vbacommandbarcontrol.hxx"
 #include "vbacommandbarcontrols.hxx"
 #include <vbahelper/vbahelper.hxx>
-#include <filter/msfilter/msvbahelper.hxx>
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
+#include <comphelper/processfactory.hxx>
 
 using namespace com::sun::star;
 using namespace ooo::vba;
@@ -78,10 +79,11 @@ ScVbaCommandBarControl::setOnAction( const ::rtl::OUString& _onaction ) throw (u
 {
     // get the current model
     uno::Reference< frame::XModel > xModel( pCBarHelper->getModel() ); 
-    VBAMacroResolvedInfo aResolvedMacro = ooo::vba::resolveVBAMacro( getSfxObjShell( xModel ), _onaction, true );
-    if ( aResolvedMacro.IsResolved() )
+    uno::Reference< script::XVBAMacroHelper > xMacroHelper =  script::theVBAMacroHelper::get( comphelper::getProcessComponentContext() );
+    uno::Reference< script::XVBAMacroResolvedInfo > xResolvedMacro = xMacroHelper->resolveVBAMacro( xModel, _onaction, sal_True );
+    if ( xResolvedMacro->getResolved() )
     {
-        rtl::OUString aCommandURL = ooo::vba::makeMacroURL( aResolvedMacro.ResolvedMacro() );
+        rtl::OUString aCommandURL = xMacroHelper->makeMacroURL( xResolvedMacro->getResolvedMacro() );
         OSL_TRACE(" ScVbaCommandBarControl::setOnAction: %s", rtl::OUStringToOString( aCommandURL, RTL_TEXTENCODING_UTF8 ).getStr() );
         setPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("CommandURL"), uno::makeAny( aCommandURL ) );
         ApplyChange();
diff --git vbahelper/source/vbahelper/vbaeventshelperbase.cxx vbahelper/source/vbahelper/vbaeventshelperbase.cxx
index 52aba1f..9c331b4 100644
--- vbahelper/source/vbahelper/vbaeventshelperbase.cxx
+++ vbahelper/source/vbahelper/vbaeventshelperbase.cxx
@@ -28,11 +28,19 @@
  *
  ************************************************************************/
 #include <vbahelper/vbaeventshelperbase.hxx>
+#include <com/sun/star/script/theVBAMacroHelper.hpp>
 
 using namespace ::com::sun::star;
 
 VbaEventsHelperBase::VbaEventsHelperBase( const css::uno::Reference< css::uno::XComponentContext >& xContext ) : m_xContext( xContext ), mbIgnoreEvents( sal_False )
 {
+    try
+    {
+        m_xMacroHelper =  script::theVBAMacroHelper::get( m_xContext );
+    }
+    catch( uno::Exception& )
+    {
+    }
 }
 
 void VbaEventsHelperBase::insert( const sal_Int32 nId, const rtl::OUString& sEventName )
