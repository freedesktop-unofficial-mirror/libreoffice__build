diff --git basctl/source/basicide/basides1.cxx basctl/source/basicide/basides1.cxx
index aed5958..3d79067 100644
--- basctl/source/basicide/basides1.cxx
+++ basctl/source/basicide/basides1.cxx
@@ -1201,10 +1201,16 @@ IDEBaseWindow* BasicIDEShell::FindWindow
                 // return any non-suspended window
                 return pWin;
             }
-            else if ( pWin->IsDocument( rDocument ) && pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
+            else if ( pWin->IsDocument( rDocument ) )
+            {
+                OSL_TRACE("FindWindow pWin->GetLibName() %s rLibName %s",
+			rtl::OUStringToOString( pWin->GetLibName(), RTL_TEXTENCODING_UTF8 ).getStr(),
+			rtl::OUStringToOString( rLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( ModulWindow ) %d && nType %d = BASICIDE_TYPE_MODULE %d", pWin->IsA( TYPE( ModulWindow ) ), nType, BASICIDE_TYPE_MODULE );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( DialogWindow ) %d && nType %d = BASICIDE_TYPE_DIALOG %d", pWin->IsA( TYPE( DialogWindow ) ), nType, BASICIDE_TYPE_DIALOG );
+		if (  pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
                       ( ( pWin->IsA( TYPE( ModulWindow ) )  && nType == BASICIDE_TYPE_MODULE ) ||
                         ( pWin->IsA( TYPE( DialogWindow ) ) && nType == BASICIDE_TYPE_DIALOG ) ) )
-            {
                 return pWin;
             }
         }
diff --git basctl/source/basicide/basides2.cxx basctl/source/basicide/basides2.cxx
index 76dcea0..90cec19 100644
--- basctl/source/basicide/basides2.cxx
+++ basctl/source/basicide/basides2.cxx
@@ -251,9 +251,12 @@ ModulWindow* BasicIDEShell::CreateBasWin
 
         if ( bSuccess )
         {
-			// new module window
-			pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
-			nKey = InsertWindowInTable( pWin );
+			pWin = FindBasWin( rDocument, aLibName, aModName, FALSE, TRUE );
+            if( !pWin )
+			{    // new module window
+			    pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
+			    nKey = InsertWindowInTable( pWin );
+            }
         }
 	}
 	else
@@ -268,7 +271,8 @@ ModulWindow* BasicIDEShell::CreateBasWin
 		}
 		DBG_ASSERT( nKey, "CreateBasWin: Kein Key- Fenster nicht gefunden!" );
 	}
-	pTabBar->InsertPage( (USHORT)nKey, aModName );
+    if( nKey )
+	    pTabBar->InsertPage( (USHORT)nKey, aModName );
 	pTabBar->Sort();
 	pWin->GrabScrollBars( &aHScrollBar, &aVScrollBar );
 	if ( !pCurWin )
diff --git basctl/source/basicide/basidesh.cxx basctl/source/basicide/basidesh.cxx
index 03459cc..d921d99 100644
--- basctl/source/basicide/basidesh.cxx
+++ basctl/source/basicide/basidesh.cxx
@@ -80,6 +80,9 @@
 #include <com/sun/star/script/XLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/container/XContainerListener.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 
 #include <svx/xmlsecctrl.hxx>
 
@@ -87,6 +90,71 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
+static const rtl::OUString sStandardLibName(  rtl::OUString::createFromAscii("Standard") );
+
+typedef ::cppu::WeakImplHelper1< container::XContainerListener > ContainerListenerBASE;
+
+class ContainerListenerImpl : public ContainerListenerBASE
+{
+    BasicIDEShell* mpShell;
+public:
+
+    ContainerListenerImpl( BasicIDEShell* pShell ) : mpShell( pShell ) {}
+
+    ~ContainerListenerImpl() 
+    {
+    }
+
+    void addContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument() && xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+                xContainer->addContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+    void removeContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument(), xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+               xContainer->removeContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& ) throw( uno::RuntimeException ) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& Event ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell && ( Event.Accessor >>= sModuleName ) )
+            mpShell->FindBasWin( mpShell->m_aCurDocument, sStandardLibName, sModuleName, TRUE, FALSE );
+    }
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& ) throw( com::sun::star::uno::RuntimeException ) { }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& Event ) throw( com::sun::star::uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell  && ( Event.Accessor >>= sModuleName ) )
+        {
+            IDEBaseWindow* pWin = mpShell->FindWindow( mpShell->m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+            if( pWin )
+                mpShell->RemoveWindow( pWin, FALSE, TRUE );
+        }
+    }
+
+};
 
 TYPEINIT1( BasicIDEShell, SfxViewShell );
 
@@ -124,6 +192,7 @@ BasicIDEShell::BasicIDEShell( SfxViewFra
         m_bAppBasicModified( FALSE ),
         m_aNotifier( *this )
 {
+    m_xLibListener = new ContainerListenerImpl( this );
 	Init();
     GnBasicIDEShellCount++;
 }
@@ -215,6 +284,12 @@ __EXPORT BasicIDEShell::~BasicIDEShell()
 	delete pTabBar;
 	delete pObjectCatalog;
 	DestroyModulWindowLayout();
+
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        // Destroy all ContainerListeners for Basic Container.
+        if ( pListener )
+            pListener->removeContainerListener( m_aCurDocument );
+    
 	// MI: Das gab einen GPF im SDT beim Schliessen da dann der ViewFrame die
 	// ObjSh loslaesst. Es wusste auch keiner mehr wozu das gut war.
 	// GetViewFrame()->GetObjectShell()->Broadcast( SfxSimpleHint( SFX_HINT_DYING ) );
@@ -935,7 +1010,15 @@ void BasicIDEShell::SetCurLib( const Scr
 {
     if ( !bCheck || ( rDocument != m_aCurDocument || aLibName != m_aCurLibName ) )
     {
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        if ( pListener )
+        	pListener->removeContainerListener( m_aCurDocument );
+
         m_aCurDocument = rDocument;
+
+        if ( pListener )
+            pListener->addContainerListener( m_aCurDocument );
+
         m_aCurLibName = aLibName;
         if ( bUpdateWindows )
             UpdateWindows();
diff --git basctl/source/basicide/scriptdocument.cxx basctl/source/basicide/scriptdocument.cxx
index fbe3f67..7e48d82 100644
--- basctl/source/basicide/scriptdocument.cxx
+++ basctl/source/basicide/scriptdocument.cxx
@@ -56,6 +56,7 @@
 #include <com/sun/star/frame/XModel2.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <sfx2/objsh.hxx>
@@ -142,6 +143,7 @@ namespace basctl
     using ::com::sun::star::uno::RuntimeException;
     using ::com::sun::star::document::XEventBroadcaster;
     using ::com::sun::star::document::XEmbeddedScripts;
+    using ::com::sun::star::script::ModuleInfo;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
     namespace FrameSearchFlag = ::com::sun::star::frame::FrameSearchFlag;
@@ -674,6 +676,15 @@ namespace basctl
             }
 
 		    // insert element by new name in container
+            if ( _eType == E_SCRIPTS )
+            {
+                ModuleInfo sModuleInfo;
+                if ( aElement >>= sModuleInfo )
+                {
+                    sModuleInfo.ModuleName = _rNewName;
+                    aElement <<= sModuleInfo;
+                }
+            }
 		    xLib->insertByName( _rNewName, aElement );
             return true;
         }
@@ -738,8 +749,16 @@ namespace basctl
             Reference< XNameContainer > xLib( getOrCreateLibrary( E_SCRIPTS, _rLibName ), UNO_QUERY_THROW );
 	        if ( !xLib->hasByName( _rModName ) )
                 return false;
-
-            xLib->replaceByName( _rModName, makeAny( _rModuleCode ) );
+            ModuleInfo mInfo;
+            Any aMod;
+            if ( xLib->getByName( _rModName ) >>= mInfo )
+            {
+                mInfo.ModuleSource = _rModuleCode;
+                aMod <<= mInfo;
+            }
+            else
+                aMod <<= _rModuleCode;
+            xLib->replaceByName( _rModName, aMod );
             return true;
         }
         catch( const Exception& )
@@ -1392,7 +1411,15 @@ namespace basctl
         Any aCode;
         if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
             return false;
-        OSL_VERIFY( aCode >>= _out_rModuleSource );
+        ModuleInfo sModuleInfo;
+        if ( aCode >>= sModuleInfo )
+        {
+            _out_rModuleSource = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            OSL_VERIFY( aCode >>= _out_rModuleSource );
+        }
         return true;
     }
 
diff --git basctl/source/inc/basidesh.hxx basctl/source/inc/basidesh.hxx
index 6b3690c..3919bd9 100644
--- basctl/source/inc/basidesh.hxx
+++ basctl/source/inc/basidesh.hxx
@@ -49,6 +49,7 @@
 #include <com/sun/star/io/XInputStreamProvider.hpp>
 #endif
 
+#include <com/sun/star/container/XContainerListener.hpp>
 
 //----------------------------------------------------------------------------
 
@@ -107,6 +108,8 @@ friend bool BasicIDE::RemoveDialog( cons
     BOOL                m_bAppBasicModified;
     ::basctl::DocumentEventNotifier
                         m_aNotifier;
+friend class ContainerListenerImpl;
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XContainerListener > m_xLibListener;
 
 #if _SOLAR__PRIVATE
 	void				Init();
diff --git basic/inc/basic/sbmod.hxx basic/inc/basic/sbmod.hxx
index 122a664..e676a49 100644
--- basic/inc/basic/sbmod.hxx
+++ basic/inc/basic/sbmod.hxx
@@ -37,7 +37,7 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
-
+#include <com/sun/star/script/ModuleType.hpp>
 class SbMethod;
 class SbProperty;
 class SbiRuntime;
@@ -67,6 +67,9 @@ protected:
 	SbiBreakpoints*	pBreaks;			// Breakpoints
 	SbClassData*	pClassData;
 	bool mbVBACompat;
+	INT32 mnType; 
+	SbxObjectRef pDocObject; // an impl object ( used by Document Modules )
+	bool 	bIsProxyModule;
 
 	void			StartDefinitions();
 	SbMethod*		GetMethod( const String&, SbxDataType );
@@ -91,7 +94,7 @@ protected:
 public:
 	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASICMOD,2);
 	TYPEINFO();
-					SbModule( const String& );
+					SbModule( const String&, bool bCompat = false );
 	virtual void	SetParent( SbxObject* );
 	virtual void 	Clear();
 
@@ -127,8 +130,12 @@ public:
 	BOOL LoadBinaryData( SvStream& );
 	BOOL ExceedsLegacyModuleSize();
 	void fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg = NULL ) const;
-        bool IsVBACompat() { return mbVBACompat; }
         bool HasExeCode();
+        bool IsVBACompat();
+        void SetVBACompat( bool bCompat );
+        INT32 GetModuleType() { return mnType; }
+        void SetModuleType( INT32 nType ) { mnType = nType; }
+	bool GetIsProxyModule() { return bIsProxyModule; }
 };
 
 #ifndef __SB_SBMODULEREF_HXX
diff --git basic/inc/basic/sbobjmod.hxx basic/inc/basic/sbobjmod.hxx
new file mode 100644
index 0000000..cb581c1
--- /dev/null
+++ basic/inc/basic/sbobjmod.hxx
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+
+namespace css = ::com::sun::star;
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+public:
+    TYPEINFO();
+    SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    SbxVariable* GetObject();
+    void SetUnoObject( const com::sun::star::uno::Any& aObj )throw ( com::sun::star::uno::RuntimeException ) ;
+};
+
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
diff --git basic/inc/basic/sbstar.hxx basic/inc/basic/sbstar.hxx
index ebd10ae..3c7e149 100644
--- basic/inc/basic/sbstar.hxx
+++ basic/inc/basic/sbstar.hxx
@@ -40,6 +40,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // fertiges Modul
 class SbiInstance;                  // Laufzeit-Instanz
@@ -71,6 +72,7 @@ class StarBASIC : public SbxObject
 	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
 	BOOL			bBreak;				// TRUE: Break, sonst Step
 	BOOL			bDocBasic;
+    BOOL            bVBAEnabled;
 	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
 protected:
@@ -113,7 +115,8 @@ public:
 
 	// Compiler-Interface
 	SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const com::sun::star::script::ModuleInfo& mInfo );
 	BOOL			Compile( SbModule* );
 	BOOL 			Disassemble( SbModule*, String& rText );
 	static void 	Stop();
@@ -185,6 +188,8 @@ public:
 					( const String& rName, USHORT& rStatus );
 	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
 	static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
 	// #60175 TRUE: SFX-Resource wird bei Basic-Fehlern nicht angezogen
 	static void StaticSuppressSfxResource( BOOL bSuppress );
diff --git basic/source/basmgr/basmgr.cxx basic/source/basmgr/basmgr.cxx
index 73eb4cb..1c8962c 100644
--- basic/source/basmgr/basmgr.cxx
+++ basic/source/basmgr/basmgr.cxx
@@ -44,6 +44,7 @@
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
 #include <basic/sbmod.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include <basic/sbuno.hxx>
 #include <basic/basmgr.hxx>
@@ -67,6 +68,8 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -243,9 +246,18 @@ void BasMgrContainerListenerImpl::addLib
 		{
 			::rtl::OUString aModuleName = pNames[ j ];
 			Any aElement = xLibNameAccess->getByName( aModuleName );
-			::rtl::OUString aMod;
-			aElement >>= aMod;
-			pLib->MakeModule32( aModuleName, aMod );
+            ModuleInfo mInfo;
+            if ( aElement >>= mInfo )
+            {
+                OSL_TRACE("#addLibraryModulesImpl - aMod");
+                pLib->MakeModule32( mInfo );
+            }
+            else
+            {
+			    ::rtl::OUString aMod;
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
 		}
 	}
 
@@ -282,8 +294,6 @@ void SAL_CALL BasMgrContainerListenerImp
 	}
 	else
 	{
-		::rtl::OUString aMod;
-		Event.Element >>= aMod;
 
 		StarBASIC* pLib = mpMgr->GetLib( maLibName );
 		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -292,7 +302,17 @@ void SAL_CALL BasMgrContainerListenerImp
     		SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-			    pLib->MakeModule32( aName, aMod );
+                ModuleInfo mInfo;
+                if( Event.Element >>= mInfo )
+                {
+                    pLib->MakeModule32( mInfo );
+                }
+                else
+                {
+        		    ::rtl::OUString aMod;
+        		    Event.Element >>= aMod;
+			        pLib->MakeModule32( aName, aMod );
+                }
 			    pLib->SetModified( FALSE );
             }
 		}
@@ -316,15 +336,35 @@ void SAL_CALL BasMgrContainerListenerImp
     DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
 
 	StarBASIC* pLib = mpMgr->GetLib( maLibName );
+    
 	if( pLib )
 	{
-		SbModule* pMod = pLib->FindModule( aName );
+	    SbModule* pMod = pLib->FindModule( aName );
 		::rtl::OUString aMod;
-		Event.Element >>= aMod;
+        ModuleInfo mInfo;
+        if( Event.Element >>= mInfo )
+			aMod = mInfo.ModuleSource;
+        else 
+            Event.Element >>= aMod;
 		if( pMod )
+		{
 			pMod->SetSource32( aMod );
-		else
-			pLib->MakeModule32( aName, aMod );
+			if ( mInfo.ModuleType == ModuleType::Document )
+			{
+				SbObjModule* pObjModule = dynamic_cast< SbObjModule* >( pMod );
+				if ( pObjModule )	
+					pObjModule->SetUnoObject( makeAny( mInfo.ModuleObject ) );
+			}
+		}
+        else
+			// Probably we should have an assert for
+			// unknow module type, e.g. either we are using
+			// the ModuleInfo structure ( vba ) for *all* modules
+			// or not ( normal )
+			if ( mInfo.ModuleType == ModuleType::Unknown )
+				pLib->MakeModule32( aName, aMod );
+			else
+				pLib->MakeModule32( mInfo );
 
 		pLib->SetModified( FALSE );
 	}
diff --git basic/source/classes/sb.cxx basic/source/classes/sb.cxx
index f65c6ca..5226d3f 100644
--- basic/source/classes/sb.cxx
+++ basic/source/classes/sb.cxx
@@ -52,12 +52,17 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
 #include <basrid.hxx>
 #include <vos/mutex.hxx>
 
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+using namespace ::com::sun::star::script;
+
 // #pragma SW_SEGMENT_CLASS( SBASIC, SBASIC_CODE )
 
 SV_IMPL_VARARR(SbTextPortions,SbTextPortion)
@@ -249,6 +254,8 @@ SbxObject* SbiFactory::CreateObject( con
 	else
 	if( rClass.EqualsIgnoreCaseAscii( "Collection" ) )
 	{
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
 		String aCollectionName( RTL_CONSTASCII_USTRINGPARAM("Collection") );
 		return new BasicCollection( aCollectionName );
 	}
@@ -446,6 +453,7 @@ SbClassModuleObject::SbClassModuleObject
 			}
 		}
 	}
+	SetModuleType( com::sun::star::script::ModuleType::Class );
 }
 
 SbClassModuleObject::~SbClassModuleObject()
@@ -581,6 +589,7 @@ StarBASIC::StarBASIC( StarBASIC* p, BOOL
 	SetParent( p );
 	pLibInfo = NULL;
 	bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
 	pModules = new SbxArray;
 
 	if( !GetSbData()->nInst++ )
@@ -683,12 +692,38 @@ SbModule* StarBASIC::MakeModule( const S
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-	SbModule* p = new SbModule( rName );
-	p->SetSource32( rSrc );
+    ModuleInfo mInfo;
+    mInfo.ModuleSource = rSrc;
+    mInfo.ModuleType = ModuleType::Normal;
+    mInfo.ModuleName = rName;
+    return MakeModule32(  mInfo );
+}
+SbModule* StarBASIC::MakeModule32( const ModuleInfo& mInfo )
+{
+    
+    OSL_TRACE("create module %s type mInfo %d", rtl::OUStringToOString( mInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr(), mInfo.ModuleType );
+    SbModule* p = NULL;
+    switch ( mInfo.ModuleType )
+    {
+        case ModuleType::Document:
+            // In theory we should be able to create Object modules
+            // in ordinary basic ( in vba mode thought these are create
+            // by the application/basic and not by the user )
+            p = new SbObjModule( mInfo, isVBAEnabled() );
+            break;
+        case ModuleType::Class:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+			p->SetModuleType( com::sun::star::script::ModuleType::Class );	
+	    break;
+        default:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+            
+    }
+	p->SetSource32( mInfo.ModuleSource );
 	p->SetParent( this );
 	pModules->Insert( p, pModules->Count() );
 	SetModified( TRUE );
-	return p;
+    return p;
 }
 
 void StarBASIC::Insert( SbxVariable* pVar )
@@ -862,6 +897,12 @@ SbxVariable* StarBASIC::Find( const Stri
 				}
 				pNamed = p;
 			}
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
+			INT32 nType = p->GetModuleType();
+            //if ( nType == com::sun::star::script::ModuleType::Class || nType == com::sun::star::script::ModuleType::Document )
+            if ( nType == com::sun::star::script::ModuleType::Document )
+                continue;
 			// Sonst testen, ob das Element vorhanden ist
 			// GBLSEARCH-Flag rausnehmen (wg. Rekursion)
 			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index 42c4536..8ea4b64 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -51,6 +51,8 @@
 #include <basic/hilight.hxx>
 #include <basic/basrdll.hxx>
 #include <vos/mutex.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 // for the bsearch
 #ifdef WNT
@@ -65,6 +67,17 @@
 
 #include <stdio.h>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/awt/XDialogProvider.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <comphelper/anytostring.hxx>
+
+using namespace ::com::sun::star; 
 
 TYPEINIT1(SbModule,SbxObject)
 TYPEINIT1(SbMethod,SbxMethod)
@@ -72,6 +85,7 @@ TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -221,12 +235,13 @@ extern "C" int CDECL compare_strings( co
 // Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
 // Elemente von anderen Modulen aus gefunden werden koennen.
 
-SbModule::SbModule( const String& rName )
+SbModule::SbModule( const String& rName, bool bVBACompat )
 		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( false )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( bVBACompat ),  pDocObject( NULL ), bIsProxyModule( false )
 {
 	SetName( rName );
 	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	SetModuleType( com::sun::star::script::ModuleType::Normal );
 }
 
 SbModule::~SbModule()
@@ -401,7 +416,10 @@ void SbModule::Clear()
 
 SbxVariable* SbModule::Find( const XubString& rName, SbxClassType t )
 {
+	// make sure a search in an uninstatiated class module will fail
 	SbxVariable* pRes = SbxObject::Find( rName, t );
+	if ( bIsProxyModule )
+		return NULL;
 	if( !pRes && pImage )
 	{
 		SbiInstance* pInst = pINST;
@@ -561,6 +579,7 @@ void SbModule::SetSource32( const ::rtl:
 	aOUSource = r;
 	StartDefinitions();
 	SbiTokenizer aTok( r );
+        aTok.SetCompatible( IsVBACompat() );
 	while( !aTok.IsEof() )
 	{
 		SbiToken eEndTok = NIL;
@@ -585,14 +604,6 @@ void SbModule::SetSource32( const ::rtl:
 				{
 					eEndTok = ENDPROPERTY; break;
 				}
-				if( eCurTok == OPTION )
-				{
-					eCurTok = aTok.Next();
-					mbVBACompat = ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 );
-					if( eCurTok == COMPATIBLE 
-					|| mbVBACompat )
-						aTok.SetCompatible( true );
-				}
 			}
 			eLastTok = eCurTok;
 		}
@@ -731,10 +742,19 @@ void ClearUnoObjectsInRTL_Impl( StarBASI
     if( ((StarBASIC*)p) != pBasic )
 	    ClearUnoObjectsInRTL_Impl_Rek( (StarBASIC*)p );
 }
+bool SbModule::IsVBACompat()
+{
+	return mbVBACompat;
+}
 
+void SbModule::SetVBACompat( bool bCompat )
+{
+	mbVBACompat = bCompat;
+}
 // Ausfuehren eines BASIC-Unterprogramms
 USHORT SbModule::Run( SbMethod* pMeth )
 {
+	OSL_TRACE("About to run %s, vba compatmode is %d", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), mbVBACompat );
 	static USHORT nMaxCallLevel = 0;
 	static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
 	static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
@@ -826,10 +846,10 @@ USHORT SbModule::Run( SbMethod* pMeth )
 			if( pRt->pNext )
 				pRt->pNext->block();
 			pINST->pRun = pRt;
-			if ( SbiRuntime ::isVBAEnabled() )
+			if ( mbVBACompat )
                         {
 				pINST->EnableCompatibility( TRUE );
-				pRt->SetVBAEnabled( true );
+				//pRt->SetVBAEnabled( true ); // can we get rid of this
                         }
 			while( pRt->Step() ) {}
 			if( pRt->pNext )
@@ -1404,7 +1424,6 @@ BOOL SbModule::LoadBinaryData( SvStream&
     return bRet;
 }
 
-
 BOOL SbModule::LoadCompleted()
 {
 	SbxArray* p = GetMethods();
@@ -2207,6 +2226,53 @@ SbJScriptMethod::~SbJScriptMethod()
 
 
 /////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible )
+    : SbModule( mInfo.ModuleName, bIsVbaCompatible )
+{
+    SetModuleType( mInfo.ModuleType );
+    if ( mInfo.ModuleType == script::ModuleType::Form )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Form" ) );
+    }
+    else if ( mInfo.ModuleObject.is() )
+        SetUnoObject( uno::makeAny( mInfo.ModuleObject ) );
+}
+void
+SbObjModule::SetUnoObject( const uno::Any& aObj ) throw ( uno::RuntimeException )
+{
+    SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxVariable*)pDocObject);
+    if ( pUnoObj && pUnoObj->getUnoAny() == aObj ) // object is equal, nothing to do
+        return;
+    pDocObject = new SbUnoObject( GetName(), uno::makeAny( aObj ) );
+            
+    com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObj, com::sun::star::uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Worksheet" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
+    }
+    else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Workbook" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
+    }
+}
+
+SbxVariable*
+SbObjModule::GetObject() 
+{
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    //OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+        pVar = pDocObject->Find( rName, t );
+    if ( !pVar )
+        pVar = SbModule::Find( rName, t );
+    return pVar;
+}
+/////////////////////////////////////////////////////////////////////////
 
 SbProperty::SbProperty( const String& r, SbxDataType t, SbModule* p )
 		: SbxProperty( r, t ), pMod( p )
diff --git basic/source/comp/codegen.cxx basic/source/comp/codegen.cxx
index 9f88fb6..4674134 100644
--- basic/source/comp/codegen.cxx
+++ basic/source/comp/codegen.cxx
@@ -130,12 +130,12 @@ void SbiCodeGen::Save()
 	// OPTION EXPLICIT-Flag uebernehmen
 	if( pParser->bExplicit )
 		p->SetFlag( SBIMG_EXPLICIT );
-	if( pParser->IsVBASupportOn() )
-		p->SetFlag( SBIMG_VBASUPPORT );
 	
 	int nIfaceCount = 0;
-	if( pParser->bClassModule )
+	if( rMod.mnType == com::sun::star::script::ModuleType::Class )
 	{
+                OSL_TRACE("COdeGen::save() classmodule processing");
+		rMod.bIsProxyModule = true;
 		p->SetFlag( SBIMG_CLASSMODULE );
 		pCLASSFAC->AddClassModule( &rMod );
 
@@ -158,6 +158,10 @@ void SbiCodeGen::Save()
 	else
 	{
 		pCLASSFAC->RemoveClassModule( &rMod );
+		// Only a ClassModule can revert to Normal
+                if ( rMod.mnType == com::sun::star::script::ModuleType::Class )
+			rMod.mnType = com::sun::star::script::ModuleType::Normal;
+		rMod.bIsProxyModule = false;
 	}
 	if( pParser->bText )
 		p->SetFlag( SBIMG_COMPARETEXT );
@@ -240,6 +244,8 @@ void SbiCodeGen::Save()
 					if( nPass == 1 )
 						aPropName = aPropName.Copy( aIfaceName.Len() + 1 );
 					SbProcedureProperty* pProcedureProperty = NULL;
+                                        OSL_TRACE("*** getProcedureProperty for thing %s",
+						rtl::OUStringToOString( aPropName,RTL_TEXTENCODING_UTF8 ).getStr() );
 					pProcedureProperty = rMod.GetProcedureProperty( aPropName, ePropType );
 				}
 				if( nPass == 1 )
diff --git basic/source/comp/parser.cxx basic/source/comp/parser.cxx
index 3259f77..1a4dc06 100644
--- basic/source/comp/parser.cxx
+++ basic/source/comp/parser.cxx
@@ -145,7 +145,8 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 	bNewGblDefs =
 	bSingleLineIf =
 	bExplicit = FALSE;
-	bClassModule = FALSE;
+	bClassModule = ( pm->GetModuleType() == com::sun::star::script::ModuleType::Class );
+	OSL_TRACE("Parser - %s, bClassModule %d", rtl::OUStringToOString( pm->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), bClassModule );
 	pPool	 = &aPublics;
 	for( short i = 0; i < 26; i++ )
 		eDefTypes[ i ] = SbxVARIANT;    // Kein expliziter Defaulttyp
@@ -158,6 +159,10 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 
 	rTypeArray = new SbxArray; // Array fuer Benutzerdefinierte Typen
 	rEnumArray = new SbxArray; // Array for Enum types
+	bVBASupportOn = pm->IsVBACompat();
+	if ( bVBASupportOn )
+		EnableCompatibility();
+
 }
 
 
@@ -778,8 +783,9 @@ void SbiParser::Option()
 
 		case CLASSMODULE:
 			bClassModule = TRUE; 
+			aGen.GetModule().SetModuleType( com::sun::star::script::ModuleType::Class );
 			break;
-		case VBASUPPORT:
+		case VBASUPPORT: // Option VBASupport used to override the module mode ( in fact this must reset the mode
 			if( Next() == NUMBER )
 			{
 				if ( nVal == 1 || nVal == 0 )
@@ -787,6 +793,10 @@ void SbiParser::Option()
 					bVBASupportOn = ( nVal == 1 );
 					if ( bVBASupportOn )
 						EnableCompatibility();
+					// if the module setting is different
+					// reset it to what the Option tells us
+					if ( bVBASupportOn != aGen.GetModule().IsVBACompat() )
+						aGen.GetModule().SetVBACompat( bVBASupportOn );
 					break;
 				}
 			}
diff --git basic/source/inc/codegen.hxx basic/source/inc/codegen.hxx
index ad11d02..a054af7 100644
--- basic/source/inc/codegen.hxx
+++ basic/source/inc/codegen.hxx
@@ -56,6 +56,7 @@ public:
 	void GenStmnt();			// evtl. Statement-Opcode erzeugen
 	UINT32 GetPC();
 	UINT32 GetOffset()				{ return GetPC() + 1; }
+    SbModule& GetModule() { return rMod; } 
 	void Save();
 
 	// #29955 for-Schleifen-Ebene pflegen
diff --git basic/source/inc/image.hxx basic/source/inc/image.hxx
index 8a454cf..c371a85 100644
--- basic/source/inc/image.hxx
+++ basic/source/inc/image.hxx
@@ -109,6 +109,5 @@ public:
 #define	SBIMG_COMPARETEXT	0x0002	// OPTION COMPARE TEXT ist aktiv
 #define	SBIMG_INITCODE		0x0004	// Init-Code vorhanden
 #define	SBIMG_CLASSMODULE	0x0008	// OPTION ClassModule is active
-#define	SBIMG_VBASUPPORT	0x0020	// OPTION VBASupport is 1
 
 #endif
diff --git basic/source/runtime/methods1.cxx basic/source/runtime/methods1.cxx
index e72f78b..bb24705 100644
--- basic/source/runtime/methods1.cxx
+++ basic/source/runtime/methods1.cxx
@@ -44,6 +44,7 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#include <basic/sbstar.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/fsys.hxx>
 #include <tools/urlobj.hxx>
@@ -64,6 +65,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -2594,14 +2596,14 @@ RTLFUNC(Me)
 
 	SbModule* pActiveModule = pINST->GetActiveModule();
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
+    SbxVariableRef refVar = rPar.Get(0);
 	if( pClassModuleObject == NULL )
 	{
-		StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod )
+            refVar->PutObject( pMod );
 	}
 	else
-	{
-		SbxVariableRef refVar = rPar.Get(0);
 		refVar->PutObject( pClassModuleObject );
-	}
 }
 
diff --git basic/source/runtime/runtime.cxx basic/source/runtime/runtime.cxx
index a51624b..5cec3e2 100644
--- basic/source/runtime/runtime.cxx
+++ basic/source/runtime/runtime.cxx
@@ -53,7 +53,8 @@ bool SbiRuntime::isVBAEnabled()
 	bool result = false;
 	SbiInstance* pInst = pINST;
 	if ( pInst && pINST->pRun )
-		result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		//result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		result = pInst->pRun->bVBAEnabled;
 	return result; 
 }
 
@@ -64,6 +65,24 @@ void StarBASIC::StaticEnableReschedule( 
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    if ( bDocBasic )
+    {
+        bVBAEnabled = bEnabled;
+    }
+}
+
+BOOL StarBASIC::isVBAEnabled()
+{
+    if ( bDocBasic )
+    { 
+        if( SbiRuntime::isVBAEnabled() )
+            return TRUE;
+        return bVBAEnabled;
+    }
+    return FALSE;
+}
 
 
 struct SbiArgvStack {					// Argv stack:
@@ -520,6 +539,7 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 	nForLvl   = 0;
 	nOps	  = 0;
 	refExprStk = new SbxArray;
+	SetVBAEnabled( pMod->IsVBACompat() );
 #if defined GCC
 	SetParameters( pe ? pe->GetParameters() : (class SbxArray *)NULL );
 #else
@@ -527,7 +547,6 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
-	bVBAEnabled = isVBAEnabled();
 }
 
 SbiRuntime::~SbiRuntime()
diff --git basic/source/uno/namecont.cxx basic/source/uno/namecont.cxx
index d96a569..da495ca 100644
--- basic/source/uno/namecont.cxx
+++ basic/source/uno/namecont.cxx
@@ -76,6 +76,9 @@
 #include <cppuhelper/exc_hlp.hxx>
 #include <basic/sbmod.hxx>
 
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 namespace basic
 {
@@ -155,7 +158,7 @@ void NameContainer::replaceByName( const
 	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -197,7 +200,7 @@ void NameContainer::insertByName( const 
 	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
diff --git basic/source/uno/scriptcont.cxx basic/source/uno/scriptcont.cxx
index f47dc64..4a46e98 100644
--- basic/source/uno/scriptcont.cxx
+++ basic/source/uno/scriptcont.cxx
@@ -214,7 +214,12 @@ void SAL_CALL SfxScriptLibraryContainer:
 	xmlscript::ModuleDescriptor aMod;
 	aMod.aName = aElementName;
 	aMod.aLanguage = maScriptLanguage;
-	aElement >>= aMod.aCode;
+	// make sure we export source
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		aMod.aCode = mInfo.ModuleSource;
+	else
+		aElement >>= aMod.aCode;
 	xmlscript::exportScriptModule( xHandler, aMod );
 }
 
@@ -1171,7 +1176,11 @@ void SfxScriptLibrary::storeResourcesToS
 bool SfxScriptLibrary::containsValidModule( const Any& aElement )
 {
 	OUString sModuleText;
-	aElement >>= sModuleText;
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		sModuleText = mInfo.ModuleSource;
+	else
+		aElement >>= sModuleText;
 	return ( sModuleText.getLength() > 0 );
 }
 
diff --git sc/inc/servuno.hxx sc/inc/servuno.hxx
index c93cdb3..73fdec1 100644
--- sc/inc/servuno.hxx
+++ sc/inc/servuno.hxx
@@ -93,8 +93,8 @@ class ScDocShell;
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
-
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
diff --git sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
index 0df678a..aff8877 100644
--- sc/source/filter/excel/excimp8.cxx
+++ sc/source/filter/excel/excimp8.cxx
@@ -103,6 +103,7 @@
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 
 using namespace com::sun::star;
@@ -110,8 +111,8 @@ using namespace com::sun::star;
 
 #define	INVALID_POS		0xFFFFFFFF
 
-
-
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
     ImportExcel( rImpData, rStrm ), mnTab(0)
@@ -273,6 +274,7 @@ bool lcl_hasVBAEnabled()
 
 void ImportExcel8::ReadBasic( void )
 {
+    //bHasBasic = TRUE;
     bHasBasic = TRUE;
 
     SfxObjectShell* pShell = GetDocShell();
@@ -302,6 +304,10 @@ void ImportExcel8::EndSheet( void )
 
 void ImportExcel8::PostDocLoad( void )
 {
+    // delay reading basic until sheet object ( codenames etc. ) are read
+
+    if ( bHasBasic ) 
+        ReadBasic();
     // #i11776# filtered ranges before outlines and hidden rows
     if( pExcRoot->pAutoFilterBuffer )
         pExcRoot->pAutoFilterBuffer->Apply();
diff --git sc/source/ui/docshell/docsh5.cxx sc/source/ui/docshell/docsh5.cxx
index 62c11ca..22f163d 100644
--- sc/source/ui/docshell/docsh5.cxx
+++ sc/source/ui/docshell/docsh5.cxx
@@ -68,6 +68,10 @@
 #include "sc.hrc"
 #include "waitoff.hxx"
 #include "sizedev.hxx"
+#include <basic/sbstar.hxx>
+
+// defined in docfunc.cxx
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sModuleSource );
 
 // ---------------------------------------------------------------------------
 
@@ -832,6 +836,33 @@ BOOL ScDocShell::MoveTable( SCTAB nSrcTab, SCTAB nDestTab, BOOL bCopy, BOOL bRec
 				GetUndoManager()->AddUndoAction(
 						new ScUndoCopyTab( this, aSrcList, aDestList ) );
 			}
+			
+			StarBASIC* pStarBASIC = GetBasic();
+			BOOL bVbaEnabled = pStarBASIC ? pStarBASIC->isVBAEnabled() : FALSE;
+			if ( bVbaEnabled )
+			{
+				String sCodeName;
+				String sSource;
+				aDocument.GetCodeName( nDestTab, sCodeName );
+				com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xLibContainer = GetBasicContainer();
+				com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLib;
+    				if( xLibContainer.is() )
+    				{
+        				String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        				com::sun::star::uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        				aLibAny >>= xLib;
+    				}
+    				if( xLib.is() )
+    				{
+					String sSrcCodeName;
+					aDocument.GetCodeName( nSrcTab, sSrcCodeName );
+					rtl::OUString sModName = sSrcCodeName;
+					com::sun::star::script::ModuleInfo sModuleInfo;
+					xLib->getByName( sModName ) >>= sModuleInfo;
+					sSource = sModuleInfo.ModuleSource;
+				} 
+				lcl_InsertModule( *this, nDestTab, sCodeName, sSource );
+			}
 		}
 
 		Broadcast( ScTablesHint( SC_TAB_COPIED, nSrcTab, nDestTab ) );
diff --git sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
index eb1b419..7f1c44b 100644
--- sc/source/filter/excel/read.cxx
+++ sc/source/filter/excel/read.cxx
@@ -947,7 +947,8 @@ FltError ImportExcel8::Read( void )
 					case 0x22:	Rec1904(); break;		// 1904			[ 2345   ]
 					case 0x56:	Builtinfmtcnt(); break;	// BUILTINFMTCNT[  34    ]
 					case 0x8D:	Hideobj(); break;		// HIDEOBJ		[  345   ]
-					case 0xD3:	ReadBasic(); break;
+					case 0xD3:	/*ReadBasic()*/bHasBasic = true; break;
+//					case 0xD3:	ReadBasic(); break;
                     case 0xDE:  Olesize(); break;
 					case 0x01BA: Codename( TRUE ); break;
 
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index 4a4af03..eee88d8 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -51,6 +51,12 @@
 #include <svtools/zforlist.hxx>
 #include <svtools/PasswordHelper.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -99,6 +105,7 @@
 using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2021,6 +2028,92 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName )
+{
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    uno::Reference< uno::XInterface > xDocModuleApiObject;
+    if ( xSF.is() )
+    {
+        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+        xDocModuleApiObject.set( xVBACodeNamedObjectAccess->getByName( sCodeName ), uno::UNO_QUERY );    
+    }
+    return xDocModuleApiObject;
+
+}
+
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule, String& sSource )
+{
+    ::rtl::OUString aModName( sModule );
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    script::ModuleInfo sModuleInfo;
+    sModuleInfo.ModuleName = aModName;
+    if ( sSource.Len() > 0 )
+        sModuleInfo.ModuleSource = sSource;
+    else
+        sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = script::ModuleType::Document;
+    sModuleInfo.ModuleObject = GetDocModuleObject( rDocSh, sModule );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sSource )
+{
+    SFX_APP()->EnterBasicCall();
+    script::ModuleInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName, sSource );
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // if the Module with codename exists then find a new name
+        sal_Int32 nNum = 1;
+        sModuleInfo.ModuleName = sModuleName;
+        while( xLib->hasByName( sModuleInfo.ModuleName  ) )
+        {
+            sModuleInfo.ModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            nNum += 1;
+        }
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleInfo.ModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleInfo.ModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
@@ -2030,8 +2120,18 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
-	if (bRecord && !pDoc->IsUndoEnabled())
+    // Strange loop, also basic is loaded too early ( InsertTable )
+    // is called via the xml import for sheets in described in odf 
+    BOOL bInsertDocModule = false;
+
+    if(  !rDocShell.GetDocument()->IsImportingXML() )
+    {
+        StarBASIC* pStarBASIC = rDocShell.GetBasic(); 
+        bInsertDocModule = pStarBASIC ? pStarBASIC->isVBAEnabled() : false;
+    }
+	if ( bInsertDocModule || ( bRecord && !pDoc->IsUndoEnabled() ) )
 		bRecord = FALSE;
+
 	if (bRecord)
 		pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2042,10 +2142,19 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 
 	if (pDoc->InsertTab( nTab, rName ))
 	{
+		String sCodeName;
 		if (bRecord)
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
+        // Only insert vba modules if vba mode ( and not currently importing XML )
+        if( bInsertDocModule )
+        {
+            if ( sCodeName.Len() == 0 )
+		sCodeName = rName;
+            String sSource;
+            lcl_InsertModule( rDocShell, nTab, sCodeName, sSource );
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
 		rDocShell.PostPaintExtras();
@@ -2067,8 +2175,12 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
 	BOOL bSuccess = FALSE;
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	BOOL bWasLinked = pDoc->IsLinked(nTab);
 	ScDocument* pUndoDoc = NULL;
 	ScRefUndoData* pUndoData = NULL;
@@ -2109,6 +2221,8 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 		pUndoData = new ScRefUndoData( pDoc );
 	}
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
 	if (pDoc->DeleteTab( nTab, pUndoDoc ))
 	{
 		if (bRecord)
@@ -2119,6 +2233,13 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 						new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
 		}
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+            }
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
 		if (bWasLinked)
diff --git sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
index 9a3edb8..b1a8a85 100644
--- sc/source/ui/unoobj/servuno.cxx
+++ sc/source/ui/unoobj/servuno.cxx
@@ -38,6 +38,7 @@
 #include <svx/unofill.hxx>
 #include <svx/unonrule.hxx>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
 
 #include "servuno.hxx"
 #include "unonames.hxx"
@@ -61,8 +62,103 @@
 #include <svx/xmleohlp.hxx>
 #include <svx/xmlgrhlp.hxx>
 
+#include <comphelper/processfactory.hxx>
+
 using namespace ::com::sun::star;
 
+class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    uno::Any maWorkbook;
+    uno::Any maCachedObject;
+    uno::Reference<lang::XMultiServiceFactory> mxSF;
+    ScDocShell* mpDocShell;
+public:
+    ScVbaObjectForCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        mxSF.set(comphelper::getProcessServiceFactory());
+        uno::Reference<beans::XPropertySet> xProps(mxSF, uno::UNO_QUERY);
+        if( xProps.is() )
+        {
+            ScDocument* pDoc = mpDocShell->GetDocument();
+            if ( !pDoc )
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
+
+            uno::Sequence< uno::Any > aArgs(2);
+            aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+            aArgs[1] = uno::Any( mpDocShell->GetModel() );
+            maWorkbook <<= mxSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs );
+        }
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        maCachedObject = uno::Any(); // clear cached object
+        String sName = aName;
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        if ( sName == pDoc->GetCodeName() )
+            maCachedObject = maWorkbook;
+        else 
+        {
+            String sCodeName;
+            SCTAB nCount = pDoc->GetTableCount();
+            for( SCTAB i = 0; i < nCount; i++ )
+            {
+                pDoc->GetCodeName( i, sCodeName );
+                if( sCodeName == sName )
+                {
+                    String sSheetName;
+                    if( pDoc->GetName( i, sSheetName ) )
+                    {
+                        uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                        uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                        uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                        uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                        uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                        uno::Sequence< uno::Any > aArgs(3);
+                        aArgs[0] = maWorkbook;
+                        aArgs[1] = uno::Any( xModel );
+                        aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                        maCachedObject <<= mxSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs );
+                        break;
+                    }
+                }
+            }
+        }
+        return maCachedObject.hasValue();
+
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectForCodeNameProvider::getByName( %s )",
+            rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( !hasByName( aName ) )
+            throw ::com::sun::star::container::NoSuchElementException();
+        return maCachedObject;
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        SCTAB nCount = pDoc->GetTableCount();
+        uno::Sequence< rtl::OUString > aNames( nCount + 1 ); 
+        SCTAB index = 0;
+        String sCodeName;
+        for( ; index < nCount; ++index )
+        {
+            pDoc->GetCodeName( index, sCodeName );
+            aNames[ index ] = sCodeName;
+        }
+        aNames[ index ] = pDoc->GetCodeName();
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
 
 //------------------------------------------------------------------------
 
@@ -112,7 +208,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+"org.openoffice.vba.VBAObjectModuleObjectProvider",// SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 //
@@ -164,7 +261,8 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 
@@ -357,6 +455,9 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<container::XNameAccess*>(new ScVbaObjectForCodeNameProvider( pDocShell )));
+            break;
 	}
 	return xRet;
 }
diff --git sc/source/ui/view/viewfun2.cxx sc/source/ui/view/viewfun2.cxx
index 1970245..7491061 100644
--- sc/source/ui/view/viewfun2.cxx
+++ sc/source/ui/view/viewfun2.cxx
@@ -57,6 +57,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2092,15 +2097,42 @@ BOOL ScViewFunc::DeleteTable( SCTAB nTab
 	return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
 	ScDocShell* pDocSh	= GetViewData()->GetDocShell();
 	ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	SCTAB		nNewTab = TheTabs[0];
 	int			i;
 	WaitObject aWait( GetFrameWin() );
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
 	while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
 		--nNewTab;
@@ -2167,9 +2199,18 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
 	for(i=TheTabs.Count()-1;i>=0;i--)
 	{
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
 		{
 			bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
 		}
 	}
@@ -2197,6 +2238,7 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
diff --git svx/source/msfilter/msvbasic.cxx svx/source/msfilter/msvbasic.cxx
index 2e4f500..2eff354 100644
--- svx/source/msfilter/msvbasic.cxx
+++ svx/source/msfilter/msvbasic.cxx
@@ -41,6 +41,8 @@
 #include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
 #include "msvbasic.hxx"
 
+using namespace ::com::sun::star::script;
+
 /*
 A few urls which may in the future be of some use
 http://www.virusbtn.com/vb2000/Programme/papers/bontchev.pdf
@@ -432,7 +434,7 @@ int VBA_Impl::ReadVBAProject(const SvSto
  *
 */
 
-ModuleType VBA_Impl::GetModuleType( const UniString& rModuleName )
+ModType VBA_Impl::GetModuleType( const UniString& rModuleName )
 {
     ModuleTypeHash::iterator iter = mhModHash.find( rModuleName );
     ModuleTypeHash::iterator iterEnd = mhModHash.end();
@@ -440,7 +442,7 @@ ModuleType VBA_Impl::GetModuleType( cons
     {
         return iter->second;
     }
-    return Unknown;
+    return ModuleType::Unknown;
 }
 
 bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
@@ -483,7 +485,7 @@ bool VBA_Impl::Open( const String &rTopl
         static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
         static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
         static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
-        mhModHash[ sThisDoc ] = Class;
+        mhModHash[ sThisDoc ] = ModuleType::Class;
         while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
         {
             xub_StrLen index = tmp.Search( '=' );
@@ -493,14 +495,14 @@ bool VBA_Impl::Open( const String &rTopl
                 String value = tmp.Copy( index + 1 );
                 if ( key == sClass )
                 {
-                    mhModHash[ value ] = Class;
+                    mhModHash[ value ] = ModuleType::Class;
                     OSL_TRACE("Module %s is of type Class",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sBaseClass )
                 {
-                    mhModHash[ value ] =  Form;
+                    mhModHash[ value ] =  ModuleType::Form;
                     OSL_TRACE("Module %s is of type Form",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
@@ -513,14 +515,14 @@ bool VBA_Impl::Open( const String &rTopl
                     // value is of form <name>/&H<identifier>, strip the identifier
                     value.Erase( value.Search( '/' ) );
 
-                    mhModHash[ value ] = Document;
+                    mhModHash[ value ] = ModuleType::Document;
                     OSL_TRACE("Module %s is of type Document VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sModule )
                 {
-                    mhModHash[ value ] = Normal;
+                    mhModHash[ value ] = ModuleType::Normal;
                     OSL_TRACE("Module %s is of type Normal VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
diff --git svx/source/msfilter/msvbasic.hxx svx/source/msfilter/msvbasic.hxx
index 8492062..a0536ae 100644
--- svx/source/msfilter/msvbasic.hxx
+++ svx/source/msfilter/msvbasic.hxx
@@ -45,6 +45,8 @@
 #include <vector>
 #endif
 #include<map>
+#include <com/sun/star/script/ModuleType.hpp>
+using namespace ::com::sun::star::script::ModuleType;
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -68,13 +70,12 @@ DECLARE_DYNARRAY(StringArray,String *)
 // #117718# define internal types to distinguish between
 // module types, form, class & normal
 // #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 // #117718# define map to hold types of module
 //
-
+typedef sal_Int32 ModType;
 typedef ::std::map< UniString,
-    ModuleType > ModuleTypeHash;
+    ModType > ModuleTypeHash;
 
 class VBA_Impl
 {
@@ -95,7 +96,7 @@ public:
     void Output(int len, const sal_uInt8 *data);
     //
     // #117718# member map of module names to types of module
-    ModuleType GetModuleType( const UniString& rModuleName );
+    ModType GetModuleType( const UniString& rModuleName );
 
     std::vector<String> maReferences;
 private:
diff --git svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
index d5878ad..d6ce988 100644
--- svx/source/msfilter/svxmsbas.cxx
+++ svx/source/msfilter/svxmsbas.cxx
@@ -53,6 +53,7 @@ using namespace com::sun::star::awt;
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -266,8 +268,22 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
             Any aLibAny = xLibContainer->getByName( aLibName );
 		    aLibAny >>= xLib;
         }
-		if( xLib.is() )
+		if( xLib.is()  )
 		{
+            Reference< container::XNameAccess > xVBAObjectForCodeName;
+			if ( !bAsComment )
+            {
+                rDocSh.GetBasic()->SetVBAEnabled( true );
+                Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                if ( xSF.is() )
+                {
+                    try
+                    {
+                        xVBAObjectForCodeName.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
+                    }
+                    catch( Exception& ) { }
+                }
+            }
 			for( UINT16 i=0; i<nStreamCount;i++)
 			{
 				StringArray aDecompressed = aVBA.Decompress(i);
@@ -301,7 +317,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 // is the same as the encoding for the names
                 // that are keys in the map used by GetModuleType method
                 const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+                ModType mType = aVBA.GetModuleType( sOrigVBAModName );
 
                 rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
 
@@ -309,23 +325,23 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 
                 switch( mType )
                 {
-                    case Class:
+                    case ModuleType::Class:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
                         break;
-                    case Form:
+                    case ModuleType::Form:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
                         break;
-                    case Document:
+                    case ModuleType::Document:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
                         break;
-                    case Normal:
+                    case ModuleType::Normal:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
                         break;
-                    case Unknown:
+                    case ModuleType::Unknown:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
                         break;
@@ -335,10 +351,10 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 }
 				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
 				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
+				if ( !bAsComment /*&& !rDocSh.GetBasic()->isVBAEnabled() */)
 				{
 					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
+					if ( mType == ModuleType::Class )
 						modeTypeComment = modeTypeComment + sClassOption;
 
 				}
@@ -405,12 +421,41 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
 				{
 					aSource = modeTypeComment + aSource;
 
 					Any aSourceAny;
-					aSourceAny <<= aSource;
+                    OSL_TRACE("erm %d", mType );
+                    if (  !bAsComment )
+                    {
+                        OSL_TRACE("vba processing  %d", mType );
+                        script::ModuleInfo sModuleInfo;
+                        sModuleInfo.ModuleName = aModName;
+                        sModuleInfo.ModuleSource = aSource;
+                        sModuleInfo.ModuleType = mType;
+                       if ( mType == ModuleType::Form )
+                            // hack, the module ( imo document basic should...
+                            // know the XModel... ) but it doesn't
+                            sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+			//  document modules, we should be able to access
+			//  the api objects at this time
+                        else if ( mType == ModuleType::Document )
+			{
+				uno::Reference< lang::XMultiServiceFactory> xSF( rDocSh.GetModel(), uno::UNO_QUERY);
+				uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    				if ( xSF.is() )
+				        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+				// get the api object for the codename
+				if ( xVBACodeNamedObjectAccess.is() )
+				{
+					sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
+					OSL_TRACE("** Straight up creation of Module");
+				}
+			}
+                        aSourceAny <<= sModuleInfo;
+                    }
+                    else
+					    aSourceAny <<= aSource;
 					if( xLib->hasByName( aModName ) )
 						xLib->replaceByName( aModName, aSourceAny );
 					else
@@ -420,6 +465,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 				bRet = true;
 			}
 		}
+        if( bRet )
 		SFX_APP()->LeaveBasicCall();
 	}
 	return bRet;
diff --git udkapi/com/sun/star/script/ModuleInfo.idl udkapi/com/sun/star/script/ModuleInfo.idl
new file mode 100644
index 0000000..00204f9
--- /dev/null
+++ udkapi/com/sun/star/script/ModuleInfo.idl
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	com::sun::star::uno::XInterface ModuleObject; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git udkapi/com/sun/star/script/ModuleType.idl udkapi/com/sun/star/script/ModuleType.idl
new file mode 100644
index 0000000..3295c52
--- /dev/null
+++ udkapi/com/sun/star/script/ModuleType.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleType.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleType_idl__
+#define __com_sun_star_script_ModuleType_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+published constants ModuleType
+{
+    const long Unknown = 0;
+    const long Normal = 1;  
+    const long Class = 2;
+    const long Form = 3;
+    const long Document = 4;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git udkapi/com/sun/star/script/makefile.mk udkapi/com/sun/star/script/makefile.mk
index 745df3e..69e06dd 100644
--- udkapi/com/sun/star/script/makefile.mk
+++ udkapi/com/sun/star/script/makefile.mk
@@ -85,6 +85,8 @@ IDLFILES=\
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+    ModuleInfo.idl\
+    ModuleType.idl\
 
 # ------------------------------------------------------------------
 
diff --git sc/source/filter/excel/xiescher.cxx sc/source/filter/excel/xiescher.cxx
index 2508629..4d6fddf 100644
--- sc/source/filter/excel/xiescher.cxx
+++ sc/source/filter/excel/xiescher.cxx
@@ -496,7 +496,7 @@ void XclImpDrawObjBase::ProcessSdrObject( SdrObject& rSdrObj ) const
     {
         if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
         {
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ) );
+            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ), GetDocShell() );
             pInfo->SetHlink( maHyperlink );
         }
     }
@@ -1887,7 +1887,7 @@ void XclImpTbxObjBase::SetDffProperties( const DffPropSet& rDffPropSet )
 
 bool XclImpTbxObjBase::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor ) const
 {
-    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName() );
+    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName(), GetDocShell() );
 }
 
 void XclImpTbxObjBase::ConvertFont( ScfPropertySet& rPropSet ) const
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index e66f60d..272578a 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -39,6 +39,11 @@
 #include "xistream.hxx"
 #include "xestream.hxx"
 
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::UNO_QUERY;
@@ -301,10 +306,26 @@ Reference< XControlModel > XclControlHelper::GetControlModel( Reference< XShape
 #define EXC_MACRONAME_PRE "vnd.sun.star.script:Standard."
 #define EXC_MACRONAME_SUF "?language=Basic&location=document"
 
-OUString XclControlHelper::GetScMacroName( const String& rXclMacroName )
+OUString XclControlHelper::GetScMacroName( const String& rXclMacroName, SfxObjectShell* pDocShell )
 {
+    String sTmp( rXclMacroName );
     if( rXclMacroName.Len() > 0 )
-        return CREATE_OUSTRING( EXC_MACRONAME_PRE ) + rXclMacroName + CREATE_OUSTRING( EXC_MACRONAME_SUF );
+    {
+        if ( ( sTmp.Search( '.' ) == STRING_NOTFOUND) && pDocShell )
+        {
+            if( StarBASIC* pBasic = pDocShell->GetBasic() )
+            {
+                if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sTmp, SbxCLASS_METHOD ) ) )
+                {
+                    if( SbModule* pModule = pMethod->GetModule() )
+                    {
+                        sTmp.Insert( '.', 0 ).Insert( pModule->GetName(), 0 );
+                    }
+                }
+            }
+        return CREATE_OUSTRING( EXC_MACRONAME_PRE ) + sTmp + CREATE_OUSTRING( EXC_MACRONAME_SUF );
+        }
+    }
     return OUString();
 }
 
@@ -338,14 +359,14 @@ spTbxListenerData[] =
 #define EXC_MACROSCRIPT "Script"
 
 bool XclControlHelper::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor,
-        XclTbxEventType eEventType, const String& rXclMacroName )
+        XclTbxEventType eEventType, const String& rXclMacroName, SfxObjectShell* pShell )
 {
     if( rXclMacroName.Len() > 0 )
     {
         rDescriptor.ListenerType = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcListenerType );
         rDescriptor.EventMethod = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcEventMethod );
         rDescriptor.ScriptType = CREATE_OUSTRING( EXC_MACROSCRIPT );
-        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName );
+        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName, pShell );
         return true;
     }
     return false;
diff --git sc/source/filter/inc/xlescher.hxx sc/source/filter/inc/xlescher.hxx
index 97fb567..d6c9b7c 100644
--- sc/source/filter/inc/xlescher.hxx
+++ sc/source/filter/inc/xlescher.hxx
@@ -432,7 +432,8 @@ public:
                         GetControlModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
 
     /** Returns the Calc macro name from an Excel macro name. */
-    static ::rtl::OUString GetScMacroName( const String& rXclMacroName );
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+
     /** Returns the Excel macro name from a Calc macro name. */
     static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
 
@@ -440,7 +441,7 @@ public:
     static bool         FillMacroDescriptor(
                             ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
                             XclTbxEventType eEventType,
-                            const String& rXclMacroName );
+                            const String& rXclMacroName, SfxObjectShell* pShell = NULL );
     /** Tries to extract an Excel macro name from the passed macro descriptor. */
     static String       ExtractFromMacroDescriptor(
                             const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
