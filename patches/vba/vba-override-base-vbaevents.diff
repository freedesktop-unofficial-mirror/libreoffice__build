diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index d22d117..4f6ae25 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -2485,7 +2485,10 @@ void SbUserFormModule::Unload()
     triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ), aParams);
 
     aParams[0] >>= nCancel;
-    if (nCancel == 1)
+    // basic boolean ( and what the user might use ) can be ambiguous ( e.g. basic true = -1 )
+    // test agains 0 ( false ) and assume anything else is true
+    // ( Note: ) this used to work ( something changes somewhere )
+    if (nCancel != 0)
     {
         return;
     }
diff --git sc/source/ui/unoobj/viewuno.cxx sc/source/ui/unoobj/viewuno.cxx
index a08c2a6..442673f 100644
--- sc/source/ui/unoobj/viewuno.cxx
+++ sc/source/ui/unoobj/viewuno.cxx
@@ -460,6 +460,117 @@ void SAL_CALL ScViewPaneObj::release() throw()
     OWeakObject::release();
 }
 
+// To process sheet compatibile event
+typedef ::cppu::WeakImplHelper2< awt::XEnhancedMouseClickHandler, view::XSelectionChangeListener > TabViewEventListener_BASE;
+class ScTabViewEventListener: public TabViewEventListener_BASE
+{
+private:
+    ScTabViewObj* pViewObj;
+    uno::Reference< script::vba::XVBAEventProcessor > xVbaEventsHelper;
+    sal_Bool bDelaySelectionEvent;
+    sal_Bool bSelectionChangeOccured;
+
+    void fireSelectionChangeEvent();
+    
+public:
+    ScTabViewEventListener( ScTabViewObj* pObj, uno::Reference< script::vba::XVBAEventProcessor >& rVbaEventsHelper);
+    ~ScTabViewEventListener();
+	// XEnhancedMouseClickHandler
+	virtual sal_Bool SAL_CALL mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+	virtual sal_Bool SAL_CALL mouseReleased( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+
+    // XSelectionChangeListener
+    virtual void SAL_CALL selectionChanged( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XEventListener
+	virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+
+ScTabViewEventListener::ScTabViewEventListener(ScTabViewObj* pObj, uno::Reference< script::vba::XVBAEventProcessor >& rVbaEventsHelper):
+	pViewObj( pObj ),xVbaEventsHelper( rVbaEventsHelper ), bDelaySelectionEvent( sal_False ), bSelectionChangeOccured( sal_False )
+{
+}
+
+ScTabViewEventListener::~ScTabViewEventListener()
+{
+}
+
+void SAL_CALL ScTabViewEventListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+}
+
+void ScTabViewEventListener::fireSelectionChangeEvent()
+{
+	if ( xVbaEventsHelper.is() && pViewObj )
+	{
+		uno::Sequence< uno::Any > aArgs(1);
+		aArgs[0] = pViewObj->getSelection();
+                try
+                {
+		    xVbaEventsHelper->processVbaEvent( script::vba::VBAEventId::WORKSHEET_SELECTIONCHANGE, aArgs );
+                }
+                catch( uno::Exception& )
+                {
+                }
+	}
+	bDelaySelectionEvent = sal_False;
+	bSelectionChangeOccured = sal_False;
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException)
+{
+	// Delay to fire the selection change event if clicking the left mouse button to do selection.
+	bDelaySelectionEvent = ( e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT ) ? sal_False : sal_True;
+	bSelectionChangeOccured = sal_False;
+
+	sal_Bool result =  sal_False;
+    // process BeforeDoubleClick and BeforeRightClick events
+	if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+	{
+		// ensure the target is a cell
+        uno::Reference< table::XCell > xCell( e.Target, uno::UNO_QUERY );
+		if( xCell.is() && xVbaEventsHelper.is() && pViewObj)
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] = pViewObj->getSelection();
+			sal_Int32 nEventId = script::vba::VBAEventId::WORKSHEET_BEFORERIGHTCLICK;
+			if( e.ClickCount == 2 )
+				nEventId = script::vba::VBAEventId::WORKSHEET_BEFOREDOUBLECLICK;
+            
+			// TODO: process Cancel argument	
+			try
+			{
+				xVbaEventsHelper->processVbaEvent( nEventId, aArgs );
+				result = sal_True;
+			}
+			catch( uno::Exception& )
+			{
+			}
+		}
+	}
+	return result;
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mouseReleased( const awt::EnhancedMouseEvent&/*e*/) throw (uno::RuntimeException)
+{
+	if ( bSelectionChangeOccured )
+	{
+		fireSelectionChangeEvent();
+	}
+	return sal_False;
+}
+
+void SAL_CALL ScTabViewEventListener::selectionChanged( const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+	if ( !bDelaySelectionEvent )
+	{
+		fireSelectionChangeEvent();
+	}
+	else
+	{
+		bSelectionChangeOccured = sal_True;
+	}
+}
+
 //------------------------------------------------------------------------
 
 //	Default-ctor wird fuer SMART_REFLECTION_IMPLEMENTATION gebraucht
@@ -485,7 +596,19 @@ ScTabViewObj::ScTabViewObj( ScTabViewShell* pViewSh ) :
     bDrawSelModeSet(sal_False)
 {
     if (pViewSh)
+    {
         nPreviousTab = pViewSh->GetViewData()->GetTabNo();
+	ScViewData* pViewData = pViewSh->GetViewData();
+	if( pViewData )
+	{
+            uno::Reference< script::vba::XVBAEventProcessor > xVbaEventsHelper (pViewData->GetDocument()->GetVbaEventProcessor(), uno::UNO_QUERY );
+			ScTabViewEventListener* pEventListener = new ScTabViewEventListener( this, xVbaEventsHelper );
+			uno::Reference< awt::XEnhancedMouseClickHandler > aMouseClickHandler( *pEventListener, uno::UNO_QUERY );
+			addEnhancedMouseClickHandler( aMouseClickHandler );
+            uno::Reference< view::XSelectionChangeListener > aSelectionChangeListener( *pEventListener, uno::UNO_QUERY );
+            addSelectionChangeListener( aSelectionChangeListener );
+	}
+    }
 }
 
 ScTabViewObj::~ScTabViewObj()
@@ -1858,19 +1981,7 @@ void ScTabViewObj::SelectionChanged()
             /*ErrCode eRet =*/ pDocSh->CallXScript( *pScript, aParams, aRet, aOutArgsIndex, aOutArgs );
         }
     }
-
-    // execute VBA event handler
-    try
-    {
-        uno::Reference< script::vba::XVBAEventProcessor > xVbaEvents( pDoc->GetVbaEventProcessor(), uno::UNO_SET_THROW );
-        // the parameter is the clicked object, as in the mousePressed call above
-        uno::Sequence< uno::Any > aArgs( 1 );
-        aArgs[ 0 ] <<= getSelection();
-        xVbaEvents->processVbaEvent( ScSheetEvents::GetVbaSheetEventId( SC_SHEETEVENT_SELECT ), aArgs );
-    }
-    catch( uno::Exception& )
-    {
-    }
+    // Removed Sun/Oracle code intentionally, it doesn't work properly ( selection should be fired after mouse release )
 }
 
 
diff --git vcl/source/window/dialog.cxx vcl/source/window/dialog.cxx
index 1e493ce..901c934 100644
--- vcl/source/window/dialog.cxx
+++ vcl/source/window/dialog.cxx
@@ -562,7 +562,11 @@ BOOL Dialog::Close()
 	//liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
 	mnCancelClose = 0;
 	ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );	
-	if (mnCancelClose == 1)
+        // basic boolean ( and what the user might use in the event handler) can
+	// be ambiguous ( e.g. basic true = -1 )
+	// test agains 0 ( false ) and assume anything else is true
+	// ( Note: ) this used to work ( something changes somewhere )
+	if (mnCancelClose != 0)
 	{
 		return FALSE;
 	}
