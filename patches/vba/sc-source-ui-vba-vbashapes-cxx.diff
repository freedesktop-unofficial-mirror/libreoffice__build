--- sc/source/ui/vba/vbashapes.cxx	
+++ sc/source/ui/vba/vbashapes.cxx
@@ -45,41 +45,53 @@
 using namespace ::org::openoffice;
 using namespace ::com::sun::star;
 
-class EnumWrapper : public EnumerationHelper_BASE
+class VbShapeEnumHelper : public EnumerationHelper_BASE
 {
-
         uno::Reference<msforms::XShapes > m_xParent;
         uno::Reference<container::XIndexAccess > m_xIndexAccess;
         sal_Int32 nIndex;
 public:
-        EnumWrapper( const uno::Reference< msforms::XShapes >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+	VbShapeEnumHelper( const uno::Reference< msforms::XShapes >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
         virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
         {
                 return ( nIndex < m_xIndexAccess->getCount() );
         }
-
         virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
         {
-                if ( nIndex < m_xIndexAccess->getCount() )
-		{
-			ScVbaShapes* pShapes = dynamic_cast< ScVbaShapes* >(m_xParent.get());
-			if ( pShapes )
-                        	return pShapes->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
-		}
+                ScVbaShapes* pShapes = dynamic_cast< ScVbaShapes* >(m_xParent.get());
+                if ( pShapes && hasMoreElements() )
+                    return pShapes->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
                 throw container::NoSuchElementException();
         }
+
 };
 
+void ScVbaShapes::initBaseCollection()
+{
+	if ( m_xNameAccess.is() ) // already has NameAccess
+		return;
+	// no NameAccess then use ShapeCollectionHelper
+	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
+	sal_Int32 nLen = m_xIndexAccess->getCount();
+	mShapes.reserve( nLen );
+	for ( sal_Int32 index=0; index<nLen; ++index )
+		mShapes.push_back( uno::Reference< drawing::XShape >( m_xIndexAccess->getByIndex( index ) , uno::UNO_QUERY ) );
+	uno::Reference< container::XIndexAccess > xShapes( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
+	m_xIndexAccess.set( xShapes, uno::UNO_QUERY );
+	m_xNameAccess.set( xShapes, uno::UNO_QUERY );
+}
+
 ScVbaShapes::ScVbaShapes( const css::uno::Reference< oo::vba::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes ): ScVbaShapes_BASE( xParent, xContext, xShapes ), m_nNewShapeCount(0)
 {
     m_xShapes.set( xShapes, uno::UNO_QUERY_THROW );
     m_xDrawPage.set( xShapes, uno::UNO_QUERY_THROW ); 
+    initBaseCollection();
 }
 
 uno::Reference< container::XEnumeration >
 ScVbaShapes::createEnumeration() throw (uno::RuntimeException)
 {
-    return new EnumWrapper( this,  m_xIndexAccess );
+    return new VbShapeEnumHelper( this,  m_xIndexAccess );
 }
 
 uno::Any
@@ -93,27 +105,6 @@ ScVbaShapes::createCollectionObject( con
     return uno::Any();
 }
 
-uno::Any
-ScVbaShapes::getItemByStringIndex( const rtl::OUString& sIndex ) throw (uno::RuntimeException)
-{
-    try
-    {
-        return ScVbaShapes_BASE::getItemByStringIndex( sIndex );
-    }
-    catch( uno::RuntimeException )
-    {
-        try
-        {
-            uno::Reference< drawing::XShape > xShape( getByName( sIndex ), uno::UNO_QUERY_THROW );
-            return createCollectionObject( uno::makeAny( xShape ) );
-        }
-        catch( uno::RuntimeException )
-        {
-            throw uno::RuntimeException( rtl::OUString::createFromAscii("Unsatisified object name!"), uno::Reference< uno::XInterface >() );
-        }
-    }
-}
-
 uno::Type
 ScVbaShapes::getElementType() throw (uno::RuntimeException)
 {
@@ -138,147 +129,78 @@ ScVbaShapes::getServiceNames()
 	return aServiceNames;
 }
 
-
-uno::Reference< msforms::XShapeRange > SAL_CALL 
-ScVbaShapes::Range( const uno::Any& shapes ) throw (css::uno::RuntimeException)
-{
-    if( shapes.hasValue() )
-    {
-        uno::Reference< msforms::XShapeRange > xShapeRange;
-        uno::Reference< drawing::XShapes > xShapes;
-        sal_Int32 nIndex;
-        rtl::OUString sIndex;
-        uno::Sequence< sal_Int16 > nArray;
-        uno::Sequence< rtl::OUString > sArray;
-        if( shapes >>= nIndex )
-        {
-            return uno::Reference< msforms::XShapeRange >( new ScVbaShapeRange( getParent(), mxContext, getShapeByIndex( nIndex ), m_xDrawPage ) );
-        }
-        else if( shapes >>= sIndex )
-        {
-            return uno::Reference< msforms::XShapeRange >( new ScVbaShapeRange( getParent(), mxContext, getShapeByName( sIndex ), m_xDrawPage ) );
-        }
-        else if( shapes >>= nArray )
-        {
-            return uno::Reference< msforms::XShapeRange >( new ScVbaShapeRange( getParent(), mxContext, getShapesByIndex( nArray ), m_xDrawPage ) );
-        }
-        else if( shapes >>= sArray )
-        {
-            return uno::Reference< msforms::XShapeRange >( new ScVbaShapeRange( getParent(), mxContext, getShapesByNames( sArray ), m_xDrawPage ) );
-        }
-        else 
-        {
-            throw uno::RuntimeException( rtl::OUString::createFromAscii("Invalid Parameter!"), uno::Reference< uno::XInterface >() );
-        }
-    }
-    else
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter should not empty!"), uno::Reference< uno::XInterface >() );
-    }
-}
-
-uno::Reference< drawing::XShapes>
-ScVbaShapes::getEmptyShapesCollection() throw (uno::RuntimeException)
-{
-    uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-    uno::Reference< uno::XInterface > xInterface = xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.drawing.ShapeCollection" ) );
-    uno::Reference< drawing::XShapes > xShapes( xInterface, uno::UNO_QUERY_THROW );
-    return xShapes;
-}
-
-uno::Reference< drawing::XShape >
-ScVbaShapes::getByName( rtl::OUString sIndex ) throw (uno::RuntimeException)
-{
-    if( m_xNameAccess.is() )
-        return  uno::Reference< drawing::XShape >( m_xNameAccess->getByName( sIndex ), uno::UNO_QUERY_THROW );
-    else
-    {
-        uno::Reference< container::XIndexAccess > xIndexAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
-        sal_uInt16 nCount = xIndexAccess->getCount();
-        for( int index = 0; index < nCount; index++ )
-        {
-            uno::Any aUnoObj =  xIndexAccess->getByIndex( index );
-            uno::Reference< drawing::XShape > xShape( aUnoObj, uno::UNO_QUERY_THROW );
-            uno::Reference< container::XNamed > xNamed( xShape, uno::UNO_QUERY_THROW );
-            if( sIndex.equals( xNamed->getName() ))
-            {
-                return xShape;
-            }
-        }
-    }
-    return uno::Reference< drawing::XShape >();
-}
-
-uno::Reference< drawing::XShapes > 
-ScVbaShapes::getShapeByName( rtl::OUString sIndex ) throw (uno::RuntimeException)
+css::uno::Reference< css::container::XIndexAccess > 
+ScVbaShapes::getShapesByArrayIndices( const uno::Any& Index  ) throw (uno::RuntimeException)
 {
-    uno::Reference< drawing::XShapes > xShapes( getEmptyShapesCollection(), uno::UNO_QUERY_THROW );
-    try
-    {
-        uno::Reference< drawing::XShape > xShape( getByName( sIndex ), uno::UNO_QUERY_THROW );
-        xShapes->add( xShape );
-        return xShapes;
-    }
-    catch( uno::RuntimeException )
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Unsatisified object name!"), uno::Reference< uno::XInterface >() );
-    }
+	if ( Index.getValueTypeClass() != uno::TypeClass_SEQUENCE )
+		throw uno::RuntimeException();
+	
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter(mxContext);
+	uno::Any aConverted;
+	aConverted = xConverter->convertTo( Index, getCppuType((uno::Sequence< uno::Any >*)0) );
+
+	uno::Sequence< uno::Any > sIndices;
+	aConverted >>= sIndices;
+	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
+	sal_Int32 nElems = sIndices.getLength();
+	for( sal_Int32 index = 0; index < nElems; ++index )
+	{
+		uno::Reference< drawing::XShape > xShape;
+		if ( sIndices[ index ].getValueTypeClass() == uno::TypeClass_STRING )
+		{
+			rtl::OUString sName;
+			sIndices[ index ] >>= sName;
+			xShape.set( m_xNameAccess->getByName( sName ), uno::UNO_QUERY );
+		}
+		else
+		{
+			sal_Int32 nIndex;
+			sIndices[ index ] >>= nIndex;
+			// adjust for 1 based mso indexing
+			xShape.set( m_xIndexAccess->getByIndex( nIndex - 1 ), uno::UNO_QUERY );		
+			
+		}
+		// populate map with drawing::XShapes
+		if ( xShape.is() )
+			mShapes.push_back( xShape );
+	}  
+	uno::Reference< container::XIndexAccess > xIndexAccess( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
+	return xIndexAccess;
 }
 
-uno::Reference< drawing::XShapes > 
-ScVbaShapes::getShapeByIndex( sal_Int32 nIndex ) throw (uno::RuntimeException)
-{
-    if( !m_xIndexAccess.is() )
-    {
-        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase numeric index access not supported by this object") ), uno::Reference< css::uno::XInterface >() );
-    }
-	if ( nIndex <= 0 )
+uno::Any SAL_CALL 
+ScVbaShapes::Item( const uno::Any& Index, const uno::Any& Index2 ) throw (uno::RuntimeException)
+{
+	// I don't think we need to support Array of indices for shapes	
+/*
+	if ( Index.getValueTypeClass() == uno::TypeClass_SEQUENCE )
 	{
-		throw  lang::IndexOutOfBoundsException( 
-			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
-			"index is 0 or negative" ) ), 
-			uno::Reference< uno::XInterface >() );
+		uno::Reference< container::XIndexAccess > xIndexAccess( getShapesByArrayIndices( Index ) );
+		// return new collection instance
+		uno::Reference< vba::XCollection > xShapesCollection(  new ScVbaShapes( this->getParent(), mxContext, xIndexAccess ) );
+		return uno::makeAny( xShapesCollection );
 	}
-    uno::Reference< drawing::XShape > xShape( m_xIndexAccess->getByIndex( nIndex - 1 ), uno::UNO_QUERY_THROW );
-    uno::Reference< drawing::XShapes > xShapes( getEmptyShapesCollection(), uno::UNO_QUERY_THROW );
-    xShapes->add( xShape );
-    return xShapes;
+*/
+	return 	ScVbaShapes_BASE::Item( Index, Index2 );
 }
 
-uno::Reference< drawing::XShapes > 
-ScVbaShapes::getShapesByNames( uno::Sequence< rtl::OUString > sArray ) throw (uno::RuntimeException)
-{
-    uno::Reference< drawing::XShapes > xShapes( getEmptyShapesCollection(), uno::UNO_QUERY_THROW );
-    rtl::OUString sName;
-    sal_Int32 nLength = sArray.getLength();
-    if( nLength == 0 )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("array of name is empty!"), uno::Reference< uno::XInterface >() );
-    for( sal_Int32 i = 0; i < nLength; i++ )
-    {
-        sName = sArray[i];
-        uno::Reference< drawing::XShapes > xTmpShapes( getShapeByName( sName ), uno::UNO_QUERY_THROW );
-        uno::Reference< drawing::XShape > xShape( xTmpShapes->getByIndex(0), uno::UNO_QUERY_THROW );
-        xShapes->add( xShape );
-    }
-    return xShapes; 
-}
-
-uno::Reference< drawing::XShapes > 
-ScVbaShapes::getShapesByIndex( uno::Sequence< sal_Int16 > nArray ) throw (uno::RuntimeException)
+uno::Reference< msforms::XShapeRange > SAL_CALL 
+ScVbaShapes::Range( const uno::Any& shapes ) throw (css::uno::RuntimeException)
 {
-    uno::Reference< drawing::XShapes > xShapes( getEmptyShapesCollection(), uno::UNO_QUERY_THROW );
-    sal_Int16 nIndex;
-    sal_Int32 nLength = nArray.getLength();
-    if( nLength == 0 )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("array of index is empty!"), uno::Reference< uno::XInterface >() );
-    for( sal_Int32 i = 0; i < nLength; i++ )
-    {
-        nIndex = nArray[i];
-        uno::Reference< drawing::XShapes > xTmpShapes( getShapeByIndex( nIndex ), uno::UNO_QUERY_THROW );
-        uno::Reference< drawing::XShape > xShape( xTmpShapes->getByIndex(0), uno::UNO_QUERY_THROW );
-        xShapes->add( xShape );
-    }
-    return xShapes; 
+	// shapes, can be an index or an array of indices
+	uno::Reference< container::XIndexAccess > xShapes;
+	if ( shapes.getValueTypeClass() == uno::TypeClass_SEQUENCE )
+		xShapes = getShapesByArrayIndices( shapes );
+	else
+	{
+		// wrap single index into a sequence
+		uno::Sequence< uno::Any > sIndices(1);
+		sIndices[ 0 ] = shapes;
+		uno::Any aIndex;
+		aIndex <<= sIndices;
+		xShapes = getShapesByArrayIndices( aIndex );
+	}
+	return new ScVbaShapeRange(  getParent(), mxContext, xShapes, m_xDrawPage );
 }
 
 void SAL_CALL 
@@ -286,7 +208,16 @@ ScVbaShapes::SelectAll() throw (uno::Run
 {
     uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
     uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    xSelectSupp->select( uno::makeAny( m_xShapes ) );
+    try
+    {
+        xSelectSupp->select( uno::makeAny( m_xShapes ) );
+    }
+    // viewuno.cxx ScTabViewObj::select will throw IllegalArgumentException
+    // if one of the shapes is no 'markable' e.g. a button 
+    // the method still works
+    catch( lang::IllegalArgumentException& )
+    {
+    }
 }
 
 uno::Reference< drawing::XShape > 
