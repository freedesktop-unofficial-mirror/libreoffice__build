diff --git basctl/source/basicide/basides1.cxx basctl/source/basicide/basides1.cxx
index aed5958..3d79067 100644
--- basctl/source/basicide/basides1.cxx
+++ basctl/source/basicide/basides1.cxx
@@ -1201,10 +1201,16 @@ IDEBaseWindow* BasicIDEShell::FindWindow
                 // return any non-suspended window
                 return pWin;
             }
-            else if ( pWin->IsDocument( rDocument ) && pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
+            else if ( pWin->IsDocument( rDocument ) )
+            {
+                OSL_TRACE("FindWindow pWin->GetLibName() %s rLibName %s",
+			rtl::OUStringToOString( pWin->GetLibName(), RTL_TEXTENCODING_UTF8 ).getStr(),
+			rtl::OUStringToOString( rLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( ModulWindow ) %d && nType %d = BASICIDE_TYPE_MODULE %d", pWin->IsA( TYPE( ModulWindow ) ), nType, BASICIDE_TYPE_MODULE );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( DialogWindow ) %d && nType %d = BASICIDE_TYPE_DIALOG %d", pWin->IsA( TYPE( DialogWindow ) ), nType, BASICIDE_TYPE_DIALOG );
+		if (  pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
                       ( ( pWin->IsA( TYPE( ModulWindow ) )  && nType == BASICIDE_TYPE_MODULE ) ||
                         ( pWin->IsA( TYPE( DialogWindow ) ) && nType == BASICIDE_TYPE_DIALOG ) ) )
-            {
                 return pWin;
             }
         }
diff --git basctl/source/basicide/basides2.cxx basctl/source/basicide/basides2.cxx
index 76dcea0..90cec19 100644
--- basctl/source/basicide/basides2.cxx
+++ basctl/source/basicide/basides2.cxx
@@ -251,9 +251,12 @@ ModulWindow* BasicIDEShell::CreateBasWin
 
         if ( bSuccess )
         {
-			// new module window
-			pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
-			nKey = InsertWindowInTable( pWin );
+			pWin = FindBasWin( rDocument, aLibName, aModName, FALSE, TRUE );
+            if( !pWin )
+			{    // new module window
+			    pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
+			    nKey = InsertWindowInTable( pWin );
+            }
         }
 	}
 	else
@@ -268,7 +271,8 @@ ModulWindow* BasicIDEShell::CreateBasWin
 		}
 		DBG_ASSERT( nKey, "CreateBasWin: Kein Key- Fenster nicht gefunden!" );
 	}
-	pTabBar->InsertPage( (USHORT)nKey, aModName );
+    if( nKey )
+	    pTabBar->InsertPage( (USHORT)nKey, aModName );
 	pTabBar->Sort();
 	pWin->GrabScrollBars( &aHScrollBar, &aVScrollBar );
 	if ( !pCurWin )
diff --git basctl/source/basicide/basidesh.cxx basctl/source/basicide/basidesh.cxx
index 03459cc..d921d99 100644
--- basctl/source/basicide/basidesh.cxx
+++ basctl/source/basicide/basidesh.cxx
@@ -80,6 +80,9 @@
 #include <com/sun/star/script/XLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/container/XContainerListener.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 
 #include <svx/xmlsecctrl.hxx>
 
@@ -87,6 +90,71 @@ using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
+static const rtl::OUString sStandardLibName(  rtl::OUString::createFromAscii("Standard") );
+
+typedef ::cppu::WeakImplHelper1< container::XContainerListener > ContainerListenerBASE;
+
+class ContainerListenerImpl : public ContainerListenerBASE
+{
+    BasicIDEShell* mpShell;
+public:
+
+    ContainerListenerImpl( BasicIDEShell* pShell ) : mpShell( pShell ) {}
+
+    ~ContainerListenerImpl() 
+    {
+    }
+
+    void addContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument() && xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+                xContainer->addContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+    void removeContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument(), xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+               xContainer->removeContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& ) throw( uno::RuntimeException ) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& Event ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell && ( Event.Accessor >>= sModuleName ) )
+            mpShell->FindBasWin( mpShell->m_aCurDocument, sStandardLibName, sModuleName, TRUE, FALSE );
+    }
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& ) throw( com::sun::star::uno::RuntimeException ) { }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& Event ) throw( com::sun::star::uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell  && ( Event.Accessor >>= sModuleName ) )
+        {
+            IDEBaseWindow* pWin = mpShell->FindWindow( mpShell->m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+            if( pWin )
+                mpShell->RemoveWindow( pWin, FALSE, TRUE );
+        }
+    }
+
+};
 
 TYPEINIT1( BasicIDEShell, SfxViewShell );
 
@@ -124,6 +192,7 @@ BasicIDEShell::BasicIDEShell( SfxViewFra
         m_bAppBasicModified( FALSE ),
         m_aNotifier( *this )
 {
+    m_xLibListener = new ContainerListenerImpl( this );
 	Init();
     GnBasicIDEShellCount++;
 }
@@ -215,6 +284,12 @@ __EXPORT BasicIDEShell::~BasicIDEShell()
 	delete pTabBar;
 	delete pObjectCatalog;
 	DestroyModulWindowLayout();
+
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        // Destroy all ContainerListeners for Basic Container.
+        if ( pListener )
+            pListener->removeContainerListener( m_aCurDocument );
+    
 	// MI: Das gab einen GPF im SDT beim Schliessen da dann der ViewFrame die
 	// ObjSh loslaesst. Es wusste auch keiner mehr wozu das gut war.
 	// GetViewFrame()->GetObjectShell()->Broadcast( SfxSimpleHint( SFX_HINT_DYING ) );
@@ -935,7 +1010,15 @@ void BasicIDEShell::SetCurLib( const Scr
 {
     if ( !bCheck || ( rDocument != m_aCurDocument || aLibName != m_aCurLibName ) )
     {
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        if ( pListener )
+        	pListener->removeContainerListener( m_aCurDocument );
+
         m_aCurDocument = rDocument;
+
+        if ( pListener )
+            pListener->addContainerListener( m_aCurDocument );
+
         m_aCurLibName = aLibName;
         if ( bUpdateWindows )
             UpdateWindows();
diff --git basctl/source/inc/basidesh.hxx basctl/source/inc/basidesh.hxx
index 6b3690c..3919bd9 100644
--- basctl/source/inc/basidesh.hxx
+++ basctl/source/inc/basidesh.hxx
@@ -49,6 +49,7 @@
 #include <com/sun/star/io/XInputStreamProvider.hpp>
 #endif
 
+#include <com/sun/star/container/XContainerListener.hpp>
 
 //----------------------------------------------------------------------------
 
@@ -107,6 +108,8 @@ friend bool BasicIDE::RemoveDialog( cons
     BOOL                m_bAppBasicModified;
     ::basctl::DocumentEventNotifier
                         m_aNotifier;
+friend class ContainerListenerImpl;
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XContainerListener > m_xLibListener;
 
 #if _SOLAR__PRIVATE
 	void				Init();
diff --git basic/inc/basic/sbmod.hxx basic/inc/basic/sbmod.hxx
index 122a664..e676a49 100644
--- basic/inc/basic/sbmod.hxx
+++ basic/inc/basic/sbmod.hxx
@@ -37,7 +37,7 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
-
+#include <com/sun/star/script/ModuleType.hpp>
 class SbMethod;
 class SbProperty;
 class SbiRuntime;
@@ -67,6 +67,9 @@ protected:
 	SbiBreakpoints*	pBreaks;			// Breakpoints
 	SbClassData*	pClassData;
 	bool mbVBACompat;
+	INT32 mnType; 
+	SbxObjectRef pDocObject; // an impl object ( used by Document Modules )
+	bool 	bIsProxyModule;
 
 	void			StartDefinitions();
 	SbMethod*		GetMethod( const String&, SbxDataType );
@@ -91,7 +94,7 @@ protected:
 public:
 	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASICMOD,2);
 	TYPEINFO();
-					SbModule( const String& );
+					SbModule( const String&, bool bCompat = false );
 	virtual void	SetParent( SbxObject* );
 	virtual void 	Clear();
 
@@ -127,8 +130,12 @@ public:
 	BOOL LoadBinaryData( SvStream& );
 	BOOL ExceedsLegacyModuleSize();
 	void fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg = NULL ) const;
-        bool IsVBACompat() { return mbVBACompat; }
         bool HasExeCode();
+        bool IsVBACompat();
+        void SetVBACompat( bool bCompat );
+        INT32 GetModuleType() { return mnType; }
+        void SetModuleType( INT32 nType ) { mnType = nType; }
+	bool GetIsProxyModule() { return bIsProxyModule; }
 };
 
 #ifndef __SB_SBMODULEREF_HXX
diff --git basic/inc/basic/sbobjmod.hxx basic/inc/basic/sbobjmod.hxx
new file mode 100644
index 0000000..cb581c1
--- /dev/null
+++ basic/inc/basic/sbobjmod.hxx
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+
+namespace css = ::com::sun::star;
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+public:
+    TYPEINFO();
+    SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    SbxVariable* GetObject();
+    void SetUnoObject( const com::sun::star::uno::Any& aObj )throw ( com::sun::star::uno::RuntimeException ) ;
+};
+
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
diff --git basic/inc/basic/sbstar.hxx basic/inc/basic/sbstar.hxx
index ebd10ae..1f20e9d 100644
--- basic/inc/basic/sbstar.hxx
+++ basic/inc/basic/sbstar.hxx
@@ -40,6 +40,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // fertiges Modul
 class SbiInstance;                  // Laufzeit-Instanz
@@ -71,6 +72,7 @@ class StarBASIC : public SbxObject
 	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
 	BOOL			bBreak;				// TRUE: Break, sonst Step
 	BOOL			bDocBasic;
+    BOOL            bVBAEnabled;
 	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
 protected:
@@ -113,7 +115,8 @@ public:
 
 	// Compiler-Interface
 	SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const com::sun::star::script::ModuleInfo& mInfo, const ::rtl::OUString& rSrc );
 	BOOL			Compile( SbModule* );
 	BOOL 			Disassemble( SbModule*, String& rText );
 	static void 	Stop();
@@ -185,6 +188,8 @@ public:
 					( const String& rName, USHORT& rStatus );
 	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
 	static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
 	// #60175 TRUE: SFX-Resource wird bei Basic-Fehlern nicht angezogen
 	static void StaticSuppressSfxResource( BOOL bSuppress );
diff --git basic/source/basmgr/basmgr.cxx basic/source/basmgr/basmgr.cxx
index 73eb4cb..864a941 100644
--- basic/source/basmgr/basmgr.cxx
+++ basic/source/basmgr/basmgr.cxx
@@ -44,6 +44,7 @@
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
 #include <basic/sbmod.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include <basic/sbuno.hxx>
 #include <basic/basmgr.hxx>
@@ -67,6 +68,9 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/XBasicLibraryInfo.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -236,6 +240,11 @@ void BasMgrContainerListenerImpl::addLib
 
 	StarBASIC* pLib = pMgr->GetLib( aLibName );
 	DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::addLibraryModulesImpl: Unknown lib!");
+	Reference<  XBasicLibraryInfo > xLibInfo( xLibNameAccess, UNO_QUERY );
+	if ( xLibInfo.is() && xLibInfo->getVBACompatMode() )
+		pLib->SetVBAEnabled( true );
+	
+	OSL_TRACE("addLibraryModulesImpl libname %s, xLibInfo %d", rtl::OUStringToOString( aLibName, RTL_TEXTENCODING_UTF8 ).getStr(), xLibInfo.is() );
 	if( pLib )
 	{
 		const ::rtl::OUString* pNames = aModuleNames.getConstArray();
@@ -245,7 +254,15 @@ void BasMgrContainerListenerImpl::addLib
 			Any aElement = xLibNameAccess->getByName( aModuleName );
 			::rtl::OUString aMod;
 			aElement >>= aMod;
-			pLib->MakeModule32( aModuleName, aMod );
+
+			if ( xLibInfo.is() && xLibInfo->getVBACompatMode() )
+			{
+            	ModuleInfo mInfo = xLibInfo->getModuleInfo( pNames[ j ] );
+                OSL_TRACE("#addLibraryModulesImpl - aMod");
+                pLib->MakeModule32( mInfo, aMod );
+            }
+            else
+			    pLib->MakeModule32( aModuleName, aMod );
 		}
 	}
 
@@ -274,6 +291,7 @@ void SAL_CALL BasMgrContainerListenerImp
 	Event.Accessor >>= aName;
 
     mpMgr->mpImpl->mbModifiedByLibraryContainer = sal_True;
+	Reference<  XBasicLibraryInfo > xLibInfo( Event.Source, UNO_QUERY );
 
 	if( bLibContainer )
 	{
@@ -282,8 +300,6 @@ void SAL_CALL BasMgrContainerListenerImp
 	}
 	else
 	{
-		::rtl::OUString aMod;
-		Event.Element >>= aMod;
 
 		StarBASIC* pLib = mpMgr->GetLib( maLibName );
 		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -292,7 +308,17 @@ void SAL_CALL BasMgrContainerListenerImp
     		SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-			    pLib->MakeModule32( aName, aMod );
+        		::rtl::OUString aMod;
+        		Event.Element >>= aMod;
+                if ( xLibInfo.is() && xLibInfo->getVBACompatMode() )
+                {
+                    ModuleInfo mInfo = xLibInfo->getModuleInfo( aName );
+                    pLib->MakeModule32( mInfo, aMod );
+                }
+                else
+                {
+			        pLib->MakeModule32( aName, aMod );
+                }
 			    pLib->SetModified( FALSE );
             }
 		}
@@ -316,15 +342,26 @@ void SAL_CALL BasMgrContainerListenerImp
     DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
 
 	StarBASIC* pLib = mpMgr->GetLib( maLibName );
+    
 	if( pLib )
 	{
-		SbModule* pMod = pLib->FindModule( aName );
+	    SbModule* pMod = pLib->FindModule( aName );
 		::rtl::OUString aMod;
-		Event.Element >>= aMod;
+        Event.Element >>= aMod;
+
 		if( pMod )
 			pMod->SetSource32( aMod );
-		else
-			pLib->MakeModule32( aName, aMod );
+        else
+        {
+			Reference<  XBasicLibraryInfo > xLibInfo( Event.Source, UNO_QUERY );
+			if (  xLibInfo.is() && xLibInfo->getVBACompatMode() )
+ 			{
+                ModuleInfo mInfo = xLibInfo->getModuleInfo( aName );
+				pLib->MakeModule32( mInfo, aMod );
+            }
+            else
+                pLib->MakeModule32( aName, aMod );
+        }
 
 		pLib->SetModified( FALSE );
 	}
diff --git basic/source/classes/sb.cxx basic/source/classes/sb.cxx
index f65c6ca..ac067de 100644
--- basic/source/classes/sb.cxx
+++ basic/source/classes/sb.cxx
@@ -52,12 +52,17 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
 #include <basrid.hxx>
 #include <vos/mutex.hxx>
 
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+using namespace ::com::sun::star::script;
+
 // #pragma SW_SEGMENT_CLASS( SBASIC, SBASIC_CODE )
 
 SV_IMPL_VARARR(SbTextPortions,SbTextPortion)
@@ -249,6 +254,8 @@ SbxObject* SbiFactory::CreateObject( con
 	else
 	if( rClass.EqualsIgnoreCaseAscii( "Collection" ) )
 	{
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
 		String aCollectionName( RTL_CONSTASCII_USTRINGPARAM("Collection") );
 		return new BasicCollection( aCollectionName );
 	}
@@ -446,6 +453,7 @@ SbClassModuleObject::SbClassModuleObject
 			}
 		}
 	}
+	SetModuleType( com::sun::star::script::ModuleType::Class );
 }
 
 SbClassModuleObject::~SbClassModuleObject()
@@ -581,6 +589,7 @@ StarBASIC::StarBASIC( StarBASIC* p, BOOL
 	SetParent( p );
 	pLibInfo = NULL;
 	bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
 	pModules = new SbxArray;
 
 	if( !GetSbData()->nInst++ )
@@ -683,12 +692,37 @@ SbModule* StarBASIC::MakeModule( const S
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-	SbModule* p = new SbModule( rName );
+    ModuleInfo mInfo;
+    mInfo.ModuleType = ModuleType::Normal;
+    mInfo.ModuleName = rName;
+    return MakeModule32(  mInfo, rSrc );
+}
+SbModule* StarBASIC::MakeModule32( const ModuleInfo& mInfo, const ::rtl::OUString& rSrc )
+{
+    
+    OSL_TRACE("create module %s type mInfo %d", rtl::OUStringToOString( mInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr(), mInfo.ModuleType );
+    SbModule* p = NULL;
+    switch ( mInfo.ModuleType )
+    {
+        case ModuleType::Document:
+            // In theory we should be able to create Object modules
+            // in ordinary basic ( in vba mode thought these are create
+            // by the application/basic and not by the user )
+            p = new SbObjModule( mInfo, isVBAEnabled() );
+            break;
+        case ModuleType::Class:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+			p->SetModuleType( com::sun::star::script::ModuleType::Class );	
+	    break;
+        default:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+            
+    }
 	p->SetSource32( rSrc );
 	p->SetParent( this );
 	pModules->Insert( p, pModules->Count() );
 	SetModified( TRUE );
-	return p;
+    return p;
 }
 
 void StarBASIC::Insert( SbxVariable* pVar )
@@ -862,6 +896,12 @@ SbxVariable* StarBASIC::Find( const Stri
 				}
 				pNamed = p;
 			}
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
+			INT32 nType = p->GetModuleType();
+            //if ( nType == com::sun::star::script::ModuleType::Class || nType == com::sun::star::script::ModuleType::Document )
+            if ( nType == com::sun::star::script::ModuleType::Document )
+                continue;
 			// Sonst testen, ob das Element vorhanden ist
 			// GBLSEARCH-Flag rausnehmen (wg. Rekursion)
 			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
diff --git basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
index 42c4536..8ea4b64 100644
--- basic/source/classes/sbxmod.cxx
+++ basic/source/classes/sbxmod.cxx
@@ -51,6 +51,8 @@
 #include <basic/hilight.hxx>
 #include <basic/basrdll.hxx>
 #include <vos/mutex.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 // for the bsearch
 #ifdef WNT
@@ -65,6 +67,17 @@
 
 #include <stdio.h>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/awt/XDialogProvider.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <comphelper/anytostring.hxx>
+
+using namespace ::com::sun::star; 
 
 TYPEINIT1(SbModule,SbxObject)
 TYPEINIT1(SbMethod,SbxMethod)
@@ -72,6 +85,7 @@ TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -221,12 +235,13 @@ extern "C" int CDECL compare_strings( co
 // Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
 // Elemente von anderen Modulen aus gefunden werden koennen.
 
-SbModule::SbModule( const String& rName )
+SbModule::SbModule( const String& rName, bool bVBACompat )
 		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( false )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( bVBACompat ),  pDocObject( NULL ), bIsProxyModule( false )
 {
 	SetName( rName );
 	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	SetModuleType( com::sun::star::script::ModuleType::Normal );
 }
 
 SbModule::~SbModule()
@@ -401,7 +416,10 @@ void SbModule::Clear()
 
 SbxVariable* SbModule::Find( const XubString& rName, SbxClassType t )
 {
+	// make sure a search in an uninstatiated class module will fail
 	SbxVariable* pRes = SbxObject::Find( rName, t );
+	if ( bIsProxyModule )
+		return NULL;
 	if( !pRes && pImage )
 	{
 		SbiInstance* pInst = pINST;
@@ -561,6 +579,7 @@ void SbModule::SetSource32( const ::rtl:
 	aOUSource = r;
 	StartDefinitions();
 	SbiTokenizer aTok( r );
+        aTok.SetCompatible( IsVBACompat() );
 	while( !aTok.IsEof() )
 	{
 		SbiToken eEndTok = NIL;
@@ -585,14 +604,6 @@ void SbModule::SetSource32( const ::rtl:
 				{
 					eEndTok = ENDPROPERTY; break;
 				}
-				if( eCurTok == OPTION )
-				{
-					eCurTok = aTok.Next();
-					mbVBACompat = ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 );
-					if( eCurTok == COMPATIBLE 
-					|| mbVBACompat )
-						aTok.SetCompatible( true );
-				}
 			}
 			eLastTok = eCurTok;
 		}
@@ -731,10 +742,19 @@ void ClearUnoObjectsInRTL_Impl( StarBASI
     if( ((StarBASIC*)p) != pBasic )
 	    ClearUnoObjectsInRTL_Impl_Rek( (StarBASIC*)p );
 }
+bool SbModule::IsVBACompat()
+{
+	return mbVBACompat;
+}
 
+void SbModule::SetVBACompat( bool bCompat )
+{
+	mbVBACompat = bCompat;
+}
 // Ausfuehren eines BASIC-Unterprogramms
 USHORT SbModule::Run( SbMethod* pMeth )
 {
+	OSL_TRACE("About to run %s, vba compatmode is %d", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), mbVBACompat );
 	static USHORT nMaxCallLevel = 0;
 	static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
 	static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
@@ -826,10 +846,10 @@ USHORT SbModule::Run( SbMethod* pMeth )
 			if( pRt->pNext )
 				pRt->pNext->block();
 			pINST->pRun = pRt;
-			if ( SbiRuntime ::isVBAEnabled() )
+			if ( mbVBACompat )
                         {
 				pINST->EnableCompatibility( TRUE );
-				pRt->SetVBAEnabled( true );
+				//pRt->SetVBAEnabled( true ); // can we get rid of this
                         }
 			while( pRt->Step() ) {}
 			if( pRt->pNext )
@@ -1404,7 +1424,6 @@ BOOL SbModule::LoadBinaryData( SvStream&
     return bRet;
 }
 
-
 BOOL SbModule::LoadCompleted()
 {
 	SbxArray* p = GetMethods();
@@ -2207,6 +2226,53 @@ SbJScriptMethod::~SbJScriptMethod()
 
 
 /////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible )
+    : SbModule( mInfo.ModuleName, bIsVbaCompatible )
+{
+    SetModuleType( mInfo.ModuleType );
+    if ( mInfo.ModuleType == script::ModuleType::Form )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Form" ) );
+    }
+    else if ( mInfo.ModuleObject.is() )
+        SetUnoObject( uno::makeAny( mInfo.ModuleObject ) );
+}
+void
+SbObjModule::SetUnoObject( const uno::Any& aObj ) throw ( uno::RuntimeException )
+{
+    SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxVariable*)pDocObject);
+    if ( pUnoObj && pUnoObj->getUnoAny() == aObj ) // object is equal, nothing to do
+        return;
+    pDocObject = new SbUnoObject( GetName(), uno::makeAny( aObj ) );
+            
+    com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObj, com::sun::star::uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Worksheet" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
+    }
+    else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "org.openoffice.excel.Workbook" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
+    }
+}
+
+SbxVariable*
+SbObjModule::GetObject() 
+{
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    //OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+        pVar = pDocObject->Find( rName, t );
+    if ( !pVar )
+        pVar = SbModule::Find( rName, t );
+    return pVar;
+}
+/////////////////////////////////////////////////////////////////////////
 
 SbProperty::SbProperty( const String& r, SbxDataType t, SbModule* p )
 		: SbxProperty( r, t ), pMod( p )
diff --git basic/source/comp/codegen.cxx basic/source/comp/codegen.cxx
index 9f88fb6..4674134 100644
--- basic/source/comp/codegen.cxx
+++ basic/source/comp/codegen.cxx
@@ -130,12 +130,12 @@ void SbiCodeGen::Save()
 	// OPTION EXPLICIT-Flag uebernehmen
 	if( pParser->bExplicit )
 		p->SetFlag( SBIMG_EXPLICIT );
-	if( pParser->IsVBASupportOn() )
-		p->SetFlag( SBIMG_VBASUPPORT );
 	
 	int nIfaceCount = 0;
-	if( pParser->bClassModule )
+	if( rMod.mnType == com::sun::star::script::ModuleType::Class )
 	{
+                OSL_TRACE("COdeGen::save() classmodule processing");
+		rMod.bIsProxyModule = true;
 		p->SetFlag( SBIMG_CLASSMODULE );
 		pCLASSFAC->AddClassModule( &rMod );
 
@@ -158,6 +158,10 @@ void SbiCodeGen::Save()
 	else
 	{
 		pCLASSFAC->RemoveClassModule( &rMod );
+		// Only a ClassModule can revert to Normal
+                if ( rMod.mnType == com::sun::star::script::ModuleType::Class )
+			rMod.mnType = com::sun::star::script::ModuleType::Normal;
+		rMod.bIsProxyModule = false;
 	}
 	if( pParser->bText )
 		p->SetFlag( SBIMG_COMPARETEXT );
@@ -240,6 +244,8 @@ void SbiCodeGen::Save()
 					if( nPass == 1 )
 						aPropName = aPropName.Copy( aIfaceName.Len() + 1 );
 					SbProcedureProperty* pProcedureProperty = NULL;
+                                        OSL_TRACE("*** getProcedureProperty for thing %s",
+						rtl::OUStringToOString( aPropName,RTL_TEXTENCODING_UTF8 ).getStr() );
 					pProcedureProperty = rMod.GetProcedureProperty( aPropName, ePropType );
 				}
 				if( nPass == 1 )
diff --git basic/source/comp/parser.cxx basic/source/comp/parser.cxx
index 3259f77..1a4dc06 100644
--- basic/source/comp/parser.cxx
+++ basic/source/comp/parser.cxx
@@ -145,7 +145,8 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 	bNewGblDefs =
 	bSingleLineIf =
 	bExplicit = FALSE;
-	bClassModule = FALSE;
+	bClassModule = ( pm->GetModuleType() == com::sun::star::script::ModuleType::Class );
+	OSL_TRACE("Parser - %s, bClassModule %d", rtl::OUStringToOString( pm->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), bClassModule );
 	pPool	 = &aPublics;
 	for( short i = 0; i < 26; i++ )
 		eDefTypes[ i ] = SbxVARIANT;    // Kein expliziter Defaulttyp
@@ -158,6 +159,10 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 
 	rTypeArray = new SbxArray; // Array fuer Benutzerdefinierte Typen
 	rEnumArray = new SbxArray; // Array for Enum types
+	bVBASupportOn = pm->IsVBACompat();
+	if ( bVBASupportOn )
+		EnableCompatibility();
+
 }
 
 
@@ -778,8 +783,9 @@ void SbiParser::Option()
 
 		case CLASSMODULE:
 			bClassModule = TRUE; 
+			aGen.GetModule().SetModuleType( com::sun::star::script::ModuleType::Class );
 			break;
-		case VBASUPPORT:
+		case VBASUPPORT: // Option VBASupport used to override the module mode ( in fact this must reset the mode
 			if( Next() == NUMBER )
 			{
 				if ( nVal == 1 || nVal == 0 )
@@ -787,6 +793,10 @@ void SbiParser::Option()
 					bVBASupportOn = ( nVal == 1 );
 					if ( bVBASupportOn )
 						EnableCompatibility();
+					// if the module setting is different
+					// reset it to what the Option tells us
+					if ( bVBASupportOn != aGen.GetModule().IsVBACompat() )
+						aGen.GetModule().SetVBACompat( bVBASupportOn );
 					break;
 				}
 			}
diff --git basic/source/inc/codegen.hxx basic/source/inc/codegen.hxx
index ad11d02..a054af7 100644
--- basic/source/inc/codegen.hxx
+++ basic/source/inc/codegen.hxx
@@ -56,6 +56,7 @@ public:
 	void GenStmnt();			// evtl. Statement-Opcode erzeugen
 	UINT32 GetPC();
 	UINT32 GetOffset()				{ return GetPC() + 1; }
+    SbModule& GetModule() { return rMod; } 
 	void Save();
 
 	// #29955 for-Schleifen-Ebene pflegen
diff --git basic/source/inc/image.hxx basic/source/inc/image.hxx
index 8a454cf..c371a85 100644
--- basic/source/inc/image.hxx
+++ basic/source/inc/image.hxx
@@ -109,6 +109,5 @@ public:
 #define	SBIMG_COMPARETEXT	0x0002	// OPTION COMPARE TEXT ist aktiv
 #define	SBIMG_INITCODE		0x0004	// Init-Code vorhanden
 #define	SBIMG_CLASSMODULE	0x0008	// OPTION ClassModule is active
-#define	SBIMG_VBASUPPORT	0x0020	// OPTION VBASupport is 1
 
 #endif
diff --git basic/source/inc/namecont.hxx basic/source/inc/namecont.hxx
index 24778f7..f2760b8 100644
--- basic/source/inc/namecont.hxx
+++ basic/source/inc/namecont.hxx
@@ -39,6 +39,7 @@
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/script/XLibraryContainerExport.hpp>
 #include <com/sun/star/script/XLibraryQueryExecutable.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/container/XContainer.hpp>
 #include <com/sun/star/ucb/XSimpleFileAccess.hpp>
@@ -573,6 +574,8 @@ private:
 protected:
     inline  sal_Bool    implIsModified() const  { return mbIsModified; }
             void        implSetModified( sal_Bool _bIsModified );
+typedef std::hash_map< rtl::OUString, com::sun::star::script::ModuleInfo, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameToInfoHash;
+    NameToInfoHash hBasicInfo;
 
 private:
     /** checks whether the lib is readonly, or a readonly link, throws an IllegalArgumentException if so
diff --git basic/source/inc/scriptcont.hxx basic/source/inc/scriptcont.hxx
index 1679b30..9a7bb87 100644
--- basic/source/inc/scriptcont.hxx
+++ basic/source/inc/scriptcont.hxx
@@ -33,6 +33,9 @@
 
 #include "namecont.hxx"
 #include <basic/basmgr.hxx>
+#include <com/sun/star/script/XBasicLibraryInfo.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <comphelper/uno3.hxx>
 
 class BasicManager;
 
@@ -139,13 +142,17 @@ public:
 };
 
 //============================================================================
+typedef std::hash_map< rtl::OUString, com::sun::star::script::ModuleInfo, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameToInfoHash;
 
+typedef ::cppu::ImplHelper1 <  ::com::sun::star::script::XBasicLibraryInfo >  SfxScriptLibrary_BASE;
 class SfxScriptLibrary : public SfxLibrary
+			, public SfxScriptLibrary_BASE
 {
     friend class SfxScriptLibraryContainer;
 
 	sal_Bool mbLoadedSource;
 	sal_Bool mbLoadedBinary;
+	sal_Bool mbVBA;
 
 	// Provide modify state including resources
 	virtual sal_Bool isModified( void );
@@ -171,9 +178,36 @@ public:
 	    const ::com::sun::star::uno::Reference< ::com::sun::star::ucb::XSimpleFileAccess >& xSFI,
         const ::rtl::OUString& aLibInfoFileURL, const ::rtl::OUString& aStorageURL, sal_Bool ReadOnly
     );
-
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString& aName, const ::com::sun::star::uno::Any& aElement ) 
+		throw(::com::sun::star::lang::IllegalArgumentException, 
+			  ::com::sun::star::container::NoSuchElementException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException);
+
+    // Methods XNameContainer
+    virtual void SAL_CALL insertByName( const ::rtl::OUString& aName, const ::com::sun::star::uno::Any& aElement )
+		throw(::com::sun::star::lang::IllegalArgumentException, 
+			  ::com::sun::star::container::ElementExistException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& Name ) 
+		throw(::com::sun::star::container::NoSuchElementException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException);
     static bool containsValidModule( const ::com::sun::star::uno::Any& _rElement );
+    DECLARE_XINTERFACE()
+    DECLARE_XTYPEPROVIDER()
+
+    // XBasicLibraryInfo
+ 
+    // Attributes
+    virtual ::sal_Bool SAL_CALL getVBACompatMode() throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setVBACompatMode( ::sal_Bool _vbacompatmodeon ) throw (::com::sun::star::uno::RuntimeException);
 
+    // Methods
+    virtual ::com::sun::star::script::ModuleInfo SAL_CALL getModuleInfo( const ::rtl::OUString& ModuleName ) throw (::com::sun::star::uno::RuntimeException);
+    
 protected:
 	virtual bool SAL_CALL isLibraryElementValid( ::com::sun::star::uno::Any aElement ) const;
 };
diff --git basic/source/runtime/methods1.cxx basic/source/runtime/methods1.cxx
index e72f78b..bb24705 100644
--- basic/source/runtime/methods1.cxx
+++ basic/source/runtime/methods1.cxx
@@ -44,6 +44,7 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#include <basic/sbstar.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/fsys.hxx>
 #include <tools/urlobj.hxx>
@@ -64,6 +65,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -2594,14 +2596,14 @@ RTLFUNC(Me)
 
 	SbModule* pActiveModule = pINST->GetActiveModule();
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
+    SbxVariableRef refVar = rPar.Get(0);
 	if( pClassModuleObject == NULL )
 	{
-		StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod )
+            refVar->PutObject( pMod );
 	}
 	else
-	{
-		SbxVariableRef refVar = rPar.Get(0);
 		refVar->PutObject( pClassModuleObject );
-	}
 }
 
diff --git basic/source/runtime/runtime.cxx basic/source/runtime/runtime.cxx
index 07f70a6..69c75b3 100644
--- basic/source/runtime/runtime.cxx
+++ basic/source/runtime/runtime.cxx
@@ -55,7 +55,8 @@ bool SbiRuntime::isVBAEnabled()
 	bool result = false;
 	SbiInstance* pInst = pINST;
 	if ( pInst && pINST->pRun )
-		result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		//result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		result = pInst->pRun->bVBAEnabled;
 	return result; 
 }
 
@@ -66,6 +67,24 @@ void StarBASIC::StaticEnableReschedule( 
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    if ( bDocBasic )
+    {
+        bVBAEnabled = bEnabled;
+    }
+}
+
+BOOL StarBASIC::isVBAEnabled()
+{
+    if ( bDocBasic )
+    { 
+        if( SbiRuntime::isVBAEnabled() )
+            return TRUE;
+        return bVBAEnabled;
+    }
+    return FALSE;
+}
 
 
 struct SbiArgvStack {					// Argv stack:
@@ -522,6 +541,7 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 	nForLvl   = 0;
 	nOps	  = 0;
 	refExprStk = new SbxArray;
+	SetVBAEnabled( pMod->IsVBACompat() );
 #if defined GCC
 	SetParameters( pe ? pe->GetParameters() : (class SbxArray *)NULL );
 #else
@@ -529,7 +549,6 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
-	bVBAEnabled = isVBAEnabled();
 }
 
 SbiRuntime::~SbiRuntime()
diff --git basic/source/uno/namecont.cxx basic/source/uno/namecont.cxx
index 7af486f..a777d23 100644
--- basic/source/uno/namecont.cxx
+++ basic/source/uno/namecont.cxx
@@ -75,7 +75,8 @@
 #endif
 #include <cppuhelper/exc_hlp.hxx>
 #include <basic/sbmod.hxx>
-
+#include "sbunoobj.hxx"
+#include <com/sun/star/script/XBasicLibraryInfo.hpp>
 
 namespace basic
 {
@@ -1721,10 +1722,17 @@ void SfxLibraryContainer::implImportLibD
     {
 	    sal_Int32 nElementCount = rLib.aElementNames.getLength();
 	    const OUString* pElementNames = rLib.aElementNames.getConstArray();
+            Reference< XNameContainer > xLib( pLib );
+            Reference< XBasicLibraryInfo > xLibInfo( xLib, UNO_QUERY );
 	    Any aDummyElement = createEmptyLibraryElement();
 	    for( sal_Int32 i = 0 ; i < nElementCount ; i++ )
 	    {
+                    // default the module type
+                    com::sun::star::script::ModuleInfo mInfo;
+                    mInfo.ModuleType = ModuleType::Normal;         
+
 		    pLib->maNameContainer.insertByName( pElementNames[i], aDummyElement );
+                    pLib->hBasicInfo[  pElementNames[i] ] = mInfo;
 	    }
         pLib->mbPasswordProtected = rLib.bPasswordProtected;
         pLib->mbReadOnly = rLib.bReadOnly;
@@ -2069,11 +2077,11 @@ Reference< XNameContainer > SAL_CALL Sfx
 {
     LibraryContainerMethodGuard aGuard( *this );
 	SfxLibrary* pNewLib = implCreateLibrary( Name );
+	Reference< XNameAccess > xNameAccess = static_cast< XNameAccess* >( pNewLib );
     pNewLib->maLibElementFileExtension = maLibElementFileExtension;
 
 	createVariableURL( pNewLib->maUnexpandedStorageURL, Name, maInfoFileName, true );
 
-	Reference< XNameAccess > xNameAccess = static_cast< XNameAccess* >( pNewLib );
 	Any aElement;
 	aElement <<= xNameAccess;
 	maNameContainer.insertByName( Name, aElement );
@@ -2099,6 +2107,7 @@ Reference< XNameAccess > SAL_CALL SfxLib
 
 
 	SfxLibrary* pNewLib = implCreateLibraryLink( Name, aLibInfoFileURL, aLibDirURL, ReadOnly );
+    Reference< XNameAccess > xRet = static_cast< XNameAccess* >( pNewLib );
     pNewLib->maLibElementFileExtension = maLibElementFileExtension;
     pNewLib->maUnexpandedStorageURL = aUnexpandedStorageURL;
 
@@ -2108,7 +2117,6 @@ Reference< XNameAccess > SAL_CALL SfxLib
     /*sal_Bool bReadIndexFile = */implLoadLibraryIndexFile( pNewLib, aLibDesc, xDummyStor, aInitFileName );
     implImportLibDescriptor( pNewLib, aLibDesc );
 
-	Reference< XNameAccess > xRet = static_cast< XNameAccess* >( pNewLib );
 	Any aElement;
 	aElement <<= xRet;
 	maNameContainer.insertByName( Name, aElement );
diff --git basic/source/uno/scriptcont.cxx basic/source/uno/scriptcont.cxx
index f47dc64..e64041a 100644
--- basic/source/uno/scriptcont.cxx
+++ basic/source/uno/scriptcont.cxx
@@ -57,7 +57,7 @@
 // For password functionality
 #include <tools/urlobj.hxx>
 
-
+#include <com/sun/star/script/ModuleSourceInfo.hpp>
 #include <svtools/pathoptions.hxx>
 #include <svtools/sfxecode.hxx>
 #include <svtools/ehdl.hxx>
@@ -214,6 +214,7 @@ void SAL_CALL SfxScriptLibraryContainer:
 	xmlscript::ModuleDescriptor aMod;
 	aMod.aName = aElementName;
 	aMod.aLanguage = maScriptLanguage;
+	// make sure we export source
 	aElement >>= aMod.aCode;
 	xmlscript::exportScriptModule( xHandler, aMod );
 }
@@ -1120,6 +1121,7 @@ SfxScriptLibrary::SfxScriptLibrary( Modi
 	: SfxLibrary( _rModifiable, getCppuType( (const OUString *)0 ), xMSF, xSFI )
     , mbLoadedSource( sal_False )
     , mbLoadedBinary( sal_False )
+    , mbVBA( sal_False )
 {
 }
 
@@ -1133,9 +1135,86 @@ SfxScriptLibrary::SfxScriptLibrary( Modi
 						aLibInfoFileURL, aStorageURL, ReadOnly)
     , mbLoadedSource( sal_False )
     , mbLoadedBinary( sal_False )
+    , mbVBA( sal_False )
+{
+}
+
+IMPLEMENT_FORWARD_XINTERFACE2( SfxScriptLibrary, SfxLibrary, SfxScriptLibrary_BASE );
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( SfxScriptLibrary, SfxLibrary, SfxScriptLibrary_BASE );
+
+::sal_Bool SAL_CALL 
+SfxScriptLibrary::getVBACompatMode() throw (RuntimeException)
+{
+    return mbVBA;
+}
+
+void SAL_CALL 
+SfxScriptLibrary::setVBACompatMode( ::sal_Bool _vbacompatmodeon ) throw (RuntimeException)
+{
+    mbVBA = _vbacompatmodeon;
+}
+
+// Methods
+::com::sun::star::script::ModuleInfo SAL_CALL 
+SfxScriptLibrary::getModuleInfo( const ::rtl::OUString& ModuleName ) throw (RuntimeException)
+{
+	::com::sun::star::script::ModuleInfo mInfo;
+	NameToInfoHash::iterator it_end = hBasicInfo.end();
+	NameToInfoHash::iterator it = hBasicInfo.find( ModuleName );
+	if ( it != it_end )
+		mInfo = it->second;
+
+	return mInfo;
+}
+
+void SAL_CALL 
+SfxScriptLibrary::replaceByName( const ::rtl::OUString& aName, const ::com::sun::star::uno::Any& aElement ) 
+		throw(::com::sun::star::lang::IllegalArgumentException, 
+			  ::com::sun::star::container::NoSuchElementException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException)
 {
+	SfxLibrary::replaceByName( aName, aElement );
 }
 
+// Methods XNameContainer
+void SAL_CALL 
+SfxScriptLibrary::insertByName( const ::rtl::OUString& aName, const ::com::sun::star::uno::Any& aElement )
+		throw(::com::sun::star::lang::IllegalArgumentException, 
+			  ::com::sun::star::container::ElementExistException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException)
+{
+    OSL_TRACE("***** insertByName module %s", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+	NameToInfoHash::iterator it_end = hBasicInfo.end();
+	NameToInfoHash::iterator it = hBasicInfo.find( aName );
+
+	if ( it != it_end )
+		throw ElementExistException(); // more detail please
+
+	ModuleSourceInfo mInfo;
+	if ( aElement >>= mInfo )
+	{
+		hBasicInfo[ aName ] = mInfo;
+		uno::Any aTmpElement( mInfo.ModuleSource );
+		SfxLibrary::insertByName( aName, aTmpElement );
+	}
+	else
+		SfxLibrary::insertByName( aName, aElement );
+}
+
+void SAL_CALL 
+SfxScriptLibrary::removeByName( const ::rtl::OUString& Name ) 
+		throw(::com::sun::star::container::NoSuchElementException, 
+			  ::com::sun::star::lang::WrappedTargetException, 
+			  ::com::sun::star::uno::RuntimeException)
+{
+	SfxLibrary::removeByName( Name );
+}
+
+
+
 // Provide modify state including resources
 sal_Bool SfxScriptLibrary::isModified( void )
 {
diff --git offapi/com/sun/star/script/XBasicLibraryInfo.idl offapi/com/sun/star/script/XBasicLibraryInfo.idl
new file mode 100644
index 0000000..0086a1b
--- /dev/null
+++ offapi/com/sun/star/script/XBasicLibraryInfo.idl
@@ -0,0 +1,19 @@
+#ifndef __com_sun_star_script_XBasicLibraryInfo_idl__ 
+#define __com_sun_star_script_XBasicLibraryInfo_idl__ 
+  
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#include <com/sun/star/script/ModuleInfo.idl> 
+#endif 
+module com {  module sun {  module star {  module script {  
+  
+interface XBasicLibraryInfo: com::sun::star::uno::XInterface
+{ 
+ 
+//============================================================================= 
+    [attribute ] boolean VBACompatMode;
+    ModuleInfo getModuleInfo( [in] string ModuleName );
+  
+}; }; }; };  
+}; 
diff --git sc/inc/servuno.hxx sc/inc/servuno.hxx
index a0e7f94..11bbabc 100644
--- sc/inc/servuno.hxx
+++ sc/inc/servuno.hxx
@@ -93,8 +93,8 @@ class ScDocShell;
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
-
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
diff --git sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
index 0df678a..aff8877 100644
--- sc/source/filter/excel/excimp8.cxx
+++ sc/source/filter/excel/excimp8.cxx
@@ -103,6 +103,7 @@
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 
 using namespace com::sun::star;
@@ -110,8 +111,8 @@ using namespace com::sun::star;
 
 #define	INVALID_POS		0xFFFFFFFF
 
-
-
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
     ImportExcel( rImpData, rStrm ), mnTab(0)
@@ -273,6 +274,7 @@ bool lcl_hasVBAEnabled()
 
 void ImportExcel8::ReadBasic( void )
 {
+    //bHasBasic = TRUE;
     bHasBasic = TRUE;
 
     SfxObjectShell* pShell = GetDocShell();
@@ -302,6 +304,10 @@ void ImportExcel8::EndSheet( void )
 
 void ImportExcel8::PostDocLoad( void )
 {
+    // delay reading basic until sheet object ( codenames etc. ) are read
+
+    if ( bHasBasic ) 
+        ReadBasic();
     // #i11776# filtered ranges before outlines and hidden rows
     if( pExcRoot->pAutoFilterBuffer )
         pExcRoot->pAutoFilterBuffer->Apply();
diff --git sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
index 0fef232..a868e17 100644
--- sc/source/filter/excel/read.cxx
+++ sc/source/filter/excel/read.cxx
@@ -947,7 +947,8 @@ FltError ImportExcel8::Read( void )
 					case 0x22:	Rec1904(); break;		// 1904			[ 2345   ]
 					case 0x56:	Builtinfmtcnt(); break;	// BUILTINFMTCNT[  34    ]
 					case 0x8D:	Hideobj(); break;		// HIDEOBJ		[  345   ]
-					case 0xD3:	ReadBasic(); break;
+					case 0xD3:	/*ReadBasic()*/bHasBasic = true; break;
+//					case 0xD3:	ReadBasic(); break;
                     case 0xDE:  Olesize(); break;
 					case 0x01BA: Codename( TRUE ); break;
 
diff --git sc/source/filter/excel/xiescher.cxx sc/source/filter/excel/xiescher.cxx
index 9c687ed..c8339df 100644
--- sc/source/filter/excel/xiescher.cxx
+++ sc/source/filter/excel/xiescher.cxx
@@ -834,7 +834,7 @@ bool XclImpTbxControlObj::FillMacroDescr
         {
             // set the macro name
             rEvent.ScriptType = XclControlObjHelper::GetTbxScriptType();
-            rEvent.ScriptCode = XclControlObjHelper::GetScMacroName( GetMacroName() );
+            rEvent.ScriptCode = XclControlObjHelper::GetScMacroName( GetMacroName(), GetDocShell() );
             return true;
         }
     }
@@ -1728,7 +1728,7 @@ SdrObject* XclImpDffManager::ProcessObj(
             if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( xSdrObj.get(), TRUE ) )
             {
                 if ( rMacro.Len() > 0 )
-                pInfo->SetMacro( XclControlObjHelper::GetScMacroName( rMacro ) );
+                pInfo->SetMacro( XclControlObjHelper::GetScMacroName( rMacro, GetDocShell() ) );
                 if ( aHlink.getLength() > 0 )
                 pInfo->SetHlink( aHlink );
             }
diff --git sc/source/filter/excel/xlescher.cxx sc/source/filter/excel/xlescher.cxx
index 8e8e694..693a323 100644
--- sc/source/filter/excel/xlescher.cxx
+++ sc/source/filter/excel/xlescher.cxx
@@ -37,7 +37,10 @@
 #include "xistream.hxx"
 #include "xestream.hxx"
 #include "globstr.hrc"
-
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::UNO_QUERY;
@@ -405,9 +408,16 @@ OUString XclControlObjHelper::GetTbxScri
 #define EXC_TBX_MACRONAME_PRE "vnd.sun.star.script:Standard."
 #define EXC_TBX_MACRONAME_SUF "?language=Basic&location=document"
 
-OUString XclControlObjHelper::GetScMacroName( const String& rXclMacroName )
+OUString XclControlObjHelper::GetScMacroName( const String& rXclMacroName, SfxObjectShell* pDocShell )
 {
-    return CREATE_OUSTRING( EXC_TBX_MACRONAME_PRE ) + rXclMacroName + CREATE_OUSTRING( EXC_TBX_MACRONAME_SUF );
+    String sTmp( rXclMacroName );
+    if (  ( sTmp.Search( '.' ) == STRING_NOTFOUND) && pDocShell )
+                    if( StarBASIC* pBasic = pDocShell->GetBasic() )
+                        if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sTmp, SbxCLASS_METHOD ) ) )
+                            if( SbModule* pModule = pMethod->GetModule() )
+                                sTmp.Insert( '.', 0 ).Insert( pModule->GetName(), 0 );
+    
+    return CREATE_OUSTRING( EXC_TBX_MACRONAME_PRE ) + sTmp + CREATE_OUSTRING( EXC_TBX_MACRONAME_SUF );
 }
 
 String XclControlObjHelper::GetXclMacroName( const OUString& rScMacroName )
diff --git sc/source/filter/inc/xlescher.hxx sc/source/filter/inc/xlescher.hxx
index e28b1c4..9263024 100644
--- sc/source/filter/inc/xlescher.hxx
+++ sc/source/filter/inc/xlescher.hxx
@@ -278,7 +278,7 @@ public:
     static ::rtl::OUString GetTbxScriptType();
 
     /** Returns the Calc macro name from an Excel macro name. */
-    static ::rtl::OUString GetScMacroName( const String& rXclMacroName );
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
     /** Returns the Excel macro name from a Calc macro name. */
     static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
 };
diff --git sc/source/ui/docshell/docfunc.cxx sc/source/ui/docshell/docfunc.cxx
index d178786..dcedaf3 100644
--- sc/source/ui/docshell/docfunc.cxx
+++ sc/source/ui/docshell/docfunc.cxx
@@ -51,6 +51,12 @@
 #include <svtools/zforlist.hxx>
 #include <svtools/PasswordHelper.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleSourceInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -99,6 +105,7 @@
 using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2021,6 +2028,92 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 }
 
 //------------------------------------------------------------------------
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName )
+{
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    uno::Reference< uno::XInterface > xDocModuleApiObject;
+    if ( xSF.is() )
+    {
+        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+        xDocModuleApiObject.set( xVBACodeNamedObjectAccess->getByName( sCodeName ), uno::UNO_QUERY );    
+    }
+    return xDocModuleApiObject;
+
+}
+
+script::ModuleSourceInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule, String& sSource )
+{
+    ::rtl::OUString aModName( sModule );
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    script::ModuleSourceInfo sModuleInfo;
+    sModuleInfo.ModuleName = aModName;
+    if ( sSource.Len() > 0 )
+        sModuleInfo.ModuleSource = sSource;
+    else
+        sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = script::ModuleType::Document;
+    sModuleInfo.ModuleObject = GetDocModuleObject( rDocSh, sModule );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sSource )
+{
+    SFX_APP()->EnterBasicCall();
+    script::ModuleSourceInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName, sSource );
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // if the Module with codename exists then find a new name
+        sal_Int32 nNum = 1;
+        sModuleInfo.ModuleName = sModuleName;
+        while( xLib->hasByName( sModuleInfo.ModuleName  ) )
+        {
+            sModuleInfo.ModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            nNum += 1;
+        }
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleInfo.ModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleInfo.ModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
@@ -2030,8 +2123,18 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
-	if (bRecord && !pDoc->IsUndoEnabled())
+    // Strange loop, also basic is loaded too early ( InsertTable )
+    // is called via the xml import for sheets in described in odf 
+    BOOL bInsertDocModule = false;
+
+    if(  !rDocShell.GetDocument()->IsImportingXML() )
+    {
+        StarBASIC* pStarBASIC = rDocShell.GetBasic(); 
+        bInsertDocModule = pStarBASIC ? pStarBASIC->isVBAEnabled() : false;
+    }
+	if ( bInsertDocModule || ( bRecord && !pDoc->IsUndoEnabled() ) )
 		bRecord = FALSE;
+
 	if (bRecord)
 		pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2042,10 +2145,19 @@ BOOL ScDocFunc::InsertTable( SCTAB nTab,
 
 	if (pDoc->InsertTab( nTab, rName ))
 	{
+		String sCodeName;
 		if (bRecord)
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
+        // Only insert vba modules if vba mode ( and not currently importing XML )
+        if( bInsertDocModule )
+        {
+            if ( sCodeName.Len() == 0 )
+		sCodeName = rName;
+            String sSource;
+            lcl_InsertModule( rDocShell, nTab, sCodeName, sSource );
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
 		rDocShell.PostPaintExtras();
@@ -2067,8 +2179,12 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
 	BOOL bSuccess = FALSE;
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	BOOL bWasLinked = pDoc->IsLinked(nTab);
 	ScDocument* pUndoDoc = NULL;
 	ScRefUndoData* pUndoData = NULL;
@@ -2109,6 +2225,8 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 		pUndoData = new ScRefUndoData( pDoc );
 	}
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
 	if (pDoc->DeleteTab( nTab, pUndoDoc ))
 	{
 		if (bRecord)
@@ -2119,6 +2237,13 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 						new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
 		}
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+            }
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
 		if (bWasLinked)
diff --git sc/source/ui/docshell/docsh5.cxx sc/source/ui/docshell/docsh5.cxx
index bbfe6e3..6623a4b 100644
--- sc/source/ui/docshell/docsh5.cxx
+++ sc/source/ui/docshell/docsh5.cxx
@@ -68,6 +68,11 @@
 #include "sc.hrc"
 #include "waitoff.hxx"
 #include "sizedev.hxx"
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleSourceInfo.hpp>
+
+// defined in docfunc.cxx
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sModuleSource );
 
 // ---------------------------------------------------------------------------
 
@@ -834,6 +839,33 @@ BOOL ScDocShell::MoveTable( SCTAB nSrcTa
 				GetUndoManager()->AddUndoAction(
 						new ScUndoCopyTab( this, aSrcList, aDestList ) );
 			}
+			
+			StarBASIC* pStarBASIC = GetBasic();
+			BOOL bVbaEnabled = pStarBASIC ? pStarBASIC->isVBAEnabled() : FALSE;
+			if ( bVbaEnabled )
+			{
+				String sCodeName;
+				String sSource;
+				aDocument.GetCodeName( nDestTab, sCodeName );
+				com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xLibContainer = GetBasicContainer();
+				com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLib;
+    				if( xLibContainer.is() )
+    				{
+        				String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        				com::sun::star::uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        				aLibAny >>= xLib;
+    				}
+    				if( xLib.is() )
+    				{
+					String sSrcCodeName;
+					aDocument.GetCodeName( nSrcTab, sSrcCodeName );
+					rtl::OUString sModName = sSrcCodeName;
+					com::sun::star::script::ModuleSourceInfo sModuleInfo;
+					xLib->getByName( sModName ) >>= sModuleInfo;
+					sSource = sModuleInfo.ModuleSource;
+				} 
+				lcl_InsertModule( *this, nDestTab, sCodeName, sSource );
+			}
 		}
 
 		Broadcast( ScTablesHint( SC_TAB_COPIED, nSrcTab, nDestTab ) );
diff --git sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
index bff687b..013c716 100644
--- sc/source/ui/unoobj/servuno.cxx
+++ sc/source/ui/unoobj/servuno.cxx
@@ -38,6 +38,7 @@
 #include <svx/unofill.hxx>
 #include <svx/unonrule.hxx>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
 
 #include "servuno.hxx"
 #include "unonames.hxx"
@@ -61,8 +62,103 @@
 #include <svx/xmleohlp.hxx>
 #include <svx/xmlgrhlp.hxx>
 
+#include <comphelper/processfactory.hxx>
+
 using namespace ::com::sun::star;
 
+class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    uno::Any maWorkbook;
+    uno::Any maCachedObject;
+    uno::Reference<lang::XMultiServiceFactory> mxSF;
+    ScDocShell* mpDocShell;
+public:
+    ScVbaObjectForCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        mxSF.set(comphelper::getProcessServiceFactory());
+        uno::Reference<beans::XPropertySet> xProps(mxSF, uno::UNO_QUERY);
+        if( xProps.is() )
+        {
+            ScDocument* pDoc = mpDocShell->GetDocument();
+            if ( !pDoc )
+                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
+
+            uno::Sequence< uno::Any > aArgs(2);
+            aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+            aArgs[1] = uno::Any( mpDocShell->GetModel() );
+            maWorkbook <<= mxSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs );
+        }
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        maCachedObject = uno::Any(); // clear cached object
+        String sName = aName;
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        if ( sName == pDoc->GetCodeName() )
+            maCachedObject = maWorkbook;
+        else 
+        {
+            String sCodeName;
+            SCTAB nCount = pDoc->GetTableCount();
+            for( SCTAB i = 0; i < nCount; i++ )
+            {
+                pDoc->GetCodeName( i, sCodeName );
+                if( sCodeName == sName )
+                {
+                    String sSheetName;
+                    if( pDoc->GetName( i, sSheetName ) )
+                    {
+                        uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                        uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                        uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                        uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                        uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                        uno::Sequence< uno::Any > aArgs(3);
+                        aArgs[0] = maWorkbook;
+                        aArgs[1] = uno::Any( xModel );
+                        aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                        maCachedObject <<= mxSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs );
+                        break;
+                    }
+                }
+            }
+        }
+        return maCachedObject.hasValue();
+
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectForCodeNameProvider::getByName( %s )",
+            rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( !hasByName( aName ) )
+            throw ::com::sun::star::container::NoSuchElementException();
+        return maCachedObject;
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        SCTAB nCount = pDoc->GetTableCount();
+        uno::Sequence< rtl::OUString > aNames( nCount + 1 ); 
+        SCTAB index = 0;
+        String sCodeName;
+        for( ; index < nCount; ++index )
+        {
+            pDoc->GetCodeName( index, sCodeName );
+            aNames[ index ] = sCodeName;
+        }
+        aNames[ index ] = pDoc->GetCodeName();
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
 
 //------------------------------------------------------------------------
 
@@ -112,7 +208,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+"org.openoffice.vba.VBAObjectModuleObjectProvider",// SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 //
@@ -164,7 +261,8 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
 	};
 
 
@@ -350,6 +448,9 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<container::XNameAccess*>(new ScVbaObjectForCodeNameProvider( pDocShell )));
+            break;
 	}
 	return xRet;
 }
diff --git sc/source/ui/view/viewfun2.cxx sc/source/ui/view/viewfun2.cxx
index 1ff1ec6..eace21b 100644
--- sc/source/ui/view/viewfun2.cxx
+++ sc/source/ui/view/viewfun2.cxx
@@ -57,6 +57,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2062,15 +2067,42 @@ BOOL ScViewFunc::DeleteTable( SCTAB nTab
 	return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
 	ScDocShell* pDocSh	= GetViewData()->GetDocShell();
 	ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	SCTAB		nNewTab = TheTabs[0];
 	int			i;
 	WaitObject aWait( GetFrameWin() );
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
 	while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
 		--nNewTab;
@@ -2137,9 +2169,18 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
 	for(i=TheTabs.Count()-1;i>=0;i--)
 	{
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
 		{
 			bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
 		}
 	}
@@ -2167,6 +2208,7 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
diff --git svx/source/msfilter/msvbasic.cxx svx/source/msfilter/msvbasic.cxx
index 2e4f500..2eff354 100644
--- svx/source/msfilter/msvbasic.cxx
+++ svx/source/msfilter/msvbasic.cxx
@@ -41,6 +41,8 @@
 #include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
 #include "msvbasic.hxx"
 
+using namespace ::com::sun::star::script;
+
 /*
 A few urls which may in the future be of some use
 http://www.virusbtn.com/vb2000/Programme/papers/bontchev.pdf
@@ -432,7 +434,7 @@ int VBA_Impl::ReadVBAProject(const SvSto
  *
 */
 
-ModuleType VBA_Impl::GetModuleType( const UniString& rModuleName )
+ModType VBA_Impl::GetModuleType( const UniString& rModuleName )
 {
     ModuleTypeHash::iterator iter = mhModHash.find( rModuleName );
     ModuleTypeHash::iterator iterEnd = mhModHash.end();
@@ -440,7 +442,7 @@ ModuleType VBA_Impl::GetModuleType( cons
     {
         return iter->second;
     }
-    return Unknown;
+    return ModuleType::Unknown;
 }
 
 bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
@@ -483,7 +485,7 @@ bool VBA_Impl::Open( const String &rTopl
         static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
         static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
         static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
-        mhModHash[ sThisDoc ] = Class;
+        mhModHash[ sThisDoc ] = ModuleType::Class;
         while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
         {
             xub_StrLen index = tmp.Search( '=' );
@@ -493,14 +495,14 @@ bool VBA_Impl::Open( const String &rTopl
                 String value = tmp.Copy( index + 1 );
                 if ( key == sClass )
                 {
-                    mhModHash[ value ] = Class;
+                    mhModHash[ value ] = ModuleType::Class;
                     OSL_TRACE("Module %s is of type Class",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sBaseClass )
                 {
-                    mhModHash[ value ] =  Form;
+                    mhModHash[ value ] =  ModuleType::Form;
                     OSL_TRACE("Module %s is of type Form",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
@@ -513,14 +515,14 @@ bool VBA_Impl::Open( const String &rTopl
                     // value is of form <name>/&H<identifier>, strip the identifier
                     value.Erase( value.Search( '/' ) );
 
-                    mhModHash[ value ] = Document;
+                    mhModHash[ value ] = ModuleType::Document;
                     OSL_TRACE("Module %s is of type Document VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sModule )
                 {
-                    mhModHash[ value ] = Normal;
+                    mhModHash[ value ] = ModuleType::Normal;
                     OSL_TRACE("Module %s is of type Normal VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
diff --git svx/source/msfilter/msvbasic.hxx svx/source/msfilter/msvbasic.hxx
index 8492062..a0536ae 100644
--- svx/source/msfilter/msvbasic.hxx
+++ svx/source/msfilter/msvbasic.hxx
@@ -45,6 +45,8 @@
 #include <vector>
 #endif
 #include<map>
+#include <com/sun/star/script/ModuleType.hpp>
+using namespace ::com::sun::star::script::ModuleType;
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -68,13 +70,12 @@ DECLARE_DYNARRAY(StringArray,String *)
 // #117718# define internal types to distinguish between
 // module types, form, class & normal
 // #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 // #117718# define map to hold types of module
 //
-
+typedef sal_Int32 ModType;
 typedef ::std::map< UniString,
-    ModuleType > ModuleTypeHash;
+    ModType > ModuleTypeHash;
 
 class VBA_Impl
 {
@@ -95,7 +96,7 @@ public:
     void Output(int len, const sal_uInt8 *data);
     //
     // #117718# member map of module names to types of module
-    ModuleType GetModuleType( const UniString& rModuleName );
+    ModType GetModuleType( const UniString& rModuleName );
 
     std::vector<String> maReferences;
 private:
diff --git svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
index d5878ad..df541c2 100644
--- svx/source/msfilter/svxmsbas.cxx
+++ svx/source/msfilter/svxmsbas.cxx
@@ -53,6 +53,9 @@ using namespace com::sun::star::awt;
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleSourceInfo.hpp>
+#include <com/sun/star/script/XBasicLibraryInfo.hpp>
+
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -266,8 +269,26 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
             Any aLibAny = xLibContainer->getByName( aLibName );
 		    aLibAny >>= xLib;
         }
-		if( xLib.is() )
+		if( xLib.is()  )
 		{
+            Reference< container::XNameAccess > xVBAObjectForCodeName;
+			if ( !bAsComment )
+            {
+                Reference< XBasicLibraryInfo > xInfo( xLib, UNO_QUERY );
+                if( xInfo.is() )
+                    xInfo->setVBACompatMode( sal_True );
+                else
+                    rDocSh.GetBasic()->SetVBAEnabled( true );
+                Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                if ( xSF.is() )
+                {
+                    try
+                    {
+                        xVBAObjectForCodeName.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
+                    }
+                    catch( Exception& ) { }
+                }
+            }
 			for( UINT16 i=0; i<nStreamCount;i++)
 			{
 				StringArray aDecompressed = aVBA.Decompress(i);
@@ -301,7 +322,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 // is the same as the encoding for the names
                 // that are keys in the map used by GetModuleType method
                 const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+                ModType mType = aVBA.GetModuleType( sOrigVBAModName );
 
                 rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
 
@@ -309,23 +330,23 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 
                 switch( mType )
                 {
-                    case Class:
+                    case ModuleType::Class:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
                         break;
-                    case Form:
+                    case ModuleType::Form:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
                         break;
-                    case Document:
+                    case ModuleType::Document:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
                         break;
-                    case Normal:
+                    case ModuleType::Normal:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
                         break;
-                    case Unknown:
+                    case ModuleType::Unknown:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
                         break;
@@ -335,10 +356,10 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                 }
 				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
 				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
+				if ( !bAsComment /*&& !rDocSh.GetBasic()->isVBAEnabled() */)
 				{
 					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
+					if ( mType == ModuleType::Class )
 						modeTypeComment = modeTypeComment + sClassOption;
 
 				}
@@ -405,12 +426,41 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
 				{
 					aSource = modeTypeComment + aSource;
 
 					Any aSourceAny;
-					aSourceAny <<= aSource;
+                    OSL_TRACE("erm %d", mType );
+                    if (  !bAsComment )
+                    {
+                        OSL_TRACE("vba processing  %d", mType );
+                        script::ModuleSourceInfo sModuleInfo;
+                        sModuleInfo.ModuleName = aModName;
+                        sModuleInfo.ModuleSource = aSource;
+                        sModuleInfo.ModuleType = mType;
+                       if ( mType == ModuleType::Form )
+                            // hack, the module ( imo document basic should...
+                            // know the XModel... ) but it doesn't
+                            sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+			//  document modules, we should be able to access
+			//  the api objects at this time
+                        else if ( mType == ModuleType::Document )
+			{
+				uno::Reference< lang::XMultiServiceFactory> xSF( rDocSh.GetModel(), uno::UNO_QUERY);
+				uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    				if ( xSF.is() )
+				        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+				// get the api object for the codename
+				if ( xVBACodeNamedObjectAccess.is() )
+				{
+					sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
+					OSL_TRACE("** Straight up creation of Module");
+				}
+			}
+                        aSourceAny <<= sModuleInfo;
+                    }
+                    else
+					    aSourceAny <<= aSource;
 					if( xLib->hasByName( aModName ) )
 						xLib->replaceByName( aModName, aSourceAny );
 					else
@@ -420,6 +470,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 				bRet = true;
 			}
 		}
+        if( bRet )
 		SFX_APP()->LeaveBasicCall();
 	}
 	return bRet;
diff --git udkapi/com/sun/star/script/ModuleInfo.idl udkapi/com/sun/star/script/ModuleInfo.idl
new file mode 100644
index 0000000..d670ec6
--- /dev/null
+++ udkapi/com/sun/star/script/ModuleInfo.idl
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+struct ModuleInfo
+{
+	string ModuleName; 
+	com::sun::star::uno::XInterface ModuleObject; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git udkapi/com/sun/star/script/ModuleSourceInfo.idl udkapi/com/sun/star/script/ModuleSourceInfo.idl
new file mode 100644
index 0000000..feef569
--- /dev/null
+++ udkapi/com/sun/star/script/ModuleSourceInfo.idl
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleSourceInfo_idl__
+#define __com_sun_star_script_ModuleSourceInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#include <com/sun/star/script/ModuleInfo.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+struct ModuleSourceInfo : ModuleInfo
+{
+	string ModuleSource; 
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git udkapi/com/sun/star/script/ModuleType.idl udkapi/com/sun/star/script/ModuleType.idl
new file mode 100644
index 0000000..3295c52
--- /dev/null
+++ udkapi/com/sun/star/script/ModuleType.idl
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleType.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleType_idl__
+#define __com_sun_star_script_ModuleType_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+published constants ModuleType
+{
+    const long Unknown = 0;
+    const long Normal = 1;  
+    const long Class = 2;
+    const long Form = 3;
+    const long Document = 4;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
diff --git udkapi/com/sun/star/script/makefile.mk udkapi/com/sun/star/script/makefile.mk
index 745df3e..d36f19d 100644
--- udkapi/com/sun/star/script/makefile.mk
+++ udkapi/com/sun/star/script/makefile.mk
@@ -85,6 +85,9 @@ IDLFILES=\
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+    ModuleInfo.idl\
+    ModuleType.idl\
+    ModuleSourceInfo.idl\
 
 # ------------------------------------------------------------------
 
