diff --git sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
index 4d1db8b..d4953f8 100644
--- sc/source/filter/excel/excimp8.cxx
+++ sc/source/filter/excel/excimp8.cxx
@@ -249,7 +249,7 @@ void ImportExcel8::Codename( BOOL bWorkbookGlobals )
             else
             {
                 GetExtDocOptions().AppendCodeName( aName );
-                GetDoc().SetCodeName( mnTab++, aName );
+                GetDoc().SetCodeName( GetCurrScTab(), aName );
             }
         }
 	}
@@ -280,7 +280,7 @@ void ImportExcel8::ReadBasic( void )
             pShell->GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
             SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
 	    bool bAsComment = !bLoadExecutable || !aGlobs.hasValue();
-            aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, bAsComment );
+            aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, AutoGeneratedCodeNames, bAsComment );
             if ( !bAsComment )
             {
                 GetObjectManager().SetOleNameOverrideInfo( aBasicImport.ControlNameForObjectId() );
diff --git sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
index aa2b377..3ceabf1 100644
--- sc/source/filter/excel/read.cxx
+++ sc/source/filter/excel/read.cxx
@@ -809,6 +809,12 @@ FltError ImportExcel8::Read( void )
     ::std::auto_ptr< ScfSimpleProgressBar > pProgress( new ScfSimpleProgressBar(
         aIn.GetSvStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
 
+    bool bSheetHasCodeName = false;
+
+    std::vector< String > CodeNames;
+
+    std::vector < SCTAB > nTabsWithNoCodeName;
+
     while( eAkt != EXC_STATE_END )
 	{
 		aIn.StartNextRecord();
@@ -876,6 +882,7 @@ FltError ImportExcel8::Read( void )
                         // #i62752# possible to have BIFF8 sheet without globals
                         NeueTabelle();
                         eAkt = EXC_STATE_SHEET_PRE;  // Shrfmla Prefetch, Row-Prefetch
+                        bSheetHasCodeName = false; // reset
                         aIn.StoreGlobalPosition();
                     }
                 }
@@ -1047,9 +1054,30 @@ FltError ImportExcel8::Read( void )
                     case EXC_ID3_DIMENSIONS:    ReadDimensions();                       break;
 
                     case 0x0A:                          // EOF          [ 2345   ]
+                    {
                         eAkt = EXC_STATE_SHEET;
+                        String sName;
+                        GetDoc().GetName( GetCurrScTab(), sName );
+                        if ( !bSheetHasCodeName )
+                        {
+                            nTabsWithNoCodeName.push_back( GetCurrScTab() );
+                            OSL_TRACE("No Codename for %d", GetCurrScTab() );
+                        }
+                        else
+                        {
+                            String sCodeName;
+                            GetDoc().GetCodeName( GetCurrScTab(), sCodeName );
+                            OSL_TRACE("Have CodeName %s for SheetName %s",
+                                rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                            CodeNames.push_back( sCodeName );
+                        }
+
+                        bSheetHasCodeName = false; // reset
+
+
                         aIn.SeekGlobalPosition();         // und zurueck an alte Position
                         break;
+                    }
                     case 0x12:  SheetProtect(); break;
                     case 0x13:  SheetPassword(); break;
                     case 0x42:  Codepage(); break;      // CODEPAGE     [ 2345   ]
@@ -1061,7 +1089,7 @@ FltError ImportExcel8::Read( void )
                     case 0x9B:  FilterMode(); break;    // FILTERMODE
                     case 0x9D:  AutoFilterInfo(); break;// AUTOFILTERINFO
                     case 0x9E:  AutoFilter(); break;    // AUTOFILTER
-                    case 0x01BA: Codename( FALSE ); break;
+                    case 0x01BA: Codename( FALSE ); bSheetHasCodeName = true; break;
                     case 0x0208: Row34(); break;        // ROW          [  34    ]
                     case 0x0021:
                     case 0x0221: Array34(); break;      // ARRAY        [  34    ]
@@ -1171,6 +1199,42 @@ FltError ImportExcel8::Read( void )
 
     if( eLastErr == eERR_OK )
     {
+        // In some strange circumstances a the codename might be missing
+        // # Create any missing Sheet CodeNames
+        std::vector < SCTAB >::iterator it_end = nTabsWithNoCodeName.end();
+        for ( std::vector < SCTAB >::iterator it = nTabsWithNoCodeName.begin(); it != it_end; ++it )
+        {
+            bool bGotCodeName = false;
+            SCTAB nTab = 1;
+            OSL_TRACE("Trying to find suitable codename for %d", *it );
+            while ( true )
+            {
+                String sTmpName( RTL_CONSTASCII_USTRINGPARAM("Sheet" ) );
+                sTmpName += String::CreateFromInt32( sal_Int32(nTab++) );
+                std::vector< String >::iterator codeName_It = CodeNames.begin();
+                std::vector< String >::iterator codeName_It_end = CodeNames.end();
+                // search for codename
+                for ( ; codeName_It != codeName_It_end; ++codeName_It )
+                {
+                    if ( *codeName_It == sTmpName )
+                        break;
+                }
+
+                if ( codeName_It == codeName_It_end ) // generated codename not found
+                {
+                    OSL_TRACE("Using generated codename %s", rtl::OUStringToOString( sTmpName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    // Set new codename
+                    GetDoc().SetCodeName( *it, sTmpName );
+                    // Record newly used codename
+                    CodeNames.push_back( sTmpName );
+                    // Record those we have created so they can be created in
+                    // basic
+                    AutoGeneratedCodeNames.push_back( sTmpName );
+                    break;
+                }
+            }
+            
+        }
         // #i45843# Convert pivot tables before calculation, so they are available
         // for the GETPIVOTDATA function.
         if( GetBiff() == EXC_BIFF8 )
diff --git sc/source/filter/inc/excimp8.hxx sc/source/filter/inc/excimp8.hxx
index f35faef..226ec6b 100644
--- sc/source/filter/inc/excimp8.hxx
+++ sc/source/filter/inc/excimp8.hxx
@@ -54,6 +54,9 @@ class ImportExcel8 : public ImportExcel
 {
         SCTAB mnTab;
 	protected:
+        // represents codename ( and associated modules ) 
+        // not speficied directly in the binary format
+        std::vector< String > AutoGeneratedCodeNames; 
         ExcScenarioList         aScenList;
 
 		BOOL					bHasBasic;
diff --git svx/inc/svxmsbas.hxx svx/inc/svxmsbas.hxx
index fab5faf..f1a4c44 100644
--- svx/inc/svxmsbas.hxx
+++ svx/inc/svxmsbas.hxx
@@ -76,8 +76,10 @@ public:
 	// 0 - nothing has done
 	// bit 0 = 1 -> any code is imported to the SO-Basic
 	// bit 1 = 1 -> the VBA - storage is copy to the ObjectShell storage
-	int Import( const String& rStorageName, const String &rSubStorageName,
+	int Import( const String& rStorageName, const String &rSubStorageName, 
 				BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
+	int Import( const String& rStorageName, const String &rSubStorageName, 
+				const std::vector< String >& codeNames, BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
 
 	// only for the export - copy or delete the saved VBA-macro-storage
 	// form the ObjectShell
@@ -98,15 +100,16 @@ private:
 	BOOL bImport;
 	BOOL bCopy;
 
-	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
-						  const String &rSubStorageName,
-						  BOOL bAsComment, BOOL bStripped );
+    SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
+                                                  const String &rSubStorageName,
+	                                              const std::vector< String >&,
+                                                  BOOL bAsComment, BOOL bStripped );
 	SVX_DLLPRIVATE bool ImportForms_Impl(const String& rStorageName, 
 		const String &rSubStorageName, BOOL bVBAMode );
 	SVX_DLLPRIVATE BOOL CopyStorage_Impl( const String& rStorageName,
 						   const String &rSubStorageName);
         rtl::OUString msProjectName;
-	SVX_DLLPRIVATE BOOL ImportCode_Impl( VBA_Impl&, BOOL, BOOL );
+	SVX_DLLPRIVATE BOOL ImportCode_Impl( VBA_Impl&, const std::vector< String >&, BOOL, BOOL );
 	SVX_DLLPRIVATE bool ImportForms_Impl( VBA_Impl&, const String&, const String&, BOOL);
 };
 
diff --git svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
index d4d6838..0ebc074 100644
--- svx/source/msfilter/svxmsbas.cxx
+++ svx/source/msfilter/svxmsbas.cxx
@@ -62,6 +62,8 @@ using namespace com::sun::star;
 
 using rtl::OUString;
 
+static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
+
 void SvxImportMSVBasic::extractAttribute( const String& rAttribute, const String& rModName )
 {
     // format of the attribute we are interested in is
@@ -83,9 +85,17 @@ int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
 {
+    std::vector< String > codeNames;
+    return Import(  rStorageName, rSubStorageName, codeNames, bAsComment, bStripped );
+}
+int SvxImportMSVBasic::Import( const String& rStorageName,
+								const String &rSubStorageName,
+								const std::vector< String >& codeNames,
+								BOOL bAsComment, BOOL bStripped )
+{
         msProjectName = rtl::OUString();
 	int nRet = 0;
-	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName,
+	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName, codeNames, 
 									bAsComment, bStripped ))
 		nRet |= 1;
 
@@ -296,6 +306,7 @@ BOOL SvxImportMSVBasic::CopyStorage_Impl( const String& rStorageName,
 
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 										const String &rSubStorageName,
+										const std::vector< String >& codeNames,
 										BOOL bAsComment, BOOL bStripped )
 {
 	BOOL bRet = FALSE;
@@ -308,31 +319,24 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
         if ( msProjectName.getLength() )
             rDocSh.GetBasicManager()->SetName( msProjectName ); // set name of Project
 
-        bRet = ImportCode_Impl( aVBA, bAsComment, bStripped );
+        bRet = ImportCode_Impl( aVBA, codeNames, bAsComment, bStripped );
     	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
     
     	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
         {
             rtl::OUString sFileName = *it;
-#ifndef WIN 
-#ifdef DEBUG
-            // hacky test code to read referenced projects on linux
-            sal_Int32 nPos = (*it).lastIndexOf('\\');
-            sFileName = (*it).copy( nPos + 1 );
-            sFileName =  rtl::OUString::createFromAscii("~/Documents/") + sFileName;
-#endif
-#endif
     		OSL_TRACE("referenced project %s ", rtl::OUStringToOString( sFileName, RTL_TEXTENCODING_UTF8 ).getStr() );
             SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
     	    VBA_Impl refVBA( *rRoot, bAsComment );
-    	    if( refVBA.Open(rStorageName,rSubStorageName) && ImportCode_Impl( refVBA, bAsComment, bStripped ) )
+			std::vector< String > codeNamesNone;
+    	    if( refVBA.Open(rStorageName,rSubStorageName) && ImportCode_Impl( refVBA, codeNamesNone, bAsComment, bStripped ) )
                 bRet = TRUE; // mark that some code was imported
         }
     }
     return bRet;
 }
 
-BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, BOOL bAsComment, BOOL bStripped )
+BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, const std::vector< String >& codeNames, BOOL bAsComment, BOOL bStripped )
 {
         BOOL bRet = FALSE;
 		SFX_APP()->EnterBasicCall();
@@ -357,7 +361,7 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, BOOL bAsComment, BOOL b
         }
 		if( xLib.is()  )
 		{
-            Reference< container::XNameAccess > xVBAObjectForCodeName;
+            Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
 			if ( !bAsComment )
             {
                 rDocSh.GetBasicManager()->GetLib( aLibName )->SetVBAEnabled( true );
@@ -366,11 +370,16 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, BOOL bAsComment, BOOL b
                 {
                     try
                     {
-                        xVBAObjectForCodeName.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
+                        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
                     }
                     catch( Exception& ) { }
                 }
             }
+            typedef  std::hash_map< rtl::OUString, uno::Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameModuleDataHash;
+
+            NameModuleDataHash moduleData;
+
 			for( UINT16 i=0; i<nStreamCount;i++)
 			{
 				StringArray aDecompressed = aVBA.Decompress(i);
@@ -436,7 +445,6 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, BOOL bAsComment, BOOL b
                         DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
                         break;
                 }
-				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
 				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
 				if ( !bAsComment /*&& !rDocSh.GetBasic()->isVBAEnabled() */)
 				{
@@ -508,60 +516,79 @@ BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, BOOL bAsComment, BOOL b
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				{
-					aSource = modeTypeComment + aSource;
+				aSource = modeTypeComment + aSource;
 
-					Any aSourceAny;
-                    OSL_TRACE("erm %d", mType );
-                    if (  !bAsComment )
-                    {
-                        OSL_TRACE("vba processing  %d", mType );
-                        script::ModuleInfo sModuleInfo;
-                        sModuleInfo.ModuleName = aModName;
-                        sModuleInfo.ModuleSource = aSource;
-                        sModuleInfo.ModuleType = mType;
-                       if ( mType == ModuleType::Form )
-                            // hack, the module ( imo document basic should...
-                            // know the XModel... ) but it doesn't
-                            sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
-			//  document modules, we should be able to access
-			//  the api objects at this time
-                        else if ( mType == ModuleType::Document )
-			{
-				uno::Reference< lang::XMultiServiceFactory> xSF( rDocSh.GetModel(), uno::UNO_QUERY);
-				uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
-    				if ( xSF.is() )
-				        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
-				// get the api object for the codename
-				if ( xVBACodeNamedObjectAccess.is() )
-				{
-					try
-					{
-						sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
-						OSL_TRACE("** Straight up creation of Module");
-					}
-					catch(uno::Exception& e)
-					{
-						OSL_TRACE("Failed to get documument object for %s", rtl::OUStringToOString( sModuleInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
-					}
-				}
-			}
-                        aSourceAny <<= sModuleInfo;
-                    }
-                    else
-					    aSourceAny <<= aSource;
-					if( xLib->hasByName( aModName ) )
-						xLib->replaceByName( aModName, aSourceAny );
-					else
-						xLib->insertByName( aModName, aSourceAny );
-				}                                
-
-				bRet = true;
-			}
-		}
+				Any aSourceAny;
+                OSL_TRACE("erm %d", mType );
+                if (  !bAsComment )
+                {
+                    OSL_TRACE("vba processing  %d", mType );
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = aModName;
+                    sModuleInfo.ModuleSource = aSource;
+                    sModuleInfo.ModuleType = mType;
+                    aSourceAny <<= sModuleInfo;
+                }
+                else
+                    aSourceAny <<= aSource;
+                moduleData[ aModName ] = aSourceAny;
+            }
+
+            // Hack for missing codenames ( only know to happen in excel but... )
+            // only makes sense to do this if we are importing non-commented basic
+            if ( !bAsComment )
+            {
+                for ( std::vector< String >::const_iterator it =  codeNames.begin(); it != codeNames.end(); ++it )
+                {
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = *it;
+                    sModuleInfo.ModuleType = ModuleType::Document ;
+                    sModuleInfo.ModuleSource = sVBAOption;
+                    moduleData[ *it ] = uno::makeAny( sModuleInfo );
+                }
+            }
+            NameModuleDataHash::iterator it_end = moduleData.end();
+            for ( NameModuleDataHash::iterator it = moduleData.begin(); it != it_end; ++it )
+            {
+                script::ModuleInfo sModuleInfo;
+                if ( it->second >>=sModuleInfo )
+                {
+            
+                    if ( sModuleInfo.ModuleType == ModuleType::Form )
+                        // hack, the module ( imo document basic should...
+                        // know the XModel... ) but it doesn't
+                        sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+                    //  document modules, we should be able to access
+			        //  the api objects at this time
+                    else if ( sModuleInfo.ModuleType == ModuleType::Document )
+			        {
+                        if ( xVBACodeNamedObjectAccess.is() )
+                        {
+                            try
+                            {
+                                sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
+                                OSL_TRACE("** Straight up creation of Module");
+                            }
+                            catch(uno::Exception& e)
+                            {
+    						    OSL_TRACE("Failed to get documument object for %s", rtl::OUStringToOString( sModuleInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    					    }
+    				    }
+    			    }
+                    it->second = uno::makeAny( sModuleInfo );
+                }
+                     
+                if( xLib->hasByName( it->first ) )
+                    xLib->replaceByName( it->first, it->second );
+                else
+                    xLib->insertByName( it->first, it->second );
+                bRet = true;
+            }                                
+
+        }
         if( bRet )
-		SFX_APP()->LeaveBasicCall();
-	return bRet;
+            SFX_APP()->LeaveBasicCall();
+	    return bRet;
 }
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
