--- basic/source/runtime/methods.cxx.orig	2008-01-01 23:40:56.000000000 +0800
+++ basic/source/runtime/methods.cxx	2008-01-01 23:43:30.000000000 +0800
@@ -3299,6 +3299,196 @@ RTLFUNC(Seek)
 	}
 }
 
+enum VbaFormatType
+{
+    VBA_FORMAT_TYPE_OFFSET, // standard number format
+    VBA_FORMAT_TYPE_USERDEFINED, // user defined number format
+    VBA_FORMAT_TYPE_NULL
+};
+
+struct VbaFormatInfo
+{
+    VbaFormatType meType; 
+    const char* mpVbaFormat; // Format string in vba
+    NfIndexTableOffset meOffset; // SvNumberFormatter format index, if meType = VBA_FORMAT_TYPE_OFFSET
+    const char* mpOOoFormat; // if meType = VBA_FORMAT_TYPE_USERDEFINED
+};
+
+#define VBA_FORMAT_OFFSET( pcUtf8, eOffset ) \
+    { VBA_FORMAT_TYPE_OFFSET, pcUtf8, eOffset, 0 }
+
+#define VBA_FORMAT_USERDEFINED( pcUtf8, pcDefinedUtf8 ) \
+    { VBA_FORMAT_TYPE_USERDEFINED, pcUtf8, NF_NUMBER_STANDARD, pcDefinedUtf8 }
+
+static VbaFormatInfo pFormatInfoTable[] = 
+{
+    VBA_FORMAT_OFFSET( "Long Date", NF_DATE_SYSTEM_LONG ),
+    VBA_FORMAT_USERDEFINED( "Medium Date", "DD-MMM-YYYY" ),
+    VBA_FORMAT_OFFSET( "Short Date", NF_DATE_SYSTEM_SHORT ),
+    VBA_FORMAT_OFFSET( "Long Time", NF_TIME_HHMMSSAMPM ),
+    VBA_FORMAT_OFFSET( "Medium Time", NF_TIME_HHMMAMPM ),
+    VBA_FORMAT_OFFSET( "Short Time", NF_TIME_HHMM ),
+    VBA_FORMAT_OFFSET( "ddddd", NF_DATE_SYSTEM_SHORT ),
+    VBA_FORMAT_OFFSET( "dddddd", NF_DATE_SYSTEM_LONG ),
+    VBA_FORMAT_OFFSET( "ttttt", NF_TIME_HHMMSSAMPM ),
+    VBA_FORMAT_OFFSET( "ww", NF_DATE_WW ),
+    VBA_FORMAT_USERDEFINED( "General Number", "0.############" ),
+    VBA_FORMAT_OFFSET( "Currency", NF_CURRENCY_1000DEC2 ),
+    VBA_FORMAT_OFFSET( "Fixed", NF_NUMBER_DEC2 ),
+    VBA_FORMAT_OFFSET( "Standard", NF_NUMBER_SYSTEM ),
+    VBA_FORMAT_OFFSET( "Percent", NF_PERCENT_DEC2 ),
+    VBA_FORMAT_OFFSET( "Scientific", NF_SCIENTIFIC_000E00 ),
+    { VBA_FORMAT_TYPE_NULL, 0, NF_INDEX_TABLE_ENTRIES, 0 }
+};
+
+VbaFormatInfo* getFormatInfo( const String& rFmt )
+{
+    VbaFormatInfo* pInfo = NULL;
+    INT16 i = 0;
+    while( (pInfo = pFormatInfoTable + i )->mpVbaFormat != NULL )
+    {
+        if( rFmt.EqualsIgnoreCaseAscii( pInfo->mpVbaFormat ) )
+            break;
+        i++;    
+    }
+    return pInfo;
+}
+
+#define VBAFORMAT_GENERALDATE       "General Date"
+#define VBAFORMAT_C                 "c"
+#define VBAFORMAT_N                 "n"
+#define VBAFORMAT_NN                "nn"
+#define VBAFORMAT_W                 "w"
+#define VBAFORMAT_Y                 "y"
+#define VBAFORMAT_YESNO     	    "Yes/No"
+#define VBAFORMAT_TRUEFALSE  		"True/False"
+#define VBAFORMAT_ONOFF	    		"On/Off"
+#define VBAFORMAT_LOWERCASE     	"<"
+#define VBAFORMAT_UPPERCASE         ">"
+
+// From methods1.cxx
+INT16 implGetWeekDay( double aDate, bool bFirstDayParam = false, INT16 nFirstDay = 0 );
+
+String VbaFormat( String& rStr, String& rFmt )
+{
+    String aRetStr;
+
+    // For simple text format
+	if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_LOWERCASE ) )
+		return rStr.ToLowerAscii();
+	if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_UPPERCASE ) )
+		return rStr.ToUpperAscii(); 
+	if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_YESNO ) )
+		return ( rStr.ToDouble() == 0.0 ) ? aRetStr.AssignAscii( "No" ) : aRetStr.AssignAscii( "Yes" ) ;
+	if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_TRUEFALSE ) )
+		return ( rStr.ToDouble() == 0.0 ) ? aRetStr.AssignAscii( "False" ) : aRetStr.AssignAscii( "True" ) ;
+	if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_ONOFF ) )
+		return ( rStr.ToDouble() == 0.0 ) ? aRetStr.AssignAscii( "Off" ) : aRetStr.AssignAscii( "On" ) ;
+
+	SvNumberFormatter* pFormatter;
+	com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > 
+		xFactory = comphelper::getProcessServiceFactory();
+	pFormatter = new SvNumberFormatter( xFactory, LANGUAGE_ENGLISH_US );
+
+	sal_uInt32 nIndex;
+	xub_StrLen nCheckPos = 0;
+	short nType;
+    double nNumber;
+    Color* pCol;
+    
+    LanguageType eLangType = GetpApp()->GetSettings().GetLanguage();
+    BOOL bSuccess = pFormatter->IsNumberFormat( rStr, nIndex, nNumber );
+
+    // Number format
+    if( bSuccess )
+    {
+        VbaFormatInfo* pInfo = getFormatInfo( rFmt );
+        if( pInfo && pInfo->meType != VBA_FORMAT_TYPE_NULL )
+        {
+            if( pInfo->meType == VBA_FORMAT_TYPE_OFFSET )
+            {
+                nIndex = pFormatter->GetFormatIndex( pInfo->meOffset, eLangType );
+            }
+            else
+            {
+                rFmt.AssignAscii( pInfo->mpOOoFormat );
+                pFormatter->PutandConvertEntry( rFmt, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH_US, eLangType );
+            }
+	        pFormatter->GetOutputString( nNumber, nIndex, aRetStr, &pCol );
+        }
+        else if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_GENERALDATE )
+                || rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_C )) 
+        {
+            if( nNumber <=-1.0 || nNumber >= 1.0 )
+            {
+                // short date 
+                nIndex = pFormatter->GetFormatIndex( NF_DATE_SYSTEM_SHORT, eLangType );
+	            pFormatter->GetOutputString( nNumber, nIndex, aRetStr, &pCol );
+                
+                // long time
+                if( floor( nNumber ) != nNumber )
+                {
+                    nIndex = pFormatter->GetFormatIndex( NF_TIME_HHMMSSAMPM, eLangType );
+                    String aTime;
+	                pFormatter->GetOutputString( nNumber, nIndex, aTime, &pCol );
+                    aRetStr.AppendAscii(" ");
+                    aRetStr += aTime;
+                }
+            }
+            else
+            {
+                // long time only
+                nIndex = pFormatter->GetFormatIndex( NF_TIME_HHMMSSAMPM, eLangType );
+	            pFormatter->GetOutputString( nNumber, nIndex, aRetStr, &pCol );
+            }
+        }
+        else if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_N )
+                || rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_NN )) 
+        {
+            INT32 nMin = implGetMinute( nNumber );
+            if( nMin < 10 && rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_NN ) )
+            {
+                // Minute in two digits
+                 sal_Unicode* p = aRetStr.AllocBuffer( 2 );
+                 *p++ = '0';
+                 *p = sal_Unicode( '0' + nMin );
+            }
+            else
+            {
+                aRetStr = String::CreateFromInt32( nMin );
+            }
+        }
+        else if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_W ))
+        {
+            INT32 nWeekDay = implGetWeekDay( nNumber );
+            aRetStr = String::CreateFromInt32( nWeekDay );
+        }
+        else if( rFmt.EqualsIgnoreCaseAscii( VBAFORMAT_Y ))
+        {
+			INT16 nYear = implGetDateYear( nNumber );
+			double dBaseDate;
+			implDateSerial( nYear, 1, 1, dBaseDate );
+			INT32 nYear32 = 1 + INT32( nNumber - dBaseDate );
+            aRetStr = String::CreateFromInt32( nYear32 );
+        }
+        else
+        {
+            pFormatter->PutandConvertEntry( rFmt, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH_US, eLangType );
+	        pFormatter->GetOutputString( nNumber, nIndex, aRetStr, &pCol );
+        }
+    }
+    else
+    {
+        // text format
+        pFormatter->PutandConvertEntry( rFmt, nCheckPos, nType, nIndex, LANGUAGE_ENGLISH_US, eLangType );
+	    pFormatter->GetOutputString( rStr, nIndex, aRetStr, &pCol );
+    }
+
+	delete pFormatter;
+    
+    return aRetStr;
+}
+
 RTLFUNC(Format)
 {
     (void)pBasic;
@@ -3315,7 +3505,16 @@ RTLFUNC(Format)
 		else
 		{
 			String aFmt( rPar.Get(2)->GetString() );
-			rPar.Get(1)->Format( aResult, &aFmt );
+
+            if( SbiRuntime::isVBAEnabled() )
+            {
+                String aStr = rPar.Get(1)->GetString();
+                aResult = VbaFormat( aStr, aFmt );
+            }
+            else
+            {
+			    rPar.Get(1)->Format( aResult, &aFmt );
+            }   
 		}
 		rPar.Get(0)->PutString( aResult );
 	}
