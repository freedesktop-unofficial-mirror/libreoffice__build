Index: xmloff/source/forms/formattributes.hxx
===================================================================
--- xmloff/source/forms/formattributes.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/forms/formattributes.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -126,6 +126,7 @@
 	#define SCA_MAX_VALUE				0x00000002
 	#define SCA_MIN_VALUE				0x00000004
 	#define SCA_VALIDATION				0x00000008
+    #define SCA_GROUP_NAME              0x00000010
 	#define SCA_MULTI_LINE				0x00000020
 	#define SCA_AUTOMATIC_COMPLETION	0x00000080
 	#define SCA_MULTIPLE				0x00000100
Index: xmloff/source/forms/elementexport.cxx
===================================================================
--- xmloff/source/forms/elementexport.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/forms/elementexport.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1113,6 +1113,39 @@
 		}
 
 		// ----------------------------------
+		// the string properties
+		{
+			static sal_Int32 nStringPropertyAttributeIds[] =
+			{	// attribute flags
+				SCA_GROUP_NAME
+			};
+			static const ::rtl::OUString* pStringPropertyNames[] =
+			{	// property names
+				&PROPERTY_GROUP_NAME
+			};
+
+			sal_Int32 nIdCount = sizeof( nStringPropertyAttributeIds ) / sizeof( nStringPropertyAttributeIds[0] );
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof( pStringPropertyNames ) / sizeof( pStringPropertyNames[0] );
+			OSL_ENSURE( ( nIdCount == nNameCount ),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (2)!" );
+		#endif
+			for ( i = 0; i < nIdCount; ++i )
+				if ( nStringPropertyAttributeIds[i] & m_nIncludeSpecial )
+				{
+					exportStringPropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( nStringPropertyAttributeIds[i] ),
+						OAttributeMetaData::getSpecialAttributeName( nStringPropertyAttributeIds[i] ),
+						*( pStringPropertyNames[i] )
+					);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~nStringPropertyAttributeIds[i];
+			#endif
+				}
+		}
+
+		// ----------------------------------
 		if ((SCA_MIN_VALUE | SCA_MAX_VALUE) & m_nIncludeSpecial)
 		{
 			// need to export the min value and the max value as attributes
@@ -1570,6 +1603,8 @@
 				}
                 if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_IMAGE_POSITION ) )
                     m_nIncludeSpecial |= SCA_IMAGE_POSITION;
+                if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_GROUP_NAME ) )
+                    m_nIncludeSpecial |= SCA_GROUP_NAME;
 				m_nIncludeDatabase = DA_DATA_FIELD | DA_INPUT_REQUIRED;
 				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE;
 				break;
Index: xmloff/source/forms/strings.hxx
===================================================================
--- xmloff/source/forms/strings.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/forms/strings.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -208,6 +208,7 @@
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_POSITION,     "ImagePosition");
     XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_ALIGN,        "ImageAlign");
     XMLFORM_CONSTASCII_STRING( PROPERTY_SCALE_IMAGE,        "ScaleImage");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_GROUP_NAME,         "GroupName");
 
     XMLFORM_CONSTASCII_STRING( PROPERTY_BOUND_CELL,		    "BoundCell");
     XMLFORM_CONSTASCII_STRING( PROPERTY_LIST_CELL_RANGE,    "CellRange");
Index: xmloff/source/forms/layerimport.cxx
===================================================================
--- xmloff/source/forms/layerimport.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/forms/layerimport.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -98,6 +98,8 @@
 	m_aAttributeMetaData.addStringProperty(
 		OAttributeMetaData::getCommonControlAttributeName(CCA_NAME), PROPERTY_NAME);
 	m_aAttributeMetaData.addStringProperty(
+			OAttributeMetaData::getSpecialAttributeName(SCA_GROUP_NAME), PROPERTY_GROUP_NAME);
+		m_aAttributeMetaData.addStringProperty(
 		OAttributeMetaData::getCommonControlAttributeName(CCA_IMAGE_DATA), PROPERTY_IMAGEURL);
 	m_aAttributeMetaData.addStringProperty(
 		OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL), PROPERTY_LABEL);
Index: xmloff/source/forms/formattributes.cxx
===================================================================
--- xmloff/source/forms/formattributes.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/forms/formattributes.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -195,6 +195,7 @@
 			case SCA_MAX_VALUE:				return "max-value";
 			case SCA_MIN_VALUE:				return "min-value";
 			case SCA_VALIDATION:			return "validation";
+            case SCA_GROUP_NAME:            return "group-name";
 			case SCA_MULTI_LINE:			return "multi-line";
 			case SCA_AUTOMATIC_COMPLETION:	return "auto-complete";
 			case SCA_MULTIPLE: 				return "multiple";
@@ -215,9 +216,12 @@
 	}
 
 	//---------------------------------------------------------------------
-	sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 /*_nId*/)
+	sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 _nId)
 	{
-		// nothing special here
+        switch( _nId )
+        {
+            case SCA_GROUP_NAME:            return XML_NAMESPACE_FORMX;
+        }
 		return XML_NAMESPACE_FORM;
 	}
 
Index: xmloff/source/core/xmltoken.cxx
===================================================================
--- xmloff/source/core/xmltoken.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/core/xmltoken.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -152,6 +152,10 @@
         TOKEN( "grddl",                                 XML_NP_GRDDL ),
         TOKEN( "http://www.w3.org/2003/g/data-view#",   XML_N_GRDDL ),
 
+        // jonp: 2008-09-24 Excel Interop
+        TOKEN( "formx",                           XML_NP_FORMX ),
+        TOKEN( "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0", XML_N_FORMX ),
+
         // units
         TOKEN( "mm",                              XML_UNIT_MM ),
         TOKEN( "m",                               XML_UNIT_M ),
Index: xmloff/source/core/xmlimp.cxx
===================================================================
--- xmloff/source/core/xmlimp.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/core/xmlimp.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -111,6 +111,7 @@
 sal_Char __READONLY_DATA sXML_np__config[] = "_config";
 sal_Char __READONLY_DATA sXML_np__db[] = "_db";
 sal_Char __READONLY_DATA sXML_np__xforms[] = "_xforms";
+sal_Char __READONLY_DATA sXML_np__formx[] = "_formx";
 sal_Char __READONLY_DATA sXML_np__xsd[] = "_xsd";
 sal_Char __READONLY_DATA sXML_np__xsi[] = "_xsi";
 sal_Char __READONLY_DATA sXML_np__field[] = "_field";
@@ -296,6 +297,9 @@
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xforms) ),
                             GetXMLToken(XML_N_XFORMS_1_0),
                             XML_NAMESPACE_XFORMS );
+        mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__formx) ),
+                            GetXMLToken( XML_N_FORMX ),
+                            XML_NAMESPACE_FORMX );
         mpNamespaceMap->Add( OUString( RTL_CONSTASCII_USTRINGPARAM ( sXML_np__xsd) ),
                             GetXMLToken(XML_N_XSD),
                             XML_NAMESPACE_XSD );
Index: xmloff/source/core/xmlexp.cxx
===================================================================
--- xmloff/source/core/xmlexp.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/core/xmlexp.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -339,6 +339,7 @@
 		mpNamespaceMap->Add( GetXMLToken(XML_NP_XSD), GetXMLToken(XML_N_XSD), XML_NAMESPACE_XSD );
 		mpNamespaceMap->Add( GetXMLToken(XML_NP_XSI), GetXMLToken(XML_N_XSI), XML_NAMESPACE_XSI );
 		mpNamespaceMap->Add( GetXMLToken(XML_NP_FIELD), GetXMLToken(XML_N_FIELD), XML_NAMESPACE_FIELD );
+		mpNamespaceMap->Add( GetXMLToken(XML_NP_FORMX), GetXMLToken(XML_N_FORMX), XML_NAMESPACE_FORMX );
 	}
     // RDFa: needed for content and header/footer styles
     if( (getExportFlags() & (EXPORT_STYLES|EXPORT_AUTOSTYLES|EXPORT_MASTERSTYLES|EXPORT_CONTENT) ) != 0 )
Index: xmloff/source/draw/eventimp.cxx
===================================================================
--- xmloff/source/draw/eventimp.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/draw/eventimp.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -104,9 +104,6 @@
 
 	sal_Bool mbValid;
 	sal_Bool mbScript;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    sal_Bool mbActionEvent;
-#endif
 	ClickAction meClickAction;
 	XMLEffect meEffect;
 	XMLEffectDirection meDirection;
@@ -118,9 +115,6 @@
 	OUString msMacroName;
 	OUString msBookmark;
 	OUString msLanguage;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    OUString msHyperURL;
-#endif
 };
 
 ///////////////////////////////////////////////////////////////////////
@@ -179,18 +173,11 @@
 
 SdXMLEventContext::SdXMLEventContext( SvXMLImport& rImp,  sal_uInt16 nPrfx, const OUString& rLocalName,  const Reference< XAttributeList >& xAttrList, const Reference< XShape >& rxShape )
 :	SvXMLImportContext(rImp, nPrfx, rLocalName),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    mxShape( rxShape ), mbScript( sal_False ), mbActionEvent( sal_False ), meClickAction( ClickAction_NONE ),
-#else
     mxShape( rxShape ), mbScript( sal_False ), meClickAction( ClickAction_NONE ),
-#endif
 	meEffect( EK_none ), meDirection( ED_none ), mnStartScale( 100 ),
 	meSpeed( AnimationSpeed_MEDIUM ), mnVerb(0), mbPlayFull( sal_False )
 {
     static const OUString sXMLClickName( RTL_CONSTASCII_USTRINGPARAM( "click" ) );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    static const OUString sXMLActionName( RTL_CONSTASCII_USTRINGPARAM( "action" ) );
-#endif
 
     if( nPrfx == XML_NAMESPACE_PRESENTATION && IsXMLToken( rLocalName, XML_EVENT_LISTENER ) )
 	{
@@ -261,12 +248,7 @@
 				sEventName = sValue;
 				sal_uInt16 nScriptPrefix =
 					GetImport().GetNamespaceMap().GetKeyByAttrName( sValue, &sEventName );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                mbValid = XML_NAMESPACE_DOM == nScriptPrefix && ( sEventName == sXMLClickName || sEventName == sXMLActionName );
-                mbActionEvent = mbValid && (sEventName == sXMLActionName);
-#else
                 mbValid = XML_NAMESPACE_DOM == nScriptPrefix && sEventName == sXMLClickName;
-#endif
 			}
 			else if( IsXMLToken( aAttrLocalName, XML_LANGUAGE ) )
 			{
@@ -295,12 +277,6 @@
 				{
 					msMacroName = sValue;
 				}
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-                else if ( mbActionEvent )
-                {
-                    msHyperURL = sValue;
-                }
-#endif
 				else
 				{
 					const rtl::OUString &rTmp =
@@ -346,26 +322,6 @@
         OUString sAPIEventName;
         uno::Sequence< beans::PropertyValue > aProperties;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        if( mbActionEvent )
-        {
-            sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) );
-            aProperties.realloc( 2 );
-            beans::PropertyValue* pProperty = aProperties.getArray();
-
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) );
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-            ++pProperty;
-            pProperty->Name = OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) );
-            pProperty->Handle = -1;
-            pProperty->Value <<= msHyperURL;
-            pProperty->State = beans::PropertyState_DIRECT_VALUE;
-        }
-        else
-#endif
-        {
             sAPIEventName = OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) );
 
             if( mbScript )
@@ -550,8 +506,6 @@
                     break;
                 }
             }
-        }
-
         xEvents->replaceByName( sAPIEventName, uno::Any( aProperties ) );
 
     } while(0);
Index: xmloff/source/draw/ximpshap.cxx
===================================================================
--- xmloff/source/draw/ximpshap.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/draw/ximpshap.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -375,6 +375,11 @@
 
 	if( msHyperlink.getLength() != 0 ) try
 	{
+		uno::Reference< beans::XPropertySet > xProp( mxShape, uno::UNO_QUERY );
+
+		rtl::OUString sLink( RTL_CONSTASCII_USTRINGPARAM( "Hyperlink" ) );
+		if ( xProp.is() && xProp->getPropertySetInfo()->hasPropertyByName( sLink ) )
+			xProp->setPropertyValue( sLink, uno::Any( msHyperlink ) );
         Reference< XEventsSupplier > xEventsSupplier( mxShape, UNO_QUERY_THROW );
         Reference< XNameReplace > xEvents( xEventsSupplier->getEvents(), UNO_QUERY_THROW );
 
@@ -3230,9 +3235,16 @@
 
 	if( !mxImplContext.Is() )
 	{
-		pContext = GetImport().GetShapeImport()->CreateFrameChildContext(
+
+		SvXMLShapeContext* pShapeContext= GetImport().GetShapeImport()->CreateFrameChildContext(
 						GetImport(), nPrefix, rLocalName, xAttrList, mxShapes, mxAttrList );
 
+		pContext = pShapeContext;
+
+		// propagate the hyperlink to child context
+		if ( msHyperlink.getLength() > 0 )
+			pShapeContext->setHyperlink( msHyperlink );
+ 
 		mxImplContext = pContext;
 		mbSupportsReplacement = IsXMLToken( rLocalName, XML_OBJECT ) ||
 								IsXMLToken( rLocalName, XML_OBJECT_OLE );
Index: xmloff/source/draw/shapeexport.cxx
===================================================================
--- xmloff/source/draw/shapeexport.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/draw/shapeexport.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -87,11 +87,6 @@
 	msStartShape( RTL_CONSTASCII_USTRINGPARAM("StartShape") ),
 	msEndShape( RTL_CONSTASCII_USTRINGPARAM("EndShape") ),
 	msOnClick( RTL_CONSTASCII_USTRINGPARAM("OnClick") ),
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-	msOnAction( RTL_CONSTASCII_USTRINGPARAM("OnAction") ),
-	msAction( RTL_CONSTASCII_USTRINGPARAM("Action") ),
-	msURL( RTL_CONSTASCII_USTRINGPARAM("URL") ),
-#endif
 	msEventType( RTL_CONSTASCII_USTRINGPARAM("EventType") ),
 	msPresentation( RTL_CONSTASCII_USTRINGPARAM("Presentation") ),
 	msMacroName( RTL_CONSTASCII_USTRINGPARAM("MacroName") ),
Index: xmloff/source/draw/shapeexport2.cxx
===================================================================
--- xmloff/source/draw/shapeexport2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/source/draw/shapeexport2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -297,9 +297,6 @@
 const sal_Int32 FOUND_MACRO             = 0x00000100;
 const sal_Int32 FOUND_LIBRARY           = 0x00000200;
 const sal_Int32 FOUND_ACTIONEVENTTYPE   = 0x00000400;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-const sal_Int32 FOUND_URL               = 0x00000800;
-#endif
 
 } // namespace
 
@@ -389,33 +386,6 @@
         }
     }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    // extract properties from "OnAction" event -------------------------------
-
-    OUString aActionEventType;
-    OUString aHyperURL;
-
-    uno::Sequence< beans::PropertyValue > aActionProperties;
-    if( xEvents->hasByName( msOnAction ) && (xEvents->getByName( msOnAction ) >>= aActionProperties) )
-    {
-        const beans::PropertyValue* pProperty = aActionProperties.getConstArray();
-        const beans::PropertyValue* pPropertyEnd = pProperty + aActionProperties.getLength();
-        for( ; pProperty != pPropertyEnd; ++pProperty )
-        {
-            if( ( ( nFound & FOUND_ACTIONEVENTTYPE ) == 0 ) && pProperty->Name == msEventType )
-            {
-                if( pProperty->Value >>= aActionEventType )
-                    nFound |= FOUND_ACTIONEVENTTYPE;
-            }
-            else if( ( ( nFound & FOUND_URL ) == 0 ) && ( pProperty->Name == msURL  ) )
-            {
-                if( pProperty->Value >>= aHyperURL )
-                    nFound |= FOUND_URL;
-            }
-        }
-    }
-#endif
-
     // create the XML elements
 
     if( aClickEventType == msPresentation )
@@ -567,15 +537,9 @@
             SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
         }
     }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    else if( aClickEventType == msScript || aActionEventType == msAction )
-    {
-        if( nFound & ( FOUND_MACRO | FOUND_URL ) )
-#else
     else if( aClickEventType == msScript )
     {
         if( nFound & FOUND_MACRO )
-#endif
         {
             SvXMLElementExport aEventsElemt(mrExport, XML_NAMESPACE_OFFICE, XML_EVENT_LISTENERS, sal_True, sal_True);
             if ( nFound & FOUND_MACRO )
@@ -590,18 +554,6 @@
 
                 SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_SCRIPT, XML_EVENT_LISTENER, sal_True, sal_True);
             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( nFound & FOUND_URL )
-            {
-                OUString aEventQName(
-                    mrExport.GetNamespaceMap().GetQNameByKey(
-                            XML_NAMESPACE_DOM, OUString( RTL_CONSTASCII_USTRINGPARAM( "action" ) ) ) );
-                mrExport.AddAttribute( XML_NAMESPACE_SCRIPT, XML_EVENT_NAME, aEventQName );
-                mrExport.AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, aHyperURL );
-
-                SvXMLElementExport aEventElemt(mrExport, XML_NAMESPACE_PRESENTATION, XML_EVENT_LISTENER, sal_True, sal_True);
-            }
-#endif
         }
     }
 }
Index: xmloff/inc/xmloff/shapeexport.hxx
===================================================================
--- xmloff/inc/xmloff/shapeexport.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/inc/xmloff/shapeexport.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -197,11 +197,6 @@
 	const rtl::OUString							msStartShape;
 	const rtl::OUString							msEndShape;
 	const rtl::OUString							msOnClick;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-	const rtl::OUString							msOnAction;
-	const rtl::OUString							msAction;
-	const rtl::OUString							msURL;
-#endif
 	const rtl::OUString							msEventType;
 	const rtl::OUString							msPresentation;
 	const rtl::OUString							msMacroName;
Index: xmloff/inc/xmloff/xmltoken.hxx
===================================================================
--- xmloff/inc/xmloff/xmltoken.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/inc/xmloff/xmltoken.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -144,6 +144,10 @@
         XML_NP_GRDDL,
         XML_N_GRDDL,
 
+        // jonp: 2008-09-24 Excel Interop
+        XML_NP_FORMX,
+        XML_N_FORMX,
+
         // units
         XML_UNIT_MM,
         XML_UNIT_M,
Index: xmloff/inc/xmlnmspe.hxx
===================================================================
--- xmloff/inc/xmlnmspe.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmloff/inc/xmlnmspe.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,6 +96,7 @@
 
 // experimental namespaces
 XML_NAMESPACE( FIELD,			100U )
+XML_NAMESPACE( FORMX,           101U )      // form interop extensions
 
 
 #endif	//  _XMLOFF_XMLNMSPE_HXX
Index: oovbaapi/genconstidl/makefile.mk
===================================================================
--- oovbaapi/genconstidl/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/genconstidl/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,11 +36,6 @@
 
 .IF "$(L10N_framework)"==""
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ENDIF
-
 # symbol files of Microsoft API
 MYSYMFILES = access.api vba.api adodb.api msforms.api word.api dao.api powerpoint.api excel.api stdole.api
 
@@ -54,18 +49,16 @@
 
 ALLTAR: GENIDL
 
-GENIDL : $(MY_GEN_IDL_PATH) $(MYDONEFILES)
+GENIDL : $(MYDONEFILES)
 
 GENRDB : GENIDL $(MYURDFILES)
 
 $(MISC)$/%.done : %.api
+    @@-$(MKDIR) $(MY_GEN_IDL_PATH)
     @echo Processing $?
     $(PERL) api-to-idl.pl $? $(MY_GEN_IDL_PATH)
     @$(TOUCH) $@
 
-$(MY_GEN_IDL_PATH) : 
-    @@-$(MKDIR) $@
-
 CLEAN :
     @$(RM) $(MY_GEN_IDL_PATH)$/*.idl
     @$(RM) $(foreach,i,$(MYSYMFILES) $(MISC)$/$(i:b).done)
Index: oovbaapi/prj/build.lst
===================================================================
--- oovbaapi/prj/build.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -4,5 +4,6 @@
 ovba	oovbaapi\ooo\vba\constants          nmake	-	all	ovba_constants  ovba_genconstidl NULL
 ovba	oovbaapi\ooo\vba                    nmake	-	all	ovba_vba NULL
 ovba	oovbaapi\ooo\vba\excel              nmake	-	all	ovba_excel NULL
+ovba	oovbaapi\ooo\vba\word               nmake	-	all	ovba_word NULL
 ovba	oovbaapi\ooo\vba\msforms            nmake	-	all	ovba_msforms NULL
-ovba    oovbaapi\util                       nmake       -       all     ovba_util ovba_vba ovba_excel ovba_msforms ovba_constants ovba_genconstidl NULL
+ovba   oovbaapi\util                             nmake   -   all ovba_util ovba_vba ovba_excel ovba_word ovba_msforms ovba_constants ovba_genconstidl NULL
Index: oovbaapi/ooo/vba/XGlobals.idl
===================================================================
--- oovbaapi/ooo/vba/XGlobals.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/XGlobals.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,67 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: XGlobals.idl,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef __ooo_vba_XGlobals_idl__
-#define __ooo_vba_XGlobals_idl__
-
-#ifndef __com_sun_star_uno_XInterface_idl__
-#include <com/sun/star/uno/XInterface.idl>
-#endif
-#ifndef __ooo_vba_excel_XApplication_idl__
-#include <ooo/vba/excel/XApplication.idl>
-#endif
-#ifndef __ooo_vba_excel_XWorkbook_idl__
-#include <ooo/vba/excel/XWorkbook.idl>
-#endif
-#ifndef __ooo_vba_excel_XWorksheet_idl__
-#include <ooo/vba/excel/XWorksheet.idl>
-#endif
-
-module ooo {  module vba { 
-
-interface XGlobals: com::sun::star::uno::XInterface
-{
-        // FIXME, need better way to expose globals
-	sequence< any > getGlobals();
-
-	[attribute, readonly] ooo::vba::excel::XApplication Application;
-	[attribute, readonly] ooo::vba::excel::XWorkbook ActiveWorkbook;
-	[attribute, readonly] ooo::vba::excel::XWorksheet ActiveSheet;
-	any WorkSheets( [in] any aIndex );
-	any WorkBooks( [in] any aIndex );
-	any Sheets( [in] any aIndex );
-	any Range( [in] any Cell1, [in] any Cell2 );
-	any Names( [in] any Index );
-};
-
-}; };
-
-#endif
-
-
Index: oovbaapi/ooo/vba/Globals.idl
===================================================================
--- oovbaapi/ooo/vba/Globals.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/Globals.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,48 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: Globals.idl,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#ifndef __ooo_vba_Globals_idl__
-#define __ooo_vba_Globals_idl__
-
-#ifndef __ooo_vba_XGlobals_idl__
-#include <ooo/vba/XGlobals.idl>
-#endif
-
-#include <com/sun/star/uno/XComponentContext.idl>
-#include <com/sun/star/table/XCellRange.idl>
-
-module ooo {  module vba {
-service Globals : XGlobals
-{
-};
-
-}; };
-
-#endif
Index: oovbaapi/ooo/vba/XDocumentProperty.idl
===================================================================
--- oovbaapi/ooo/vba/XDocumentProperty.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDocumentProperty.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocument.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_XDocumentProperty_idl__
+#define __ooo_vba_XDocumentProperty_idl__
+
+#ifndef __com_sun_star_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+#ifndef __com_sun_star_script_XDefaultProperty_idl__
+#include <com/sun/star/script/XDefaultProperty.idl>
+#endif
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo { module vba { 
+
+/**
+ * Specific built-in document property. Use CustomDocumentProperties(index),
+ * where index is the name or index number of the custom document property,
+ * to return a DocumentProperty object that represents a specific custom document property.
+ */
+interface XDocumentProperty 
+{
+   
+    interface com::sun::star::script::XDefaultProperty;
+    interface ooo::vba::XHelperInterface;
+
+    void Delete()
+        raises (com::sun::star::script::BasicErrorException);
+
+    /** Required String. The name of the property.
+     */
+    string getName()
+        raises (com::sun::star::script::BasicErrorException);
+
+    void setName([in] string Name)
+        raises (com::sun::star::script::BasicErrorException);
+
+    /** The data type of the property.
+     * Can be one of the following MsoDocProperties constants:
+     * msoPropertyTypeBoolean, msoPropertyTypeDate, msoPropertyTypeFloat,
+     * msoPropertyTypeNumber, or msoPropertyTypeString.
+     */
+    byte getType()
+        raises (com::sun::star::script::BasicErrorException);
+
+    void setType([in] byte Type)
+        raises (com::sun::star::script::BasicErrorException);
+
+    /** If true, then LinkSource has a valid value. */
+    boolean getLinkToContent()
+        raises (com::sun::star::script::BasicErrorException);
+
+    void setLinkToContent([in] boolean LinkToContent)
+        raises (com::sun::star::script::BasicErrorException);
+
+    /** If LinkToContent is false, then this contains the value of the property
+     * The data type of the value will match the Type property.
+     */
+    any getValue()
+        raises (com::sun::star::script::BasicErrorException);
+
+    void setValue([in] any Value)
+        raises (com::sun::star::script::BasicErrorException);
+
+    /** If LinkToContent is false, then this contains the value of the property */
+    string getLinkSource()
+        raises (com::sun::star::script::BasicErrorException);
+
+    void setLinkSource([in] string LinkSource)
+        raises (com::sun::star::script::BasicErrorException);
+};
+
+}; };
+
+#endif
+
Index: oovbaapi/ooo/vba/makefile.mk
===================================================================
--- oovbaapi/ooo/vba/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,16 +38,11 @@
 # --- Settings -----------------------------------------------------
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ELSE
 
 # ------------------------------------------------------------------------
 .IF "$(L10N_framework)"=""
 IDLFILES=\
 	XErrObject.idl \
-	XGlobals.idl \
 	XCollection.idl\
 	XVBAToOOEventDescGen.idl\
 	XPropValue.idl\
@@ -57,9 +51,23 @@
 	XCommandBarControls.idl\
 	XCommandBar.idl\
 	XCommandBars.idl\
-	Globals.idl\
+	XCommandBarPopup.idl\
+	XCommandBarButton.idl\
+	XControlProvider.idl\
+	ControlProvider.idl\
+	XApplicationBase.idl\
+	XWindowBase.idl\
+	XDocumentBase.idl\
+	XDocumentsBase.idl\
+	XGlobalsBase.idl\
+	XDocumentProperty.idl\
+	XDocumentProperties.idl\
+	XFontBase.idl\
+	XDialogsBase.idl\
+	XDialogBase.idl\
+    XPageSetupBase.idl  \
 
 # ------------------------------------------------------------------
-.ENDIF
+
 .INCLUDE :  target.mk
 .ENDIF
Index: oovbaapi/ooo/vba/msforms/XControl.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XControl.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XControl.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -61,6 +61,7 @@
     [attribute] double  Left;
     [attribute] double  Top;
 	[attribute] string Name;
+	[attribute] string ControlTipText;
 };
 
 //=============================================================================
Index: oovbaapi/ooo/vba/msforms/XShapes.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XShapes.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XShapes.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,7 @@
     */
     any AddLine( [in] long StartX, [in] long StartY, [in] long endX, [in] long endY );
     any AddShape([in] long ShapeType, [in] long StartX, [in] long StartY, [in] long endX, [in] long endY );
+    any AddTextbox([in] long Orientation, [in] long Left, [in] long Top, [in] long Width, [in] long Height );
 };
 }; }; };
 
Index: oovbaapi/ooo/vba/msforms/makefile.mk
===================================================================
--- oovbaapi/ooo/vba/msforms/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,11 +38,6 @@
 # --- Settings -----------------------------------------------------
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ENDIF
-
 # ------------------------------------------------------------------------
 
 IDLFILES=\
@@ -71,6 +66,7 @@
 	XSpinButton.idl \
 	XImage.idl \
 	XControls.idl \
+	XTextFrame.idl \
 
 # ------------------------------------------------------------------
 
Index: oovbaapi/ooo/vba/msforms/XListBox.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XListBox.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XListBox.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -43,7 +43,7 @@
 {
 	[attribute] any Value;
 	[attribute] string Text;
-	[attribute] boolean MultiSelect;
+	[attribute] long MultiSelect; //liuchen 2009-7-31 MultiSelect property in Excel VBA is type long
 	[attribute] any ListIndex;
         [attribute, readonly ] long ListCount;
 	void AddItem( [in] any pvargItem, [in] any pvargIndex );
Index: oovbaapi/ooo/vba/msforms/XTextFrame.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XTextFrame.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/msforms/XTextFrame.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XTextFrame.idl,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_msforms_XTextFrame_idl__
+#define __ooo_vba_msforms_XTextFrame_idl__
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module msforms {
+interface XTextFrame : ooo::vba::XHelperInterface
+{
+    [attribute] boolean AutoSize;
+    [attribute] float MarginBottom;
+    [attribute] float MarginTop;
+    [attribute] float MarginLeft;
+    [attribute] float MarginRight;
+    any Characters();
+    /*I don't find it in msdn
+    Range TextRange();*/
+};
+}; }; };
+#endif
Index: oovbaapi/ooo/vba/msforms/XShape.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XShape.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XShape.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,10 +34,6 @@
 #include <ooo/vba/XHelperInterface.idl>
 #endif
 
-#ifndef __ooo_vba_excel_XTextFrame_idl__
-#include <ooo/vba/excel/XTextFrame.idl>
-#endif
-
 #ifndef __ooo_vba_msforms_XLineFormat_idl__
 #include <ooo/vba/msforms/XLineFormat.idl>
 #endif
@@ -66,14 +62,13 @@
     [attribute, readonly] XLineFormat Line;
     [attribute, readonly] XFillFormat Fill;
     [attribute, readonly] XPictureFormat PictureFormat;
+    [attribute] boolean LockAspectRatio;
+    [attribute] boolean LockAnchor;
+    [attribute] long RelativeHorizontalPosition;
+    [attribute] long RelativeVerticalPosition;
 
-    /*
-    using in word
-    [attribute] RelativeHorizontalPosition
-    [attribute] RelativeVerticalPosition
-    [attribute] XWrapFormat WrapFormat;
-    */
-    ooo::vba::excel::XTextFrame TextFrame();
+    any TextFrame();
+    any WrapFormat();
     void Delete();
     void ZOrder( [in] long ZOrderCmd );
     void IncrementRotation( [in] double Increment );
Index: oovbaapi/ooo/vba/msforms/XShapeRange.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XShapeRange.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XShapeRange.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,9 +44,25 @@
 
 module ooo {  module vba { module msforms {
 
+interface XLineFormat;
+interface XFillFormat;
 interface XShapeRange 
 {
     interface ooo::vba::XCollection;
+
+    [attribute] double Height;
+    [attribute] double Width;
+    [attribute] double Left;
+    [attribute] double Top;
+    [attribute, readonly] XLineFormat Line;
+    [attribute, readonly] XFillFormat Fill;
+    [attribute] boolean LockAspectRatio;
+    [attribute] boolean LockAnchor;
+    [attribute] long RelativeHorizontalPosition;
+    [attribute] long RelativeVerticalPosition;
+
+    any TextFrame();
+    any WrapFormat();
     void Select();
     XShape Group();
     void IncrementRotation( [in] double Increment );
Index: oovbaapi/ooo/vba/msforms/XLabel.idl
===================================================================
--- oovbaapi/ooo/vba/msforms/XLabel.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/msforms/XLabel.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -42,6 +42,7 @@
 {
 	[attribute] string Caption;
 	[attribute] any Value;
+	[attribute] long ForeColor; //liuchen 2009-7-3
 };
 
 //=============================================================================
Index: oovbaapi/ooo/vba/XCommandBarPopup.idl
===================================================================
--- oovbaapi/ooo/vba/XCommandBarPopup.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XCommandBarPopup.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XCommandBarPopup_idl__
+#define __ooo_vba_XCommandBarPopup_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XCommandBarPopup: com::sun::star::uno::XInterface
+{
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/XPageSetupBase.idl
===================================================================
--- oovbaapi/ooo/vba/XPageSetupBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XPageSetupBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XPageSetupBase_idl__
+#define __ooo_vba_XPageSetupBase_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {
+
+//=============================================================================
+
+
+interface XPageSetupBase
+{
+
+	interface ::ooo::vba::XHelperInterface;
+
+	//Attributes
+    [attribute] double TopMargin;
+    [attribute] double BottomMargin;
+    [attribute] double RightMargin;
+    [attribute] double LeftMargin;
+    [attribute] long Orientation;
+};
+
+//=============================================================================
+
+}; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/XDialogBase.idl
===================================================================
--- oovbaapi/ooo/vba/XDialogBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDialogBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDialog.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XDialog_idl__
+#define __ooo_vba_XDialog_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {
+                                                                                                                             
+//=============================================================================
+
+interface XDialogBase 
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	void Show();
+};
+                                                                                                                             
+}; };
+                                                                                                                             
+#endif
+
Index: oovbaapi/ooo/vba/XControlProvider.idl
===================================================================
--- oovbaapi/ooo/vba/XControlProvider.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XControlProvider.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XGlobals.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XControlProvider_idl__
+#define __ooo_vba_XControlProvider_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_frame_XModel_idl__
+#include <com/sun/star/frame/XModel.idl>
+#endif
+
+#ifndef __com_sun_star_awt_XControl_idl__
+#include <com/sun/star/awt/XControl.idl>
+#endif
+
+#ifndef __com_sun_star_drawing_XControlShape_idl__
+#include <com/sun/star/drawing/XControlShape.idl>
+#endif
+#ifndef __ooo_vba_msforms_XControl_idl__
+#include <ooo/vba/msforms/XControl.idl>
+#endif
+
+module ooo {  module vba { 
+
+interface XControlProvider 
+{
+   ::ooo::vba::msforms::XControl createControl( [in] ::com::sun::star::drawing::XControlShape xControl, [in] ::com::sun::star::frame::XModel xDocOwner );
+   ::ooo::vba::msforms::XControl createUserformControl( [in] ::com::sun::star::awt::XControl xControl, [in] ::com::sun::star::awt::XControl xDialog, [in] ::com::sun::star::frame::XModel xDocOwner );
+
+};
+
+}; };
+
+#endif
+
Index: oovbaapi/ooo/vba/XDocumentProperties.idl
===================================================================
--- oovbaapi/ooo/vba/XDocumentProperties.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDocumentProperties.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocument.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_XDocumentProperties_idl__
+#define __ooo_vba_XDocumentProperties_idl__
+
+#ifndef __com_sun_star_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+module ooo { module vba { 
+interface XDocumentProperty;
+interface XDocumentProperties
+{
+    interface XCollection;
+    /** Creates a new custom document property.
+     * You can only add a new document property to the custom DocumentProperties collection. Depending on value of
+     * boolean LinkSource, either (False) Value or (True) LinkSource must be provided.
+     * @param Name (Required String. The name of the property.
+     * @param LinkToContent Specifies whether the property is linked to the contents of the container document. If this argument is True, the LinkSource argument is required; if it's False, the value argument is required.
+     * @param Type The data type of the property. Can be one of the following MsoDocProperties constants:
+     * msoPropertyTypeBoolean, msoPropertyTypeDate, msoPropertyTypeFloat, msoPropertyTypeNumber, or msoPropertyTypeString.
+     * @param Value The value of the property, if it's not linked to the contents of the container document.
+     * The value is converted to match the data type specified by the type argument, if it can't be converted, an error occurs.
+     * If LinkToContent is True, the Value argument is ignored and the new document property is assigned a default value
+     * until the linked property values are updated by the container application (usually when the document is saved).
+     * @param LinkSource Ignored if LinkToContent is False. The source of the linked property. The container application determines
+     * what types of source linking you can use.
+     */
+    XDocumentProperty Add([in] string Name, [in] boolean LinkToContent, [in] /* MsoDocProperties */ byte Type, [in] any Value, 
+        [in] /*optional*/ any LinkSource)
+        raises (com::sun::star::script::BasicErrorException);
+};
+
+}; };
+
+#endif
+
Index: oovbaapi/ooo/vba/XDocumentsBase.idl
===================================================================
--- oovbaapi/ooo/vba/XDocumentsBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDocumentsBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocumentsBase.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XDocumentsBase_idl__
+#define __ooo_vba_XDocumentsBase_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {
+
+//=============================================================================
+
+interface XDocumentsBase 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/XApplicationBase.idl
===================================================================
--- oovbaapi/ooo/vba/XApplicationBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XApplicationBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XApplicationBase_idl__
+#define __ooo_vba_XApplicationBase_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XApplicationBase
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	[attribute] boolean ScreenUpdating;
+	[attribute] boolean DisplayStatusBar;
+	[attribute, readonly] string Version;
+
+	void Quit();
+
+    any CommandBars( [in] any aIndex );
+	void Run([in] string MacroName, [in] /*Optional*/ any varg1, [in] /*Optional*/ any varg2, [in] /*Optional*/ any varg3, [in] /*Optional*/ any varg4, [in] /*Optional*/ any varg5, [in] /*Optional*/ any varg6, [in] /*Optional*/ any varg7, [in] /*Optional*/ any varg8, [in] /*Optional*/ any varg9, [in] /*Optional*/ any varg10, [in] /*Optional*/ any varg11, [in] /*Optional*/ any varg12, [in] /*Optional*/ any varg13, [in] /*Optional*/ any varg14, [in] /*Optional*/ any varg15, [in] /*Optional*/ any varg16, [in] /*Optional*/ any varg17, [in] /*Optional*/ any varg18, [in] /*Optional*/ any varg19, [in] /*Optional*/ any varg20, [in] /*Optional*/ any varg21, [in] /*Optional*/ any varg22, [in] /*Optional*/ any varg23, [in] /*Optional*/ any varg24, [in] /*Optional*/ any varg25, [in] /*Optional*/ any varg26, [in] /*Optional*/ any varg27, [in] /*Optional*/ any varg28, [in] /*Optional*/ any varg29, [in] /*Optional*/ any varg30);
+    float CentimetersToPoints([in] float Centimeters );
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/XCommandBarButton.idl
===================================================================
--- oovbaapi/ooo/vba/XCommandBarButton.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XCommandBarButton.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XCommandBarButton_idl__
+#define __ooo_vba_XCommandBarButton_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XCommandBarButton: com::sun::star::uno::XInterface
+{
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/XFontBase.idl
===================================================================
--- oovbaapi/ooo/vba/XFontBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XFontBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XFont.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XFont_idl__
+#define __ooo_vba_XFont_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {
+
+interface XFontBase
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	[attribute] any   Size;
+	[attribute] any    ColorIndex;
+	[attribute] any    Color;
+	[attribute] any Bold;
+	[attribute] any Underline;
+	[attribute] any Strikethrough;
+	[attribute] any Shadow;
+	[attribute] any Italic;
+	[attribute] any Subscript;
+	[attribute] any Superscript;
+	[attribute] any  Name;
+};
+
+//=============================================================================
+
+}; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/XVPageBreaks.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XVPageBreaks.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XVPageBreaks.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVPageBreaks.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XVPageBreaks_idl__
+#define __ooo_vba_excel_XVPageBreaks_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+//interface XVPageBreak;
+
+interface XVPageBreaks
+{
+	interface ooo::vba::XCollection;
+	
+	//Methods	
+	any Add( [in] any Before ) raises( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/XPageSetup.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XPageSetup.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XPageSetup.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,20 +45,15 @@
 //=============================================================================
 
 
-interface XPageSetup
+interface XPageSetup : com::sun::star::uno::XInterface
 {
 
-	interface ::ooo::vba::XHelperInterface;
+//	interface ::ooo::vba::XHelperInterface;
 
 	//Attributes
     [attribute] string PrintArea;
-    [attribute] double TopMargin;
-    [attribute] double BottomMargin;
-    [attribute] double RightMargin;
-    [attribute] double LeftMargin;
     [attribute] double HeaderMargin;
     [attribute] double FooterMargin;
-    [attribute] long Orientation;
     [attribute] any FitToPagesTall;
     [attribute] any FitToPagesWide;
     [attribute] any Zoom;
Index: oovbaapi/ooo/vba/excel/XWorkbook.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XWorkbook.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XWorkbook.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -48,31 +48,20 @@
 interface XWorksheets;
 interface XStyles;
 
-interface XWorkbook
+interface XWorkbook : com::sun::star::uno::XInterface
 {
-	interface ::ooo::vba::XHelperInterface;
-
-	[attribute, readonly] string  Name;
-	[attribute, readonly] string  Path;
-	[attribute, readonly] string  FullName;
 	[attribute, readonly] boolean ProtectStructure; 
 	[attribute, readonly] XWorksheet ActiveSheet;
-	[attribute] boolean Saved;
 	[attribute, readonly] string  CodeName;
+	[attribute] boolean  PrecisionAsDisplayed;
 
 	any  Worksheets([in] any sheet);
 	any  Styles([in] any Index );
 	any  Sheets([in] any sheet);
 	any  Windows([in] any index );
-	void Close([in] any SaveChanges, [in] any FileName, [in] any RouteWorkBook);
-	void Protect( [in] any Password );
-	void Unprotect( [in] any Password );
-	void Save();
-	void Activate();
 	void ResetColors() raises (com::sun::star::script::BasicErrorException);
-
+	void Activate();
 	any Names( [in] any Index );
-
 	any Colors([in] any Index) raises (com::sun::star::script::BasicErrorException);
 	long FileFormat() raises (com::sun::star::script::BasicErrorException);
 	void SaveCopyAs( [in] string Filename );
Index: oovbaapi/ooo/vba/excel/XFont.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XFont.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XFont.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,22 +47,9 @@
 
 interface XFont
 {
-	interface ::ooo::vba::XHelperInterface;
-
-	[attribute] any   Size;
 	[attribute] any StandardFontSize;
 	[attribute] any  StandardFont;
 	[attribute] any  FontStyle;
-	[attribute] any    ColorIndex;
-	[attribute] any    Color;
-	[attribute] any Bold;
-	[attribute] any Underline;
-	[attribute] any Strikethrough;
-	[attribute] any Shadow;
-	[attribute] any Italic;
-	[attribute] any Subscript;
-	[attribute] any Superscript;
-	[attribute] any  Name;
 	[attribute] any  OutlineFont;
 };
 
Index: oovbaapi/ooo/vba/excel/XVPageBreak.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XVPageBreak.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XVPageBreak.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVPageBreak.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XVPageBreak_idl__
+#define __ooo_vba_excel_XVPageBreak_idl__
+
+#ifndef __ooo_vba_excel_XPageBreak_idl__
+#include <ooo/vba/excel/XPageBreak.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XVPageBreak
+{
+	interface ::ooo::vba::excel::XPageBreak;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/makefile.mk
===================================================================
--- oovbaapi/ooo/vba/excel/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,15 +38,12 @@
 # --- Settings -----------------------------------------------------
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ENDIF
-
 # ------------------------------------------------------------------------
 
 
-IDLFILES= XApplication.idl\
+IDLFILES= XGlobals.idl\
+	Globals.idl\
+	XApplication.idl\
 	XComment.idl\
 	XComments.idl\
 	XRange.idl\
@@ -103,6 +100,15 @@
  	XPageBreak.idl \
  	XHPageBreak.idl \
  	XHPageBreaks.idl \
+ 	XVPageBreak.idl \
+ 	XVPageBreaks.idl \
+ 	TextFrame.idl \
+ 	XMenuBar.idl \
+ 	XMenuBars.idl \
+ 	XMenu.idl \
+ 	XMenus.idl \
+ 	XMenuItem.idl \
+ 	XMenuItems.idl \
 
 
 # ------------------------------------------------------------------
Index: oovbaapi/ooo/vba/excel/XApplication.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XApplication.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XApplication.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -42,10 +42,6 @@
 #include <ooo/vba/XAssistant.idl>
 #endif
 
-#ifndef __ooo_vba_XCommandBars_idl__
-#include <ooo/vba/XCommandBars.idl>
-#endif
-
 module ooo {  module vba {  module excel { 
 
 interface XRange;
@@ -56,10 +52,10 @@
 interface XWindow;
 interface XWorksheet;
 
-interface XApplication
+interface XApplication : com::sun::star::uno::XInterface
 {
 
-	interface ::ooo::vba::XHelperInterface;
+//	interface ::ooo::vba::XHelperInterface;
 
 	[attribute, readonly] any Selection;
 	[attribute, readonly] XWorkbook ActiveWorkbook;
@@ -74,14 +70,11 @@
 	// to determine this
 	[attribute, readonly] XWorkbook ThisWorkbook;
 	[attribute, readonly] string Name;
-	[attribute] boolean ScreenUpdating;
-	[attribute] boolean DisplayStatusBar;
 	[attribute] boolean DisplayAlerts;
 	[attribute] boolean DisplayFormulaBar;
 	[attribute] any CutCopyMode;
 	[attribute] any StatusBar;
 	[attribute] long Cursor; 
-	[attribute, readonly] string Version;
 
 	void setDefaultFilePath([in] string DefaultFilePath) raises(com::sun::star::script::BasicErrorException);
 
@@ -90,7 +83,7 @@
 	string LibraryPath() raises(com::sun::star::script::BasicErrorException);
 	string TemplatesPath() raises(com::sun::star::script::BasicErrorException);
 	string PathSeparator() raises(com::sun::star::script::BasicErrorException);
-    any CommandBars( [in] any aIndex );
+    //any CommandBars( [in] any aIndex );
 	any Workbooks( [in] any aIndex );
 	any Worksheets( [in] any aIndex );
 	any Windows( [in] any aIndex );
@@ -109,7 +102,8 @@
 	XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
         raises(com::sun::star::script::BasicErrorException);
 	void Volatile([in] any Volatile);
-	void DoEvents();
+	any Caller( [in] any aIndex );
+	any MenuBars( [in] any aIndex );
 };
 
 }; }; };
Index: oovbaapi/ooo/vba/excel/XMenu.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenu.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenu.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenu_idl__
+#define __ooo_vba_excel_XMenu_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenu
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+    any MenuItems( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/excel/XMenuItems.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenuItems.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenuItems.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuItems.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItems_idl__
+#define __ooo_vba_excel_XMenuItems_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuItem;
+
+interface XMenuItems
+{
+	interface ooo::vba::XCollection;
+
+    XMenuItem Add( [in] string Caption, [in] any OnAction, [in] any ShortcutKey, [in] any Before, [in] any Restore, [in] any StatusBar, [in] any HelpFile, [in] any HelpContextID ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/XWindow.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XWindow.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XWindow.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -46,10 +46,8 @@
 interface XRange;
 interface XWorksheet;
 interface XPane;
-interface XWindow
+interface XWindow : com::sun::star::uno::XInterface
 {
-	interface ::ooo::vba::XHelperInterface;
-
 	[attribute] any Caption;
 	[attribute] boolean DisplayGridlines; 
 	[attribute] boolean DisplayHeadings; 
@@ -58,8 +56,6 @@
 	[attribute] boolean DisplayVerticalScrollBar; 
 	[attribute] boolean DisplayWorkbookTabs; 
 	[attribute] boolean FreezePanes; 
-	[attribute] long Height; 
-	[attribute] long Left; 
 	[attribute] boolean Split; 
 	[attribute] long SplitColumn;
 	[attribute] double SplitHorizontal;
@@ -67,10 +63,7 @@
 	[attribute] double SplitVertical;
 	[attribute] any ScrollColumn;
 	[attribute] any ScrollRow;
-	[attribute] long Top; 
 	[attribute] any View;
-	[attribute] boolean Visible;
-	[attribute] long Width; 
 	[attribute] any WindowState;
 	[attribute] any Zoom;
 	any SelectedSheets( [in] any aIndex );
Index: oovbaapi/ooo/vba/excel/XWorkbooks.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XWorkbooks.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XWorkbooks.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,9 +45,8 @@
 
 //=============================================================================
 
-interface XWorkbooks 
+interface XWorkbooks : com::sun::star::uno::XInterface
 {
-	interface ::ooo::vba::XCollection;
 	any Add();
 	any Open([in] string Filename, [in] any UpdateLinks, [in] any ReadOnly, [in] any Format, [in] any Password, [in] any WriteResPassword, [in] any IgnoreReadOnlyRecommended, [in] any Origin, [in] any Delimiter, [in] any Editable, [in] any Notify, [in] any Converter, [in] any AddToMru);
 
Index: oovbaapi/ooo/vba/excel/XDialogs.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XDialogs.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XDialogs.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,9 +33,6 @@
 #ifndef __com_sun_star_uno_XInterface_idl__
 #include <com/sun/star/uno/XInterface.idl>
 #endif
-#ifndef __ooo_vba_XCollection_idl__
-#include <ooo/vba/XCollection.idl>
-#endif
 
 #ifndef __ooo_vba_XHelperInterface_idl__
 #include <ooo/vba/XHelperInterface.idl>
@@ -44,16 +41,10 @@
 //=============================================================================
                                                                                                                              
 module ooo {  module vba {  module excel {
-interface XApplication;                                                                                                                             
-//=============================================================================
                                                                                                                              
-//interface XDialogs : ::ooo::vba::XCollection
-interface XDialogs 
+interface XDialogs : com::sun::star::uno::XInterface
 {
-	interface ::ooo::vba::XHelperInterface;
 
-        [attribute, readonly] long Count;
-
 	any Item( [in] any Index );
 };
                                                                                                                              
Index: oovbaapi/ooo/vba/excel/XGlobals.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XGlobals.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XGlobals.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XGlobals.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XGlobals_idl__
+#define __ooo_vba_excel_XGlobals_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __com_sun_star_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+#ifndef __ooo_vba_excel_XWorkbook_idl__
+#include <ooo/vba/excel/XWorkbook.idl>
+#endif
+#ifndef __ooo_vba_excel_XWorksheet_idl__
+#include <ooo/vba/excel/XWorksheet.idl>
+#endif
+#ifndef __ooo_vba_XAssistant_idl__
+#include <ooo/vba/XAssistant.idl>
+#endif
+
+module ooo {  module vba {  module excel {
+interface XRange;
+interface XWindow;
+interface XGlobals: com::sun::star::uno::XInterface
+{
+	[attribute, readonly] ooo::vba::excel::XWorkbook ActiveWorkbook;
+	[attribute, readonly] ooo::vba::excel::XWorksheet ActiveSheet;
+	[attribute, readonly] ooo::vba::excel::XWindow ActiveWindow;
+	[attribute, readonly] ooo::vba::excel::XRange ActiveCell;
+	[attribute, readonly] ooo::vba::XAssistant Assistant;
+	[attribute, readonly] any Selection;
+	[attribute, readonly] XWorkbook ThisWorkbook;
+
+	void Calculate() raises(com::sun::star::script::BasicErrorException);
+	XRange Cells([in] any RowIndex, [in] any ColumnIndex);
+	XRange Columns([in] any aIndex);
+	any CommandBars( [in] any aIndex );
+	any Evaluate( [in] string Name );
+XRange Intersect([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
+        raises(com::sun::star::script::BasicErrorException);
+	any WorkSheets( [in] any aIndex );
+	any WorkBooks( [in] any aIndex );
+	any WorksheetFunction();
+	any Windows( [in] any aIndex );
+	any Sheets( [in] any aIndex );
+	any Range( [in] any Cell1, [in] any Cell2 );
+	XRange Rows([in] any aIndex);
+	any Names( [in] any Index );
+	XRange Union([in] XRange Arg1, [in] XRange Arg2, [in] /*Optional*/ any Arg3, [in] /*Optional*/ any Arg4, [in] /*Optional*/ any Arg5, [in] /*Optional*/ any Arg6, [in] /*Optional*/ any Arg7, [in] /*Optional*/ any Arg8, [in] /*Optional*/ any Arg9, [in] /*Optional*/ any Arg10, [in] /*Optional*/ any Arg11, [in] /*Optional*/ any Arg12, [in] /*Optional*/ any Arg13, [in] /*Optional*/ any Arg14, [in] /*Optional*/ any Arg15, [in] /*Optional*/ any Arg16, [in] /*Optional*/ any Arg17, [in] /*Optional*/ any Arg18, [in] /*Optional*/ any Arg19, [in] /*Optional*/ any Arg20, [in] /*Optional*/ any Arg21, [in] /*Optional*/ any Arg22, [in] /*Optional*/ any Arg23, [in] /*Optional*/ any Arg24, [in] /*Optional*/ any Arg25, [in] /*Optional*/ any Arg26, [in] /*Optional*/ any Arg27, [in] /*Optional*/ any Arg28, [in] /*Optional*/ any Arg29, [in] /*Optional*/ any Arg30)
+        raises(com::sun::star::script::BasicErrorException);
+	any MenuBars( [in] any aIndex );
+
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/XMenuItem.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenuItem.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenuItem.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuItem_idl__
+#define __ooo_vba_excel_XMenuItem_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuItem
+{
+	interface XHelperInterface;
+
+    [attribute] string Caption;
+    [attribute] string OnAction;
+
+    void Delete() raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/excel/XMenus.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenus.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenus.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenus.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenus_idl__
+#define __ooo_vba_excel_XMenus_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenu;
+
+interface XMenus
+{
+	interface ooo::vba::XCollection;
+
+    XMenu Add( [in] string Caption, [in] any Before, [in] any Restore ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/excel/XMenuBar.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenuBar.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenuBar.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBar_idl__
+#define __ooo_vba_excel_XMenuBar_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+//=============================================================================
+
+interface XMenuBar
+{
+	interface XHelperInterface;
+
+    any Menus( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/excel/XDialog.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XDialog.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XDialog.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,13 +45,8 @@
                                                                                                                              
 //=============================================================================
 
-interface XApplication;
-                                                                                                                             
-interface XDialog 
+interface XDialog : com::sun::star::uno::XInterface
 {
-	interface ::ooo::vba::XHelperInterface;
-
-	void Show();
 };
                                                                                                                              
 }; }; };
Index: oovbaapi/ooo/vba/excel/XTextFrame.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XTextFrame.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XTextFrame.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,21 +34,9 @@
 #include <ooo/vba/XHelperInterface.idl>
 #endif
 
-#ifndef __ooo_vba_excel_XCharacters_idl__
-#include <ooo/vba/excel/XCharacters.idl>
-#endif
-
 module ooo {  module vba {  module excel {
-interface XTextFrame : ooo::vba::XHelperInterface
+interface XTextFrame : com::sun::star::uno::XInterface
 {
-    [attribute] boolean AutoSize;
-    [attribute] float MarginBottom;
-    [attribute] float MarginTop;
-    [attribute] float MarginLeft;
-    [attribute] float MarginRight;
-    XCharacters Characters();
-    /*I don't find it in msdn
-    Range TextRange();*/
 };
 }; }; };
 #endif
Index: oovbaapi/ooo/vba/excel/XWorksheet.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XWorksheet.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XWorksheet.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -42,6 +42,9 @@
 #include <com/sun/star/script/XInvocation.idl>
 #endif
 
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
 //=============================================================================
 
 module ooo {  module vba {  module excel { 
@@ -53,12 +56,13 @@
 interface XOutline;
 interface XPageSetup;
 interface XHPageBreaks;
+interface XVPageBreaks;
 interface XWorksheet
 {
 	interface ::ooo::vba::XHelperInterface;
 	interface ::com::sun::star::script::XInvocation;
+	interface ::com::sun::star::container::XNamed;
 
-        [attribute] string Name;
 	[attribute] boolean Visible; 
 	[attribute, readonly] long StandardHeight;
 	[attribute, readonly] long StandardWidth;
@@ -70,6 +74,7 @@
 	[attribute, readonly] XWorksheet Previous;
 	[attribute, readonly] string CodeName;
  	[attribute, readonly] short Index;
+ 	[attribute] long EnableSelection;
 	
 	void Activate();
 	void Calculate( );
@@ -88,6 +93,7 @@
 	XOutline Outline();
 	XPageSetup PageSetup();
 	any HPageBreaks([in] any Index);
+	any VPageBreaks([in] any Index);
 	any OLEObjects([in] any Index);
 	void ShowDataForm();
 	any Shapes([in] any Index);
Index: oovbaapi/ooo/vba/excel/Globals.idl
===================================================================
--- oovbaapi/ooo/vba/excel/Globals.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/Globals.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,48 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: Globals.idl,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_excel_Globals_idl__
+#define __ooo_vba_excel_Globals_idl__
+
+#ifndef __ooo_vba_excel_XGlobals_idl__
+#include <ooo/vba/excel/XGlobals.idl>
+#endif
+
+#include <com/sun/star/uno/XComponentContext.idl>
+#include <com/sun/star/table/XCellRange.idl>
+
+module ooo {  module vba { module excel {
+service Globals : XGlobals
+{
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/excel/XRange.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XRange.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/excel/XRange.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,9 @@
 #ifndef __com_sun_star_script_XDefaultMethod_idl__
 #include <com/sun/star/script/XDefaultMethod.idl>
 #endif
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#include <com/sun/star/script/XErrorQuery.idl>
+#endif
 #ifndef __ooo_vba_XCollection_idl__
 #include <ooo/vba/XCollection.idl>
 #endif
@@ -77,6 +80,7 @@
  	interface com::sun::star::container::XEnumerationAccess;
 	interface com::sun::star::script::XDefaultMethod;
 	interface com::sun::star::script::XDefaultProperty;
+	interface com::sun::star::script::XErrorQuery;
 	interface ::ooo::vba::excel::XFormat;
 	//interface ::ooo::vba::XHelperInterface;
 
Index: oovbaapi/ooo/vba/excel/TextFrame.idl
===================================================================
--- oovbaapi/ooo/vba/excel/TextFrame.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/TextFrame.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_excel_TextFrame_idl__
+#define __ooo_vba_excel_TextFrame_idl__
+
+#ifndef __ooo_vba_excel_XTextFrame_idl__
+#include <ooo/vba/excel/XTextFrame.idl>
+#endif
+
+#include <com/sun/star/uno/XComponentContext.idl>
+
+module ooo {  module vba { module excel {
+service TextFrame : XTextFrame
+{
+  	//createTextFrame(  [in] ::ooo::vba::XHelperInterface Parent, [in] ::com::sun::star::frame::XModel xModel );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/excel/XMenuBars.idl
===================================================================
--- oovbaapi/ooo/vba/excel/XMenuBars.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/excel/XMenuBars.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XMenuBars.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_excel_XMenuBars_idl__
+#define __ooo_vba_excel_XMenuBars_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_helper_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module excel { 
+
+//=============================================================================
+
+interface XMenuBars
+{
+	interface ooo::vba::XCollection;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/XWindowBase.idl
===================================================================
--- oovbaapi/ooo/vba/XWindowBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XWindowBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XHelperWindow_idl__
+#define __ooo_vba_XHelperWindow_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XWindowBase
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	[attribute] long Height; 
+	[attribute] long Left; 
+	[attribute] long Top; 
+	[attribute] boolean Visible;
+	[attribute] long Width; 
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/XCommandBar.idl
===================================================================
--- oovbaapi/ooo/vba/XCommandBar.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/XCommandBar.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,9 +54,12 @@
 
     [attribute] string Name;
     [attribute] boolean Visible;
+    [attribute] boolean Enabled;
     
     void Delete() raises ( com::sun::star::script::BasicErrorException );
     any Controls( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
+    long Type() raises ( com::sun::star::script::BasicErrorException );
+    any FindControl( [in] any Type, [in] any Id, [in] any Tag, [in] any Visible, [in] any Recursive ) raises ( com::sun::star::script::BasicErrorException );
 };
 
 }; };
Index: oovbaapi/ooo/vba/ControlProvider.idl
===================================================================
--- oovbaapi/ooo/vba/ControlProvider.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/ControlProvider.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XGlobals.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_ControlProvider_idl__
+#define __ooo_vba_ControlProvider_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_frame_XModel_idl__
+#include <com/sun/star/frame/XModel.idl>
+#endif
+
+
+module ooo {  module vba { 
+
+interface XControlProvider;
+
+service ControlProvider 
+{
+    interface ::ooo::vba::XControlProvider;
+};
+
+}; };
+
+#endif
+
Index: oovbaapi/ooo/vba/XCommandBarControl.idl
===================================================================
--- oovbaapi/ooo/vba/XCommandBarControl.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/XCommandBarControl.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,6 +54,8 @@
     [attribute] string Caption;
     [attribute] string OnAction;
     [attribute] boolean Visible;
+    [attribute, readonly] long Type;
+    [attribute] boolean Enabled;
     
     void Delete() raises ( com::sun::star::script::BasicErrorException );
     any Controls( [in] any Index ) raises ( com::sun::star::script::BasicErrorException );
Index: oovbaapi/ooo/vba/XVBAToOOEventDescGen.idl
===================================================================
--- oovbaapi/ooo/vba/XVBAToOOEventDescGen.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/XVBAToOOEventDescGen.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -41,8 +41,8 @@
 module ooo {  module vba { 
 interface XVBAToOOEventDescGen : com::sun::star::uno::XInterface
 {
-	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sLibModName, [in] sequence< string > handlerExts );
-	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl );
+	sequence< com::sun::star::script::ScriptEventDescriptor >  getEventDescriptions( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
+	com::sun::star::script::XScriptEventsSupplier getEventSupplier( [in] com::sun::star::uno::XInterface xControl, [in] string sCodeName );
 };
 
 }; };
Index: oovbaapi/ooo/vba/XDocumentBase.idl
===================================================================
--- oovbaapi/ooo/vba/XDocumentBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDocumentBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XDocumentBase_idl__
+#define __ooo_vba_XDocumentBase_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba { 
+//=============================================================================
+
+interface XDocumentBase
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	[attribute, readonly] string  Name;
+	[attribute, readonly] string  Path;
+	[attribute, readonly] string  FullName;
+	[attribute] boolean Saved;
+
+	void Close([in] any SaveChanges, [in] any FileName, [in] any RouteWorkBook);
+	void Save();
+	void Activate();
+	void Protect( [in] any Password );
+	void Unprotect( [in] any Password );
+};
+
+}; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XFind.idl
===================================================================
--- oovbaapi/ooo/vba/word/XFind.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XFind.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFind_idl__
+#define __ooo_vba_word_XFind_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFind
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Text;
+    [attribute] any Replacement;
+    [attribute] boolean Forward;
+    [attribute] long Wrap;
+    [attribute] boolean Format;
+    [attribute] boolean MatchCase;
+    [attribute] boolean MatchWholeWord;
+    [attribute] boolean MatchWildcards;
+    [attribute] boolean MatchSoundsLike;
+    [attribute] boolean MatchAllWordForms;
+    [attribute] any Style;
+
+    boolean Execute([in] /* string */ any FindText,
+        [in] /* boolean */ any MatchCase,
+        [in] /* boolean */ any MatchWholeWord,
+        [in] /* boolean */ any MatchWildcards,
+        [in] /* boolean */ any MatchSoundsLike,
+        [in] /* boolean */ any MatchAllWordForms,
+        [in] /* boolean */ any Forward,
+        [in] /* long */ any Wrap,
+        [in] /* boolean */ any Format,
+        [in] /* string */ any ReplaceWith,
+        [in] /* boolean */ any Replace,
+        [in] /* boolean */ any MatchKashida,
+        [in] /* boolean */ any MatchDiacritics,
+        [in] /* boolean */ any MatchAlefHamza,
+        [in] /* boolean */ any MatchControl,
+        [in] /* boolean */ any MatchPrefix,
+        [in] /* boolean */ any MatchSuffix,
+        [in] /* boolean */ any MatchPhrase,
+        [in] /* boolean */ any IgnoreSpace,
+        [in] /* boolean */ any IgnorePunct );
+    void ClearFormatting();
+
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XDialogs.idl
===================================================================
--- oovbaapi/ooo/vba/word/XDialogs.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XDialogs.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDialogs.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XDialogs_idl__
+#define __ooo_vba_word_XDialogs_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  module word {
+                                                                                                                             
+interface XDialogs : com::sun::star::uno::XInterface
+{
+
+	any Item( [in] any Index );
+};
+                                                                                                                             
+}; }; };
+                                                                                                                             
+#endif
+
Index: oovbaapi/ooo/vba/word/XPane.idl
===================================================================
--- oovbaapi/ooo/vba/word/XPane.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XPane.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XPane_idl__
+#define __ooo_vba_word_XPane_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XPane
+{
+    interface ooo::vba::XHelperInterface;
+
+    any View();
+    void Close();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XGlobals.idl
===================================================================
--- oovbaapi/ooo/vba/word/XGlobals.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XGlobals.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XGlobals.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XGlobals_idl__
+#define __ooo_vba_word_XGlobals_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+interface XDocument;
+interface XWindow;
+interface XSystem;
+interface XOptions;
+interface XSelection;
+interface XGlobals : com::sun::star::uno::XInterface
+{
+	[attribute, readonly] XDocument ActiveDocument;
+	[attribute, readonly] XWindow ActiveWindow;
+	[attribute, readonly] string Name;
+	[attribute, readonly] ooo::vba::word::XSystem System;
+	[attribute, readonly] ooo::vba::word::XOptions Options;
+	[attribute, readonly] ooo::vba::word::XSelection Selection;
+    any CommandBars( [in] any aIndex );
+    any Documents( [in] any aIndex );
+    any Addins( [in] any aIndex );
+    any Dialogs( [in] any aIndex );
+    float CentimetersToPoints([in] float Centimeters );
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XField.idl
===================================================================
--- oovbaapi/ooo/vba/word/XField.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XField.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XField.idl,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: jsc $ $Date: 2007/02/09 08:35:01 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_word_XField_idl__
+#define __ooo_vba_word_XField_idl__
+
+#ifndef  __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+module ooo { module vba { module word {
+
+interface XField 
+{
+    interface ::ooo::vba::XHelperInterface;
+};
+
+}; }; };
+
+#endif
+
Index: oovbaapi/ooo/vba/word/XSelection.idl
===================================================================
--- oovbaapi/ooo/vba/word/XSelection.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XSelection.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XSelection_idl__
+#define __ooo_vba_word_XSelection_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XParagraphFormat;
+interface XFind;
+interface XFont;
+interface XStyle;
+interface XHeaderFooter;
+interface XSelection
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Text;
+    [attribute, readonly] XRange Range;
+    [attribute] XParagraphFormat ParagraphFormat;
+    [attribute, readonly] XFind Find;
+    [attribute] XStyle Style;
+    [attribute, readonly] XFont Font;
+    [attribute, readonly] XHeaderFooter HeaderFooter;
+    [attribute] long LanguageID;
+    [attribute] long Start;
+    [attribute] long End;
+
+    any Tables( [in] any aIndex );
+    any Fields( [in] any aIndex );
+    void TypeText( [in] string Text );
+    void HomeKey( [in] any Unit, [in] any Extend );
+    void EndKey( [in] any Unit, [in] any Extend );
+    void Delete( [in] any Unit, [in] any Count );
+    void MoveRight( [in] any Unit, [in] any Count, [in] any Extend );
+    void MoveLeft( [in] any Unit, [in] any Count, [in] any Extend );
+    void MoveDown( [in] any Unit, [in] any Count, [in] any Extend );
+    void TypeParagraph();
+    void InsertParagraph();
+    void InsertParagraphBefore();
+    void InsertParagraphAfter();
+    void TypeBackspace();
+    XRange GoTo( [in] any What, [in] any Which, [in] any Count, [in] any Name );
+    any Information( [in] long Type );
+    void InsertBreak( [in] any Type );
+    any ShapeRange();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XVariable.idl
===================================================================
--- oovbaapi/ooo/vba/word/XVariable.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XVariable.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XVariable_idl__
+#define __ooo_vba_word_XVariable_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XVariable
+{
+    interface ooo::vba::XHelperInterface;
+	interface ::com::sun::star::container::XNamed;
+
+    [attribute] any Value;
+    [attribute, readonly] long Index;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XTable.idl
===================================================================
--- oovbaapi/ooo/vba/word/XTable.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XTable.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XTable.idl,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: jsc $ $Date: 2007/02/09 08:35:01 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_word_XTable_idl__
+#define __ooo_vba_word_XTable_idl__
+
+#ifndef  __com_sun_star_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+#ifndef  __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+module ooo { module vba { module word {
+
+interface XRange;
+
+interface XTable 
+{
+    interface ::ooo::vba::XHelperInterface;
+    [attribute, readonly ] string Name; // for debug only
+
+    XRange Range() raises (com::sun::star::script::BasicErrorException);
+
+    /**
+     select the table
+     */
+    void Select()
+        raises (com::sun::star::script::BasicErrorException);
+
+    /**
+     delete the table
+     */
+    void Delete()
+        raises (com::sun::star::script::BasicErrorException);
+
+    /**
+     convert the table to text
+     @param Separator the separator used for the text where cell separation was
+     @return XRange a range containing the text
+     @throw BasicErrorException when the conversion cannot be done
+     */
+/*
+    XRange ConvertToText([in] any Separator, [in] any NestedTables)
+        raises(com::sun::star::script::BasicErrorException);
+*/
+    any Borders( [in] any aIndex );
+
+};
+
+}; }; };
+
+#endif
+
Index: oovbaapi/ooo/vba/word/XParagraphs.idl
===================================================================
--- oovbaapi/ooo/vba/word/XParagraphs.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XParagraphs.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XParagraphs_idl__
+#define __ooo_vba_word_XParagraphs_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XParagraphs 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XOptions.idl
===================================================================
--- oovbaapi/ooo/vba/word/XOptions.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XOptions.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XOptions_idl__
+#define __ooo_vba_word_XOptions_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XOptions
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long DefaultBorderLineStyle;
+    [attribute] long DefaultBorderLineWidth;
+    [attribute] long DefaultBorderColorIndex;
+    [attribute] boolean ReplaceSelection;
+    [attribute] boolean MapPaperSize;
+    [attribute] boolean AutoFormatAsYouTypeApplyHeadings;
+    [attribute] boolean AutoFormatAsYouTypeApplyBulletedLists;
+    [attribute] boolean AutoFormatAsYouTypeApplyNumberedLists;
+    [attribute] boolean AutoFormatAsYouTypeFormatListItemBeginning;
+    [attribute] boolean AutoFormatAsYouTypeDefineStyles;
+    [attribute] boolean AutoFormatApplyHeadings;
+    [attribute] boolean AutoFormatApplyLists;
+    [attribute] boolean AutoFormatApplyBulletedLists;
+
+    any DefaultFilePath( [in] long Path );
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XPageSetup.idl
===================================================================
--- oovbaapi/ooo/vba/word/XPageSetup.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XPageSetup.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XPageSetup_idl__
+#define __ooo_vba_word_XPageSetup_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+
+interface XPageSetup : com::sun::star::uno::XInterface
+{
+    [attribute] double Gutter;
+    [attribute] double HeaderDistance;
+    [attribute] double FooterDistance;
+    [attribute] boolean DifferentFirstPageHeaderFooter;
+    [attribute] long SectionStart;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XReplacement.idl
===================================================================
--- oovbaapi/ooo/vba/word/XReplacement.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XReplacement.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XReplacement_idl__
+#define __ooo_vba_word_XReplacement_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XReplacement
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Text;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XDialog.idl
===================================================================
--- oovbaapi/ooo/vba/word/XDialog.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XDialog.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDialog.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XDialog_idl__
+#define __ooo_vba_word_XDialog_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {  module word {
+                                                                                                                             
+//=============================================================================
+
+interface XDialog : com::sun::star::uno::XInterface
+{
+};
+                                                                                                                             
+}; }; };
+                                                                                                                             
+#endif
+
Index: oovbaapi/ooo/vba/word/XStyle.idl
===================================================================
--- oovbaapi/ooo/vba/word/XStyle.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XStyle.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XStyle_idl__
+#define __ooo_vba_word_XStyle_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XFont;
+interface XStyle
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Name;
+    [attribute] long LanguageID;
+    [attribute, readonly] long Type;
+    [attribute, readonly] XFont Font;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XDocuments.idl
===================================================================
--- oovbaapi/ooo/vba/word/XDocuments.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XDocuments.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XDocuments_idl__
+#define __ooo_vba_word_XDocuments_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XDocuments : com::sun::star::uno::XInterface
+{
+	any Add([in] any Template, [in] any NewTemplate, [in] any DocumentType, [in] any Visible);
+	any Open([in] string Filename, [in] any ConfirmConversions, [in] any ReadOnly, [in] any AddToRecentFiles, [in] any PasswordDocument, [in] any PasswordTemplate, [in] any Revert, [in] any WritePasswordDocument, [in] any WritePasswordTemplate, [in] any Format, [in] any Encoding, [in] any Visible, [in] any OpenAndRepair, [in] any DocumentDirection, [in] any NoEncodingDialog, [in] any XMLTransform);
+
+	void Close([in] any SaveChanges,[in] any OriginalFormat,[in] any RouteDocument);
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XSection.idl
===================================================================
--- oovbaapi/ooo/vba/word/XSection.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XSection.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XSection_idl__
+#define __ooo_vba_word_XSection_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XSection
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] boolean ProtectedForForms;
+
+    any Headers();
+    any Footers();
+    any PageSetup();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XParagraph.idl
===================================================================
--- oovbaapi/ooo/vba/word/XParagraph.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XParagraph.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XParagraph_idl__
+#define __ooo_vba_word_XParagraph_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XParagraph
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute, readonly] XRange Range;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XFont.idl
===================================================================
--- oovbaapi/ooo/vba/word/XFont.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XFont.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XFont.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XFont_idl__
+#define __ooo_vba_word_XFont_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+interface XFont : com::sun::star::uno::XInterface
+{
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XAutoTextEntries.idl
===================================================================
--- oovbaapi/ooo/vba/word/XAutoTextEntries.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XAutoTextEntries.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XAutoTextEntries_idl__
+#define __ooo_vba_word_XAutoTextEntries_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XAutoTextEntries 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XTemplate.idl
===================================================================
--- oovbaapi/ooo/vba/word/XTemplate.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XTemplate.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XTemplate_idl__
+#define __ooo_vba_word_XTemplate_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XTemplate
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute, readonly] string Name;
+
+    any AutoTextEntries( [in] any aIndex );
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XParagraphFormat.idl
===================================================================
--- oovbaapi/ooo/vba/word/XParagraphFormat.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XParagraphFormat.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XParagraphFormat_idl__
+#define __ooo_vba_word_XParagraphFormat_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+module ooo {  module vba {  module word { 
+
+interface XParagraphFormat
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Alignment;
+    [attribute] float FirstLineIndent;
+    [attribute] any KeepTogether;
+    [attribute] any KeepWithNext;
+    [attribute] any Hyphenation;
+    [attribute] float LineSpacing;
+    [attribute] long LineSpacingRule;
+    [attribute] any NoLineNumber;
+    [attribute] long OutlineLevel;
+    [attribute] any PageBreakBefore;
+    [attribute] float SpaceBefore;
+    [attribute] float SpaceAfter;
+    [attribute] float LeftIndent;
+    [attribute] float RightIndent;
+    [attribute] any TabStops;
+    [attribute] any WidowControl;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XWrapFormat.idl
===================================================================
--- oovbaapi/ooo/vba/word/XWrapFormat.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XWrapFormat.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,48 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XWrapFormat.idl,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XWrapFormat_idl__
+#define __ooo_vba_word_XWrapFormat_idl__
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word {
+interface XWrapFormat : ooo::vba::XHelperInterface
+{
+    [attribute] long Type;
+    [attribute] long Side;
+    [attribute] float DistanceTop;
+    [attribute] float DistanceBottom;
+    [attribute] float DistanceLeft;
+    [attribute] float DistanceRight;
+};
+}; }; };
+#endif
Index: oovbaapi/ooo/vba/word/XStyles.idl
===================================================================
--- oovbaapi/ooo/vba/word/XStyles.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XStyles.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XStyles_idl__
+#define __ooo_vba_word_XStyles_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XStyles 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/makefile.mk
===================================================================
--- oovbaapi/ooo/vba/word/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,90 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.4 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+PRJ=..$/..$/..
+
+PRJNAME=oovapi
+
+TARGET=word
+PACKAGE=ooo$/vba$/Word
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# ------------------------------------------------------------------------
+
+
+IDLFILES= XGlobals.idl\
+	XApplication.idl \
+	XDocument.idl \
+	XWindow.idl \
+	XSystem.idl \
+	XRange.idl \
+	XBookmark.idl \
+	XBookmarks.idl \
+	XVariable.idl \
+	XVariables.idl \
+	XView.idl \
+	XPane.idl \
+	XPanes.idl \
+	XOptions.idl \
+	XSelection.idl \
+ 	XTemplate.idl \
+	XParagraphFormat.idl \
+	XAutoTextEntries.idl \
+	XAutoTextEntry.idl \
+	XParagraphs.idl \
+	XParagraph.idl \
+	XFind.idl \
+	XReplacement.idl \
+	XStyle.idl \
+	XStyles.idl \
+    XFont.idl \
+    XTable.idl \
+    XTables.idl \
+    XField.idl \
+    XFields.idl \
+    XBorder.idl \
+    XBorders.idl \
+    XDocuments.idl \
+    XHeaderFooter.idl \
+    XAddins.idl \
+    XAddin.idl \
+    XDialogs.idl \
+    XDialog.idl \
+	XWrapFormat.idl \
+	XPageSetup.idl \
+	XSection.idl \
+	XSections.idl \
+
+# ------------------------------------------------------------------
+
+.INCLUDE :  target.mk
+
Index: oovbaapi/ooo/vba/word/XSystem.idl
===================================================================
--- oovbaapi/ooo/vba/word/XSystem.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XSystem.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XSystem_idl__
+#define __ooo_vba_word_XSystem_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+module ooo {  module vba {  module word { 
+
+interface XSystem
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long Cursor;
+    any PrivateProfileString( [in] string Filename, [in] string Section, [in] string Key );
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XSections.idl
===================================================================
--- oovbaapi/ooo/vba/word/XSections.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XSections.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XSections_idl__
+#define __ooo_vba_word_XSections_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XSections 
+{
+	interface ::ooo::vba::XCollection;
+    
+    any PageSetup();
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XBookmarks.idl
===================================================================
--- oovbaapi/ooo/vba/word/XBookmarks.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XBookmarks.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XBookmarks_idl__
+#define __ooo_vba_word_XBookmarks_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XBookmarks 
+{
+	interface ::ooo::vba::XCollection;
+
+    [attribute] long DefaultSorting;
+    [attribute] boolean ShowHidden;
+
+	any Add( [in] string Name, [in] any Range );
+    boolean Exists( [in] string Name );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XRange.idl
===================================================================
--- oovbaapi/ooo/vba/word/XRange.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XRange.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XRange_idl__
+#define __ooo_vba_word_XRange_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_text_XTextRange_idl__
+#include <com/sun/star/text/XTextRange.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+
+module ooo {  module vba {  module word { 
+
+interface XParagraphFormat;
+interface XStyle;
+interface XFont;
+interface XRange
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] string Text;
+    [attribute] XParagraphFormat ParagraphFormat;
+    [attribute] XStyle Style;
+    [attribute,readonly] ::com::sun::star::text::XTextRange XTextRange;
+    // Of course Font is NOT readonly, #FIXME #TODO
+    // readonly though will force an error attempting to write
+    [attribute, readonly] XFont Font;
+    [attribute] long LanguageID;
+    [attribute] long Start;
+    [attribute] long End;
+
+    void InsertBreak( [in] any Type );
+    void Select();
+    void InsertParagraph();
+    void InsertParagraphBefore();
+    void InsertParagraphAfter();
+    any PageSetup();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XAutoTextEntry.idl
===================================================================
--- oovbaapi/ooo/vba/word/XAutoTextEntry.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XAutoTextEntry.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XAutoTextEntry_idl__
+#define __ooo_vba_word_XAutoTextEntry_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XAutoTextEntry
+{
+    interface ooo::vba::XHelperInterface;
+
+    XRange Insert([in] XRange Where, [in] /*Optional*/ any RichText);
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XBorders.idl
===================================================================
--- oovbaapi/ooo/vba/word/XBorders.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XBorders.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XBorders.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XBorders_idl__
+#define __ooo_vba_word_XBorders_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef  __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+interface XBorders
+{
+	interface ooo::vba::XCollection;
+
+    [attribute] boolean Shadow;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XAddins.idl
===================================================================
--- oovbaapi/ooo/vba/word/XAddins.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XAddins.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XAddins_idl__
+#define __ooo_vba_word_XAddins_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XAddins 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XApplication.idl
===================================================================
--- oovbaapi/ooo/vba/word/XApplication.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XApplication.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XApplication.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XApplication_idl__
+#define __ooo_vba_word_XApplication_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XDocument;
+interface XWindow;
+interface XSystem;
+interface XOptions;
+interface XSelection;
+interface XApplication : com::sun::star::uno::XInterface
+{
+	[attribute, readonly] XDocument ActiveDocument;
+	[attribute, readonly] XWindow ActiveWindow;
+	[attribute, readonly] string Name;
+	[attribute, readonly] ooo::vba::word::XSystem System;
+	[attribute, readonly] ooo::vba::word::XOptions Options;
+	[attribute, readonly] ooo::vba::word::XSelection Selection;
+	[attribute] boolean DisplayAutoCompleteTips;
+	[attribute] long EnableCancelKey;
+
+    any CommandBars( [in] any aIndex );
+    any Documents( [in] any aIndex );
+    any Addins( [in] any aIndex );
+    any Dialogs( [in] any aIndex );
+    float CentimetersToPoints([in] float Centimeters );
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XBookmark.idl
===================================================================
--- oovbaapi/ooo/vba/word/XBookmark.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XBookmark.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XBookmark_idl__
+#define __ooo_vba_word_XBookmark_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XBookmark
+{
+    interface ooo::vba::XHelperInterface;
+	interface ::com::sun::star::container::XNamed;
+
+    void Delete();
+    void Select();
+    any Range();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XPanes.idl
===================================================================
--- oovbaapi/ooo/vba/word/XPanes.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XPanes.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XPanes_idl__
+#define __ooo_vba_word_XPanes_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XPanes 
+{
+	interface ::ooo::vba::XCollection;
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XFields.idl
===================================================================
--- oovbaapi/ooo/vba/word/XFields.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XFields.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XFields.idl,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: jsc $ $Date: 2007/02/09 08:45:13 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_word__XFields_idl__
+#define __ooo_vba_word__XFields_idl__
+
+#ifndef  __ooo_vba_HelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+module ooo { module vba { module word {
+
+interface XRange;
+interface XField;
+interface XFields
+{
+    interface ooo::vba::XCollection;
+
+    XField Add([in] XRange Range, [in] any Type, [in] any Text,[in] any PreserveFormatting);
+    long Update();
+};
+
+}; }; };
+
+#endif
+
Index: oovbaapi/ooo/vba/word/XHeaderFooter.idl
===================================================================
--- oovbaapi/ooo/vba/word/XHeaderFooter.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XHeaderFooter.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XHeaderFooter_idl__
+#define __ooo_vba_word_XHeaderFooter_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XRange;
+interface XHeaderFooter
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute, readonly] boolean IsHeader;
+    [attribute] boolean LinkToPrevious;
+    [attribute, readonly] XRange Range;
+    //[attribute, readonly] XShapers Shapes ;
+    any Shapes([in] any Index);
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XWindow.idl
===================================================================
--- oovbaapi/ooo/vba/word/XWindow.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XWindow.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XWindow.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XWindow_idl__
+#define __ooo_vba_word_XWindow_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+//interface XPane;
+interface XWindow : com::sun::star::uno::XInterface
+{
+    [attribute] any View;
+	void Activate();
+    void Close([in] any SaveChanges, [in] any RouteDocument);
+	any Panes( [in] any aIndex ); // this is a fake api for it seems not support in Write
+	any ActivePane(); // this is a fake api for it seems not support in Write
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XVariables.idl
===================================================================
--- oovbaapi/ooo/vba/word/XVariables.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XVariables.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XVariables_idl__
+#define __ooo_vba_word_XVariables_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+//=============================================================================
+
+interface XVariables 
+{
+	interface ::ooo::vba::XCollection;
+
+	any Add( [in] string Name, [in] any Value );
+};
+
+}; }; };
+
+#endif
Index: oovbaapi/ooo/vba/word/XTables.idl
===================================================================
--- oovbaapi/ooo/vba/word/XTables.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XTables.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XTables.idl,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: jsc $ $Date: 2007/02/09 08:45:13 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ooo_vba_word__XTables_idl__
+#define __ooo_vba_word__XTables_idl__
+
+#ifndef  __ooo_vba_HelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+#ifndef __ooo_vba_word_XTable_idl__
+#include <ooo/vba/word/XTable.idl>
+#endif
+
+#ifndef __com_sun_star_script_BasicErrorException_idl__
+#include <com/sun/star/script/BasicErrorException.idl>
+#endif
+
+module ooo { module vba { module word {
+
+interface XRange;
+
+interface XTables
+{
+    interface ooo::vba::XCollection;
+    /** Creates a new Table, optionally with a name.
+     <p>Creates a new table at the current cursor position. </p>
+     @param range
+     @returns
+     reference to the new table.
+     */
+    XTable Add([in] XRange Range, [in] any NumRows, [in] any NumColumns,
+    /*optional*/ [in] any DefaultTableBehavior,
+    /*optional*/ [in] any AutoFitBehavior)
+        raises(com::sun::star::script::BasicErrorException);
+
+
+};
+
+}; }; };
+
+#endif
+
Index: oovbaapi/ooo/vba/word/XView.idl
===================================================================
--- oovbaapi/ooo/vba/word/XView.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XView.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XView_idl__
+#define __ooo_vba_word_XView_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XView
+{
+    interface ooo::vba::XHelperInterface;
+
+    [attribute] long SeekView;
+    [attribute] long SplitSpecial;
+    [attribute] boolean TableGridLines;
+    [attribute] long Type;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XBorder.idl
===================================================================
--- oovbaapi/ooo/vba/word/XBorder.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XBorder.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XBorder.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XBorder_idl__
+#define __ooo_vba_word_XBorder_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+//=============================================================================
+
+module ooo {  module vba {  module word { 
+
+
+//=============================================================================
+interface XBorder
+{
+	interface ::ooo::vba::XHelperInterface;
+
+	[attribute] any LineStyle;
+};
+
+//=============================================================================
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XDocument.idl
===================================================================
--- oovbaapi/ooo/vba/word/XDocument.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XDocument.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocument.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XDocument_idl__
+#define __ooo_vba_word_XDocument_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __ooo_vba_word_XRange_idl__
+#include <ooo/vba/word/XRange.idl>
+#endif
+
+#ifndef __com_sun_star_script_XInvocation_idl__
+#include <com/sun/star/script/XInvocation.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XDocument : com::sun::star::script::XInvocation
+{
+    [attribute, readonly] XRange Content;
+    [attribute] any AttachedTemplate;
+
+    XRange Range( [in] any Start, [in] any End );
+    any BuiltInDocumentProperties( [in] any index );
+    any CustomDocumentProperties( [in] any index );
+    any Bookmarks( [in] any aIndex );
+    any Variables( [in] any aIndex );
+    any Paragraphs( [in] any aIndex );
+    any Styles( [in] any aIndex );
+    any Tables( [in] any aIndex );
+    any Fields( [in] any aIndex );
+    any Shapes([in] any Index);
+    any Sections([in] any Index);
+	void Activate();
+    any PageSetup();
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/word/XAddin.idl
===================================================================
--- oovbaapi/ooo/vba/word/XAddin.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/word/XAddin.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_word_XAddin_idl__
+#define __ooo_vba_word_XAddin_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+#ifndef __com_sun_star_container_XNamed_idl__
+#include <com/sun/star/container/XNamed.idl>
+#endif
+
+module ooo {  module vba {  module word { 
+
+interface XAddin
+{
+    interface ooo::vba::XHelperInterface;
+	interface ::com::sun::star::container::XNamed;
+
+    [attribute, readonly] string Path;
+    [attribute, readonly] boolean Autoload;
+    [attribute] boolean Installed;
+};
+
+}; }; };
+
+#endif
+
+
Index: oovbaapi/ooo/vba/XDialogsBase.idl
===================================================================
--- oovbaapi/ooo/vba/XDialogsBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XDialogsBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDialogs.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XDialogs_idl__
+#define __ooo_vba_XDialogs_idl__
+                                                                                                                             
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __ooo_vba_XCollection_idl__
+#include <ooo/vba/XCollection.idl>
+#endif
+
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+
+//=============================================================================
+                                                                                                                             
+module ooo {  module vba {
+                                                                                                                             
+//interface XDialogs : ::ooo::vba::XCollection
+interface XDialogsBase 
+{
+	interface ::ooo::vba::XHelperInterface;
+
+    [attribute, readonly] long Count;
+	any Item( [in] any Index );
+};
+                                                                                                                             
+}; };
+                                                                                                                             
+#endif
+
Index: oovbaapi/ooo/vba/constants/makefile.mk
===================================================================
--- oovbaapi/ooo/vba/constants/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/ooo/vba/constants/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,10 +38,6 @@
 
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ELSE
 
 .IF "$(L10N_framework)"=="" 
 # ------------------------------------------------------------------------
@@ -55,4 +50,3 @@
     $(REGMERGE) $(OUT)$/ucr/constants.db /UCR @$(mktmp $(MYURDFILES))
 
 .ENDIF
-.ENDIF
Index: oovbaapi/ooo/vba/XGlobalsBase.idl
===================================================================
--- oovbaapi/ooo/vba/XGlobalsBase.idl	(.../tags/DEV300_m58)	(revision 0)
+++ oovbaapi/ooo/vba/XGlobalsBase.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XGlobals.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __ooo_vba_XGlobalsBase_idl__
+#define __ooo_vba_XGlobalsBase_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#ifndef __ooo_vba_XHelperInterface_idl__
+#include <ooo/vba/XHelperInterface.idl>
+#endif
+#ifndef __com_sun_star_lang_XMultiServiceFactory
+#include <com/sun/star/lang/XMultiServiceFactory.idl>
+#endif
+module ooo {  module vba {
+interface XGlobalsBase
+{
+	interface ::ooo::vba::XHelperInterface;
+	interface ::com::sun::star::lang::XMultiServiceFactory;
+};
+
+}; };
+
+#endif
+
+
Index: oovbaapi/util/makefile.mk
===================================================================
--- oovbaapi/util/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ oovbaapi/util/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,16 +40,13 @@
 
 .INCLUDE :  makefile.pmk
 
-.IF "$(ENABLE_VBA)"!="YES"
-dummy:
-        @echo "not building vba..."
-.ENDIF
 
 .IF "$(L10N_framework)"==""
 # ------------------------------------------------------------------
 UNOIDLDBFILES= \
 	$(UCR)$/vba.db \
 	$(UCR)$/excel.db \
+	$(UCR)$/word.db \
 	$(UCR)$/msforms.db \
 	$(UCR)$/constants.db
 
Index: scripting/source/basprov/basscript.hxx
===================================================================
--- scripting/source/basprov/basscript.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/basprov/basscript.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,12 +31,14 @@
 #ifndef SCRIPTING_BASSCRIPT_HXX
 #define SCRIPTING_BASSCRIPT_HXX
 
+#include "bcholder.hxx"
 #include <com/sun/star/script/provider/XScript.hpp>
 #include <com/sun/star/document/XScriptInvocationContext.hpp>
 #include <cppuhelper/implbase1.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
 #include <basic/sbmeth.hxx>
 
-
 class BasicManager;
 
 //.........................................................................
@@ -52,7 +54,11 @@
         ::com::sun::star::script::provider::XScript > BasicScriptImpl_BASE;
 
 
-    class BasicScriptImpl : public BasicScriptImpl_BASE
+    class BasicScriptImpl : public BasicScriptImpl_BASE,
+                                public ::scripting_helper::OMutexHolder,
+                                public ::scripting_helper::OBroadcastHelperHolder,
+                                public ::comphelper::OPropertyContainer,
+                                public ::comphelper::OPropertyArrayUsageHelper< BasicScriptImpl >
     {
     private:
         SbMethodRef         m_xMethod;
@@ -60,7 +66,17 @@
         BasicManager*       m_documentBasicManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::document::XScriptInvocationContext >
                             m_xDocumentScriptContext;
+        // hack, OPropertyContainer doesn't allow you to define a property of unknown
+        // type ( I guess because an Any can't contain an Any... I've always wondered why?
+	// as its not unusual to do that in corba )
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > m_caller;
+    protected:
+        // OPropertySetHelper
+        virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
 
+        // OPropertyArrayUsageHelper
+        virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
     public:
         BasicScriptImpl(
             const ::rtl::OUString& funcName,
@@ -74,6 +90,12 @@
         );
         virtual ~BasicScriptImpl();
 
+        // XInterface
+        DECLARE_XINTERFACE()
+
+        // XTypeProvider
+        DECLARE_XTYPEPROVIDER()
+
         // XScript
         virtual ::com::sun::star::uno::Any SAL_CALL invoke(
             const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
@@ -83,6 +105,9 @@
                     ::com::sun::star::script::provider::ScriptFrameworkErrorException, 
                     ::com::sun::star::reflection::InvocationTargetException,
                     ::com::sun::star::uno::RuntimeException );               
+        // XPropertySet
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) 
+            throw (::com::sun::star::uno::RuntimeException);
     };
 
 //.........................................................................
Index: scripting/source/basprov/basscript.cxx
===================================================================
--- scripting/source/basprov/basscript.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/basprov/basscript.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -39,7 +39,10 @@
 #include <basic/sbmeth.hxx>
 #include <basic/basmgr.hxx>
 #include <com/sun/star/script/provider/ScriptFrameworkErrorType.hpp>
-
+#include "bcholder.hxx"
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <map>
 
 
@@ -48,6 +51,7 @@
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
 
 extern ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any& aValue );
@@ -57,7 +61,11 @@
 namespace basprov
 {
 //.........................................................................
+#define BASSCRIPT_PROPERTY_ID_CALLER         1
+#define BASSCRIPT_PROPERTY_CALLER            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Caller" ) )
 
+#define BASSCRIPT_DEFAULT_ATTRIBS()       PropertyAttribute::BOUND | PropertyAttribute::TRANSIENT
+
     typedef ::std::map< sal_Int16, Any, ::std::less< sal_Int16 > > OutParamMap;
 
     // =============================================================================
@@ -67,22 +75,28 @@
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod )
-        :m_xMethod( xMethod )
+        : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( NULL )
         ,m_xDocumentScriptContext()
     {
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
 
     BasicScriptImpl::BasicScriptImpl( const ::rtl::OUString& funcName, SbMethodRef xMethod,
-        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext )
-        :m_xMethod( xMethod )
+        BasicManager& documentBasicManager, const Reference< XScriptInvocationContext >& documentScriptContext ) : ::scripting_helper::OBroadcastHelperHolder( m_aMutex )
+        ,OPropertyContainer( GetBroadcastHelper() )
+        ,m_xMethod( xMethod )
         ,m_funcName( funcName )
         ,m_documentBasicManager( &documentBasicManager )
         ,m_xDocumentScriptContext( documentScriptContext )
     {
+	// 
+        registerProperty( BASSCRIPT_PROPERTY_CALLER, BASSCRIPT_PROPERTY_ID_CALLER, BASSCRIPT_DEFAULT_ATTRIBS(), &m_caller, ::getCppuType( &m_caller ) );
     }
 
     // -----------------------------------------------------------------------------
@@ -91,6 +105,48 @@
     }
 
     // -----------------------------------------------------------------------------
+    // XInterface
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XINTERFACE2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // XTypeProvider
+    // -----------------------------------------------------------------------------
+
+    IMPLEMENT_FORWARD_XTYPEPROVIDER2( BasicScriptImpl, BasicScriptImpl_BASE, OPropertyContainer )
+
+    // -----------------------------------------------------------------------------
+    // OPropertySetHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper& BasicScriptImpl::getInfoHelper(  )
+    {
+        return *getArrayHelper();
+    }
+
+    // -----------------------------------------------------------------------------
+    // OPropertyArrayUsageHelper
+    // -----------------------------------------------------------------------------
+
+    ::cppu::IPropertyArrayHelper* BasicScriptImpl::createArrayHelper(  ) const
+    {
+        Sequence< Property > aProps;
+        describeProperties( aProps );
+        return new ::cppu::OPropertyArrayHelper( aProps );
+    }
+
+    // -----------------------------------------------------------------------------
+    // XPropertySet
+    // -----------------------------------------------------------------------------
+
+    Reference< XPropertySetInfo > BasicScriptImpl::getPropertySetInfo(  ) throw (RuntimeException)
+    {
+        Reference< XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+        return xInfo;
+    }
+
+    // -----------------------------------------------------------------------------
     // XScript
     // -----------------------------------------------------------------------------
 
@@ -169,8 +225,14 @@
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     aOldThisComponent = m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", makeAny( m_xDocumentScriptContext ) );
 
+            if ( m_caller.getLength() && m_caller[ 0 ].hasValue()  )
+            {
+                SbxVariableRef xCallerVar = new SbxVariable( SbxVARIANT );
+                unoToSbxValue( static_cast< SbxVariable* >( xCallerVar ), m_caller[ 0 ] );
+                nErr = m_xMethod->Call( xReturn, xCallerVar );
+            }
+            else
                 nErr = m_xMethod->Call( xReturn );
-
                 if ( m_documentBasicManager && m_xDocumentScriptContext.is() )
                     m_documentBasicManager->SetGlobalUNOConstant( "ThisComponent", aOldThisComponent );
             }
Index: scripting/source/dlgprov/dlgevtatt.cxx
===================================================================
--- scripting/source/dlgprov/dlgevtatt.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/dlgprov/dlgevtatt.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -112,27 +112,30 @@
     {
         protected:
         rtl::OUString msDialogCodeName;
+        rtl::OUString msDialogLibName;
         Reference<  script::XScriptListener > mxListener;
         virtual void firing_impl( const script::ScriptEvent& aScriptEvent, uno::Any* pRet );
         public:
-        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel );
+        DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName );
     };
 
-    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel ) : DialogScriptListenerImpl( rxContext )
+    DialogVBAScriptListenerImpl::DialogVBAScriptListenerImpl( const Reference< XComponentContext >& rxContext, const Reference< awt::XControl >& rxControl, const Reference< frame::XModel >& xModel, const rtl::OUString& sDialogLibName ) : DialogScriptListenerImpl( rxContext ), msDialogLibName( sDialogLibName )
     {
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
+        Sequence< Any > args(1);
         if ( xSMgr.is() )
         {
-            Sequence< Any > args(1);
             args[0] <<= xModel;
             mxListener = Reference< XScriptListener >( xSMgr->createInstanceWithArgumentsAndContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.EventListener" ) ), args, m_xContext ), UNO_QUERY );
         }
         if ( rxControl.is() )
         {
-            Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY );
             try
             {
+                Reference< XPropertySet > xProps( rxControl->getModel(), UNO_QUERY_THROW );
                 xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= msDialogCodeName;
+                xProps.set( mxListener, UNO_QUERY_THROW );
+                xProps->setPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Model") ), args[ 0 ] );
             } 
             catch ( Exception&  ) {}
         }
@@ -144,7 +147,7 @@
         if ( aScriptEvent.ScriptType.equals( rtl::OUString::createFromAscii("VBAInterop") ) && mxListener.is() )
         {
             ScriptEvent aScriptEventCopy( aScriptEvent );
-            aScriptEventCopy.ScriptCode = msDialogCodeName;
+            aScriptEventCopy.ScriptCode = msDialogLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "." ) ) ).concat( msDialogCodeName );
             try
             {
                 mxListener->firing( aScriptEventCopy );
@@ -160,7 +163,7 @@
     // DialogEventsAttacherImpl
     // =============================================================================
 
-    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener   )
+    DialogEventsAttacherImpl::DialogEventsAttacherImpl( const Reference< XComponentContext >& rxContext, const Reference< frame::XModel >& rxModel, const Reference< awt::XControl >& rxControl, const Reference< XInterface >& rxHandler, const Reference< beans::XIntrospectionAccess >& rxIntrospect, bool bProviderMode, const Reference< script::XScriptListener >& rxRTLListener, const rtl::OUString& sDialogLibName  )
         :m_xContext( rxContext )
     {
         // key listeners by protocol when ScriptType = 'Script'
@@ -173,7 +176,7 @@
         listernersForTypes[ rtl::OUString::createFromAscii("vnd.sun.star.UNO") ] = new DialogUnoScriptListenerImpl( rxContext, rxModel, rxControl, rxHandler, rxIntrospect, bProviderMode );
         listernersForTypes[ rtl::OUString::createFromAscii("vnd.sun.star.script") ] = new DialogSFScriptListenerImpl( rxContext, rxModel );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-        listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel );
+        listernersForTypes[ rtl::OUString::createFromAscii("VBAInterop") ] = new DialogVBAScriptListenerImpl( rxContext, rxControl, rxModel, sDialogLibName );
 #endif
     }
 
@@ -193,7 +196,7 @@
         return it->second; 
     }
 #ifdef FAKE_VBA_EVENT_SUPPORT
-    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl )
+    Reference< XScriptEventsSupplier > DialogEventsAttacherImpl::getFakeVbaEventsSupplier( const Reference< XControl >& xControl, rtl::OUString& sControlName )
     {
         Reference< XScriptEventsSupplier > xEventsSupplier;
         Reference< XMultiComponentFactory > xSMgr( m_xContext->getServiceManager() );
@@ -201,7 +204,7 @@
         {
             Reference< ooo::vba::XVBAToOOEventDescGen > xVBAToOOEvtDesc( xSMgr->createInstanceWithContext( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAToOOEventDesc" ) ), m_xContext ), UNO_QUERY );
             if ( xVBAToOOEvtDesc.is() )
-                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl ), UNO_QUERY );
+                xEventsSupplier.set( xVBAToOOEvtDesc->getEventSupplier( xControl, sControlName ), UNO_QUERY );
             
         }
         return xEventsSupplier;
@@ -324,6 +327,20 @@
         // go over all objects
         const Reference< XInterface >* pObjects = Objects.getConstArray();
         sal_Int32 nObjCount = Objects.getLength();
+#ifdef FAKE_VBA_EVENT_SUPPORT
+        Reference< awt::XControl > xDlgControl( Objects[ nObjCount - 1 ], uno::UNO_QUERY ); // last object is the dialog	
+        rtl::OUString sDialogCodeName;
+        if ( xDlgControl.is() )
+        {
+            Reference< XPropertySet > xProps( xDlgControl->getModel(), UNO_QUERY );
+            try
+            {
+                xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sDialogCodeName;  
+            }
+            catch( Exception& ){}
+        }
+#endif
+	
         for ( sal_Int32 i = 0; i < nObjCount; ++i )
         {
             // We know that we have to do with instances of XControl.
@@ -338,7 +355,7 @@
             Reference< XScriptEventsSupplier > xEventsSupplier( xControlModel, UNO_QUERY );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl ) );
+            xEventsSupplier.set( getFakeVbaEventsSupplier( xControl, sDialogCodeName ) );
             attachEventsToControl( xControl, xEventsSupplier, Helper );
 #endif
         }
@@ -399,7 +416,7 @@
 
     void DialogAllListenerImpl::firing( const AllEventObject& Event ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( Event, NULL );
     }
@@ -409,7 +426,7 @@
     Any DialogAllListenerImpl::approveFiring( const AllEventObject& Event ) 
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( Event, &aReturn );
@@ -653,7 +670,7 @@
 
     void DialogScriptListenerImpl::firing( const ScriptEvent& aScriptEvent ) throw ( RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         firing_impl( aScriptEvent, NULL );
     }
@@ -663,7 +680,7 @@
     Any DialogScriptListenerImpl::approveFiring( const ScriptEvent& aScriptEvent ) 
         throw ( reflection::InvocationTargetException, RuntimeException )
     {
-        ::osl::MutexGuard aGuard( getMutex() );
+        //::osl::MutexGuard aGuard( getMutex() );
 
         Any aReturn;
         firing_impl( aScriptEvent, &aReturn );
Index: scripting/source/dlgprov/dlgprov.hxx
===================================================================
--- scripting/source/dlgprov/dlgprov.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/dlgprov/dlgprov.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -84,9 +84,9 @@
         ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >        m_xContext;
         ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >                 m_xModel;
 
-
+	rtl::OUString msDialogLibName;
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel > createDialogModel( const ::rtl::OUString& sURL );
-
+     
         ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl > createDialogControl( 
             const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& rxDialogModel,
 			const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer >& xParent );
@@ -94,7 +94,7 @@
         void attachControlEvents( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl >& rxControlContainer,
 			const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler,
 			const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& rxIntrospectionAccess,
-			bool bDialogProviderMode );
+			bool bDialogProviderMode, const rtl::OUString& );
 		::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess > inspectHandler( 
 			const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxHandler );
 	// helper methods
Index: scripting/source/dlgprov/dlgevtatt.hxx
===================================================================
--- scripting/source/dlgprov/dlgevtatt.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/dlgprov/dlgevtatt.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -46,6 +46,9 @@
 #include <com/sun/star/script/XScriptEventsSupplier.hpp>
 
 #include <hash_map>
+
+#define FAKE_VBA_EVENT_SUPPORT 1 
+
 //.........................................................................
 namespace dlgprov
 {
@@ -71,7 +74,7 @@
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XEventAttacher > m_xEventAttacher;
         ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener > getScriptListenerForKey( const rtl::OUString& sScriptName ) throw ( ::com::sun::star::uno::RuntimeException );
 #ifdef FAKE_VBA_EVENT_SUPPORT
-        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl );
+        ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier > getFakeVbaEventsSupplier( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, rtl::OUString& sCodeName );
 #endif
         void  SAL_CALL attachEventsToControl( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControl>& xControl, const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptEventsSupplier >& events, const ::com::sun::star::uno::Any& Helper  );
     public:
@@ -81,7 +84,7 @@
         	 const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& xHandler, 
         	 const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XIntrospectionAccess >& xIntrospect, 
              bool bProviderMode, 
-        	 const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener );
+        	 const ::com::sun::star::uno::Reference< ::com::sun::star::script::XScriptListener >& xRTLListener ,const rtl::OUString& sDialogLibName );
         virtual ~DialogEventsAttacherImpl();
 
         // XScriptEventsAttacher
Index: scripting/source/dlgprov/dlgprov.cxx
===================================================================
--- scripting/source/dlgprov/dlgprov.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/source/dlgprov/dlgprov.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -196,7 +196,15 @@
 		Reference< beans::XPropertySet > xDlgPropSet( xDialogModel, UNO_QUERY );
 		xDlgPropSet->setPropertyValue( aDlgSrcUrlPropName, aDialogSourceURL );
 
-        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext );
+        // #TODO we really need to detect the source of the Dialog, is it
+        // located in the document or not. m_xModel need not be the location of
+        // the dialog. E.g. if the dialog was created from basic ( then we just
+        // can't tell  where its from ) 
+        // If we are happy to always substitute the form model for the awt
+        // one then maybe the presence of a document model is enough to trigger
+        // swapping out the models ( or perhaps we only want to do this 
+        // for vba mode ) there are a number of feasible and valid possibilities
+        ::xmlscript::importDialogModel( xInput, xDialogModel, m_xContext, m_xModel );
         // Set resource property
         if( xStringResourceManager.is() )
         {
@@ -410,6 +418,7 @@
 
 			if ( xISP.is() )
 				xInput = xISP->createInputStream();
+            msDialogLibName = sLibName;
 		}
 
         // import dialog model
@@ -527,7 +536,7 @@
 		const Reference< XControl >& rxControl,
 		const Reference< XInterface >& rxHandler,
 		const Reference< XIntrospectionAccess >& rxIntrospectionAccess,
-		bool bDialogProviderMode )
+		bool bDialogProviderMode, const rtl::OUString& sDialogLibName )
     {
         if ( rxControl.is() )
         {
@@ -551,7 +560,7 @@
 
 				Reference< XScriptEventsAttacher > xScriptEventsAttacher = new DialogEventsAttacherImpl
 					( m_xContext, m_xModel, rxControl, rxHandler, rxIntrospectionAccess, 
-					  bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ) );
+					  bDialogProviderMode, ( m_BasicInfo.get() ? m_BasicInfo->mxBasicRTLListener : NULL ), msDialogLibName );
 
                 Any aHelper;
                 xScriptEventsAttacher->attachEvents( aObjects, Reference< XScriptListener >(), aHelper );
@@ -656,7 +665,10 @@
             aArguments[0] >>= m_xModel;
             m_BasicInfo.reset( new BasicRTLParams() );
             m_BasicInfo->mxInput.set( aArguments[ 1 ], UNO_QUERY_THROW );
-            m_BasicInfo->mxDlgLib.set( aArguments[ 2 ], UNO_QUERY_THROW );
+            // allow null mxDlgLib, a document dialog instantiated from 
+            // from application basic is unable to provide ( or find ) it's
+            // Library
+            aArguments[ 2 ] >>= m_BasicInfo->mxDlgLib;
             // leave the possibility to optionally allow the old dialog creation
             // to use the new XScriptListener ( which converts the old style macro
             // to a SF url )
@@ -731,7 +743,7 @@
             {
                 //xDialog = Reference< XDialog >( xCtrl, UNO_QUERY );
 	            Reference< XIntrospectionAccess > xIntrospectionAccess = inspectHandler( xHandler );
-                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode );
+                attachControlEvents( xCtrl, xHandler, xIntrospectionAccess, bDialogProviderMode, msDialogLibName );
             }
         }
 
Index: scripting/source/vbaevents/service.cxx
===================================================================
--- scripting/source/vbaevents/service.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ scripting/source/vbaevents/service.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,99 @@
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace evtlstner
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end evtlstner
+
+namespace ooevtdescgen
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end ooevtdescgen
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::evtlstner::create, ::evtlstner::getImplementationName,
+            ::evtlstner::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        {
+            ::ooevtdescgen::create, ::ooevtdescgen::getImplementationName,
+            ::ooevtdescgen::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
Index: scripting/source/vbaevents/eventhelper.cxx
===================================================================
--- scripting/source/vbaevents/eventhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ scripting/source/vbaevents/eventhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,1075 @@
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+
+#include <ooo/vba/XVBAToOOEventDescGen.hpp>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <com/sun/star/script/provider/XScriptProviderSupplier.hpp>
+
+#include <com/sun/star/drawing/XControlShape.hpp>
+
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/awt/KeyEvent.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+#include <com/sun/star/awt/XFixedText.hpp> //liuchen 2009-6-5
+#include <com/sun/star/awt/XTextComponent.hpp> //liuchen 2009-6-5
+#include <com/sun/star/awt/XComboBox.hpp> //liuchen 2009-6-18
+#include <com/sun/star/awt/XRadioButton.hpp> //liuchen 2009-7-30
+
+#include <msforms/ReturnInteger.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbx.hxx>
+#include <svx/msvbahelper.hxx>
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <comphelper/evtmethodhelper.hxx>
+
+#include <set>
+#include <list>
+#include <hash_map>
+#define ASYNC 0
+
+// primitive support for asynchronous handling of 
+// events from controls ( all event will be processed asynchronously 
+// in the application thread )
+#if ASYNC
+#include <vcl/svapp.hxx>
+#endif
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::script;
+using namespace ::com::sun::star::uno;
+using namespace ::ooo::vba;
+
+#define MAP_CHAR_LEN(x) ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(x))//liuchen 2009-6-8
+#define GET_TYPE(x) ::getCppuType((uno::Reference< x > *)0);
+
+// Some constants 
+const static rtl::OUString DELIM = rtl::OUString::createFromAscii( "::" );
+const static sal_Int32 DELIMLEN = DELIM.getLength();
+
+#if 0
+void dumpListeners( const Reference< beans::XIntrospection >& xIntrospection, const Reference<XInterface>& xIfc)
+{
+    Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+    if ( xIntrospection.is() )
+    {
+        xIntrospectionAccess = xIntrospection->inspect( 
+            makeAny( xIfc ) );
+        Sequence< Type > aControlListeners = 
+            xIntrospectionAccess->getSupportedListeners();
+        sal_Int32 nLength = aControlListeners.getLength();
+             
+        for ( sal_Int32 i = 0; i< nLength; ++i )
+        {
+            Type& listType = aControlListeners[ i ];
+            rtl::OUString sFullTypeName = listType.getTypeName();
+            rtl::OUString sTypeName = listType.getTypeName();
+            sal_Int32 lastDotIndex = -1;
+            if ( ( lastDotIndex = sFullTypeName.lastIndexOf( '.' ) ) > -1 )
+            {
+                sTypeName = sFullTypeName.copy( lastDotIndex + 1 );    
+            } 
+            Sequence< ::rtl::OUString > sMeths = comphelper::getEventMethodsForType( listType );    
+            sal_Int32 sMethLen = sMeths.getLength();
+            for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+            {
+                OSL_TRACE("**Listener [%d] Type[%s] Method[%s]",j,
+                    rtl::OUStringToOString( sTypeName, 
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString( sMeths[ j ], 
+                        RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+        }
+       
+    }
+}
+
+void dumpEvent( const ScriptEvent& evt )
+{
+    OSL_TRACE("dumpEvent: Source %s",
+        rtl::OUStringToOString( comphelper::anyToString( makeAny(evt.Source)), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ScriptType %s",
+        rtl::OUStringToOString( evt.ScriptType, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: ScriptCode %s",
+        rtl::OUStringToOString( evt.ScriptCode, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ListenerType %s",
+        rtl::OUStringToOString( evt.ListenerType.getTypeName(), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: Listener methodname %s",
+        rtl::OUStringToOString( evt.MethodName, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: arguments;");
+    sal_Int32 nLen = evt.Arguments.getLength();
+    for ( sal_Int32 index=0; index < nLen; ++index )
+    {
+        OSL_TRACE("\t [%d] %s", index, 
+        rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[ index ] ), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    }
+}
+
+#endif
+
+bool isKeyEventOk( awt::KeyEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !( isMouseEventOk(evt, params)) || 
+        (evt.ClickCount != 2) )
+        return Sequence< Any >(); 
+    // give back orig params, this will signal that the event is good
+    return params;
+}
+
+Sequence< Any > ooMouseEvtToVBAMouseEvt( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !isMouseEventOk(evt, params) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(4);
+
+    // Buttons
+    translatedParams[ 0 ] <<= evt.Buttons;
+    // Shift
+    translatedParams[ 1 ] <<= evt.Modifiers;
+    // X
+    translatedParams[ 2 ] <<= evt.X;
+    // Y
+    translatedParams[ 3 ] <<= evt.Y;
+    return translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    msforms::ReturnInteger keyCode;
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    return  translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(2);
+
+    msforms::ReturnInteger keyCode;
+    sal_Int8 shift = evt.Modifiers;
+
+    // #TODO check whether values from OOO conform to values generated from vba
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    translatedParams[1] <<= shift;
+    return  translatedParams;
+}
+
+typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
+
+//liuchen 2009-6-23
+//expand the "TranslateInfo" struct to support more kinds of events 
+struct TranslateInfo
+{
+    rtl::OUString sVBAName; //vba event name
+    Translator toVBA;       //the method to convert OO event parameters to VBA event parameters	
+	bool (*ApproveRule)(const ScriptEvent& evt, void* pPara); //this method is used to determine which types of controls should execute the event 
+	void *pPara;			//Parameters for the above approve method
+};
+
+
+typedef std::hash_map< rtl::OUString, 
+std::list< TranslateInfo >, 
+::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventInfoHash;
+
+//liuchen 2009-6-23
+struct TranslatePropMap
+{
+	rtl::OUString sEventInfo;   //OO event name
+	TranslateInfo aTransInfo;   
+};
+
+bool ApproveAll(const ScriptEvent& evt, void* pPara); //allow all types of controls to execute the event
+bool ApproveType(const ScriptEvent& evt, void* pPara); //certain types of controls should execute the event, those types are given by pPara
+bool DenyType(const ScriptEvent& evt, void* pPara);    //certain types of controls should not execute the event, those types are given by pPara
+bool DenyMouseDrag(const ScriptEvent& evt, void* pPara); //used for VBA MouseMove event when "Shift" key is pressed
+
+struct TypeList
+{
+	uno::Type* pTypeList;
+	int nListLength;
+};
+
+Type typeXFixedText = GET_TYPE(awt::XFixedText);
+Type typeXTextComponent = GET_TYPE(awt::XTextComponent);
+Type typeXComboBox = GET_TYPE(awt::XComboBox);
+Type typeXRadioButton = GET_TYPE(awt::XRadioButton);
+
+
+TypeList fixedTextList = {&typeXFixedText, 1};
+TypeList textCompList = {&typeXTextComponent, 1};
+TypeList radioButtonList = {&typeXRadioButton, 1};
+TypeList comboBoxList = {&typeXComboBox, 1};
+
+//this array stores the OO event to VBA event translation info
+static TranslatePropMap aTranslatePropMap_Impl[] = 
+{
+	// actionPerformed ooo event
+	{ MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Click"), NULL, ApproveAll, NULL } },	
+	{ MAP_CHAR_LEN("actionPerformed"), { MAP_CHAR_LEN("_Change"), NULL, DenyType, (void*)(&radioButtonList) } },  //liuchen 2009-7-30, OptionalButton_Change event is not the same as OptionalButton_Click event
+
+	// itemStateChanged ooo event
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Click"), NULL, ApproveType, (void*)(&comboBoxList) } },  //liuchen, add to support VBA ComboBox_Click event
+	{ MAP_CHAR_LEN("itemStateChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveType, (void*)(&radioButtonList) } }, //liuchen 2009-7-30, OptionalButton_Change event should be triggered when the button state is changed
+	
+	// changed ooo event
+	{ MAP_CHAR_LEN("changed"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },	
+
+	// focusGained ooo event
+	{ MAP_CHAR_LEN("focusGained"), { MAP_CHAR_LEN("_GotFocus"), NULL, ApproveAll, NULL } },
+
+	// focusLost ooo event
+	{ MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_LostFocus"), NULL, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("focusLost"), { MAP_CHAR_LEN("_Exit"), NULL, ApproveType, (void*)(&textCompList) } }, //liuchen, add to support VBA TextBox_Exit event
+
+	// adjustmentValueChanged ooo event
+	{ MAP_CHAR_LEN("adjustmentValueChanged"), { MAP_CHAR_LEN("_Scroll"), NULL, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("adjustmentValueChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },
+
+	// textChanged ooo event
+	{ MAP_CHAR_LEN("textChanged"), { MAP_CHAR_LEN("_Change"), NULL, ApproveAll, NULL } },
+
+	// keyReleased ooo event
+	{ MAP_CHAR_LEN("keyReleased"), { MAP_CHAR_LEN("_KeyUp"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } },
+
+	// mouseReleased ooo event
+	{ MAP_CHAR_LEN("mouseReleased"), { MAP_CHAR_LEN("_Click"), ooMouseEvtToVBAMouseEvt, ApproveType, (void*)(&fixedTextList) } }, //liuchen, add to support VBA Label_Click event
+	{ MAP_CHAR_LEN("mouseReleased"), { MAP_CHAR_LEN("_MouseUp"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+
+	// mousePressed ooo event
+	{ MAP_CHAR_LEN("mousePressed"), { MAP_CHAR_LEN("_MouseDown"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("mousePressed"), { MAP_CHAR_LEN("_DblClick"), ooMouseEvtToVBADblClick, ApproveAll, NULL } },
+
+	// mouseMoved ooo event	
+	{ MAP_CHAR_LEN("mouseMoved"), { MAP_CHAR_LEN("_MouseMove"), ooMouseEvtToVBAMouseEvt, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("mouseDragged"), { MAP_CHAR_LEN("_MouseMove"), ooMouseEvtToVBAMouseEvt, DenyMouseDrag, NULL } }, //liuchen, add to support VBA MouseMove event when the "Shift" key is pressed
+
+	// keyPressed ooo event
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyDown"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } },
+	{ MAP_CHAR_LEN("keyPressed"), { MAP_CHAR_LEN("_KeyPress"), ooKeyPressedToVBAKeyUpDown, ApproveAll, NULL } }
+};
+
+EventInfoHash& getEventTransInfo()
+{
+    static bool initialised = false;
+    static EventInfoHash eventTransInfo;
+    if ( !initialised )
+    {		
+		rtl::OUString sEventInfo = MAP_CHAR_LEN("");
+		TranslatePropMap* pTransProp = aTranslatePropMap_Impl;
+
+		int nCount = sizeof(aTranslatePropMap_Impl) / sizeof(aTranslatePropMap_Impl[0]);
+
+		int i = 0;
+		while (i < nCount)
+		{			
+			if (sEventInfo != pTransProp->sEventInfo)
+			{
+				sEventInfo = pTransProp->sEventInfo;
+				std::list< TranslateInfo > infoList;
+				do
+				{									
+					infoList.push_back( pTransProp->aTransInfo );
+                                        i++;
+					pTransProp++;
+				}
+				while( ( i < nCount ) && ( sEventInfo == pTransProp->sEventInfo ) );
+				eventTransInfo[sEventInfo] = infoList;
+			}
+		}		
+        initialised = true;
+    }
+    return eventTransInfo;
+}
+//liuchen 2009-6-23 end
+
+// Helper class
+
+class ScriptEventHelper
+{
+public:
+    ScriptEventHelper( const Reference< XInterface >& xControl );
+    Sequence< ScriptEventDescriptor > createEvents( const rtl::OUString& sCodeName );   
+    Sequence< rtl::OUString > getEventListeners();
+private:
+    Reference< XComponentContext > m_xCtx;
+    Reference< XInterface > m_xControl;
+};
+
+bool
+eventMethodToDescriptor( const ::rtl::OUString& rEventMethod, ScriptEventDescriptor& evtDesc, const ::rtl::OUString& sCodeName )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        // just fill in CodeName, when the event fires the other 
+	// info is gathered from the event source to determine what
+	// event handler we try to call
+        evtDesc.ScriptCode = sCodeName;
+        evtDesc.ListenerType = sTypeName;
+        evtDesc.EventMethod = sMethodName;
+
+        // set this it VBAInterop, ensures that it doesn't
+        // get persisted or shown in property editors
+        evtDesc.ScriptType = rtl::OUString::createFromAscii(
+            "VBAInterop" );	
+        return true;
+    }
+    return false;
+
+}
+
+ScriptEventHelper::ScriptEventHelper( const Reference< XInterface >& xControl ) : m_xControl( xControl )
+{
+    Reference < beans::XPropertySet > xProps(
+        ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+    m_xCtx.set( xProps->getPropertyValue( rtl::OUString(
+        RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+        uno::UNO_QUERY_THROW );
+}
+
+Sequence< rtl::OUString > 
+ScriptEventHelper::getEventListeners()
+{
+    Reference< lang::XMultiComponentFactory > xMFac( 
+        m_xCtx->getServiceManager(), UNO_QUERY );
+    std::list< rtl::OUString > eventMethods;
+
+    if ( xMFac.is() )
+    {
+        Reference< beans::XIntrospection > xIntrospection( 
+            xMFac->createInstanceWithContext( rtl::OUString( 
+                RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.beans.Introspection"  ) ), m_xCtx ), UNO_QUERY );
+#if 0
+        dumpListeners( xIntrospection, m_xControl );
+        dumpListeners( xIntrospection, m_xControl->getModel() );
+#endif 
+        Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+	if  ( xIntrospection.is() )
+	{
+            xIntrospectionAccess = xIntrospection->inspect( 
+                makeAny( m_xControl ) );
+            Sequence< Type > aControlListeners = 
+                xIntrospectionAccess->getSupportedListeners();
+            sal_Int32 nLength = aControlListeners.getLength();             
+            for ( sal_Int32 i = 0; i< nLength; ++i )
+            {
+                Type& listType = aControlListeners[ i ];
+                rtl::OUString sFullTypeName = listType.getTypeName();
+                Sequence< ::rtl::OUString > sMeths = 
+                    comphelper::getEventMethodsForType( listType );    
+                sal_Int32 sMethLen = sMeths.getLength();
+                for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+                {
+                    rtl::OUString sEventMethod = sFullTypeName;
+                    sEventMethod += DELIM;
+                    sEventMethod += sMeths[ j ];
+                    eventMethods.push_back( sEventMethod );
+                }
+            }
+            
+        }
+    }
+
+    Sequence< rtl::OUString > sEventMethodNames( eventMethods.size() );
+    std::list< rtl::OUString >::const_iterator it = eventMethods.begin();
+    rtl::OUString* pDest = sEventMethodNames.getArray();
+
+    for ( ; it != eventMethods.end(); ++it, ++pDest )
+        *pDest = *it;         
+
+    return sEventMethodNames;
+}
+
+Sequence< ScriptEventDescriptor > 
+ScriptEventHelper::createEvents( const rtl::OUString& sCodeName )
+{
+    Sequence< rtl::OUString > aControlListeners = getEventListeners();
+    rtl::OUString* pSrc = aControlListeners.getArray();
+    sal_Int32 nLength = aControlListeners.getLength();             
+
+    Sequence< ScriptEventDescriptor > aDest( nLength );
+    sal_Int32 nEvts = 0; 
+    for ( sal_Int32 i = 0; i< nLength; ++i, ++pSrc )
+    {
+        // from getListeners eventName is of form
+        // "com.sun.star.awt.XActionListener::actionPerformed"
+        // we need to strip "com.sun.star.awt." from that for form
+        // controls
+    	ScriptEventDescriptor evtDesc;
+        if ( eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            sal_Int32 dIndex = nEvts;
+            ++nEvts;
+            if ( nEvts > aDest.getLength() )
+                aDest.realloc( nEvts );// should never happen
+            aDest[ dIndex ] = evtDesc;
+        }
+    }
+    aDest.realloc( nEvts );
+
+    return aDest;
+}
+
+
+typedef ::cppu::WeakImplHelper1< container::XNameContainer > NameContainer_BASE;
+
+class ReadOnlyEventsNameContainer : public NameContainer_BASE
+{
+public:
+    ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName );
+    // XNameContainer
+
+    virtual void SAL_CALL insertByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::ElementExistException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& ) throw (::com::sun::star::container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+    }
+
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString&, const Any& ) throw (lang::IllegalArgumentException, container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+                                                                                
+    // XNameAccess
+    virtual Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException);
+    virtual Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (RuntimeException);
+
+    // XElementAccess
+    virtual Type SAL_CALL getElementType(  ) throw (RuntimeException)
+    { return getCppuType(static_cast< const rtl::OUString * >(0) ); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (RuntimeException)
+    { return ( ( m_hEvents.size() > 0 ? sal_True : sal_False ) ); }
+private:
+
+typedef std::hash_map< rtl::OUString, Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventSupplierHash;
+
+    EventSupplierHash m_hEvents;
+};
+
+ReadOnlyEventsNameContainer::ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+{
+    const rtl::OUString* pSrc = eventMethods.getConstArray();
+    sal_Int32 nLen = eventMethods.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index, ++pSrc )
+    {
+        Any aDesc;
+        ScriptEventDescriptor evtDesc;
+        if (  eventMethodToDescriptor( *pSrc, evtDesc, sCodeName ) )
+        {
+            aDesc <<= evtDesc; 
+            m_hEvents[ *pSrc ] = aDesc;
+        }
+    }
+}
+
+Any SAL_CALL 
+ReadOnlyEventsNameContainer::getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException){
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        throw container::NoSuchElementException();
+    return it->second;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL 
+ReadOnlyEventsNameContainer::getElementNames(  ) throw (RuntimeException)
+{
+    Sequence< ::rtl::OUString > names(m_hEvents.size());
+    rtl::OUString* pDest = names.getArray();
+    EventSupplierHash::const_iterator it = m_hEvents.begin();
+    EventSupplierHash::const_iterator it_end = m_hEvents.end();
+    for ( sal_Int32 index = 0; it != it_end; ++index, ++pDest, ++it )
+        *pDest = it->first;
+    return names;
+}
+
+sal_Bool SAL_CALL 
+ReadOnlyEventsNameContainer::hasByName( const ::rtl::OUString& aName ) throw (RuntimeException)
+{
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        return sal_False;
+    return sal_True;
+}
+
+typedef ::cppu::WeakImplHelper1< XScriptEventsSupplier > EventsSupplier_BASE;
+
+class ReadOnlyEventsSupplier : public EventsSupplier_BASE
+{
+public:
+    ReadOnlyEventsSupplier( const Sequence< ::rtl::OUString >& eventMethods, const rtl::OUString& sCodeName )
+    { m_xNameContainer = new ReadOnlyEventsNameContainer( eventMethods, sCodeName ); }
+    
+    // XScriptEventSupplier
+    virtual Reference< container::XNameContainer > SAL_CALL getEvents(  ) throw (RuntimeException){ return m_xNameContainer; }
+private:
+    Reference< container::XNameContainer > m_xNameContainer;
+};
+
+typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+
+#define EVENTLSTNR_PROPERTY_ID_MODEL         1
+#define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
+
+class EventListener : public EventListener_BASE
+    ,public ::comphelper::OMutexAndBroadcastHelper
+    ,public ::comphelper::OPropertyContainer
+    ,public ::comphelper::OPropertyArrayUsageHelper< EventListener >
+
+{
+    
+public:
+    EventListener( const Reference< XComponentContext >& rxContext );
+    // XEventListener
+    virtual void SAL_CALL disposing(const lang::EventObject& Source) throw( RuntimeException );
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
+    // XInitialization
+    virtual void SAL_CALL initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException);
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+    virtual void SAL_CALL setFastPropertyValue( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::beans::PropertyVetoException, ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OPropertyContainer::setFastPropertyValue( nHandle, rValue );
+	if ( nHandle == EVENTLSTNR_PROPERTY_ID_MODEL )
+            setShellFromModel();
+    }
+
+protected:
+    // OPropertySetHelper
+    virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+    // OPropertyArrayUsageHelper
+    virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
+private:
+#if ASYNC
+    DECL_LINK( OnAsyncScriptEvent, ScriptEvent* );
+#endif
+    void setShellFromModel();
+    void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
+
+    Reference< XComponentContext > m_xContext;
+    Reference< frame::XModel > m_xModel;
+    SfxObjectShell* mpShell;
+    
+};
+
+EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext ), mpShell( 0 )
+{
+    registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
+        beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
+
+}
+
+void
+EventListener::setShellFromModel()
+{
+	// reset mpShell
+	mpShell = 0;
+	SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+	while ( m_xModel.is() && pShell )
+	{
+		if ( pShell->GetModel() == m_xModel )
+		{
+			mpShell = pShell;
+			break;
+		}
+		pShell = SfxObjectShell::GetNext( *pShell );
+	}    
+}
+
+//XEventListener
+void
+EventListener::disposing(const lang::EventObject&)  throw( RuntimeException )
+{
+}
+
+//XScriptListener
+
+void SAL_CALL 
+EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
+{
+#if ASYNC
+    // needs some logic to check if the event handler is oneway or not
+    // if not oneway then firing_Impl otherwise... as below
+    acquire();
+    Application::PostUserEvent( LINK( this, EventListener, OnAsyncScriptEvent ), new ScriptEvent( evt ) );
+#else
+    firing_Impl( evt );
+#endif
+}
+
+#if ASYNC
+IMPL_LINK( EventListener, OnAsyncScriptEvent, ScriptEvent*, _pEvent )
+{
+	if ( !_pEvent )
+		return 1L;
+
+	{
+		// #FIXME if we enable ASYNC we probably need something like 
+		// below
+		//::osl::ClearableMutexGuard aGuard( m_aMutex );
+
+		//if ( !impl_isDisposed_nothrow() )
+		//	impl_doFireScriptEvent_nothrow( aGuard, *_pEvent, NULL );
+		firing_Impl( *_pEvent, NULL );
+	}
+
+	delete _pEvent;
+	// we acquired ourself immediately before posting the event
+	release();
+	return 0L;
+ }
+#endif 
+
+Any SAL_CALL 
+EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
+{
+    Any ret;
+    firing_Impl( evt, &ret );
+    return ret;
+}
+
+// XInitialization
+void SAL_CALL 
+EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
+{
+    if ( aArguments.getLength() == 1 )
+        aArguments[0] >>= m_xModel;
+    OSL_TRACE("EventListener::initialize() args %d m_xModel %d", aArguments.getLength(), m_xModel.is() );
+}
+
+// XInterface
+
+IMPLEMENT_FORWARD_XINTERFACE2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// XTypeProvider
+
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// OPropertySetHelper
+
+::cppu::IPropertyArrayHelper& 
+EventListener::getInfoHelper(  )
+{
+    return *getArrayHelper();
+}
+
+// OPropertyArrayUsageHelper
+
+::cppu::IPropertyArrayHelper* 
+EventListener::createArrayHelper(  ) const
+{
+    Sequence< beans::Property > aProps;
+    describeProperties( aProps );
+    return new ::cppu::OPropertyArrayHelper( aProps );
+}
+
+// XPropertySet
+Reference< beans::XPropertySetInfo > 
+EventListener::getPropertySetInfo(  ) throw (RuntimeException)
+{
+    Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+    return xInfo;
+}
+
+//liuchen 2009-6-23
+//decide if the control should execute the event
+bool ApproveAll(const ScriptEvent& evt, void* pPara)
+{
+	return true;
+}
+
+//for the given control type in evt.Arguments[0], look for if it appears in the type list in pPara
+bool FindControl(const ScriptEvent& evt, void* pPara)
+{
+	lang::EventObject aEvent;
+	evt.Arguments[ 0 ] >>= aEvent;
+	uno::Reference< uno::XInterface > xInterface( aEvent.Source, uno::UNO_QUERY );
+
+	TypeList* pTypeListInfo = static_cast<TypeList*>(pPara);
+	Type* pType = pTypeListInfo->pTypeList;
+	int nLen = pTypeListInfo->nListLength;
+
+	for (int i = 0; i < nLen; i++)
+	{
+		if ( xInterface->queryInterface( *pType ).hasValue() )
+		{
+			return true;
+		}
+		pType++;
+	}
+
+	return false;
+}
+
+//if the the given control type in evt.Arguments[0] appears in the type list in pPara, then approve the execution
+bool ApproveType(const ScriptEvent& evt, void* pPara)
+{
+	return FindControl(evt, pPara);
+}
+
+//if the the given control type in evt.Arguments[0] appears in the type list in pPara, then deny the execution
+bool DenyType(const ScriptEvent& evt, void* pPara)
+{
+	return !FindControl(evt, pPara);
+}
+
+//when mouse is moving, either the mouse button is pressed or some key is pressed can trigger the OO mouseDragged event,
+//the former should be denyed, and the latter allowed, only by doing so can the VBA MouseMove event when the "Shift" key is 
+//pressed can be correctly triggered
+bool DenyMouseDrag(const ScriptEvent& evt, void* pPara)
+{
+	awt::MouseEvent aEvent;
+	evt.Arguments[ 0 ] >>= aEvent;
+	if (aEvent.Buttons == 0 )
+	{
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+}
+
+
+
+//liuchen 2009-6-23
+// EventListener
+
+void
+EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeException)
+{
+	OSL_TRACE("EventListener::firing_Impl( FAKE VBA_EVENTS )");
+    static const ::rtl::OUString vbaInterOp =
+        ::rtl::OUString::createFromAscii("VBAInterop");
+
+    // let default handlers deal with non vba stuff
+    if ( !evt.ScriptType.equals( vbaInterOp ) )
+        return;
+    lang::EventObject aEvent;
+    evt.Arguments[ 0 ] >>= aEvent;
+	OSL_TRACE("evt.MethodName is  %s", rtl::OUStringToOString( evt.MethodName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Argument[0] is  %s", rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[0] ), RTL_TEXTENCODING_UTF8 ).getStr() );
+	OSL_TRACE("Getting Control");
+    uno::Reference< awt::XControl > xControl( aEvent.Source, uno::UNO_QUERY_THROW );
+	OSL_TRACE("Getting properties");
+    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
+
+    rtl::OUString sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm") );
+	OSL_TRACE("Getting Name");
+
+    uno::Reference< awt::XDialog > xDlg( aEvent.Source, uno::UNO_QUERY );
+    if ( !xDlg.is() )
+        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sName;
+    //dumpEvent( evt );
+    EventInfoHash& infos = getEventTransInfo();
+    EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+    if ( eventInfo_it == it_end )
+    {
+        OSL_TRACE("Bogus event for %s",
+            rtl::OUStringToOString( evt.ScriptType, RTL_TEXTENCODING_UTF8 ).getStr() );
+        return;
+    }
+
+    uno::Reference< script::provider::XScriptProviderSupplier > xSPS( m_xModel, uno::UNO_QUERY );
+    uno::Reference< script::provider::XScriptProvider > xScriptProvider;
+    if ( xSPS.is() )
+        xScriptProvider =  xSPS->getScriptProvider();
+    if ( xScriptProvider.is() && mpShell )
+    {
+        std::list< TranslateInfo > matchingMethods;
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
+       
+        StarBASIC* pBasic = mpShell->GetBasic();
+        BasicManager* pBasicManager = mpShell->GetBasicManager();
+        rtl::OUString sProject;
+        rtl::OUString sScriptCode( evt.ScriptCode );
+	// dialogs pass their own library, presence of Dot determines that
+	if ( sScriptCode.indexOf( '.' ) == -1 )
+	{
+        	//'Project' is a better default but I want to force failures
+	        //rtl::OUString sMacroLoc = rtl::OUString::createFromAscii("Project");
+        	sProject = rtl::OUString::createFromAscii("Standard");
+
+        	if ( pBasicManager->GetName().Len() > 0 )
+            		sProject =  pBasicManager->GetName();
+	}
+	else
+	{
+		sal_Int32 nIndex = sScriptCode.indexOf( '.' );
+		sProject = sScriptCode.copy( 0, nIndex );
+                sScriptCode = sScriptCode.copy( nIndex + 1 );
+	}
+        rtl::OUString sMacroLoc = sProject;
+        sMacroLoc = sMacroLoc.concat(  rtl::OUString::createFromAscii(".") );
+        sMacroLoc = sMacroLoc.concat( sScriptCode ).concat( rtl::OUString::createFromAscii(".") );
+        
+        OSL_TRACE("sMacroLoc is %s", rtl::OUStringToOString( sMacroLoc, RTL_TEXTENCODING_UTF8 ).getStr() );
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            rtl::OUString sTemp = sName.concat( (*txInfo).sVBAName ); 
+            // see if we have a match for the handlerextension
+            // where ScriptCode is methodname_handlerextension 
+            rtl::OUString sToResolve = sMacroLoc.concat( sTemp );
+            OSL_TRACE("*** trying to invoke %s ",
+                rtl::OUStringToOString( sToResolve, RTL_TEXTENCODING_UTF8 ).getStr() );
+            ooo::vba::VBAMacroResolvedInfo aMacroResolvedInfo = ooo::vba::resolveVBAMacro( mpShell, sToResolve ); 
+            if ( aMacroResolvedInfo.IsResolved() )
+            {
+				//liuchen 2009-6-8
+				if (! txInfo->ApproveRule(evt, txInfo->pPara) )
+				{
+					continue;
+				}
+				//liuchen 2009-6-8
+                // !! translate arguments & emulate events where necessary 
+                Sequence< Any > aArguments;
+                if  ( (*txInfo).toVBA )
+                    aArguments = (*txInfo).toVBA( evt.Arguments );
+                else
+                    aArguments = evt.Arguments;
+                if ( aArguments.getLength() )
+                {
+                    // call basic event handlers for event
+
+                    // create script url
+                    rtl::OUString url = aMacroResolvedInfo.ResolvedMacro();
+                 
+                    OSL_TRACE("resolved script = %s",
+                        rtl::OUStringToOString( url, 
+                            RTL_TEXTENCODING_UTF8 ).getStr() );
+                    try
+                    {
+                        uno::Any aDummyCaller = uno::makeAny( rtl::OUString::createFromAscii("Error") );
+                        if ( pRet )
+                            ooo::vba::executeMacro( mpShell, url, aArguments, *pRet, aDummyCaller ); 
+                        else
+                        {
+                            uno::Any aRet;
+                            ooo::vba::executeMacro( mpShell, url, aArguments, aRet, aDummyCaller ); 
+                        }
+                    }
+                    catch ( uno::Exception& e )
+                    {
+                        OSL_TRACE("event script raised %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    }
+               } 
+           }
+       }
+    }
+}
+
+typedef ::cppu::WeakImplHelper1< XVBAToOOEventDescGen > VBAToOOEventDescGen_BASE;
+
+
+class VBAToOOEventDescGen : public VBAToOOEventDescGen_BASE
+{
+public:
+    VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext );
+
+    // XVBAToOOEventDescGen
+    virtual Sequence< ScriptEventDescriptor > SAL_CALL getEventDescriptions( const Reference< XInterface >& control, const rtl::OUString& sCodeName ) throw (RuntimeException);
+    virtual Reference< XScriptEventsSupplier > SAL_CALL getEventSupplier( const Reference< XInterface >& xControl,  const rtl::OUString& sCodeName ) throw (::com::sun::star::uno::RuntimeException);
+private:
+    Reference< XComponentContext > m_xContext;
+  
+};
+
+VBAToOOEventDescGen::VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext ):m_xContext( rxContext ) {}
+
+Sequence< ScriptEventDescriptor > SAL_CALL 
+VBAToOOEventDescGen::getEventDescriptions( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName ) throw (RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    return evntHelper.createEvents( sCodeName ); 
+}
+
+Reference< XScriptEventsSupplier > SAL_CALL 
+VBAToOOEventDescGen::getEventSupplier( const Reference< XInterface >& xControl, const rtl::OUString& sCodeName  ) throw (::com::sun::star::uno::RuntimeException)
+{
+    ScriptEventHelper evntHelper( xControl ); 
+    Reference< XScriptEventsSupplier > xSupplier = 
+        new ReadOnlyEventsSupplier( 
+            evntHelper.getEventListeners(), sCodeName ) ;
+    return xSupplier;
+}
+
+// Component related 
+
+namespace evtlstner
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.EventListener" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+    Reference< XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new EventListener( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::evtlstner::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
+namespace ooevtdescgen 
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAToOOEventDesc" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new VBAToOOEventDescGen( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+    	const ::rtl::OUString strName( ::ooevtdescgen::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
Index: scripting/source/vbaevents/makefile.mk
===================================================================
--- scripting/source/vbaevents/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ scripting/source/vbaevents/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+PRJ=..$/..
+
+PRJNAME=vbaevents
+TARGET=vbaevents
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vbaevents..."
+.ENDIF
+
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+        $(SLOTARGET)
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/eventhelper.obj
+
+SHL1TARGET= $(TARGET)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+
+SHL1VERSIONMAP=$(TARGET).map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                              
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(COMPHELPERLIB) \
+		$(SFXLIB) \
+		$(SVXMSFILTERLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+                                                                              
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
Index: scripting/source/vbaevents/vbaevents.map
===================================================================
--- scripting/source/vbaevents/vbaevents.map	(.../tags/DEV300_m58)	(revision 0)
+++ scripting/source/vbaevents/vbaevents.map	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
Index: scripting/source/vbaevents/vbaevents.xml
===================================================================
--- scripting/source/vbaevents/vbaevents.xml	(.../tags/DEV300_m58)	(revision 0)
+++ scripting/source/vbaevents/vbaevents.xml	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>vbaevents</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>ooo.vba.EventListener</name>
+        <description>Event listener to handle ooo events and to translate them to calls to basic macros ala Button_Click etc.</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>ooo.vba.EventListener</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
Index: scripting/prj/build.lst
===================================================================
--- scripting/prj/build.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ scripting/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,8 +1,9 @@
-tc	scripting	:	bridges rdbmaker vcl xmlscript basic sfx2 rhino BSH:beanshell javaunohelper NULL
+tc	scripting	:	oovbaapi svx bridges rdbmaker vcl xmlscript basic sfx2 rhino BSH:beanshell javaunohelper NULL
 tc	scripting									usr1	-	all	tc1_mkout NULL
 tc	scripting\inc								nmake	-	all	tc1_inc NULL
 tc	scripting\source\provider				nmake	-	all	tc1_scriptingprovider tc1_inc NULL
 tc	scripting\source\basprov				nmake	-	all	tc1_scriptingbasprov tc1_inc NULL
+tc	scripting\source\vbaevents				nmake	-	all	tc1_scriptingvbaevents tc1_inc NULL
 tc	scripting\source\dlgprov				nmake	-	all	tc1_scriptingdlgprov tc1_inc NULL
 tc	scripting\source\stringresource			nmake	-	all	tc1_scriptingstringresource tc1_inc NULL
 tc	scripting\source\pyprov				nmake	-	all	tc1_scriptingpyprov tc1_inc NULL
@@ -10,4 +11,4 @@
 tc	scripting\java						nmake	-	all	tc1_scriptingjava tc1_scriptingprovider tc1_scriptingprotocolhandler NULL
 tc	scripting\examples\java				nmake	-	all	tc1_scriptingexamplesjava tc1_scriptingjava  NULL
 tc	scripting\examples				nmake	-	all	tc1_scriptingexamples tc1_scriptingexamplesjava  tc1_inc NULL
-tc	scripting\util						nmake	-	all	tc1_scriptingutil tc1_scriptingprovider tc1_scriptingprotocolhandler tc1_scriptingbasprov tc1_scriptingstringresource tc1_scriptingpyprov tc1_scriptingjava tc1_scriptingexamplesjava tc1_scriptingexamples NULL
+tc	scripting\util						nmake	-	all	tc1_scriptingutil tc1_scriptingprovider tc1_scriptingprotocolhandler tc1_scriptingbasprov tc1_scriptingstringresource tc1_scriptingvbaevents tc1_scriptingpyprov tc1_scriptingjava tc1_scriptingexamplesjava tc1_scriptingexamples NULL
Index: dbaccess/source/ext/macromigration/migrationengine.cxx
===================================================================
--- dbaccess/source/ext/macromigration/migrationengine.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ dbaccess/source/ext/macromigration/migrationengine.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1838,7 +1838,7 @@
             Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
 
             Reference< XNameContainer > xDialogModel( m_aContext.createComponent( "com.sun.star.awt.UnoControlDialogModel" ), UNO_QUERY_THROW );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext() );
+            ::xmlscript::importDialogModel( xInput, xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
 
             // adjust the events of the dialog
             impl_adjustDialogElementEvents_throw( xDialogModel );
@@ -1853,7 +1853,7 @@
             }
 
             // export dialog model
-            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext() );
+            xISP = ::xmlscript::exportDialogModel( xDialogModel, m_aContext.getUNOContext(), m_xDocumentModel );
             _inout_rDialogLibraryElement <<= xISP;
         }
         catch( const Exception& )
Index: sfx2/source/doc/docmacromode.cxx
===================================================================
--- sfx2/source/doc/docmacromode.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/docmacromode.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,7 @@
 #include <com/sun/star/task/DocumentMacroConfirmationRequest.hpp>
 #include <com/sun/star/task/InteractionClassification.hpp>
 #include <com/sun/star/security/XDocumentDigitalSignatures.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
 /** === end UNO includes === **/
 
 #include <comphelper/componentcontext.hxx>
@@ -75,8 +76,10 @@
     using ::com::sun::star::document::XEmbeddedScripts;
     using ::com::sun::star::uno::UNO_SET_THROW;
     using ::com::sun::star::script::XLibraryContainer;
+    using ::com::sun::star::script::XLibraryQueryExecutable;
     using ::com::sun::star::container::XNameAccess;
     using ::com::sun::star::uno::UNO_QUERY_THROW;
+    using ::com::sun::star::uno::UNO_QUERY;
 	/** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
 
@@ -438,11 +441,9 @@
                             // rid of the "Standard" thingie - this shouldn't be necessary
                             // anymore, should it?
                             // 2007-01-25 / frank.schoenheit@sun.com
-						    Reference < XNameAccess > xLib;
-						    Any aAny = xContainer->getByName( aStdLibName );
-						    aAny >>= xLib;
+						    Reference < XLibraryQueryExecutable > xLib( xContainer, UNO_QUERY );
 						    if ( xLib.is() )
-							    bHasMacroLib = xLib->hasElements();
+							    bHasMacroLib = xLib->HasExecutableCode( aStdLibName );
 					    }
 				    }
 			    }
Index: sfx2/source/doc/objcont.cxx
===================================================================
--- sfx2/source/doc/objcont.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/objcont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1471,31 +1471,35 @@
 
 void SfxObjectShell::ResetFromTemplate( const String& rTemplateName, const String& rFileName )
 {
-    uno::Reference<document::XDocumentProperties> xDocProps(getDocProperties());
-    xDocProps->setTemplateURL( ::rtl::OUString() );
-    xDocProps->setTemplateName( ::rtl::OUString() );
-    xDocProps->setTemplateDate( util::DateTime() );
-    xDocProps->resetUserData( ::rtl::OUString() );
-
-	// TODO/REFACTOR:
-	// Title?
-
-    if( ::utl::LocalFileHelper::IsLocalFile( rFileName ) )
-	{
-        String aFoundName;
-        if( SFX_APP()->Get_Impl()->GetDocumentTemplates()->GetFull( String(), rTemplateName, aFoundName ) )
-        {
-            INetURLObject aObj( rFileName );
-            xDocProps->setTemplateURL( aObj.GetMainURL(INetURLObject::DECODE_TO_IURI) );
-            xDocProps->setTemplateName( rTemplateName );
-
-            ::DateTime now;
-            xDocProps->setTemplateDate( util::DateTime(
-                now.Get100Sec(), now.GetSec(), now.GetMin(),
-                now.GetHour(), now.GetDay(), now.GetMonth(),
-                now.GetYear() ) );
-
-			SetQueryLoadTemplate( sal_True );
+    // only care about reseting this data for openoffice formats otherwise
+    if ( IsOwnStorageFormat_Impl( *GetMedium())  )
+    {
+        uno::Reference<document::XDocumentProperties> xDocProps(getDocProperties());
+        xDocProps->setTemplateURL( ::rtl::OUString() );
+        xDocProps->setTemplateName( ::rtl::OUString() );
+        xDocProps->setTemplateDate( util::DateTime() );
+        xDocProps->resetUserData( ::rtl::OUString() );
+    
+    	// TODO/REFACTOR:
+    	// Title?
+    
+        if( ::utl::LocalFileHelper::IsLocalFile( rFileName ) )
+    	{
+            String aFoundName;
+            if( SFX_APP()->Get_Impl()->GetDocumentTemplates()->GetFull( String(), rTemplateName, aFoundName ) )
+            {
+                INetURLObject aObj( rFileName );
+                xDocProps->setTemplateURL( aObj.GetMainURL(INetURLObject::DECODE_TO_IURI) );
+                xDocProps->setTemplateName( rTemplateName );
+    
+                ::DateTime now;
+                xDocProps->setTemplateDate( util::DateTime(
+                    now.Get100Sec(), now.GetSec(), now.GetMin(),
+                    now.GetHour(), now.GetDay(), now.GetMonth(),
+                    now.GetYear() ) );
+    
+    			SetQueryLoadTemplate( sal_True );
+            }
         }
     }
 }
Index: sfx2/source/doc/SfxDocumentMetaData.cxx
===================================================================
--- sfx2/source/doc/SfxDocumentMetaData.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/SfxDocumentMetaData.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -89,6 +89,10 @@
 #include <cstring>
 #include <limits>
 
+
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
+
 /**
  * This file contains the implementation of the service
  * com.sun.star.document.DocumentProperties.
@@ -298,12 +302,12 @@
         const css::uno::Sequence< css::beans::StringPair >& i_rNamespaces)
         throw (css::uno::RuntimeException, css::xml::sax::SAXException);
 
-private:
+protected:
     SfxDocumentMetaData(SfxDocumentMetaData &); // not defined
     SfxDocumentMetaData& operator =(SfxDocumentMetaData &); // not defined
 
     virtual ~SfxDocumentMetaData() {}
-
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new SfxDocumentMetaData( context ); };
     const css::uno::Reference< css::uno::XComponentContext > m_xContext;
 
     /// for notification
@@ -378,6 +382,54 @@
     void createUserDefined();
 };
 
+typedef ::cppu::ImplInheritanceHelper1< SfxDocumentMetaData, css::document::XCompatWriterDocProperties > CompatWriterDocPropsImpl_BASE;
+
+class CompatWriterDocPropsImpl : public CompatWriterDocPropsImpl_BASE
+{
+    rtl::OUString msManager;
+    rtl::OUString msCategory;
+    rtl::OUString msCompany;
+protected:
+    virtual SfxDocumentMetaData* createMe( css::uno::Reference< css::uno::XComponentContext > const & context ) { return new CompatWriterDocPropsImpl( context ); };
+public:
+    CompatWriterDocPropsImpl( css::uno::Reference< css::uno::XComponentContext > const & context) : CompatWriterDocPropsImpl_BASE( context ) {}
+// XCompatWriterDocPropsImpl
+    virtual ::rtl::OUString SAL_CALL getManager() throw (::com::sun::star::uno::RuntimeException) { return msManager; }
+    virtual void SAL_CALL setManager( const ::rtl::OUString& _manager ) throw (::com::sun::star::uno::RuntimeException) { msManager = _manager; }
+    virtual ::rtl::OUString SAL_CALL getCategory() throw (::com::sun::star::uno::RuntimeException){ return msCategory; }
+    virtual void SAL_CALL setCategory( const ::rtl::OUString& _category ) throw (::com::sun::star::uno::RuntimeException){ msCategory = _category; }
+    virtual ::rtl::OUString SAL_CALL getCompany() throw (::com::sun::star::uno::RuntimeException){ return msCompany; }
+    virtual void SAL_CALL setCompany( const ::rtl::OUString& _company ) throw (::com::sun::star::uno::RuntimeException){ msCompany = _company; }
+
+// XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getImplementationName();
+    }
+
+    virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        css::uno::Sequence< rtl::OUString > sServiceNames= getSupportedServiceNames();
+        sal_Int32 nLen = sServiceNames.getLength();
+        rtl::OUString* pIt = sServiceNames.getArray();
+        rtl::OUString* pEnd = ( pIt + nLen );
+        sal_Bool bRes = sal_False;
+        for ( ; pIt != pEnd; ++pIt )
+        {
+            if ( pIt->equals( ServiceName ) )
+            {
+                bRes = sal_True;
+                break;
+            }
+        }
+        return bRes;
+    }
+
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        return comp_CompatWriterDocProps::_getSupportedServiceNames();
+    }
+};
 ////////////////////////////////////////////////////////////////////////////
 
 bool operator== (const css::util::DateTime &i_rLeft,
@@ -2123,7 +2175,7 @@
     ::osl::MutexGuard g(m_aMutex);
     checkInit();
 
-    SfxDocumentMetaData *pNew = new SfxDocumentMetaData(m_xContext);
+    SfxDocumentMetaData *pNew = createMe(m_xContext);
 
     // NB: do not copy the modification listeners, only DOM
     css::uno::Reference<css::xml::dom::XDocument> xDoc = createDOM();
@@ -2289,6 +2341,32 @@
 
 
 // component helper namespace
+namespace comp_CompatWriterDocProps {
+
+    ::rtl::OUString SAL_CALL _getImplementationName() {
+        return ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
+            "CompatWriterDocPropsImpl"));
+}
+
+   css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames()
+   {
+        static css::uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+            aServiceNames.realloc( 1 );
+            aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.writer.DocumentProperties" ) ); 
+        }
+        return aServiceNames;
+   } 
+    css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        const css::uno::Reference< css::uno::XComponentContext > & context)
+            SAL_THROW((css::uno::Exception))
+    {
+        return static_cast< ::cppu::OWeakObject * >
+                    (new CompatWriterDocPropsImpl(context));
+    }
+
+}
 namespace comp_SfxDocumentMetaData {
 
 ::rtl::OUString SAL_CALL _getImplementationName() {
Index: sfx2/source/doc/docinf.cxx
===================================================================
--- sfx2/source/doc/docinf.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/docinf.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -37,6 +37,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyContainer.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 #include <com/sun/star/uno/Exception.hpp>
 
 #include <rtl/ustring.hxx>
@@ -46,7 +47,6 @@
 #include <vcl/gdimtf.hxx>
 
 #include "oleprops.hxx"
-
 // ============================================================================
 
 // stream names
@@ -175,6 +175,28 @@
         }
     }
 
+    uno::Reference< document::XCompatWriterDocProperties > xWriterProps( i_xDocProps, uno::UNO_QUERY );
+    if ( xWriterProps.is() )
+    {
+        SfxOleSectionRef xBuiltin = aDocSet.GetSection( SECTION_BUILTIN );
+        if ( xBuiltin.get() )
+        {
+            try
+            {
+                String aStrValue;
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_MANAGER ) )
+                    xWriterProps->setManager( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_CATEGORY ) )
+                    xWriterProps->setCategory( aStrValue );
+                if ( xBuiltin->GetStringValue( aStrValue, PROPID_COMPANY ) )
+                    xWriterProps->setCompany( aStrValue );
+            }
+            catch ( uno::Exception& )
+            {
+            }
+        }
+    }
+
     // return code
     return (nGlobError != ERRCODE_NONE) ? nGlobError : nDocError;
 }
Index: sfx2/source/doc/objserv.cxx
===================================================================
--- sfx2/source/doc/objserv.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/objserv.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -103,6 +103,7 @@
 #include <com/sun/star/embed/XTransactedObject.hpp>
 #include <com/sun/star/util/XCloneable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 
 #include "helpid.hrc"
 
@@ -507,6 +508,18 @@
 		case SID_SAVEASDOC:
 		case SID_SAVEDOC:
 		{
+            if( nId == SID_SAVEDOC || nId == SID_SAVEASDOC )
+            {
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue( SfxBoolItem( 0, sal_True ) );
+                        return;
+                    }
+                }
+            }
 			//!! detaillierte Auswertung eines Fehlercodes
 			SfxObjectShellRef xLock( this );
 
@@ -1475,3 +1488,19 @@
     ImplSign( TRUE );
 }
 
+// static
+const uno::Sequence<sal_Int8>& SfxObjectShell::getUnoTunnelId()
+{
+	static uno::Sequence<sal_Int8> * pSeq = 0;
+	if( !pSeq )
+	{
+		osl::Guard< osl::Mutex > aGuard( osl::Mutex::getGlobalMutex() );
+		if( !pSeq )
+		{
+			static uno::Sequence< sal_Int8 > aSeq( 16 );
+			rtl_createUuid( (sal_uInt8*)aSeq.getArray(), 0, sal_True );
+			pSeq = &aSeq;
+		}
+	}
+	return *pSeq;
+}
Index: sfx2/source/doc/sfxbasemodel.cxx
===================================================================
--- sfx2/source/doc/sfxbasemodel.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/sfxbasemodel.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -888,7 +888,15 @@
 
 	return m_pData->m_xDocumentInfo;
 }
-
+void 
+SfxBaseModel::setDocumentProperties( const uno::Reference< document::XDocumentProperties >& rxNewDocProps )
+{
+	// object already disposed?
+    ::vos::OGuard aGuard( Application::GetSolarMutex() );
+    if ( impl_isDisposed() )
+        throw lang::DisposedException();
+    m_pData->m_xDocumentProperties.set(rxNewDocProps, uno::UNO_QUERY_THROW);
+}
 // document::XDocumentPropertiesSupplier:
 uno::Reference< document::XDocumentProperties > SAL_CALL
 SfxBaseModel::getDocumentProperties()
Index: sfx2/source/doc/objmisc.cxx
===================================================================
--- sfx2/source/doc/objmisc.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/objmisc.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1644,7 +1644,7 @@
 }
 
 ErrCode SfxObjectShell::CallXScript( const Reference< XInterface >& _rxScriptContext, const ::rtl::OUString& _rScriptURL,
-    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam )
+    const Sequence< Any >& aParams, Any& aRet, Sequence< sal_Int16 >& aOutParamIndex, Sequence< Any >& aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
     OSL_TRACE( "in CallXScript" );
 	ErrCode nErr = ERRCODE_NONE;
@@ -1675,7 +1675,16 @@
 
         // obtain the script, and execute it
         Reference< provider::XScript > xScript( xScriptProvider->getScript( _rScriptURL ), UNO_QUERY_THROW );
-
+        if ( pCaller && pCaller->hasValue() )
+        {
+            Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY ); 
+            if ( xProps.is() )
+            {
+                Sequence< uno::Any > aArgs( 1 );
+                aArgs[ 0 ] = *pCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii("Caller"), uno::makeAny( aArgs ) );
+            }
+        }
         aRet = xScript->invoke( aParams, aOutParamIndex, aOutParam );
     }
     catch ( const uno::Exception& )
@@ -1685,7 +1694,7 @@
         nErr = ERRCODE_BASIC_INTERNAL_ERROR;
     }
 
-	if ( bCaughtException )
+	if ( bCaughtException && bRaiseError )
 	{
         ::std::auto_ptr< VclAbstractDialog > pScriptErrDlg;
 		SfxAbstractDialogFactory* pFact = SfxAbstractDialogFactory::Create();
@@ -1709,9 +1718,9 @@
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >&
-            aOutParam)
+            aOutParam, bool bRaiseError, ::com::sun::star::uno::Any* pCaller )
 {
-    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam );
+    return CallXScript( GetModel(), rScriptURL, aParams, aRet, aOutParamIndex, aOutParam, bRaiseError, pCaller );
 }
 
 //-------------------------------------------------------------------------
Index: sfx2/source/doc/objxtor.cxx
===================================================================
--- sfx2/source/doc/objxtor.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/objxtor.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -136,6 +136,33 @@
 extern svtools::AsynchronLink* pPendingCloser;
 static WeakReference< XInterface > s_xCurrentComponent;
 
+void lcl_UpdateAppBasicDocVars(  const Reference< XInterface >& _rxComponent, bool bClear = false )
+{
+    BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
+    if ( pAppMgr )
+    {
+        uno::Reference< beans::XPropertySet > xProps( _rxComponent, uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            try
+            {
+                beans::PropertyValue aProp;
+                xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisVBADocObj") ) ) >>= aProp;
+                rtl::OString sTmp( rtl::OUStringToOString( aProp.Name, RTL_TEXTENCODING_UTF8 ) );
+                const char* pAscii = sTmp.getStr();
+                if ( bClear )
+                    pAppMgr->SetGlobalUNOConstant( pAscii, uno::makeAny( uno::Reference< uno::XInterface >() ) );
+                else
+                    pAppMgr->SetGlobalUNOConstant( pAscii, aProp.Value );
+    
+            }
+            catch( uno::Exception& e )
+            {
+            }
+        }
+    }
+}
+
 //=========================================================================
 
 
@@ -170,6 +197,7 @@
     ::vos::OGuard aSolarGuard( Application::GetSolarMutex() );
     if ( SfxObjectShell::GetCurrentComponent() == _rEvent.Source )
     {
+        lcl_UpdateAppBasicDocVars( SfxObjectShell::GetCurrentComponent(), true );
         // remove ThisComponent reference from AppBasic
         SfxObjectShell::SetCurrentComponent( Reference< XInterface >() );
     }
@@ -538,6 +566,13 @@
 	return pFrame ? pFrame->GetObjectShell() : 0;
 }
 
+//-------------------------------------------------------------------------
+
+sal_Bool SfxObjectShell::IsInPrepareClose() const
+{
+    return pImp->bInPrepareClose;
+}
+
 //------------------------------------------------------------------------
 
 struct BoolEnv_Impl
@@ -1048,7 +1083,10 @@
     BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
     s_xCurrentComponent = _rxComponent;
     if ( pAppMgr )
+    {
+        lcl_UpdateAppBasicDocVars( _rxComponent );
         pAppMgr->SetGlobalUNOConstant( "ThisComponent", makeAny( _rxComponent ) );
+    }
 
 #if OSL_DEBUG_LEVEL > 0
     const char* pComponentImplName = _rxComponent.get() ? typeid( *_rxComponent.get() ).name() : "void";
Index: sfx2/source/doc/objuno.cxx
===================================================================
--- sfx2/source/doc/objuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/objuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -48,6 +48,7 @@
 #include <com/sun/star/lang/Locale.hpp>
 #include <com/sun/star/util/XModifiable.hpp>
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XCompatWriterDocProperties.hpp>
 
 #include <unotools/configmgr.hxx>
 #include <tools/inetdef.hxx>
@@ -107,6 +108,9 @@
         { "AutoloadEnabled" , 15, MID_DOCINFO_AUTOLOADENABLED, &::getBooleanCppuType(),   PROPERTY_UNBOUND, 0 },
         { "AutoloadSecs"    , 12, MID_DOCINFO_AUTOLOADSECS, &::getCppuType((const sal_Int32*)0),     PROPERTY_UNBOUND, 0 },
         { "AutoloadURL"     , 11, MID_DOCINFO_AUTOLOADURL, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Category"			, 8	, MID_CATEGORY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Company"			, 7	, MID_COMPANY,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
+	{ "Manager"			, 7	, MID_MANAGER,           &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "CreationDate"    , 12, WID_DATE_CREATED,   &::getCppuType((const ::com::sun::star::util::DateTime*)0),PROPERTY_MAYBEVOID, 0 },
         { "DefaultTarget"   , 13, MID_DOCINFO_DEFAULTTARGET, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
         { "Description"     , 11, MID_DOCINFO_DESCRIPTION, &::getCppuType((const ::rtl::OUString*)0), PROPERTY_UNBOUND, 0 },
@@ -810,6 +814,22 @@
                     _pImp->m_xDocProps->setDefaultTarget(sTemp);
 				break;
 //            case WID_CONTENT_TYPE : // this is readonly!
+               case MID_CATEGORY:
+               case MID_MANAGER:
+               case MID_COMPANY:
+                   {
+                       uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                       if ( xWriterProps.is() ) 
+                       {
+                           if ( nHandle ==  MID_CATEGORY )
+                               xWriterProps->setCategory( sTemp );
+                           else if ( nHandle ==  MID_MANAGER )
+                               xWriterProps->setManager( sTemp );
+                           else
+                               xWriterProps->setCompany( sTemp );
+                           break;
+                       }
+                   }
 			default:
 				break;
 		}
@@ -1027,6 +1047,23 @@
         case MID_DOCINFO_CHARLOCALE:
             aValue <<= _pImp->m_xDocProps->getLanguage();
             break;
+        case MID_CATEGORY:
+        case MID_MANAGER:
+        case MID_COMPANY:
+            {
+                uno::Reference< document::XCompatWriterDocProperties > xWriterProps( _pImp->m_xDocProps, uno::UNO_QUERY  );
+                if ( xWriterProps.is() ) 
+                {
+                    if ( nHandle ==  MID_CATEGORY )
+                        aValue <<= xWriterProps->getCategory();
+                    else if ( nHandle ==  MID_MANAGER )
+                        aValue <<= xWriterProps->getManager();
+                    else
+                        aValue <<= xWriterProps->getCompany();
+                        break;
+               }
+           }
+	
         default:
             aValue <<= ::rtl::OUString();
             break;
Index: sfx2/source/doc/oleprops.hxx
===================================================================
--- sfx2/source/doc/oleprops.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/doc/oleprops.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -83,6 +83,10 @@
 const sal_Int32 PROPID_LASTSAVED        = 13;
 const sal_Int32 PROPID_THUMBNAIL        = 17;
 
+// some Builtin properties
+const sal_Int32 PROPID_CATEGORY         = 0x2;
+const sal_Int32 PROPID_COMPANY          = 0xf;
+const sal_Int32 PROPID_MANAGER          = 0xe;
 // predefined codepages
 const sal_uInt16 CODEPAGE_UNKNOWN       = 0;
 const sal_uInt16 CODEPAGE_UNICODE       = 1200;
Index: sfx2/source/inc/SfxDocumentMetaData.hxx
===================================================================
--- sfx2/source/inc/SfxDocumentMetaData.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/inc/SfxDocumentMetaData.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -48,5 +48,16 @@
 
 } // closing component helper namespace
 
+namespace comp_CompatWriterDocProps {
+
+namespace css = ::com::sun::star;
+
+// component and service helper functions:
+::rtl::OUString SAL_CALL _getImplementationName();
+css::uno::Sequence< ::rtl::OUString > SAL_CALL _getSupportedServiceNames();
+css::uno::Reference< css::uno::XInterface > SAL_CALL _create(
+        css::uno::Reference< css::uno::XComponentContext > const & context );
+
+}
 #endif
 
Index: sfx2/source/view/viewprn.cxx
===================================================================
--- sfx2/source/view/viewprn.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/view/viewprn.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,6 +32,7 @@
 #include "precompiled_sfx2.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <com/sun/star/view/PrintableState.hpp>
 #include <svtools/itempool.hxx>
 #ifndef _MSGBOX_HXX //autogen
@@ -67,6 +68,8 @@
 #include "view.hrc"
 #include "helpid.hrc"
 
+using namespace com::sun::star;
+
 TYPEINIT1(SfxPrintingHint, SfxHint);
 
 // -----------------------------------------------------------------------
@@ -405,6 +408,22 @@
 		case SID_SETUPPRINTER:
 	    case SID_PRINTER_NAME :
 		{
+            if( nId == SID_PRINTDOC )
+            {
+				SfxObjectShell* pDoc = GetObjectShell();
+                if( pDoc )
+                {
+                    uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                    if( xVbaEventHelper.is() )
+                    {
+                        if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                        {
+                            rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                            return;
+                        }
+                    }
+                }
+            }
 	        // quiet mode (AppEvent, API call)
 			SFX_REQUEST_ARG(rReq, pSilentItem, SfxBoolItem, SID_SILENT, FALSE);
 			bSilent = pSilentItem && pSilentItem->GetValue();
@@ -717,6 +736,15 @@
 	        if ( SID_PRINTDOCDIRECT == nId )
 	        {
 				SfxObjectShell* pDoc = GetObjectShell();
+                uno::Reference< document::XDocumentEventCompatibleHelper > xVbaEventHelper( pDoc->GetModel(), uno::UNO_QUERY );
+                if( xVbaEventHelper.is() )
+                {
+                    if( xVbaEventHelper->processCompatibleEvent( nId ) )
+                    {
+                        rReq.SetReturnValue(SfxBoolItem(0,FALSE));
+                        return;
+                    }
+                }
 				bool bDetectHidden = ( !bSilent && pDoc );
 				if ( bDetectHidden && pDoc->QueryHiddenInformation( WhenPrinting, NULL ) != RET_YES )
 					return;
Index: sfx2/source/appl/app.cxx
===================================================================
--- sfx2/source/appl/app.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/appl/app.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -761,7 +761,7 @@
     basicide_handle_basic_error pSymbol = (basicide_handle_basic_error) osl_getFunctionSymbol( handleMod, aSymbol.pData );
 
     // call basicide_handle_basic_error in basctl
-    long nRet = pSymbol( pStarBasic );
+    long nRet = pSymbol ? pSymbol( pStarBasic ) : 0;
 
 	return nRet;
 }
Index: sfx2/source/appl/appuno.cxx
===================================================================
--- sfx2/source/appl/appuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/source/appl/appuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -2283,6 +2283,16 @@
     xNewKey = xKey->createKey( aTempStr );
     xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.document.DocumentProperties") );
 
+
+    // writer compatable document properties
+    aImpl = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+    aImpl += comp_CompatWriterDocProps::_getImplementationName();
+
+    aTempStr = aImpl;
+    aTempStr += ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/UNO/SERVICES"));
+    xNewKey = xKey->createKey( aTempStr );
+    xNewKey->createKey( ::rtl::OUString::createFromAscii("com.sun.star.writer.DocumentProperties") );
+
 	return sal_True;
 }
 
@@ -2340,8 +2350,18 @@
 			::comp_SfxDocumentMetaData::_getImplementationName(),
 			::comp_SfxDocumentMetaData::_getSupportedServiceNames());
         }
+        if ( ::comp_CompatWriterDocProps::_getImplementationName().equals(
+                 ::rtl::OUString::createFromAscii( pImplementationName ) ) )
+        {
+            xFactory = ::cppu::createSingleComponentFactory(
+			::comp_CompatWriterDocProps::_create,
+			::comp_CompatWriterDocProps::_getImplementationName(),
+			::comp_CompatWriterDocProps::_getSupportedServiceNames());
+        }
 
         // Factory is valid - service was found.
+
+        // Factory is valid - service was found.
 		if ( xFactory.is() )
 		{
 			xFactory->acquire();
Index: sfx2/inc/sfx2/sfx.hrc
===================================================================
--- sfx2/inc/sfx2/sfx.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/inc/sfx2/sfx.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -392,9 +392,11 @@
 #define MID_DOCINFO_ENCRYPTED				 0x2c
 #define MID_DOCINFO_STATISTIC				 0x33
 #define MID_DOCINFO_CHARLOCALE				 0x34
+#define MID_CATEGORY                                     0x35
+#define MID_COMPANY                                      0x36
+#define MID_MANAGER                                      0x37
+#define MID_LAST_USED_PROPID              MID_MANAGER   
 
-#define MID_LAST_USED_PROPID                 MID_DOCINFO_CHARLOCALE
-
 // Config-Ids -----------------------------------------------------------
 
 #define SFX_ITEMTYPE_SW_BEGIN 		20000
Index: sfx2/inc/sfx2/sfxbasemodel.hxx
===================================================================
--- sfx2/inc/sfx2/sfxbasemodel.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/inc/sfx2/sfxbasemodel.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1487,6 +1487,7 @@
     /* returns true if the document signatures are valid, otherwise false */
     sal_Bool hasValidSignatures() const;
 
+    void setDocumentProperties( const ::com::sun::star::uno::Reference< ::com::sun::star::document::XDocumentProperties >& );
 //________________________________________________________________________________________________________
 //	private methods
 //________________________________________________________________________________________________________
Index: sfx2/inc/sfx2/objsh.hxx
===================================================================
--- sfx2/inc/sfx2/objsh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sfx2/inc/sfx2/objsh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -264,6 +264,7 @@
 								TYPEINFO();
 								SFX_DECL_INTERFACE(SFX_INTERFACE_SFXDOCSH)
 
+    static const com::sun::star::uno::Sequence<sal_Int8>& getUnoTunnelId();
     /* Stampit disable/enable cancel button for print jobs
        default = true = enable! */
     void                        Stamp_SetPrintCancelState(sal_Bool bState);
@@ -307,6 +308,7 @@
     void                        SetNoName();
     sal_Bool                    IsInModalMode() const;
     sal_Bool					HasModalViews() const;
+    sal_Bool                    IsInPrepareClose() const;
     sal_Bool                    IsHelpDocument() const;
 
     sal_Bool                    IsDocShared() const;
@@ -409,7 +411,9 @@
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     static ErrCode  CallXScript(
@@ -418,7 +422,9 @@
         const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aParams,
         ::com::sun::star::uno::Any& aRet,
         ::com::sun::star::uno::Sequence< sal_Int16 >& aOutParamIndex,
-        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam
+        ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aOutParam,
+        bool bRaiseError = true,
+        ::com::sun::star::uno::Any* aCaller = 0
     );
 
     /** adjusts the internal macro mode, according to the current security settings
@@ -882,6 +888,7 @@
 	virtual	sal_Bool		PutValue( const com::sun::star::uno::Any& rVal, BYTE nMemberId = 0 );
 	SfxObjectShell* 		GetObjectShell() const
 							{ return pObjSh; }
+
 };
 
 #endif
Index: vcl/source/control/combobox.cxx
===================================================================
--- vcl/source/control/combobox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/control/combobox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -470,8 +470,11 @@
 		mpSubEdit->SetModifyFlag();
 		mbSyntheticModify = TRUE;
 		Modify();
-		mbSyntheticModify = FALSE;
-		Select();
+		mbSyntheticModify = FALSE;		
+		if (ImplGetWindowImpl() != NULL) //liuchen 2009-7-28, resolve the problem that soffice get crashed if in ComboBox_Change event a Worksheets("SheetX").Activate sentence needs to be executed 
+		{
+			Select();
+		}
 	}
 
 	return 0;
Index: vcl/source/gdi/bitmapex.cxx
===================================================================
--- vcl/source/gdi/bitmapex.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/gdi/bitmapex.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,6 +47,7 @@
 #include <tools/rc.h>
 #endif
 #include <vcl/svapp.hxx>
+#include <vcl/virdev.hxx>
 
 // ------------
 // - BitmapEx -
@@ -759,6 +760,61 @@
 	pOutDev->DrawBitmapEx( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, *this );
 }
 
+BitmapEx BitmapEx:: AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize)
+{
+	Point aEmptyPoint(0,0);
+	sal_Int32 imgNewWidth = 0;
+	sal_Int32 imgNewHeight = 0;
+	double imgposX = 0;
+	double imgposY = 0;
+    BitmapEx  aRet = aBitmap;
+	double imgOldWidth = aRet.GetSizePixel().Width();
+	double imgOldHeight =aRet.GetSizePixel().Height();
+
+    Size aScaledSize;
+    if (imgOldWidth >= aStandardSize || imgOldHeight >= aStandardSize)
+	{
+		if (imgOldWidth >= imgOldHeight)
+		{
+			imgNewWidth = aStandardSize;
+			imgNewHeight = sal_Int32(imgOldHeight / (imgOldWidth / aStandardSize) + 0.5);
+			imgposX = 0;
+			imgposY = (aStandardSize - (imgOldHeight / (imgOldWidth / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+		else
+		{
+			imgNewHeight = aStandardSize;
+			imgNewWidth = sal_Int32(imgOldWidth / (imgOldHeight / aStandardSize) + 0.5);
+			imgposY = 0;
+			imgposX = (aStandardSize - (imgOldWidth / (imgOldHeight / aStandardSize) + 0.5)) / 2 + 0.5;
+		}
+
+		aScaledSize = Size( imgNewWidth, imgNewHeight );
+        aRet.Scale( aScaledSize, BMP_SCALE_INTERPOLATE );
+	}
+	else
+	{
+		imgposX = (aStandardSize - imgOldWidth) / 2 + 0.5;
+		imgposY = (aStandardSize - imgOldHeight) / 2 + 0.5;
+	}
+
+    Size aBmpSize = aRet.GetSizePixel();
+    Size aStdSize( aStandardSize, aStandardSize );
+    Rectangle aRect(aEmptyPoint, aStdSize );
+
+    VirtualDevice aVirDevice( *Application::GetDefaultDevice(), 0, 1 );
+	aVirDevice.SetOutputSizePixel( aStdSize );
+	aVirDevice.SetFillColor( COL_TRANSPARENT );
+    aVirDevice.SetLineColor( COL_TRANSPARENT );
+
+    //draw a rect into virDevice
+	aVirDevice.DrawRect( aRect );
+	Point aPointPixel( (long)imgposX, (long)imgposY );
+	aVirDevice.DrawBitmapEx( aPointPixel, aRet );
+	aRet = aVirDevice.GetBitmapEx( aEmptyPoint, aStdSize );
+
+	return aRet;
+}
 // ------------------------------------------------------------------
 
 SvStream& operator<<( SvStream& rOStm, const BitmapEx& rBitmapEx )
Index: vcl/source/gdi/bitmap2.cxx
===================================================================
--- vcl/source/gdi/bitmap2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/gdi/bitmap2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -49,6 +49,8 @@
 
 #define DIBCOREHEADERSIZE			( 12UL )
 #define DIBINFOHEADERSIZE			( sizeof( DIBInfoHeader ) )
+#define BITMAPINFOHEADER                        0x28
+
 #define SETPIXEL4( pBuf, nX, cChar )( (pBuf)[ (nX) >> 1 ] |= ( (nX) & 1 ) ? ( cChar ): (cChar) << 4 );
 
 // ----------------------
@@ -132,7 +134,7 @@
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader )
+BOOL Bitmap::Read( SvStream& rIStm, BOOL bFileHeader, BOOL bIsMSOFormat )
 {
 	const USHORT	nOldFormat = rIStm.GetNumberFormatInt();
 	const ULONG 	nOldPos = rIStm.Tell();
@@ -147,7 +149,7 @@
 			bRet = ImplReadDIB( rIStm, *this, nOffset );
 	}
 	else
-		bRet = ImplReadDIB( rIStm, *this, nOffset );
+		bRet = ImplReadDIB( rIStm, *this, nOffset, bIsMSOFormat );
 
 	if( !bRet )
 	{
@@ -164,14 +166,14 @@
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset )
+BOOL Bitmap::ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bIsMSOFormat )
 {
 	DIBInfoHeader	aHeader;
 	const ULONG 	nStmPos = rIStm.Tell();
 	BOOL			bRet = FALSE;
 	sal_Bool		bTopDown = sal_False;
 
-	if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
+	if( ImplReadDIBInfoHeader( rIStm, aHeader, bTopDown, bIsMSOFormat ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
 	{
 		const USHORT nBitCount( discretizeBitcount(aHeader.nBitCount) );
 
@@ -302,21 +304,37 @@
 
 // ------------------------------------------------------------------
 
-BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown )
+BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, sal_Bool bIsMSOFormat )
 {
 	// BITMAPINFOHEADER or BITMAPCOREHEADER
 	rIStm >> rHeader.nSize;
 
 	// BITMAPCOREHEADER
+	sal_Int16 nTmp16 = 0;
+	sal_uInt8 nTmp8 = 0;
 	if ( rHeader.nSize == DIBCOREHEADERSIZE )
 	{
-		sal_Int16 nTmp16;
 
 		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
 		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
 		rIStm >> rHeader.nPlanes;
 		rIStm >> rHeader.nBitCount;
 	}
+	else if ( bIsMSOFormat && ( rHeader.nSize == BITMAPINFOHEADER ) )
+	{
+		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
+		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
+		rIStm >> nTmp8; rHeader.nPlanes = nTmp8;
+		rIStm >> nTmp8; rHeader.nBitCount = nTmp8;
+		rIStm >> nTmp16; rHeader.nSizeImage = nTmp16;
+		rIStm >> nTmp16; rHeader.nCompression = nTmp16;
+		if ( !rHeader.nSizeImage ) // uncompressed?
+			rHeader.nSizeImage = ((rHeader.nWidth * rHeader.nBitCount + 31) & ~31) / 8 * rHeader.nHeight;
+		rIStm >> rHeader.nXPelsPerMeter;
+		rIStm >> rHeader.nYPelsPerMeter;
+		rIStm >> rHeader.nColsUsed;
+		rIStm >> rHeader.nColsImportant;
+	}
 	else
 	{
 		// unknown Header
Index: vcl/source/window/toolbox.cxx
===================================================================
--- vcl/source/window/toolbox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/window/toolbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -229,6 +229,22 @@
     }
     return width;
 }
+
+ButtonType determineButtonType( ImplToolItem* pItem, ButtonType defaultType )
+{
+    ButtonType tmpButtonType = defaultType;
+    ToolBoxItemBits nBits( pItem->mnBits & 0x300 );
+    if ( nBits & TIB_TEXTICON ) // item has custom setting
+    {
+        tmpButtonType = BUTTON_SYMBOLTEXT; 
+        if ( nBits == TIB_TEXT_ONLY )
+            tmpButtonType = BUTTON_TEXT; 
+        else if ( nBits == TIB_ICON_ONLY )
+            tmpButtonType = BUTTON_SYMBOL; 
+    }
+    return tmpButtonType;
+}
+
 // -----------------------------------------------------------------------
 
 void ToolBox::ImplUpdateDragArea( ToolBox *pThis )
@@ -1992,12 +2008,13 @@
                     bText = FALSE;
                 else
                     bText = TRUE;
-
+                ButtonType tmpButtonType = determineButtonType( &(*it), meButtonType ); // default to toolbox setting 
                 if ( bImage || bText )
                 {
+
                     it->mbEmptyBtn = FALSE;
 
-                    if ( meButtonType == BUTTON_SYMBOL )
+                    if ( tmpButtonType == BUTTON_SYMBOL )
                     {
                         // we're drawing images only
                         if ( bImage || !bText )
@@ -2011,7 +2028,7 @@
                             it->mbVisibleText = TRUE;
                         }
                     }
-                    else if ( meButtonType == BUTTON_TEXT )
+                    else if ( tmpButtonType == BUTTON_TEXT )
                     {
                         // we're drawing text only
                         if ( bText || !bImage )
@@ -3625,7 +3642,8 @@
     // determine what has to be drawn on the button: image, text or both
     BOOL bImage;
     BOOL bText;
-    pItem->DetermineButtonDrawStyle( meButtonType, bImage, bText );
+    ButtonType tmpButtonType = determineButtonType( pItem, meButtonType ); // default to toolbox setting 
+    pItem->DetermineButtonDrawStyle( tmpButtonType, bImage, bText );
 
     // compute output values
     long    nBtnWidth = aBtnSize.Width()-SMALLBUTTON_HSIZE;
Index: vcl/source/window/toolbox2.cxx
===================================================================
--- vcl/source/window/toolbox2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/window/toolbox2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -59,6 +59,8 @@
 
 #define TB_SEP_SIZE 			8
 
+ButtonType determineButtonType( ImplToolItem* pItem, ButtonType defaultType );
+
 // -----------------------------------------------------------------------
 
 ImplToolBoxPrivateData::ImplToolBoxPrivateData() :
Index: vcl/source/window/dialog.cxx
===================================================================
--- vcl/source/window/dialog.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/source/window/dialog.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -550,7 +550,14 @@
 {
     ImplDelData aDelData;
     ImplAddDel( &aDelData );
-    ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );
+	//liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	mnCancelClose = 0;
+	ImplCallEventListeners( VCLEVENT_WINDOW_CLOSE );	
+	if (mnCancelClose == 1)
+	{
+		return FALSE;
+	}
+	//liuchen 2009-7-22
     if ( aDelData.IsDelete() )
         return FALSE;
     ImplRemoveDel( &aDelData );
Index: vcl/inc/vcl/toolbox.hxx
===================================================================
--- vcl/inc/vcl/toolbox.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/inc/vcl/toolbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -124,6 +124,9 @@
 #define TIB_DROPDOWN            ((ToolBoxItemBits)0x0020)
 #define TIB_REPEAT              ((ToolBoxItemBits)0x0040)
 #define TIB_DROPDOWNONLY        ((ToolBoxItemBits)0x0080 | TIB_DROPDOWN)    // this button has only drop down functionality
+#define TIB_TEXT_ONLY           ((ToolBoxItemBits)0x0100)
+#define TIB_ICON_ONLY           ((ToolBoxItemBits)0x0200)
+#define TIB_TEXTICON            ((ToolBoxItemBits) TIB_TEXT_ONLY | TIB_ICON_ONLY )
 
 // -----------------
 // - ToolBox-Types -
Index: vcl/inc/vcl/bitmap.hxx
===================================================================
--- vcl/inc/vcl/bitmap.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/inc/vcl/bitmap.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -270,9 +270,9 @@
     SAL_DLLPRIVATE void                 ImplSetImpBitmap( ImpBitmap* pImpBmp );
     SAL_DLLPRIVATE void                 ImplAssignWithSize( const Bitmap& rBitmap );
 
-    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIB( SvStream& rIStm, Bitmap& rBmp, ULONG nOffset, BOOL bMSOFormat=FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBFileHeader( SvStream& rIStm, ULONG& rOffset );
-    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown );
+    SAL_DLLPRIVATE static BOOL          ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal_Bool& bTopDown, BOOL bMSOFormat = FALSE );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBPalette( SvStream& rIStm, BitmapWriteAccess& rAcc, BOOL bQuad );
     SAL_DLLPRIVATE static BOOL          ImplReadDIBBits( SvStream& rIStm, DIBInfoHeader& rHeader, BitmapWriteAccess& rAcc, sal_Bool bTopDown );
     SAL_DLLPRIVATE BOOL                 ImplWriteDIB( SvStream& rOStm, BitmapReadAccess& rAcc, BOOL bCompressed ) const;
@@ -767,7 +767,7 @@
 
 public:
 
-    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE );
+    BOOL                    Read( SvStream& rIStm, BOOL bFileHeader = TRUE, BOOL bMSOFormat = FALSE );
     BOOL                    Write( SvStream& rOStm, BOOL bCompressed = TRUE, BOOL bFileHeader = TRUE ) const;
 
     friend VCL_DLLPUBLIC SvStream&        operator>>( SvStream& rIStm, Bitmap& rBitmap );
Index: vcl/inc/vcl/dialog.hxx
===================================================================
--- vcl/inc/vcl/dialog.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/inc/vcl/dialog.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -56,6 +56,7 @@
 	BOOL			mbOldSaveBack;
 	BOOL			mbInClose;
 	BOOL			mbModalMode;
+	sal_Int8		mnCancelClose;  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
 
 	SAL_DLLPRIVATE void    ImplInitDialogData();
 	SAL_DLLPRIVATE void    ImplInitSettings();
@@ -93,6 +94,9 @@
 	virtual short	Execute();
 	BOOL			IsInExecute() const { return mbInExecute; }
 
+	sal_Int8		GetCloseFlag() const { return mnCancelClose; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+	void			SetCloseFlag( sal_Int8 nCancel ) { mnCancelClose = nCancel; }  //liuchen 2009-7-22, support Excel VBA UserForm_QueryClose event
+
     ////////////////////////////////////////
     // Dialog::Execute replacement API
 public:
Index: vcl/inc/vcl/bitmapex.hxx
===================================================================
--- vcl/inc/vcl/bitmapex.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/inc/vcl/bitmapex.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -385,6 +385,7 @@
 
 	friend VCL_DLLPUBLIC SvStream&	operator<<( SvStream& rOStm, const BitmapEx& rBitmapEx );
 	friend VCL_DLLPUBLIC SvStream&	operator>>( SvStream& rIStm, BitmapEx& rBitmapEx );
+	static BitmapEx AutoScaleBitmap(BitmapEx & aBitmap, const long aStandardSize);
 };
 
 #endif // _SV_BITMAPEX_HXX
Index: vcl/inc/vcl/menu.hxx
===================================================================
--- vcl/inc/vcl/menu.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ vcl/inc/vcl/menu.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -93,6 +93,8 @@
 #define MIB_POPUPSELECT 		((MenuItemBits)0x0020)
 // not in rsc/vclsrc.hxx because only a prelimitary solution
 #define MIB_NOSELECT 		    ((MenuItemBits)0x0040)
+#define MIB_ICON 		    ((MenuItemBits)0x0080)
+#define MIB_TEXT 		    ((MenuItemBits)0x0100)
 
 #define MENU_FLAG_NOAUTOMNEMONICS		0x0001
 #define MENU_FLAG_HIDEDISABLEDENTRIES	0x0002
Index: sc/sdi/cellsh.sdi
===================================================================
--- sc/sdi/cellsh.sdi	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/sdi/cellsh.sdi	(.../cws/vbasupportdev300)	(revision 277097)
@@ -60,6 +60,7 @@
 	SID_SBA_BRW_INSERT		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_SELECT_DB			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_SORT				[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
+	SID_DATA_FORM			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	FID_FILTER_OK			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_AUTO_FILTER			[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
 	SID_AUTOFILTER_HIDE		[ ExecMethod = ExecuteDB; StateMethod = GetDBState; ]
Index: sc/sdi/scalc.sdi
===================================================================
--- sc/sdi/scalc.sdi	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/sdi/scalc.sdi	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1601,6 +1601,31 @@
 ]
 
 //--------------------------------------------------------------------------
+SfxVoidItem DataForm SID_DATA_FORM
+()
+[
+	/* flags: */
+	AutoUpdate = FALSE,
+	Cachable = Cachable,
+	FastCall = FALSE,
+	HasCoreId = FALSE,
+	HasDialog = TRUE,
+	ReadOnlyDoc = TRUE,
+	Toggle = FALSE,
+	Container = FALSE,
+	RecordAbsolute = FALSE,
+	RecordPerSet;
+	Synchron;
+
+	/* config: */
+	AccelConfig = TRUE,
+	MenuConfig = TRUE,
+	StatusBarConfig = FALSE,
+	ToolBoxConfig = FALSE,
+	GroupId = GID_DATA;
+]
+
+//--------------------------------------------------------------------------
 SfxVoidItem DataSubTotals SID_SUBTOTALS
 ()
 [
@@ -6347,56 +6372,56 @@
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = FALSE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = TRUE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
+SfxVoidItem EditShapeHyperlink SID_DRAW_HLINK_EDIT
+()
+[
+   /* flags: */
+   AutoUpdate = FALSE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = TRUE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
+
 //   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
 
 //--------------------------------------------------------------------------
 // ISSUE66550_HLINK_FOR_SHAPES
-//SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
-//()
-//[
-//   /* flags: */
-//   AutoUpdate = TRUE,
-//   Cachable = Cachable,
-//   FastCall = TRUE,
-//   HasCoreId = FALSE,
-//   HasDialog = FALSE,
-//   ReadOnlyDoc = TRUE,
-//   Toggle = FALSE,
-//   Container = FALSE,
-//   RecordAbsolute = FALSE,
-//   RecordPerSet;
-//   Synchron;
-//
-//   /* config: */
-//   AccelConfig = TRUE,
-//   MenuConfig = FALSE,
-//   StatusBarConfig = FALSE,
-//   ToolBoxConfig = FALSE,
-//   GroupId = GID_DRAWING;
-//]
+SfxVoidItem DeleteShapeHyperlink SID_DRAW_HLINK_DELETE
+()
+[
+   /* flags: */
+   AutoUpdate = TRUE,
+   Cachable = Cachable,
+   FastCall = TRUE,
+   HasCoreId = FALSE,
+   HasDialog = FALSE,
+   ReadOnlyDoc = TRUE,
+   Toggle = FALSE,
+   Container = FALSE,
+   RecordAbsolute = FALSE,
+   RecordPerSet;
+   Synchron;
 
+   /* config: */
+   AccelConfig = TRUE,
+   MenuConfig = FALSE,
+   StatusBarConfig = FALSE,
+   ToolBoxConfig = FALSE,
+   GroupId = GID_DRAWING;
+]
+
 //--------------------------------------------------------------------------
 SfxVoidItem StandardTextAttributes SID_TEXT_STANDARD
 ()
Index: sc/sdi/drawsh.sdi
===================================================================
--- sc/sdi/drawsh.sdi	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/sdi/drawsh.sdi	(.../cws/vbasupportdev300)	(revision 277097)
@@ -229,9 +229,9 @@
     SID_FONTWORK_CHARACTER_SPACING_DIALOG	[ ExecMethod = ExecDrawFunc ; StateMethod = GetDrawFuncState ; ]
 
 // ISSUE66550_HLINK_FOR_SHAPES
-//    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
-//    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_EDIT             [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_DRAW_HLINK_DELETE           [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
+    SID_OPEN_HYPERLINK              [ ExecMethod = ExecDrawAttr; StateMethod = GetDrawFuncState; Export = FALSE; ]
 }
 
 
Index: sc/source/filter/excel/xltoolbar.cxx
===================================================================
--- sc/source/filter/excel/xltoolbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/filter/excel/xltoolbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,433 @@
+#include "xltoolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOExcelCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOExcelCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOExcelCommandConvertor::MSOExcelCommandConvertor()
+{
+/*
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+*/
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOExcelCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+
+CTBS::CTBS() : bSignature(0), bVersion(0), reserved1(0), reserved2(0), reserved3(0), ctb(0), ctbViews(0), ictbView(0)
+{
+}
+
+CTB::CTB() : nViews( 0 ), ectbid(0)
+{
+}
+
+CTB::CTB(sal_uInt16 nNum ) : nViews( nNum ), ectbid(0)
+{
+}
+
+bool CTB::Read( SvStream *pS )
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    tb.Read( pS );
+    for ( sal_uInt16 index = 0; index < nViews; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+    *pS >> ectbid;
+  
+    for ( sal_Int16 index = 0; index < tb.getcCL(); ++index )
+    {
+        TBC aTBC;
+        aTBC.Read( pS );
+        rTBC.push_back( aTBC ); 
+    }
+    return true;
+}
+
+void CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTB -- dump\n", nOffSet );
+    indent_printf( fp, "  nViews 0x%x\n", nViews);
+    tb.Print( fp );
+
+    std::vector<TBVisualData>::iterator visData_end = rVisualData.end();
+    sal_Int32 counter = 0;
+    for ( std::vector<TBVisualData>::iterator it = rVisualData.begin(); it != visData_end; ++it )
+    {
+        
+        indent_printf( fp, "  TBVisualData [%d]\n", counter++ );
+        Indent b;
+        it->Print( fp );
+    } 
+    indent_printf( fp, "  ectbid 0x%x\n", ectbid);
+    std::vector<TBC>::iterator it_end = rTBC.end();
+    counter = 0;
+    for ( std::vector<TBC>::iterator it = rTBC.begin(); it != it_end; ++it )
+    {
+        indent_printf( fp, "  TBC [%d]\n", counter++);
+        Indent c;
+        it->Print( fp );
+    }
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xMenuDesc, CustomToolBarImportHelper& helper )
+{
+    sal_Int32 index = 0;
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it, ++index )
+    {
+        if ( !it->ImportToolBarControl( rWrapper, xMenuDesc, helper, IsMenuToolbar() ) )
+            return false;
+    }
+    return true;
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        WString& name = tb.getName();
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif 
+    
+        bRes = true;
+    }
+    catch( uno::Exception& )
+    {
+       bRes = false; 
+    }
+    return bRes;
+}
+bool CTBS::Read( SvStream *pS )
+{
+    OSL_TRACE("CTBS::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> bSignature >> bVersion >> reserved1 >> reserved2 >> reserved3 >> ctb >> ctbViews >> ictbView;
+    return true;
+}
+
+void CTBS::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBS -- dump\n", nOffSet );
+
+    indent_printf( fp, "  bSignature 0x%x\n", bSignature);
+    indent_printf( fp, "  bVersion 0x%x\n", bVersion);
+
+    indent_printf( fp, "  reserved1 0x%x\n", reserved1 );
+    indent_printf( fp, "  reserved2 0x%x\n", reserved2 );
+    indent_printf( fp, "  reserved3 0x%x\n", reserved3 );
+
+    indent_printf( fp, "  ctb 0x%x\n", ctb );
+    indent_printf( fp, "  ctbViews 0x%x\n", ctbViews );
+    indent_printf( fp, "  ictbView 0x%x\n", ictbView );
+}
+
+TBC::TBC()
+{
+}
+
+bool 
+TBC::Read(SvStream *pS)
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    if ( !tbch.Read( pS ) )
+        return false;
+    sal_uInt16 tcid = tbch.getTcID();
+    sal_uInt8 tct = tbch.getTct();
+    if (  ( tcid != 0x0001 && tcid != 0x06CC && tcid != 0x03D8 && tcid != 0x03EC && tcid != 0x1051 ) && ( ( tct > 0 && tct < 0x0B ) || ( ( tct > 0x0B && tct < 0x10 ) || tct == 0x15 ) ) )
+    {
+        tbcCmd.reset( new TBCCmd );
+        if ( !  tbcCmd->Read( pS ) )
+            return false;
+    }
+    if ( tct != 0x16 )
+    {
+        tbcd.reset( new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+
+void
+TBC::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBC -- dump\n", nOffSet );
+    tbch.Print( fp );
+    if ( tbcCmd.get() )
+        tbcCmd->Print( fp );    
+    if ( tbcd.get() )
+        tbcd->Print( fp );    
+}
+
+bool TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuToolbar )
+{
+    // how to identify built-in-command ?
+//    bool bBuiltin = false;
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+/*
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+         
+        }
+*/
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuToolbar ) )
+            return false;
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                 if ( !pCustTB->ImportMenuTB( rWrapper, xMenuDesc, helper ) )
+                     return false;     
+                 if ( !bIsMenuToolbar ) 
+                 {
+                     if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                         return false;
+                 }
+                 else
+                 {
+                     beans::PropertyValue aProp;
+                     aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                     aProp.Value <<= xMenuDesc;
+                     props.push_back( aProp );
+                 }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+        }
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+void
+TBCCmd::Print(FILE* fp)
+{
+    Indent a;
+    indent_printf( fp, " TBCCmd -- dump\n" );
+    indent_printf( fp, "   cmdID 0x%x\n", cmdID );
+    indent_printf( fp, "   A ( fHideDrawing ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   B ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   cmdType 0x%x\n", cmdType );
+    indent_printf( fp, "   C ( reserved - ignored ) %s\n", A ? "true" : "false" );
+    indent_printf( fp, "   reserved3 0x%x\n", reserved3 );
+}
+
+bool TBCCmd::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCCmd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();    
+    *pS >> cmdID;
+    sal_uInt16 temp;
+    *pS >> temp;
+    OSL_TRACE("TBCmd temp = 0x%x", temp );
+    A = (temp & 0x8000 ) == 0x8000; 
+    B = (temp & 0x4000) == 0x4000; 
+    cmdType = ( temp & 0x3E00 ) >> 9;
+    C = ( temp & 0x100 ) == 0x100; 
+    reserved3 = ( temp & 0xFF ); 
+    return true;
+}
+
+CTBWrapper::CTBWrapper()
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+bool 
+CTBWrapper::Read( SvStream *pS)
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();   
+    if ( !ctbSet.Read( pS ) )
+        return false;
+    for ( sal_uInt16 index = 0; index < ctbSet.ctb; ++index )
+    {
+        CTB aCTB( ctbSet.ctbViews );
+        if ( !aCTB.Read( pS ) )
+            return false;
+        rCTB.push_back( aCTB ); 
+    }
+    return true;
+}
+
+void 
+CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] CTBWrapper -- dump\n", nOffSet );
+    ctbSet.Print( fp );
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        Indent b;
+        it->Print( fp );
+    } 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< CTB >::iterator it = rCTB.begin(); it != rCTB.end(); ++it )
+    {
+        if ( it->GetName().equals( sTBName ) )
+        {
+            pCTB = &(*it);
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    std::vector<CTB>::iterator it_end = rCTB.end();
+    for ( std::vector<CTB>::iterator it = rCTB.begin(); it != it_end; ++it )
+    {
+        // for each customtoolbar
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument" ) ) ) );
+        helper.setMSOCommandMap( new  MSOExcelCommandConvertor() );
+        // Ignore menu toolbars, excel doesn't ( afaics ) store
+        // menu customizations ( but you can have menus in a customtoolbar
+        // such menus will be dealt with when they are encountered 
+        // as part of importing the appropriate MenuSpecific toolbar control )
+
+
+        if ( !(*it).IsMenuToolbar() ) 
+        {
+            if ( !(*it).ImportCustomToolBar( *this, helper ) )
+                return false;
+        }
+    } 
+    return true;
+}
+
+
Index: sc/source/filter/excel/xecontent.cxx
===================================================================
--- sc/source/filter/excel/xecontent.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/xecontent.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -519,12 +519,17 @@
 {
     sal_uInt16 nXclCol = static_cast< sal_uInt16 >( maScPos.Col() );
     sal_uInt16 nXclRow = static_cast< sal_uInt16 >( maScPos.Row() );
-    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
+    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol;
+    WriteEmbeddedData( rStrm );
+}
 
-    rStrm   << nXclRow << nXclRow << nXclCol << nXclCol
-            << XclTools::maGuidStdLink
+void XclExpHyperlink::WriteEmbeddedData( XclExpStream& rStrm )
+{
+    rStrm << XclTools::maGuidStdLink
             << sal_uInt32( 2 )
             << mnFlags;
+
+    mxVarData->Seek( STREAM_SEEK_TO_BEGIN );
     rStrm.CopyFromStream( *mxVarData );
 }
 
Index: sc/source/filter/excel/xltoolbar.hxx
===================================================================
--- sc/source/filter/excel/xltoolbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/filter/excel/xltoolbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,95 @@
+#ifndef _XLTOOLBAR_HXX
+#define _XLTOOLBAR_HXX
+
+#include <svx/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class CTBWrapper;
+// hmm I don't normally use these packed structures
+// but.. hey always good to do something different
+class TBCCmd : public TBBase
+{
+public:
+    TBCCmd() : cmdID(0), A(0), B(0), cmdType(0), C(0), reserved3(0) {}
+    sal_uInt16 cmdID;
+    sal_uInt16 A:1;
+    sal_uInt16 B:1;
+    sal_uInt16 cmdType:5;
+    sal_uInt16 C:1;
+    sal_uInt16 reserved3:8;
+    bool Read( SvStream* pS );
+    void Print(FILE* fp);
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr<TBCCmd> tbcCmd; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool ImportToolBarControl( CTBWrapper&, const com::sun::star::uno::Reference< com::sun::star::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar );
+};
+ 
+class CTB : public TBBase
+{
+    sal_uInt16 nViews;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_uInt32 ectbid;
+    std::vector< TBC > rTBC;
+    bool ImportCustomToolBar_Impl( CTBWrapper&, CustomToolBarImportHelper& );
+public:
+    CTB();
+    CTB(sal_uInt16);
+    ~CTB(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+
+
+};
+
+class CTBS : public TBBase
+{
+public:
+    sal_uInt8 bSignature;
+    sal_uInt8 bVersion;
+    sal_uInt16 reserved1;
+    sal_uInt16 reserved2;
+    sal_uInt16 reserved3;
+    sal_uInt16 ctb;
+    sal_uInt16 ctbViews;
+    sal_uInt16 ictbView;
+    CTBS(const CTBS&);
+    CTBS& operator = ( const CTBS&);
+    CTBS();
+    ~CTBS(){}
+    void Print( FILE* );
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper : public TBBase
+{
+    CTBS ctbSet;
+
+    std::vector< CTB > rCTB; 
+
+public:
+    CTBWrapper();
+    ~CTBWrapper();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+};
+
+
+#endif //_XLTOOLBAR_HXX
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
--- sc/source/filter/excel/excimp8.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/excimp8.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -99,21 +99,27 @@
 #include "stlpool.hxx"
 #include "stlsheet.hxx"
 #include "detfunc.hxx"
+#include "macromgr.hxx"
 
 #include <com/sun/star/document/XDocumentProperties.hpp>
 #include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <basic/basmgr.hxx>
+#include <cppuhelper/component_context.hxx>
 
-
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <sfx2/app.hxx>
+#include "xltoolbar.hxx"
 using namespace com::sun::star;
 
 
 #define	INVALID_POS		0xFFFFFFFF
 
+// defined in docfunc.cxx ( really this needs a new name )
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule );
 
-
-
 ImportExcel8::ImportExcel8( XclImpRootData& rImpData, SvStream& rStrm ) :
-    ImportExcel( rImpData, rStrm )
+    ImportExcel( rImpData, rStrm ), mnTab(0)
 {
 	delete pFormConv;
 
@@ -236,9 +242,15 @@
         if( aName.Len() )
         {
             if( bWorkbookGlobals )
+            {
                 GetExtDocOptions().GetDocSettings().maGlobCodeName = aName;
+                GetDoc().SetCodeName( aName );
+            }
             else
+            {
                 GetExtDocOptions().AppendCodeName( aName );
+                GetDoc().SetCodeName( GetCurrScTab(), aName );
+            }
         }
 	}
 }
@@ -248,18 +260,9 @@
     GetSheetProtectBuffer().ReadOptions( aIn, GetCurrScTab() );
 }
 
-bool lcl_hasVBAEnabled()
-{
-	uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY);
-		// test if vba service is present
-	uno::Reference< uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY );
-	uno::Reference< uno::XInterface > xGlobals( xCtx->getValueByName( ::rtl::OUString::createFromAscii( "/singletons/ooo.vba.theGlobals") ), uno::UNO_QUERY );
-
-	return xGlobals.is();
-}
-
 void ImportExcel8::ReadBasic( void )
 {
+    //bHasBasic = TRUE;
     bHasBasic = TRUE;
 
     SfxObjectShell* pShell = GetDocShell();
@@ -273,13 +276,33 @@
         if( bLoadCode || bLoadStrg )
         {
             SvxImportMSVBasic aBasicImport( *pShell, *xRootStrg, bLoadCode, bLoadStrg );
-			bool bAsComment = !bLoadExecutable || !lcl_hasVBAEnabled();
-            aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, bAsComment );
+	    bool bAsComment = !bLoadExecutable;
+            aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA, AutoGeneratedCodeNames, bAsComment );
+            if ( !bAsComment )
+            {
+                GetObjectManager().SetOleNameOverrideInfo( aBasicImport.ControlNameForObjectId() );
+                ScDocument& rDoc = GetDoc();
+#if 1
+                // see if we have the XCB stream
+                SvStorageStreamRef xXCB = xRootStrg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "XCB" ) ), STREAM_STD_READ | STREAM_NOCREATE  );
+                if ( xXCB.Is()|| SVSTREAM_OK == xXCB->GetError() )
+                {
+                    CTBWrapper wrapper;
+                    if ( wrapper.Read( xXCB ) )
+                    {
+#if DEBUG
+                        wrapper.Print( stderr ); 
+#endif
+                        wrapper.ImportCustomToolBar( *pShell );
+                    }
+                }
+#endif
+
+            }
         }
     }
 }
 
-
 void ImportExcel8::EndSheet( void )
 {
     GetCondFormatManager().Apply();
@@ -289,6 +312,10 @@
 
 void ImportExcel8::PostDocLoad( void )
 {
+    // delay reading basic until sheet object ( codenames etc. ) are read
+
+    if ( bHasBasic ) 
+        ReadBasic();
     // #i11776# filtered ranges before outlines and hidden rows
     if( pExcRoot->pAutoFilterBuffer )
         pExcRoot->pAutoFilterBuffer->Apply();
Index: sc/source/filter/excel/makefile.mk
===================================================================
--- sc/source/filter/excel/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -106,7 +106,8 @@
 		$(SLO)$/xlstyle.obj					\
 		$(SLO)$/xltools.obj					\
 		$(SLO)$/xltracer.obj				\
-		$(SLO)$/xlview.obj
+		$(SLO)$/xlview.obj \
+		$(SLO)$/xltoolbar.obj \
 
 .IF "$(OS)$(COM)$(CPUNAME)"=="LINUXGCCSPARC"
 NOOPTFILES = \
@@ -154,7 +155,8 @@
 		$(SLO)$/xlpivot.obj					\
 		$(SLO)$/xlroot.obj					\
 		$(SLO)$/xlstyle.obj					\
-		$(SLO)$/xlview.obj
+		$(SLO)$/xlview.obj \
+		$(SLO)$/xltoolbar.obj \
 
 # --- Targets -------------------------------------------------------
 
Index: sc/source/filter/excel/xistyle.cxx
===================================================================
--- sc/source/filter/excel/xistyle.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/xistyle.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -68,10 +68,70 @@
 #include "root.hxx"
 #include "colrowst.hxx"
 
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
+typedef ::std::vector< ColorData > ColorDataVec;
+
+class PaletteIndex : public XIndexAccess_BASE
+{
+public:
+    PaletteIndex( const ColorDataVec& rColorDataTable ) : maColorData( rColorDataTable ) {}
+
+    // Methods XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
+    {
+         return  maColorData.size();
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        //--Index;  // apparently the palette is already 1 based
+        return uno::makeAny( sal_Int32( maColorData[ Index ] ) );
+    }
+
+    // Methods XElementAcess
+    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (sal_Int32*)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
+    {
+        return (maColorData.size() > 0);
+    }
+
+private:
+    ColorDataVec        maColorData; 
+};
+
+void
+XclImpPalette::ExportPalette()
+{
+    if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
+    {
+        // copy values in color palette
+        sal_Int16 nColors =  maColorTable.size();
+        ColorDataVec aColors;
+        aColors.resize( nColors );
+        for( sal_uInt16 nIndex = 0; nIndex < nColors; ++nIndex )
+            aColors[ nIndex ] = GetColorData( nIndex );
+
+        uno::Reference< beans::XPropertySet > xProps( pDocShell->GetModel(), uno::UNO_QUERY );
+        if ( xProps.is() )
+        {
+            uno::Reference< container::XIndexAccess > xIndex( new PaletteIndex( aColors ) ); 
+            xProps->setPropertyValue( CREATE_OUSTRING("ColorPalette"), uno::makeAny( xIndex ) ); 
+        }
+    }
+            
+}
 // PALETTE record - color information =========================================
 
 XclImpPalette::XclImpPalette( const XclImpRoot& rRoot ) :
-    XclDefaultPalette( rRoot )
+    XclDefaultPalette( rRoot ), mrRoot( rRoot )
 {
 }
 
@@ -105,6 +165,7 @@
         rStrm >> aColor;
         maColorTable[ nIndex ] = aColor.GetColor();
     }
+    ExportPalette();
 }
 
 // FONT record - font information =============================================
Index: sc/source/filter/excel/xeescher.cxx
===================================================================
--- sc/source/filter/excel/xeescher.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/xeescher.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -66,6 +66,9 @@
 #include "xelink.hxx"
 #include "xename.hxx"
 #include "xestyle.hxx"
+#include "userdat.hxx"
+#include "drwlayer.hxx"
+#include "svx/unoapi.hxx"
 
 #include <oox/core/tokens.hxx>
 
@@ -333,7 +336,7 @@
 
 XclExpTbxControlObj::XclExpTbxControlObj( const XclExpRoot& rRoot, Reference< XShape > xShape ) :
     XclObj( rRoot, EXC_OBJTYPE_UNKNOWN, true ),
-    XclExpControlHelper( rRoot ),
+    XclMacroHelper( rRoot ),
     mnHeight( 0 ),
     mnState( 0 ),
     mnLineCount( 0 ),
@@ -583,6 +586,8 @@
 
 bool XclExpTbxControlObj::SetMacroLink( const ScriptEventDescriptor& rEvent )
 {
+    return XclMacroHelper::SetMacroLink( rEvent, meEventType );
+/*
     String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, meEventType );
     if( aMacroName.Len() )
     {
@@ -592,6 +597,7 @@
         return true;
     }
     return false;
+*/
 }
 
 void XclExpTbxControlObj::WriteSubRecs( XclExpStream& rStrm )
@@ -730,12 +736,6 @@
     }
 }
 
-void XclExpTbxControlObj::WriteMacroSubRec( XclExpStream& rStrm )
-{
-    if( mxMacroLink.is() )
-        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
-}
-
 void XclExpTbxControlObj::WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId )
 {
     if( const XclTokenArray* pCellLink = GetCellLinkTokArr() )
@@ -764,6 +764,7 @@
 
 #endif
 
+
 // ----------------------------------------------------------------------------
 
 XclExpChartObj::XclExpChartObj( const XclExpRoot& rRoot, Reference< XShape > xShape ) :
@@ -909,6 +910,7 @@
     }
 }
 
+
 void XclExpNote::WriteBody( XclExpStream& rStrm )
 {
     // BIFF5/BIFF7 is written separately
@@ -945,6 +947,70 @@
 
 // ============================================================================
 
+XclMacroHelper::XclMacroHelper( const XclExpRoot& rRoot ) :
+    XclExpControlHelper( rRoot )
+{
+}
+
+XclMacroHelper::~XclMacroHelper()
+{
+}
+
+void XclMacroHelper::WriteMacroSubRec( XclExpStream& rStrm )
+{
+    if( mxMacroLink.is() )
+        WriteFormulaSubRec( rStrm, EXC_ID_OBJMACRO, *mxMacroLink );
+}
+
+bool 
+XclMacroHelper::SetMacroLink( const ScriptEventDescriptor& rEvent, const XclTbxEventType& nEventType )
+{
+    String aMacroName = XclControlHelper::ExtractFromMacroDescriptor( rEvent, nEventType );
+    if( aMacroName.Len() )
+    {
+        return SetMacroLink( aMacroName );
+    }
+    return false;
+}
+
+bool
+XclMacroHelper::SetMacroLink( const String& rMacroName )
+{
+    OSL_TRACE("SetMacroLink( macroname:=%s )", rtl::OUStringToOString( rMacroName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( rMacroName.Len() )
+    {
+        sal_uInt16 nExtSheet = GetLocalLinkManager().FindExtSheet( EXC_EXTSH_OWNDOC );
+        sal_uInt16 nNameIdx = GetNameManager().InsertMacroCall( rMacroName, true, false );
+        mxMacroLink = GetFormulaCompiler().CreateNameXFormula( nExtSheet, nNameIdx );
+        return true;
+    }
+    return false;
+}
+
+XclExpShapeObj::XclExpShapeObj( const XclExpRoot& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape ) : 
+    XclObjAny( rRoot ),
+    XclMacroHelper( rRoot )
+{
+    if( SdrObject* pSdrObj = ::GetSdrObjectFromXShape( xShape ) )
+    {
+        ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pSdrObj );
+        if ( pInfo && pInfo->GetMacro().getLength() )
+            SetMacroLink( XclControlHelper::GetXclMacroName( pInfo->GetMacro() ) ); 
+    }
+}
+
+XclExpShapeObj::~XclExpShapeObj()
+{
+}
+
+void XclExpShapeObj::WriteSubRecs( XclExpStream& rStrm )
+{
+    XclObjAny::WriteSubRecs( rStrm );
+    WriteMacroSubRec( rStrm );
+}
+
+// ============================================================================
+
 XclExpComments::XclExpComments( SCTAB nTab, XclExpRecordList< XclExpNote >& rNotes )
     : mnTab( nTab ), mrNotes( rNotes )
 {
Index: sc/source/filter/excel/xiescher.cxx
===================================================================
--- sc/source/filter/excel/xiescher.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/xiescher.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -116,6 +116,8 @@
 #include "xipage.hxx"
 #include "xichart.hxx"
 #include "xicontent.hxx"
+#include "scextopt.hxx"
+
 #include "namebuff.hxx"
 
 using ::rtl::OUString;
@@ -399,11 +401,16 @@
 
 String XclImpDrawObjBase::GetObjName() const
 {
+    String sName( GetObjectManager().GetOleNameOverride( GetObjId() ) );
+  
+    
     /*  #118053# #i51348# Always return a non-empty name. Create English
         default names depending on the object type. This is not implemented as
         virtual functions in derived classes, as class type and object type may
         not match. */
-    return (maObjName.Len() > 0) ? maObjName : GetObjectManager().GetDefaultObjName( *this );
+    if ( sName.Len() == 0 )
+        sName = ( (maObjName.Len() > 0) ? maObjName : GetObjectManager().GetDefaultObjName( *this ) );
+    return sName;
 }
 
 bool XclImpDrawObjBase::IsValidSize( const Rectangle& rAnchorRect ) const
@@ -483,20 +490,15 @@
     }
 
     // macro and hyperlink
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-    if( mbSimpleMacro && ((maMacroName.Len() > 0) || (maHyperlink.getLength() > 0)) )
+    if( mbSimpleMacro && ((maMacroName.Len() > 0) ||
+ (maHyperlink.Len() > 0)) )
     {
         if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
         {
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ) );
+            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName, GetDocShell() ) );
             pInfo->SetHlink( maHyperlink );
         }
     }
-#else
-    if( mbSimpleMacro && (maMacroName.Len() > 0) )
-        if( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( &rSdrObj, TRUE ) )
-            pInfo->SetMacro( XclControlHelper::GetScMacroName( maMacroName ) );
-#endif
 
     // call virtual function for object type specific processing
     DoProcessSdrObj( rSdrObj );
@@ -1686,22 +1688,15 @@
     return xSdrObj.release();
 }
 
-void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+void XclImpControlHelper::ApplySheetLinkProps() const
 {
+
     Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
     if( !xCtrlModel.is() )
         return;
-
     ScfPropertySet aPropSet( xCtrlModel );
 
-    // #118053# #i51348# set object name at control model
-    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
-
-    // control visible and printable?
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
-    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
-
-    // sheet links
+   // sheet links
     if( SfxObjectShell* pDocShell = mrRoot.GetDocShell() )
     {
         Reference< XMultiServiceFactory > xFactory( pDocShell->GetModel(), UNO_QUERY );
@@ -1764,7 +1759,26 @@
             }
         }
     }
+}
 
+void XclImpControlHelper::ProcessControl( const XclImpDrawObjBase& rDrawObj ) const
+{
+    Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( mxShape );
+    if( !xCtrlModel.is() )
+        return;
+
+    ApplySheetLinkProps();
+
+    ScfPropertySet aPropSet( xCtrlModel );
+
+    // #118053# #i51348# set object name at control model
+    aPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), rDrawObj.GetObjName() );
+
+    // control visible and printable?
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), rDrawObj.IsVisible() );
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), rDrawObj.IsPrintable() );
+
+ 
     // virtual call for type specific processing
     DoProcessControl( aPropSet );
 }
@@ -1858,7 +1872,7 @@
 
 bool XclImpTbxObjBase::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor ) const
 {
-    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName() );
+    return XclControlHelper::FillMacroDescriptor( rDescriptor, DoGetEventType(), GetMacroName(), GetDocShell() );
 }
 
 void XclImpTbxObjBase::ConvertFont( ScfPropertySet& rPropSet ) const
@@ -2095,6 +2109,45 @@
 {
     XclImpCheckBoxObj::DoProcessControl( rPropSet );
     // TODO: grouping
+    XclImpOptionButtonObj* pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), mnNextInGroup ) ).get() );
+    if ( ( pTbxObj && pTbxObj->mnFirstInGroup ) )
+    {
+        // Group has terminated
+        // traverse each RadioButton in group and 
+        //     a) apply the groupname 
+        //     b) propagate the linked cell from the lead radiobutton
+        //     c) apply the correct Ref value
+        XclImpOptionButtonObj* pLeader = pTbxObj;
+ ;
+        sal_Int32 nRefVal = 1;
+        OSL_TRACE( "0x%x start group ", pLeader->GetObjId().mnObjId );
+        do 
+        {
+           
+            Reference< XControlModel > xCtrlModel = XclControlHelper::GetControlModel( pTbxObj->mxShape );
+            if ( xCtrlModel.is() )
+            {
+                ScfPropertySet aProps( xCtrlModel );
+                rtl::OUString sGroupName = rtl::OUString::valueOf( static_cast< sal_Int32 >( pLeader->GetDffShapeId() ) );
+
+                aProps.SetStringProperty( CREATE_OUSTRING( "GroupName" ), sGroupName );
+                aProps.SetStringProperty( CREATE_OUSTRING( "RefValue" ), rtl::OUString::valueOf( nRefVal++ ) );
+                if ( pLeader->HasCellLink() && !pTbxObj->HasCellLink() )
+                {
+                    // propagate cell link info
+                    pTbxObj->mxCellLink.reset( new ScAddress( *pLeader->mxCellLink.get() ) );                
+                    pTbxObj->ApplySheetLinkProps();
+                }
+                pTbxObj = dynamic_cast< XclImpOptionButtonObj* >( GetObjectManager().FindDrawObj( XclObjId( GetScTab(), pTbxObj->mnNextInGroup ) ).get() );
+            }
+            else
+                pTbxObj = NULL;
+        } while ( pTbxObj && !( pTbxObj->mnFirstInGroup == 1 ) );
+    }
+    else
+    {
+        // not the leader? try and find it
+    }
 }
 
 OUString XclImpOptionButtonObj::DoGetServiceName() const
@@ -3036,6 +3089,23 @@
 {
 }
 
+String XclImpObjectManager::GetOleNameOverride( const XclObjId& nObjId )
+{
+    String sOleName; 
+    String sCodeName = GetExtDocOptions().GetCodeName( nObjId.mnScTab );
+    
+    CodeNameToCntrlObjIdInfo::iterator it = maOleCtrlNameOverride.find( sCodeName );
+    if ( it != maOleCtrlNameOverride.end() )
+    {
+        CntrlObjIdToName::iterator it_id = it->second.find( nObjId.mnObjId );
+        if ( it_id != it->second.end() )
+        {
+            sOleName = it_id->second;
+        }
+    }
+    return sOleName;
+}
+
 void XclImpDffManager::StartProgressBar( sal_Size nProgressSize )
 {
     mxProgress.reset( new ScfProgressBar( GetDocShell(), STR_PROGRESS_CALCULATING ) );
@@ -3511,27 +3581,27 @@
     XclImpRoot( rRoot )
 {
     maDefObjNames[ EXC_OBJTYPE_GROUP ]          = CREATE_STRING( "Group" );
-    maDefObjNames[ EXC_OBJTYPE_LINE ]           = CREATE_STRING( "Line" );
-    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = CREATE_STRING( "Rectangle" );
-    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = CREATE_STRING( "Oval" );
+    maDefObjNames[ EXC_OBJTYPE_LINE ]           = ScGlobal::GetRscString( STR_SHAPE_LINE );
+    maDefObjNames[ EXC_OBJTYPE_RECTANGLE ]      = ScGlobal::GetRscString( STR_SHAPE_RECTANGLE );
+    maDefObjNames[ EXC_OBJTYPE_OVAL ]           = ScGlobal::GetRscString( STR_SHAPE_OVAL );
     maDefObjNames[ EXC_OBJTYPE_ARC ]            = CREATE_STRING( "Arc" );
     maDefObjNames[ EXC_OBJTYPE_CHART ]          = CREATE_STRING( "Chart" );
     maDefObjNames[ EXC_OBJTYPE_TEXT ]           = CREATE_STRING( "Text" );
-    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         = CREATE_STRING( "Button" );
+    maDefObjNames[ EXC_OBJTYPE_BUTTON ]         =  ScGlobal::GetRscString( STR_FORM_BUTTON );
     maDefObjNames[ EXC_OBJTYPE_PICTURE ]        = CREATE_STRING( "Picture" );
     maDefObjNames[ EXC_OBJTYPE_POLYGON ]        = CREATE_STRING( "Freeform" );
-    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = CREATE_STRING( "Check Box" );
-    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = CREATE_STRING( "Option Button" );
+    maDefObjNames[ EXC_OBJTYPE_CHECKBOX ]       = ScGlobal::GetRscString( STR_FORM_CHECKBOX ); 
+    maDefObjNames[ EXC_OBJTYPE_OPTIONBUTTON ]   = ScGlobal::GetRscString( STR_FORM_OPTIONBUTTON );
     maDefObjNames[ EXC_OBJTYPE_EDIT ]           = CREATE_STRING( "Edit Box" );
-    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = CREATE_STRING( "Label" );
+    maDefObjNames[ EXC_OBJTYPE_LABEL ]          = ScGlobal::GetRscString( STR_FORM_LABEL );
     maDefObjNames[ EXC_OBJTYPE_DIALOG ]         = CREATE_STRING( "Dialog Frame" );
-    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = CREATE_STRING( "Spinner" );
-    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = CREATE_STRING( "Scroll Bar" );
-    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = CREATE_STRING( "List Box" );
-    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = CREATE_STRING( "Group Box" );
-    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = CREATE_STRING( "Drop Down" );
+    maDefObjNames[ EXC_OBJTYPE_SPIN ]           = ScGlobal::GetRscString( STR_FORM_SPINNER );
+    maDefObjNames[ EXC_OBJTYPE_SCROLLBAR ]      = ScGlobal::GetRscString( STR_FORM_SCROLLBAR );
+    maDefObjNames[ EXC_OBJTYPE_LISTBOX ]        = ScGlobal::GetRscString( STR_FORM_LISTBOX );
+    maDefObjNames[ EXC_OBJTYPE_GROUPBOX ]       = ScGlobal::GetRscString( STR_FORM_GROUPBOX );
+    maDefObjNames[ EXC_OBJTYPE_DROPDOWN ]       = ScGlobal::GetRscString( STR_FORM_DROPDOWN );
     maDefObjNames[ EXC_OBJTYPE_NOTE ]           = CREATE_STRING( "Comment" );
-    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = CREATE_STRING( "AutoShape" );
+    maDefObjNames[ EXC_OBJTYPE_DRAWING ]        = ScGlobal::GetRscString( STR_SHAPE_AUTOSHAPE );
 }
 
 XclImpObjectManager::~XclImpObjectManager()
Index: sc/source/filter/excel/read.cxx
===================================================================
--- sc/source/filter/excel/read.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/read.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -804,6 +804,12 @@
     ::std::auto_ptr< ScfSimpleProgressBar > pProgress( new ScfSimpleProgressBar(
         aIn.GetSvStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
 
+    bool bSheetHasCodeName = false;
+
+    std::vector< String > CodeNames;
+
+    std::vector < SCTAB > nTabsWithNoCodeName;
+
     while( eAkt != EXC_STATE_END )
 	{
 		aIn.StartNextRecord();
@@ -871,6 +877,7 @@
                         // #i62752# possible to have BIFF8 sheet without globals
                         NeueTabelle();
                         eAkt = EXC_STATE_SHEET_PRE;  // Shrfmla Prefetch, Row-Prefetch
+                        bSheetHasCodeName = false; // reset
                         aIn.StoreGlobalPosition();
                     }
                 }
@@ -945,7 +952,8 @@
 					case 0x22:	Rec1904(); break;		// 1904			[ 2345   ]
 					case 0x56:	Builtinfmtcnt(); break;	// BUILTINFMTCNT[  34    ]
 					case 0x8D:	Hideobj(); break;		// HIDEOBJ		[  345   ]
-					case 0xD3:	ReadBasic(); break;
+					case 0xD3:	/*ReadBasic()*/bHasBasic = true; break;
+//					case 0xD3:	ReadBasic(); break;
                     case 0xDE:  Olesize(); break;
 					case 0x01BA: Codename( TRUE ); break;
 
@@ -1042,9 +1050,30 @@
                     case EXC_ID3_DIMENSIONS:    ReadDimensions();                       break;
 
                     case 0x0A:                          // EOF          [ 2345   ]
+                    {
                         eAkt = EXC_STATE_SHEET;
+                        String sName;
+                        GetDoc().GetName( GetCurrScTab(), sName );
+                        if ( !bSheetHasCodeName )
+                        {
+                            nTabsWithNoCodeName.push_back( GetCurrScTab() );
+                            OSL_TRACE("No Codename for %d", GetCurrScTab() );
+                        }
+                        else
+                        {
+                            String sCodeName;
+                            GetDoc().GetCodeName( GetCurrScTab(), sCodeName );
+                            OSL_TRACE("Have CodeName %s for SheetName %s",
+                                rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                            CodeNames.push_back( sCodeName );
+                        }
+
+                        bSheetHasCodeName = false; // reset
+
+
                         aIn.SeekGlobalPosition();         // und zurueck an alte Position
                         break;
+                    }
                     case 0x12:  SheetProtect(); break;
                     case 0x13:  SheetPassword(); break;
                     case 0x42:  Codepage(); break;      // CODEPAGE     [ 2345   ]
@@ -1056,7 +1085,7 @@
                     case 0x9B:  FilterMode(); break;    // FILTERMODE
                     case 0x9D:  AutoFilterInfo(); break;// AUTOFILTERINFO
                     case 0x9E:  AutoFilter(); break;    // AUTOFILTER
-                    case 0x01BA: Codename( FALSE ); break;
+                    case 0x01BA: Codename( FALSE ); bSheetHasCodeName = true; break;
                     case 0x0208: Row34(); break;        // ROW          [  34    ]
                     case 0x0021:
                     case 0x0221: Array34(); break;      // ARRAY        [  34    ]
@@ -1162,6 +1191,42 @@
 
     if( eLastErr == eERR_OK )
     {
+        // In some strange circumstances a the codename might be missing
+        // # Create any missing Sheet CodeNames
+        std::vector < SCTAB >::iterator it_end = nTabsWithNoCodeName.end();
+        for ( std::vector < SCTAB >::iterator it = nTabsWithNoCodeName.begin(); it != it_end; ++it )
+        {
+            bool bGotCodeName = false;
+            SCTAB nTab = 1;
+            OSL_TRACE("Trying to find suitable codename for %d", *it );
+            while ( true )
+            {
+                String sTmpName( RTL_CONSTASCII_USTRINGPARAM("Sheet" ) );
+                sTmpName += String::CreateFromInt32( sal_Int32(nTab++) );
+                std::vector< String >::iterator codeName_It = CodeNames.begin();
+                std::vector< String >::iterator codeName_It_end = CodeNames.end();
+                // search for codename
+                for ( ; codeName_It != codeName_It_end; ++codeName_It )
+                {
+                    if ( *codeName_It == sTmpName )
+                        break;
+                }
+
+                if ( codeName_It == codeName_It_end ) // generated codename not found
+                {
+                    OSL_TRACE("Using generated codename %s", rtl::OUStringToOString( sTmpName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    // Set new codename
+                    GetDoc().SetCodeName( *it, sTmpName );
+                    // Record newly used codename
+                    CodeNames.push_back( sTmpName );
+                    // Record those we have created so they can be created in
+                    // basic
+                    AutoGeneratedCodeNames.push_back( sTmpName );
+                    break;
+                }
+            }
+            
+        }
         // #i45843# Convert pivot tables before calculation, so they are available
         // for the GETPIVOTDATA function.
         if( GetBiff() == EXC_BIFF8 )
Index: sc/source/filter/excel/xlescher.cxx
===================================================================
--- sc/source/filter/excel/xlescher.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/excel/xlescher.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,7 +38,15 @@
 #include "document.hxx"
 #include "xistream.hxx"
 #include "xlescher.hxx"
+#include "globstr.hrc"
 
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/basmgr.hxx>
+#include <svx/msvbahelper.hxx>
+
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::UNO_QUERY;
@@ -301,10 +309,16 @@
 #define EXC_MACRONAME_PRE "vnd.sun.star.script:Standard."
 #define EXC_MACRONAME_SUF "?language=Basic&location=document"
 
-OUString XclControlHelper::GetScMacroName( const String& rXclMacroName )
+OUString XclControlHelper::GetScMacroName( const String& rXclMacroName, SfxObjectShell* pDocShell )
 {
+    String sTmp( rXclMacroName );
     if( rXclMacroName.Len() > 0 )
-        return CREATE_OUSTRING( EXC_MACRONAME_PRE ) + rXclMacroName + CREATE_OUSTRING( EXC_MACRONAME_SUF );
+    {
+        ooo::vba::VBAMacroResolvedInfo aMacro = ooo::vba::resolveVBAMacro( pDocShell, rXclMacroName, false );
+        if ( aMacro.IsResolved() )
+            return ooo::vba::makeMacroURL( aMacro.ResolvedMacro() );
+
+    }
     return OUString();
 }
 
@@ -338,14 +352,14 @@
 #define EXC_MACROSCRIPT "Script"
 
 bool XclControlHelper::FillMacroDescriptor( ScriptEventDescriptor& rDescriptor,
-        XclTbxEventType eEventType, const String& rXclMacroName )
+        XclTbxEventType eEventType, const String& rXclMacroName, SfxObjectShell* pShell )
 {
     if( rXclMacroName.Len() > 0 )
     {
         rDescriptor.ListenerType = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcListenerType );
         rDescriptor.EventMethod = OUString::createFromAscii( spTbxListenerData[ eEventType ].mpcEventMethod );
         rDescriptor.ScriptType = CREATE_OUSTRING( EXC_MACROSCRIPT );
-        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName );
+        rDescriptor.ScriptCode = GetScMacroName( rXclMacroName, pShell );
         return true;
     }
     return false;
Index: sc/source/filter/xml/xmlexprt.cxx
===================================================================
--- sc/source/filter/xml/xmlexprt.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/xml/xmlexprt.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -3126,7 +3126,34 @@
 		}
 	}
 	if (!bIsChart)
+	{
+		// #i66550 HLINK_FOR_SHAPES
+		rtl::OUString sHlink;
+		uno::Reference< beans::XPropertySet > xProps( xShape, uno::UNO_QUERY );
+		if ( xProps.is() )
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_HYPERLINK ) ) ) >>= sHlink;
+
+		std::auto_ptr< SvXMLElementExport > pDrawA;
+		// enlose shapes with <draw:a> element only if sHlink contains something
+		if ( sHlink.getLength() > 0 )
+		{
+			// need to get delete the attributes that are pre-loaded
+			// for the shape export ( otherwise they will become 	
+			// attributes of the draw:a element ) This *shouldn't* 
+			// affect performance adversely as there are only a 
+			// couple of attributes involved
+			uno::Reference< xml::sax::XAttributeList > xSaveAttribs( new  SvXMLAttributeList( GetAttrList() ) );
+			ClearAttrList();
+			// Add Hlink	
+			AddAttribute( XML_NAMESPACE_XLINK, XML_TYPE, XML_SIMPLE );
+			AddAttribute( XML_NAMESPACE_XLINK, XML_HREF, sHlink);
+			pDrawA.reset( new SvXMLElementExport( *this, XML_NAMESPACE_DRAW, XML_A, sal_False, sal_False ) );
+			// Attribute list has been cleared by previous operation
+			// re-add pre-loaded attributes
+			AddAttributeList( xSaveAttribs );
+		}
 		GetShapeExport()->exportShape(xShape, SEF_DEFAULT, pPoint);
+	}
 	IncrementProgressBar(sal_False);
 }
 
Index: sc/source/filter/xcl97/xcl97esc.cxx
===================================================================
--- sc/source/filter/xcl97/xcl97esc.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/xcl97/xcl97esc.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -57,6 +57,9 @@
 #include "global.hxx"
 #include "document.hxx"
 #include "drwlayer.hxx"
+#include "xecontent.hxx"
+#include <svx/flditem.hxx>
+#include "userdat.hxx"
 #include "xcl97rec.hxx"
 #include "xehelper.hxx"
 #include "xechart.hxx"
@@ -232,7 +235,8 @@
         {
             // #107540# ignore permanent note shapes
             // #i12190# do not ignore callouts (do not filter by object type ID)
-            pCurrXclObj = new XclObjAny( GetRoot() );   // just a metafile
+            pCurrXclObj = ShapeInteractionHelper::CreateShapeObj( GetRoot(), rShape );
+            ShapeInteractionHelper::PopulateShapeInteractionInfo( GetRoot(), rShape, *pCurrAppData );
         }
 	}
 	if ( pCurrXclObj )
@@ -345,6 +349,7 @@
 		delete pCurrAppData->GetClientAnchor();
 //		delete pCurrAppData->GetClientData();
 		delete pCurrAppData->GetClientTextbox();
+		delete pCurrAppData->GetInteractionInfo();
 		delete pCurrAppData;
 	}
 }
@@ -576,4 +581,40 @@
     pXclObj->SetText( GetRoot(), rTextObj );
 }
 
+XclExpShapeObj* 
+ShapeInteractionHelper::CreateShapeObj(const XclExpRoot& rRoot, const Reference< XShape >& xShape )
+{
+    return new XclExpShapeObj( rRoot, xShape );
+}
 
+void
+ShapeInteractionHelper::PopulateShapeInteractionInfo(const XclExpRoot& rRoot, const Reference< XShape >& xShape, EscherExHostAppData& rHostAppData )
+{
+   try
+   {
+      SvMemoryStream* pMemStrm = NULL;
+      rtl::OUString sHyperLink;
+      rtl::OUString sMacro;
+      if ( ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( ::GetSdrObjectFromXShape( xShape ) ) )
+      {
+         sHyperLink = pInfo->GetHlink();      
+         sMacro = pInfo->GetMacro();
+      }
+      if (  sHyperLink.getLength() > 0 )
+      {
+         pMemStrm = new SvMemoryStream();
+         XclExpStream tmpStream( *pMemStrm, rRoot );
+         ScAddress dummyAddress;
+         SvxURLField aUrlField;
+         aUrlField.SetURL( sHyperLink );
+         XclExpHyperlink hExpHlink( rRoot, aUrlField, dummyAddress );
+         hExpHlink.WriteEmbeddedData( tmpStream );
+      }
+      if ( ( sHyperLink.getLength() > 0 ) || ( sMacro.getLength() > 0 ) )
+          rHostAppData.SetInteractionInfo( new InteractionInfo( pMemStrm, true ) );
+   }
+   catch( Exception& )
+   {
+   }
+}
+
Index: sc/source/filter/inc/xlescher.hxx
===================================================================
--- sc/source/filter/inc/xlescher.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xlescher.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -432,7 +432,8 @@
                         GetControlModel( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
 
     /** Returns the Calc macro name from an Excel macro name. */
-    static ::rtl::OUString GetScMacroName( const String& rXclMacroName );
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName, SfxObjectShell* pShell = NULL );
+
     /** Returns the Excel macro name from a Calc macro name. */
     static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
 
@@ -440,7 +441,7 @@
     static bool         FillMacroDescriptor(
                             ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
                             XclTbxEventType eEventType,
-                            const String& rXclMacroName );
+                            const String& rXclMacroName, SfxObjectShell* pShell = NULL );
     /** Tries to extract an Excel macro name from the passed macro descriptor. */
     static String       ExtractFromMacroDescriptor(
                             const ::com::sun::star::script::ScriptEventDescriptor& rDescriptor,
Index: sc/source/filter/inc/xecontent.hxx
===================================================================
--- sc/source/filter/inc/xecontent.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xecontent.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -116,6 +116,8 @@
     inline const String* GetRepr() const { return mxRepr.get(); }
 
     virtual void        SaveXml( XclExpXmlStream& rStrm );
+
+    virtual void        WriteEmbeddedData( XclExpStream& rStrm );
 private:
     /** Builds file name from the passed file URL. Tries to convert to relative file name.
         @param rnLevel  (out-param) The parent directory level.
Index: sc/source/filter/inc/xcl97rec.hxx
===================================================================
--- sc/source/filter/inc/xcl97rec.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xcl97rec.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -285,7 +285,7 @@
 
 class XclObjAny : public XclObj
 {
-private:
+protected:
     virtual void                WriteSubRecs( XclExpStream& rStrm );
 
 public:
Index: sc/source/filter/inc/xistyle.hxx
===================================================================
--- sc/source/filter/inc/xistyle.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xistyle.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -72,8 +72,10 @@
     void                ReadPalette( XclImpStream& rStrm );
 
 private:
+    void ExportPalette();
     typedef ::std::vector< ColorData > ColorDataVec;
     ColorDataVec        maColorTable;       /// Colors read from file.
+    const XclImpRoot&             mrRoot;
 };
 
 // FONT record - font information =============================================
Index: sc/source/filter/inc/xcl97esc.hxx
===================================================================
--- sc/source/filter/inc/xcl97esc.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xcl97esc.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,6 +54,15 @@
 #else
 class XclExpTbxControlObj;
 #endif
+class XclExpShapeObj;
+class EscherExHostAppData;
+class ShapeInteractionHelper
+{
+public:
+   static XclExpShapeObj* CreateShapeObj(const XclExpRoot& rRoot, const ::com::sun::star::uno::Reference<
+                            ::com::sun::star::drawing::XShape >& xShape );
+   static void PopulateShapeInteractionInfo( const XclExpRoot& rRoot, const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >& xShape, EscherExHostAppData& rHostAppData );
+};
 
 class XclEscherEx : public EscherEx, protected XclExpRoot
 {
Index: sc/source/filter/inc/xeescher.hxx
===================================================================
--- sc/source/filter/inc/xeescher.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xeescher.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -88,6 +88,34 @@
     sal_uInt16          mnEntryCount;   /// Number of entries in source range.
 };
 
+class XclMacroHelper : public XclExpControlHelper
+{
+protected:
+    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
+
+public:
+    explicit            XclMacroHelper( const XclExpRoot& rRoot );
+    virtual             ~XclMacroHelper();
+    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
+    void                WriteMacroSubRec( XclExpStream& rStrm  );
+    /** Sets the name of a macro for object of passed type
+        @return  true = The passed event descriptor was valid, macro name has been found. */
+    bool                SetMacroLink( const ::com::sun::star::script::ScriptEventDescriptor& rEvent,  const XclTbxEventType& nEventType );
+
+    /** Sets the name of a macro 
+        @return  true = The passed macro name has been found. */
+    bool                SetMacroLink( const String& rMacro );
+};
+
+class XclExpShapeObj : public XclObjAny, public XclMacroHelper
+{
+public:
+    explicit            XclExpShapeObj( const XclExpRoot& rRoot, ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+    virtual             ~XclExpShapeObj();
+private:
+    virtual void        WriteSubRecs( XclExpStream& rStrm );
+};
+
 // ----------------------------------------------------------------------------
 
 #if EXC_EXP_OCX_CTRL
@@ -114,7 +142,7 @@
 #else
 
 /** Represents an OBJ record for an TBX form control. */
-class XclExpTbxControlObj : public XclObj, public XclExpControlHelper
+class XclExpTbxControlObj : public XclObj, public XclMacroHelper
 {
 public:
     explicit            XclExpTbxControlObj(
@@ -128,8 +156,6 @@
 private:
     virtual void        WriteSubRecs( XclExpStream& rStrm );
 
-    /** Writes an ftMacro subrecord containing a macro link, or nothing, if no macro present. */
-    void                WriteMacroSubRec( XclExpStream& rStrm );
     /** Writes a subrecord containing a cell link, or nothing, if no link present. */
     void                WriteCellLinkSubRec( XclExpStream& rStrm, sal_uInt16 nSubRecId );
     /** Writes the ftSbs sub structure containing scrollbar data. */
@@ -137,7 +163,6 @@
 
 private:
     ScfInt16Vec         maMultiSel;     /// Indexes of all selected entries in a multi selection.
-    XclTokenArrayRef    mxMacroLink;    /// Token array containing a link to an attached macro.
     XclTbxEventType     meEventType;    /// Type of supported macro event.
     sal_Int32           mnHeight;       /// Height of the control.
     sal_uInt16          mnState;        /// Checked/unchecked state.
Index: sc/source/filter/inc/xiescher.hxx
===================================================================
--- sc/source/filter/inc/xiescher.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/xiescher.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,6 +33,7 @@
 
 #include <vector>
 #include <map>
+#include <hash_map>
 #include <svx/msdffimp.hxx>
 #include <svx/msocximex.hxx>
 #include <vcl/graph.hxx>
@@ -497,6 +498,10 @@
     /** Derived classes will set additional properties for the current form control. */
     virtual void        DoProcessControl( ScfPropertySet& rPropSet ) const;
 
+    void ApplySheetLinkProps() const;
+    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
+                        mxShape;        /// The UNO wrapper of the control shape.
+    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
 private:
     /** Reads a list of cell ranges from a formula at the current stream position. */
     void                ReadRangeList( ScRangeList& rScRanges, XclImpStream& rStrm );
@@ -505,9 +510,6 @@
 
 private:
     const XclImpRoot&   mrRoot;         /// Not derived from XclImpRoot to allow multiple inheritance.
-    mutable ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >
-                        mxShape;        /// The UNO wrapper of the control shape.
-    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
     ScfRef< ScRange >   mxSrcRange;     /// Source data range in the Calc document.
     XclCtrlBindMode     meBindMode;     /// Value binding mode.
 };
@@ -609,6 +611,7 @@
     virtual XclTbxEventType DoGetEventType() const;
 
 protected:
+    void ApplyGrouping( XclImpOptionButtonObj& rLeader, sal_Int32 nRefVal );
     sal_uInt16          mnNextInGroup;      /// Next option button in a group.
     sal_uInt16          mnFirstInGroup;     /// 1 = Button is the first in a group.
 };
@@ -1083,6 +1086,8 @@
 /** Stores all drawing and OLE objects and additional data related to these objects. */
 class XclImpObjectManager : protected XclImpRoot
 {
+typedef std::hash_map< sal_Int32, String >  CntrlObjIdToName;
+typedef std::map< String, CntrlObjIdToName > CodeNameToCntrlObjIdInfo;
 public:
     explicit            XclImpObjectManager( const XclImpRoot& rRoot );
     virtual             ~XclImpObjectManager();
@@ -1128,9 +1133,13 @@
     String              GetDefaultObjName( const XclImpDrawObjBase& rDrawObj ) const;
     /** Returns the used area in the sheet with the passed index. */
     ScRange             GetUsedArea( SCTAB nScTab ) const;
-
+    void SetOleNameOverrideInfo( const CodeNameToCntrlObjIdInfo& rOverrideInfo ) {  maOleCtrlNameOverride = rOverrideInfo; }
+    String GetOleNameOverride( const XclObjId& nObjId );
     // ------------------------------------------------------------------------
 private:
+
+    CodeNameToCntrlObjIdInfo maOleCtrlNameOverride;
+
     /** Reads and returns a bitmap from WMF/PICT format. */
     static void         ReadWmf( Graphic& rGraphic, XclImpStream& rStrm );
     /** Reads and returns a bitmap from BMP format. */
Index: sc/source/filter/inc/excimp8.hxx
===================================================================
--- sc/source/filter/inc/excimp8.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/filter/inc/excimp8.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -52,7 +52,11 @@
 
 class ImportExcel8 : public ImportExcel
 {
+        SCTAB mnTab;
 	protected:
+        // represents codename ( and associated modules ) 
+        // not speficied directly in the binary format
+        std::vector< String > AutoGeneratedCodeNames; 
         ExcScenarioList         aScenList;
 
 		BOOL					bHasBasic;
Index: sc/source/core/data/cell.cxx
===================================================================
--- sc/source/core/data/cell.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/cell.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,6 +54,7 @@
 #include "recursionhelper.hxx"
 #include "postit.hxx"
 #include "externalrefmgr.hxx"
+#include "macromgr.hxx"
 #include <svx/editobj.hxx>
 #include <svtools/intitem.hxx>
 #include <svx/flditem.hxx>
@@ -822,6 +823,9 @@
 ScFormulaCell::~ScFormulaCell()
 {
 	pDocument->RemoveFromFormulaTree( this );
+    if (pCode->HasOpCode(ocMacro))
+        pDocument->GetMacroManager()->RemoveDependentCell(this);
+
 	delete pCode;
 #ifdef DBG_UTIL
 	eCellType = CELLTYPE_DESTROYED;
@@ -1469,6 +1473,9 @@
             }
         } while (bIterationFromRecursion || bResumeIteration);
     }
+
+	// Fire worksheet calculate event
+	pDocument->FireCalculateEvent( aPos.Tab() );
 }
 
 void ScFormulaCell::InterpretTail( ScInterpretTailParameter eTailParam )
@@ -1739,6 +1746,36 @@
         // Reschedule verlangsamt das ganze erheblich, nur bei Prozentaenderung ausfuehren
         ScProgress::GetInterpretProgress()->SetStateCountDownOnPercent(
             pDocument->GetFormulaCodeInTree()/MIN_NO_CODES_PER_PROGRESS_UPDATE );
+
+        switch (p->GetVolatileType())
+        {
+            case ScInterpreter::VOLATILE:
+                // Volatile via built-in volatile functions.  No actions needed.
+            break;
+            case ScInterpreter::VOLATILE_MACRO:
+                // The formula contains a volatile macro.
+                pCode->SetRecalcModeAlways();
+                pDocument->PutInFormulaTree(this);
+                StartListeningTo(pDocument);
+            break;
+            case ScInterpreter::NOT_VOLATILE:
+                if (pCode->IsRecalcModeAlways())
+                {
+                    // The formula was previously volatile, but no more.
+                    EndListeningTo(pDocument);
+                    pCode->SetRecalcModeNormal();
+                }
+                else
+                {    
+                    // non-volatile formula.  End listening to the area in case 
+                    // it's listening due to macro module change.
+                    pDocument->EndListeningArea(BCA_LISTEN_ALWAYS, this);
+                }
+                pDocument->RemoveFromFormulaTree(this);
+            break;
+            default:
+                ;
+        }
     }
     else
     {
@@ -1806,7 +1843,7 @@
 			else
             {
                 bForceTrack = !bDirty;
-				bDirty = TRUE;
+				SetDirtyVar();
             }
             // #35962# Don't remove from FormulaTree to put in FormulaTrack to
             // put in FormulaTree again and again, only if necessary.
@@ -1829,7 +1866,7 @@
 	if ( !IsInChangeTrack() )
 	{
 		if ( pDocument->GetHardRecalcState() )
-			bDirty = TRUE;
+			SetDirtyVar();
 		else
 		{
 			// Mehrfach-FormulaTracking in Load und in CompileAll
@@ -1838,7 +1875,7 @@
 			// setzen, z.B. in CompileTokenArray
 			if ( !bDirty || !pDocument->IsInFormulaTree( this ) )
 			{
-				bDirty = TRUE;
+				SetDirtyVar();
 				pDocument->AppendToFormulaTrack( this );
 				pDocument->TrackFormulas();
 			}
@@ -1849,6 +1886,13 @@
 	}
 }
 
+void ScFormulaCell::SetDirtyVar()
+{
+	bDirty = TRUE;
+	// mark the sheet of this cell to be calculated
+	pDocument->AddCalculateTable( aPos.Tab() );
+}
+
 void ScFormulaCell::SetDirtyAfterLoad()
 {
     bDirty = TRUE;
Index: sc/source/core/data/table1.cxx
===================================================================
--- sc/source/core/data/table1.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/table1.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -125,6 +125,7 @@
 ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
 					BOOL bColInfo, BOOL bRowInfo ) :
 	aName( rNewName ),
+	aCodeName( rNewName ),
 	bScenario( FALSE ),
 	bLayoutRTL( FALSE ),
     bLoadingRTL( FALSE ),
Index: sc/source/core/data/documen2.cxx
===================================================================
--- sc/source/core/data/documen2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/documen2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,6 +96,8 @@
 #include "tabprotection.hxx"
 #include "formulaparserpool.hxx"
 #include "clipparam.hxx"
+#include "macromgr.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
 // dtor plus helpers are convenient.
@@ -156,6 +158,7 @@
         pCacheFieldEditEngine( NULL ),
         pDocProtection( NULL ),
         mpClipParam( NULL),
+        mpMacroMgr( NULL ), 
         pExternalRefMgr( NULL ),
 		pViewOptions( NULL ),
 		pDocOptions( NULL ),
@@ -1260,6 +1263,29 @@
     }
 }
 
+using namespace com::sun::star;
+uno::Reference< document::XVbaEventsHelper > 
+ScDocument::GetVbaEventsHelper()
+{
+	if( !mxVbaEventsHelper.is() )
+	{
+        try
+        {
+            uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+            uno::Reference< frame::XModel > xModel( pShell ? pShell->GetModel() : NULL, uno::UNO_QUERY );
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] = uno::Any( xModel );
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.document.VbaEventsHelper" ) ), aArgs ), uno::UNO_QUERY );
+            // helper will always be created successfully.
+            mxVbaEventsHelper.set( xVbaEventsHelper, uno::UNO_QUERY );
+        }
+        catch( uno::Exception& e )
+        {
+        }
+	}
+	return mxVbaEventsHelper;
+}
+
 void ScDocument::ClearLookupCaches()
 {
     if( pLookupCacheMapImpl )
Index: sc/source/core/data/documen7.cxx
===================================================================
--- sc/source/core/data/documen7.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/documen7.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -59,7 +59,15 @@
 
 
 #include "globstr.hrc"
+#include <algorithm>
+#include <vector>
 
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 extern const ScFormulaCell* pLastFormulaTreeTop;	// cellform.cxx Err527 WorkAround
 
 // STATIC DATA -----------------------------------------------------------
@@ -527,5 +535,35 @@
 	}
 }
 
+BOOL ScDocument::FireCalculateEvent( SCTAB nTab )
+{
+	BOOL bSuccess = FALSE;
+	::std::vector<SCTAB>::iterator iter;
+	iter = ::std::find( maTabs.begin(), maTabs.end(), nTab );
+	if( iter != maTabs.end() )
+	{
+		// make sure fire worksheet calculate event only once for each sheet 
+		// regardless of how many formula cells are calculated.
+		maTabs.erase(iter);
 
+		uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( GetVbaEventsHelper(), uno::UNO_QUERY );
+		if( xVbaEventsHelper.is() )
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] <<= nTab;
+			bSuccess = xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CALCULATE, aArgs );
+		}
+	}	
+	return bSuccess;
+}
 
+void ScDocument::AddCalculateTable( SCTAB nTab )
+{
+	::std::vector<SCTAB>::iterator iter;
+	iter = ::std::find( maTabs.begin(), maTabs.end(), nTab );
+	if( iter == maTabs.end() )
+	{
+		maTabs.push_back( nTab );
+	}
+}
+
Index: sc/source/core/data/documen8.cxx
===================================================================
--- sc/source/core/data/documen8.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/documen8.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,7 +96,8 @@
 #include "globstr.hrc"
 #include "sc.hrc"
 #include "charthelper.hxx"
+#include "macromgr.hxx"
 #include "dpobject.hxx"
 
 #define GET_SCALEVALUE(set,id) 	((const SfxUInt16Item&)(set.Get( id ))).GetValue()
 
@@ -420,6 +421,13 @@
     return sal::static_int_cast<BYTE>(eRet);
 }
 
+ScMacroManager* ScDocument::GetMacroManager()
+{
+    if (!mpMacroMgr.get())
+        mpMacroMgr.reset(new ScMacroManager(this));
+    return mpMacroMgr.get();
+}
+
 //------------------------------------------------------------------------
 
 void ScDocument::InvalidateTextWidth( const ScAddress* pAdrFrom, const ScAddress* pAdrTo,
Index: sc/source/core/data/column3.cxx
===================================================================
--- sc/source/core/data/column3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/column3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -824,8 +824,10 @@
     bool bCloneValue    = (nFlags & IDF_VALUE) != 0;
     bool bCloneDateTime = (nFlags & IDF_DATETIME) != 0;
     bool bCloneString   = (nFlags & IDF_STRING) != 0;
+    bool bCloneSpecialBoolean  = (nFlags & IDF_SPECIAL_BOOLEAN) != 0;
     bool bCloneFormula  = (nFlags & IDF_FORMULA) != 0;
     bool bCloneNote     = (nFlags & IDF_NOTE) != 0;
+    bool bForceFormula  = false;
 
     ScBaseCell* pNew = 0;
     ScBaseCell& rSource = *pItems[nIndex].pCell;
@@ -849,8 +851,19 @@
         break;
 
 		case CELLTYPE_FORMULA:
-            if (bCloneFormula)
+            if ( bCloneSpecialBoolean )
             {
+                ScFormulaCell& rForm = (ScFormulaCell&)rSource;
+                rtl::OUStringBuffer aBuf;
+                // #TODO #FIXME do we have a localisation issue here?
+                rForm.GetFormula( aBuf );
+                rtl::OUString aVal( aBuf.makeStringAndClear() );
+                if ( aVal.equalsAscii( "=TRUE()" )
+                        || aVal.equalsAscii( "=FALSE()" ) )
+                    bForceFormula = true;
+            }
+            if (bForceFormula || bCloneFormula)
+            {
                 // note will be cloned below
                 pNew = rSource.CloneWithoutNote( rDestDoc, rDestPos );
             }
Index: sc/source/core/data/document.cxx
===================================================================
--- sc/source/core/data/document.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/data/document.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -94,10 +94,14 @@
 #include "externalrefmgr.hxx"
 #include "tabprotection.hxx"
 #include "clipparam.hxx"
+#include <basic/basmgr.hxx>
+#include <com/sun/star/container/XContainer.hpp>
 
 #include <map>
 #include <limits>
 
+using namespace ::com::sun::star;
+
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
 
 struct ScDefaultAttr
@@ -154,7 +158,33 @@
 	return FALSE;
 }
 
+BOOL ScDocument::SetCodeName( SCTAB nTab, String& rName ) 
+{
+	if (VALIDTAB(nTab))
+	{
+		if (pTab[nTab])
+		{
+			pTab[nTab]->SetCodeName( rName );
+			return TRUE;
+		}
+	}
+	OSL_TRACE( "**** can't set code name %s", rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	return FALSE;
+}
 
+BOOL ScDocument::GetCodeName( SCTAB nTab, String& rName ) const
+{
+	if (VALIDTAB(nTab))
+		if (pTab[nTab])
+		{
+			pTab[nTab]->GetCodeName( rName );
+			return TRUE;
+		}
+	rName.Erase();
+	return FALSE;
+}
+
+
 BOOL ScDocument::GetTable( const String& rName, SCTAB& rTab ) const
 {
 	String aUpperName = rName;
@@ -293,6 +323,7 @@
 		if (nPos == SC_TAB_APPEND || nPos == nTabCount)
 		{
 			pTab[nTabCount] = new ScTable(this, nTabCount, rName);
+            pTab[nTabCount]->SetCodeName( rName );
 			++nMaxTableNumber;
 			if ( bExternalDocument )
 				pTab[nTabCount]->SetVisible( FALSE );
@@ -320,10 +351,16 @@
 				for (i = 0; i <= MAXTAB; i++)
 					if (pTab[i])
 						pTab[i]->UpdateInsertTab(nPos);
+
 				for (i = nTabCount; i > nPos; i--)
+				{
 					pTab[i] = pTab[i - 1];
+				}
+
 				pTab[nPos] = new ScTable(this, nPos, rName);
+                pTab[nPos]->SetCodeName( rName );
 				++nMaxTableNumber;
+
                 // UpdateBroadcastAreas must be called between UpdateInsertTab, 
                 // which ends listening, and StartAllListeners, to not modify 
                 // areas that are to be inserted by starting listeners.
@@ -414,7 +451,10 @@
 									pRefUndoDoc ? pRefUndoDoc->pTab[i] : 0);
 				delete pTab[nTab];
 				for (i=nTab + 1; i < nTabCount; i++)
+				{
 					pTab[i - 1] = pTab[i];
+				}
+
 				pTab[nTabCount - 1] = NULL;
 				--nMaxTableNumber;
                 // UpdateBroadcastAreas must be called between UpdateDeleteTab, 
Index: sc/source/core/inc/interpre.hxx
===================================================================
--- sc/source/core/inc/interpre.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/inc/interpre.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -143,6 +143,15 @@
     static inline double div( const double& fNumerator, const double& fDenominator );
 
     ScMatrixRef GetNewMat(SCSIZE nC, SCSIZE nR);
+
+    enum VolatileType { 
+        VOLATILE,   
+        VOLATILE_MACRO,
+        NOT_VOLATILE
+    };
+
+    VolatileType GetVolatileType() const;
+
 private:
     static ScTokenStack*    pGlobalStack;
     static BOOL             bGlobalStackInUse;
@@ -176,6 +185,8 @@
     BOOL        bCalcAsShown;           // precision as shown
     BOOL        bMatrixFormula;         // formula cell is a matrix formula
 
+    VolatileType meVolaileType;
+
 //---------------------------------Funktionen in interpre.cxx---------
 // nMust <= nAct <= nMax ? ok : PushError
 inline BOOL MustHaveParamCount( short nAct, short nMust );
Index: sc/source/core/tool/address.cxx
===================================================================
--- sc/source/core/tool/address.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/tool/address.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1286,7 +1286,7 @@
     }
     nRes1 = ( ( nRes1 | nRes2 ) & SCA_VALID )
           | nRes1
-          | ( ( nRes2 & 0x070F ) << 4 );
+          | ( ( nRes2 & SCA_BITS ) << 4 );
     return nRes1;
 }
 
Index: sc/source/core/tool/interpr1.cxx
===================================================================
--- sc/source/core/tool/interpr1.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/tool/interpr1.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -72,8 +72,9 @@
 #include "rangenam.hxx"
 #include "compiler.hxx"
 #include "externalrefmgr.hxx"
+#include <basic/sbstar.hxx>
 #include "doubleref.hxx"
 #include "queryparam.hxx"
 
 #define SC_DOUBLE_MAXVALUE  1.7e307
 
@@ -4145,7 +4146,20 @@
                 }
             }
             if ( rEntry.bQueryByString )
-                rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            {
+		BOOL bIsVBAMode = FALSE;
+                if ( pDok ) 
+                {
+                   SfxObjectShell* pDocSh = pDok->GetDocumentShell();
+                   if ( pDocSh )
+                        bIsVBAMode = pDocSh->GetBasic()->isVBAEnabled();
+                }
+                // #TODO handle MSO wildcards
+                if ( bIsVBAMode )
+                    rParam.bRegExp = FALSE;
+                else
+                    rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+            }
 
             if (pMatSrc) // The source data is matrix array.
             {
Index: sc/source/core/tool/interpr4.cxx
===================================================================
--- sc/source/core/tool/interpr4.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/tool/interpr4.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,10 +36,13 @@
 #include <sfx2/app.hxx>
 #include <sfx2/docfile.hxx>
 #include <sfx2/objsh.hxx>
+#include <sfx2/docfilt.hxx>
 #include <basic/sbmeth.hxx>
 #include <basic/sbmod.hxx>
 #include <basic/sbstar.hxx>
 #include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/urlobj.hxx>
 #include <rtl/logfile.hxx>
@@ -48,6 +51,7 @@
 #include <signal.h>
 
 #include <com/sun/star/table/XCellRange.hpp>
+#include <comphelper/processfactory.hxx>
 
 #include "interpre.hxx"
 #include "global.hxx"
@@ -68,14 +72,18 @@
 #include "jumpmatrix.hxx"
 #include "parclass.hxx"
 #include "externalrefmgr.hxx"
 #include "doubleref.hxx"
+#include "formula/FormulaCompiler.hxx"
+#include "macromgr.hxx"
 
 #include <math.h>
 #include <float.h>
 #include <map>
 #include <algorithm>
 #include <functional>
 #include <memory>
+#include <vbahelper/vbahelper.hxx>
+#include <basic/basmgr.hxx>
 
 using namespace com::sun::star;
 using namespace formula;
@@ -2488,7 +2496,31 @@
     PushTempToken( new FormulaMissingToken );
 }
 
-
+bool
+lcl_setVBARange( ScRange& aRange, ScDocument* pDok, SbxVariable* pPar )
+{
+	bool bOk = false;
+	try
+	{
+		uno::Reference< uno::XInterface > xVBARange;
+		uno::Reference<table::XCellRange> xCellRange = ScCellRangeObj::CreateRangeFromDoc( pDok, aRange );
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+		aArgs[1] = uno::Any( xCellRange );
+		xVBARange = ov::createVBAUnoAPIServiceWithArgs( pDok->GetDocumentShell(), "ooo.vba.excel.Range", aArgs );
+		if ( xVBARange.is() )
+		{
+			String sDummy(RTL_CONSTASCII_USTRINGPARAM("A-Range") );
+			SbxObjectRef aObj = GetSbUnoObject( sDummy, uno::Any( xVBARange ) );
+			SetSbUnoObjectDfltPropName( aObj );
+			bOk = pPar->PutObject( aObj );
+		}
+	}
+	catch( uno::Exception& )
+	{
+	}
+	return bOk;
+}
 void ScInterpreter::ScMacro()
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "sc", "Eike.Rathke@sun.com", "ScInterpreter::ScMacro" );
@@ -2525,8 +2557,11 @@
         return;
     }
 
+    bool bVolatileMacro = false; 
     SbMethod* pMethod = (SbMethod*)pVar;
+
     SbModule* pModule = pMethod->GetModule();
+	bool bUseVBAObjects = pModule->IsVBACompat();
     SbxObject* pObject = pModule->GetParent();
     DBG_ASSERT(pObject->IsA(TYPE(StarBASIC)), "Kein Basic gefunden!");
     String aMacroStr = pObject->GetName();
@@ -2536,7 +2571,13 @@
     aMacroStr += pMethod->GetName();
     String aBasicStr;
     if (pObject->GetParent())
+	{
         aBasicStr = pObject->GetParent()->GetName();    // Dokumentenbasic
+		const SfxFilter* pFilter = NULL;
+		SfxMedium* pMedium = pDok->GetDocumentShell()->GetMedium();
+		if ( pMedium )
+			pFilter = pMedium->GetFilter();
+	}
     else
         aBasicStr = SFX_APP()->GetName();               // Applikationsbasic
 
@@ -2560,7 +2601,13 @@
             {
                 ScAddress aAdr;
                 PopSingleRef( aAdr );
-                bOk = SetSbxVariable( pPar, aAdr );
+				if ( bUseVBAObjects )
+				{
+					ScRange aRange( aAdr );
+					bOk = lcl_setVBARange( aRange, pDok, pPar );
+				}
+				else
+					bOk = SetSbxVariable( pPar, aAdr );
             }
             break;
             case svDoubleRef:
@@ -2579,24 +2626,32 @@
                 }
                 else
                 {
-                    SbxDimArrayRef refArray = new SbxDimArray;
-                    refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
-                    refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
-                    ScAddress aAdr( nCol1, nRow1, nTab1 );
-                    for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+					if ( bUseVBAObjects )
                     {
-                        aAdr.SetRow( nRow );
-                        INT32 nIdx[ 2 ];
-                        nIdx[ 0 ] = nRow-nRow1+1;
-                        for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
-                        {
-                            aAdr.SetCol( nCol );
-                            nIdx[ 1 ] = nCol-nCol1+1;
-                            SbxVariable* p = refArray->Get32( nIdx );
-                            bOk = SetSbxVariable( p, aAdr );
+						ScRange aRange( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
+						bOk = lcl_setVBARange( aRange, pDok, pPar );
+					}
+					else
+					{
+						SbxDimArrayRef refArray = new SbxDimArray;
+						refArray->AddDim32( 1, nRow2 - nRow1 + 1 );
+						refArray->AddDim32( 1, nCol2 - nCol1 + 1 );
+						ScAddress aAdr( nCol1, nRow1, nTab1 );
+						for( SCROW nRow = nRow1; bOk && nRow <= nRow2; nRow++ )
+						{
+							aAdr.SetRow( nRow );
+							INT32 nIdx[ 2 ];
+							nIdx[ 0 ] = nRow-nRow1+1;
+							for( SCCOL nCol = nCol1; bOk && nCol <= nCol2; nCol++ )
+							{
+								aAdr.SetCol( nCol );
+								nIdx[ 1 ] = nCol-nCol1+1;
+								SbxVariable* p = refArray->Get32( nIdx );
+								bOk = SetSbxVariable( p, aAdr );
+							}
                         }
+						pPar->PutObject( refArray );
                     }
-                    pPar->PutObject( refArray );
                 }
             }
             break;
@@ -2644,6 +2699,13 @@
         pDok->DecMacroInterpretLevel();
         pDok->UnlockTable( aPos.Tab() );
 
+        ScMacroManager* pMacroMgr = pDok->GetMacroManager();
+        if (pMacroMgr)
+        {
+            bVolatileMacro = pMacroMgr->GetUserFuncVolatile( pMethod->GetName() );
+            pMacroMgr->AddDependentCell(pModule->GetName(), pMyFormulaCell);
+        }
+
         SbxDataType eResType = refRes->GetType();
         if( pVar->GetError() )
             SetError( errNoValue);
@@ -2715,6 +2777,9 @@
     }
 
     pSfxApp->LeaveBasicCall();
+
+    if (bVolatileMacro && meVolaileType == NOT_VOLATILE)
+        meVolaileType = VOLATILE_MACRO;
 }
 
 
@@ -3372,7 +3437,8 @@
     pTokenMatrixMap( NULL ),
     pMyFormulaCell( pCell ),
     pFormatter( pDoc->GetFormatTable() ),
-    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() )
+    bCalcAsShown( pDoc->GetDocOptions().IsCalcAsShown() ),
+    meVolaileType(NOT_VOLATILE)
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "sc", "Eike.Rathke@sun.com", "ScInterpreter::ScTTT" );
 //  pStack = new ScToken*[ MAXSTACK ];
@@ -3821,6 +3887,9 @@
                 continue;   // while( ( pCur = aCode.Next() ) != NULL  ...
             }
 
+            if (FormulaCompiler::IsOpCodeVolatile(eOp))
+                meVolaileType = VOLATILE;
+
             // Remember result matrix in case it could be reused.
             if (pTokenMatrixMap && sp && GetStackType() == svMatrix)
                 pTokenMatrixMap->insert( ScTokenMatrixMap::value_type( pCur,
Index: sc/source/core/tool/interpr5.cxx
===================================================================
--- sc/source/core/tool/interpr5.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/tool/interpr5.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -324,6 +324,11 @@
     return pMat;
 }
 
+ScInterpreter::VolatileType ScInterpreter::GetVolatileType() const
+{
+    return meVolaileType;
+}
+
 ScMatrixRef ScInterpreter::CreateMatrixFromDoubleRef( const FormulaToken* pToken,
         SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
         SCCOL nCol2, SCROW nRow2, SCTAB nTab2 )
Index: sc/source/core/tool/rangelst.cxx
===================================================================
--- sc/source/core/tool/rangelst.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/core/tool/rangelst.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -104,15 +104,18 @@
 		for ( USHORT i=0; i<nTCount; i++ )
 		{
 			aOne = rStr.GetToken( i, cDelimiter );
-			// FIXME : broken for Lotus
-			if ( aOne.Search( ':' ) == STRING_NOTFOUND )
-			{	// Range muss es sein
-				String aStrTmp( aOne );
-				aOne += ':';
-				aOne += aStrTmp;
-			}
 			aRange.aStart.SetTab( nTab );	// Default Tab wenn nicht angegeben
-			USHORT nRes = aRange.Parse( aOne, pDoc, eConv );
+			USHORT nRes = aRange.ParseAny( aOne, pDoc, eConv );
+			USHORT nEndRangeBits = SCA_VALID_COL2 | SCA_VALID_ROW2 |
+SCA_VALID_TAB2;
+			USHORT nTmp1 = ( nRes & SCA_BITS );
+			USHORT nTmp2 = ( nRes & nEndRangeBits );
+			// If we have a valid single range with
+			// any of the address bits we are interested in
+			// set - set the equiv end range bits
+			if ( (nRes & SCA_VALID ) && nTmp1 && ( nTmp2 != nEndRangeBits ) )
+					nRes |= ( nTmp1 << 4 );
+	
 			if ( (nRes & nMask) == nMask )
 				Append( aRange );
 			nResult &= nRes;		// alle gemeinsamen Bits bleiben erhalten
Index: sc/source/ui/src/makefile.mk
===================================================================
--- sc/source/ui/src/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/src/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -57,6 +57,7 @@
 	dbnamdlg.src \
 	subtdlg.src  \
 	miscdlgs.src \
+	datafdlg.src \
 	autofmt.src  \
 	solvrdlg.src \
     optsolver.src \
Index: sc/source/ui/src/datafdlg.src
===================================================================
--- sc/source/ui/src/datafdlg.src	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/src/datafdlg.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.src,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: hr $ $Date: 2005/09/23 15:07:30 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "datafdlg.hrc"
+
+//zhangyun, dataform
+ModalDialog RID_SCDLG_DATAFORM
+{
+    OutputSize = TRUE ;
+    SVLook = TRUE ;
+    Size = MAP_APPFONT ( 191 , 180 ) ;
+    Text [ en-US ] = "Data Form" ;
+    Moveable = TRUE ;
+    Closeable = TRUE ;
+    FixedText LAB_DATAFORM_RECORDNO
+    {
+        Pos = MAP_APPFONT ( 136 , 6 ) ;
+        Size = MAP_APPFONT ( 50 , 12 ) ;
+        Text [ en-US ] = "/" ;
+    };
+    PushButton BTN_DATAFORM_NEW
+    {
+        Pos = MAP_APPFONT ( 135 , 23 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        DefButton = TRUE ;
+        Text [ en-US ] = "New" ;
+    };
+    PushButton BTN_DATAFORM_DELETE
+    {
+        Pos = MAP_APPFONT ( 135 , 40 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Delete" ;
+    };
+    PushButton BTN_DATAFORM_RESTORE
+    {
+        Pos = MAP_APPFONT ( 135 , 57 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Restore" ;
+    };
+    PushButton BTN_DATAFORM_LAST
+    {
+        Pos = MAP_APPFONT ( 135 , 82 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Last Record" ;
+    };
+    PushButton BTN_DATAFORM_NEXT
+    {
+        Pos = MAP_APPFONT ( 135 , 99 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Next Record" ;
+    };
+    PushButton BTN_DATAFORM_CLOSE
+    {
+        Pos = MAP_APPFONT ( 135 , 116 ) ;
+        Size = MAP_APPFONT ( 50 , 14 ) ;
+        TabStop = TRUE ;
+        Text [ en-US ] = "Close" ;
+    };
+    ScrollBar WND_DATAFORM_SCROLLBAR
+    {
+        Pos = MAP_APPFONT ( 124 , 6 ) ;
+        Size = MAP_APPFONT ( 8 , 135 ) ;
+        HScroll = FALSE ;
+        TabStop = FALSE ;
+    };
+};
+//end
+
+
+
+
Index: sc/source/ui/src/globstr.src
===================================================================
--- sc/source/ui/src/globstr.src	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/src/globstr.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1717,6 +1717,77 @@
     {
         Text [ en-US ] = "Unknown User";
     };
+
+    String STR_SHAPE_AUTOSHAPE
+    {
+        Text [ en-US ] = "AutoShape";
+    };
+
+    String STR_SHAPE_RECTANGLE
+    {
+        Text [ en-US ] = "Rectangle";
+    };
+
+    String STR_SHAPE_LINE
+    {
+        Text [ en-US ] = "Line";
+    };
+
+    String STR_SHAPE_OVAL
+    {
+        Text [ en-US ] = "Oval";
+    };
+
+    String STR_SHAPE_TEXTBOX
+    {
+        Text [ en-US ] = "Text Box";
+    };
+
+    String STR_FORM_BUTTON
+    {
+        Text [ en-US ] = "Button";
+    };
+
+    String STR_FORM_CHECKBOX
+    {
+        Text [ en-US ] = "Check Box";
+    };
+
+    String STR_FORM_OPTIONBUTTON
+    {
+        Text [ en-US ] = "Option Button";
+    };
+
+    String STR_FORM_LABEL
+    {
+        Text [ en-US ] = "Label";
+    };
+
+    String STR_FORM_LISTBOX
+    {
+        Text [ en-US ] = "List Box";
+    };
+
+    String STR_FORM_GROUPBOX
+    {
+        Text [ en-US ] = "Group Box";
+    };
+
+    String STR_FORM_DROPDOWN 
+    {
+        Text [ en-US ] = "Drop Down";
+    };
+
+    String STR_FORM_SPINNER
+    {
+        Text [ en-US ] = "Spinner";
+    };
+
+    String STR_FORM_SCROLLBAR
+    {
+        Text [ en-US ] = "Scroll Bar";
+    };
+
     String STR_STYLE_FAMILY_CELL
     {
         Text [ en-US ] = "Cell Styles";
Index: sc/source/ui/unoobj/shapeuno.cxx
===================================================================
--- sc/source/ui/unoobj/shapeuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/unoobj/shapeuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -73,6 +73,8 @@
         {MAP_CHAR_LEN(SC_UNONAME_HORIPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
 		{MAP_CHAR_LEN(SC_UNONAME_IMAGEMAP),	0, &getCppuType((uno::Reference<container::XIndexContainer>*)0), 0, 0 },
 		{MAP_CHAR_LEN(SC_UNONAME_VERTPOS), 0, &getCppuType((sal_Int32*)0), 0, 0 },
+		// #i66550 HLINK_FOR_SHAPES
+		{MAP_CHAR_LEN(SC_UNONAME_HYPERLINK), 0, &getCppuType((rtl::OUString*)0), 0, 0 },
         {0,0,0,0,0,0}
 	};
 	return aShapeMap_Impl;
@@ -87,6 +89,14 @@
 	};
 	return aMacroDescriptionsImpl;
 }
+// #i66550 HLINK_FOR_SHAPES
+ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate = FALSE )
+{
+        if( pShape )
+            if( SdrObject* pObj = pShape->GetSdrObject() )
+                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
+        return 0;
+}
 
 //------------------------------------------------------------------------
 
@@ -638,6 +648,13 @@
             }
         }
     }
+	else if  ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+                rtl::OUString sHlink;
+        	ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this, TRUE);
+        	if ( ( aValue >>= sHlink ) && pInfo )
+			pInfo->SetHlink( sHlink );
+	}
 	else
 	{
         GetShapePropertySet();
@@ -819,6 +836,13 @@
             }
         }
     }
+	else if ( aNameString.EqualsAscii( SC_UNONAME_HYPERLINK ) )
+	{
+		rtl::OUString sHlink;
+		if ( ScMacroInfo* pInfo = lcl_getShapeHyperMacroInfo(this) )
+			sHlink = pInfo->GetHlink();
+		aAny <<= sHlink;
+	}
 	else
 	{
         GetShapePropertySet();
@@ -1342,11 +1366,6 @@
 }
 
 #define SC_EVENTACC_ONCLICK     ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) )
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-#define SC_EVENTACC_ONACTION    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OnAction" ) )
-#define SC_EVENTACC_URL         ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "URL" ) )
-#define SC_EVENTACC_ACTION      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Action" ) )
-#endif
 #define SC_EVENTACC_SCRIPT      ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Script" ) )
 #define SC_EVENTACC_EVENTTYPE   ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EventType" ) )
 
@@ -1358,10 +1377,7 @@
 
     ScMacroInfo* getInfo( BOOL bCreate = FALSE )
 	{
-        if( mpShape )
-            if( SdrObject* pObj = mpShape->GetSdrObject() )
-                return ScDrawLayer::GetMacroInfo( pObj, bCreate );
-        return 0;
+		return lcl_getShapeHyperMacroInfo( mpShape, bCreate );
 	}
 
 public:
@@ -1387,11 +1403,7 @@
 				isEventType = true;
 				continue;
 			}
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-            if ( isEventType && ((pProperties->Name == SC_EVENTACC_SCRIPT) || (pProperties->Name == SC_EVENTACC_URL)) )
-#else
             if ( isEventType && (pProperties->Name == SC_EVENTACC_SCRIPT) )
-#endif
 			{
                 rtl::OUString sValue;
                 if ( pProperties->Value >>= sValue )
@@ -1402,10 +1414,8 @@
                         break;
                     if ( pProperties->Name == SC_EVENTACC_SCRIPT )
                         pInfo->SetMacro( sValue );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                     else
                         pInfo->SetHlink( sValue );
-#endif
                 }
 			}
 		}
@@ -1428,19 +1438,6 @@
                 aProperties[ 1 ].Value <<= pInfo->GetMacro();
             }
         }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        else if( aName == SC_EVENTACC_ONACTION )
-        {
-            if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
-            {
-                aProperties.realloc( 2 );
-                aProperties[ 0 ].Name = SC_EVENTACC_EVENTTYPE;
-                aProperties[ 0 ].Value <<= SC_EVENTACC_ACTION;
-                aProperties[ 1 ].Name = SC_EVENTACC_URL;
-                aProperties[ 1 ].Value <<= pInfo->GetHlink();
-            }
-        }
-#endif
         else
         {
             throw container::NoSuchElementException();
@@ -1451,25 +1448,14 @@
 
     virtual uno::Sequence< rtl::OUString > SAL_CALL getElementNames() throw(uno::RuntimeException)
 	{
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        uno::Sequence< rtl::OUString > aSeq( 2 );
-#else
         uno::Sequence< rtl::OUString > aSeq( 1 );
-#endif
         aSeq[ 0 ] = SC_EVENTACC_ONCLICK;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        aSeq[ 1 ] = SC_EVENTACC_ONACTION;
-#endif
         return aSeq;
 	}
 
 	virtual sal_Bool SAL_CALL hasByName( const rtl::OUString& aName ) throw(uno::RuntimeException)
 	{
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
-        return (aName == SC_EVENTACC_ONCLICK) || (aName == SC_EVENTACC_ONACTION);
-#else
         return aName == SC_EVENTACC_ONCLICK;
-#endif
 	}
 
 	// XElementAccess
Index: sc/source/ui/unoobj/viewuno.cxx
===================================================================
--- sc/source/ui/unoobj/viewuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/unoobj/viewuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -71,9 +71,13 @@
 #include "gridwin.hxx"
 #include <com/sun/star/view/DocumentZoomType.hpp>
 #include "AccessibilityHints.hxx"
+#include <com/sun/star/awt/MouseButton.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 #include <svx/sdrhittesthelper.hxx>
 
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -459,6 +463,78 @@
 	OWeakObject::release();
 }
 
+// To process sheet compatibile event
+typedef ::cppu::WeakImplHelper2< awt::XEnhancedMouseClickHandler, view::XSelectionChangeListener > TabViewEventListener_BASE;
+class ScTabViewEventListener: public TabViewEventListener_BASE
+{
+private:
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper;
+    ScTabViewObj* pViewObj;
+    
+public:
+    ScTabViewEventListener( ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper);
+    ~ScTabViewEventListener();
+	// XEnhancedMouseClickHandler
+	virtual sal_Bool SAL_CALL mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+	virtual sal_Bool SAL_CALL mouseReleased( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException);
+
+    // XSelectionChangeListener
+    virtual void SAL_CALL selectionChanged( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XEventListener
+	virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+};
+
+ScTabViewEventListener::ScTabViewEventListener(ScTabViewObj* pObj, uno::Reference< document::XVbaEventsHelper >& rVbaEventsHelper):
+                        pViewObj( pObj ),xVbaEventsHelper( rVbaEventsHelper )
+{
+}
+
+ScTabViewEventListener::~ScTabViewEventListener()
+{
+}
+
+void SAL_CALL ScTabViewEventListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mousePressed( const awt::EnhancedMouseEvent& e ) throw (uno::RuntimeException)
+{
+	sal_Bool result =  sal_False;
+    // process BeforeDoubleClick and BeforeRightClick events
+	if( e.ClickCount == 2 || e.Buttons == ::com::sun::star::awt::MouseButton::RIGHT )
+	{
+		// ensure the target is a cell
+        uno::Reference< table::XCell > xCell( e.Target, uno::UNO_QUERY );
+		if( xCell.is() && xVbaEventsHelper.is() && pViewObj)
+		{
+			uno::Sequence< uno::Any > aArgs(1);
+			aArgs[0] = pViewObj->getSelection();
+			sal_Int32 nEventId = VBAEVENT_WORKSHEET_BEFORERIGHTCLICK;
+			if( e.ClickCount == 2 )
+				nEventId = VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK;
+            
+            result = xVbaEventsHelper->ProcessCompatibleVbaEvent( nEventId, aArgs );
+			// TODO: process Cancel argument	
+		}
+	}
+	return result;
+}
+
+sal_Bool SAL_CALL ScTabViewEventListener::mouseReleased( const awt::EnhancedMouseEvent&/*e*/) throw (uno::RuntimeException)
+{
+	return sal_False;
+}
+
+void SAL_CALL ScTabViewEventListener::selectionChanged( const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+	if ( xVbaEventsHelper.is() && pViewObj)
+	{
+	    uno::Sequence< uno::Any > aArgs(1);
+	    aArgs[0] = pViewObj->getSelection();
+	    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_SELECTIONCHANGE, aArgs );
+	}
+}
+
 //------------------------------------------------------------------------
 
 //	Default-ctor wird fuer SMART_REFLECTION_IMPLEMENTATION gebraucht
@@ -469,7 +545,8 @@
 //UNUSED2008-05  aPropSet( lcl_GetViewOptPropertyMap() ),
 //UNUSED2008-05  aMouseClickHandlers( 0 ),
 //UNUSED2008-05  aActivationListeners( 0 ),
-//UNUSED2008-05  bDrawSelModeSet(sal_False)
+//UNUSED2008-05  bDrawSelModeSet(sal_False),
+//UNUSED2008-05  bFilteredRangeSelection(sal_True)
 //UNUSED2008-05  {
 //UNUSED2008-05  }
 
@@ -479,9 +556,22 @@
 	aPropSet( lcl_GetViewOptPropertyMap() ),
 	aMouseClickHandlers( 0 ),
 	aActivationListeners( 0 ),
-	bDrawSelModeSet(sal_False)
+	bDrawSelModeSet(sal_False),
+    bFilteredRangeSelection(sal_True)
 {
-	//!	Listening oder so
+	if( pViewSh )
+	{
+		ScViewData* pViewData = pViewSh->GetViewData();
+		if( pViewData )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper (pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+			ScTabViewEventListener* pEventListener = new ScTabViewEventListener( this, xVbaEventsHelper );
+			uno::Reference< awt::XEnhancedMouseClickHandler > aMouseClickHandler( *pEventListener, uno::UNO_QUERY );
+			addEnhancedMouseClickHandler( aMouseClickHandler );
+            uno::Reference< view::XSelectionChangeListener > aSelectionChangeListener( *pEventListener, uno::UNO_QUERY );
+            addSelectionChangeListener( aSelectionChangeListener );
+		}
+	}
 }
 
 ScTabViewObj::~ScTabViewObj()
@@ -884,6 +974,15 @@
 
 		ScRange aRange;
         ScMarkType eMarkType = pViewData->GetSimpleArea(aRange);
+
+        if (!bFilteredRangeSelection)
+        {
+            if (eMarkType == SC_MARK_SIMPLE_FILTERED)
+                eMarkType = SC_MARK_SIMPLE;
+            else if (eMarkType == SC_MARK_FILTERED)
+                eMarkType = SC_MARK_MULTI;
+        }
+
 		if ( nTabs == 1 && (eMarkType == SC_MARK_SIMPLE) )
 		{
 			if (aRange.aStart == aRange.aEnd)
@@ -1729,6 +1828,12 @@
 	ScUnoGuard aGuard;
 	String aString(aPropertyName);
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        bFilteredRangeSelection = ScUnoHelpFunctions::GetBoolFromAny(aValue);
+        return;
+    }
+
 	ScTabViewShell* pViewSh = GetViewShell();
 	if (pViewSh)
 	{
@@ -1849,6 +1954,12 @@
 	String aString(aPropertyName);
 	uno::Any aRet;
 
+    if ( aString.EqualsAscii(SC_UNO_FILTERED_RANGE_SELECTION) )
+    {
+        ScUnoHelpFunctions::SetBoolInAny(aRet, bFilteredRangeSelection);
+        return aRet;
+    }
+
 	ScTabViewShell* pViewSh = GetViewShell();
 	if (pViewSh)
 	{
Index: sc/source/ui/unoobj/docuno.cxx
===================================================================
--- sc/source/ui/unoobj/docuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/unoobj/docuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -100,7 +100,10 @@
 #include <svx/unoshape.hxx>
 #endif
 
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 //------------------------------------------------------------------------
 
@@ -318,6 +321,7 @@
 	SC_QUERYINTERFACE( view::XRenderable )
 	SC_QUERYINTERFACE( document::XLinkTargetSupplier )
 	SC_QUERYINTERFACE( beans::XPropertySet )
+	SC_QUERYINTERFACE( document::XDocumentEventCompatibleHelper)
 	SC_QUERYINTERFACE( lang::XMultiServiceFactory )
 	SC_QUERYINTERFACE( lang::XServiceInfo )
     SC_QUERYINTERFACE( util::XChangesNotifier )
@@ -1733,6 +1737,39 @@
 	return concatServiceNames( aMyServices, aDrawServices );
 }
 
+// XVbaEventHelper
+// For Vba Event
+sal_Bool SAL_CALL
+ScModelObj::processCompatibleEvent( sal_Int16 nSlotId ) throw( ::com::sun::star::uno::RuntimeException )
+{
+    USHORT nId = (USHORT)nSlotId;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper( GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+    if( xVbaEventsHelper.is() )
+    {
+        switch( nId )
+        {
+            case SID_SAVEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_False;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_SAVEASDOC:
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= sal_True;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORESAVE, aArgs );
+            }
+            case SID_PRINTDOC:
+            case SID_PRINTDOCDIRECT:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                return xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFOREPRINT, aArgs );
+            }
+        }
+    }
+    return sal_False;
+}
 // XServiceInfo
 
 rtl::OUString SAL_CALL ScModelObj::getImplementationName() throw(uno::RuntimeException)
@@ -1771,6 +1808,12 @@
         return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(this));
 	}
 
+	if ( rId.getLength() == 16 &&
+          0 == rtl_compareMemory( SfxObjectShell::getUnoTunnelId().getConstArray(),
+									rId.getConstArray(), 16 ) )
+        {
+            return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(pDocShell ));
+        }
 	//	aggregated number formats supplier has XUnoTunnel, too
 	//	interface from aggregated object must be obtained via queryAggregation
 
Index: sc/source/ui/unoobj/addruno.cxx
===================================================================
--- sc/source/ui/unoobj/addruno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/unoobj/addruno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -72,7 +72,7 @@
     }
 }
 
-sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString )
+sal_Bool ScAddressConversionObj::ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv )
 {
     if (!pDocShell)
         return sal_False;
@@ -81,7 +81,7 @@
     sal_Bool bSuccess = sal_False;
     if ( bIsRange )
     {
-        USHORT nResult = aRange.ParseAny( rUIString, pDoc );
+        USHORT nResult = aRange.ParseAny( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -95,7 +95,7 @@
     }
     else
     {
-        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc );
+        USHORT nResult = aRange.aStart.Parse( rUIString, pDoc, eConv );
         if ( nResult & SCA_VALID )
         {
             if ( ( nResult & SCA_TAB_3D ) == 0 )
@@ -119,6 +119,7 @@
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellRangeAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -132,6 +133,7 @@
         {
             {MAP_CHAR_LEN(SC_UNONAME_ADDRESS),  0,  &getCppuType((table::CellAddress*)0), 0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_PERSREPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
+            {MAP_CHAR_LEN(SC_UNONAME_XL_A1_REPR), 0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_REFSHEET), 0,  &getCppuType((sal_Int32*)0),        0, 0 },
             {MAP_CHAR_LEN(SC_UNONAME_UIREPR),   0,  &getCppuType((rtl::OUString*)0),    0, 0 },
             {0,0,0,0,0,0}
@@ -193,8 +195,11 @@
             bSuccess = ParseUIString( aUIString );
         }
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
         //  parse the file format string
         rtl::OUString sRepresentation;
         if (aValue >>= sRepresentation)
@@ -215,7 +220,7 @@
             }
 
             //  parse the rest like a UI string
-            bSuccess = ParseUIString( aUIString );
+            bSuccess = ParseUIString( aUIString, aConv );
         }
     }
     else
@@ -268,17 +273,24 @@
             aRange.aStart.Format( aFormatStr, nFlags, pDoc );
         aRet <<= rtl::OUString( aFormatStr );
     }
-    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) )
+    else if ( aNameStr.EqualsAscii( SC_UNONAME_PERSREPR ) || aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
     {
+        ::formula::FormulaGrammar::AddressConvention aConv = ::formula::FormulaGrammar::CONV_OOO; 
+        if ( aNameStr.EqualsAscii( SC_UNONAME_XL_A1_REPR ) )
+            aConv = ::formula::FormulaGrammar::CONV_XL_A1; 
+
         //  generate file format string - always include sheet
         String aFormatStr;
-        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc );
+        aRange.aStart.Format( aFormatStr, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
         if ( bIsRange )
         {
             //  manually concatenate range so both parts always have the sheet name
             aFormatStr.Append( (sal_Unicode) ':' );
             String aSecond;
-            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc );
+            USHORT nFlags = SCA_VALID;
+            if( aConv != ::formula::FormulaGrammar::CONV_XL_A1 )
+		nFlags |= SCA_TAB_3D;
+            aRange.aEnd.Format( aSecond, SCA_VALID | SCA_TAB_3D, pDoc, aConv );
             aFormatStr.Append( aSecond );
         }
         aRet <<= rtl::OUString( aFormatStr );
Index: sc/source/ui/unoobj/servuno.cxx
===================================================================
--- sc/source/ui/unoobj/servuno.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/unoobj/servuno.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,6 +38,7 @@
 #include <svx/unofill.hxx>
 #include <svx/unonrule.hxx>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
 
 #include "servuno.hxx"
 #include "unonames.hxx"
@@ -61,9 +62,154 @@
 #include <svx/xmleohlp.hxx>
 #include <svx/xmlgrhlp.hxx>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <cppuhelper/component_context.hxx>
+#include <vbahelper/vbahelper.hxx>
 using namespace ::com::sun::star;
 
+class ScVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    uno::Any maWorkbook;
+    uno::Any maCachedObject;
+    ScDocShell* mpDocShell;
+public:
+    ScVbaObjectForCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("")), uno::Reference< uno::XInterface >() );
 
+        uno::Sequence< uno::Any > aArgs(2);
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( mpDocShell->GetModel() );
+        maWorkbook <<= ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.excel.Workbook", aArgs );
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        maCachedObject = uno::Any(); // clear cached object
+        String sName = aName;
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        if ( sName == pDoc->GetCodeName() )
+            maCachedObject = maWorkbook;
+        else 
+        {
+            String sCodeName;
+            SCTAB nCount = pDoc->GetTableCount();
+            for( SCTAB i = 0; i < nCount; i++ )
+            {
+                pDoc->GetCodeName( i, sCodeName );
+                if( sCodeName == sName )
+                {
+                    String sSheetName;
+                    if( pDoc->GetName( i, sSheetName ) )
+                    {
+                        uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                        uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                        uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                        uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                        uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                        uno::Sequence< uno::Any > aArgs(3);
+                        aArgs[0] = maWorkbook;
+                        aArgs[1] = uno::Any( xModel );
+                        aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                        maCachedObject <<= ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.excel.Worksheet", aArgs );
+                        break;
+                    }
+                }
+            }
+        }
+        return maCachedObject.hasValue();
+
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectForCodeNameProvider::getByName( %s )",
+            rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if ( !hasByName( aName ) )
+            throw ::com::sun::star::container::NoSuchElementException();
+        return maCachedObject;
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        ScDocument* pDoc = mpDocShell->GetDocument();
+        if ( !pDoc )
+            throw uno::RuntimeException();
+        SCTAB nCount = pDoc->GetTableCount();
+        uno::Sequence< rtl::OUString > aNames( nCount + 1 ); 
+        SCTAB index = 0;
+        String sCodeName;
+        for( ; index < nCount; ++index )
+        {
+            pDoc->GetCodeName( index, sCodeName );
+            aNames[ index ] = sCodeName;
+        }
+        aNames[ index ] = pDoc->GetCodeName();
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
+
+class ScVbaCodeNameProvider : public ::cppu::WeakImplHelper1< document::XCodeNameQuery >
+{
+ScDocShell* mpDocShell;
+public:
+    ScVbaCodeNameProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+    // XCodeNameQuery
+    rtl::OUString SAL_CALL getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sCodeName;
+        if ( mpDocShell )
+        {
+            OSL_TRACE( "*** In ScVbaCodeNameProvider::getCodeNameForObject");
+            // need to find the page ( and index )  for this control
+            uno::Reference< drawing::XDrawPagesSupplier > xSupplier( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPages(), uno::UNO_QUERY_THROW );
+            sal_Int32 nLen = xIndex->getCount();
+            bool bMatched = false;
+            uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+            for ( sal_Int32 index = 0; index < nLen; ++index )
+            {
+                try
+                {
+                    uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex->getByIndex( index ), uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                    // get the www-standard container
+                    uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                    sal_Int32 nCntrls = xFormControls->getCount();
+                    for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                    {
+                        uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                        bMatched = ( xControl == xIf );
+                        if ( bMatched )
+                        {
+                            String sName;
+                            mpDocShell->GetDocument()->GetCodeName( index, sName );
+                            sCodeName = sName;
+                        }
+                    }
+                }
+                catch( uno::Exception& ) {}
+                if ( bMatched )
+                    break;
+            }
+        }
+        // Probably should throw here ( if !bMatched )
+         return sCodeName;
+    }
+
+};
+
 //------------------------------------------------------------------------
 
 static const sal_Char* __FAR_DATA aProvNames[SC_SERVICE_COUNT] =
@@ -112,7 +258,9 @@
 
     { "com.sun.star.text.textfield.DocumentTitle",      SC_SERVICE_TITLEFIELD },
    { "com.sun.star.text.textfield.FileName",           SC_SERVICE_FILEFIELD },
     { "com.sun.star.text.textfield.SheetName",          SC_SERVICE_SHEETFIELD },
+{"ooo.vba.VBAObjectModuleObjectProvider", SC_SERVICE_VBAOBJECTPROVIDER },
+{"ooo.vba.VBACodeNameProvider", SC_SERVICE_VBACODENAMEPROVIDER },
 };
 
 //
@@ -164,7 +312,9 @@
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_OPCODEMAPPER
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
+        "",                                         // SC_SERVICE_VBACODENAMEPROVIDER
 	};
 
 
@@ -363,6 +513,12 @@
                 xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj(::std::auto_ptr<formula::FormulaCompiler> (pComp))));
             }
             break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<container::XNameAccess*>(new ScVbaObjectForCodeNameProvider( pDocShell )));
+            break;
+        case SC_SERVICE_VBACODENAMEPROVIDER:
+            xRet.set(static_cast<document::XCodeNameQuery*>(new ScVbaCodeNameProvider( pDocShell )));
+            break;
 	}
 	return xRet;
 }
Index: sc/source/ui/docshell/docfunc.cxx
===================================================================
--- sc/source/ui/docshell/docfunc.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/docshell/docfunc.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,12 @@
 #include <svtools/zforlist.hxx>
 #include <svtools/PasswordHelper.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+
 #include <list>
 
 #include "docfunc.hxx"
@@ -101,6 +107,7 @@
 using namespace com::sun::star;
 using ::com::sun::star::uno::Sequence;
 
+
 // STATIC DATA -----------------------------------------------------------
 
 //========================================================================
@@ -2579,7 +2586,93 @@
 }
 
 //------------------------------------------------------------------------
+uno::Reference< uno::XInterface > GetDocModuleObject( SfxObjectShell& rDocSh, String& sCodeName )
+{
+    uno::Reference< lang::XMultiServiceFactory> xSF(rDocSh.GetModel(), uno::UNO_QUERY);
+    uno::Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+    uno::Reference< uno::XInterface > xDocModuleApiObject;
+    if ( xSF.is() )
+    {
+        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), uno::UNO_QUERY );    
+        xDocModuleApiObject.set( xVBACodeNamedObjectAccess->getByName( sCodeName ), uno::UNO_QUERY );    
+    }
+    return xDocModuleApiObject;
 
+}
+
+script::ModuleInfo lcl_InitModuleInfo( SfxObjectShell& rDocSh, String& sModule, String& sSource )
+{
+    ::rtl::OUString aModName( sModule );
+    ::rtl::OUString sVbaOption( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=VBADocumentModule\nOption VBASupport 1\n" ));
+    script::ModuleInfo sModuleInfo;
+    sModuleInfo.ModuleName = aModName;
+    if ( sSource.Len() > 0 )
+        sModuleInfo.ModuleSource = sSource;
+    else
+        sModuleInfo.ModuleSource = sVbaOption;
+    sModuleInfo.ModuleType = script::ModuleType::Document;
+    sModuleInfo.ModuleObject = GetDocModuleObject( rDocSh, sModule );
+    return sModuleInfo;
+}
+
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sSource )
+{
+    SFX_APP()->EnterBasicCall();
+    script::ModuleInfo sModuleInfo = lcl_InitModuleInfo(  rDocSh, sModuleName, sSource );
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        // if the Module with codename exists then find a new name
+        sal_Int32 nNum = 1;
+        sModuleInfo.ModuleName = sModuleName;
+        while( xLib->hasByName( sModuleInfo.ModuleName  ) )
+        {
+            sModuleInfo.ModuleName = rtl::OUString::createFromAscii( "Sheet" ) + rtl::OUString::valueOf( nNum );
+            nNum += 1;
+        }
+        uno::Any aSourceAny;
+        aSourceAny <<= sModuleInfo;
+        xLib->insertByName( sModuleInfo.ModuleName, aSourceAny );
+        ScDocument* pDoc = rDocSh.GetDocument();
+        String sCodeName( sModuleInfo.ModuleName );
+        pDoc->SetCodeName( nTab, sCodeName );
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+void lcl_DeleteModule( ScDocShell& rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
+
 BOOL ScDocFunc::InsertTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
 {
 	BOOL bSuccess = FALSE;
@@ -2588,8 +2681,18 @@
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
-	if (bRecord && !pDoc->IsUndoEnabled())
+    // Strange loop, also basic is loaded too early ( InsertTable )
+    // is called via the xml import for sheets in described in odf 
+    BOOL bInsertDocModule = false;
+
+    if(  !rDocShell.GetDocument()->IsImportingXML() )
+    {
+        StarBASIC* pStarBASIC = rDocShell.GetBasic(); 
+        bInsertDocModule = pStarBASIC ? pStarBASIC->isVBAEnabled() : false;
+    }
+	if ( bInsertDocModule || ( bRecord && !pDoc->IsUndoEnabled() ) )
 		bRecord = FALSE;
+
 	if (bRecord)
 		pDoc->BeginDrawUndo();							//	InsertTab erzeugt ein SdrUndoNewPage
 
@@ -2600,10 +2703,19 @@
 
 	if (pDoc->InsertTab( nTab, rName ))
 	{
+		String sCodeName;
 		if (bRecord)
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoInsertTab( &rDocShell, nTab, bAppend, rName));
 		//	Views updaten:
+        // Only insert vba modules if vba mode ( and not currently importing XML )
+        if( bInsertDocModule )
+        {
+            if ( sCodeName.Len() == 0 )
+		sCodeName = rName;
+            String sSource;
+            lcl_InsertModule( rDocShell, nTab, sCodeName, sSource );
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_INSERTED, nTab ) );
 
 		rDocShell.PostPaintExtras();
@@ -2625,8 +2737,12 @@
 
 	BOOL bSuccess = FALSE;
 	ScDocument* pDoc = rDocShell.GetDocument();
+    StarBASIC* pStarBASIC = rDocShell.GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 	BOOL bWasLinked = pDoc->IsLinked(nTab);
 	ScDocument* pUndoDoc = NULL;
 	ScRefUndoData* pUndoData = NULL;
@@ -2667,6 +2783,8 @@
 		pUndoData = new ScRefUndoData( pDoc );
 	}
 
+    String sCodeName;
+    BOOL bHasCodeName = pDoc->GetCodeName( nTab, sCodeName );
 	if (pDoc->DeleteTab( nTab, pUndoDoc ))
 	{
 		if (bRecord)
@@ -2677,6 +2795,13 @@
 						new ScUndoDeleteTab( &rDocShell, theTabs, pUndoDoc, pUndoData ));
 		}
 		//	Views updaten:
+        if( bVbaEnabled )
+        {
+            if( bHasCodeName )
+            {
+                lcl_DeleteModule( rDocShell, sCodeName );
+            }
+        }
 		rDocShell.Broadcast( ScTablesHint( SC_TAB_DELETED, nTab ) );
 
 		if (bWasLinked)
@@ -3921,6 +4046,13 @@
 BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
 							FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi )
 {
+	double		fStep = 1.0;
+	double		fMax = MAXDOUBLE;
+	return FillAuto( rRange, pTabMark, eDir, FILL_AUTO, FILL_DAY, nCount, fStep, fMax, bRecord, bApi );
+}
+
+BOOL ScDocFunc::FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax,  BOOL bRecord, BOOL bApi )
+{
 	ScDocShellModificator aModificator( rDocShell );
 
 	ScDocument* pDoc = rDocShell.GetDocument();
@@ -3946,10 +4078,6 @@
 	ScRange aSourceArea = rRange;
 	ScRange aDestArea   = rRange;
 
-	FillCmd		eCmd = FILL_AUTO;
-	FillDateCmd	eDateCmd = FILL_DAY;
-	double		fStep = 1.0;
-	double		fMax = MAXDOUBLE;
 
 	switch (eDir)
 	{
Index: sc/source/ui/docshell/makefile.mk
===================================================================
--- sc/source/ui/docshell/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/docshell/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -95,7 +95,8 @@
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 
 EXCEPTIONSFILES= \
@@ -105,7 +106,8 @@
         $(SLO)$/docsh8.obj \
         $(SLO)$/externalrefmgr.obj \
         $(SLO)$/dbdocimp.obj \
-        $(SLO)$/docfunc.obj
+        $(SLO)$/docfunc.obj \
+	$(SLO)$/macromgr.obj
 
 SRS1NAME=$(TARGET)
 SRC1FILES =  tpstat.src
@@ -135,7 +137,8 @@
         $(SLO)$/hiranges.obj \
         $(SLO)$/pntlock.obj \
         $(SLO)$/sizedev.obj \
-        $(SLO)$/editable.obj
+        $(SLO)$/editable.obj \
+	$(SLO)$/macromgr.obj
 
 # --- Tagets -------------------------------------------------------
 
Index: sc/source/ui/docshell/docsh2.cxx
===================================================================
--- sc/source/ui/docshell/docsh2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/docshell/docsh2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -53,8 +53,11 @@
 #include <svx/unolingu.hxx>
 #include <rtl/logfile.hxx>
 
+#include <comphelper/processfactory.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <sfx2/app.hxx>
 
-
 // INCLUDE ---------------------------------------------------------------
 /*
 #include <svdrwetc.hxx>
@@ -102,6 +105,14 @@
 
 	InitItems();
 	CalcOutputFactor();
+	uno::Any aGlobs;
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[ 0 ] <<= GetModel();
+	aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.excel.Globals" ) ), aArgs );
+	GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+        BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
+        if ( pAppMgr )
+            pAppMgr->SetGlobalUNOConstant( "ThisExcelDoc", aArgs[ 0 ] );
 
 	return bRet;
 }
Index: sc/source/ui/docshell/docsh5.cxx
===================================================================
--- sc/source/ui/docshell/docsh5.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/docshell/docsh5.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -68,7 +68,12 @@
 #include "sc.hrc"
 #include "waitoff.hxx"
 #include "sizedev.hxx"
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
 
+// defined in docfunc.cxx
+void lcl_InsertModule( ScDocShell& rDocSh, SCTAB nTab, String& sModuleName, String& sModuleSource );
+
 // ---------------------------------------------------------------------------
 
 //
@@ -871,6 +876,43 @@
 				GetUndoManager()->AddUndoAction(
 						new ScUndoCopyTab( this, aSrcList, aDestList ) );
 			}
+			
+			StarBASIC* pStarBASIC = GetBasic();
+        		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+                        if ( GetBasicManager()->GetName().Len() > 0 )
+			{
+				aLibName = GetBasicManager()->GetName();
+				pStarBASIC = GetBasicManager()->GetLib( aLibName );
+			}
+			BOOL bVbaEnabled = pStarBASIC ? pStarBASIC->isVBAEnabled() : FALSE;
+			SCTAB nTabToUse = nDestTab; 
+
+			if ( nDestTab == SC_TAB_APPEND )
+				nTabToUse = aDocument.GetMaxTableNumber() - 1;
+
+			if ( bVbaEnabled )
+			{
+				String sCodeName;
+				String sSource;
+				aDocument.GetCodeName( nTabToUse, sCodeName );
+				com::sun::star::uno::Reference< com::sun::star::script::XLibraryContainer > xLibContainer = GetBasicContainer();
+				com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLib;
+    				if( xLibContainer.is() )
+    				{
+        				com::sun::star::uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        				aLibAny >>= xLib;
+    				}
+    				if( xLib.is() )
+    				{
+					String sSrcCodeName;
+					aDocument.GetCodeName( nSrcTab, sSrcCodeName );
+					rtl::OUString sModName = sSrcCodeName;
+					com::sun::star::script::ModuleInfo sModuleInfo;
+					xLib->getByName( sModName ) >>= sModuleInfo;
+					sSource = sModuleInfo.ModuleSource;
+				} 
+				lcl_InsertModule( *this, nTabToUse, sCodeName, sSource );
+			}
 		}
 
 		Broadcast( ScTablesHint( SC_TAB_COPIED, nSrcTab, nDestTab ) );
Index: sc/source/ui/docshell/docsh.cxx
===================================================================
--- sc/source/ui/docshell/docsh.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/docshell/docsh.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -128,6 +128,14 @@
 #include <rtl/logfile.hxx>
 
 #include <comphelper/processfactory.hxx>
+#include "uiitems.hxx"
+#include "cellsuno.hxx"
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 
 using namespace com::sun::star;
 
@@ -273,7 +281,12 @@
 void ScDocShell::BeforeXMLLoading()
 {
     aDocument.DisableIdle( TRUE );
-
+    // suppress VBA events when loading the xml
+    uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+    if ( xEvt.is() )
+       xEvt->setIgnoreEvents( sal_True );
+    
+// if VBA enabled then we need to  
     // prevent unnecessary broadcasts and updates
     DBG_ASSERT(pModificator == NULL, "The Modificator should not exist");
 	pModificator = new ScDocShellModificator( *this );
@@ -358,7 +371,30 @@
     }
     else
 		aDocument.SetInsertingFromOtherDoc( FALSE );
-
+	// add vba globals ( if they are availabl )
+	uno::Any aGlobs;
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[ 0 ] <<= GetModel();
+	aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.excel.Globals" ) ), aArgs );
+	GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+        // Fake ThisComponent being setup by Activate ( which is a view 
+        // related thing ), 
+        //  a) if another document is opened then in theory  ThisComponent
+        //     will be reset as before, 
+        //  b) when this document is  'really' Activated then ThisComponent
+        //     again will be set as before
+        // The only wrinkle seems if this document is loaded 'InVisible'
+        // but.. I don't see that this is possible from the vba API 
+        // I could be wrong though
+        // There may be implications setting the current component
+        // too early :-/ so I will just manually set the Basic Variables
+        BasicManager* pAppMgr = SFX_APP()->GetBasicManager();
+        if ( pAppMgr )
+            pAppMgr->SetGlobalUNOConstant( "ThisExcelDoc", aArgs[ 0 ] );
+        // suppress VBA events when loading the xml
+        uno::Reference< document::XVbaEventsHelper > xEvt( aDocument.GetVbaEventsHelper() );
+        if ( xEvt.is() )
+            xEvt->setIgnoreEvents( sal_False );
 	aDocument.SetImportingXML( FALSE );
     aDocument.EnableExecuteLink( true );
     aDocument.EnableUndo( TRUE );
@@ -480,9 +516,71 @@
 	return bRet;
 }
 
+void lcl_processCompatibleSfxHint( uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper, const SfxHint& rHint )
+{
+    if (rHint.ISA(ScTablesHint) )
+    {
+		USHORT nId = ((ScTablesHint&)rHint).GetId();	
+		SCTAB nTab = ((ScTablesHint&)rHint).GetTab1();	
+        if( nId == SC_TAB_INSERTED )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= nTab;
+            xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_NEWSHEET, aArgs );
+        }
+    }
+    else if ( rHint.ISA( SfxEventHint ) )
+    {
+        ULONG nEventId = ((SfxEventHint&)rHint).GetEventId();
+        switch ( nEventId )
+        {
+            case SFX_EVENT_ACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+                break;
+            case SFX_EVENT_DEACTIVATEDOC:
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_DEACTIVATE, aArgs );
+            }
+                break;
+            /*case SFX_EVENT_CLOSEDOC :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_CLOSE, aArgs );
+            }
+                break;
+            case SFX_EVENT_CLOSEVIEW :
+            {
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWCOLSE, aArgs );
+            }
+                break;
+            */    
+            case SFX_EVENT_OPENDOC:
+            {
+                // some later than workbook activate.
+                uno::Sequence< uno::Any > aArgs;
+                xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_OPEN, aArgs );
+            }
+                break;
+            default:
+                {
+                }
+                break;
+        }
+    }
+}
 
 void __EXPORT ScDocShell::Notify( SfxBroadcaster&, const SfxHint& rHint )
 {
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( xVbaEventsHelper.is() )
+    {
+        lcl_processCompatibleSfxHint( xVbaEventsHelper, rHint );
+    }
 	if (rHint.ISA(SfxSimpleHint))								// ohne Parameter
 	{
 		ULONG nSlot = ((const SfxSimpleHint&)rHint).GetId();
@@ -2129,6 +2227,16 @@
 
 	DoEnterHandler();
 
+	// start handler for possible veto from DocBefore_Close
+    uno::Sequence< uno::Any > aArgs;
+    uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( aDocument.GetVbaEventsHelper(), uno::UNO_QUERY );
+    if ( !IsInPrepareClose() && xVbaEventsHelper.is() )
+    {
+	    if ( xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_BEFORECLOSE, aArgs ) )
+		    return sal_False;
+    }
+	// end handler code
+
 	USHORT nRet = SfxObjectShell::PrepareClose( bUI, bForBrowsing );
 	if (nRet == TRUE)						// TRUE = schliessen
 		aDocument.DisableIdle(TRUE);		// nicht mehr drin rumpfuschen !!!
Index: sc/source/ui/docshell/macromgr.cxx
===================================================================
--- sc/source/ui/docshell/macromgr.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/docshell/macromgr.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+// INCLUDE ---------------------------------------------------------------
+
+#include "macromgr.hxx"
+#include "document.hxx"
+
+#include "basic/basmgr.hxx"
+#include "cppuhelper/implbase1.hxx"
+#include "sfx2/objsh.hxx"
+#include "cell.hxx"
+#include <com/sun/star/container/XContainer.hpp>
+
+#include <list>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::RuntimeException;
+using ::com::sun::star::uno::Reference;
+using ::rtl::OUString;
+using ::rtl::OUStringHash;
+using ::std::hash_map;
+using ::std::list;
+using ::std::for_each;
+using ::std::pair;
+
+// ============================================================================
+
+/** 
+ * A simple container to keep track of cells that depend on basic modules 
+ * changes.  We don't check for duplicates at insertion time; instead, we 
+ * remove duplicates at query time. 
+ */
+class ScUserMacroDepTracker
+{
+public:
+    void addCell(const OUString& rModuleName, ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+        {
+            pair<ModuleCellMap::iterator, bool> r = maCells.insert(
+                ModuleCellMap::value_type(rModuleName, list<ScFormulaCell*>()));
+
+            if (!r.second)
+                // insertion failed.
+                return;
+
+            itr = r.first;
+        }
+        itr->second.push_back(pCell);
+    }
+
+    void removeCell(ScFormulaCell* pCell)
+    {
+        ModuleCellMap::iterator itr = maCells.begin(), itrEnd = maCells.end();
+        for (; itr != itrEnd; ++itr)
+            itr->second.remove(pCell);
+    }
+
+    void getCellsByModule(const OUString& rModuleName, list<ScFormulaCell*>& rCells)
+    {
+        ModuleCellMap::iterator itr = maCells.find(rModuleName);
+        if (itr == maCells.end())
+            return;
+
+        list<ScFormulaCell*>& rCellList = itr->second;
+
+        // Remove duplicates.
+        rCellList.sort();
+        rCellList.unique();
+        // exception safe copy
+        list<ScFormulaCell*> temp(rCellList);
+        rCells.swap(temp);
+    }
+
+private:
+    typedef hash_map<OUString, list<ScFormulaCell*>, OUStringHash> ModuleCellMap;
+    ModuleCellMap maCells;
+};
+
+
+// ============================================================================
+
+ScMacroManager::ScMacroManager(ScDocument* pDoc) :
+    mpDepTracker(new ScUserMacroDepTracker),
+    mpDoc(pDoc)
+{
+}
+
+ScMacroManager::~ScMacroManager()
+{
+}
+
+typedef ::cppu::WeakImplHelper1< ::com::sun::star::container::XContainerListener > ContainerListenerHelper;
+
+class VBAProjectListener : public ContainerListenerHelper
+{
+    ScMacroManager* mpMacroMgr;
+public:
+    VBAProjectListener( ScMacroManager* pMacroMgr ) : mpMacroMgr( pMacroMgr ) {}
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& /*Source*/ ) throw(RuntimeException) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& Event ) throw(RuntimeException)
+    {
+        rtl::OUString sModuleName;
+        Event.Accessor >>= sModuleName;
+        OSL_TRACE("VBAProjectListener::elementReplaced(%s)", rtl::OUStringToOString( sModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mpMacroMgr->InitUserFuncData();
+        mpMacroMgr->BroadcastModuleUpdate(sModuleName);
+    }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& /*Event*/ ) throw(RuntimeException){}
+
+};
+
+void ScMacroManager::InitUserFuncData()
+{
+    // Clear hash_map
+    mhFuncToVolatile.clear();
+    String sProjectName( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+
+    Reference< container::XContainer > xModuleContainer;
+    SfxObjectShell* pShell = mpDoc->GetDocumentShell();
+    if ( pShell && pShell->GetBasicManager()->GetName().Len() > 0 )
+        sProjectName = pShell->GetBasicManager()->GetName();
+    try
+    { 
+        Reference< script::XLibraryContainer > xLibraries( pShell->GetBasicContainer(), uno::UNO_QUERY_THROW );
+        xModuleContainer.set( xLibraries->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+        
+        if ( xModuleContainer.is() )
+        {
+            // remove old listener ( if there was one )
+            if ( mxContainerListener.is() )
+                xModuleContainer->removeContainerListener( mxContainerListener );
+            // Create listener
+            mxContainerListener = new VBAProjectListener( this );
+            xModuleContainer->addContainerListener( mxContainerListener );
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+void ScMacroManager::SetUserFuncVolatile( const OUString& sName, bool isVolatile )
+{
+    mhFuncToVolatile[ sName ] = isVolatile;
+}
+
+bool ScMacroManager::GetUserFuncVolatile( const OUString& sName )
+{
+    NameBoolMap::iterator it = mhFuncToVolatile.find( sName );
+    if ( it == mhFuncToVolatile.end() )
+        return false;
+    return it->second;
+}
+
+void ScMacroManager::AddDependentCell(const OUString& aModuleName, ScFormulaCell* pCell)
+{
+    mpDepTracker->addCell(aModuleName, pCell);
+}
+
+void ScMacroManager::RemoveDependentCell(ScFormulaCell* pCell)
+{
+    mpDepTracker->removeCell(pCell);
+}
+
+void ScMacroManager::BroadcastModuleUpdate(const OUString& aModuleName)
+{
+    list<ScFormulaCell*> aCells;
+    mpDepTracker->getCellsByModule(aModuleName, aCells);
+    list<ScFormulaCell*>::iterator itr = aCells.begin(), itrEnd = aCells.end();
+    for (; itr != itrEnd; ++itr)
+    {   
+        ScFormulaCell* pCell = *itr; 
+        mpDoc->PutInFormulaTree(pCell); // for F9 recalc
+
+        // for recalc on cell value change.  If the cell is not volatile, the
+        // cell stops listening right away after it gets re-interpreted.
+        mpDoc->StartListeningArea(BCA_LISTEN_ALWAYS, pCell);
+    }
+}
+
Index: sc/source/ui/attrdlg/scdlgfact.hxx
===================================================================
--- sc/source/ui/attrdlg/scdlgfact.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/attrdlg/scdlgfact.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,7 @@
 class ScDataPilotSourceTypeDlg;
 class ScDataPilotServiceDlg;
 class ScDeleteCellDlg;
+class ScDataFormDlg;
 class ScDeleteContentsDlg;
 class ScFillSeriesDlg;
 class ScGroupDlg;
@@ -164,6 +165,12 @@
 	virtual DelCellCmd GetDelCellCmd() const;
 };
 
+//for dataform
+class AbstractScDataFormDlg_Impl : public AbstractScDataFormDlg  //add for ScDataFormDlg
+{
+	DECL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl,ScDataFormDlg);
+};
+
 class AbstractScDeleteContentsDlg_Impl : public AbstractScDeleteContentsDlg  //add for ScDeleteContentsDlg
 {
 	DECL_ABSTDLG_BASE( AbstractScDeleteContentsDlg_Impl,ScDeleteContentsDlg)
@@ -412,6 +419,9 @@
 	virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId,
 															BOOL bDisallowCellMove = FALSE ); //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell); //add for ScDeleteCellDlg
+
 	virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults = 0 );
 
Index: sc/source/ui/attrdlg/scdlgfact.cxx
===================================================================
--- sc/source/ui/attrdlg/scdlgfact.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/attrdlg/scdlgfact.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -80,7 +80,9 @@
 #include "tpstat.hxx" //add for ScDocStatPage
 #include "tpusrlst.hxx" //add for ScTpUserLists
 #include "tpview.hxx" //add for ScTpContentOptions
 #include "tpformula.hxx"
+//for dataform
+#include "datafdlg.hxx" //add for ScDataFormDlg
 
 // ause
 #include "editutil.hxx"
@@ -93,6 +95,8 @@
 IMPL_ABSTDLG_BASE(AbstractScDataPilotSourceTypeDlg_Impl); //add for ScDataPilotSourceTypeDlg
 IMPL_ABSTDLG_BASE(AbstractScDataPilotServiceDlg_Impl); //add for ScDataPilotServiceDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteCellDlg_Impl); //add for ScDeleteCellDlg
+//for dataform
+IMPL_ABSTDLG_BASE(AbstractScDataFormDlg_Impl); //add for ScDataFormDlg
 IMPL_ABSTDLG_BASE(AbstractScDeleteContentsDlg_Impl); //add for ScDeleteContentsDlg
 IMPL_ABSTDLG_BASE(AbstractScFillSeriesDlg_Impl); //add for ScFillSeriesDlg
 IMPL_ABSTDLG_BASE(AbstractScGroupDlg_Impl); //add for ScGroupDlg
@@ -820,6 +824,26 @@
 
 //add for ScDeleteCellDlg  end
 
+//add for ScDataFormDlg begin
+AbstractScDataFormDlg* ScAbstractDialogFactory_Impl::CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*	pTabViewShell )
+{
+	ScDataFormDlg * pDlg=NULL;
+	switch ( nId )
+	{
+		case RID_SCDLG_DATAFORM :
+			pDlg = new ScDataFormDlg( pParent, pTabViewShell);
+			break;
+		default:
+			break;
+	}
+
+	if ( pDlg )
+		return new AbstractScDataFormDlg_Impl( pDlg );
+	return 0;
+}
+
+//add for ScDataFormDlg  end
+
 //add for ScDeleteContentsDlg begin
 AbstractScDeleteContentsDlg* ScAbstractDialogFactory_Impl::CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults )
Index: sc/source/ui/undo/undodat.cxx
===================================================================
--- sc/source/ui/undo/undodat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/undo/undodat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,6 +54,8 @@
 #include "dpobject.hxx"
 #include "attrib.hxx"
 #include "sc.hrc"
+#include "chgtrack.hxx"  // Amelia Wang
+#include "refundo.hxx"  // Amelia Wang
 
 // -----------------------------------------------------------------------
 
@@ -74,6 +76,7 @@
 TYPEINIT1(ScUndoDataPilot,          ScSimpleUndo);
 TYPEINIT1(ScUndoConsolidate,        ScSimpleUndo);
 TYPEINIT1(ScUndoChartData,          ScSimpleUndo);
+TYPEINIT1(ScUndoDataForm,           SfxUndoAction);    // amelia
 
 // -----------------------------------------------------------------------
 
@@ -2179,8 +2182,210 @@
 	return FALSE;
 }
 
+// Amelia Wang
+ScUndoDataForm::ScUndoDataForm( ScDocShell* pNewDocShell,
+                                SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+                                SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+                                const ScMarkData& rMark,
+                                ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+                                USHORT nNewFlags,
+                                ScRefUndoData* pRefData,
+                                void* /*pFill1*/, void* /*pFill2*/, void* /*pFill3*/,
+                                BOOL bRedoIsFilled ) :
+        ScBlockUndo( pNewDocShell, ScRange( nStartX, nStartY, nStartZ, nEndX, nEndY, nEndZ ), SC_UNDO_SIMPLE ),
+        aMarkData( rMark ),
+        pUndoDoc( pNewUndoDoc ),
+        pRedoDoc( pNewRedoDoc ),
+        nFlags( nNewFlags ),
+        pRefUndoData( pRefData ),
+        pRefRedoData( NULL ),
+        bRedoFilled( bRedoIsFilled )
+{
+        //      pFill1,pFill2,pFill3 are there so the ctor calls for simple paste (without cutting)
+        //      don't have to be changed and branched for 641.
+        //      They can be removed later.
 
+        if ( !aMarkData.IsMarked() )                            // no cell marked:
+                aMarkData.SetMarkArea( aBlockRange );   //  mark paste block
 
+        if ( pRefUndoData )
+                pRefUndoData->DeleteUnchanged( pDocShell->GetDocument() );
 
+        SetChangeTrack();
+}
 
+ScUndoDataForm::~ScUndoDataForm()
+{
+        delete pUndoDoc;
+        delete pRedoDoc;
+        delete pRefUndoData;
+        delete pRefRedoData;
+}
 
+String ScUndoDataForm::GetComment() const
+{
+        return ScGlobal::GetRscString( STR_UNDO_PASTE ); 
+}
+
+void ScUndoDataForm::SetChangeTrack()
+{
+        ScChangeTrack* pChangeTrack = pDocShell->GetDocument()->GetChangeTrack();
+        if ( pChangeTrack && (nFlags & IDF_CONTENTS) )
+                pChangeTrack->AppendContentRange( aBlockRange, pUndoDoc,
+                        nStartChangeAction, nEndChangeAction, SC_CACM_PASTE );
+        else
+                nStartChangeAction = nEndChangeAction = 0;
+}
+
+
+void ScUndoDataForm::Undo()
+{
+        BeginUndo();
+        DoChange( TRUE );
+        ShowTable( aBlockRange );
+        EndUndo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Redo()
+{
+        BeginRedo();
+        ScDocument* pDoc = pDocShell->GetDocument();
+        EnableDrawAdjust( pDoc, FALSE );                                //! include in ScBlockUndo?
+        DoChange( FALSE );
+        EnableDrawAdjust( pDoc, TRUE );                                 //! include in ScBlockUndo?
+        EndRedo();
+        SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+}
+
+void ScUndoDataForm::Repeat(SfxRepeatTarget& /*rTarget*/)
+{
+}
+
+BOOL ScUndoDataForm::CanRepeat(SfxRepeatTarget& rTarget) const
+{
+        return (rTarget.ISA(ScTabViewTarget));
+}
+
+void ScUndoDataForm::DoChange( const BOOL bUndo )
+{
+    ScDocument* pDoc = pDocShell->GetDocument();
+
+    //      RefUndoData for redo is created before first undo
+    //      (with DeleteUnchanged after the DoUndo call)
+    BOOL bCreateRedoData = ( bUndo && pRefUndoData && !pRefRedoData );
+    if ( bCreateRedoData )
+            pRefRedoData = new ScRefUndoData( pDoc );
+
+    ScRefUndoData* pWorkRefData = bUndo ? pRefUndoData : pRefRedoData;
+
+    //      fuer Undo immer alle oder keine Inhalte sichern
+    USHORT nUndoFlags = IDF_NONE;
+    if (nFlags & IDF_CONTENTS)
+            nUndoFlags |= IDF_CONTENTS;
+    if (nFlags & IDF_ATTRIB)
+            nUndoFlags |= IDF_ATTRIB;
+
+    BOOL bPaintAll = FALSE;
+
+    ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
+
+    // marking is in ScBlockUndo...
+    //ScUndoUtil::MarkSimpleBlock( pDocShell, aBlockRange );
+
+    SCTAB nTabCount = pDoc->GetTableCount();
+    if ( bUndo && !bRedoFilled )
+    {
+        if (!pRedoDoc)
+        {
+            BOOL bColInfo = ( aBlockRange.aStart.Row()==0 && aBlockRange.aEnd.Row()==MAXROW );
+            BOOL bRowInfo = ( aBlockRange.aStart.Col()==0 && aBlockRange.aEnd.Col()==MAXCOL );
+
+            pRedoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pRedoDoc->InitUndoSelected( pDoc, aMarkData, bColInfo, bRowInfo );
+        }
+        //  read "redo" data from the document in the first undo
+            //  all sheets - CopyToDocument skips those that don't exist in pRedoDoc
+        ScRange aCopyRange = aBlockRange;
+        aCopyRange.aStart.SetTab(0);
+        aCopyRange.aEnd.SetTab(nTabCount-1);
+        pDoc->CopyToDocument( aCopyRange, 1, FALSE, pRedoDoc );
+        bRedoFilled = TRUE;
+    }
+
+    USHORT nExtFlags = 0;
+    pDocShell->UpdatePaintExt( nExtFlags, aBlockRange );
+
+    for ( sal_uInt16 i=0; i <= ( aBlockRange.aEnd.Col() - aBlockRange.aStart.Col() ); i++ )
+    {
+        String aOldString;
+        pUndoDoc->GetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+        pDoc->SetString( aBlockRange.aStart.Col()+i , aBlockRange.aStart.Row() , aBlockRange.aStart.Tab() , aOldString );
+    }
+
+    //ScRange aTabSelectRange = aBlockRange;
+
+    if (pWorkRefData)
+    {
+        pWorkRefData->DoUndo( pDoc, TRUE );             // TRUE = bSetChartRangeLists for SetChartListenerCollection
+        if ( pDoc->RefreshAutoFilter( 0,0, MAXCOL,MAXROW, aBlockRange.aStart.Tab() ) )
+            bPaintAll = TRUE;
+    }
+
+    if ( bCreateRedoData && pRefRedoData )
+            pRefRedoData->DeleteUnchanged( pDoc );
+    
+    if ( bUndo )
+    {
+        ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+        if ( pChangeTrack )
+            pChangeTrack->Undo( nStartChangeAction, nEndChangeAction );
+    }
+    else
+        SetChangeTrack();
+
+    ScRange aDrawRange( aBlockRange );
+    pDoc->ExtendMerge( aDrawRange, TRUE );      // only needed for single sheet (text/rtf etc.)
+    USHORT nPaint = PAINT_GRID;
+    if (bPaintAll)
+    {
+        aDrawRange.aStart.SetCol(0);
+        aDrawRange.aStart.SetRow(0);
+        aDrawRange.aEnd.SetCol(MAXCOL);
+        aDrawRange.aEnd.SetRow(MAXROW);
+        nPaint |= PAINT_TOP | PAINT_LEFT;
+/*A*/   if (pViewShell)
+            pViewShell->AdjustBlockHeight(FALSE);
+    }
+    else
+    {
+        if ( aBlockRange.aStart.Row() == 0 && aBlockRange.aEnd.Row() == MAXROW )        // ganze Spalte
+        {
+            nPaint |= PAINT_TOP;
+            aDrawRange.aEnd.SetCol(MAXCOL);
+        }
+        if ( aBlockRange.aStart.Col() == 0 && aBlockRange.aEnd.Col() == MAXCOL )        // ganze Zeile
+        {
+            nPaint |= PAINT_LEFT;
+            aDrawRange.aEnd.SetRow(MAXROW);
+        }
+/*A*/   if ((pViewShell) && pViewShell->AdjustBlockHeight(FALSE))
+        {
+            aDrawRange.aStart.SetCol(0);
+            aDrawRange.aStart.SetRow(0);
+            aDrawRange.aEnd.SetCol(MAXCOL);
+            aDrawRange.aEnd.SetRow(MAXROW);
+            nPaint |= PAINT_LEFT;
+        }
+        pDocShell->UpdatePaintExt( nExtFlags, aDrawRange );
+    }
+
+    if ( !bUndo )                               //      draw redo after updating row heights
+        RedoSdrUndoAction( pDrawUndo );                 //!     include in ScBlockUndo?
+
+    pDocShell->PostPaint( aDrawRange, nPaint, nExtFlags );
+
+    pDocShell->PostDataChanged();
+    if (pViewShell)
+        pViewShell->CellContentChanged();
+}
Index: sc/source/ui/miscdlgs/makefile.mk
===================================================================
--- sc/source/ui/miscdlgs/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/miscdlgs/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,7 @@
 # --- Files --------------------------------------------------------
 
 SLOFILES =  \
+	$(SLO)$/datafdlg.obj		\
 	$(SLO)$/delcldlg.obj		\
 	$(SLO)$/inscldlg.obj		\
 	$(SLO)$/delcodlg.obj		\
Index: sc/source/ui/miscdlgs/datafdlg.cxx
===================================================================
--- sc/source/ui/miscdlgs/datafdlg.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/miscdlgs/datafdlg.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,422 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.cxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: kz $ $Date: 2006/07/21 14:04:33 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+#undef SC_DLLIMPLEMENTATION
+
+//------------------------------------------------------------------
+
+#include "datafdlg.hxx"
+#include "scresid.hxx"
+#include "datafdlg.hrc"
+#include "viewdata.hxx"
+//#include "document.hxx"
+#include "docsh.hxx"
+#include "refundo.hxx"
+#include "undodat.hxx"
+
+#define HDL(hdl)            LINK( this, ScDataFormDlg, hdl )
+
+//zhangyun
+ScDataFormDlg::ScDataFormDlg( Window* pParent, ScTabViewShell*  pTabViewShellOri) :
+    ModalDialog     ( pParent, ScResId( RID_SCDLG_DATAFORM ) ),
+    //
+    aBtnNew          ( this, ScResId( BTN_DATAFORM_NEW ) ),
+    aBtnDelete          ( this, ScResId( BTN_DATAFORM_DELETE ) ),
+    aBtnRestore          ( this, ScResId( BTN_DATAFORM_RESTORE ) ),
+    aBtnLast          ( this, ScResId( BTN_DATAFORM_LAST ) ),
+    aBtnNext          ( this, ScResId( BTN_DATAFORM_NEXT ) ),
+    aBtnClose          ( this, ScResId( BTN_DATAFORM_CLOSE ) ),
+    aSlider         ( this, ScResId( WND_DATAFORM_SCROLLBAR ) ),
+    aFixedText          ( this, ScResId( LAB_DATAFORM_RECORDNO ) )
+{
+    pTabViewShell = pTabViewShellOri;
+    FreeResource();
+    //read header form current document, and add new controls
+    DBG_ASSERT( pTabViewShell, "pTabViewShell is NULL! :-/" );
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    
+    pDoc = pViewData->GetDocument();
+    if (pDoc)
+    {
+        ScRange aRange;
+        pViewData->GetSimpleArea( aRange );
+        ScAddress aStart = aRange.aStart;
+        ScAddress aEnd = aRange.aEnd;
+        
+        nStartCol = aStart.Col();
+        nEndCol = aEnd.Col();
+        nStartRow   = aStart.Row();
+        nEndRow = aEnd.Row();
+        
+        nTab = pViewData->GetTabNo();
+        //if there is no selection
+        if ((nStartCol == nEndCol) && (nStartRow == nEndRow))
+            bNoSelection = TRUE;
+        
+        if (bNoSelection)
+        {
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                nEndCol++;
+                pDoc->GetString( nEndCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nEndCol--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                if (nStartCol <= 0)
+                    break;
+                nStartCol--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                int nColWidth = pDoc->GetColWidth( nEndCol, nTab );
+                if ( aColName.Len() == 0 && nColWidth)
+                {
+                    nStartCol++;
+                    break;
+                }
+            }
+            
+            //skip leading hide column
+            for (int i=1;i<=MAX_DATAFORM_COLS;i++)
+            {
+                String  aColName;
+                int nColWidth = pDoc->GetColWidth( nStartCol, nTab );
+                if (nColWidth)
+                    break;
+                nStartCol++;
+            }
+
+            if (nEndCol < nStartCol)
+                nEndCol = nStartCol;
+                
+            //find last not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                nEndRow++;
+                pDoc->GetString( nStartCol, nEndRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nEndRow--;
+                    break;
+                }
+            }
+            
+            //find first not blank cell in row
+            for (int i=1;i<=MAX_DATAFORM_ROWS;i++)
+            {
+                String  aColName;
+                if (nStartRow <= 0)
+                    break;
+                nStartRow--;
+
+                pDoc->GetString( nStartCol, nStartRow, nTab, aColName );
+                if ( aColName.Len() == 0 )
+                {
+                    nStartRow++;
+                    break;
+                }
+            }
+
+            if (nEndRow < nStartRow)
+                nEndRow = nStartRow;
+        }
+        
+        aCurrentRow = nStartRow + 1;
+        
+        String  aFieldName;
+
+        int nTop = 12;
+
+        Size    nFixedSize(FIXED_WIDTH, CTRL_HEIGHT );
+        Size    nEditSize(EDIT_WIDTH, CTRL_HEIGHT );
+        
+        //pFtArray = new FixedText(this);
+        aColLength = nEndCol - nStartCol + 1;
+        
+        //new the controls
+        pFixedTexts = new FixedText*[aColLength];
+        pEdits = new Edit*[aColLength];
+        
+        for(sal_uInt16 nIndex = 0; nIndex < aColLength; nIndex++)
+        {
+            pDoc->GetString( nIndex + nStartCol, nStartRow, nTab, aFieldName );
+            int nColWidth = pDoc->GetColWidth( nIndex + nStartCol, nTab );
+            if (nColWidth)
+            {
+                pFixedTexts[nIndex] = new FixedText(this);
+                pEdits[nIndex] = new Edit(this, WB_BORDER);
+        
+                pFixedTexts[nIndex]->SetSizePixel(nFixedSize);
+                pEdits[nIndex]->SetSizePixel(nEditSize);
+                pFixedTexts[nIndex]->SetPosPixel(Point(FIXED_LEFT, nTop));
+                pEdits[nIndex]->SetPosPixel(Point(EDIT_LEFT, nTop));
+                //pFixedTexts[nIndex]->SetText(String::CreateFromAscii("W4W-Filter Nr. "));
+                pFixedTexts[nIndex]->SetText(aFieldName);
+                pFixedTexts[nIndex]->Show();
+                pEdits[nIndex]->Show();
+                
+                nTop += LINE_HEIGHT;
+            }
+            else
+            {
+                pFixedTexts[nIndex] = NULL;
+                pEdits[nIndex] = NULL;
+            }
+        pEdits[nIndex]->SetModifyHdl( HDL(Impl_DataModifyHdl) );
+        }
+        
+        Size nDialogSize = this->GetSizePixel();
+        if (nTop > nDialogSize.Height())
+        {
+            nDialogSize.setHeight(nTop);
+            this->SetSizePixel(nDialogSize);
+        }
+        Size nScrollSize = aSlider.GetSizePixel();
+        nScrollSize.setHeight(nDialogSize.Height()-20);
+        aSlider.SetSizePixel(nScrollSize);
+    }
+    
+    FillCtrls(aCurrentRow);
+    
+    aSlider.SetPageSize( 10 );
+    aSlider.SetVisibleSize( 1 );
+    aSlider.SetLineSize( 1 );
+    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+    aSlider.Show();
+    
+    aBtnNew.SetClickHdl     ( HDL(Impl_NewHdl)    );
+    aBtnLast.SetClickHdl    ( HDL(Impl_LastHdl)    );
+    aBtnNext.SetClickHdl    ( HDL(Impl_NextHdl)    );
+    
+    aBtnRestore.SetClickHdl     ( HDL(Impl_RestoreHdl)    );
+    aBtnDelete.SetClickHdl  ( HDL(Impl_DeleteHdl)    );
+    aBtnClose.SetClickHdl   ( HDL(Impl_CloseHdl)    );
+    
+    aSlider.SetEndScrollHdl( HDL( Impl_ScrollHdl ) );
+
+    SetButtonState();
+
+    //end
+    //FreeResource();
+}
+
+ScDataFormDlg::~ScDataFormDlg()
+{
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+            delete pEdits[i];
+        if (pFixedTexts[i])
+            delete pFixedTexts[i];
+    }
+    if (pEdits)
+        delete pEdits;
+    if (pFixedTexts)
+        delete pFixedTexts;
+}
+
+void ScDataFormDlg::FillCtrls(SCROW /*nCurrentRow*/)
+{
+    //ScViewData*   pViewData = pTabViewShell->GetViewData();
+    
+    //pDoc = pViewData->GetDocument();
+    String  aFieldName;
+    int nRecordNum = nEndRow - nStartRow;
+    for(sal_uInt16 i = 0; i < aColLength; i++)
+    {
+        if (pEdits[i])
+        {
+            if (aCurrentRow<=nEndRow)
+            {
+                pDoc->GetString( i + nStartCol, aCurrentRow, nTab, aFieldName );
+                pEdits[i]->SetText(aFieldName);
+            }
+            else
+                pEdits[i]->SetText(String());
+        }
+    }
+    char sRecordStr[256];
+    if (aCurrentRow<=nEndRow)
+        aFixedText.SetText(String::CreateFromAscii(sRecordStr));
+    else
+        aFixedText.SetText(String::CreateFromAscii("New Record"));
+        
+    aSlider.SetThumbPos(aCurrentRow-nStartRow-1);
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DataModifyHdl, Edit*, pEdit)
+{
+    if ( pEdit->IsModified() )
+        aBtnRestore.Enable( TRUE );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NewHdl, PushButton*, EMPTYARG )
+{
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if ( pDoc )
+    {
+        sal_Bool bHasData = sal_False;
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+            if (pEdits[i])
+                if ( pEdits[i]->GetText().Len() != 0 )
+                {
+                    bHasData = sal_True;
+                    break;
+                }
+
+        if ( bHasData )
+        {
+            pTabViewShell->DataFormPutData( aCurrentRow , nStartRow , nStartCol , nEndRow , nEndCol , pEdits , aColLength );
+            aCurrentRow++;
+            if (aCurrentRow >= nEndRow + 2)
+            {
+                    nEndRow ++ ;
+                    aSlider.SetRange( Range( 0, nEndRow - nStartRow + 1) );
+            }
+            SetButtonState();
+            FillCtrls(aCurrentRow);
+            pDocSh->SetDocumentModified();
+            pDocSh->PostPaintGridAll();
+            }
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_LastHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow > nStartRow +1 )
+            aCurrentRow--;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_NextHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        if ( aCurrentRow <= nEndRow)
+            aCurrentRow++;
+
+        SetButtonState();
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_RestoreHdl, PushButton*, EMPTYARG )
+{   
+    if (pDoc)
+    {
+        FillCtrls(aCurrentRow);
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_DeleteHdl, PushButton*, EMPTYARG )
+{   
+    ScViewData* pViewData = pTabViewShell->GetViewData();
+    ScDocShell* pDocSh = pViewData->GetDocShell();
+    if (pDoc)
+    {
+        ScRange aRange(nStartCol, aCurrentRow, nTab, nEndCol, aCurrentRow, nTab);
+        pDoc->DeleteRow(aRange);
+        nEndRow--;
+        
+        SetButtonState();
+        pDocSh->GetUndoManager()->Clear();
+
+        FillCtrls(aCurrentRow);
+        pDocSh->SetDocumentModified();
+        pDocSh->PostPaintGridAll();
+    }
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_CloseHdl, PushButton*, EMPTYARG )
+{   
+    EndDialog( );
+    return 0;
+}
+
+IMPL_LINK( ScDataFormDlg, Impl_ScrollHdl, ScrollBar*, EMPTYARG )
+{   
+    long nOffset = aSlider.GetThumbPos();
+    aCurrentRow = nStartRow + nOffset + 1;
+    SetButtonState();
+    FillCtrls(aCurrentRow);
+    return 0;
+}
+
+void ScDataFormDlg::SetButtonState()
+{
+    if ( aCurrentRow > nEndRow )
+    {
+        aBtnDelete.Enable( FALSE );
+        aBtnLast.Enable( TRUE );
+        aBtnNext.Enable( FALSE );
+    }
+    else
+    {
+        aBtnDelete.Enable( TRUE );
+        aBtnNext.Enable( TRUE );
+    }
+    if ( 1 == aCurrentRow )
+        aBtnLast.Enable( FALSE );
+
+    aBtnRestore.Enable( FALSE );
+    if ( pEdits )
+        pEdits[0]->GrabFocus();
+}
Index: sc/source/ui/vba/vbaframe.hxx
===================================================================
--- sc/source/ui/vba/vbaframe.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaframe.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,58 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_FRAME_HXX
-#define SC_VBA_FRAME_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XLabel.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XLabel > FrameImpl_BASE;
-
-class ScVbaFrame : public FrameImpl_BASE
-{
-public:
-    ScVbaFrame(  const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_LABEL_HXX
Index: sc/source/ui/vba/vbafillformat.cxx
===================================================================
--- sc/source/ui/vba/vbafillformat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbafillformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,202 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbafillformat.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/awt/Gradient.hpp>
-#include <com/sun/star/awt/GradientStyle.hpp>
-#include <ooo/vba/office/MsoGradientStyle.hpp>
-#include "vbafillformat.hxx"
-#include "vbacolorformat.hxx"
-
-using namespace ooo::vba;
-using namespace com::sun::star;
-
-ScVbaFillFormat::ScVbaFillFormat( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape > xShape ) : ScVbaFillFormat_BASE( xParent, xContext ), m_xShape( xShape )
-{
-    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
-    m_nFillStyle = drawing::FillStyle_SOLID;
-    m_nForeColor = 0;
-    m_nBackColor = 0;
-    m_nGradientAngle = 0;
-}
-
-void
-ScVbaFillFormat::setFillStyle( drawing::FillStyle nFillStyle ) throw (uno::RuntimeException)
-{
-    m_nFillStyle = nFillStyle;
-    if( m_nFillStyle == drawing::FillStyle_GRADIENT )
-    {
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny( drawing::FillStyle_GRADIENT ) );
-        awt::Gradient aGradient;
-        // AXIAL
-        // RADIAL
-        // ELLIPTICAL
-        // SQUARE
-        // RECT
-        aGradient.Style = awt::GradientStyle_LINEAR;
-        aGradient.StartColor = ForeColor()->getRGB();
-        aGradient.EndColor = BackColor()->getRGB();
-        aGradient.Angle = m_nGradientAngle;
-        aGradient.Border = 0;
-        aGradient.XOffset = 0;
-        aGradient.YOffset = 0;
-        aGradient.StartIntensity = 100;
-        aGradient.EndIntensity = 100;
-        aGradient.StepCount = 1;
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillGradient"), uno::makeAny( aGradient ) );
-    }
-    else if( m_nFillStyle == drawing::FillStyle_SOLID )
-    {
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID) );
-    }
-}
-
-void
-ScVbaFillFormat::setForeColorAndInternalStyle( sal_Int32 nForeColor ) throw (css::uno::RuntimeException)
-{
-    m_nForeColor = nForeColor;
-    setFillStyle( m_nFillStyle );
-}
-
-// Attributes
-sal_Bool SAL_CALL 
-ScVbaFillFormat::getVisible() throw (uno::RuntimeException)
-{
-    drawing::FillStyle nFillStyle;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillStyle") ) >>= nFillStyle;
-    if( nFillStyle == drawing::FillStyle_NONE )
-        return sal_False;
-    return sal_True;
-}
-
-void SAL_CALL 
-ScVbaFillFormat::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
-{
-    drawing::FillStyle aFillStyle;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillStyle") ) >>= aFillStyle;
-    if( !_visible )
-    {
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny( drawing::FillStyle_NONE ) );
-    }
-    else
-    {
-        if( aFillStyle == drawing::FillStyle_NONE )
-        {
-            setFillStyle( m_nFillStyle );
-        }
-    }
-}
-
-double SAL_CALL 
-ScVbaFillFormat::getTransparency() throw (uno::RuntimeException)
-{
-    sal_Int16 nTransparence = 0;
-    double dTransparence = 0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "FillTransparence" ) ) >>= nTransparence;
-    dTransparence = static_cast<double>( nTransparence );
-    dTransparence /= 100;
-    return dTransparence;
-}
-
-void SAL_CALL 
-ScVbaFillFormat::setTransparency( double _transparency ) throw (uno::RuntimeException)
-{
-    sal_Int16 nTransparence = static_cast< sal_Int16 >( _transparency * 100 );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillTransparence" ), uno::makeAny( nTransparence ) );
-}
-
-
-// Methods
-void SAL_CALL 
-ScVbaFillFormat::Solid() throw (uno::RuntimeException)
-{
-    setFillStyle( drawing::FillStyle_SOLID );
-}
-
-void SAL_CALL 
-ScVbaFillFormat::TwoColorGradient( sal_Int32 style, sal_Int32 /*variant*/ ) throw (uno::RuntimeException)
-{
-    if( style == office::MsoGradientStyle::msoGradientHorizontal )
-    {
-        m_nGradientAngle = 0;
-        setFillStyle( drawing::FillStyle_GRADIENT );
-    }
-    else if( style == office::MsoGradientStyle::msoGradientVertical )
-    {
-        m_nGradientAngle = 900;
-        setFillStyle( drawing::FillStyle_GRADIENT );
-    }
-    else if( style == office::MsoGradientStyle::msoGradientDiagonalDown )
-    {
-        m_nGradientAngle = 450;
-        setFillStyle( drawing::FillStyle_GRADIENT );
-    }
-    else if( style == office::MsoGradientStyle::msoGradientDiagonalUp )
-    {
-        m_nGradientAngle = 900 + 450;
-        setFillStyle( drawing::FillStyle_GRADIENT );
-    }
-}
-
-uno::Reference< msforms::XColorFormat > SAL_CALL 
-ScVbaFillFormat::BackColor() throw (uno::RuntimeException)
-{
-    if( !m_xColorFormat.is() )
-        m_xColorFormat.set( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ColorFormatType::FILLFORMAT_BACKCOLOR ) );
-    return m_xColorFormat;
-}
-
-uno::Reference< msforms::XColorFormat > SAL_CALL 
-ScVbaFillFormat::ForeColor() throw (uno::RuntimeException)
-{
-    if( !m_xColorFormat.is() )
-        m_xColorFormat.set( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ColorFormatType::FILLFORMAT_FORECOLOR ) );
-    return m_xColorFormat;
-}
-
-
-rtl::OUString&
-ScVbaFillFormat::getServiceImplName()
-{
-    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFillFormat") );
-    return sImplName;
-}
-
-uno::Sequence< rtl::OUString >
-ScVbaFillFormat::getServiceNames()
-{
-    static uno::Sequence< rtl::OUString > aServiceNames;
-    if ( aServiceNames.getLength() == 0 )
-    {
-        aServiceNames.realloc( 1 );
-        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.FillFormat" ) );
-    }
-    return aServiceNames;
-}
-
Index: sc/source/ui/vba/vbacontrols.cxx
===================================================================
--- sc/source/ui/vba/vbacontrols.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacontrols.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,227 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-
-#include "vbacontrols.hxx"
-#include "vbacontrol.hxx"
-#include <cppuhelper/implbase2.hxx>
-#include <com/sun/star/awt/XControlContainer.hpp>
-#include <hash_map>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-typedef ::cppu::WeakImplHelper2< container::XNameAccess, container::XIndexAccess > ArrayWrapImpl;
-
-typedef  std::hash_map< rtl::OUString, sal_Int32, ::rtl::OUStringHash,
-    ::std::equal_to< ::rtl::OUString >  > ControlIndexMap;
-typedef  std::vector< uno::Reference< awt::XControl > > ControlVec;
-
-class ControlArrayWrapper : public ArrayWrapImpl
-{
-    uno::Reference< awt::XControlContainer > mxDialog;
-    uno::Sequence< ::rtl::OUString > msNames;
-    ControlVec mControls;
-    ControlIndexMap mIndices;
-
-    rtl::OUString getControlName( const uno::Reference< awt::XControl >& xCtrl )
-    {
-        uno::Reference< beans::XPropertySet > xProp( xCtrl->getModel(), uno::UNO_QUERY );
-        rtl::OUString sName;
-        xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ) ) >>= sName;
-        return sName;
-    }
-
-public:
-
-    ControlArrayWrapper( const uno::Reference< awt::XControl >& xDialog )
-    {
-        mxDialog.set( xDialog, uno::UNO_QUERY_THROW );
-        uno::Sequence< uno::Reference< awt::XControl > > sXControls = mxDialog->getControls();
-    
-        msNames.realloc( sXControls.getLength() );
-        for ( sal_Int32 i = 0; i < sXControls.getLength(); ++i )
-        {
-            uno::Reference< awt::XControl > xCtrl = sXControls[ i ];
-            msNames[ i ] = getControlName( xCtrl );
-            mControls.push_back( xCtrl );
-            mIndices[ msNames[ i ] ] = i;
-        }
-    }
-    
-    // XElementAccess
-    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
-    {
-        return awt::XControl::static_type(0);
-    }
-    
-    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
-    {
-        return ( mControls.size() > 0 );
-    }
-    
-    // XNameAcess 
-    virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-    {
-        if ( !hasByName( aName ) )
-            throw container::NoSuchElementException();
-        return getByIndex( mIndices[ aName ] );
-    }
-    
-    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
-    {
-        return msNames;
-    }
-    
-    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException)
-    {
-        ControlIndexMap::iterator it = mIndices.find( aName );
-        return it != mIndices.end();
-    }
-    
-    // XElementAccess
-    virtual ::sal_Int32 SAL_CALL getCount(  ) throw (css::uno::RuntimeException)
-    {
-        return mControls.size();
-    }
-    
-    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
-    {
-        if ( Index < 0 || Index >= static_cast< sal_Int32 >( mControls.size() ) )
-            throw lang::IndexOutOfBoundsException();
-        return uno::makeAny( mControls[ Index ] );
-    }
-};
-
-
-class ControlsEnumWrapper : public EnumerationHelper_BASE
-{
-    uno::Reference<XHelperInterface > m_xParent;
-    uno::Reference<uno::XComponentContext > m_xContext;
-    uno::Reference<container::XIndexAccess > m_xIndexAccess;
-    uno::Reference<awt::XControl > m_xDlg;
-    sal_Int32 nIndex;
-
-public:
-
-    ControlsEnumWrapper(  const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess, const uno::Reference< awt::XControl >& xDlg ) :  m_xParent( xParent ), m_xContext( xContext), m_xIndexAccess( xIndexAccess ), m_xDlg( xDlg ), nIndex( 0 ) {}
-
-    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
-    {
-        return ( nIndex < m_xIndexAccess->getCount() );
-    }
-
-    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-    {
-        if ( nIndex < m_xIndexAccess->getCount() )
-        {
-            uno::Reference< frame::XModel > xModel;
-            uno::Reference< uno::XInterface > xControl;
-            m_xIndexAccess->getByIndex( nIndex++ ) >>= xControl;
-            // Create control from awt::XControl
-            ScVbaControlFactory aFac( m_xContext, xControl,  xModel );
-            uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( m_xDlg->getModel() ) );
-            return uno::makeAny( xVBAControl );
-        }
-        throw container::NoSuchElementException();
-    }
-
-};
-
-
-uno::Reference<container::XIndexAccess >
-lcl_controlsWrapper( const uno::Reference< awt::XControl >& xDlg )
-{
-    return new ControlArrayWrapper( xDlg );
-}
-
-ScVbaControls::ScVbaControls( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext,
-                const css::uno::Reference< awt::XControl >& xDialog )
-            : ControlsImpl_BASE( xParent, xContext, lcl_controlsWrapper( xDialog  ) )
-{
-    mxDialog.set( xDialog, uno::UNO_QUERY_THROW );
-}
-
-uno::Reference< container::XEnumeration >
-ScVbaControls::createEnumeration() throw (uno::RuntimeException)
-{
-    uno::Reference< container::XEnumeration > xEnum( new ControlsEnumWrapper( mxParent, mxContext, m_xIndexAccess, mxDialog ) );
-    if ( !xEnum.is() )
-        throw uno::RuntimeException();
-    return xEnum;
-}
-
-uno::Any
-ScVbaControls::createCollectionObject( const css::uno::Any& aSource )
-{
-    // Create control from awt::XControl
-    uno::Reference< awt::XControl > xControl;
-    aSource >>= xControl;
-    uno::Reference< frame::XModel > xModel;
-    ScVbaControlFactory aFac( mxContext, xControl,  xModel );
-    uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( mxDialog->getModel() ) );
-    return uno::makeAny( xVBAControl );
-}
-
-void SAL_CALL 
-ScVbaControls::Move( double cx, double cy ) throw (uno::RuntimeException)
-{
-    uno::Reference< container::XEnumeration > xEnum( createEnumeration() );
-    while ( xEnum->hasMoreElements() )
-    {
-        uno::Reference< msforms::XControl > xControl( xEnum->nextElement(), uno::UNO_QUERY_THROW );
-        xControl->setLeft( xControl->getLeft() + cx );
-        xControl->setTop( xControl->getTop() + cy ); 
-    }
-}
-
-uno::Type
-ScVbaControls::getElementType() throw (uno::RuntimeException)
-{
-    return ooo::vba::msforms::XControl::static_type(0);
-}
-rtl::OUString& 
-ScVbaControls::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaControls") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaControls::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Controls" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbalineformat.hxx
===================================================================
--- sc/source/ui/vba/vbalineformat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalineformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,85 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalineformat.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_XLINEFORMAT_HXX
-#define SC_VBA_XLINEFORMAT_HXX
-
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/msforms/XLineFormat.hpp>
-#include "vbahelperinterface.hxx"
-
-typedef InheritedHelperInterfaceImpl1< ov::msforms::XLineFormat > ScVbaLineFormat_BASE;
-
-class ScVbaLineFormat : public ScVbaLineFormat_BASE
-{
-private:
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-    sal_Int32 m_nLineDashStyle;
-    double m_nLineWeight;
-protected:
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    sal_Int32 convertLineStartEndNameToArrowheadStyle( rtl::OUString sLineName );
-    rtl::OUString convertArrowheadStyleToLineStartEndName( sal_Int32 nArrowheadStyle ) throw (css::uno::RuntimeException);
-    sal_Int32 calculateArrowheadSize();
-public:
-    ScVbaLineFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape > xShape );
-
-    // Attributes
-    virtual sal_Int32 SAL_CALL getBeginArrowheadStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setBeginArrowheadStyle( sal_Int32 _beginarrowheadstyle ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getBeginArrowheadLength() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setBeginArrowheadLength( sal_Int32 _beginarrowheadlength ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getBeginArrowheadWidth() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setBeginArrowheadWidth( sal_Int32 _beginarrowheadwidth ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getEndArrowheadStylel() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setEndArrowheadStylel( sal_Int32 _endarrowheadstylel ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getEndArrowheadLength() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setEndArrowheadLength( sal_Int32 _endarrowheadlength ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getEndArrowheadWidth() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setEndArrowheadWidth( sal_Int32 _endarrowheadwidth ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getWeight() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setWeight( double _weight ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getTransparency() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setTransparency( double _transparency ) throw (css::uno::RuntimeException);
-    virtual sal_Int16 SAL_CALL getStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStyle( sal_Int16 _style ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getDashStyle() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setDashStyle( sal_Int32 _dashstyle ) throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL BackColor() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL ForeColor() throw (css::uno::RuntimeException);
-};
-
-#endif//SC_VBA_XLINEFORMAT_HXX
Index: sc/source/ui/vba/vbacombobox.hxx
===================================================================
--- sc/source/ui/vba/vbacombobox.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacombobox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,80 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacombobox.hxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_COMBOBOX_HXX
-#define SC_VBA_COMBOBOX_HXX
-#include <cppuhelper/implbase2.hxx>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/script/XDefaultProperty.hpp>
-#include <ooo/vba/msforms/XComboBox.hpp>
-#include <comphelper/proparrhlp.hxx>
-#include <comphelper/propertycontainer.hxx>
-#include <com/sun/star/beans/PropertyAttribute.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbalistcontrolhelper.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper2<ScVbaControl, ov::msforms::XComboBox, css::script::XDefaultProperty > ComboBoxImpl_BASE;
-class ScVbaComboBox : public ComboBoxImpl_BASE
-{		
-	std::auto_ptr< ListControlHelper > mpListHelper;
-	rtl::OUString sSourceName; 
-	rtl::OUString msDftPropName;
-	bool mbDialogType;
-	
-public:
-	ScVbaComboBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, bool bDialogType = false );
-
-	// Attributes
-	virtual css::uno::Any SAL_CALL getListIndex() throw (css::uno::RuntimeException);
-	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setListIndex( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-	virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
-
-	// Methods
-	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
-	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
-	// XControl
-    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
-
-	// XDefaultProperty
-        ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-	//XHelperInterface
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-
-#endif //
Index: sc/source/ui/vba/vbatogglebutton.cxx
===================================================================
--- sc/source/ui/vba/vbatogglebutton.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatogglebutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,108 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbatogglebutton.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-const static rtl::OUString TOGGLE( RTL_CONSTASCII_USTRINGPARAM("Toggle") );
-const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
-ScVbaToggleButton::ScVbaToggleButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : ToggleButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-    OSL_TRACE("ScVbaToggleButton(ctor)");
-    m_xProps->setPropertyValue( TOGGLE, uno::makeAny( sal_True ) );
-}
-
-ScVbaToggleButton::~ScVbaToggleButton()
-{
-    OSL_TRACE("~ScVbaToggleButton(dtor)");
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaToggleButton::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaToggleButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-
-uno::Any SAL_CALL 
-ScVbaToggleButton::getValue() throw (uno::RuntimeException)
-{
-	sal_Int16 nState = 0;
-    	m_xProps->getPropertyValue( STATE ) >>= nState;
- 	return uno::makeAny( nState ? sal_Int16( -1 ) : sal_Int16( 0 ) );
-}
-
-void SAL_CALL 
-ScVbaToggleButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-	sal_Int16 nState = 0;
-	_value >>= nState;
-        OSL_TRACE( "nState - %d", nState );
-	nState = ( nState == -1 ) ?  1 : 0;
-        OSL_TRACE( "nState - %d", nState );
-	m_xProps->setPropertyValue( STATE, uno::makeAny(  nState ) );
-}
-
-rtl::OUString& 
-ScVbaToggleButton::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaToggleButton") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaToggleButton::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ToggleButton" ) );
-	}
-	return aServiceNames;
-}
-
Index: sc/source/ui/vba/vbalabel.cxx
===================================================================
--- sc/source/ui/vba/vbalabel.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalabel.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,88 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalabel.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbalabel.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-ScVbaLabel::ScVbaLabel(  const css::uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : LabelImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaLabel::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaLabel::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-uno::Any SAL_CALL 
-ScVbaLabel::getValue() throw (css::uno::RuntimeException)
-{
-    return uno::makeAny( getCaption() );
-}
-
-void SAL_CALL 
-ScVbaLabel::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    rtl::OUString sCaption;
-    _value >>= sCaption;
-    setCaption( sCaption ); 
-}
-
-
-rtl::OUString& 
-ScVbaLabel::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaLabel") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaLabel::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Label" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbashapes.cxx
===================================================================
--- sc/source/ui/vba/vbashapes.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashapes.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,394 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashapes.cxx,v $
- * $Revision: 1.3.32.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/container/XNamed.hpp>
-#include <com/sun/star/view/XSelectionSupplier.hpp>
-#include <com/sun/star/text/WrapTextMode.hpp>
-#include <ooo/vba/msforms/XShapeRange.hpp>
-#include <ooo/vba/office/MsoAutoShapeType.hpp>
-
-#include "vbashapes.hxx"
-#include "vbashape.hxx"
-#include "vbashaperange.hxx"
-
-using namespace ::ooo::vba;
-using namespace ::com::sun::star;
-
-class VbShapeEnumHelper : public EnumerationHelper_BASE
-{
-        uno::Reference<msforms::XShapes > m_xParent;
-        uno::Reference<container::XIndexAccess > m_xIndexAccess;
-        sal_Int32 nIndex;
-public:
-	VbShapeEnumHelper( const uno::Reference< msforms::XShapes >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
-        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
-        {
-                return ( nIndex < m_xIndexAccess->getCount() );
-        }
-        virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-        {
-                ScVbaShapes* pShapes = dynamic_cast< ScVbaShapes* >(m_xParent.get());
-                if ( pShapes && hasMoreElements() )
-                    return pShapes->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
-                throw container::NoSuchElementException();
-        }
-
-};
-
-void ScVbaShapes::initBaseCollection()
-{
-	if ( m_xNameAccess.is() ) // already has NameAccess
-		return;
-	// no NameAccess then use ShapeCollectionHelper
-	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
-	sal_Int32 nLen = m_xIndexAccess->getCount();
-	mShapes.reserve( nLen );
-	for ( sal_Int32 index=0; index<nLen; ++index )
-		mShapes.push_back( uno::Reference< drawing::XShape >( m_xIndexAccess->getByIndex( index ) , uno::UNO_QUERY ) );
-	uno::Reference< container::XIndexAccess > xShapes( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
-	m_xIndexAccess.set( xShapes, uno::UNO_QUERY );
-	m_xNameAccess.set( xShapes, uno::UNO_QUERY );
-}
-
-ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes ): ScVbaShapes_BASE( xParent, xContext, xShapes ), m_nNewShapeCount(0)
-{
-    m_xShapes.set( xShapes, uno::UNO_QUERY_THROW );
-    m_xDrawPage.set( xShapes, uno::UNO_QUERY_THROW ); 
-    initBaseCollection();
-}
-
-uno::Reference< container::XEnumeration >
-ScVbaShapes::createEnumeration() throw (uno::RuntimeException)
-{
-    return new VbShapeEnumHelper( this,  m_xIndexAccess );
-}
-
-uno::Any
-ScVbaShapes::createCollectionObject( const css::uno::Any& aSource )
-{
-    if( aSource.hasValue() )
-    {
-        uno::Reference< drawing::XShape > xShape( aSource, uno::UNO_QUERY_THROW );
-        return uno::makeAny( uno::Reference< msforms::XShape >( new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, ScVbaShape::getType( xShape ) ) ) );
-    }
-    return uno::Any();
-}
-
-uno::Type
-ScVbaShapes::getElementType() throw (uno::RuntimeException)
-{
-    return ooo::vba::msforms::XShape::static_type(0);
-}
-rtl::OUString& 
-ScVbaShapes::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShapes") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaShapes::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Shapes" ) );
-	}
-	return aServiceNames;
-}
-
-css::uno::Reference< css::container::XIndexAccess > 
-ScVbaShapes::getShapesByArrayIndices( const uno::Any& Index  ) throw (uno::RuntimeException)
-{
-	if ( Index.getValueTypeClass() != uno::TypeClass_SEQUENCE )
-		throw uno::RuntimeException();
-	
-	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter(mxContext);
-	uno::Any aConverted;
-	aConverted = xConverter->convertTo( Index, getCppuType((uno::Sequence< uno::Any >*)0) );
-
-	uno::Sequence< uno::Any > sIndices;
-	aConverted >>= sIndices;
-	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
-	sal_Int32 nElems = sIndices.getLength();
-	for( sal_Int32 index = 0; index < nElems; ++index )
-	{
-		uno::Reference< drawing::XShape > xShape;
-		if ( sIndices[ index ].getValueTypeClass() == uno::TypeClass_STRING )
-		{
-			rtl::OUString sName;
-			sIndices[ index ] >>= sName;
-			xShape.set( m_xNameAccess->getByName( sName ), uno::UNO_QUERY );
-		}
-		else
-		{
-			sal_Int32 nIndex = 0;
-			sIndices[ index ] >>= nIndex;
-			// adjust for 1 based mso indexing
-			xShape.set( m_xIndexAccess->getByIndex( nIndex - 1 ), uno::UNO_QUERY );		
-			
-		}
-		// populate map with drawing::XShapes
-		if ( xShape.is() )
-			mShapes.push_back( xShape );
-	}  
-	uno::Reference< container::XIndexAccess > xIndexAccess( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
-	return xIndexAccess;
-}
-
-uno::Any SAL_CALL 
-ScVbaShapes::Item( const uno::Any& Index, const uno::Any& Index2 ) throw (uno::RuntimeException)
-{
-	// I don't think we need to support Array of indices for shapes	
-/*
-	if ( Index.getValueTypeClass() == uno::TypeClass_SEQUENCE )
-	{
-		uno::Reference< container::XIndexAccess > xIndexAccess( getShapesByArrayIndices( Index ) );
-		// return new collection instance
-		uno::Reference< XCollection > xShapesCollection(  new ScVbaShapes( this->getParent(), mxContext, xIndexAccess ) );
-		return uno::makeAny( xShapesCollection );
-	}
-*/
-	return 	ScVbaShapes_BASE::Item( Index, Index2 );
-}
-
-uno::Reference< msforms::XShapeRange > SAL_CALL 
-ScVbaShapes::Range( const uno::Any& shapes ) throw (css::uno::RuntimeException)
-{
-	// shapes, can be an index or an array of indices
-	uno::Reference< container::XIndexAccess > xShapes;
-	if ( shapes.getValueTypeClass() == uno::TypeClass_SEQUENCE )
-		xShapes = getShapesByArrayIndices( shapes );
-	else
-	{
-		// wrap single index into a sequence
-		uno::Sequence< uno::Any > sIndices(1);
-		sIndices[ 0 ] = shapes;
-		uno::Any aIndex;
-		aIndex <<= sIndices;
-		xShapes = getShapesByArrayIndices( aIndex );
-	}
-	return new ScVbaShapeRange(  getParent(), mxContext, xShapes, m_xDrawPage );
-}
-
-void SAL_CALL 
-ScVbaShapes::SelectAll() throw (uno::RuntimeException)
-{
-    uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    try
-    {
-        xSelectSupp->select( uno::makeAny( m_xShapes ) );
-    }
-    // viewuno.cxx ScTabViewObj::select will throw IllegalArgumentException
-    // if one of the shapes is no 'markable' e.g. a button 
-    // the method still works
-    catch( lang::IllegalArgumentException& )
-    {
-    }
-}
-
-uno::Reference< drawing::XShape > 
-ScVbaShapes::createShape( rtl::OUString service ) throw (css::uno::RuntimeException)
-{
-    uno::Reference< lang::XMultiServiceFactory > xMSF( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< drawing::XShape > xShape( xMSF->createInstance( service ), uno::UNO_QUERY_THROW );
-    return xShape;
-}
-
-uno::Any 
-ScVbaShapes::AddRectangle( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, uno::Any aRange ) throw (css::uno::RuntimeException)
-{
-    rtl::OUString sCreateShapeName( rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) );
-    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( startX );
-    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( startY );
-    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
-    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
-
-    uno::Reference< drawing::XShape > xShape( createShape( sCreateShapeName ), uno::UNO_QUERY_THROW );
-    m_xShapes->add( xShape );
-
-    rtl::OUString sName = createName( rtl::OUString::createFromAscii( "Rectangle" ) );
-    setDefaultShapeProperties( xShape );
-    setShape_NameProperty( xShape, sName );
-
-    awt::Point aMovePositionIfRange(0, 0);
-    awt::Point position;
-    position.X = nXPos - aMovePositionIfRange.X;
-    position.Y = nYPos - aMovePositionIfRange.Y;
-    xShape->setPosition( position );
-
-    awt::Size size;
-    size.Height = nHeight;
-    size.Width = nWidth;
-    xShape->setSize( size );
-
-    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, ScVbaShape::getType( xShape ) );
-    pScVbaShape->setRange( aRange ); 
-    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
-}
-
-uno::Any 
-ScVbaShapes::AddEllipse( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, uno::Any aRange ) throw (css::uno::RuntimeException)
-{
-    rtl::OUString sCreateShapeName( rtl::OUString::createFromAscii( "com.sun.star.drawing.EllipseShape" ) );
-    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( startX );
-    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( startY );
-    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
-    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
-
-    uno::Reference< drawing::XShape > xShape( createShape( sCreateShapeName ), uno::UNO_QUERY_THROW );
-    m_xShapes->add( xShape );
-
-    awt::Point aMovePositionIfRange( 0, 0 );
-    //TODO helperapi using a writer document
-    /*
-    XDocument xDocument = (XDocument)getParent();
-    if (AnyConverter.isVoid(_aRange))
-    {
-        _aRange = xDocument.Range(new Integer(0), new Integer(1));
-        // Top&Left in Word is Top&Left of the paper and not the writeable area.
-        aMovePositionIfRange = calculateTopLeftMargin((HelperInterfaceAdaptor)xDocument);
-    }
-
-    setShape_AnchorTypeAndRangeProperty(xShape, _aRange);
-    */
-    rtl::OUString name = createName( rtl::OUString::createFromAscii( "Oval" ));
-    setDefaultShapeProperties(xShape);
-    setShape_NameProperty(xShape, name);
-
-    awt::Point position;
-    position.X = nXPos - aMovePositionIfRange.X;
-    position.Y = nYPos - aMovePositionIfRange.Y;
-    xShape->setPosition(position);
-
-    awt::Size size;
-    size.Height = nHeight;
-    size.Width = nWidth;
-    xShape->setSize(size);
-
-    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, ScVbaShape::getType( xShape ) );
-    pScVbaShape->setRange( aRange ); 
-    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
-}
-
-//helpeapi calc
-uno::Any SAL_CALL
-ScVbaShapes::AddLine( sal_Int32 StartX, sal_Int32 StartY, sal_Int32 endX, sal_Int32 endY ) throw (uno::RuntimeException)
-{
-    sal_Int32 nLineWidth = endX - StartX;
-    sal_Int32 nLineHeight = endY - StartY;
-
-    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
-    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
-    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( StartX );
-    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( StartY );
-    
-    uno::Reference< drawing::XShape > xShape( createShape( rtl::OUString::createFromAscii("com.sun.star.drawing.LineShape") ), uno::UNO_QUERY_THROW );
-    m_xShapes->add( xShape );
-
-    awt::Point aMovePositionIfRange( 0, 0 );
-    
-    rtl::OUString name = createName( rtl::OUString::createFromAscii( "Line" ) );
-    setDefaultShapeProperties(xShape);
-    setShape_NameProperty(xShape, name);
-
-    awt::Point position;
-    position.X = nXPos - aMovePositionIfRange.X;
-    position.Y = nYPos - aMovePositionIfRange.Y;
-    xShape->setPosition(position);
-
-    awt::Size size;
-    size.Height = nHeight;
-    size.Width = nWidth;
-    xShape->setSize(size);
-
-    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, ScVbaShape::getType( xShape ) );
-    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
-}
-
-uno::Any SAL_CALL
-ScVbaShapes::AddShape( sal_Int32 _nType, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (uno::RuntimeException)
-{
-    uno::Any _aAnchor;
-    if (_nType == office::MsoAutoShapeType::msoShapeRectangle)
-    {
-        return AddRectangle(_nLeft, _nTop, _nWidth, _nHeight, _aAnchor);
-    }
-    else if (_nType == office::MsoAutoShapeType::msoShapeOval)
-    {
-        return AddEllipse(_nLeft, _nTop, _nWidth, _nHeight, _aAnchor);
-    }
-    return uno::Any();
-}
-
-void
-ScVbaShapes::setDefaultShapeProperties( uno::Reference< drawing::XShape > xShape ) throw (uno::RuntimeException)
-{
-    uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
-    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillStyle" ), uno::makeAny( rtl::OUString::createFromAscii( "SOLID" ) ) );
-    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillColor"), uno::makeAny( sal_Int32(0xFFFFFF) )  );
-    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextWordWrap"), uno::makeAny( text::WrapTextMode_THROUGHT )  );
-    //not find in OOo2.3
-    //xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "Opaque"), uno::makeAny( sal_True )  );
-}
-
-void
-ScVbaShapes::setShape_NameProperty( uno::Reference< css::drawing::XShape > xShape, rtl::OUString sName )
-{
-    uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
-    try
-    {
-        xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "Name" ), uno::makeAny( sName ) );
-    }
-    catch( script::BasicErrorException e )
-    {
-    }
-}
-
-rtl::OUString
-ScVbaShapes::createName( rtl::OUString sName )
-{
-    sal_Int32 nActNumber = 1 + m_nNewShapeCount;
-    m_nNewShapeCount++; 
-    sName += rtl::OUString::valueOf( nActNumber );
-    return sName;
-}
-
-#if 0
-//TODO helperapi using a writer document
-awt::Point
-calculateTopLeftMargin( uno::Reference< XHelperInterface > xDocument )
-{
-    awt::Point aPoint( 0, 0 );
-    uno::Reference< frame::XModel > xModel( xDocument, uno::UNO_QUERY_THROW );
-    return awt::Point();
-}
-#endif
Index: sc/source/ui/vba/vbahelper.hxx
===================================================================
--- sc/source/ui/vba/vbahelper.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbahelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,352 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbahelper.hxx,v $
- * $Revision: 1.5.32.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_HELPER_HXX
-#define SC_VBA_HELPER_HXX
-
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/beans/XIntrospectionAccess.hpp>
-#include <com/sun/star/script/BasicErrorException.hpp>
-#include <com/sun/star/script/XTypeConverter.hpp>
-#include <com/sun/star/lang/IllegalArgumentException.hpp>
-#include <com/sun/star/awt/XControl.hpp>
-#include <com/sun/star/awt/XDevice.hpp>
-#include <basic/sberrors.hxx>
-#include <cppuhelper/implbase1.hxx>
-#include <com/sun/star/frame/XModel.hpp>
-#include <docsh.hxx>
-#include <sfx2/dispatch.hxx>
-#include <ooo/vba/msforms/XShape.hpp>
-#include "cellsuno.hxx"
-
-namespace css = ::com::sun::star;
-
-namespace ooo 
-{
-	namespace vba 
-	{
-		template < class T > 
-		css::uno::Reference< T > getXSomethingFromArgs( css::uno::Sequence< css::uno::Any > const & args, sal_Int32 nPos, bool bCanBeNull = true ) throw (css::lang::IllegalArgumentException)
-		{
-			if ( args.getLength() < ( nPos + 1) )
-				throw css::lang::IllegalArgumentException();
-			css::uno::Reference< T > aSomething( args[ nPos ], css::uno::UNO_QUERY );
-			if ( !bCanBeNull && !aSomething.is() )
-				throw css::lang::IllegalArgumentException();
-			return aSomething;
-		}
-		css::uno::Reference< css::beans::XIntrospectionAccess > getIntrospectionAccess( const css::uno::Any& aObject ) throw (css::uno::RuntimeException);
-		css::uno::Reference< css::script::XTypeConverter > getTypeConverter( const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException);
-
-		void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl) ;
-		void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl, css::uno::Sequence< css::beans::PropertyValue >& sProps ) ;
-		void dispatchExecute(css::uno::Reference< css::frame::XModel>& xModel, USHORT nSlot, SfxCallMode nCall = SFX_CALLMODE_SYNCHRON );
-		void implnCopy();
-		void implnPaste();
-		void implnCut();
-		void implnPasteSpecial(sal_uInt16 nFlags,sal_uInt16 nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose);
-		css::uno::Reference< css::frame::XModel >
-			getCurrentDocument() throw (css::uno::RuntimeException);
-		ScTabViewShell* getBestViewShell( css::uno::Reference< css::frame::XModel>& xModel ) ;
-		ScDocShell* getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) ;
-		ScTabViewShell* getCurrentBestViewShell();
-		SfxViewFrame* getCurrentViewFrame();
-		sal_Int32 OORGBToXLRGB( sal_Int32 );
-		sal_Int32 XLRGBToOORGB( sal_Int32 );
-		css::uno::Any OORGBToXLRGB( const css::uno::Any& );
-		css::uno::Any XLRGBToOORGB( const css::uno::Any& );
-		// provide a NULL object that can be passed as variant so that 
-		// the object when passed to IsNull will return true. aNULL 
-		// contains an empty object reference
-		const css::uno::Any& aNULL();
-		void PrintOutHelper( const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName, css::uno::Reference< css::frame::XModel >& xModel, sal_Bool bSelection  );
-		void PrintPreviewHelper( const css::uno::Any& EnableChanges, css::uno::Reference< css::frame::XModel >& xModel );
-
-		rtl::OUString getAnyAsString( const css::uno::Any& pvargItem ) throw ( css::uno::RuntimeException );
-		rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike = false); // needs to be in an uno service ( already this code is duplicated in basic )
-	double getPixelTo100thMillimeterConversionFactor( css::uno::Reference< css::awt::XDevice >& xDevice, sal_Bool bVertical);
-	double PointsToPixels( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical);
-	double PixelsToPoints( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical);
-
-
-class ScVbaCellRangeAccess
-{
-public:
-    static SfxItemSet* GetDataSet( ScCellRangeObj* pRangeObj );
-};
-
-class Millimeter
-{
-//Factor to translate between points and hundredths of millimeters:
-private:
-	static const double factor;
-    
-	double m_nMillimeter;
-
-public:
-	Millimeter():m_nMillimeter(0) {}
-    
-	Millimeter(double mm):m_nMillimeter(mm) {}
-    
-	void set(double mm) { m_nMillimeter = mm; }
-	void setInPoints(double points) 
-	{ 
-		m_nMillimeter = points * 0.352777778; 
-		// 25.4mm / 72 
-	}
-      
-	void setInHundredthsOfOneMillimeter(double hmm)
-	{
-		m_nMillimeter = hmm / 100;
-	}
-    
-	double get()
-	{
-		return m_nMillimeter;
-	}
-	double getInHundredthsOfOneMillimeter()
-	{
-		return m_nMillimeter * 100;
-	}
-	double getInPoints()
-	{
-		return m_nMillimeter * 2.834645669; // 72 / 25.4mm
-	}    
-
-	static sal_Int32 getInHundredthsOfOneMillimeter(double points)
-	{
-		sal_Int32 mm = static_cast<sal_Int32>(points * factor);
-		return mm;
-	}
-    
-	static double getInPoints(int _hmm)
-	{
-		double points = double( static_cast<double>(_hmm) / factor);
-		return points;
-	}
-};
-
-class AbstractGeometryAttributes // probably should replace the ShapeHelper below
-{
-public:
-    virtual ~AbstractGeometryAttributes() {}
-    virtual double getLeft() = 0;
-    virtual void setLeft( double ) = 0;
-    virtual double getTop() = 0;
-    virtual void setTop( double ) = 0;
-    virtual double getHeight() = 0;
-    virtual void setHeight( double ) = 0;
-    virtual double getWidth() = 0;
-    virtual void setWidth( double ) = 0;
-};
-
-class ConcreteXShapeGeometryAttributes : public AbstractGeometryAttributes
-{
-public:
-    css::uno::Reference< ooo::vba::msforms::XShape > m_xShape; 
-    ConcreteXShapeGeometryAttributes( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape );
-    virtual double getLeft()
-    {
-        return m_xShape->getLeft();
-    }
-    virtual void setLeft( double nLeft )
-    {
-        m_xShape->setLeft( nLeft );
-    }
-    virtual double getTop()
-    {
-        return m_xShape->getTop();
-    }
-    virtual void setTop( double nTop )
-    {
-        m_xShape->setTop( nTop );
-    }
-
-    virtual double getHeight()
-    {
-        return m_xShape->getHeight();
-    }
-    virtual void setHeight( double nHeight )
-    {
-        m_xShape->setHeight( nHeight );
-    }
-    virtual double getWidth()
-    {
-        return m_xShape->getWidth();
-    }
-    virtual void setWidth( double nWidth)
-    {
-        m_xShape->setHeight( nWidth );
-    }
-
-   
-};
-#define VBA_LEFT "PositionX"
-#define VBA_TOP "PositionY"
-class UserFormGeometryHelper : public AbstractGeometryAttributes
-{
-
-    css::uno::Reference< css::beans::XPropertySet > mxModel;
-public:
-    UserFormGeometryHelper( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::awt::XControl >& xControl );
-    virtual double getLeft();
-    virtual void setLeft( double nLeft );
-    virtual double getTop();
-    virtual void setTop( double nTop );
-    virtual double getHeight();
-    virtual void setHeight( double nHeight );
-    virtual double getWidth();
-    virtual void setWidth( double nWidth);
-};
-
-class ShapeHelper
-{
-protected:
-	css::uno::Reference< css::drawing::XShape > xShape;
-public:
-	ShapeHelper( const css::uno::Reference< css::drawing::XShape >& _xShape) throw (css::script::BasicErrorException ) : xShape( _xShape )
-	{ 
-		if( !xShape.is() ) 
-			throw css::uno::RuntimeException( rtl::OUString::createFromAscii("No valid shape for helper"), css::uno::Reference< css::uno::XInterface >() );
-	}
-    
-	double getHeight()
-	{
-        	return  Millimeter::getInPoints(xShape->getSize().Height);
-    	}
-
-
-    	void setHeight(double _fheight) throw ( css::script::BasicErrorException )
-	{
-		try
-		{
-			css::awt::Size aSize = xShape->getSize();
-			aSize.Height = Millimeter::getInHundredthsOfOneMillimeter(_fheight);
-			xShape->setSize(aSize);
-		}
-		catch ( css::uno::Exception& /*e*/)
-		{
-			throw css::script::BasicErrorException( rtl::OUString(), css::uno::Reference< css::uno::XInterface >(), SbERR_METHOD_FAILED, rtl::OUString() );
-    		}
-	}
-    
-    
-	double getWidth()
-	{ 
-		return Millimeter::getInPoints(xShape->getSize().Width);
-    	}
-
-	void setWidth(double _fWidth) throw ( css::script::BasicErrorException )
-	{
-		try
-		{
-			css::awt::Size aSize = xShape->getSize();
-			aSize.Width = Millimeter::getInHundredthsOfOneMillimeter(_fWidth);
-			xShape->setSize(aSize);
-		}
-		catch (css::uno::Exception& /*e*/)
-		{
-			throw css::script::BasicErrorException( rtl::OUString(), css::uno::Reference< css::uno::XInterface >(), SbERR_METHOD_FAILED, rtl::OUString() );
-		}
-	}
-    
-    
-	double getLeft()
-	{
-		return Millimeter::getInPoints(xShape->getPosition().X);
-	}
-
-    
-	void setLeft(double _fLeft)
-	{
-		css::awt::Point aPoint = xShape->getPosition();
-		aPoint.X = Millimeter::getInHundredthsOfOneMillimeter(_fLeft);
-		xShape->setPosition(aPoint);
-	}
-    
-
-	double getTop()
-	{
-        	return Millimeter::getInPoints(xShape->getPosition().Y);
-	}
-
-    
-	void setTop(double _fTop)
-	{
-		css::awt::Point aPoint = xShape->getPosition();
-		aPoint.Y = Millimeter::getInHundredthsOfOneMillimeter(_fTop);
-		xShape->setPosition(aPoint);
-	}
-    
-};
-
-class ContainerUtilities
-{
-
-public: 
-	static rtl::OUString getUniqueName( const css::uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator);
-	static rtl::OUString getUniqueName( const css::uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix );
-
-	static sal_Int32 FieldInList( const css::uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString );
-};
-
-// really just a a place holder to ease the porting pain
-class DebugHelper
-{
-public:
-	static void exception( const rtl::OUString&  DetailedMessage, const css::uno::Exception& ex,  int err, const rtl::OUString& /*additionalArgument*/ ) throw( css::script::BasicErrorException )
-	{
-		// #TODO #FIXME ( do we want to support additionalArg here )
-		throw css::script::BasicErrorException( DetailedMessage.concat( rtl::OUString::createFromAscii(" ") ).concat( ex.Message ), css::uno::Reference< css::uno::XInterface >(), err, rtl::OUString() );
-	}
-
-	static void exception( int err,  const rtl::OUString& additionalArgument ) throw( css::script::BasicErrorException )
-	{
-		exception( rtl::OUString(), css::uno::Exception(), err, additionalArgument );
-	}
-
-	static void exception( css::uno::Exception& ex ) throw( css::script::BasicErrorException )
-	{
-		exception( rtl::OUString(), ex, SbERR_INTERNAL_ERROR, rtl::OUString() );
-	}
-};
-	} // openoffice
-} // org
-
-namespace ov = ooo::vba;
-
-#ifdef DEBUG
-#  define SC_VBA_FIXME(a) OSL_TRACE( a )
-#  define SC_VBA_STUB() SC_VBA_FIXME(( "%s - stubbed\n", __FUNCTION__ ))
-#else
-#  define SC_VBA_FIXME(a)
-#  define SC_VBA_STUB()
-#endif
-
-#endif
Index: sc/source/ui/vba/vbapictureformat.cxx
===================================================================
--- sc/source/ui/vba/vbapictureformat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapictureformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,147 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbapictureformat.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbapictureformat.hxx"
-
-using namespace ooo::vba;
-using namespace com::sun::star;
-
-ScVbaPictureFormat::ScVbaPictureFormat( const css::uno::Reference< ov::XHelperInterface >& xParent,
-    const css::uno::Reference< css::uno::XComponentContext >& xContext,
-    uno::Reference< drawing::XShape > xShape ) 
-    throw( lang::IllegalArgumentException ) : ScVbaPictureFormat_BASE( xParent, xContext ), m_xShape( xShape )
-{
-    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
-}
-
-void
-ScVbaPictureFormat::checkParameterRangeInDouble( double nRange, double nMin, double nMax ) throw (css::uno::RuntimeException)
-{
-    if( nRange < nMin )
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter out of range, value is too small.") , uno::Reference< uno::XInterface >() );
-    }
-    if( nRange > nMax )
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter out of range, value is too high.") , uno::Reference< uno::XInterface >() );
-    }
-}
-
-// Attributes
-double SAL_CALL 
-ScVbaPictureFormat::getBrightness() throw (uno::RuntimeException)
-{
-    sal_Int16 nLuminance = 0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("AdjustLuminance") ) >>= nLuminance;
-    double fBrightness = static_cast< double >( nLuminance );
-    fBrightness = ( fBrightness +100 ) / 200;
-    return fBrightness; 
-}
-
-void SAL_CALL 
-ScVbaPictureFormat::setBrightness( double _brightness ) throw (uno::RuntimeException)
-{
-    checkParameterRangeInDouble( _brightness, 0.0, 1.0 );
-    double fLuminance = _brightness * 200 - 100;
-    sal_Int16 nLuminance = static_cast< sal_Int16 >( fLuminance );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("AdjustLuminance"), uno::makeAny( nLuminance ) ); 
-}
-
-double SAL_CALL 
-ScVbaPictureFormat::getContrast() throw (uno::RuntimeException)
-{
-    sal_Int16 nContrast = 0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("AdjustContrast") ) >>= nContrast;
-    double fContrast = static_cast< double >( nContrast );
-    fContrast = ( fContrast + 100 ) / 200;
-    return fContrast;
-}
-
-void SAL_CALL 
-ScVbaPictureFormat::setContrast( double _contrast ) throw (uno::RuntimeException)
-{
-    checkParameterRangeInDouble( _contrast, 0.0, 1.0 );
-    double fContrast = _contrast * 200 - 100;
-    sal_Int16 nContrast = static_cast< sal_Int16 >( fContrast );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("AdjustContrast"), uno::makeAny( nContrast ) );
-}
-
-
-// Methods
-void SAL_CALL 
-ScVbaPictureFormat::IncrementBrightness( double increment ) throw (uno::RuntimeException)
-{
-    double fBrightness = getBrightness();
-    fBrightness += increment;
-    if( fBrightness < 0 )
-    {
-        fBrightness = 0.0;
-    }
-    if( fBrightness > 1 )
-    {
-        fBrightness = 1;
-    }
-    setBrightness( fBrightness );
-}
-
-void SAL_CALL 
-ScVbaPictureFormat::IncrementContrast( double increment ) throw (uno::RuntimeException)
-{
-    double nContrast = getContrast();
-    nContrast += increment;
-    if( increment < 0 )
-    {
-        increment = 0.0;
-    }
-    if( increment > 1 )
-    {
-        increment = 1.0;
-    }
-    setContrast( nContrast );
-}
-
-
-rtl::OUString&
-ScVbaPictureFormat::getServiceImplName()
-{
-    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaPictureFormat") );
-    return sImplName;
-}
-
-uno::Sequence< rtl::OUString >
-ScVbaPictureFormat::getServiceNames()
-{
-    static uno::Sequence< rtl::OUString > aServiceNames;
-    if ( aServiceNames.getLength() == 0 )
-    {
-        aServiceNames.realloc( 1 );
-        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.PictureFormat" ) );
-    }
-    return aServiceNames;
-}
Index: sc/source/ui/vba/vbacontrol.hxx
===================================================================
--- sc/source/ui/vba/vbacontrol.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacontrol.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,111 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacontrol.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_CONTROL_HXX
-#define SC_VBA_CONTROL_HXX
-
-#include <cppuhelper/implbase1.hxx>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/script/XDefaultProperty.hpp>
-#include <com/sun/star/drawing/XControlShape.hpp>
-#include <com/sun/star/awt/XControl.hpp>
-#include <com/sun/star/awt/XWindowPeer.hpp>
-#include <ooo/vba/msforms/XControl.hpp>
-
-#include "vbahelper.hxx"
-#include "vbahelperinterface.hxx"
-
-//typedef ::cppu::WeakImplHelper1< ov::msforms::XControl > ControlImpl_BASE;
-typedef InheritedHelperInterfaceImpl1< ov::msforms::XControl > ControlImpl_BASE;
-
-class ScVbaControl : public ControlImpl_BASE
-{
-private:
-    com::sun::star::uno::Reference< com::sun::star::lang::XEventListener > m_xEventListener;
-protected:
-    std::auto_ptr< ov::AbstractGeometryAttributes > mpGeometryHelper;
-    css::uno::Reference< css::beans::XPropertySet > m_xProps;
-    css::uno::Reference< css::uno::XInterface > m_xControl;
-    css::uno::Reference< css::frame::XModel > m_xModel;
-
-    virtual css::uno::Reference< css::awt::XWindowPeer > getWindowPeer() throw (css::uno::RuntimeException);
-public:
-    ScVbaControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, 
-                    const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pHelper );
-    virtual ~ScVbaControl();
-    // This class will own the helper, so make sure it is allocated from 
-    // the heap
-    void setGeometryHelper( ov::AbstractGeometryAttributes* pHelper );
-    // XControl
-    virtual sal_Bool SAL_CALL getEnabled() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setEnabled( sal_Bool _enabled ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setWidth( double _width ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getLeft() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setLeft( double _left ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getTop() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setTop( double _top ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL SetFocus(  ) throw (css::uno::RuntimeException);
-
-    virtual css::uno::Reference< css::uno::XInterface > SAL_CALL getObject() throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getControlSource() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setControlSource( const rtl::OUString& _controlsource ) throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getRowSource() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
-    //remove resouce because ooo.vba.excel.XControl is a wrapper of com.sun.star.drawing.XControlShape
-    virtual void removeResouce() throw( css::uno::RuntimeException );
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-
-
-class ScVbaControlFactory
-{
-public:
-    ScVbaControlFactory( const css::uno::Reference< css::uno::XComponentContext >& xContext, 
-                    const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel );
-    ScVbaControl* createControl()  throw ( css::uno::RuntimeException );
-    ScVbaControl* createControl( const css::uno::Reference< css::uno::XInterface >& xParent )  throw ( css::uno::RuntimeException );
-private:
-    ScVbaControl* createControl( const css::uno::Reference< css::awt::XControl >&, const css::uno::Reference< css::uno::XInterface >&  )  throw ( css::uno::RuntimeException );
-    ScVbaControl* createControl( const css::uno::Reference< css::drawing::XControlShape >&, const css::uno::Reference< css::uno::XInterface >& )  throw ( css::uno::RuntimeException );
-    css::uno::Reference< css::uno::XComponentContext > m_xContext;
-    css::uno::Reference< css::uno::XInterface > m_xControl;
-    css::uno::Reference< css::frame::XModel > m_xModel;
-};
-
-#endif//SC_VBA_CONTROL_HXX
Index: sc/source/ui/vba/vbacommandbars.cxx
===================================================================
--- sc/source/ui/vba/vbacommandbars.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbars.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,247 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include <com/sun/star/lang/XServiceInfo.hpp>
-#include <com/sun/star/frame/XDesktop.hpp>
-#include <com/sun/star/container/XNameAccess.hpp>
-
-#include "vbacommandbars.hxx"
-#include "vbacommandbar.hxx"
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-typedef ::cppu::WeakImplHelper1< container::XEnumeration > CommandBarEnumeration_BASE;
-
-static rtl::OUString sSpreadsheetDocumentUrl( rtl::OUString::createFromAscii( "com.sun.star.sheet.SpreadsheetDocument" ) );
-static rtl::OUString sTextDocumentUrl( rtl::OUString::createFromAscii( "com.sun.star.text.TextDocument" ) );
-static rtl::OUString sWindowStateConfUrl( rtl::OUString::createFromAscii( "com.sun.star.ui.WindowStateConfiguration" ) );
-
-class CommandBarEnumeration : public CommandBarEnumeration_BASE
-{
-    uno::Reference< uno::XComponentContext > m_xContext;
-    uno::Reference< XCommandBars > m_xCommandBars;
-    uno::Sequence< rtl::OUString > m_sNames;
-    sal_Int32 m_nCurrentPosition;
-public:
-    CommandBarEnumeration( const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBars > xCommandBars, const uno::Sequence< rtl::OUString > sNames ) : m_xContext( xContext ), m_xCommandBars( xCommandBars ), m_sNames( sNames ), m_nCurrentPosition( 0 )
-    {
-    }
-    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
-    {
-        if( m_nCurrentPosition < m_sNames.getLength() )
-            return sal_True;
-        return sal_False;
-    }
-    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
-    {
-        if( hasMoreElements() )
-        {
-            rtl::OUString sName( m_sNames[ m_nCurrentPosition ] );
-            m_nCurrentPosition = m_nCurrentPosition + 1;
-            if( sName.indexOf( rtl::OUString::createFromAscii("private:resource/toolbar/") ) != -1 ) 
-            {
-                sal_Int32 nLastIndex = sName.lastIndexOf( rtl::OUString::createFromAscii( "/" ) );
-                if( ( nLastIndex != -1 ) && ( ( nLastIndex + 1 ) < sName.getLength() ) )
-                {
-                   sName = sName.copy( nLastIndex + 1);
-                   if( sName.getLength() > 0 )
-                   {
-                        uno::Reference< XHelperInterface > xHelperInterface( m_xCommandBars, uno::UNO_QUERY_THROW );
-                        uno::Reference< XCommandBar > xCommandBar( new ScVbaCommandBar( xHelperInterface, m_xContext, sName, sal_True, sal_False ) );
-                        if( xCommandBar.is() )
-                            return uno::makeAny( xCommandBar );
-                        else
-                            return nextElement();
-                    }
-                    else
-                        return nextElement();
-                    }
-             }
-             else
-                return nextElement();
-        }
-        else
-            throw container::NoSuchElementException();
-        return uno::Any();
-    }
-};
-
-
-ScVbaCommandBars::ScVbaCommandBars( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< container::XIndexAccess > xIndexAccess ) : CommandBars_BASE( xParent, xContext, xIndexAccess )
-{
-    retrieveObjects();
-}
-void
-ScVbaCommandBars::retrieveObjects() throw ( uno::RuntimeException )
-{
-    uno::Reference< lang::XServiceInfo > xServiceInfo( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    if( xServiceInfo->supportsService( sSpreadsheetDocumentUrl ) )
-    {
-        m_sModuleName = sSpreadsheetDocumentUrl;
-    }
-    else if( xServiceInfo->supportsService( sTextDocumentUrl ) )
-    {
-        m_sModuleName = sTextDocumentUrl;
-    }
-    else
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Unsupported Document" ), uno::Reference< uno::XInterface >() );
-    
-    uno::Reference < lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-    uno::Reference < container::XNameAccess > xNameAccess( xMSF->createInstance( sWindowStateConfUrl ), uno::UNO_QUERY_THROW );
-    m_xNameAccess.set( xNameAccess->getByName( m_sModuleName ), uno::UNO_QUERY_THROW );
-}
-
-// XEnumerationAccess
-uno::Type SAL_CALL 
-ScVbaCommandBars::getElementType() throw ( uno::RuntimeException )
-{
-    return XCommandBars::static_type( 0 );
-}
-uno::Reference< container::XEnumeration >
-ScVbaCommandBars::createEnumeration() throw ( uno::RuntimeException )
-{
-    return uno::Reference< container::XEnumeration >( new CommandBarEnumeration( mxContext, this, m_xNameAccess->getElementNames() ) );
-}
-
-uno::Any
-ScVbaCommandBars::createCollectionObject( const uno::Any& aSource )
-{
-    // aSource should be a name at this time, because of the class is API wrapper.
-    rtl::OUString sToolBarName;
-    if( aSource >>= sToolBarName )
-    {
-        sToolBarName = sToolBarName.toAsciiLowerCase();
-        if( sToolBarName.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii("Worksheet Menu Bar") ) )
-        {
-            return uno::makeAny( uno::Reference< XCommandBar > ( new ScVbaCommandBar( this, mxContext, 0 ) ) );
-        }
-        else if( sToolBarName.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii("Menu Bar") ) )
-        {
-            return uno::makeAny( uno::Reference< XCommandBar > ( new ScVbaCommandBar( this, mxContext, 1 ) ) );
-        }
-        else if( checkToolBarExist( sToolBarName ) )
-        {
-            return uno::makeAny( uno::Reference< XCommandBar > (new ScVbaCommandBar( this, mxContext, sToolBarName, sal_True, sal_False ) ) );
-        }
-    }
-    return uno::Any();
-}
-
-// XCommandBars
-uno::Reference< XCommandBar > SAL_CALL 
-ScVbaCommandBars::Add( const css::uno::Any& Name, const css::uno::Any& /*Position*/, const css::uno::Any& /*MenuBar*/, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
-{
-    // Position - MsoBar MenuBar - sal_Bool
-    // Currently only the Name is supported.
-    rtl::OUString sName;
-    if( !( Name >>= sName ) )
-    {
-        sName = rtl::OUString::createFromAscii("Custom1");
-    }
-    sal_Bool bTemporary = false;
-    if( !( Temporary >>= bTemporary ) )
-    {
-        bTemporary = sal_True;
-    }
-    return uno::Reference< XCommandBar >( new ScVbaCommandBar( this, mxContext, sName.toAsciiLowerCase(), bTemporary, sal_True ) );
-}
-sal_Int32 SAL_CALL 
-ScVbaCommandBars::getCount() throw(css::uno::RuntimeException)
-{
-    // Filter out all toolbars from the window collection
-    sal_Int32 nCount = 0;
-    uno::Sequence< ::rtl::OUString > allNames = m_xNameAccess->getElementNames();
-    for( sal_Int32 i = 0; i < allNames.getLength(); i++ )
-    {
-        if(allNames[i].indexOf( rtl::OUString::createFromAscii("private:resource/toolbar/") ) != -1 )
-        {
-            nCount++;
-        }
-    }
-    return nCount;
-}
-
-// ScVbaCollectionBaseImpl
-uno::Any SAL_CALL
-ScVbaCommandBars::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
-{
-    if( aIndex.getValueTypeClass() == uno::TypeClass_STRING )
-    {
-        return createCollectionObject( aIndex );    
-    }
-    return uno::Any();
-}
-
-sal_Bool
-ScVbaCommandBars::checkToolBarExist( rtl::OUString sToolBarName )
-{
-    CommandBarNameMap::const_iterator iter = mCommandBarNameMap.find( sToolBarName.toAsciiLowerCase() );
-    if( iter != mCommandBarNameMap.end() )
-    {
-        return sal_True;
-    }    
-    uno::Sequence< ::rtl::OUString > allNames = m_xNameAccess->getElementNames();
-    for( sal_Int32 i = 0; i < allNames.getLength(); i++ )
-    {
-        if(allNames[i].indexOf( rtl::OUString::createFromAscii("private:resource/toolbar/") ) != -1 )
-        {
-            if( allNames[i].indexOf( sToolBarName ) != -1 )
-            {
-                return sal_True;
-            }
-        }
-    }
-    return sal_False;
-}
-    
-// XHelperInterface
-rtl::OUString& 
-ScVbaCommandBars::getServiceImplName()
-{
-    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBars") );
-    return sImplName;
-}
-uno::Sequence<rtl::OUString> 
-ScVbaCommandBars::getServiceNames()
-{
-    static uno::Sequence< rtl::OUString > aServiceNames;
-    if ( aServiceNames.getLength() == 0 )
-    {
-        aServiceNames.realloc( 1 );
-        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBars" ) );
-    }
-    return aServiceNames;
-}
-
Index: sc/source/ui/vba/vbatextbox.hxx
===================================================================
--- sc/source/ui/vba/vbatextbox.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,57 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbatextbox.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_TEXTBOX_HXX
-#define SC_VBA_TEXTBOX_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XTextBox.hpp>
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XTextBox > TextBoxImpl_BASE;
-
-class ScVbaTextBox : public TextBoxImpl_BASE
-{
-    bool mbDialog;
-public:
-    ScVbaTextBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, bool bDialog = false );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setText( const rtl::OUString& _text ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getMaxLength() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getMultiline() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMultiline( sal_Bool _multiline ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_TEXTBOX_HXX
Index: sc/source/ui/vba/vbashape.hxx
===================================================================
--- sc/source/ui/vba/vbashape.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashape.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,108 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashape.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_SHAPE_HXX
-#define SC_VBA_SHAPE_HXX
-
-#include <ooo/vba/office/MsoShapeType.hpp>
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/drawing/XShapes.hpp>
-#include <com/sun/star/lang/XEventListener.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/msforms/XShape.hpp>
-#include <ooo/vba/msforms/XLineFormat.hpp>
-#include <cppuhelper/implbase2.hxx>
-
-#include "vbahelperinterface.hxx"
-
-typedef  ::cppu::WeakImplHelper2< ov::msforms::XShape, css::lang::XEventListener > ListeningShape;
-
-typedef InheritedHelperInterfaceImpl< ListeningShape > ScVbaShape_BASE;
-
-class ScVbaShape : public ScVbaShape_BASE
-{
-friend class ConcreteXShapeHelper; // perhaps an accessor would be better
-private:
-protected:
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::drawing::XShapes > m_xShapes;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-    sal_Int32 m_nType;
-    css::uno::Any m_aRange;
-	virtual void addListeners();
-	virtual void removeShapeListener() throw( css::uno::RuntimeException );
-	virtual void removeShapesListener() throw( css::uno::RuntimeException );
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-public:
-    ScVbaShape( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape, const css::uno::Reference< css::drawing::XShapes >& xShapes, sal_Int32 nType ) throw ( css::lang::IllegalArgumentException );
-    ScVbaShape( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape ) throw ( css::lang::IllegalArgumentException );
-    virtual ~ScVbaShape();
-    css::uno::Any getRange() { return m_aRange; };
-    void setRange( css::uno::Any aRange ) { m_aRange = aRange; };
-
-    static sal_Int32 getType( const css::uno::Reference< css::drawing::XShape > xShape ) throw (css::uno::RuntimeException);
-
-    // Attributes
-    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setWidth( double _width ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getLeft() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setLeft( double _left ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getTop() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setTop( double _top ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getZOrderPosition() throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getRotation() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setRotation( double _rotation ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XLineFormat > SAL_CALL getLine() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XFillFormat > SAL_CALL getFill() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XPictureFormat > SAL_CALL getPictureFormat() throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual css::uno::Reference< ov::excel::XTextFrame > SAL_CALL TextFrame(  ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL Delete() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL ZOrder( sal_Int32 ZOrderCmd ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL ScaleHeight( double Factor, sal_Bool RelativeToOriginalSize, sal_Int32 Scale ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL ScaleWidth( double Factor, sal_Bool RelativeToOriginalSize, sal_Int32 Scale ) throw (css::uno::RuntimeException);
-    // Replace??
-    virtual void SAL_CALL Select( const css::uno::Any& Replace ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL ShapeRange( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
-    // XEventListener
-    virtual void SAL_CALL disposing( const css::lang::EventObject& rEventObject ) throw( css::uno::RuntimeException );
-};
-#endif//SC_VBA_SHAPE_HXX
Index: sc/source/ui/vba/vbauserform.hxx
===================================================================
--- sc/source/ui/vba/vbauserform.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbauserform.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,78 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_USERFORM_HXX
-#define SC_VBA_USERFORM_HXX
-
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XUserForm.hpp>
-#include <com/sun/star/awt/XDialog.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-
-#include "vbahelperinterface.hxx"
-#include "vbacontrol.hxx"
-
-//typedef InheritedHelperInterfaceImpl1< ov::msforms::XUserForm > ScVbaUserForm_BASE;
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XUserForm > ScVbaUserForm_BASE;
-
-class ScVbaUserForm : public ScVbaUserForm_BASE
-{
-private:
-    css::uno::Reference< css::awt::XDialog > m_xDialog;
-    ScDocShell* m_pDocShell;
-    bool mbDispose;
-protected:
-public:
-    ScVbaUserForm( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext ) throw ( css::lang::IllegalArgumentException );
-    virtual ~ScVbaUserForm();
-    // XUserForm
-    virtual void SAL_CALL RePaint(  ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL Show(  ) throw (css::uno::RuntimeException);
-    // XIntrospection
-    virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const ::rtl::OUString& aPropertyName, const css::uno::Any& aValue ) throw (css::beans::UnknownPropertyException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL getValue( const ::rtl::OUString& aPropertyName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException);
-    virtual ::sal_Bool SAL_CALL hasMethod( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
-    virtual ::sal_Bool SAL_CALL hasProperty( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
-    virtual ::rtl::OUString SAL_CALL getCaption() throw (::com::sun::star::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException);
-    virtual void SAL_CALL Hide(  ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL UnloadObject(  ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& index ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif
Index: sc/source/ui/vba/vbacommandbarcontrol.hxx
===================================================================
--- sc/source/ui/vba/vbacommandbarcontrol.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbarcontrol.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,90 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_COMMANDBARCONTROL_HXX
-#define SC_VBA_COMMANDBARCONTROL_HXX
-
-#include <ooo/vba/XCommandBarControl.hpp>
-
-#include "vbahelperinterface.hxx"
-#include "vbacommandbarcontrols.hxx"
-
-typedef InheritedHelperInterfaceImpl1< ov::XCommandBarControl > CommandBarControl_BASE;
-
-class ScVbaCommandBarControl : public CommandBarControl_BASE
-{
-private:
-    rtl::OUString       m_sName;
-    rtl::OUString       m_sBarName;
-    rtl::OUString       m_sCommand;
-    sal_Int32           m_nType;
-    sal_Int32           m_nPosition;
-    sal_Bool            m_bTemporary;
-    sal_Bool            m_bIsMenu;
-    ScVbaCommandBarControls*        m_pCommandBarControls;
-    css::uno::Reference< ov::XHelperInterface >               m_xParentHardRef;
-    css::uno::Reference< css::ui::XUIConfigurationManager >         m_xUICfgManager;
-    css::uno::Reference< css::ui::XUIConfigurationPersistence >     m_xUICfgPers;
-    css::uno::Reference< css::container::XIndexContainer >          m_xBarSettings;
-    css::uno::Reference< css::container::XIndexContainer >          m_xCurrentSettings;
-    css::beans::PropertyValues                                      m_aPropertyValues;
-    
-    void initObjects() throw (css::uno::RuntimeException);
-    void createNewMenuBarControl();
-    void createNewToolBarControl();
-public:
-    ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, rtl::OUString sName ) throw (css::uno::RuntimeException);
-    ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, rtl::OUString sName, rtl::OUString sCommand, sal_Int32 nPosition, sal_Bool bTemporary ) throw (css::uno::RuntimeException);
-    sal_Int32 GetPosition() { return m_nPosition; };
-    css::uno::Reference< css::container::XIndexContainer > GetCurrentSettings() { return m_xCurrentSettings; };
-    css::beans::PropertyValues GetPropertyValues() { return m_aPropertyValues; };
-    void SetPropertyValues( css::beans::PropertyValues aPropertyValues ) { m_aPropertyValues = aPropertyValues; };
-    
-    // Attributes
-    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    virtual ::rtl::OUString SAL_CALL getOnAction() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setOnAction( const ::rtl::OUString& _onaction ) throw (css::uno::RuntimeException);
-    virtual ::sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( ::sal_Bool _visible ) throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-
-	// XHelperInterface
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif//SC_VBA_COMMANDBARCONTROL_HXX
Index: sc/source/ui/vba/vbaprogressbar.cxx
===================================================================
--- sc/source/ui/vba/vbaprogressbar.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaprogressbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,78 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbaprogressbar.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-// uno servicename com.sun.star.awt.UnoControlProgressBarMode
-const rtl::OUString SVALUE( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") );
-
-ScVbaProgressBar::ScVbaProgressBar( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ProgressBarImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-uno::Any SAL_CALL 
-ScVbaProgressBar::getValue() throw (css::uno::RuntimeException)
-{
-    return m_xProps->getPropertyValue( SVALUE );
-}
-
-void SAL_CALL 
-ScVbaProgressBar::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SVALUE,  _value );
-}
-
-rtl::OUString& 
-ScVbaProgressBar::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaProgressBar") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaProgressBar::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Label" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbafillformat.hxx
===================================================================
--- sc/source/ui/vba/vbafillformat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbafillformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,74 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbafillformat.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_XFILLFORMAT_HXX
-#define SC_VBA_XFILLFORMAT_HXX
-
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/drawing/FillStyle.hpp>
-#include <ooo/vba/msforms/XFillFormat.hpp>
-#include "vbahelperinterface.hxx"
-
-typedef InheritedHelperInterfaceImpl1< ov::msforms::XFillFormat > ScVbaFillFormat_BASE;
-
-class ScVbaFillFormat : public ScVbaFillFormat_BASE
-{
-private:
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-    css::uno::Reference< ov::msforms::XColorFormat > m_xColorFormat;
-    css::drawing::FillStyle m_nFillStyle;
-    sal_Int32 m_nForeColor;
-    sal_Int32 m_nBackColor;
-    sal_Int16 m_nGradientAngle;
-private:
-    void setFillStyle( css::drawing::FillStyle nFillStyle ) throw (css::uno::RuntimeException);
-protected:
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-
-public:
-    ScVbaFillFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape > xShape );
-
-    void setForeColorAndInternalStyle( sal_Int32 nForeColor ) throw (css::uno::RuntimeException);
-    // Attributes
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getTransparency() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setTransparency( double _transparency ) throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual void SAL_CALL Solid() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL TwoColorGradient( sal_Int32 style, sal_Int32 variant ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL BackColor() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL ForeColor() throw (css::uno::RuntimeException);
-
-};
-
-#endif//SC_VBA_XFILLFORMAT_HXX
Index: sc/source/ui/vba/vbacontrols.hxx
===================================================================
--- sc/source/ui/vba/vbacontrols.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacontrols.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,62 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_CONTROLS_HXX
-#define SC_VBA_CONTROLS_HXX
-
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XControls.hpp>
-#include <com/sun/star/awt/XControl.hpp>
-
-#include "vbacollectionimpl.hxx"
-#include "vbahelper.hxx"
-
-typedef CollTestImplHelper< ov::msforms::XControls > ControlsImpl_BASE;
-
-class ScVbaControls : public ControlsImpl_BASE
-{
-	css::uno::Reference< css::awt::XControl > mxDialog;
-protected:
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-public:
-    ScVbaControls( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, 
-                    const css::uno::Reference< css::awt::XControl >& xDialog );
-    // XControls
-     virtual void SAL_CALL Move( double cx, double cy ) throw (css::uno::RuntimeException);
-    // XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
-
-    // ScVbaCollectionBaseImpl
-    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-    
-};
-#endif //SC_VBA_OLEOBJECTS_HXX
-
Index: sc/source/ui/vba/vbalistcontrolhelper.cxx
===================================================================
--- sc/source/ui/vba/vbalistcontrolhelper.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalistcontrolhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,145 +0,0 @@
-#include <vbalistcontrolhelper.hxx>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
-
-void SAL_CALL 
-ListControlHelper::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
-{
-	if ( pvargItem.hasValue()  )
-	{
-		uno::Sequence< rtl::OUString > sList;
-		m_xProps->getPropertyValue( ITEMS ) >>= sList;
-
-		sal_Int32 nIndex = sList.getLength();
-
-		if ( pvargIndex.hasValue() )
-			pvargIndex >>= nIndex;
-
-		rtl::OUString sString = getAnyAsString( pvargItem );
-
-		// if no index specified or item is to be appended to end of 
-		// list just realloc the array and set the last item
-		if ( nIndex  == sList.getLength() )
-		{
-			sal_Int32 nOldSize = sList.getLength();
-			sList.realloc( nOldSize + 1 );
-			sList[ nOldSize ] = sString; 
-		}
-		else
-		{
-			// just copy those elements above the one to be inserted
-			std::vector< rtl::OUString > sVec;
-			// reserve just the amount we need to copy
-			sVec.reserve( sList.getLength() - nIndex );
-
-			// point at first element to copy
-			rtl::OUString* pString = sList.getArray() + nIndex;
-			const rtl::OUString* pEndString = sList.getArray() + sList.getLength();
-			// insert the new element
-			sVec.push_back( sString );
-			// copy elements	
-			for ( ; pString != pEndString; ++pString )
-				sVec.push_back( *pString );
-		
-			sList.realloc(  sList.getLength() + 1 );
-
-			// point at first element to be overwritten
-			pString = sList.getArray() + nIndex;
-			pEndString = sList.getArray() + sList.getLength();
-			std::vector< rtl::OUString >::iterator it = sVec.begin();
-			for ( ; pString != pEndString; ++pString, ++it)
-				*pString = *it;	
-			//
-		}
-
-		m_xProps->setPropertyValue( ITEMS, uno::makeAny( sList ) );
-		
-	}
-}
-
-void SAL_CALL 
-ListControlHelper::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
-{
-    sal_Int32 nIndex = 0;
-    // for int index
-	if ( index >>= nIndex  )
-	{
-		uno::Sequence< rtl::OUString > sList;
-		m_xProps->getPropertyValue( ITEMS ) >>= sList;
-        if( nIndex < 0 || nIndex > ( sList.getLength() - 1 ) )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid index" ), uno::Reference< uno::XInterface > () );
-        if( sList.hasElements() )
-        {
-            if( sList.getLength() == 1 )
-            {
-                Clear();
-                return;
-            }
-            for( sal_Int32 i = nIndex; i < ( sList.getLength()-1 ); i++ )
-            {
-                sList[i] = sList[i+1];
-            }
-			sList.realloc(  sList.getLength() - 1 );
-		}
-
-		m_xProps->setPropertyValue( ITEMS, uno::makeAny( sList ) );
-	}
-}
-
-void SAL_CALL 
-ListControlHelper::Clear(  ) throw (uno::RuntimeException)
-{
-	// urk, setValue doesn't seem to work !!
-	//setValue( uno::makeAny( sal_Int16() ) );
-	m_xProps->setPropertyValue( ITEMS, uno::makeAny( uno::Sequence< rtl::OUString >() ) );
-}
-
-void SAL_CALL
-ListControlHelper::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
-{
-	if ( _rowsource.getLength() == 0 )
-		Clear();
-}
-
-sal_Int32 SAL_CALL
-ListControlHelper::getListCount() throw (uno::RuntimeException)
-{
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    return sList.getLength();
-}
-
-uno::Any SAL_CALL 
-ListControlHelper::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
-{
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
-    uno::Any aRet;
-    if ( pvargIndex.hasValue() )
-    {
-        sal_Int16 nIndex = -1;
-        pvargIndex >>= nIndex;
-        if( nIndex < 0 || nIndex >= nLength )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
-        aRet <<= sList[ nIndex ];
-    }
-    else if ( pvarColumn.hasValue() ) // pvarColumn on its own would be bad
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
-    else // List() ( e.g. no args )
-    {
-        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
-        for ( sal_Int32 i = 0; i < nLength; ++i )
-        {
-            sReturnArray[ i ].realloc( 10 );
-            sReturnArray[ i ][ 0 ] = sList[ i ];
-        }        
-        aRet = uno::makeAny( sReturnArray );
-    }
-    return aRet;
-}
Index: sc/source/ui/vba/vbacollectionimpl.cxx
===================================================================
--- sc/source/ui/vba/vbacollectionimpl.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacollectionimpl.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,136 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacollectionimpl.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <vbacollectionimpl.hxx>
-#include "vbaglobals.hxx"
-using namespace ::com::sun::star;
-using namespace ::ooo::vba;
-
-
-ScVbaCollectionBaseImpl::ScVbaCollectionBaseImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) throw (uno::RuntimeException) : m_xContext( xContext ), m_xIndexAccess( xIndexAccess )
-{
-	m_xNameAccess.set( xIndexAccess, uno::UNO_QUERY );
-}
-
-uno::Any
-ScVbaCollectionBaseImpl::getItemByStringIndex( const rtl::OUString& sIndex ) throw (::uno::RuntimeException)
-{
-	if ( !m_xNameAccess.is() )
-		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBaseImpl string index access not supported by this object") ), uno::Reference< uno::XInterface >() );
-
-	return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
-}
-
-uno::Any 
-ScVbaCollectionBaseImpl::getItemByIntIndex( const sal_Int32 nIndex ) throw (uno::RuntimeException)
-{
-	if ( !m_xIndexAccess.is() )
-		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBaseImpl numeric index access not supported by this object") ), uno::Reference< uno::XInterface >() );
-	if ( nIndex <= 0 )
-	{
-		throw  lang::IndexOutOfBoundsException( 
-			::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
-			"index is 0 or negative" ) ), 
-			uno::Reference< uno::XInterface >() );
-	}
-	// need to adjust for vba index ( for which first element is 1 )
-	return createCollectionObject( m_xIndexAccess->getByIndex( nIndex - 1 ) );	
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaCollectionBaseImpl::getCount() throw (uno::RuntimeException)
-{
-	return m_xIndexAccess->getCount();
-}
-
-uno::Any SAL_CALL 
-ScVbaCollectionBaseImpl::getParent() throw (uno::RuntimeException)
-{
-	// #TODO #FIXME investigate whether this makes sense
-	uno::Reference< excel::XApplication > xApplication =
-		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
-	uno::Reference< excel::XWorkbook > xWorkbook;
-	if ( xApplication.is() )
-	{
-		xWorkbook = xApplication->getActiveWorkbook();
-	}
-	return uno::Any( xWorkbook );
-}
-
-::sal_Int32 SAL_CALL ScVbaCollectionBaseImpl::getCreator() throw (uno::RuntimeException)
-{
-	// #TODO #FIXE some sort of implementation
-	//SC_VBA_STUB();
-	return 0;
-}
-uno::Reference< excel::XApplication > SAL_CALL ScVbaCollectionBaseImpl::getApplication() throw (uno::RuntimeException)
-{
-	// #TODO #FIXME investigate whether this makes sense
-	uno::Reference< excel::XApplication > xApplication =
-		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
-	return  xApplication;
-}
-
-uno::Any SAL_CALL ScVbaCollectionBaseImpl::Item( const uno::Any& aIndex ) throw (uno::RuntimeException)
-{
-	if ( aIndex.getValueTypeClass() != uno::TypeClass_STRING )
-	{
-		sal_Int32 nIndex = 0;
-
-		if ( ( aIndex >>= nIndex ) != sal_True )
-		{
-			rtl::OUString message;
-			message = rtl::OUString::createFromAscii(
-				"Couldn't convert index to Int32");
-			throw  lang::IndexOutOfBoundsException( message,
-				uno::Reference< uno::XInterface >() );
-		}
-		return 	getItemByIntIndex( nIndex );
-	}
-	rtl::OUString aStringSheet;
-
-	aIndex >>= aStringSheet;
-	return getItemByStringIndex( aStringSheet );	
-}
-
-::rtl::OUString SAL_CALL 
-ScVbaCollectionBaseImpl::getDefaultMethodName(  ) throw (css::uno::RuntimeException)
-{
-	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
-	return sName;
-}
-
-	// XElementAccess
-
-::sal_Bool SAL_CALL ScVbaCollectionBaseImpl::hasElements() throw (uno::RuntimeException)
-{
-	return ( m_xIndexAccess->getCount() > 0 );
-}
-
-
Index: sc/source/ui/vba/vbatogglebutton.hxx
===================================================================
--- sc/source/ui/vba/vbatogglebutton.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatogglebutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,63 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_TOGGLEBUTTON_HXX
-#define SC_VBA_TOGGLEBUTTON_HXX
-#include <cppuhelper/implbase2.hxx>
-#include <ooo/vba/msforms/XToggleButton.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XToggleButton, css::script::XDefaultProperty  > ToggleButtonImpl_BASE;
-
-class ScVbaToggleButton : public ToggleButtonImpl_BASE
-{
-	rtl::OUString msDftPropName;
-public:
-    ScVbaToggleButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-    ~ScVbaToggleButton();
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-};
-#endif //SC_VBA_TOGGLEBUTTON_HXX
Index: sc/source/ui/vba/vbalistbox.cxx
===================================================================
--- sc/source/ui/vba/vbalistbox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalistbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,289 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalistbox.cxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/form/validation/XValidatableFormComponent.hpp>
-
-#include "vbalistbox.hxx"
-#include "vbapropvalue.hxx"
-#include <vector>
-#include <comphelper/anytostring.hxx>
-#include <com/sun/star/script/ArrayWrapper.hpp>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-const static rtl::OUString TEXT( RTL_CONSTASCII_USTRINGPARAM("Text") );
-const static rtl::OUString SELECTEDITEMS( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") );
-const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
-
-
-ScVbaListBox::ScVbaListBox( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< css::uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ListBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-    mpListHelper.reset( new ListControlHelper( m_xProps ) );
-}
-
-// Attributes
-void SAL_CALL 
-ScVbaListBox::setListIndex( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-    sal_Int32 nIndex = 0;
-    _value >>= nIndex;
-    Selected( nIndex );
-}
-
-uno::Any SAL_CALL 
-ScVbaListBox::getListIndex() throw (uno::RuntimeException)
-{
-    uno::Sequence< sal_Int16 > sSelection;
-    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= sSelection;
-    if ( sSelection.getLength() == 0 )
-        return uno::Any( sal_Int32( -1 ) );
-    return uno::Any( sSelection[ 0 ] );
-}
-
-uno::Any SAL_CALL 
-ScVbaListBox::getValue() throw (uno::RuntimeException)
-{
-    uno::Sequence< sal_Int16 > sSelection;
-    uno::Sequence< rtl::OUString > sItems;
-    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= sSelection;
-    m_xProps->getPropertyValue( ITEMS ) >>= sItems;
-    if( getMultiSelect() )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
-    uno::Any aRet;
-    if ( sSelection.getLength() )
-        aRet = uno::makeAny( sItems[ sSelection[ 0 ] ] ); 
-    return aRet;
-}
-
-void SAL_CALL 
-ScVbaListBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-    if( getMultiSelect() )
-    {	
-        throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
-    }
-    rtl::OUString sValue = getAnyAsString( _value );
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    uno::Sequence< sal_Int16 > nList;
-    sal_Int16 nLength = static_cast<sal_Int16>( sList.getLength() );
-    sal_Int16 nValue = -1;
-    sal_Int16 i = 0;
-    for( i = 0; i < nLength; i++ )
-    {
-        if( sList[i].equals( sValue ) )
-        {
-            nValue = i; 
-            break;
-        }
-    }
-    if( nValue == -1 )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
-
-    uno::Sequence< sal_Int16 > nSelectedIndices(1);
-    nSelectedIndices[ 0 ] = nValue;
-    m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nSelectedIndices ) ); 
-    m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) ); 
-}
-
-::rtl::OUString SAL_CALL 
-ScVbaListBox::getText() throw (uno::RuntimeException)
-{
-	rtl::OUString result;
-	getValue() >>= result;
-	return result;
-}
-
-void SAL_CALL 
-ScVbaListBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
-{
-	setValue( uno::makeAny( _text ) ); // seems the same
-}
-
-sal_Bool SAL_CALL 
-ScVbaListBox::getMultiSelect() throw (css::uno::RuntimeException)
-{
-    sal_Bool bMultiSelect = sal_False;
-    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ) ) >>= bMultiSelect;
-    return bMultiSelect;
-}
-
-void SAL_CALL 
-ScVbaListBox::setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( _multiselect ) );
-}
-
-css::uno::Any SAL_CALL 
-ScVbaListBox::Selected( sal_Int32 index ) throw (css::uno::RuntimeException)
-{
-    uno::Sequence< rtl::OUString > sList;
-    m_xProps->getPropertyValue( ITEMS ) >>= sList;
-    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
-    // no choice but to do a horror cast as internally
-    // the indices are but sal_Int16 
-    sal_Int16 nIndex = static_cast< sal_Int16 >( index );
-    if( nIndex < 0 || nIndex >= nLength )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Error Number." ), uno::Reference< uno::XInterface >() );
-    m_nIndex = nIndex;
-    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( this ) ) );
-}
-
-// Methods
-void SAL_CALL 
-ScVbaListBox::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
-{
-	mpListHelper->AddItem( pvargItem, pvargIndex );
-		}
-
-void SAL_CALL 
-ScVbaListBox::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
-{
-	mpListHelper->removeItem( index );
-}
-
-void SAL_CALL 
-ScVbaListBox::Clear(  ) throw (uno::RuntimeException)
-{
-	mpListHelper->Clear();
-}
-
-// this is called when something like the following vba code is used
-// to set the selected state of particular entries in the Listbox
-// ListBox1.Selected( 3 ) = false
-//PropListener
-void 
-ScVbaListBox::setValueEvent( const uno::Any& value )
-{
-    sal_Bool bValue = sal_False;
-    if( !(value >>= bValue) )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Invalid type\n. need boolean." ), uno::Reference< uno::XInterface >() );
-    uno::Sequence< sal_Int16 > nList;
-    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= nList;
-    sal_Int16 nLength = static_cast<sal_Int16>( nList.getLength() );
-    sal_Int16 nIndex = m_nIndex;
-    for( sal_Int16 i = 0; i < nLength; i++ )
-    {
-        if( nList[i] == nIndex )
-        {
-            if( bValue )
-                return;
-            else
-            {
-                for( ; i < nLength - 1; i++ )
-                {
-                    nList[i] = nList[i + 1];
-                }
-                nList.realloc( nLength - 1 );
-                //m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
-		m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nList ) );
-                return;
-            }
-        }
-    }
-    if( bValue )
-    {
-        if( getMultiSelect() )
-        {
-            nList.realloc( nLength + 1 );
-            nList[nLength] = nIndex;
-        }
-        else
-        {
-            nList.realloc( 1 );
-            nList[0] = nIndex;
-        }
-        m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
-    }
-}
-
-// this is called when something like the following vba code is used
-// to determine the selected state of particular entries in the Listbox
-// msgbox ListBox1.Selected( 3 )
-
-css::uno::Any 
-ScVbaListBox::getValueEvent()
-{
-    uno::Sequence< sal_Int16 > nList;
-    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "SelectedItems" ) ) ) >>= nList;
-    sal_Int32 nLength = nList.getLength();
-    sal_Int32 nIndex = m_nIndex;
-    
-    for( sal_Int32 i = 0; i < nLength; i++ )
-    {
-        if( nList[i] == nIndex )
-            return uno::makeAny( sal_True );
-    }
-
-    return uno::makeAny( sal_False );
-}
-
-void SAL_CALL
-ScVbaListBox::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
-{
-	ScVbaControl::setRowSource( _rowsource );
-	mpListHelper->setRowSource( _rowsource );
-}
-
-sal_Int32 SAL_CALL
-ScVbaListBox::getListCount() throw (uno::RuntimeException)
-{
-	return mpListHelper->getListCount();
-}
-
-uno::Any SAL_CALL 
-ScVbaListBox::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
-{
-	return mpListHelper->List( pvargIndex, pvarColumn );
-}
-
-rtl::OUString& 
-ScVbaListBox::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaListBox") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaListBox::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ScVbaListBox" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbalabel.hxx
===================================================================
--- sc/source/ui/vba/vbalabel.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalabel.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,56 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalabel.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_LABEL_HXX
-#define SC_VBA_LABEL_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XLabel.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-#include <cppuhelper/implbase2.hxx>
-
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XLabel, css::script::XDefaultProperty  > LabelImpl_BASE;
-
-class ScVbaLabel : public LabelImpl_BASE
-{
-public:
-    ScVbaLabel( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-};
-#endif //SC_VBA_LABEL_HXX
Index: sc/source/ui/vba/vbamultipage.cxx
===================================================================
--- sc/source/ui/vba/vbamultipage.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbamultipage.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,132 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbamultipage.hxx"
-#include <ooo/vba/XCollection.hpp>
-#include "vbapages.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-// uno servicename com.sun.star.awt.UnoControlProgressBarMode
-const rtl::OUString SVALUE( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") );
-const rtl::OUString SVALUEMAX( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") );
-const rtl::OUString SSTEP( RTL_CONSTASCII_USTRINGPARAM("Step") );
-
-typedef cppu::WeakImplHelper1< container::XIndexAccess > PagesImpl_Base;
-class PagesImpl : public PagesImpl_Base
-{
-	sal_Int32 mnPages;
-public:
-	PagesImpl( sal_Int32 nPages ) : mnPages( nPages ) {}
-	virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException) { return mnPages; }
-	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, ::uno::RuntimeException)
-	{
-		if ( Index < 0 || Index > mnPages )
-			throw lang::IndexOutOfBoundsException();
-		return uno::makeAny( uno::Reference< uno::XInterface >() );
-	}
-	// XElementAccess
-	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
-	{
-		// no Pages object yet #FIXME
-		//return msforms::XPage::static_type(0);
-		return uno::XInterface::static_type(0);
-	}
-	virtual ::sal_Bool SAL_CALL hasElements( ) throw (uno::RuntimeException)
-	{
-		return ( mnPages > 0 );
-	}
-};
-uno::Reference< container::XIndexAccess > 
-ScVbaMultiPage::getPages( sal_Int32 nPages )
-{
-	return new PagesImpl( nPages );
-}
-
-ScVbaMultiPage::ScVbaMultiPage( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, const uno::Reference< uno::XInterface >& xDialog ) : MultiPageImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-    mxDialogProps.set( xDialog, uno::UNO_QUERY_THROW );
-    // set dialog step to value of multipage pseudo model
-    setValue(getValue());
-}
-
-// Attributes
-sal_Int32 SAL_CALL 
-ScVbaMultiPage::getValue() throw (css::uno::RuntimeException)
-{
-    sal_Int32 nValue = 0;
-    m_xProps->getPropertyValue( SVALUE ) >>= nValue;
-    return nValue;
-}
-
-void SAL_CALL 
-ScVbaMultiPage::setValue( const sal_Int32 _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    // track change in dialog ( dialog value is 1 based, 0 is a special value )
-    m_xProps->setPropertyValue( SVALUE, uno::makeAny( _value ) );
-    mxDialogProps->setPropertyValue( SSTEP, uno::makeAny( _value + 1) );
-}
-
-
-rtl::OUString& 
-ScVbaMultiPage::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMultiPage") );
-	return sImplName;
-}
-
-uno::Any SAL_CALL 
-ScVbaMultiPage::Pages( const uno::Any& index ) throw (uno::RuntimeException)
-{
-	sal_Int32 nValue = 0;
-	m_xProps->getPropertyValue( SVALUEMAX ) >>= nValue;
-	uno::Reference< XCollection > xColl( new ScVbaPages( this, mxContext, getPages( nValue ) ) );
-	if ( !index.hasValue() )
-		return uno::makeAny( xColl );
-	return xColl->Item( uno::makeAny( index ), uno::Any() );
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaMultiPage::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.MultiPage" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbashapes.hxx
===================================================================
--- sc/source/ui/vba/vbashapes.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashapes.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,80 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashapes.hxx,v $
- * $Revision: 1.3.32.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_SHAPES_HXX
-#define SC_VBA_SHAPES_HXX
-
-#include <com/sun/star/drawing/XShapes.hpp>
-#include <com/sun/star/drawing/XDrawPage.hpp>
-#include <com/sun/star/container/XIndexAccess.hpp>
-#include <ooo/vba/msforms/XShapes.hpp>
-
-#include "vbahelperinterface.hxx"
-
-#include "vbacollectionimpl.hxx"
-
-typedef CollTestImplHelper< ov::msforms::XShapes > ScVbaShapes_BASE;
-
-class ScVbaShapes : public ScVbaShapes_BASE
-{
-private: 
-    css::uno::Reference< css::drawing::XShapes > m_xShapes;
-    css::uno::Reference< css::drawing::XDrawPage > m_xDrawPage;
-    sal_Int32 m_nNewShapeCount;
-    void initBaseCollection();
-protected:
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-	virtual css::uno::Reference< css::container::XIndexAccess > getShapesByArrayIndices( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
-    css::uno::Reference< css::drawing::XShape > createShape( rtl::OUString service ) throw (css::uno::RuntimeException);
-    css::uno::Any AddRectangle( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, css::uno::Any aRange ) throw (css::uno::RuntimeException);
-    css::uno::Any AddEllipse( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, css::uno::Any aRange ) throw (css::uno::RuntimeException);
-    rtl::OUString createName( rtl::OUString sName );
-    //TODO helperapi using a writer document
-    //css::awt::Point calculateTopLeftMargin( css::uno::Reference< ov::XHelperInterface > xDocument );
-    
-public:
-    ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes );
-    static void setDefaultShapeProperties( css::uno::Reference< css::drawing::XShape > xShape ) throw (css::uno::RuntimeException);
-    static void setShape_NameProperty( css::uno::Reference< css::drawing::XShape > xShape, rtl::OUString sName );
-    //XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
-
-    virtual void SAL_CALL SelectAll() throw (css::uno::RuntimeException);
-    //helper::calc
-    virtual css::uno::Any SAL_CALL AddLine( sal_Int32 StartX, sal_Int32 StartY, sal_Int32 endX, sal_Int32 endY ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL AddShape( sal_Int32 _nType, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ov::msforms::XShapeRange > SAL_CALL Range( const css::uno::Any& shapes ) throw (css::uno::RuntimeException);
-    // ScVbaCollectionBaseImpl
-    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& Index2 ) throw (css::uno::RuntimeException);
-};
-
-#endif//SC_VBA_SHAPES_HXX
Index: sc/source/ui/vba/vbapictureformat.hxx
===================================================================
--- sc/source/ui/vba/vbapictureformat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapictureformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,64 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbapictureformat.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_PICTUREFORMAT_HXX
-#define SC_VBA_PICTUREFORMAT_HXX
-
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/msforms/XPictureFormat.hpp>
-#include "vbahelperinterface.hxx"
-
-typedef InheritedHelperInterfaceImpl1< ov::msforms::XPictureFormat > ScVbaPictureFormat_BASE;
-
-class ScVbaPictureFormat : public ScVbaPictureFormat_BASE
-{
-private:
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-protected:
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-private:
-    void checkParameterRangeInDouble( double nRange, double nMin, double nMax ) throw (css::uno::RuntimeException);
-public:
-    ScVbaPictureFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, css::uno::Reference< css::drawing::XShape > xShape ) throw( css::lang::IllegalArgumentException );
-
-    // Attributes
-    virtual double SAL_CALL getBrightness() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setBrightness( double _brightness ) throw (css::uno::RuntimeException);
-    virtual double SAL_CALL getContrast() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setContrast( double _contrast ) throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual void SAL_CALL IncrementBrightness( double increment ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementContrast( double increment ) throw (css::uno::RuntimeException);
-};
-
-#endif//SC_VBA_PICTUREFORMAT_HXX
Index: sc/source/ui/vba/vbaradiobutton.cxx
===================================================================
--- sc/source/ui/vba/vbaradiobutton.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaradiobutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,107 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbaradiobutton.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbaradiobutton.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
-ScVbaRadioButton::ScVbaRadioButton( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : RadioButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaRadioButton::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaRadioButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-
-uno::Any SAL_CALL 
-ScVbaRadioButton::getValue() throw (css::uno::RuntimeException)
-{
-    sal_Int16 nValue = -1;
-    m_xProps->getPropertyValue( STATE ) >>= nValue;
-    if( nValue != 0 )
-        nValue = -1;
-//    return uno::makeAny( nValue ); 
-// I must be missing something MSO says value should be -1 if selected, 0 if not
-// selected
-    return uno::makeAny( ( nValue == -1 ) ? sal_True : sal_False ); 
-
-}
-
-void SAL_CALL 
-ScVbaRadioButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-    sal_Int16 nValue = 0;
-    sal_Bool bValue = sal_False;
-    if( _value >>= nValue )
-    {
-        if( nValue == -1)
-        nValue = 1;
-    }
-    else if ( _value >>= bValue )
-    {
-        if ( bValue )
-            nValue = 1;
-    }
-    m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
-}
-
-rtl::OUString& 
-ScVbaRadioButton::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaRadioButton") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaRadioButton::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.RadioButton" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbacommandbars.hxx
===================================================================
--- sc/source/ui/vba/vbacommandbars.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbars.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,79 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_COMMANDBARS_HXX
-#define SC_VBA_COMMANDBARS_HXX
-
-#include <ooo/vba/XCommandBar.hpp>
-#include <ooo/vba/XCommandBars.hpp>
-#include <com/sun/star/container/XNameAccess.hpp>
-
-#include <cppuhelper/implbase1.hxx>
-
-#include "vbahelperinterface.hxx"
-#include "vbacollectionimpl.hxx"
-
-typedef CollTestImplHelper< ov::XCommandBars > CommandBars_BASE;
-
-class ScVbaCommandBars : public CommandBars_BASE
-{
-private:
-    css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
-    rtl::OUString m_sModuleName;
-    void retrieveObjects() throw( css::uno::RuntimeException );
-public:
-    ScVbaCommandBars( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< css::container::XIndexAccess > xIndexAccess );
-
-    sal_Bool checkToolBarExist( rtl::OUString sToolBarName );
-    rtl::OUString GetModuleName(){ return m_sModuleName; };
-    css::uno::Reference< css::container::XNameAccess > GetWindows() 
-    { 
-        retrieveObjects();
-        return m_xNameAccess; 
-    };
-    // XCommandBars
-    virtual css::uno::Reference< ov::XCommandBar > SAL_CALL Add( const css::uno::Any& Name, const css::uno::Any& Position, const css::uno::Any& MenuBar, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-    // XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
-    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-
-    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& aIndex, const css::uno::Any& /*aIndex2*/ ) throw( css::uno::RuntimeException);
-    // XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-
-#endif//SC_VBA_COMMANDBARS_HXX
Index: sc/source/ui/vba/vbapages.cxx
===================================================================
--- sc/source/ui/vba/vbapages.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapages.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,81 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbapages.hxx"
-
-using namespace ::ooo::vba;
-using namespace ::com::sun::star;
-using namespace ::vos;
-
-ScVbaPages::ScVbaPages( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xPages ) throw( lang::IllegalArgumentException ) : ScVbaPages_BASE( xParent, xContext, xPages )
-{
-}
-
-uno::Type SAL_CALL 
-ScVbaPages::getElementType() throw (uno::RuntimeException)
-{
-	// return msforms::XPage::static_type(0); 
-	return uno::XInterface::static_type(0); 
-}
-
-uno::Any 
-ScVbaPages::createCollectionObject( const css::uno::Any& aSource )
-{
-	return aSource;
-}
-
-rtl::OUString& 
-ScVbaPages::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaPages") );
-	return sImplName;
-}
-
-uno::Reference< container::XEnumeration > SAL_CALL 
-ScVbaPages::createEnumeration() throw (uno::RuntimeException)
-{
-	return uno::Reference< container::XEnumeration >();
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaPages::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Pages" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbaspinbutton.cxx
===================================================================
--- sc/source/ui/vba/vbaspinbutton.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaspinbutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,109 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbaspinbutton.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString ORIENTATION( RTL_CONSTASCII_USTRINGPARAM("Orientation") );
-const static rtl::OUString SPINVALUE( RTL_CONSTASCII_USTRINGPARAM("SpinValue") );
-const static rtl::OUString SPINMAX( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") );
-const static rtl::OUString SPINMIN( RTL_CONSTASCII_USTRINGPARAM("SpinValueMin") );
-
-ScVbaSpinButton::ScVbaSpinButton(  const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : SpinButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-uno::Any SAL_CALL 
-ScVbaSpinButton::getValue() throw (css::uno::RuntimeException)
-{
-    return  m_xProps->getPropertyValue( SPINVALUE );
-}
-
-void SAL_CALL 
-ScVbaSpinButton::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SPINVALUE, _value );
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaSpinButton::getMax() throw (uno::RuntimeException)
-{
-    sal_Int32 nMax = 0;
-    m_xProps->getPropertyValue( SPINMAX ) >>= nMax;
-    return nMax;
-}
-
-void SAL_CALL 
-ScVbaSpinButton::setMax( sal_Int32 nVal ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SPINMAX, uno::makeAny( nVal ) ); 
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaSpinButton::getMin() throw (uno::RuntimeException)
-{
-    sal_Int32 nVal = 0;
-    m_xProps->getPropertyValue( SPINMIN ) >>= nVal;
-    return nVal;
-}
-
-void SAL_CALL 
-ScVbaSpinButton::setMin( sal_Int32 nVal ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SPINMIN, uno::makeAny( nVal ) ); 
-}
-
-rtl::OUString& 
-ScVbaSpinButton::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaSpinButton") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaSpinButton::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbabutton.cxx
===================================================================
--- sc/source/ui/vba/vbabutton.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbabutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,74 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbabutton.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbabutton.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-ScVbaButton::ScVbaButton( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaButton::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-
-rtl::OUString& 
-ScVbaButton::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaButton") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaButton::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Button" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbashaperange.cxx
===================================================================
--- sc/source/ui/vba/vbashaperange.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashaperange.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,170 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashaperange.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/drawing/XShapeGrouper.hpp>
-#include <com/sun/star/drawing/XDrawPage.hpp>
-
-#include "vbashaperange.hxx"
-#include "vbashape.hxx"
-
-using namespace ::ooo::vba;
-using namespace ::com::sun::star;
-
-class VbShapeRangeEnumHelper : public EnumerationHelper_BASE
-{
-        uno::Reference< XCollection > m_xParent;
-        uno::Reference<container::XIndexAccess > m_xIndexAccess;
-        sal_Int32 nIndex;
-public:
-	VbShapeRangeEnumHelper( const uno::Reference< XCollection >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
-        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
-        {
-                return ( nIndex < m_xIndexAccess->getCount() );
-        }
-        virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
-        {
-                ScVbaShapeRange* pCollectionImpl = dynamic_cast< ScVbaShapeRange* >(m_xParent.get());
-                if ( pCollectionImpl && hasMoreElements() )
-                    return pCollectionImpl->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
-                throw container::NoSuchElementException();
-        }
-
-};
-
-ScVbaShapeRange::ScVbaShapeRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xShapes, const uno::Reference< drawing::XDrawPage >& xDrawPage ) : ScVbaShapeRange_BASE( xParent, xContext, xShapes ), m_xDrawPage( xDrawPage ), m_nShapeGroupCount(0)
-{
-}
-
-// Methods
-void SAL_CALL 
-ScVbaShapeRange::Select(  ) throw (uno::RuntimeException)
-{
-    uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    xSelectSupp->select( uno::makeAny( getShapes() ) );
-}
-
-uno::Reference< msforms::XShape > SAL_CALL 
-ScVbaShapeRange::Group() throw (uno::RuntimeException)
-{
-    uno::Reference< drawing::XShapeGrouper > xShapeGrouper( m_xDrawPage, uno::UNO_QUERY_THROW );
-    uno::Reference< drawing::XShapeGroup > xShapeGroup( xShapeGrouper->group( getShapes() ), uno::UNO_QUERY_THROW );
-    uno::Reference< drawing::XShape > xShape( xShapeGroup, uno::UNO_QUERY_THROW );
-    return uno::Reference< msforms::XShape >( new ScVbaShape( getParent(), mxContext, xShape, getShapes(), office::MsoShapeType::msoGroup ) );
-}
-
-uno::Reference< drawing::XShapes > 
-ScVbaShapeRange::getShapes() throw (uno::RuntimeException)
-{
-	if ( !m_xShapes.is() )
-	{
-		uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-		m_xShapes.set( xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.drawing.ShapeCollection" ) ), uno::UNO_QUERY_THROW );
-		sal_Int32 nLen = m_xIndexAccess->getCount();
-		for ( sal_Int32 index = 0; index < nLen; ++index )
-			m_xShapes->add( uno::Reference< drawing::XShape >( m_xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ) );
-
-	}
-	return m_xShapes;
-}
-
-
-void SAL_CALL 
-ScVbaShapeRange::IncrementRotation( double Increment ) throw (uno::RuntimeException)
-{
-	sal_Int32 nLen = getCount();
-	for ( sal_Int32 index = 1; index <= nLen; ++index )
-	{
-		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
-		xShape->IncrementRotation( Increment );
-	}
-}
-
-void SAL_CALL 
-ScVbaShapeRange::IncrementLeft( double Increment ) throw (uno::RuntimeException)
-{
-	sal_Int32 nLen = getCount();
-	for ( sal_Int32 index = 1; index <= nLen; ++index )
-	{
-		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
-		xShape->IncrementLeft( Increment );
-	}
-}
-
-void SAL_CALL 
-ScVbaShapeRange::IncrementTop( double Increment ) throw (uno::RuntimeException)
-{
-	sal_Int32 nLen = getCount();
-	for ( sal_Int32 index = 1; index <= nLen; ++index )
-	{
-		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
-		xShape->IncrementTop( Increment );
-	}
-}
-
-uno::Type SAL_CALL
-ScVbaShapeRange::getElementType() throw (uno::RuntimeException)
-{
-    return msforms::XShape::static_type(0);
-}
-
-uno::Reference< container::XEnumeration > SAL_CALL 
-ScVbaShapeRange::createEnumeration() throw (uno::RuntimeException)
-{
-	return new VbShapeRangeEnumHelper( this, m_xIndexAccess );
-}
-
-uno::Any
-ScVbaShapeRange:: createCollectionObject( const css::uno::Any& aSource )
-{
-	uno::Reference< drawing::XShape > xShape( aSource, uno::UNO_QUERY_THROW );
-	// #TODO  #FIXME Shape parent should always be the sheet the shapes belong 
-	// to 
-	uno::Reference< msforms::XShape > xVbShape( new ScVbaShape( uno::Reference< XHelperInterface >(), mxContext, xShape, getShapes(), ScVbaShape::getType( xShape ) ) ); 
-        return uno::makeAny( xVbShape );
-}
-
-rtl::OUString& 
-ScVbaShapeRange::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShapeRange") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaShapeRange::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.ShapeRange" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbascrollbar.cxx
===================================================================
--- sc/source/ui/vba/vbascrollbar.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbascrollbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,139 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbascrollbar.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LARGECHANGE( RTL_CONSTASCII_USTRINGPARAM("BlockIncrement") );
-const static rtl::OUString SMALLCHANGE( RTL_CONSTASCII_USTRINGPARAM("LineIncrement") );
-const static rtl::OUString ORIENTATION( RTL_CONSTASCII_USTRINGPARAM("Orientation") );
-const static rtl::OUString SCROLLVALUE( RTL_CONSTASCII_USTRINGPARAM("ScrollValue") );
-const static rtl::OUString SCROLLMAX( RTL_CONSTASCII_USTRINGPARAM("ScrollValueMax") );
-const static rtl::OUString SCROLLMIN( RTL_CONSTASCII_USTRINGPARAM("ScrollValueMin") );
-
-ScVbaScrollBar::ScVbaScrollBar(  const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ScrollBarImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-uno::Any SAL_CALL 
-ScVbaScrollBar::getValue() throw (css::uno::RuntimeException)
-{
-    return  m_xProps->getPropertyValue( SCROLLVALUE );
-}
-
-void SAL_CALL 
-ScVbaScrollBar::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SCROLLVALUE, _value );
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaScrollBar::getMax() throw (uno::RuntimeException)
-{
-    sal_Int32 nMax = 0;
-    m_xProps->getPropertyValue( SCROLLMAX ) >>= nMax;
-    return nMax;
-}
-
-void SAL_CALL 
-ScVbaScrollBar::setMax( sal_Int32 nVal ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SCROLLMAX, uno::makeAny( nVal ) ); 
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaScrollBar::getMin() throw (uno::RuntimeException)
-{
-    sal_Int32 nVal = 0;
-    m_xProps->getPropertyValue( SCROLLMIN ) >>= nVal;
-    return nVal;
-}
-
-void SAL_CALL 
-ScVbaScrollBar::setMin( sal_Int32 nVal ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SCROLLMIN, uno::makeAny( nVal ) ); 
-}
-
-void SAL_CALL 
-ScVbaScrollBar::setLargeChange( ::sal_Int32 _largechange ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LARGECHANGE, uno::makeAny( _largechange ) );
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaScrollBar::getLargeChange() throw (uno::RuntimeException)
-{
-    sal_Int32 nVal = 0;
-    m_xProps->getPropertyValue( LARGECHANGE ) >>= nVal;
-    return nVal;
-}
-
-::sal_Int32 SAL_CALL 
-ScVbaScrollBar::getSmallChange() throw (uno::RuntimeException)
-{
-    sal_Int32 nSmallChange = 0;
-    m_xProps->getPropertyValue( SMALLCHANGE ) >>= nSmallChange;
-    return nSmallChange;
-}
-
-void SAL_CALL 
-ScVbaScrollBar::setSmallChange( ::sal_Int32 _smallchange ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( SMALLCHANGE, uno::makeAny( _smallchange ) );
-}
-
-rtl::OUString& 
-ScVbaScrollBar::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaScrollBar") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaScrollBar::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbacheckbox.cxx
===================================================================
--- sc/source/ui/vba/vbacheckbox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacheckbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,110 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbacheckbox.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
-ScVbaCheckbox::ScVbaCheckbox( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : CheckBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaCheckbox::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaCheckbox::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-
-uno::Any SAL_CALL 
-ScVbaCheckbox::getValue() throw (css::uno::RuntimeException)
-{
-    sal_Int16 nValue = -1;
-    m_xProps->getPropertyValue( STATE ) >>= nValue;
-    if( nValue != 0 )
-        nValue = -1;
-//    return uno::makeAny( nValue ); 
-// I must be missing something MSO says value should be -1 if selected, 0 if not
-// selected
-    return uno::makeAny( ( nValue == -1 ) ? sal_True : sal_False ); 
-}
-
-void SAL_CALL 
-ScVbaCheckbox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeException)
-{
-    sal_Int16 nValue = 0;
-    sal_Bool bValue = false;
-    if( _value >>= nValue )
-    {
-        if( nValue == -1)
-            nValue = 1;
-    }
-    else if ( _value >>= bValue )
-    {
-        if ( bValue )
-            nValue = 1;
-    }
-    m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
-}
-rtl::OUString& 
-ScVbaCheckbox::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCheckbox") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaCheckbox::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.CheckBox" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbaprogressbar.hxx
===================================================================
--- sc/source/ui/vba/vbaprogressbar.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaprogressbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,59 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_PROGRESSBAR_HXX
-#define SC_VBA_PROGRESSBAR_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XProgressBar.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-#include <cppuhelper/implbase2.hxx>
-
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XProgressBar, css::script::XDefaultProperty  > ProgressBarImpl_BASE;
-
-class ScVbaProgressBar : public ProgressBarImpl_BASE
-{
-public:
-    ScVbaProgressBar( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-};
-#endif //SC_VBA_LABEL_HXX
Index: sc/source/ui/vba/vbacommandbar.cxx
===================================================================
--- sc/source/ui/vba/vbacommandbar.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,329 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
-#include <com/sun/star/frame/XFrame.hpp>
-#include <com/sun/star/frame/XDesktop.hpp>
-#include <com/sun/star/frame/XLayoutManager.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-
-#include "vbacommandbar.hxx"
-#include "vbacommandbarcontrols.hxx"
-#include "vbahelper.hxx"
-
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-ScVbaCommandBar::ScVbaCommandBar( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, sal_Int32 nModuleType ) throw (uno::RuntimeException) : CommandBar_BASE( xParent, xContext )
-{
-    // it's a menu bar
-    // only supporting factory menus ( no custom menus )
-    m_xParentHardRef.set( xParent, uno::UNO_QUERY_THROW );
-    initCommandBar();
-    switch( nModuleType )
-    {
-        case 0:
-            m_sMenuModuleName = rtl::OUString::createFromAscii( "com.sun.star.sheet.SpreadsheetDocument" );
-            break;
-        case 1:
-            m_sMenuModuleName = rtl::OUString::createFromAscii( "com.sun.star.text.TextDocument" );
-            break;
-        default:
-            m_sMenuModuleName = rtl::OUString::createFromAscii( "com.sun.star.text.TextDocument" );
-    }
-    getMenuSettings();
-    m_bIsMenu = sal_True;
-    m_bCustom = sal_False;
-}
-ScVbaCommandBar::ScVbaCommandBar( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, rtl::OUString sToolBarName, sal_Bool bTemporary, sal_Bool bCreate ) throw (uno::RuntimeException) :  CommandBar_BASE( xParent, xContext )
-{
-    // it's a tool bar
-    m_xParentHardRef.set( xParent, uno::UNO_QUERY_THROW );
-    initCommandBar();
-    m_bTemporary = bTemporary;
-    m_bCreate = bCreate;
-    // get OOo ToolBarName
-    CommandBarNameMap::const_iterator iter = mCommandBarNameMap.find( sToolBarName.toAsciiLowerCase() );
-    if( iter != mCommandBarNameMap.end() )
-    {
-        m_sToolBarName = iter->second;
-    }
-    else
-    {
-        m_sToolBarName = sToolBarName;
-    }
-    m_sUIName = m_sToolBarName;
-    m_bIsMenu = sal_False;
-    getToolBarSettings( m_sToolBarName );
-}
-void
-ScVbaCommandBar::initCommandBar() throw (uno::RuntimeException)
-{
-    m_pScVbaCommandBars = dynamic_cast< ScVbaCommandBars* >( m_xParentHardRef.get() );
-    if ( !m_pScVbaCommandBars )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Parent needs to be a ScVbaCommandBars"), uno::Reference< uno::XInterface >() );
-    m_bIsMenu = sal_False;
-    m_bCustom = sal_False;
-    m_bTemporary = sal_True;
-    m_sToolBarName = rtl::OUString::createFromAscii("");
-    m_sUIName = rtl::OUString::createFromAscii("");
-    m_sMenuModuleName = rtl::OUString::createFromAscii( "com.sun.star.sheet.SpreadsheetDocument" );
-}
-void
-ScVbaCommandBar::getToolBarSettings( rtl::OUString sToolBarName ) throw( uno::RuntimeException )
-{
-    rtl::OUString sFactoryToolBar = rtl::OUString::createFromAscii("private:resource/toolbar/") + sToolBarName.toAsciiLowerCase();
-    rtl::OUString sCustomToolBar = rtl::OUString::createFromAscii("private:resource/toolbar/custom_toolbar_") + sToolBarName;
-    uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-    uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xUICfgManagerSup( xMSF->createInstance(rtl::OUString::createFromAscii("com.sun.star.ui.ModuleUIConfigurationManagerSupplier") ), uno::UNO_QUERY_THROW );
-    m_xUICfgManager.set( xUICfgManagerSup->getUIConfigurationManager( m_pScVbaCommandBars->GetModuleName() ), uno::UNO_QUERY_THROW );
-    m_xUICfgPers.set( m_xUICfgManager, uno::UNO_QUERY_THROW );
-    if( m_xUICfgManager->hasSettings( sFactoryToolBar ) )
-    {
-        // exsiting standard ToolBar
-        m_xBarSettings.set( m_xUICfgManager->getSettings( sFactoryToolBar, sal_True ), uno::UNO_QUERY_THROW );
-        m_sToolBarName = sFactoryToolBar;
-    }
-    else if( m_xUICfgManager->hasSettings( sCustomToolBar ) )
-    {
-        // exisiting custom ToolBar
-        m_xBarSettings.set( m_xUICfgManager->getSettings( sCustomToolBar, sal_True ), uno::UNO_QUERY_THROW );
-        m_sToolBarName = sCustomToolBar;
-        m_bCustom = sal_True;
-    }
-    else if( m_bCreate )
-    {
-        // new custom ToolBar
-        m_xBarSettings.set( m_xUICfgManager->createSettings(), uno::UNO_QUERY_THROW );
-        m_sToolBarName = sCustomToolBar;
-        m_bCustom = sal_True;
-        addCustomBar();
-    }
-    else
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("ToolBar do not exist"), uno::Reference< uno::XInterface >() );
-    if( m_pScVbaCommandBars->GetWindows()->hasByName( m_sToolBarName ) )
-    {
-        uno::Any aToolBar = m_pScVbaCommandBars->GetWindows()->getByName( m_sToolBarName );
-        aToolBar >>= m_aToolBar; 
-    }
-}
-void
-ScVbaCommandBar::addCustomBar()
-{
-    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
-    xPropertySet->setPropertyValue(rtl::OUString::createFromAscii("UIName"), uno::makeAny( m_sUIName ));
-
-    if( m_xUICfgManager->hasSettings(m_sToolBarName) )
-    {
-        m_xUICfgManager->replaceSettings( m_sToolBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    else
-    {
-        m_xUICfgManager->insertSettings( m_sToolBarName,  uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    if( !m_bTemporary )
-    {
-        m_xUICfgPers->store();
-    }
-}
-void 
-ScVbaCommandBar::getMenuSettings()
-{
-    try
-    {
-        rtl::OUString sMenuBar = rtl::OUString::createFromAscii( "private:resource/menubar/menubar" );
-        uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xUICfgManagerSup( xMSF->createInstance(rtl::OUString::createFromAscii("com.sun.star.ui.ModuleUIConfigurationManagerSupplier") ), uno::UNO_QUERY_THROW );
-        m_xUICfgManager.set( xUICfgManagerSup->getUIConfigurationManager( m_sMenuModuleName ), uno::UNO_QUERY_THROW );
-        m_xUICfgPers.set( m_xUICfgManager, uno::UNO_QUERY_THROW );
-        m_xBarSettings.set( m_xUICfgManager->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
-    } 
-    catch ( uno::Exception e)
-    {
-        OSL_TRACE( "getMenuSetting got a error\n" );
-    }
-}
-::rtl::OUString SAL_CALL
-ScVbaCommandBar::getName() throw ( uno::RuntimeException )
-{
-    // This will get a "NULL length string" when Name is not set. 
-    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
-    uno::Any aName = xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("UIName") );
-    rtl::OUString sName;
-    aName >>= sName;
-    if( sName.getLength() < 1 && !m_bIsMenu )
-    {
-        uno::Reference< container::XNameAccess > xNameAccess( m_pScVbaCommandBars->GetWindows(), uno::UNO_QUERY_THROW );
-        if( xNameAccess->hasByName( m_sToolBarName ) )
-        {
-            beans::PropertyValues aToolBar; 
-            xNameAccess->getByName( m_sToolBarName ) >>= aToolBar;
-            sal_Int32 nCount = aToolBar.getLength();
-            beans::PropertyValue aPropertyValue;
-            for( sal_Int32 i = 0; i < nCount; i++ )
-            {
-                aPropertyValue = aToolBar[i];
-                if( aPropertyValue.Name.equals( rtl::OUString::createFromAscii("UIName") ) )
-                {
-                    aPropertyValue.Value >>= sName;
-                    return sName;
-                }
-            }
-        }
-    }
-    return sName;
-}
-void SAL_CALL 
-ScVbaCommandBar::setName( const ::rtl::OUString& _name ) throw (uno::RuntimeException)
-{
-    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
-    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("UIName"), uno::makeAny( _name ) );
-    uno::Reference< container::XIndexAccess > xIndexAccess( m_xBarSettings, uno::UNO_QUERY_THROW );
-    
-    if( m_xUICfgManager->hasSettings( m_sToolBarName ) )
-    {
-        m_xUICfgManager->replaceSettings( m_sToolBarName, xIndexAccess );
-    }
-    else
-    {
-        // toolbar not found
-    }
-    if( !m_bTemporary )
-    {
-        m_xUICfgPers->store();
-    }
-}
-::sal_Bool SAL_CALL 
-ScVbaCommandBar::getVisible() throw (uno::RuntimeException)
-{
-    sal_Bool bVisible = sal_False;
-    try
-    {
-        sal_Int32 i = 0;
-        while( !m_aToolBar[i].Name.equals( rtl::OUString::createFromAscii( "Visible" ) ) )
-        {
-            i++;
-        }
-        m_aToolBar[i].Value >>= bVisible;
-    }
-    catch ( uno::Exception e )
-    {
-    }
-    return bVisible;
-}
-void SAL_CALL 
-ScVbaCommandBar::setVisible( ::sal_Bool _visible ) throw (uno::RuntimeException)
-{
-    try
-    {
-        uno::Reference< frame::XFrame > xFrame( getCurrentDocument()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW ); 
-        uno::Reference< beans::XPropertySet > xPropertySet( xFrame, uno::UNO_QUERY_THROW );
-        uno::Reference< frame::XLayoutManager > xLayoutManager( xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("LayoutManager") ), uno::UNO_QUERY_THROW );
-        if( _visible )
-        {
-            xLayoutManager->createElement( m_sToolBarName );
-            xLayoutManager->showElement( m_sToolBarName );
-        }
-        else
-        {
-            xLayoutManager->hideElement( m_sToolBarName );
-            xLayoutManager->destroyElement( m_sToolBarName );
-        }
-    }
-    catch( uno::Exception e )
-    {
-        OSL_TRACE( "SetVisible get an exception\n" );
-    }
-}
-void SAL_CALL 
-ScVbaCommandBar::Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
-{
-    if( m_bCustom )
-    {
-        if( m_xUICfgManager->hasSettings( m_sToolBarName ) )
-        {
-            m_xUICfgManager->removeSettings(m_sToolBarName);
-            // make it permanent
-            if( !m_bTemporary )
-            {
-                m_xUICfgPers->store();
-            }
-        }
-        else
-        {
-            // toolbar not found
-            // TODO throw Error
-        }
-        uno::Reference< container::XNameContainer > xNameContainer( m_pScVbaCommandBars->GetWindows(), uno::UNO_QUERY_THROW );
-        if( xNameContainer->hasByName( m_sToolBarName ) )
-        {
-            xNameContainer->removeByName( m_sToolBarName );
-        }
-    }
-}
-uno::Any SAL_CALL 
-ScVbaCommandBar::Controls( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
-{
-    sal_Int32 nIndex;
-    uno::Reference< XCommandBarControls > xCommandBarControls( new ScVbaCommandBarControls( this, mxContext, uno::Reference< container::XIndexAccess >() ) );
-    if( aIndex.hasValue() )
-    {
-        if( aIndex >>= nIndex )
-        {
-            uno::Reference< XCommandBarControl > xCommandBarControl( xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
-            return uno::makeAny( xCommandBarControl );
-        }
-        else
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(  "invalid index" ), uno::Reference< uno::XInterface >() );
-    }
-    return uno::makeAny( xCommandBarControls );
-}
-rtl::OUString& 
-ScVbaCommandBar::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBar") );
-	return sImplName;
-}
-uno::Sequence<rtl::OUString> 
-ScVbaCommandBar::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBar" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbalistcontrolhelper.hxx
===================================================================
--- sc/source/ui/vba/vbalistcontrolhelper.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalistcontrolhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,20 +0,0 @@
-#ifndef SC_VBA_LISTCONTROLHELPER
-#define SC_VBA_LISTCONTROLHELPER
-
-#include "vbahelper.hxx"
-
-class ListControlHelper
-{
-	css::uno::Reference< css::beans::XPropertySet > m_xProps;
-
-public:
-	ListControlHelper( const css::uno::Reference< css::beans::XPropertySet >& rxControl ) : m_xProps( rxControl ){}
-	virtual ~ListControlHelper() {}
-	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);   
-    	virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
-	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
-	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
-};
-#endif
Index: sc/source/ui/vba/vbacollectionimpl.hxx
===================================================================
--- sc/source/ui/vba/vbacollectionimpl.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacollectionimpl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,259 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacollectionimpl.hxx,v $
- * $Revision: 1.5 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_COLLECTION_IMPL_HXX
-#define SC_VBA_COLLECTION_IMPL_HXX
-
-#include <ooo/vba/XCollection.hpp>
-//#include <ooo/vba/XCollectionTest.hpp>
-#include <com/sun/star/container/XEnumerationAccess.hpp>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/script/XDefaultMethod.hpp>
-#include <com/sun/star/container/XIndexAccess.hpp>
-#include <com/sun/star/container/XNameAccess.hpp>
-#include <com/sun/star/container/XNamed.hpp>
-
-#include <cppuhelper/implbase3.hxx>
-#include <cppuhelper/implbase2.hxx>
-#include <cppuhelper/implbase1.hxx>
-
-#include "vbahelper.hxx"
-#include "vbahelperinterface.hxx"
-#include "vbaglobals.hxx"
-
-#include <vector>
-
-typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumerationHelper_BASE;
-
-class EnumerationHelperImpl : public EnumerationHelper_BASE
-{
-protected:
-	css::uno::Reference< css::uno::XComponentContext > m_xContext;
-	css::uno::Reference< css::container::XEnumeration > m_xEnumeration;
-public:
-
-	EnumerationHelperImpl( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XEnumeration >& xEnumeration ) throw ( css::uno::RuntimeException ) : m_xContext( xContext ),  m_xEnumeration( xEnumeration ) { }
-	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException) { return m_xEnumeration->hasMoreElements(); }
-};
-
-// a wrapper class for a providing a XIndexAccess, XNameAccess, XEnumerationAccess impl based on providing a vector of interfaces 
-// only requirement is the object needs to implement XName
-
-
-
-typedef ::cppu::WeakImplHelper3< css::container::XNameAccess, css::container::XIndexAccess, css::container::XEnumerationAccess > XNamedCollectionHelper_BASE;
-
-template< typename Ifc1 >
-class XNamedObjectCollectionHelper : public XNamedCollectionHelper_BASE
-{
-public:
-typedef std::vector< css::uno::Reference< Ifc1 > >  XNamedVec;
-private:
-
-	class XNamedEnumerationHelper : public EnumerationHelper_BASE
-	{
-		XNamedVec mXNamedVec;
-		typename XNamedVec::iterator mIt;
-	public:
-	        XNamedEnumerationHelper( const XNamedVec& sMap ) : mXNamedVec( sMap ), mIt( mXNamedVec.begin() ) {}
-	
-	        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException)
-	        {
-			return ( mIt != mXNamedVec.end() );
-	        }
-	
-	        virtual css::uno::Any SAL_CALL nextElement(  ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException)
-	        {
-	                if ( hasMoreElements() )
-				return css::uno::makeAny( *mIt++ );
-	                throw css::container::NoSuchElementException();
-	        }
-	};
-
-protected:
-	XNamedVec mXNamedVec;
-	typename XNamedVec::iterator cachePos;
-public:
-	XNamedObjectCollectionHelper( const XNamedVec& sMap ) : mXNamedVec( sMap ), cachePos(mXNamedVec.begin()) {}
-	// XElementAccess
-	virtual css::uno::Type SAL_CALL getElementType(  ) throw (css::uno::RuntimeException) { return  Ifc1::static_type(0); }
-	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (css::uno::RuntimeException) { return ( mXNamedVec.size() > 0 ); }
-	// XNameAcess 
-	virtual css::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException)
-	{
-		if ( !hasByName(aName) )
-			throw css::container::NoSuchElementException();
-		return css::uno::makeAny( *cachePos );
-	}
-	virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (css::uno::RuntimeException)
-	{
-		css::uno::Sequence< rtl::OUString > sNames( mXNamedVec.size() );
-		rtl::OUString* pString = sNames.getArray();
-		typename XNamedVec::iterator it = mXNamedVec.begin();
-		typename XNamedVec::iterator it_end = mXNamedVec.end();
-
-		for ( ; it != it_end; ++it, ++pString )
-		{
-			css::uno::Reference< css::container::XNamed > xName( *it, css::uno::UNO_QUERY_THROW );	
-			*pString = xName->getName();
-		}
-		return sNames;
-	}
-	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException)
-	{
-		cachePos = mXNamedVec.begin();
-		typename XNamedVec::iterator it_end = mXNamedVec.end();
-		for ( ; cachePos != it_end; ++cachePos )
-		{
-			css::uno::Reference< css::container::XNamed > xName( *cachePos, css::uno::UNO_QUERY_THROW );	
-			if ( aName.equals( xName->getName() ) )
-				break;
-		}
-		return ( cachePos != it_end );
-	}
-
-	// XElementAccess
-	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (css::uno::RuntimeException) { return mXNamedVec.size(); }	
-	virtual css::uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (css::lang::IndexOutOfBoundsException, css::lang::WrappedTargetException, css::uno::RuntimeException )
-	{
-		if ( Index < 0 || Index >= getCount() )
-			throw css::lang::IndexOutOfBoundsException();
-	
-		return css::uno::makeAny( mXNamedVec[ Index ] );
-
-	}
-	// XEnumerationAccess
-	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration(  ) throw (css::uno::RuntimeException)
-	{
-		return new XNamedEnumerationHelper( mXNamedVec );
-	}
-};
-
-// including a HelperInterface implementation
-template< typename Ifc1 >
-class ScVbaCollectionBase : public InheritedHelperInterfaceImpl< Ifc1 >
-{
-typedef InheritedHelperInterfaceImpl< Ifc1 > BaseColBase;
-protected:
-	css::uno::Reference< css::container::XIndexAccess > m_xIndexAccess;
-	css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
-
-	virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException)
-	{
-		if ( !m_xNameAccess.is() )
-			throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase string index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
-	
-		return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
-	}		
-
-	virtual css::uno::Any getItemByIntIndex( const sal_Int32 nIndex ) throw (css::uno::RuntimeException)
-	{
-		if ( !m_xIndexAccess.is() )
-			throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase numeric index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
-		if ( nIndex <= 0 )
-		{
-			throw  css::lang::IndexOutOfBoundsException( 
-				::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
-				"index is 0 or negative" ) ), 
-				css::uno::Reference< css::uno::XInterface >() );
-		}
-		// need to adjust for vba index ( for which first element is 1 )
-		return createCollectionObject( m_xIndexAccess->getByIndex( nIndex - 1 ) );		
-	}
-public:
-	ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ){ m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
-	//XCollection
-	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException)
-	{
-		return m_xIndexAccess->getCount();
-	}
-
-	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw (css::uno::RuntimeException)
-	{
-		if ( Index1.getValueTypeClass() != css::uno::TypeClass_STRING )
-		{
-			sal_Int32 nIndex = 0;
-	
-			if ( ( Index1 >>= nIndex ) != sal_True )
-			{
-				rtl::OUString message;
-				message = rtl::OUString::createFromAscii(
-					"Couldn't convert index to Int32");
-				throw  css::lang::IndexOutOfBoundsException( message,
-					css::uno::Reference< css::uno::XInterface >() );
-			}
-			return 	getItemByIntIndex( nIndex );
-		}
-		rtl::OUString aStringSheet;
-
-		Index1 >>= aStringSheet;
-		return getItemByStringIndex( aStringSheet );	
-	}
-	// XDefaultMethod
-	::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (css::uno::RuntimeException)
-	{
-		const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
-		return sName;
-	}
-	// XEnumerationAccess
-	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException) = 0;	
-
-	// XElementAccess
-	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException) = 0;
-	// XElementAccess
-	virtual ::sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException)
-	{
-		return ( m_xIndexAccess->getCount() > 0 );
-	}
-	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ) = 0;
-	
-};
-
-typedef ::cppu::WeakImplHelper1<ov::XCollection> XCollection_InterfacesBASE;
-
-typedef ScVbaCollectionBase< XCollection_InterfacesBASE > CollImplBase1;
-// compatible with the old collections ( pre XHelperInterface base class ) ( some internal objects still use this )
-class ScVbaCollectionBaseImpl : public CollImplBase1
-{
-public:
-	ScVbaCollectionBaseImpl( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : CollImplBase1( xParent, xContext, xIndexAccess){}
-
-};
-
-template <typename Ifc> // where Ifc must implement XCollectionTest
-class CollTestImplHelper :  public ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc > >
-{
-typedef ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc >  > ImplBase1;
-
-public:
-	CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess ) {}
-};
-
-
-#endif //SC_VBA_COLLECTION_IMPL_HXX
Index: sc/source/ui/vba/vbaimage.cxx
===================================================================
--- sc/source/ui/vba/vbaimage.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaimage.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,59 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbaimage.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-ScVbaImage::ScVbaImage( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ImageImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-rtl::OUString& 
-ScVbaImage::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaImage") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaImage::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Image" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbacommandbarcontrols.cxx
===================================================================
--- sc/source/ui/vba/vbacommandbarcontrols.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbarcontrols.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,246 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbacommandbarcontrols.hxx"
-#include "vbacommandbarcontrol.hxx"
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-typedef ::cppu::WeakImplHelper1< container::XEnumeration > CommandBarControlEnumeration_BASE;
-class CommandBarControlEnumeration : public CommandBarControlEnumeration_BASE
-{
-    //uno::Reference< uno::XComponentContext > m_xContext;
-    ScVbaCommandBarControls* m_pCommandBarControls;
-    sal_Int32 m_nCurrentPosition;
-public:
-    CommandBarControlEnumeration( ScVbaCommandBarControls* pCommandBarControls ) : m_pCommandBarControls( pCommandBarControls ), m_nCurrentPosition( 0 ) {}
-    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
-    {
-        if( m_nCurrentPosition < m_pCommandBarControls->getCount() )
-            return sal_True;
-        return sal_False;
-    }
-    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
-    {
-        if( hasMoreElements() )
-        {
-            rtl::OUString sName = m_pCommandBarControls->GetControlNameByIndex( m_nCurrentPosition );
-            m_nCurrentPosition = m_nCurrentPosition + 1;
-            if( sName.getLength() > 0 )
-                return m_pCommandBarControls->createCollectionObject( uno::makeAny( sName ) );
-            else
-                return nextElement();
-        }
-        else
-            throw container::NoSuchElementException();
-    }
-};
-
-ScVbaCommandBarControls::ScVbaCommandBarControls( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< container::XIndexAccess> xIndexAccess ) throw (uno::RuntimeException) : CommandBarControls_BASE( xParent, xContext, xIndexAccess )
-{
-    m_bIsMenu = sal_False;
-    m_bHasElements = sal_False;
-    m_xParentHardRef.set( xParent, uno::UNO_QUERY_THROW );
-    m_pCommandBar = dynamic_cast< ScVbaCommandBar* >( m_xParentHardRef.get() );
-    m_pCommandBarControl = dynamic_cast< ScVbaCommandBarControl* >( m_xParentHardRef.get() );
-    if( m_pCommandBar )
-    {
-        m_xUICfgManager.set( m_pCommandBar->GetUICfgManager(), uno::UNO_QUERY_THROW );
-        m_xUICfgPers.set( m_pCommandBar->GetUICfgPers(), uno::UNO_QUERY_THROW );
-        m_xBarSettings.set( m_pCommandBar->GetBarSettings(), uno::UNO_QUERY_THROW );
-        m_bIsMenu = m_pCommandBar->IsMenu();
-        if( m_xBarSettings->hasElements() )
-        {
-            m_bHasElements = sal_True;
-        }
-    }
-    else if( m_pCommandBarControl )
-    {
-    }
-    else
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parent needs to be a ScVbaCommandBar or a ScVbaCommandBarControl"), uno::Reference< uno::XInterface >() );
-    }
-}
-rtl::OUString
-ScVbaCommandBarControls::GetControlNameByIndex( const sal_Int32 nIndex ) throw ( uno::RuntimeException )
-{
-    sal_Int32 nCount = 0;
-    if( m_bHasElements )
-    {
-        sal_Int32 nBarSettingsCount = m_xBarSettings->getCount();
-        for( sal_Int32 i = 0; i < nBarSettingsCount; i++ )
-        {
-            beans::PropertyValues aMenuValues;
-            m_xBarSettings->getByIndex( i ) >>= aMenuValues;
-            for( sal_Int32 j = 0; j < aMenuValues.getLength(); j++ )
-            {
-                if( aMenuValues[j].Name.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii( "CommandURL" ) ) )
-                {
-                    nCount++;
-                    if( nIndex == nCount )
-                    {
-                        rtl::OUString sCommandURL;
-                        aMenuValues[j].Value >>= sCommandURL;
-                        sal_Int32 nLastIndex = sCommandURL.lastIndexOf( rtl::OUString::createFromAscii(":") );
-                        if( ( nLastIndex != -1 ) && ( ( nLastIndex +1 ) < sCommandURL.getLength() ) )
-                        {
-                            sCommandURL = sCommandURL.copy( nLastIndex + 1 );
-                            return sCommandURL;
-                        }
-                    }
-                }
-            }
-        } 
-    }
-    else
-        throw  uno::RuntimeException( rtl::OUString::createFromAscii( "Out of bound" ), uno::Reference< uno::XInterface >() );
-    return rtl::OUString();
-}
-
-// Attributes
-sal_Int32 SAL_CALL 
-ScVbaCommandBarControls::getCount() throw (uno::RuntimeException)
-{
-    sal_Int32 nCount = 0;
-    if( m_bHasElements )
-    {
-        sal_Int32 nBarSettingsCount = m_xBarSettings->getCount();
-        for( sal_Int32 i = 0; i < nBarSettingsCount; i++ )
-        {
-            beans::PropertyValues aMenuValues;
-            m_xBarSettings->getByIndex( i ) >>= aMenuValues;
-            for( sal_Int32 j = 0; j < aMenuValues.getLength(); j++ )
-            {
-                if( aMenuValues[j].Name.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii( "CommandURL" ) ) )
-                {
-                    nCount++;
-                }
-            }
-        } 
-    }
-    return nCount;
-}
-// XEnumerationAccess
-uno::Type SAL_CALL
-ScVbaCommandBarControls::getElementType() throw ( uno::RuntimeException )
-{
-    return XCommandBarControls::static_type( 0 );
-}
-uno::Reference< container::XEnumeration >
-ScVbaCommandBarControls::createEnumeration() throw ( uno::RuntimeException )
-{
-    return uno::Reference< container::XEnumeration >( new CommandBarControlEnumeration( this ) );
-}
-uno::Any
-ScVbaCommandBarControls::createCollectionObject( const uno::Any& aSource )
-{
-    // only surport the aSource as a name string, because this class is a API wrapper
-    rtl::OUString sName;
-    if( aSource >>= sName )
-        return uno::makeAny( uno::Reference< XCommandBarControl > ( new ScVbaCommandBarControl( this, mxContext, sName ) ) );
-    return uno::Any();
-}
-
-// Methods
-uno::Any SAL_CALL 
-ScVbaCommandBarControls::Item( const uno::Any& aIndex, const uno::Any& /*aIndex*/ ) throw (uno::RuntimeException)
-{
-    if( aIndex.getValueTypeClass() == uno::TypeClass_STRING )
-    {
-        return createCollectionObject( aIndex );
-    } 
-    sal_Int32 nIndex = 0;
-    if( aIndex >>= nIndex )
-    {
-        return createCollectionObject( uno::makeAny( GetControlNameByIndex( nIndex ) ) );
-    }
-    
-    return uno::Any();
-}
-uno::Reference< XCommandBarControl > SAL_CALL 
-ScVbaCommandBarControls::Add( const uno::Any& Type, const uno::Any& Id, const uno::Any& /*Parameter*/, const uno::Any& Before, const uno::Any& Temporary ) throw (script::BasicErrorException, uno::RuntimeException)
-{
-    // Parameter is not supported
-    // the following name needs to be individually created;
-    rtl::OUString sCaption( rtl::OUString::createFromAscii("custom Control") );
-    rtl::OUString sCommand( rtl::OUString::createFromAscii("macro:///Standard.Module1.Test()") );
-    sal_Int32 nType =0;
-    sal_Int32 nPosition = 0;
-    sal_Int32 nId;
-    sal_Bool bTemporary = sal_True;
-    
-    if( Type.hasValue() )
-        if( Type >>= nType )
-        {
-            // evalute the type of the new control
-        }
-    if( Id.hasValue() )
-        if( Id >>= nId )
-        {
-            // evalute the action of the new control
-        }
-    if( Before.hasValue() )
-        if( Before >>= nPosition )
-        {
-            // evalute the position of the new Control
-        }
-    if( Temporary.hasValue() )
-        if( Temporary >>= bTemporary )
-        {
-            // evalute the temporary of the new Control
-        }
-    return uno::Reference< XCommandBarControl > ( new ScVbaCommandBarControl( this, mxContext, sCaption, sCommand, nPosition, bTemporary ) );
-}
-   
-// XHelperInterface
-rtl::OUString& 
-ScVbaCommandBarControls::getServiceImplName()
-{
-    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarControls") );
-    return sImplName;
-}
-uno::Sequence<rtl::OUString> 
-ScVbaCommandBarControls::getServiceNames()
-{
-    static uno::Sequence< rtl::OUString > aServiceNames;
-    if ( aServiceNames.getLength() == 0 )
-    {
-        aServiceNames.realloc( 1 );
-        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarControls" ) );
-    }
-    return aServiceNames;
-}
-
Index: sc/source/ui/vba/vbacolorformat.cxx
===================================================================
--- sc/source/ui/vba/vbacolorformat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacolorformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,190 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacolorformat.cxx,v $
- * $Revision: 1.3.146.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/msforms/XLineFormat.hpp>
-#include "vbacolorformat.hxx"
-
-using namespace ooo::vba;
-using namespace com::sun::star;
-
-sal_Int32
-MsoColorIndizes::getColorIndex( sal_Int32 nIndex )
-{
-    const static sal_Int32 COLORINDIZES[56] =
-    {   HAPICOLOR_BLACK, HAPICOLOR_WITHE, HAPICOLOR_RED, HAPICOLOR_BRIGHTGREEN, HAPICOLOR_BLUE, HAPICOLOR_YELLOW, HAPICOLOR_PINK,
-        HAPICOLOR_TURQUOISE, HAPICOLOR_DARKRED, HAPICOLOR_GREEN, HAPICOLOR_DARKBLUE, HAPICOLOR_DARKYELLOW, HAPICOLOR_VIOLET,
-        HAPICOLOR_TEAL, HAPICOLOR_GRAY_25_PERCENT, HAPICOLOR_GRAY_50_PERCENT, HAPICOLOR_PERIWINCKLE, HAPICOLOR_PLUM,
-        HAPICOLOR_IVORY, HAPICOLOR_LIGHTTURQUOISE, HAPICOLOR_DARKPRUPLE, HAPICOLOR_CORAL, HAPICOLOR_OCEANBLUE, HAPICOLOR_ICEBLUE,
-        HAPICOLOR_GREEN, HAPICOLOR_PINK, HAPICOLOR_YELLOW, HAPICOLOR_TURQUOISE, HAPICOLOR_VIOLET, HAPICOLOR_DARKRED, HAPICOLOR_TEAL,
-        HAPICOLOR_BLUE, HAPICOLOR_SKYBLUE, HAPICOLOR_LIGHTTURQUOISE, HAPICOLOR_LIGHTGREEN, HAPICOLOR_LIGHTYELLOW, HAPICOLOR_PALEBLUE,
-        HAPICOLOR_ROSE, HAPICOLOR_LAVENDER, HAPICOLOR_TAN, HAPICOLOR_LIGHTBLUE, HAPICOLOR_AQUA, HAPICOLOR_LIME, HAPICOLOR_GOLD,
-        HAPICOLOR_LIGHTORANGE, HAPICOLOR_ORANGE, HAPICOLOR_BLUEGRAY, HAPICOLOR_GRAY_40_PERCENT, HAPICOLOR_DARKTEAL,
-        HAPICOLOR_SEAGREEN, HAPICOLOR_NONAME, HAPICOLOR_OLIVEGREEN, HAPICOLOR_BROWN, HAPICOLOR_PLUM, HAPICOLOR_INDIGO,
-        HAPICOLOR_GRAY_80_PERCENT
-    };
-    return COLORINDIZES[nIndex];
-}
-ScVbaColorFormat::ScVbaColorFormat( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XHelperInterface > xInternalParent, const uno::Reference< drawing::XShape > xShape, const sal_Int16 nColorFormatType ) : ScVbaColorFormat_BASE( xParent, xContext ), m_xInternalParent( xInternalParent ), m_xShape( xShape ), m_nColorFormatType( nColorFormatType )
-{
-    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
-    m_nFillFormatBackColor = 0;
-    try
-    {
-        uno::Reference< ov::msforms::XFillFormat > xFillFormat( xInternalParent, uno::UNO_QUERY_THROW );
-        m_pFillFormat = ( ScVbaFillFormat* )( xFillFormat.get() );
-    }catch ( uno::RuntimeException  e )
-    {
-        m_pFillFormat = NULL;
-    }
-}
-
-void
-ScVbaColorFormat::setColorFormat( sal_Int16 _ntype )
-{
-    m_nColorFormatType = _ntype;
-}
-
-// Attribute
-sal_Int32 SAL_CALL 
-ScVbaColorFormat::getRGB() throw (uno::RuntimeException)
-{
-    sal_Int32 nRGB = 0;
-    switch( m_nColorFormatType )
-    {
-    case ColorFormatType::LINEFORMAT_FORECOLOR:
-        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("LineColor") ) >>= nRGB;
-        break;
-    case ColorFormatType::LINEFORMAT_BACKCOLOR:
-        //TODO BackColor not supported
-        // m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("Color"), uno::makeAny( nRGB ) );
-        break;
-    case ColorFormatType::FILLFORMAT_FORECOLOR:
-        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillColor") ) >>= nRGB;
-        break;
-    case ColorFormatType::FILLFORMAT_BACKCOLOR:
-        nRGB = m_nFillFormatBackColor;
-        break;
-    default:
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Second parameter of ColorFormat is wrong."), uno::Reference< uno::XInterface >() );
-    }
-    nRGB = OORGBToXLRGB( nRGB );
-    return nRGB;
-}
-
-void SAL_CALL 
-ScVbaColorFormat::setRGB( sal_Int32 _rgb ) throw (uno::RuntimeException)
-{
-    sal_Int32 nRGB = XLRGBToOORGB( _rgb );
-    switch( m_nColorFormatType )
-    {
-    case ColorFormatType::LINEFORMAT_FORECOLOR:
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineColor" ), uno::makeAny( nRGB ) );
-        break;
-    case ColorFormatType::LINEFORMAT_BACKCOLOR:
-        // TODO BackColor not supported
-        break;
-    case ColorFormatType::FILLFORMAT_FORECOLOR:
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillColor" ), uno::makeAny( nRGB ) );
-        if( m_pFillFormat )
-        {
-            m_pFillFormat->setForeColorAndInternalStyle(nRGB);
-        }
-        break;
-    case ColorFormatType::FILLFORMAT_BACKCOLOR:
-        m_nFillFormatBackColor = nRGB;
-        if( m_pFillFormat )
-        {
-            m_pFillFormat->setForeColorAndInternalStyle(nRGB);
-        }
-        break;
-    default:    
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Second parameter of ColorFormat is wrong."), uno::Reference< uno::XInterface >() );
-    }
-}
-
-sal_Int32 SAL_CALL 
-ScVbaColorFormat::getSchemeColor() throw (uno::RuntimeException)
-{
-    sal_Int32 nColor = getRGB();
-    // #TODO I guess the number of elements is determined by the correct scheme
-    // the implementation here seems to be a rehash of color index ( which seems to be a 
-    // different thing ) - I would guess we need to know/import etc. the correct color scheme
-    // or at least find out a little more
-    sal_Int32 i = 0;
-    for( ; i < 56; i++ )
-    {
-        if( nColor == MsoColorIndizes::getColorIndex(i) )
-	   break;
-    }
-
-    if( i == 56 ) // this is most likely an error condition
-        --i;
-    return i; 
-    // #TODO figure out what craziness is this, 
-    // the 56 colors seems incorrect, as in default XL ( 2003 ) there are 80 colors
-/*
-    if( i == 56 )
-    {
-        i = -2;
-    }
-
-    return ( i + 2 );
-*/
-}
-
-void SAL_CALL 
-ScVbaColorFormat::setSchemeColor( sal_Int32 _schemecolor ) throw (uno::RuntimeException)
-{
-    // the table is 0 based
-    sal_Int32 nColor = MsoColorIndizes::getColorIndex( _schemecolor );
-    // nColor is already xl RGB
-    setRGB( nColor );
-}
-
-
-rtl::OUString&
-ScVbaColorFormat::getServiceImplName()
-{
-    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaColorFormat") );
-    return sImplName;
-}
-
-uno::Sequence< rtl::OUString >
-ScVbaColorFormat::getServiceNames()
-{
-    static uno::Sequence< rtl::OUString > aServiceNames;
-    if ( aServiceNames.getLength() == 0 )
-    {
-        aServiceNames.realloc( 1 );
-        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ColorFormat" ) );
-    }
-    return aServiceNames;
-}
-
Index: sc/source/ui/vba/vbalistbox.hxx
===================================================================
--- sc/source/ui/vba/vbalistbox.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalistbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,90 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalistbox.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_LISTBOX_HXX
-#define SC_VBA_LISTBOX_HXX
-#include <cppuhelper/implbase2.hxx>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/script/XDefaultProperty.hpp>
-#include <ooo/vba/msforms/XListBox.hpp>
-#include <com/sun/star/beans/PropertyAttribute.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbapropvalue.hxx"
-#include "vbalistcontrolhelper.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper2<ScVbaControl, ov::msforms::XListBox, css::script::XDefaultProperty > ListBoxImpl_BASE;
-class ScVbaListBox : public ListBoxImpl_BASE
-    ,public PropListener
-{		
-	std::auto_ptr< ListControlHelper > mpListHelper;
-	rtl::OUString sSourceName; 
-	rtl::OUString msDftPropName;
-
-    sal_Int16 m_nIndex;
-	
-public:
-	ScVbaListBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-
-	// Attributes
-	virtual css::uno::Any SAL_CALL getListIndex() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setListIndex( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
-	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-	virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMultiSelect( sal_Bool _multiselect ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Selected( ::sal_Int32 index ) throw (css::uno::RuntimeException);
-
-	// Methods
-	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
-	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
-	// XControl
-    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
-
-	// XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-    
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();    
-
-    //PropListener
-    virtual void setValueEvent( const css::uno::Any& value );
-    virtual css::uno::Any getValueEvent();
-
-
-};
-
-#endif //
Index: sc/source/ui/vba/vbamultipage.hxx
===================================================================
--- sc/source/ui/vba/vbamultipage.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbamultipage.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,65 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_MULTIPAGE_HXX
-#define SC_VBA_MULTIPAGE_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XMultiPage.hpp>
-#include <com/sun/star/container/XIndexAccess.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-//#include <cppuhelper/implbase2.hxx>
-#include <cppuhelper/implbase1.hxx>
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XMultiPage > MultiPageImpl_BASE;
-
-class ScVbaMultiPage : public MultiPageImpl_BASE
-{
-    css::uno::Reference< css::container::XIndexAccess > getPages( sal_Int32 nPages );
-    css::uno::Reference< css::beans::XPropertySet > mxDialogProps;
-public:
-    ScVbaMultiPage( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, const css::uno::Reference< css::uno::XInterface >& xDialog );
-   // Attributes
-    virtual sal_Int32 SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( sal_Int32 _value ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Pages( const css::uno::Any& index ) throw (css::uno::RuntimeException);
-
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-};
-#endif //SC_VBA_LABEL_HXX
Index: sc/source/ui/vba/vbaradiobutton.hxx
===================================================================
--- sc/source/ui/vba/vbaradiobutton.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaradiobutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,55 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbaradiobutton.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_RADIOBUTTON_HXX
-#define SC_VBA_RADIOBUTTON_HXX
-#include <ooo/vba/msforms/XRadioButton.hpp>
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-#include <cppuhelper/implbase2.hxx>
-
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > RadioButtonImpl_BASE;
-
-class ScVbaRadioButton : public RadioButtonImpl_BASE
-{
-public:
-    ScVbaRadioButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-   // Attributes
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue(const com::sun::star::uno::Any&) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-
-};
-#endif //SC_VBA_RADIOBUTTON_HXX
Index: sc/source/ui/vba/vbapages.hxx
===================================================================
--- sc/source/ui/vba/vbapages.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapages.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,64 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_PAGES_HXX
-#define SC_VBA_PAGES_HXX
-
-#include <ooo/vba/office/MsoShapeType.hpp>
-#include <com/sun/star/lang/XEventListener.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/msforms/XPages.hpp>
-#include <cppuhelper/implbase2.hxx>
-#include <cppuhelper/implbase1.hxx>
-
-#include "vbacollectionimpl.hxx"
-typedef CollTestImplHelper< 
-ov::msforms::XPages > ScVbaPages_BASE;
-
-class ScVbaPages : public ScVbaPages_BASE
-{
-protected:
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-public:
-    ScVbaPages( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xPages ) throw ( css::lang::IllegalArgumentException );
-    virtual ~ScVbaPages() {}
-        // XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
-     // ScVbaPages_BASE
-     virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-
-};
-#endif//SC_VBA_SHAPE_HXX
Index: sc/source/ui/vba/vbahelperinterface.hxx
===================================================================
--- sc/source/ui/vba/vbahelperinterface.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbahelperinterface.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,116 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbahelperinterface.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_HELPERINTERFACE_HXX
-#define SC_VBA_HELPERINTERFACE_HXX
-
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/XHelperInterface.hpp>
-#include "vbahelper.hxx"
-#include "vbaglobals.hxx"
-
-// use this class when you have an a object like
-// interface  XAnInterface which contains XHelperInterface in its inheritance hierarchy
-// interface XAnInterface
-// { 
-//     interface XHelperInterface;
-//     [attribute, string] name;
-// }
-// or
-// interface XAnInterface : XHelperInterface;
-// { 
-//     [attribute, string] name;
-// }
-//
-// then this class can provide a default implementation of XHelperInterface,
-// you can use it like this
-// typedef InheritedHelperInterfaceImpl< XAnInterface > > AnInterfaceImpl_BASE;
-// class AnInterfaceImpl : public AnInterfaceImpl_BASE
-// {
-// public:
-//     AnInterface( const Reference< HelperInterface >& xParent ) : AnInterfaceImpl_BASE( xParent ) {}
-//     // implement XAnInterface methods only, no need to implement the XHelperInterface 
-//     // methods
-//     virtual void setName( const OUString& );  
-//     virtual OUString getName();  
-// }
-//
-const ::rtl::OUString sHelperServiceName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.HelperServiceBase" ) );
-
-template< typename Ifc1 >
-class InheritedHelperInterfaceImpl : public Ifc1
-{
-protected: 
-	css::uno::WeakReference< ov::XHelperInterface > mxParent;
-	css::uno::Reference< css::uno::XComponentContext > mxContext;
-public:
-	InheritedHelperInterfaceImpl() {}
-	InheritedHelperInterfaceImpl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) : mxParent( xParent ), mxContext( xContext ) {}
-	virtual rtl::OUString& getServiceImplName() = 0;
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames() = 0;
-
-	// XHelperInterface Methods
-	virtual ::sal_Int32 SAL_CALL getCreator() throw (css::script::BasicErrorException, css::uno::RuntimeException)
-	{
-		return 0x53756E4F;
-	}
-	virtual css::uno::Reference< ov::XHelperInterface > SAL_CALL getParent(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { return mxParent; }
-	
-	virtual css::uno::Any SAL_CALL Application(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { return  css::uno::makeAny( ScVbaGlobals::getGlobalsImpl( mxContext )->getApplication() ); }
-
-
-	// XServiceInfo Methods
-	virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (css::uno::RuntimeException) { return getServiceImplName(); }
-	virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (css::uno::RuntimeException) 
-	{ 
-		css::uno::Sequence< rtl::OUString > sServices = getSupportedServiceNames();
-		const rtl::OUString* pStart = sServices.getConstArray();
-		const rtl::OUString* pEnd = pStart + sServices.getLength();
-		for ( ; pStart != pEnd ; ++pStart )
-			if ( (*pStart).equals( ServiceName ) )
-				return sal_True;
-		return sal_False;	
-	}
-	virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (css::uno::RuntimeException) 
-	{ 
-		css::uno::Sequence< rtl::OUString > aNames = getServiceNames();;
-		return aNames;
-	}
- };
-
-template< typename Ifc1 >
-class InheritedHelperInterfaceImpl1 : public InheritedHelperInterfaceImpl< ::cppu::WeakImplHelper1< Ifc1 > >
-
-{
-typedef InheritedHelperInterfaceImpl< ::cppu::WeakImplHelper1< Ifc1 > > Base;
-public:
-	InheritedHelperInterfaceImpl1< Ifc1 > ( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) : Base( xParent, xContext ) {}	
-
-};
-#endif
Index: sc/source/ui/vba/vbaspinbutton.hxx
===================================================================
--- sc/source/ui/vba/vbaspinbutton.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaspinbutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,61 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_SPINBUTTON_HXX
-#define SC_VBA_SPINBUTTON_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XSpinButton.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XSpinButton > SpinButtonImpl_BASE;
-
-class ScVbaSpinButton : public SpinButtonImpl_BASE
-{
-public:
-    ScVbaSpinButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getMax() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMax( ::sal_Int32 _max ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getMin() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMin( ::sal_Int32 _min ) throw (css::uno::RuntimeException);
-
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_SPINBUTTON_HXX
Index: sc/source/ui/vba/vbabutton.hxx
===================================================================
--- sc/source/ui/vba/vbabutton.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbabutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,51 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbabutton.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_BUTTON_HXX
-#define SC_VBA_BUTTON_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XButton.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XButton > ButtonImpl_BASE;
-
-class ScVbaButton : public ButtonImpl_BASE
-{
-public:
-    ScVbaButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
-   // Attributes
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_BUTTON_HXX
Index: sc/source/ui/vba/vbashaperange.hxx
===================================================================
--- sc/source/ui/vba/vbashaperange.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashaperange.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,66 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashaperange.hxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_SHAPERANGE_HXX
-#define SC_VBA_SHAPERANGE_HXX
-
-#include <com/sun/star/drawing/XShapes.hpp>
-#include <ooo/vba/msforms/XShapeRange.hpp>
-
-#include "vbacollectionimpl.hxx"
-
-typedef CollTestImplHelper< ov::msforms::XShapeRange > ScVbaShapeRange_BASE;
-
-class ScVbaShapeRange : public ScVbaShapeRange_BASE
-{
-private:
-    css::uno::Reference< css::drawing::XDrawPage > m_xDrawPage;
-    css::uno::Reference< css::drawing::XShapes > m_xShapes;
-    sal_Int32 m_nShapeGroupCount;
-protected:
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-	css::uno::Reference< css::drawing::XShapes > getShapes() throw (css::uno::RuntimeException) ;
-public:
-    ScVbaShapeRange( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xShapes, const css::uno::Reference< css::drawing::XDrawPage>& xDrawShape );
-
-    // Methods
-    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< ::ooo::vba::msforms::XShape > SAL_CALL Group() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
-    virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
-    //XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException); 
-    // ScVbaCollectionBaseImpl
-    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-};
-
-#endif//SC_VBA_SHAPERANGE_HXX
Index: sc/source/ui/vba/vbascrollbar.hxx
===================================================================
--- sc/source/ui/vba/vbascrollbar.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbascrollbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,66 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_SCROLLBAR_HXX
-#define SC_VBA_SCROLLBAR_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XScrollBar.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XScrollBar > ScrollBarImpl_BASE;
-
-class ScVbaScrollBar : public ScrollBarImpl_BASE
-{
-public:
-    ScVbaScrollBar( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
-   // Attributes
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getMax() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMax( ::sal_Int32 _max ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getMin() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMin( ::sal_Int32 _min ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getLargeChange() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setLargeChange( ::sal_Int32 _largechange ) throw (css::uno::RuntimeException);
-    virtual ::sal_Int32 SAL_CALL getSmallChange() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setSmallChange( ::sal_Int32 _smallchange ) throw (css::uno::RuntimeException);
-
-
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_LABEL_HXX
Index: sc/source/ui/vba/vbaframe.cxx
===================================================================
--- sc/source/ui/vba/vbaframe.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaframe.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,93 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbaframe.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
-ScVbaFrame::ScVbaFrame( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : FrameImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
-{
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaFrame::getCaption() throw (css::uno::RuntimeException)
-{
-    rtl::OUString Label;
-    m_xProps->getPropertyValue( LABEL ) >>= Label;
-    return Label;
-}
-
-void SAL_CALL 
-ScVbaFrame::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
-}
-
-uno::Any SAL_CALL 
-ScVbaFrame::getValue() throw (css::uno::RuntimeException)
-{
-    return uno::makeAny( getCaption() );
-}
-
-void SAL_CALL 
-ScVbaFrame::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
-{
-    rtl::OUString sCaption;
-    _value >>= sCaption;
-    setCaption( sCaption ); 
-}
-
-rtl::OUString& 
-ScVbaFrame::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFrame") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaFrame::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbacheckbox.hxx
===================================================================
--- sc/source/ui/vba/vbacheckbox.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacheckbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,60 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_CHECKBOX_HXX
-#define SC_VBA_CHECKBOX_HXX
-#include <cppuhelper/implbase2.hxx>
-#include <ooo/vba/msforms/XRadioButton.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > CheckBoxImpl_BASE;
-
-class ScVbaCheckbox : public CheckBoxImpl_BASE
-{
-public:
-    ScVbaCheckbox(  const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
-   // Attributes
-    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
-    // XDefaultProperty
-    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_CHECKBOX_HXX
Index: sc/source/ui/vba/vbalineformat.cxx
===================================================================
--- sc/source/ui/vba/vbalineformat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbalineformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,458 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbalineformat.cxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <ooo/vba/office/MsoArrowheadStyle.hpp>
-#include <ooo/vba/office/MsoArrowheadLength.hpp>
-#include <ooo/vba/office/MsoArrowheadWidth.hpp>
-#include <ooo/vba/office/MsoLineDashStyle.hpp>
-#include <com/sun/star/drawing/LineStyle.hpp>
-#include <com/sun/star/drawing/LineDash.hpp>
-#include "vbalineformat.hxx"
-#include "vbacolorformat.hxx"
-
-using namespace ooo::vba;
-using namespace com::sun::star;
-
-ScVbaLineFormat::ScVbaLineFormat( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape > xShape ) : ScVbaLineFormat_BASE( xParent, xContext ), m_xShape( xShape ) 
-{
-    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
-    m_nLineDashStyle = office::MsoLineDashStyle::msoLineSolid;
-    m_nLineWeight = 1;
-}
-
-sal_Int32
-ScVbaLineFormat::calculateArrowheadSize()
-{
-    return 0;
-}
-
-sal_Int32
-ScVbaLineFormat::convertLineStartEndNameToArrowheadStyle( rtl::OUString sLineName )
-{
-    sal_Int32 nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
-    if (sLineName.equals(rtl::OUString::createFromAscii("Small Arrow")) ||
-        sLineName.equals(rtl::OUString::createFromAscii("Arrow")) ||
-        sLineName.equals(rtl::OUString::createFromAscii("msArrowEnd")) ||
-        sLineName.equals(rtl::OUString::createFromAscii("Double Arrow")))
-    {
-        // msoArrowheadTriangle
-        nLineType = office::MsoArrowheadStyle::msoArrowheadTriangle;
-    }
-    else if (sLineName.equals(rtl::OUString::createFromAscii("Square 45")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("Square")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("msArrowDiamondEnd")))
-    {
-        // msoArrowheadDiamond
-        nLineType = office::MsoArrowheadStyle::msoArrowheadDiamond;
-    }
-    else if (sLineName.equals(rtl::OUString::createFromAscii("Circle")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("msArrowOvalEnd")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("Dimension Lines")) )
-    {
-        // msoArrowheadOval
-        nLineType = office::MsoArrowheadStyle::msoArrowheadOval;
-    }
-    else if (sLineName.equals(rtl::OUString::createFromAscii("Arrow concave")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("msArrowStealthEnd")))
-    {
-        // msoArrowheadStealth
-        nLineType = office::MsoArrowheadStyle::msoArrowheadStealth;
-    }
-    else if (sLineName.equals(rtl::OUString::createFromAscii("Rounded short Arrow")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("Rounded large Arrow")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("Symmetric Arrow")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("msArrowOpenEnd")) ||
-             sLineName.equals(rtl::OUString::createFromAscii("Line Arrow")))
-    {
-        // msoArrowheadOpen
-        nLineType = office::MsoArrowheadStyle::msoArrowheadOpen;
-    }
-    else
-    {
-        // msoArrowheadNone
-        nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
-    }
-    return nLineType;
-}
-
-rtl::OUString 
-ScVbaLineFormat::convertArrowheadStyleToLineStartEndName( sal_Int32 nArrowheadStyle ) throw (uno::RuntimeException)
-{
-    switch( nArrowheadStyle )
-    {
-        case office::MsoArrowheadStyle::msoArrowheadNone:
-            return rtl::OUString(rtl::OUString::createFromAscii( "" ) );
-        case office::MsoArrowheadStyle::msoArrowheadStealth:
-            return rtl::OUString::createFromAscii( "Arrow concave" );
-        case office::MsoArrowheadStyle::msoArrowheadOpen:
-            return rtl::OUString::createFromAscii("Line Arrow" );
-        case office::MsoArrowheadStyle::msoArrowheadOval:
-            return  rtl::OUString::createFromAscii("Circle" );
-        case office::MsoArrowheadStyle::msoArrowheadDiamond:
-            return rtl::OUString::createFromAscii( "Square 45" );
-        case office::MsoArrowheadStyle::msoArrowheadTriangle:
-            return rtl::OUString::createFromAscii( "Arrow" );
-        default:
-            throw uno::RuntimeException( rtl::OUString::createFromAscii("Invalid Arrow Style!"), uno::Reference< uno::XInterface >() );
-    }
-}
-
-// Attributes
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getBeginArrowheadStyle() throw (uno::RuntimeException)
-{
-    sal_Int32 nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
-    rtl::OUString sLineName;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStartName" ) ) >>= sLineName;
-    if( ( sLineName.getLength() > 7 ) && ( sLineName.indexOf( rtl::OUString::createFromAscii( "msArray" ) ) ) != -1 )
-    {
-        sal_Int32 nIndex = sLineName.indexOf( rtl::OUString::createFromAscii(" ") );
-        rtl::OUString sName = sLineName.copy( 0, nIndex );
-        //sal_Int32 nSize = sLineName.copy( nIndex + 1 ).toInt32();
-        nLineType = convertLineStartEndNameToArrowheadStyle( sName );
-    }
-    else
-    {
-        nLineType = convertLineStartEndNameToArrowheadStyle( sLineName );
-    }
-    return nLineType;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setBeginArrowheadStyle( sal_Int32 _beginarrowheadstyle ) throw (uno::RuntimeException)
-{
-    rtl::OUString sArrayName = convertArrowheadStyleToLineStartEndName( _beginarrowheadstyle );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStartName" ), uno::makeAny( sArrayName ) );
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getBeginArrowheadLength() throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setBeginArrowheadLength( sal_Int32 /*_beginarrowheadlength*/ ) throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getBeginArrowheadWidth() throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setBeginArrowheadWidth( sal_Int32 /*_beginarrowheadwidth*/ ) throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getEndArrowheadStylel() throw (uno::RuntimeException)
-{
-    return 0;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setEndArrowheadStylel( sal_Int32 /*_endarrowheadstylel*/ ) throw (uno::RuntimeException)
-{
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getEndArrowheadLength() throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setEndArrowheadLength( sal_Int32 /*_endarrowheadlength*/ ) throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getEndArrowheadWidth() throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setEndArrowheadWidth( sal_Int32 /*_endarrowheadwidth*/ ) throw (uno::RuntimeException)
-{
-    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
-}
-
-double SAL_CALL 
-ScVbaLineFormat::getWeight() throw (uno::RuntimeException)
-{
-    sal_Int32 nLineWidth=0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineWidth") ) >>= nLineWidth;
-    double dLineWidth = Millimeter::getInPoints( nLineWidth );
-    return dLineWidth;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setWeight( double _weight ) throw (uno::RuntimeException)
-{
-    if( _weight < 0 )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter: Must be positv."), uno::Reference< uno::XInterface >() );
-    if( _weight == 0 )
-        _weight = 0.5;
-    m_nLineWeight = _weight;
-    Millimeter aMillimeter;
-    aMillimeter.setInPoints( _weight );
-        
-    sal_Int32 nLineWidth = static_cast<sal_Int32>( aMillimeter.getInHundredthsOfOneMillimeter() );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineWidth" ), uno::makeAny( nLineWidth ) );
-    setDashStyle( m_nLineDashStyle );
-}
-
-sal_Bool SAL_CALL 
-ScVbaLineFormat::getVisible() throw (uno::RuntimeException)
-{
-    drawing::LineStyle aLineStyle;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= aLineStyle;
-    if( aLineStyle == drawing::LineStyle_NONE )
-    {
-        return sal_False;
-    }
-    return sal_True;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
-{
-    drawing::LineStyle aLineStyle;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= aLineStyle;
-    if( !_visible )
-    {
-        aLineStyle = drawing::LineStyle_NONE;
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( aLineStyle ) );
-    }
-    else
-    {
-        if( aLineStyle == drawing::LineStyle_NONE )
-        {
-            setDashStyle( m_nLineDashStyle );
-        }
-    }
-}
-
-double SAL_CALL 
-ScVbaLineFormat::getTransparency() throw (uno::RuntimeException)
-{
-    sal_Int16 nTransparency = 0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineTransparence" ) ) >>= nTransparency;
-    double fTransparency = static_cast<double>( nTransparency );
-    return fTransparency / 100;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setTransparency( double _transparency ) throw (uno::RuntimeException)
-{
-    sal_Int16 nTransparency = static_cast<sal_Int16>( _transparency * 100 );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineTransparence" ), uno::makeAny( nTransparency ) );
-}
-
-sal_Int16 SAL_CALL 
-ScVbaLineFormat::getStyle() throw (uno::RuntimeException)
-{
-    //OpenOffice.org only supports one LineStyle (other than the DashStyles)
-    //Therefore we can only return the SingleLine
-    return 1;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setStyle( sal_Int16 /*_style */) throw (uno::RuntimeException)
-{
-    //OpenOffice.org only supports one LineStyle (other than the DashStyles)
-    //Therefore we do not set the LineStyle, because it maybe is already set
-    //to Dashed or Single Line. Setting the 'Visible' or 'DashStyle' properties
-    //will be done with the according methods.
-}
-
-sal_Int32 SAL_CALL 
-ScVbaLineFormat::getDashStyle() throw (uno::RuntimeException)
-{
-    drawing::LineStyle eLineStyle;
-    //LineStyle integer in Xray
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= eLineStyle;
-    if( eLineStyle == drawing::LineStyle_SOLID )
-        m_nLineDashStyle = office::MsoLineDashStyle::msoLineSolid;
-    else
-    {
-        drawing::LineDash aLineDash;
-        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineDash" ) ) >>= aLineDash;
-        if( aLineDash.Dots == 0 )
-        {
-            //LineDash
-            //LineLongDash
-            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDash;
-            if( aLineDash.Distance > 0 && ( aLineDash.DashLen / aLineDash.Distance > 1 ) )
-            {
-                m_nLineDashStyle = office::MsoLineDashStyle::msoLineLongDash;
-            }
-        }
-        else if( aLineDash.Dots == 1 )
-        {
-            // LineDashDot
-            // LineLongDashDot
-            // LineSquareDot
-            // LineRoundDot ! not supported
-            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDashDot;
-            if( aLineDash.Dashes == 0 )
-            {
-                m_nLineDashStyle = office::MsoLineDashStyle::msoLineSquareDot;
-            }
-            else
-            {
-                if( aLineDash.Distance > 0 && ( aLineDash.DashLen / aLineDash.Distance > 1 ) )
-                {
-                    m_nLineDashStyle = office::MsoLineDashStyle::msoLineLongDashDot;
-                }
-            }
-        }
-        else if( aLineDash.Dots == 2 )
-        {
-            // LineDashDotDot
-            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDashDotDot;
-        }
-    }
-
-    return m_nLineDashStyle;
-}
-
-void SAL_CALL 
-ScVbaLineFormat::setDashStyle( sal_Int32 _dashstyle ) throw (uno::RuntimeException)
-{
-    m_nLineDashStyle = _dashstyle;
-    if( _dashstyle == office::MsoLineDashStyle::msoLineSolid )
-    {
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( drawing::LineStyle_SOLID  ));
-    }
-    else
-    {
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( drawing::LineStyle_DASH ) );
-        drawing::LineDash  pLineDash;
-        Millimeter aMillimeter( m_nLineWeight );
-        sal_Int32 nPixel = static_cast< sal_Int32 >( aMillimeter.getInHundredthsOfOneMillimeter() );
-        switch( _dashstyle )
-        {
-        case office::MsoLineDashStyle::msoLineDashDot:
-            pLineDash.Dots = 1;
-            pLineDash.DotLen = nPixel;
-            pLineDash.Dashes = 1;
-            pLineDash.DashLen = 5 * nPixel;
-            pLineDash.Distance = 4 * nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineLongDashDot:
-            pLineDash.Dots = 1;
-            pLineDash.DotLen = nPixel;
-            pLineDash.Dashes = 1;
-            pLineDash.DashLen = 10 * nPixel;
-            pLineDash.Distance = 4 * nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineDash:
-            pLineDash.Dots = 0;
-            pLineDash.DotLen = 0;
-            pLineDash.Dashes = 1;
-            pLineDash.DashLen = 6 * nPixel;
-            pLineDash.Distance = 4 * nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineDashDotDot:
-            pLineDash.Dots = 2;
-            pLineDash.DotLen = nPixel;
-            pLineDash.Dashes = 1;
-            pLineDash.DashLen = 10 * nPixel;
-            pLineDash.Distance = 3 * nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineLongDash:
-            pLineDash.Dots = 0;
-            pLineDash.DotLen = 0;
-            pLineDash.Dashes = 1;
-            pLineDash.DashLen = 10 * nPixel;
-            pLineDash.Distance = 4 * nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineSquareDot:
-            pLineDash.Dots = 1;
-            pLineDash.DotLen = nPixel;
-            pLineDash.Dashes = 0;
-            pLineDash.DashLen = 0;
-            pLineDash.Distance = nPixel;
-            break;
-        case office::MsoLineDashStyle::msoLineRoundDot:
-            pLineDash.Dots = 1;
-            pLineDash.DotLen = nPixel;
-            pLineDash.Dashes = 0;
-            pLineDash.DashLen = 0;
-            pLineDash.Distance = nPixel;
-            break;
-        default:
-            throw uno::RuntimeException( rtl::OUString::createFromAscii("this MsoLineDashStyle is not supported."), uno::Reference< uno::XInterface >() );
-        }
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineDash" ), uno::makeAny( pLineDash ) );
-    }
-}
-
-// Methods
-uno::Reference< msforms::XColorFormat > SAL_CALL
-ScVbaLineFormat::BackColor() throw (uno::RuntimeException)
-{
-    return uno::Reference< msforms::XColorFormat >( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ::ColorFormatType::LINEFORMAT_BACKCOLOR ) );
-}
-
-uno::Reference< msforms::XColorFormat > SAL_CALL
-ScVbaLineFormat::ForeColor() throw (uno::RuntimeException)
-{
-    return uno::Reference< msforms::XColorFormat >( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ::ColorFormatType::LINEFORMAT_FORECOLOR ) );
-}
-
-
-rtl::OUString& 
-ScVbaLineFormat::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaLineFormat") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaLineFormat::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.LineFormat" ) );
-	}
-	return aServiceNames;
-}
-
-
Index: sc/source/ui/vba/vbacombobox.cxx
===================================================================
--- sc/source/ui/vba/vbacombobox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacombobox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,175 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacombobox.cxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include "vbacombobox.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-//SelectedItems list of integer indexes
-//StringItemList list of items
-
-const static rtl::OUString TEXT( RTL_CONSTASCII_USTRINGPARAM("Text") );
-const static rtl::OUString SELECTEDITEMS( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") );
-const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
-const static rtl::OUString CONTROLSOURCEPROP( RTL_CONSTASCII_USTRINGPARAM("DataFieldProperty") );
-
-ScVbaComboBox::ScVbaComboBox( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, bool bDialogType ) : ComboBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper ), mbDialogType( bDialogType )
-{
-    	mpListHelper.reset( new ListControlHelper( m_xProps ) );
-	// grab the default value property name
-	m_xProps->getPropertyValue( CONTROLSOURCEPROP ) >>= sSourceName;
-}
-
-// Attributes
-
-
-// Value, [read] e.g. getValue returns the value of ooo Text propery e.g. the value in
-// the drop down
-uno::Any SAL_CALL 
-ScVbaComboBox::getValue() throw (uno::RuntimeException)
-{
-	return m_xProps->getPropertyValue( sSourceName );
-}
-
-void SAL_CALL 
-ScVbaComboBox::setListIndex( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-    uno::Sequence< sal_Int16 > sSelection(1);
-    _value >>= sSelection[ 0 ];
-    m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( sSelection ) );
-}
-
-uno::Any SAL_CALL 
-ScVbaComboBox::getListIndex() throw (uno::RuntimeException)
-{
-	uno::Sequence< rtl::OUString > sItems;
-	m_xProps->getPropertyValue( ITEMS ) >>= sItems;
-	// should really return the item that has focus regardless of
-	// it been selected
-	if ( sItems.getLength() > 0 )
-	{
-		rtl::OUString sText = getText();
-		sal_Int32 nLen = sItems.getLength();
-		for ( sal_Int32 index = 0; sText.getLength() && index < nLen; ++index )
-		{
-			if ( sItems[ index ].equals( sText ) )
-			{
-				OSL_TRACE("getListIndex returning %d", index );
-				return uno::makeAny( index );
-			}
-				
-		} 
- 	} 
-	OSL_TRACE("getListIndex returning %d", -1 );
-	return uno::makeAny( sal_Int32( -1 ) );
-}
-
-// Value, [write]e.g. setValue sets the value in the drop down, and if the value is one
-// of the values in the list then the selection is also set
-void SAL_CALL 
-ScVbaComboBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
-{
-	m_xProps->setPropertyValue( sSourceName, _value );
-}
-
-// see Value
-
-::rtl::OUString SAL_CALL 
-ScVbaComboBox::getText() throw (uno::RuntimeException)
-{
-	rtl::OUString result;
-	getValue() >>= result;
-	return result;
-}
-
-void SAL_CALL 
-ScVbaComboBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
-{
-	setValue( uno::makeAny( _text ) ); // seems the same
-}
-
-// Methods
-void SAL_CALL 
-ScVbaComboBox::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
-{
-	mpListHelper->AddItem( pvargItem, pvargIndex );
-}
-
-void SAL_CALL 
-ScVbaComboBox::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
-	{
-	mpListHelper->removeItem( index );
-}
-
-void SAL_CALL 
-ScVbaComboBox::Clear(  ) throw (uno::RuntimeException)
-		{
-	mpListHelper->Clear();
-		}
-
-void SAL_CALL
-ScVbaComboBox::setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException)
-{
-	ScVbaControl::setRowSource( _rowsource );
-	mpListHelper->setRowSource( _rowsource );
-		}
-
-sal_Int32 SAL_CALL
-ScVbaComboBox::getListCount() throw (uno::RuntimeException)
-{
-	return mpListHelper->getListCount();
-}
-		
-uno::Any SAL_CALL 
-ScVbaComboBox::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
-{
-	return mpListHelper->List( pvargIndex, pvarColumn );
-	}
-
-rtl::OUString& 
-ScVbaComboBox::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaComboBox") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaComboBox::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ComboBox" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbacommandbar.hxx
===================================================================
--- sc/source/ui/vba/vbacommandbar.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,105 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_COMMANDBAR_HXX
-#define SC_VBA_COMMANDBAR_HXX
-
-#include <ooo/vba/XCommandBar.hpp>
-#include <com/sun/star/ui/XUIConfigurationManager.hpp>
-#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
-#include <com/sun/star/container/XIndexContainer.hpp>
-#include <com/sun/star/beans/PropertyValues.hpp>
-
-#include "vbahelperinterface.hxx"
-#include "vbacommandbars.hxx"
-
-#include <map>
-typedef std::map< const rtl::OUString, rtl::OUString > CommandBarNameMap;
-typedef std::pair< const rtl::OUString, rtl::OUString > CommandBarNamePair;
-const CommandBarNamePair namePair[] = { 
-    CommandBarNamePair(  rtl::OUString::createFromAscii("standard"), rtl::OUString::createFromAscii("standardbar") ),
-    CommandBarNamePair(  rtl::OUString::createFromAscii("formatting"), rtl::OUString::createFromAscii("formatobjectbar") ),
-};
-static const CommandBarNameMap mCommandBarNameMap( namePair, ( namePair + sizeof(namePair) / sizeof(namePair[0]) ) );
-
-
-typedef InheritedHelperInterfaceImpl1< ov::XCommandBar > CommandBar_BASE;
-
-class ScVbaCommandBar : public CommandBar_BASE
-{
-private:
-    rtl::OUString       m_sToolBarName;
-    rtl::OUString       m_sMenuModuleName;
-    rtl::OUString       m_sUIName;
-    sal_Bool            m_bTemporary;
-    sal_Bool            m_bIsMenu;
-    sal_Bool            m_bCustom;
-    sal_Bool            m_bCreate;
-    ScVbaCommandBars*   m_pScVbaCommandBars;
-    css::beans::PropertyValues  m_aToolBar;
-    // hard reference for parent
-    css::uno::Reference< ov::XHelperInterface >               m_xParentHardRef;
-    css::uno::Reference< css::ui::XUIConfigurationManager >         m_xUICfgManager;
-    css::uno::Reference< css::ui::XUIConfigurationPersistence >     m_xUICfgPers;
-    css::uno::Reference< css::container::XIndexContainer >          m_xBarSettings;
-    void initCommandBar() throw( css::uno::RuntimeException );
-protected:
-    void getToolBarSettings( rtl::OUString sToolBarName ) throw( css::uno::RuntimeException );
-    void getMenuSettings();
-    void addCustomBar();
-public:
-    ScVbaCommandBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, sal_Int32 nModuleType ) throw( css::uno::RuntimeException );
-    ScVbaCommandBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, rtl::OUString sToolBarName, sal_Bool bTemporary, sal_Bool bCreate ) throw( css::uno::RuntimeException );
-    
-    sal_Bool IsMenu() { return m_bIsMenu; };
-    css::uno::Reference< css::ui::XUIConfigurationManager > GetUICfgManager() { return m_xUICfgManager; };
-    css::uno::Reference< css::ui::XUIConfigurationPersistence > GetUICfgPers() { return m_xUICfgPers; };
-    css::uno::Reference< css::container::XIndexContainer > GetBarSettings() { return m_xBarSettings; };
-    rtl::OUString GetToolBarName() { return m_sToolBarName; };
-
-    // Attributes
-    virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setName( const ::rtl::OUString& _name ) throw (css::uno::RuntimeException);
-    virtual ::sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( ::sal_Bool _visible ) throw (css::uno::RuntimeException);
-
-    // Methods
-    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-
-	// XHelperInterface
-	virtual rtl::OUString& getServiceImplName();
-	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif//SC_VBA_COMMANDBAR_HXX
Index: sc/source/ui/vba/vbaimage.hxx
===================================================================
--- sc/source/ui/vba/vbaimage.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaimage.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,48 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile$
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_IMAGE_HXX
-#define SC_VBA_IMAGE_HXX
-#include <cppuhelper/implbase1.hxx>
-#include <ooo/vba/msforms/XImage.hpp>
-
-#include "vbacontrol.hxx"
-#include "vbahelper.hxx"
-
-typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XImage > ImageImpl_BASE;
-
-class ScVbaImage : public ImageImpl_BASE
-{
-public:
-    ScVbaImage( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
-    //XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-#endif //SC_VBA_IMAGE_HXX
Index: sc/source/ui/vba/vbacolorformat.hxx
===================================================================
--- sc/source/ui/vba/vbacolorformat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacolorformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,128 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacolorformat.hxx,v $
- * $Revision: 1.3.146.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#ifndef SC_VBA_XCOLORFORMAT_HXX
-#define SC_VBA_XCOLORFORMAT_HXX
-
-#include <com/sun/star/drawing/XShape.hpp>
-#include <ooo/vba/msforms/XColorFormat.hpp>
-#include <ooo/vba/msforms/XFillFormat.hpp>
-#include "vbahelperinterface.hxx"
-#include "vbafillformat.hxx"
-
-typedef InheritedHelperInterfaceImpl1< ov::msforms::XColorFormat > ScVbaColorFormat_BASE;
-
-class ColorFormatType
-{
-public:
-    const static sal_Int16 LINEFORMAT_FORECOLOR = 1;
-    const static sal_Int16 LINEFORMAT_BACKCOLOR = 2;
-    const static sal_Int16 FILLFORMAT_FORECOLOR = 3;
-    const static sal_Int16 FILLFORMAT_BACKCOLOR = 4;
-    const static sal_Int16 THREEDFORMAT_EXTRUSIONCOLOR = 5;
-};
-
-struct MsoColorIndizes
-{
-    const static sal_Int32 HAPICOLOR_BLACK = 0;
-    const static sal_Int32 HAPICOLOR_WITHE = 16777215;
-    const static sal_Int32 HAPICOLOR_RED = 16711680;
-    const static sal_Int32 HAPICOLOR_BRIGHTGREEN = 65280;
-    const static sal_Int32 HAPICOLOR_BLUE = 255;
-    const static sal_Int32 HAPICOLOR_YELLOW = 16776960;
-    const static sal_Int32 HAPICOLOR_PINK = 16711935;
-    const static sal_Int32 HAPICOLOR_TURQUOISE = 65535;
-    const static sal_Int32 HAPICOLOR_DARKRED = 8388608;
-    const static sal_Int32 HAPICOLOR_GREEN = 32768;
-    const static sal_Int32 HAPICOLOR_DARKBLUE = 128;
-    const static sal_Int32 HAPICOLOR_DARKYELLOW = 8421376;
-    const static sal_Int32 HAPICOLOR_VIOLET = 8388736;
-    const static sal_Int32 HAPICOLOR_TEAL = 32896;
-    const static sal_Int32 HAPICOLOR_GRAY_25_PERCENT = 12632256;
-    const static sal_Int32 HAPICOLOR_GRAY_50_PERCENT = 8421504;
-    const static sal_Int32 HAPICOLOR_PERIWINCKLE = 10066431;
-    const static sal_Int32 HAPICOLOR_PLUM = 10040166;
-    const static sal_Int32 HAPICOLOR_IVORY = 16777164;
-    const static sal_Int32 HAPICOLOR_LIGHTTURQUOISE = 13434879;
-    const static sal_Int32 HAPICOLOR_DARKPRUPLE = 6684774;
-    const static sal_Int32 HAPICOLOR_CORAL = 16744576;
-    const static sal_Int32 HAPICOLOR_OCEANBLUE = 26316;
-    const static sal_Int32 HAPICOLOR_ICEBLUE = 13421823;
-    const static sal_Int32 HAPICOLOR_SKYBLUE = 52479;
-    const static sal_Int32 HAPICOLOR_LIGHTGREEN = 13434828;
-    const static sal_Int32 HAPICOLOR_LIGHTYELLOW = 16777113;
-    const static sal_Int32 HAPICOLOR_PALEBLUE = 10079487;
-    const static sal_Int32 HAPICOLOR_ROSE = 16751052;
-    const static sal_Int32 HAPICOLOR_LAVENDER = 13408767;
-    const static sal_Int32 HAPICOLOR_TAN = 16764057;
-    const static sal_Int32 HAPICOLOR_LIGHTBLUE = 3368703;
-    const static sal_Int32 HAPICOLOR_AQUA = 3394764;
-    const static sal_Int32 HAPICOLOR_LIME = 10079232;
-    const static sal_Int32 HAPICOLOR_GOLD = 16763904;
-    const static sal_Int32 HAPICOLOR_LIGHTORANGE = 16750848;
-    const static sal_Int32 HAPICOLOR_ORANGE = 16737792;
-    const static sal_Int32 HAPICOLOR_BLUEGRAY = 6710937;
-    const static sal_Int32 HAPICOLOR_GRAY_40_PERCENT = 9868950;
-    const static sal_Int32 HAPICOLOR_DARKTEAL = 13158;
-    const static sal_Int32 HAPICOLOR_SEAGREEN = 3381606;
-    const static sal_Int32 HAPICOLOR_NONAME = 13056;
-    const static sal_Int32 HAPICOLOR_OLIVEGREEN = 3355392;
-    const static sal_Int32 HAPICOLOR_BROWN = 10040064;
-    const static sal_Int32 HAPICOLOR_INDIGO = 3355545;
-    const static sal_Int32 HAPICOLOR_GRAY_80_PERCENT = 3355443;
-
-    static sal_Int32 getColorIndex( sal_Int32 nIndex );
-    
-};
-
-class ScVbaColorFormat : public ScVbaColorFormat_BASE
-{
-private:
-    css::uno::Reference< ov::XHelperInterface > m_xInternalParent;
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-    ScVbaFillFormat *m_pFillFormat;
-    sal_Int16 m_nColorFormatType;
-    sal_Int32 m_nFillFormatBackColor;
-protected:
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    void setColorFormat( sal_Int16 nType );
-public:
-    ScVbaColorFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XHelperInterface > xInternalParent, const css::uno::Reference< css::drawing::XShape > xShape, const sal_Int16 nColorFormatType );
-
-    // Attributes
-    virtual sal_Int32 SAL_CALL getRGB() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setRGB( sal_Int32 _rgb ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getSchemeColor() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setSchemeColor( sal_Int32 _schemecolor ) throw (css::uno::RuntimeException);
-
-};
-
-#endif//SC_VBA_XCOLORFORMAT_HXX
Index: sc/source/ui/vba/vbacommandbarcontrols.hxx
===================================================================
--- sc/source/ui/vba/vbacommandbarcontrols.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbarcontrols.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,90 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#ifndef SC_VBA_COMMANDBARCONTROLS_HXX
-#define SC_VBA_COMMANDBARCONTROLS_HXX
-
-#include <ooo/vba/XCommandBarControls.hpp>
-
-#include "vbahelperinterface.hxx"
-#include "vbacommandbar.hxx"
-#include "vbacollectionimpl.hxx"
-
-class ScVbaCommandBarControl;
-
-typedef CollTestImplHelper< ov::XCommandBarControls > CommandBarControls_BASE;
-
-class ScVbaCommandBarControls : public CommandBarControls_BASE
-{
-private:
-    sal_Bool                    m_bIsMenu;
-    sal_Bool                    m_bHasElements;
-    ScVbaCommandBar*            m_pCommandBar; 
-    ScVbaCommandBarControl*     m_pCommandBarControl; 
-    css::uno::Reference< ov::XHelperInterface >               m_xParentHardRef;
-    css::uno::Reference< css::ui::XUIConfigurationManager >         m_xUICfgManager;
-    css::uno::Reference< css::ui::XUIConfigurationPersistence >     m_xUICfgPers;
-    css::uno::Reference< css::container::XIndexContainer >          m_xBarSettings;
-
-public:
-    ScVbaCommandBarControls( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< css::container::XIndexAccess > xIndexAccess ) throw( css::uno::RuntimeException );
-    css::uno::Reference< css::ui::XUIConfigurationManager > GetUICfgManager() { return m_xUICfgManager; };
-    css::uno::Reference< css::ui::XUIConfigurationPersistence > GetUICfgPers() { return m_xUICfgPers; };
-    css::uno::Reference< css::container::XIndexContainer >  GetBarSettings() { return m_xBarSettings; };
-    sal_Bool IsMenu() { return m_bIsMenu; };
-    ScVbaCommandBar* GetParentCommandBar() { return m_pCommandBar; };
-    ScVbaCommandBarControl* GetParentCommandBarControl() { return m_pCommandBarControl; };
-    rtl::OUString GetParentToolBarName() 
-    { 
-        if( m_pCommandBar ) return m_pCommandBar->GetToolBarName();
-        else return rtl::OUString();
-    }
-    rtl::OUString GetControlNameByIndex( const sal_Int32 nIndex ) throw ( css::uno::RuntimeException );
-
-    // Attributes
-    virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
-    // XEnumerationAccess
-    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
-    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
-    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
-
-    // Methods     
-    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
-    virtual css::uno::Reference< ov::XCommandBarControl > SAL_CALL Add( const css::uno::Any& Type, const css::uno::Any& Id, const css::uno::Any& Parameter, const css::uno::Any& Before, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
-    // XHelperInterface
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-};
-
-#endif//SC_VBA_COMMANDBARCONTROLS_HXX
Index: sc/source/ui/vba/vbatextbox.cxx
===================================================================
--- sc/source/ui/vba/vbatextbox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,137 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbatextbox.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/text/XTextRange.hpp>
-
-#include "vbatextbox.hxx"
-#include <vector>
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-
-
-ScVbaTextBox::ScVbaTextBox( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, bool bDialog ) : TextBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper ), mbDialog( bDialog )
-{
-}
-
-// Attributes
-uno::Any SAL_CALL 
-ScVbaTextBox::getValue() throw (css::uno::RuntimeException)
-{
-	return uno::makeAny( getText() );
-}
-
-void SAL_CALL 
-ScVbaTextBox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeException)
-{
-	rtl::OUString sVal = getAnyAsString( _value );
-	setText( sVal );
-}
-
-//getString() will cause some imfo lose.
-rtl::OUString SAL_CALL 
-ScVbaTextBox::getText() throw (css::uno::RuntimeException)
-{
-    uno::Any aValue;
-    aValue = m_xProps->getPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Text" ) ) );
-    rtl::OUString sString;
-    aValue >>= sString;
-    return sString;
-}
-
-void SAL_CALL 
-ScVbaTextBox::setText( const rtl::OUString& _text ) throw (css::uno::RuntimeException)
-{
-    if ( !mbDialog )
-    {
-    uno::Reference< text::XTextRange > xTextRange( m_xProps, uno::UNO_QUERY_THROW );
-    xTextRange->setString( _text );
-}
-    else
-        m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Text") ), uno::makeAny( _text ) ); 
-}
-
-sal_Int32 SAL_CALL 
-ScVbaTextBox::getMaxLength() throw (css::uno::RuntimeException)
-{
-    uno::Any aValue;
-    aValue = m_xProps->getPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ) );
-    sal_Int32 nMaxLength = 0;
-    aValue >>= nMaxLength;
-    return nMaxLength;
-}
-
-void SAL_CALL 
-ScVbaTextBox::setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException)
-{
-    uno::Any aValue( _maxlength );
-    m_xProps->setPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ), aValue);
-}
-
-sal_Bool SAL_CALL 
-ScVbaTextBox::getMultiline() throw (css::uno::RuntimeException)
-{
-    uno::Any aValue;
-    aValue = m_xProps->getPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiLine" ) ) );
-    sal_Bool bRet = false;
-    aValue >>= bRet;
-    return bRet;
-}
-
-void SAL_CALL 
-ScVbaTextBox::setMultiline( sal_Bool _multiline ) throw (css::uno::RuntimeException)
-{
-    uno::Any aValue( _multiline );
-    m_xProps->setPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiLine" ) ), aValue);
-}
-
-rtl::OUString& 
-ScVbaTextBox::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaTextBox") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaTextBox::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.TextBox" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbashape.cxx
===================================================================
--- sc/source/ui/vba/vbashape.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbashape.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,480 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbashape.cxx,v $
- * $Revision: 1.4 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include<ooo/vba/office/MsoZOrderCmd.hpp>
-#include<ooo/vba/office/MsoScaleFrom.hpp>
-#include<com/sun/star/container/XNamed.hpp>
-#include<com/sun/star/drawing/ConnectorType.hpp>
-#include <com/sun/star/lang/XEventListener.hpp>
-#include<com/sun/star/drawing/XDrawPagesSupplier.hpp>
-#include<com/sun/star/drawing/XDrawPages.hpp>
-
-#include <vos/mutex.hxx>
-#include <vcl/svapp.hxx>
-#include <svx/unopage.hxx>
-#include <svx/unoshape.hxx>
-
-#include "vbashape.hxx"
-#include "vbatextframe.hxx"
-#include "vbalineformat.hxx"
-#include "vbafillformat.hxx"
-#include "vbapictureformat.hxx"
-
-using namespace ::ooo::vba;
-using namespace ::com::sun::star;
-using namespace ::vos;
-
-ScVbaShape::ScVbaShape( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< drawing::XShapes >& xShapes, sal_Int32 nType ) throw( lang::IllegalArgumentException ) : ScVbaShape_BASE( xParent, xContext ), m_xShape( xShape ), m_xShapes( xShapes ), m_nType( nType )
-{
-    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
-    addListeners();
-}
-
-ScVbaShape::ScVbaShape( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape ) throw( lang::IllegalArgumentException ) : ScVbaShape_BASE( uno::Reference< XHelperInterface >(), xContext ), m_xShape( xShape )
-{
-    // add listener
-    addListeners();
-}
-
-ScVbaShape::~ScVbaShape()
-{ 
-    // dtor must never ever throw
-    try
-    {
-        removeShapeListener();
-        removeShapesListener();
-    }
-    catch( uno::Exception& )
-    {
-    }    
-}
-
-void SAL_CALL 
-ScVbaShape::disposing( const lang::EventObject& rEventObject ) throw( uno::RuntimeException )
-{
-    uno::Reference< drawing::XShapes > xShapes( rEventObject.Source, uno::UNO_QUERY );
-    uno::Reference< drawing::XShape > xShape( rEventObject.Source, uno::UNO_QUERY );
-    if ( xShapes.is() )
-        removeShapesListener();
-    if ( xShape.is() )
-        removeShapeListener();
-}
-
-
-void ScVbaShape::addListeners()
-{
-    uno::Reference< lang::XComponent > xComponent( m_xShape, uno::UNO_QUERY );
-    if ( xComponent.is() )
-    	xComponent->addEventListener( this );
-
-    xComponent.set( m_xShapes, uno::UNO_QUERY );
-    if ( xComponent.is() )
-    	xComponent->addEventListener( this );
-}
-
-void
-ScVbaShape::removeShapeListener() throw( uno::RuntimeException )
-{
-    if( m_xShape.is() )
-    {
-        uno::Reference< lang::XComponent > xComponent( m_xShape, uno::UNO_QUERY_THROW );
-        xComponent->removeEventListener( this );
-    }
-    m_xShape = NULL;
-    m_xPropertySet = NULL;
-}
-
-void
-ScVbaShape::removeShapesListener() throw( uno::RuntimeException )
-{
-    if( m_xShapes.is() )
-    {
-        uno::Reference< lang::XComponent > xComponent( m_xShapes, uno::UNO_QUERY_THROW );
-        xComponent->removeEventListener( this );
-    }
-    m_xShapes = NULL;
-}
-
-sal_Int32 
-ScVbaShape::getType( const css::uno::Reference< drawing::XShape > xShape ) throw (uno::RuntimeException)
-{
-    rtl::OUString sShapeType;
-    uno::Reference< drawing::XShapeDescriptor > xShapeDescriptor( xShape, uno::UNO_QUERY_THROW );
-    sShapeType = xShapeDescriptor->getShapeType();
-    // office::MsoShapeType::msoDiagram to "com.sun.star.drawing.GroupShape"
-    if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.GroupShape" ) ) )
-        return office::MsoShapeType::msoGroup;
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.GraphicObjectShape" ) ) )
-        return office::MsoShapeType::msoPicture;
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.ControlShape" ) ) )
-        return office::MsoShapeType::msoOLEControlObject;
-    // OOo don't support office::MsoShapeType::msoComment as a Shape.
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.OLE2Shape" ) ) )
-        return office::MsoShapeType::msoChart;
-    // Art characters office::MsoShapeType::msoTextEffect, in OOo corresponding to "com.sun.star.drawing.CustomShape"
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.ConnectorShape" ) ) )
-    {
-        enum drawing::ConnectorType connectorType;
-        uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
-        xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("EdgeKind")) >>= connectorType;
-        if( connectorType == drawing::ConnectorType_CURVE )
-            return office::MsoShapeType::msoFreeform;
-        else if( connectorType == drawing::ConnectorType_LINE )
-            return office::MsoShapeType::msoLine;
-        else 
-            return office::MsoShapeType::msoAutoShape;
-    }
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.LineShape" ) ) )
-        return office::MsoShapeType::msoLine;
-    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.CustomShape" ) ) ||
-            sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape") ) )
-        return office::MsoShapeType::msoAutoShape;
-    else
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "the shape type do not be surppored: " ) + sShapeType, uno::Reference< uno::XInterface >() );
-}
-
-// Attributes
-rtl::OUString SAL_CALL 
-ScVbaShape::getName() throw (uno::RuntimeException)
-{
-    rtl::OUString sName;
-    uno::Reference< container::XNamed > xNamed( m_xShape, uno::UNO_QUERY_THROW );
-    sName = xNamed->getName();
-    return sName;
-}
-
-void SAL_CALL 
-ScVbaShape::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
-{
-    uno::Reference< container::XNamed > xNamed( m_xShape, uno::UNO_QUERY_THROW );
-    xNamed->setName( _name );
-}
-
-double SAL_CALL 
-ScVbaShape::getHeight() throw (uno::RuntimeException)
-{
-    return Millimeter::getInPoints( m_xShape->getSize().Height );
-}
-
-void SAL_CALL 
-ScVbaShape::setHeight( double _height ) throw (uno::RuntimeException)
-{
-    awt::Size aSize( m_xShape->getSize() );
-    aSize.Height = Millimeter::getInHundredthsOfOneMillimeter( _height );
-    m_xShape->setSize( aSize );
-}
-
-double SAL_CALL 
-ScVbaShape::getWidth() throw (uno::RuntimeException)
-{
-    return Millimeter::getInPoints( m_xShape->getSize().Width );
-}
-
-void SAL_CALL 
-ScVbaShape::setWidth( double _width ) throw (uno::RuntimeException)
-{
-    awt::Size aSize( m_xShape->getSize() );
-    aSize.Width = Millimeter::getInHundredthsOfOneMillimeter( _width );
-    m_xShape->setSize( aSize );
-}
-
-double SAL_CALL 
-ScVbaShape::getLeft() throw (uno::RuntimeException)
-{
-    return Millimeter::getInPoints( m_xShape->getPosition().X );
-}
-
-void SAL_CALL 
-ScVbaShape::setLeft( double _left ) throw (uno::RuntimeException)
-{
-    awt::Point oldPosition;
-    oldPosition = m_xShape->getPosition();
-    oldPosition.X = Millimeter::getInHundredthsOfOneMillimeter( _left );
-    m_xShape->setPosition( oldPosition );
-}
-
-double SAL_CALL 
-ScVbaShape::getTop() throw (uno::RuntimeException)
-{
-    return Millimeter::getInPoints( m_xShape->getPosition().Y );
-}
-
-void SAL_CALL 
-ScVbaShape::setTop( double _top ) throw (uno::RuntimeException)
-{
-    awt::Point oldPosition;
-    oldPosition = m_xShape->getPosition();
-    oldPosition.Y = Millimeter::getInHundredthsOfOneMillimeter( _top );
-    m_xShape->setPosition( oldPosition );
-}
-
-sal_Bool SAL_CALL 
-ScVbaShape::getVisible() throw (uno::RuntimeException)
-{
-    //UNO Shapes are always visible
-    return sal_True;
-}
-
-void SAL_CALL 
-ScVbaShape::setVisible( sal_Bool /*_visible*/ ) throw (uno::RuntimeException)
-{
-    //UNO Shapes are always visible
-}
-
-sal_Int32 SAL_CALL 
-ScVbaShape::getZOrderPosition() throw (uno::RuntimeException)
-{
-    sal_Int32 nZOrderPosition = 0;
-    uno::Any aZOrderPosition =  m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ) );
-    aZOrderPosition >>= nZOrderPosition;
-    return nZOrderPosition + 1;
-}
-
-sal_Int32 SAL_CALL 
-ScVbaShape::getType() throw (uno::RuntimeException)
-{
-    return m_nType;
-}
-
-double SAL_CALL 
-ScVbaShape::getRotation() throw (uno::RuntimeException)
-{
-    double dRotation = 0;
-    sal_Int32 nRotation = 0;
-    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "RotateAngle" ) ) >>= nRotation;
-    dRotation = static_cast< double >( nRotation /100 );
-    return dRotation;
-}
-
-void SAL_CALL 
-ScVbaShape::setRotation( double _rotation ) throw (uno::RuntimeException)
-{
-    sal_Int32 nRotation = static_cast < sal_Int32 > ( _rotation * 100 );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "RotateAngle" ), uno::makeAny( nRotation ) );
-}
-
-uno::Reference< msforms::XLineFormat > SAL_CALL 
-ScVbaShape::getLine() throw (uno::RuntimeException)
-{
-    // TODO should ongly return line
-    return uno::Reference< msforms::XLineFormat >( new ScVbaLineFormat( this, mxContext, m_xShape ) );
-}
-
-uno::Reference< msforms::XFillFormat > SAL_CALL
-ScVbaShape::getFill() throw (uno::RuntimeException)
-{
-    return uno::Reference< msforms::XFillFormat >( new ScVbaFillFormat( this, mxContext, m_xShape ) );
-}
-
-uno::Reference<  msforms::XPictureFormat > SAL_CALL
-ScVbaShape::getPictureFormat() throw (uno::RuntimeException)
-{
-    return uno::Reference< msforms::XPictureFormat >( new ScVbaPictureFormat( this, mxContext, m_xShape ) );
-}
-
-// Methods
-uno::Reference< excel::XTextFrame > SAL_CALL 
-ScVbaShape::TextFrame() throw (uno::RuntimeException)
-{
-    return uno::Reference< excel::XTextFrame >(new ScVbaTextFrame( getParent(), mxContext, m_xShape ) );
-}
-
-void SAL_CALL 
-ScVbaShape::Delete() throw (uno::RuntimeException)
-{
-    OGuard aGuard( Application::GetSolarMutex() );
-    m_xShapes->remove( m_xShape );
-}
-
-void SAL_CALL 
-ScVbaShape::ZOrder( sal_Int32 ZOrderCmd ) throw (uno::RuntimeException)
-{
-    sal_Int32 nOrderPositon;
-    uno::Any aOrderPostion = m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ) );
-    aOrderPostion >>= nOrderPositon;
-    switch( ZOrderCmd )
-    {
-    case office::MsoZOrderCmd::msoBringToFront:
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( SAL_MAX_INT32 ) );
-        break;
-    case office::MsoZOrderCmd::msoSendToBack:
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( (sal_Int32)0 ) );
-        break;
-    case office::MsoZOrderCmd::msoBringForward:
-        nOrderPositon += 1;
-        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( nOrderPositon ) );
-        break;
-    case office::MsoZOrderCmd::msoSendBackward:
-        if( nOrderPositon > 0 )
-        {
-            nOrderPositon -= 1;
-            m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( nOrderPositon ) );
-        }
-        break;
-    // below two commands use with Writer for text and image object.
-    case office::MsoZOrderCmd::msoBringInFrontOfText:
-    case office::MsoZOrderCmd::msoSendBehindText:
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "This ZOrderCmd is not implemented, it is use with writer." ), uno::Reference< uno::XInterface >() );
-    default:
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid Parameter." ), uno::Reference< uno::XInterface >() );
-    }
-}
-
-void SAL_CALL 
-ScVbaShape::IncrementRotation( double Increment ) throw (uno::RuntimeException)
-{
-    double nCurrentRotation = getRotation();
-    nCurrentRotation += Increment;
-    setRotation(nCurrentRotation);
-}
-
-void SAL_CALL 
-ScVbaShape::IncrementLeft( double Increment ) throw (uno::RuntimeException)
-{
-    double nCurrentLeft = getLeft();
-    nCurrentLeft += Increment;
-    setLeft(nCurrentLeft);
-}
-
-void SAL_CALL 
-ScVbaShape::IncrementTop( double Increment ) throw (uno::RuntimeException)
-{
-    double nCurrentTop = getTop();
-    nCurrentTop += Increment;
-    setTop(nCurrentTop);
-}
-
-void SAL_CALL 
-ScVbaShape::ScaleHeight( double Factor, sal_Bool /*RelativeToOriginalSize*/, sal_Int32 Scale ) throw (uno::RuntimeException)
-{
-    double nHeight = getHeight();
-    double nNewHeight = nHeight * Factor;
-    if( Scale == office::MsoScaleFrom::msoScaleFromTopLeft )
-    {
-        setHeight(nNewHeight);
-    }
-    else if( Scale == office::MsoScaleFrom::msoScaleFromBottomRight )
-    {
-        double nDeltaHeight = nNewHeight - nHeight;
-        double nNewTop = getTop() - nDeltaHeight;
-        setTop(nNewTop);
-        setHeight(nNewHeight);
-    }
-    else if( Scale == office::MsoScaleFrom::msoScaleFromMiddle )
-    {
-        double nDeltaHeight = (nNewHeight - nHeight) / 2;
-        double nNewTop = getTop() - nDeltaHeight;
-        setTop(nNewTop);
-        setHeight(nNewHeight);
-    }
-    else
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "ScaleHeight.Scale wrong value is given." ) , uno::Reference< uno::XInterface >() );
-    }
-}
-
-void SAL_CALL 
-ScVbaShape::ScaleWidth( double Factor, sal_Bool /*RelativeToOriginalSize*/, sal_Int32 Scale ) throw (uno::RuntimeException)
-{
-    double nWidth = getWidth();
-    double nNewWidth = nWidth * Factor;
-    if( Scale == office::MsoScaleFrom::msoScaleFromTopLeft )
-    {
-        setWidth(nNewWidth);
-    }
-    else if( Scale == office::MsoScaleFrom::msoScaleFromBottomRight )
-    {
-        double nDeltaWidth = nNewWidth - nWidth;
-        double nNewLeft = getLeft() - nDeltaWidth;
-        setLeft(nNewLeft);
-        setWidth(nNewWidth);
-    }
-    else if( Scale == office::MsoScaleFrom::msoScaleFromMiddle )
-    {
-        double nDeltaWidth = (nNewWidth - nWidth) / 2;
-        double nNewLeft = getLeft() - nDeltaWidth;
-        setLeft(nNewLeft);
-        setWidth(nNewWidth);
-    }
-    else
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "ScaleHeight.Scale wrong value is given." ) , uno::Reference< uno::XInterface >() );
-    }
-}
-
-void SAL_CALL
-ScVbaShape::Select( const uno::Any& /*Replace*/ ) throw ( uno::RuntimeException )
-{
-    uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< view::XSelectionSupplier > xSelectSupp( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    xSelectSupp->select( uno::makeAny( m_xShape ) );
-}
-
-// This method should not be part of Shape, what we reall need to do is...
-// dynamically create the appropriate objects e.g. TextBox, Oval, Picture etc. 
-// ( e.g. the ones that really do have ShapeRange as an attribute )
-#include "vbashaperange.hxx"
-
-uno::Any SAL_CALL 
-ScVbaShape::ShapeRange( const uno::Any& index ) throw ( uno::RuntimeException )
-{
-	// perhaps we should store a reference to the Shapes Collection 
-	// in this class
-	// but anyway this method should not even be in this class
-	// #TODO not sure what the parent of the Shapes collection should be
-	
-	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec aVec;
-	aVec.push_back( m_xShape );
-	uno::Reference< container::XIndexAccess > xIndexAccess( new XNamedObjectCollectionHelper< drawing::XShape >( aVec ) );
-	uno::Reference< container::XChild > xChild( m_xShape, uno::UNO_QUERY_THROW );	
-	// #FIXME for want of a better parent, setting this
-	uno::Reference< msforms::XShapeRange > xShapeRange( new ScVbaShapeRange( mxParent, mxContext, xIndexAccess,  uno::Reference< drawing::XDrawPage >( xChild->getParent(), uno::UNO_QUERY_THROW ) ) );
-	if ( index.hasValue() )
-		return xShapeRange->Item( index, uno::Any() );
-	return uno::makeAny( xShapeRange );
-}
-
-rtl::OUString& 
-ScVbaShape::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShape") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaShape::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Shape" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbauserform.cxx
===================================================================
--- sc/source/ui/vba/vbauserform.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbauserform.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,228 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "helperdecl.hxx"
-#include "vbauserform.hxx"
-#include <com/sun/star/awt/XControl.hpp>
-#include <com/sun/star/awt/XControlContainer.hpp>
-#include <com/sun/star/beans/PropertyConcept.hpp>
-#include <basic/sbx.hxx>
-#include <basic/sbstar.hxx>
-#include <basic/sbmeth.hxx>
-#include "unonames.hxx"
-#include "vbacontrols.hxx"
-
-using namespace ::ooo::vba;
-using namespace ::com::sun::star;
-
-// some little notes
-// XDialog implementation has the following interesting bits
-// a Controls property ( which is an array of the container controls )
-//   each item in the controls array is a XControl, where the model is 
-//   basically a property bag
-// additionally the XDialog instance has itself a model
-//     this model has a ControlModels ( array of models ) property
-//     the models in ControlModels can be accessed by name
-// also the XDialog is a XControl ( to access the model above
-
-ScVbaUserForm::ScVbaUserForm( uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& xContext ) throw ( lang::IllegalArgumentException ) :  ScVbaUserForm_BASE( getXSomethingFromArgs< XHelperInterface >( aArgs, 0 ), xContext, getXSomethingFromArgs< uno::XInterface >( aArgs, 1 ), getXSomethingFromArgs< frame::XModel >( aArgs, 2 ), static_cast< ooo::vba::AbstractGeometryAttributes* >(0) ), m_pDocShell( 0 ), mbDispose( true )
-{
-    m_xDialog.set( m_xControl, uno::UNO_QUERY_THROW );
-    uno::Reference< awt::XControl > xControl( m_xDialog, uno::UNO_QUERY_THROW );
-    m_pDocShell = getDocShell( m_xModel );
-    m_xProps.set( xControl->getModel(), uno::UNO_QUERY_THROW );
-    setGeometryHelper( new UserFormGeometryHelper( xContext, xControl ) );
-}
-
-ScVbaUserForm::~ScVbaUserForm()
-{
-}
-
-void SAL_CALL 
-ScVbaUserForm::Show(  ) throw (uno::RuntimeException)
-{
-	OSL_TRACE("ScVbaUserForm::Show(  )");
-	short aRet = 0;
-	if ( m_xDialog.is() )
-		aRet = m_xDialog->execute();
-	OSL_TRACE("ScVbaUserForm::Show() execute returned %d", aRet);
-	if ( mbDispose )
-	{
-		try
-		{
-			uno::Reference< lang::XComponent > xComp( m_xDialog, uno::UNO_QUERY_THROW );
-			m_xDialog = NULL;
-			xComp->dispose();
-			mbDispose = false; 
-		}
-		catch( uno::Exception& )
-		{
-		}
-	}
-}
-
-rtl::OUString SAL_CALL 
-ScVbaUserForm::getCaption() throw (::com::sun::star::uno::RuntimeException)
-{
-    rtl::OUString sCaption;
-    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Title") ) ) >>= sCaption;
-    return sCaption;
-}
-void
-ScVbaUserForm::setCaption( const ::rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
-{
-    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Title") ), uno::makeAny( _caption ) );
-}
-
-void SAL_CALL 
-ScVbaUserForm::Hide(  ) throw (uno::RuntimeException)
-{
-	mbDispose = false;  // hide not dispose
-	if ( m_xDialog.is() )
-		m_xDialog->endExecute();
-}
-
-void SAL_CALL 
-ScVbaUserForm::RePaint(  ) throw (uno::RuntimeException)
-{
-	// do nothing
-}
-
-void SAL_CALL 
-ScVbaUserForm::UnloadObject(  ) throw (uno::RuntimeException)
-{
-	mbDispose = true;
-	if ( m_xDialog.is() )
-		m_xDialog->endExecute();
-}
-
-rtl::OUString& 
-ScVbaUserForm::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaUserForm") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaUserForm::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.UserForm" ) );
-	}
-	return aServiceNames;
-}
-
-uno::Reference< beans::XIntrospectionAccess > SAL_CALL 
-ScVbaUserForm::getIntrospection(  ) throw (uno::RuntimeException)
-{
-	return uno::Reference< beans::XIntrospectionAccess >();
-}
-
-uno::Any SAL_CALL 
-ScVbaUserForm::invoke( const ::rtl::OUString& /*aFunctionName*/, const uno::Sequence< uno::Any >& /*aParams*/, uno::Sequence< ::sal_Int16 >& /*aOutParamIndex*/, uno::Sequence< uno::Any >& /*aOutParam*/ ) throw (lang::IllegalArgumentException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
-{
-	throw uno::RuntimeException(); // unsupported operation
-}
-
-void SAL_CALL 
-ScVbaUserForm::setValue( const ::rtl::OUString& aPropertyName, const uno::Any& aValue ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
-{
-	uno::Any aObject = getValue( aPropertyName );
-	// The Object *must* support XDefaultProperty here because getValue will
-	// only return properties that are Objects ( e.g. controls )
-	// e.g. Userform1.aControl = something
-	// 'aControl' has to support XDefaultProperty to make sense here
-	uno::Reference< script::XDefaultProperty > xDfltProp( aObject, uno::UNO_QUERY_THROW );
-	rtl::OUString aDfltPropName = xDfltProp->getDefaultPropertyName();
-	uno::Reference< beans::XIntrospectionAccess > xUnoAccess( getIntrospectionAccess( aObject ) );
-	uno::Reference< beans::XPropertySet > xPropSet( xUnoAccess->queryAdapter( ::getCppuType( (const uno::Reference< beans::XPropertySet > *)0 ) ), uno::UNO_QUERY_THROW );
-	xPropSet->setPropertyValue( aDfltPropName, aValue );
-}
-
-uno::Any SAL_CALL 
-ScVbaUserForm::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::UnknownPropertyException, uno::RuntimeException)
-{
-	uno::Reference< awt::XControl > xDialogControl( m_xDialog, uno::UNO_QUERY_THROW );
-	uno::Reference< awt::XControlContainer > xContainer( m_xDialog, uno::UNO_QUERY_THROW );
-	uno::Reference< awt::XControl > xControl = xContainer->getControl( aPropertyName );
-	ScVbaControlFactory aFac( mxContext, xControl, m_xModel );
-        uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( xDialogControl->getModel() ) );
-        ScVbaControl* pControl  = dynamic_cast< ScVbaControl* >( xVBAControl.get() );
-        pControl->setGeometryHelper( new UserFormGeometryHelper( mxContext, xControl ) );
-	return uno::makeAny( xVBAControl );
-}
-
-::sal_Bool SAL_CALL 
-ScVbaUserForm::hasMethod( const ::rtl::OUString& /*aName*/ ) throw (uno::RuntimeException)
-{
-	return sal_False;
-}
-uno::Any SAL_CALL 
-ScVbaUserForm::Controls( const uno::Any& index ) throw (uno::RuntimeException)
-{
-	uno::Reference< awt::XControl > xDialogControl( m_xDialog, uno::UNO_QUERY_THROW );
-	uno::Reference< XCollection > xControls( new ScVbaControls( this, mxContext, xDialogControl ) );
-	if ( index.hasValue() )
-		return uno::makeAny( xControls->Item( index, uno::Any() ) );
-	return uno::makeAny( xControls );
-}
-
-::sal_Bool SAL_CALL 
-ScVbaUserForm::hasProperty( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
-{
-	uno::Reference< awt::XControl > xControl( m_xDialog, uno::UNO_QUERY );
-	OSL_TRACE("ScVbaUserForm::hasProperty(%s) %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), xControl.is() );
-	if ( xControl.is() )
-	{
-		uno::Reference< container::XNameAccess > xNameAccess( xControl->getModel(), uno::UNO_QUERY_THROW );	
-		sal_Bool bRes =  xNameAccess->hasByName( aName );
-	OSL_TRACE("ScVbaUserForm::hasProperty(%s) %d ---> %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), xControl.is(), bRes );
-		return bRes;
-	}
-	return sal_False;
-}
-
-namespace userform
-{
-namespace sdecl = comphelper::service_decl;
-sdecl::vba_service_class_<ScVbaUserForm, sdecl::with_args<true> > serviceImpl;
-extern sdecl::ServiceDecl const serviceDecl(
-    serviceImpl,
-    "ScVbaUserForm",
-    "ooo.vba.excel.UserForm" );
-}
-
Index: sc/source/ui/vba/vbacommandbarcontrol.cxx
===================================================================
--- sc/source/ui/vba/vbacommandbarcontrol.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacommandbarcontrol.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,403 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile$
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-#include "vbacommandbarcontrol.hxx"
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-uno::Any lcl_getPropertyValue( beans::PropertyValues aPropertyValues, rtl::OUString sPropertyName )
-{
-    sal_Int32 nCount = aPropertyValues.getLength();
-    for( sal_Int32 i = 0; i < nCount; i++ )
-    {
-        if( aPropertyValues[i].Name.equalsIgnoreAsciiCase( sPropertyName ) )
-        {
-            return aPropertyValues[i].Value;
-        }
-    }
-    return uno::Any();
-}
-
-beans::PropertyValues lcl_repalcePropertyValue( beans::PropertyValues aPropertyValues, rtl::OUString sPropertyName, uno::Any aValue )
-{
-    sal_Int32 nCount = aPropertyValues.getLength();
-    for( sal_Int32 i = 0; i < nCount; i++ )
-    {
-        if( aPropertyValues[i].Name.equalsIgnoreAsciiCase( sPropertyName ) )
-        {
-            aPropertyValues[i].Value = aValue;
-            return aPropertyValues;
-        }
-    }
-    return aPropertyValues;
-}
-
-ScVbaCommandBarControl::ScVbaCommandBarControl( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, rtl::OUString sName ) throw (uno::RuntimeException) : CommandBarControl_BASE( xParent, xContext ), m_sName( sName )
-{
-    // exsiting CommandBarBarControl
-    m_xParentHardRef.set( xParent, uno::UNO_QUERY_THROW );
-    initObjects();
-    if( m_xBarSettings->hasElements() )
-    {
-        ScVbaCommandBarControl* pParentCommandBarControl = m_pCommandBarControls->GetParentCommandBarControl();
-        if( pParentCommandBarControl )
-        {
-            beans::PropertyValues aPropertyValues;
-            pParentCommandBarControl->GetCurrentSettings()->getByIndex( pParentCommandBarControl->GetPosition() ) >>= aPropertyValues;
-            pParentCommandBarControl->SetPropertyValues( aPropertyValues );
-            m_xCurrentSettings.set( lcl_getPropertyValue( pParentCommandBarControl->GetPropertyValues(), rtl::OUString::createFromAscii( "ItemDescriptorContainer" ) ), uno::UNO_QUERY_THROW );
-        }
-        if( !m_xCurrentSettings.is() )
-        {
-            m_xCurrentSettings.set( m_xUICfgManager->getSettings( m_pCommandBarControls->GetParentToolBarName(), sal_True ), uno::UNO_QUERY_THROW );
-        }
-        for( sal_Int32 i = 0; i < m_xCurrentSettings->getCount(); i++ )
-        {
-            beans::PropertyValues aPropertyValuesTemp;
-            m_xCurrentSettings->getByIndex( i ) >>= aPropertyValuesTemp;
-            // Label always empty in OOo
-            rtl::OUString sLabel;
-            lcl_getPropertyValue( aPropertyValuesTemp, rtl::OUString::createFromAscii( "Label" ) ) >>= sLabel;
-            if( sLabel.equalsIgnoreAsciiCase( sName ) )
-            {
-                m_nPosition = i;
-                break;
-            }
-            // using CammandURL to find
-            rtl::OUString sCommandURL;
-            lcl_getPropertyValue( aPropertyValuesTemp, rtl::OUString::createFromAscii( "CommandURL" ) ) >>= sCommandURL;
-            sal_Int32 nLastIndex = sCommandURL.lastIndexOf( rtl::OUString::createFromAscii(":") );
-            if( ( nLastIndex != -1 ) && ( ( nLastIndex + 1 ) < sCommandURL.getLength() ) )
-            {
-                sCommandURL = sCommandURL.copy( nLastIndex + 1 );
-            }
-            if( sCommandURL.equalsIgnoreAsciiCase( sName ) )
-            {
-                m_nPosition = i;
-                break;
-            }
-        }
-        if( m_nPosition  == -1 )
-            throw uno::RuntimeException( rtl::OUString::createFromAscii("The CommandBarControl do not exist"), uno::Reference< uno::XInterface >() );
-    }
-    if( m_bIsMenu )
-    {
-        m_sBarName = rtl::OUString::createFromAscii("private:resource/menubar/menubar");
-    }
-    else
-    {
-        m_sBarName = m_pCommandBarControls->GetParentToolBarName();
-    }
-    m_bTemporary = sal_True;
-}
-ScVbaCommandBarControl::ScVbaCommandBarControl( const uno::Reference< XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, rtl::OUString sName, rtl::OUString sCommand, sal_Int32 nPosition, sal_Bool bTemporary ) throw (uno::RuntimeException) :  CommandBarControl_BASE( xParent, xContext ), m_nPosition( nPosition ), m_bTemporary( bTemporary )
-{
-    m_xParentHardRef.set( xParent, uno::UNO_QUERY_THROW );
-    initObjects();
-    if( sName.getLength() > 0 )
-    {
-        m_sName = sName;
-    }
-    if( sCommand.getLength() > 0 )
-    {
-        m_sCommand = sCommand;
-    }
-    else
-    {
-        m_sCommand = rtl::OUString::createFromAscii("vnd.openoffice.org:") + sName;
-    }
-    if( m_bIsMenu )
-    {
-        m_sBarName = rtl::OUString::createFromAscii("private:resource/menubar/menubar");
-        createNewMenuBarControl();
-    }
-    else
-    {
-        m_sBarName = m_pCommandBarControls->GetParentToolBarName();
-        createNewToolBarControl();
-    }
-}
-
-void
-ScVbaCommandBarControl::initObjects() throw (uno::RuntimeException)
-{
-    m_pCommandBarControls = dynamic_cast< ScVbaCommandBarControls* >( m_xParentHardRef.get() );
-    if( !m_pCommandBarControls )
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Parent needs to be a ScVbaCommandBarControls"), uno::Reference< uno::XInterface >() );
-    m_xUICfgManager.set( m_pCommandBarControls->GetUICfgManager(), uno::UNO_QUERY_THROW );
-    m_xUICfgPers.set( m_pCommandBarControls->GetUICfgPers(), uno::UNO_QUERY_THROW );
-    m_xBarSettings.set( m_pCommandBarControls->GetBarSettings(), uno::UNO_QUERY_THROW );
-    m_bIsMenu = m_pCommandBarControls->IsMenu();
-    m_sName = rtl::OUString::createFromAscii( "Custom" );
-    m_nPosition = -1;
-}
-
-void
-ScVbaCommandBarControl::createNewMenuBarControl()
-{
-    uno::Sequence< beans::PropertyValue > aPropertys(4);
-    aPropertys[0].Name = rtl::OUString::createFromAscii("CommandURL");
-    aPropertys[0].Value <<= m_sCommand; 
-    aPropertys[1].Name = rtl::OUString::createFromAscii("Label");
-    aPropertys[1].Value <<= m_sName; 
-    aPropertys[2].Name = rtl::OUString::createFromAscii("Type");
-    aPropertys[2].Value <<= m_nType; 
-    aPropertys[3].Name = rtl::OUString::createFromAscii("ItemDescriptorContainer");
-
-    m_xBarSettings->insertByIndex( m_nPosition, uno::makeAny( aPropertys ) );
-    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
-    rtl::OUString sUIName;
-    xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("UIName") ) >>= sUIName;
-
-    uno::Reference< lang::XSingleComponentFactory > xMenuMSF( m_xBarSettings, uno::UNO_QUERY_THROW );
-    if( m_pCommandBarControls->GetParentCommandBar() != NULL )
-    {
-        // create a new menu
-        m_xBarSettings->insertByIndex( m_nPosition, uno::makeAny( aPropertys ) );
-        m_xCurrentSettings.set( m_xBarSettings, uno::UNO_QUERY_THROW );
-    }
-    else if( m_pCommandBarControls->GetParentCommandBarControl() != NULL )
-    {
-        // create a new menu entry
-        // change the parent MenuItem to a PopupMenu
-        ScVbaCommandBarControl* pPc = m_pCommandBarControls->GetParentCommandBarControl();
-        beans::PropertyValues aPropertyValues;
-        pPc->GetCurrentSettings()->getByIndex( pPc->GetPosition() ) >>= aPropertyValues;
-        pPc->SetPropertyValues( aPropertyValues );
-        
-        // has the property already been set?
-        if( lcl_getPropertyValue( pPc->GetPropertyValues(), rtl::OUString::createFromAscii("ItemDescriptorContainer") ).hasValue() )
-        {
-            lcl_repalcePropertyValue(  pPc->GetPropertyValues(), rtl::OUString::createFromAscii("ItemDescriptorContainer"), uno::makeAny( xMenuMSF->createInstanceWithContext( mxContext ) ) );
-            pPc->GetCurrentSettings()->replaceByIndex( pPc->GetPosition(), uno::makeAny( pPc->GetPropertyValues() ) );
-        }
-        m_xCurrentSettings.set( lcl_getPropertyValue( pPc->GetPropertyValues(), rtl::OUString::createFromAscii("ItemDescriptorContainer") ), uno::UNO_QUERY_THROW );
-        m_xCurrentSettings->insertByIndex( m_nPosition, uno::makeAny( m_aPropertyValues ) );
-    }
-    if( m_xUICfgManager->hasSettings( m_sBarName ) )
-    {
-        m_xUICfgManager->replaceSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    else
-    {
-        m_xUICfgManager->insertSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    if( !m_bTemporary )
-    {
-        m_xUICfgPers->store();
-    }
-}
-
-void
-ScVbaCommandBarControl::createNewToolBarControl()
-{
-    uno::Sequence< beans::PropertyValue > aPropertys(4);
-    aPropertys[0].Name = rtl::OUString::createFromAscii("CommandURL");
-    aPropertys[0].Value <<= m_sCommand; 
-    aPropertys[1].Name = rtl::OUString::createFromAscii("Label");
-    aPropertys[1].Value <<= m_sName; 
-    aPropertys[2].Name = rtl::OUString::createFromAscii("Type");
-    aPropertys[2].Value <<= m_nType; 
-    aPropertys[3].Name = rtl::OUString::createFromAscii("IsVisible");
-    aPropertys[3].Value <<= sal_True; 
-
-    m_xBarSettings->insertByIndex( m_nPosition, uno::makeAny( aPropertys ) );
-    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
-    rtl::OUString sUIName;
-    xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("UIName") ) >>= sUIName;
-
-    m_xCurrentSettings.set( m_xBarSettings, uno::UNO_QUERY_THROW );
-    if( m_xUICfgManager->hasSettings( m_sBarName ) )
-    {
-        m_xUICfgManager->replaceSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    else
-    {
-        m_xUICfgManager->insertSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-    }
-    if( !m_bTemporary )
-    {
-        m_xUICfgPers->store();
-    }
-}
-
-::rtl::OUString SAL_CALL
-ScVbaCommandBarControl::getCaption() throw ( uno::RuntimeException )
-{
-    // "Label" always empty
-    rtl::OUString sCaption;
-    beans::PropertyValues aPropertyValues;
-    if( m_xCurrentSettings.is() )
-    {
-        m_xCurrentSettings->getByIndex( m_nPosition ) >>= aPropertyValues;
-        lcl_getPropertyValue( aPropertyValues, rtl::OUString::createFromAscii("Label") ) >>= sCaption;
-    }
-    else if( m_xBarSettings.is() )
-    {
-        m_xBarSettings->getByIndex( m_nPosition ) >>= aPropertyValues;
-        lcl_getPropertyValue( aPropertyValues, rtl::OUString::createFromAscii("Label") ) >>= sCaption;
-    }
-    return sCaption;
-}
-void SAL_CALL 
-ScVbaCommandBarControl::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
-{
-    if( m_xCurrentSettings.is() )
-    {
-        beans::PropertyValues aPropertyValues;
-        m_xCurrentSettings->getByIndex( m_nPosition ) >>= aPropertyValues;
-        beans::PropertyValues aNewPropertyValues;
-        aNewPropertyValues = lcl_repalcePropertyValue( aPropertyValues, rtl::OUString::createFromAscii("Label"), uno::makeAny( _caption ) );
-        m_xCurrentSettings->replaceByIndex( m_nPosition, uno::makeAny( aNewPropertyValues ) );
-        if( m_xUICfgManager->hasSettings( m_sBarName ) )
-        {
-            m_xUICfgManager->replaceSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        else
-        {
-            m_xUICfgManager->insertSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        // make it permanent
-        if( !m_bTemporary )
-        {
-            m_xUICfgPers->store();
-        }
-    }
-}
-::rtl::OUString SAL_CALL 
-ScVbaCommandBarControl::getOnAction() throw (uno::RuntimeException)
-{
-    if( m_xCurrentSettings.is() )
-    {
-        beans::PropertyValues aPropertyValues;
-        m_xCurrentSettings->getByIndex( m_nPosition ) >>= aPropertyValues;
-        rtl::OUString sCommandURL;
-        lcl_getPropertyValue( aPropertyValues, rtl::OUString::createFromAscii( "CommandURL" ) ) >>= sCommandURL;
-        return sCommandURL;
-    }
-    return ::rtl::OUString();
-}
-void SAL_CALL 
-ScVbaCommandBarControl::setOnAction( const ::rtl::OUString& _onaction ) throw (uno::RuntimeException)
-{
-    if( m_xCurrentSettings.is() )
-    {
-        beans::PropertyValues aPropertyValues;
-        m_xCurrentSettings->getByIndex( m_nPosition ) >>= aPropertyValues;
-        beans::PropertyValues aNewPropertyValues;
-        aNewPropertyValues = lcl_repalcePropertyValue( aPropertyValues, rtl::OUString::createFromAscii("CommandURL"), uno::makeAny( _onaction ) );
-        m_xCurrentSettings->replaceByIndex( m_nPosition, uno::makeAny( aNewPropertyValues ) );
-        if( m_xUICfgManager->hasSettings( m_sBarName ) )
-        {
-            m_xUICfgManager->replaceSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        else
-        {
-            m_xUICfgManager->insertSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        // make it permanent
-        if( !m_bTemporary )
-        {
-            m_xUICfgPers->store();
-        }
-    }
-}
-::sal_Bool SAL_CALL 
-ScVbaCommandBarControl::getVisible() throw (uno::RuntimeException)
-{
-    // not possible in UNO?
-    return sal_True;
-}
-void SAL_CALL 
-ScVbaCommandBarControl::setVisible( ::sal_Bool /*_visible*/ ) throw (uno::RuntimeException)
-{
-    // "IsVisilbe"
-}
-void SAL_CALL 
-ScVbaCommandBarControl::Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
-{
-    if( m_xCurrentSettings.is() )
-    {
-        m_xCurrentSettings->removeByIndex( m_nPosition );
-
-        if( m_xUICfgManager->hasSettings( m_sBarName ) )
-        {
-            m_xUICfgManager->replaceSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        else
-        {
-            m_xUICfgManager->insertSettings( m_sBarName, uno::Reference< container::XIndexAccess > (m_xBarSettings, uno::UNO_QUERY_THROW ) );
-        }
-        // make it permanent
-        if( !m_bTemporary )
-        {
-            m_xUICfgPers->store();
-        }
-    }
-}
-uno::Any SAL_CALL 
-ScVbaCommandBarControl::Controls( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
-{
-    sal_Int32 nIndex;
-    uno::Reference< XCommandBarControls > xCommandBarControls( new ScVbaCommandBarControls( this, mxContext, uno::Reference< container::XIndexAccess >() ) );
-    if( aIndex.hasValue() )
-    {
-        if( aIndex >>= nIndex )
-        {
-            uno::Reference< XCommandBarControl > xCommandBarControl( xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
-            return uno::makeAny( xCommandBarControl );
-        }
-        else
-            throw uno::RuntimeException( rtl::OUString::createFromAscii( "invalid index" ), uno::Reference< uno::XInterface >() );
-    }
-    return uno::makeAny( xCommandBarControls );
-}
-rtl::OUString& 
-ScVbaCommandBarControl::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarControl") );
-	return sImplName;
-}
-uno::Sequence<rtl::OUString> 
-ScVbaCommandBarControl::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarControl" ) );
-	}
-	return aServiceNames;
-}
Index: sc/source/ui/vba/vbaworkbooks.hxx
===================================================================
--- sc/source/ui/vba/vbaworkbooks.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworkbooks.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,21 +31,20 @@
 #define SC_VBA_WORKBOOKS_HXX
 
 
-#include "vbacollectionimpl.hxx"
-#include <ooo/vba/XGlobals.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
 #include <ooo/vba/excel/XWorkbooks.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
-#include "vbahelper.hxx"
+#include <vbahelper/vbadocumentsbase.hxx>
+#include "excelvbahelper.hxx"
 
 
 class ScModelObj;
 
-typedef CollTestImplHelper< ov::excel::XWorkbooks > ScVbaWorkbooks_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaDocumentsBase, ov::excel::XWorkbooks > ScVbaWorkbooks_BASE;
 
 class ScVbaWorkbooks : public ScVbaWorkbooks_BASE
 {
 private:
-	css::uno::Reference< ov::XGlobals > getGlobals() throw (css::uno::RuntimeException);
 	rtl::OUString 	getFileFilterType( const rtl::OUString& rString );
 	bool 	isTextFile( const rtl::OUString& rString );
 	bool 	isSpreadSheetFile( const rtl::OUString& rString );
@@ -68,6 +67,8 @@
 	virtual void SAL_CALL Close(  ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& UpdateLinks, const css::uno::Any& ReadOnly, const css::uno::Any& Format, const css::uno::Any& Password, const css::uno::Any& WriteResPassword, const css::uno::Any& IgnoreReadOnlyRecommended, const css::uno::Any& Origin, const css::uno::Any& Delimiter, const css::uno::Any& Editable, const css::uno::Any& Notify, const css::uno::Any& Converter, const css::uno::Any& AddToMru ) throw (css::uno::RuntimeException);
 
+	// VbaDocumentsBase / XDocumentsBase (to avoid warning C4266 for hiding function on wntmsci)
+	virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& ReadOnly, const css::uno::Sequence< css::beans::PropertyValue >& rProps ) throw (css::uno::RuntimeException);
 };
 
 #endif /* SC_VBA_WORKBOOKS_HXX */
Index: sc/source/ui/vba/vbaname.hxx
===================================================================
--- sc/source/ui/vba/vbaname.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaname.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,8 +34,10 @@
 #include <com/sun/star/sheet/XNamedRange.hpp>
 #include <com/sun/star/sheet/XNamedRanges.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
+class ScDocument; 
+
 typedef InheritedHelperInterfaceImpl1< ov::excel::XName > NameImpl_BASE;
 
 class ScVbaName : public NameImpl_BASE 
Index: sc/source/ui/vba/vbamenuitem.hxx
===================================================================
--- sc/source/ui/vba/vbamenuitem.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenuitem.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEM_HXX
+#define SC_VBA_MENUITEM_HXX
+
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuItem > MenuItem_BASE;
+
+class ScVbaMenuItem : public MenuItem_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenuItem( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getOnAction() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setOnAction( const ::rtl::OUString& _onaction ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUITEM_HXX
Index: sc/source/ui/vba/vbacomments.hxx
===================================================================
--- sc/source/ui/vba/vbacomments.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacomments.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,8 +34,8 @@
 
 #include <ooo/vba/excel/XComments.hpp>
 
-#include "vbahelper.hxx"
-#include "vbacollectionimpl.hxx"
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 #include "vbacomment.hxx"
 
 typedef CollTestImplHelper< ov::excel::XComments > ScVbaComments_BASE;
Index: sc/source/ui/vba/vbastyle.cxx
===================================================================
--- sc/source/ui/vba/vbastyle.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbastyle.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -71,7 +71,7 @@
 
 }
 
-ScVbaStyle::ScVbaStyle( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const rtl::OUString& sStyleName, const uno::Reference< frame::XModel >& _xModel ) throw ( script::BasicErrorException, uno::RuntimeException ) :  ScVbaStyle_BASE( xParent, xContext, lcl_getStyleProps( sStyleName, _xModel ), _xModel, false )
+ScVbaStyle::ScVbaStyle( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const rtl::OUString& sStyleName, const uno::Reference< frame::XModel >& _xModel ) throw ( script::BasicErrorException, uno::RuntimeException ) :  ScVbaStyle_BASE( xParent, xContext, lcl_getStyleProps( sStyleName, _xModel ), _xModel, false ), mxModel( _xModel )
 {
 	try
 	{
@@ -83,7 +83,7 @@
 	}
 }
 
-ScVbaStyle::ScVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& _xPropertySet, const uno::Reference< frame::XModel >& _xModel ) throw ( script::BasicErrorException, uno::RuntimeException ) : ScVbaStyle_BASE( xParent, xContext, _xPropertySet, _xModel, false )
+ScVbaStyle::ScVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& _xPropertySet, const uno::Reference< frame::XModel >& _xModel ) throw ( script::BasicErrorException, uno::RuntimeException ) : ScVbaStyle_BASE( xParent, xContext, _xPropertySet, _xModel, false ),  mxModel( _xModel )
 {
 	try
 	{
Index: sc/source/ui/vba/vbapivottable.hxx
===================================================================
--- sc/source/ui/vba/vbapivottable.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapivottable.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,8 +33,8 @@
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/sheet/XDataPilotTable.hpp>
 #include <ooo/vba/excel/XPivotTable.hpp>
-#include "vbahelper.hxx"
-#include "vbahelperinterface.hxx"
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XPivotTable >  PivotTableImpl_BASE;
 
Index: sc/source/ui/vba/vbaworksheet.hxx
===================================================================
--- sc/source/ui/vba/vbaworksheet.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworksheet.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,9 +44,12 @@
 #include <ooo/vba/excel/XOutline.hpp>
 #include <ooo/vba/excel/XPageSetup.hpp>
 #include <ooo/vba/excel/XHPageBreaks.hpp>
+#include <ooo/vba/excel/XVPageBreaks.hpp>
 #include <ooo/vba/excel/XChartObjects.hpp>
+#include <com/sun/star/container/XNamed.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include "address.hxx"
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XWorksheet >  WorksheetImpl_BASE;
 
@@ -93,9 +96,12 @@
 	virtual css::uno::Reference< ov::excel::XOutline > SAL_CALL Outline( ) throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XPageSetup > SAL_CALL PageSetup( ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL HPageBreaks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL VPageBreaks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XWorksheet > SAL_CALL getNext() throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XWorksheet > SAL_CALL getPrevious() throw (css::uno::RuntimeException);
  	virtual sal_Int16 SAL_CALL getIndex() throw (css::uno::RuntimeException);
+ 	virtual sal_Int32 SAL_CALL getEnableSelection() throw (css::uno::RuntimeException);
+ 	virtual void SAL_CALL setEnableSelection( sal_Int32 nSelection ) throw (css::uno::RuntimeException);
 
     // Methods
 	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
Index: sc/source/ui/vba/vbachartobjects.hxx
===================================================================
--- sc/source/ui/vba/vbachartobjects.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbachartobjects.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,8 +36,8 @@
 #include <com/sun/star/table/XTableCharts.hpp>
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
-#include"vbacollectionimpl.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "excelvbahelper.hxx"
 #include <hash_map>
 
 typedef CollTestImplHelper< ov::excel::XChartObjects > ChartObjects_BASE;
Index: sc/source/ui/vba/vbapagebreak.cxx
===================================================================
--- sc/source/ui/vba/vbapagebreak.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagebreak.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -139,3 +139,37 @@
 	return aServiceNames;
 }
 
+template class ScVbaPageBreak< excel::XVPageBreak >;
+
+/* class ScVbaVPageBreak */
+ScVbaVPageBreak::ScVbaVPageBreak( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+								  const css::uno::Reference< css::uno::XComponentContext >& xContext,
+								  css::uno::Reference< css::beans::XPropertySet >& xProps,
+								  css::sheet::TablePageBreakData aTablePageBreakData ) throw ( css::uno::RuntimeException )
+:   ScVbaVPageBreak_BASE( xParent, xContext, xProps, aTablePageBreakData )
+{
+}
+            
+ScVbaVPageBreak::~ScVbaVPageBreak()
+{
+}
+
+rtl::OUString& 
+ScVbaVPageBreak::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaVPageBreak") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaVPageBreak::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.excel.VPageBreak" ) );
+	}
+	return aServiceNames;
+}
+
Index: sc/source/ui/vba/vbaformat.cxx
===================================================================
--- sc/source/ui/vba/vbaformat.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,6 +33,7 @@
 #include <ooo/vba/excel/XlHAlign.hpp>
 #include <ooo/vba/excel/XlOrientation.hpp>
 #include <ooo/vba/excel/Constants.hpp>
+#include <ooo/vba/excel/XRange.hpp>
 #include <com/sun/star/table/CellVertJustify.hpp>
 #include <com/sun/star/table/CellHoriJustify.hpp>
 #include <com/sun/star/table/CellOrientation.hpp>
@@ -341,7 +342,7 @@
 uno::Any SAL_CALL 
 ScVbaFormat<Ifc1>::Borders( const uno::Any& Index ) throw (script::BasicErrorException, uno::RuntimeException )
 {
-	ScVbaPalette aPalette( getDocShell( mxModel ) );	
+	ScVbaPalette aPalette( excel::getDocShell( mxModel ) );	
 	uno::Reference< XCollection > xColl =  new ScVbaBorders( thisHelperIface(), ScVbaFormat_BASE::mxContext, uno::Reference< table::XCellRange >( mxPropertySet, uno::UNO_QUERY_THROW ), aPalette );
 
 	if ( Index.hasValue() )
@@ -355,7 +356,7 @@
 uno::Reference< excel::XFont > SAL_CALL 
 ScVbaFormat<Ifc1>::Font(  ) throw (script::BasicErrorException, uno::RuntimeException)
 {
-	ScVbaPalette aPalette( getDocShell( mxModel ) );
+	ScVbaPalette aPalette( excel::getDocShell( mxModel ) );
 	return new ScVbaFont( thisHelperIface(), ScVbaFormat_BASE::mxContext, aPalette, mxPropertySet );
 }
 
Index: sc/source/ui/vba/makefile.mk
===================================================================
--- sc/source/ui/vba/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,9 +45,9 @@
 dummy:
         @echo "not building vba..."
 .ENDIF
 .IF "$(L10N_framework)"==""
 INCPRE=$(INCCOM)$/$(TARGET)
-
+CDEFS+=-DVBA_OOBUILD_HACK
 # ------------------------------------------------------------------
 
 SLOFILES= \
@@ -64,7 +64,7 @@
 		$(SLO)$/vbaworksheet.obj \
 		$(SLO)$/vbaoutline.obj \
 		$(SLO)$/vbafont.obj\
-		$(SLO)$/vbahelper.obj\
+		$(SLO)$/excelvbahelper.obj\
 		$(SLO)$/vbainterior.obj\
 		$(SLO)$/vbawsfunction.obj\
 		$(SLO)$/vbawindow.obj\
@@ -81,28 +81,11 @@
 		$(SLO)$/vbapalette.obj \
 		$(SLO)$/vbaborders.obj \
 		$(SLO)$/vbacharacters.obj \
-		$(SLO)$/vbacombobox.obj \
 		$(SLO)$/vbavalidation.obj \
-                $(SLO)$/vbacontrol.obj \
-                $(SLO)$/vbacontrols.obj \
                 $(SLO)$/vbaoleobject.obj \
                 $(SLO)$/vbaoleobjects.obj \
-                $(SLO)$/vbabutton.obj \
-                $(SLO)$/vbalabel.obj \
-                $(SLO)$/vbatextbox.obj \
                 $(SLO)$/vbatextboxshape.obj \
-                $(SLO)$/vbaradiobutton.obj \
-                $(SLO)$/vbalistbox.obj \
-		$(SLO)$/vbalistcontrolhelper.obj \
-                $(SLO)$/vbapropvalue.obj \
                 $(SLO)$/vbapane.obj \
-                $(SLO)$/vbashape.obj \
-                $(SLO)$/vbacolorformat.obj \
-                $(SLO)$/vbashapes.obj \
-                $(SLO)$/vbalineformat.obj \
-                $(SLO)$/vbafillformat.obj \
-                $(SLO)$/vbapictureformat.obj \
-                $(SLO)$/vbashaperange.obj \
                 $(SLO)$/vbatextframe.obj \
                 $(SLO)$/vbacharttitle.obj \
                 $(SLO)$/vbacharts.obj \
@@ -116,25 +99,18 @@
                 $(SLO)$/vbastyle.obj \
                 $(SLO)$/vbastyles.obj \
                 $(SLO)$/vbaassistant.obj \
-                $(SLO)$/vbauserform.obj \
-                $(SLO)$/vbacheckbox.obj \
-                $(SLO)$/vbatogglebutton.obj \
-                $(SLO)$/vbaframe.obj \
-                $(SLO)$/vbascrollbar.obj \
-                $(SLO)$/vbaprogressbar.obj \
-				$(SLO)$/vbamultipage.obj \
-				$(SLO)$/vbapages.obj \
-                $(SLO)$/vbacommandbarcontrol.obj \
-                $(SLO)$/vbacommandbarcontrols.obj \
-                $(SLO)$/vbacommandbar.obj \
-                $(SLO)$/vbacommandbars.obj \
 		        $(SLO)$/vbahyperlink.obj \
         		$(SLO)$/vbapagesetup.obj \
 		        $(SLO)$/vbapagebreak.obj \
         		$(SLO)$/vbapagebreaks.obj \
-		        $(SLO)$/vbaspinbutton.obj \
-		        $(SLO)$/vbaimage.obj \
-				$(SLO)$/service.obj
+				$(SLO)$/service.obj \
+        $(SLO)$/vbaeventshelper.obj \
+        $(SLO)$/vbamenubar.obj  \
+        $(SLO)$/vbamenubars.obj \
+        $(SLO)$/vbamenu.obj \
+        $(SLO)$/vbamenus.obj \
+        $(SLO)$/vbamenuitem.obj \
+        $(SLO)$/vbamenuitems.obj
 .ENDIF
 # --- Targets ------------------------------------------------------
 
Index: sc/source/ui/vba/vbamenubar.cxx
===================================================================
--- sc/source/ui/vba/vbamenubar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenubar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubar.hxx" 
+#include "vbamenus.hxx"
+#include <ooo/vba/XCommandBarControls.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuBar::ScVbaMenuBar( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBar >& xCommandBar ) throw( uno::RuntimeException ) : MenuBar_BASE( xParent, xContext ), m_xCommandBar( xCommandBar )
+{
+}
+
+uno::Any SAL_CALL 
+ScVbaMenuBar::Menus( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBar->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenus > xMenus( new ScVbaMenus( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenus->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenus );
+}
+
+rtl::OUString& 
+ScVbaMenuBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBar") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBar" ) );
+	}
+	return aServiceNames;
+}
Index: sc/source/ui/vba/vbapagesetup.cxx
===================================================================
--- sc/source/ui/vba/vbapagesetup.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagesetup.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,6 +31,7 @@
 #include "cellsuno.hxx"
 #include "convuno.hxx"
 #include "rangelst.hxx"
+#include "excelvbahelper.hxx"
 #include <com/sun/star/sheet/XPrintAreas.hpp>
 #include <com/sun/star/sheet/XHeaderFooterContent.hpp>
 #include <com/sun/star/text/XText.hpp>
@@ -52,10 +53,10 @@
 				const uno::Reference< uno::XComponentContext >& xContext,
 				const uno::Reference< sheet::XSpreadsheet >& xSheet,
 				const uno::Reference< frame::XModel >& xModel) throw (uno::RuntimeException):
-	   	ScVbaPageSetup_BASE( xParent, xContext ),
-		mxSheet( xSheet ), mxModel( xModel )
+	   	ScVbaPageSetup_BASE( xParent, xContext ), mxSheet( xSheet )
 {
     // query for current page style
+    mxModel.set( xModel, uno::UNO_QUERY_THROW );
     uno::Reference< beans::XPropertySet > xSheetProps( mxSheet, uno::UNO_QUERY_THROW );
     uno::Any aValue = xSheetProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "PageStyle" )));
     rtl::OUString aStyleName;
@@ -65,6 +66,8 @@
     uno::Reference< container::XNameAccess > xStyleFamilies = xStyleFamiliesSup->getStyleFamilies();
     uno::Reference< container::XNameAccess > xPageStyle( xStyleFamilies->getByName(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles"))), uno::UNO_QUERY_THROW );
     mxPageProps.set( xPageStyle->getByName(aStyleName), uno::UNO_QUERY_THROW );
+    mnOrientLandscape = excel::XlPageOrientation::xlLandscape;
+    mnOrientPortrait = excel::XlPageOrientation::xlPortrait;
 }		
 
 rtl::OUString SAL_CALL ScVbaPageSetup::getPrintArea() throw (css::uno::RuntimeException)
@@ -85,7 +88,7 @@
 			ScUnoConversion::FillScRange( aRange, aSeq[i] );
 			aRangeList.Append( aRange );
 		}
-		ScDocument* pDoc = getDocShell( mxModel )->GetDocument();
+		ScDocument* pDoc = excel::getDocShell( mxModel )->GetDocument();
 		aRangeList.Format( aPrintArea, nFlags, pDoc, formula::FormulaGrammar::CONV_XL_A1, ','  );
     }
     
@@ -106,7 +109,7 @@
     {
 		ScRangeList aCellRanges;
 		ScRange aRange;
-		if( getScRangeListForAddress( rAreas, getDocShell( mxModel ) , aRange, aCellRanges ) ) 
+		if( getScRangeListForAddress( rAreas, excel::getDocShell( mxModel ) , aRange, aCellRanges ) ) 
 		{
 			uno::Sequence< table::CellRangeAddress > aSeq( aCellRanges.Count() );
 			USHORT i=0;
@@ -121,292 +124,26 @@
     }
 }
 
-double SAL_CALL ScVbaPageSetup::getTopMargin() throw (css::uno::RuntimeException)
-{
-    sal_Bool headerOn = sal_False;
-    sal_Int32 topMargin = 0;
-    sal_Int32 headerHeight = 0;
-
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")));
-        aValue >>= headerOn;
-
-        aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")));
-        aValue >>= topMargin;
-
-        if( headerOn )
-        {
-            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight")));
-            aValue >>= headerHeight;
-            topMargin += headerHeight;
-        }
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( topMargin );
-}
-
-void SAL_CALL ScVbaPageSetup::setTopMargin( double margin ) throw (css::uno::RuntimeException)
-{
-    sal_Int32 topMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    sal_Bool headerOn = sal_False;
-    sal_Int32 headerHeight = 0;
-
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")));
-        aValue >>= headerOn;
-        
-        if( headerOn )
-        {
-            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight")));
-            aValue >>= headerHeight;
-            topMargin -= headerHeight;
-        }
-
-        aValue <<= topMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
-}
-
-double SAL_CALL ScVbaPageSetup::getBottomMargin() throw (css::uno::RuntimeException)
-{
-    sal_Bool footerOn = sal_False;
-    sal_Int32 bottomMargin = 0;
-    sal_Int32 footerHeight = 0;
-
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")));
-        aValue >>= footerOn;
-
-        aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")));
-        aValue >>= bottomMargin;
-
-        if( footerOn )
-        {
-            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight")));
-            aValue >>= footerHeight;
-            bottomMargin += footerHeight;
-        }
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( bottomMargin );
-}
-
-void SAL_CALL ScVbaPageSetup::setBottomMargin( double margin ) throw (css::uno::RuntimeException)
-{
-    sal_Int32 bottomMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    sal_Bool footerOn = sal_False;
-    sal_Int32 footerHeight = 0;
-
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")));
-        aValue >>= footerOn;
-        
-        if( footerOn )
-        {
-            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight")));
-            aValue >>= footerHeight;
-            bottomMargin -= footerHeight;
-        }
-
-        aValue <<= bottomMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
-}
-
-double SAL_CALL ScVbaPageSetup::getRightMargin() throw (css::uno::RuntimeException)
-{
-    sal_Int32 rightMargin = 0;
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin")));
-        aValue >>= rightMargin;
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( rightMargin );;
-}
-
-void SAL_CALL ScVbaPageSetup::setRightMargin( double margin ) throw (css::uno::RuntimeException)
-{
-    sal_Int32 rightMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    try
-    {
-        uno::Any aValue;
-        aValue <<= rightMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
-
-}
-
-double SAL_CALL ScVbaPageSetup::getLeftMargin() throw (css::uno::RuntimeException)
-{
-    sal_Int32 leftMargin = 0;
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin")));
-        aValue >>= leftMargin;
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( leftMargin );;
-}
-
-void SAL_CALL ScVbaPageSetup::setLeftMargin( double margin ) throw (css::uno::RuntimeException)
-{
-    sal_Int32 leftMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    try
-    {
-        uno::Any aValue;
-        aValue <<= leftMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
-}
-
 double SAL_CALL ScVbaPageSetup::getHeaderMargin() throw (css::uno::RuntimeException)
 {
-    sal_Int32 headerMargin = 0;
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")));
-        aValue >>= headerMargin;
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( headerMargin );;
+    return VbaPageSetupBase::getHeaderMargin();
 }
 
 void SAL_CALL ScVbaPageSetup::setHeaderMargin( double margin ) throw (css::uno::RuntimeException)
 {
-    sal_Int32 headerMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    try
-    {
-        uno::Any aValue;
-        aValue <<= headerMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
+    VbaPageSetupBase::setHeaderMargin( margin );
 }
 
 double SAL_CALL ScVbaPageSetup::getFooterMargin() throw (css::uno::RuntimeException)
 {
-    sal_Int32 footerMargin = 0;
-    try
-    {
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")));
-        aValue >>= footerMargin;
-    }
-    catch( uno::Exception& )
-    {
-    }
-    
-    return Millimeter::getInPoints( footerMargin );;
+    return VbaPageSetupBase::getFooterMargin();
 }
 
 void SAL_CALL ScVbaPageSetup::setFooterMargin( double margin ) throw (css::uno::RuntimeException)
 {
-    sal_Int32 footerMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
-    try
-    {
-        uno::Any aValue;
-        aValue <<= footerMargin;
-        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")), aValue );
-    }
-    catch( uno::Exception& )
-    {
-    }
+    VbaPageSetupBase::setFooterMargin( margin );
 }
 
-sal_Int32 SAL_CALL ScVbaPageSetup::getOrientation() throw (css::uno::RuntimeException)
-{
-    sal_Int32 orientation = excel::XlPageOrientation::xlPortrait;
-    try
-    {
-        sal_Bool isLandscape = sal_False;
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")));
-        aValue >>= isLandscape;
-
-        if( isLandscape )
-        {
-            orientation = excel::XlPageOrientation::xlLandscape;
-        }
-    }
-    catch( uno::Exception& )
-    {
-    }
-    return orientation;
-}
-
-void SAL_CALL ScVbaPageSetup::setOrientation( sal_Int32 orientation ) throw (css::uno::RuntimeException)
-{
-    if( ( orientation != excel::XlPageOrientation::xlPortrait ) &&
-        ( orientation != excel::XlPageOrientation::xlLandscape ) )
-    {
-        DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
-    }
-
-    try
-    {
-        sal_Bool isLandscape = sal_False;
-        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")));
-        aValue >>= isLandscape;
-
-        sal_Bool switchOrientation = sal_False;
-        if(( isLandscape && orientation != excel::XlPageOrientation::xlLandscape ) || 
-            ( !isLandscape && orientation != excel::XlPageOrientation::xlPortrait ))
-        {
-            switchOrientation = sal_True;
-        }
-
-        if( switchOrientation )
-        {
-            aValue <<= !isLandscape;
-            uno::Any aHeight = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height")));
-            uno::Any aWidth = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width")));
-            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")), aValue );
-            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width")),  aHeight );
-            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height")), aWidth );
-        }
-
-        if( isLandscape )
-        {
-            orientation = excel::XlPageOrientation::xlLandscape;
-        }
-    }
-    catch( uno::Exception& )
-    {
-    }
-}
-
 uno::Any SAL_CALL ScVbaPageSetup::getFitToPagesTall() throw (css::uno::RuntimeException)
 {
     return mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleToPagesY")));
Index: sc/source/ui/vba/vbarange.hxx
===================================================================
--- sc/source/ui/vba/vbarange.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbarange.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -53,12 +53,15 @@
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
 #include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
 
-//#include "vbahelperinterface.hxx"
+//#include <vbahelper/vbahelperinterface.hxx>
 #include "vbaformat.hxx"
+#include <formula/grammar.hxx>
 
 class ScTableSheetsObj;
 class ScCellRangesBase;
 class ScCellRangeObj;
+class ScDocShell;
+class ScDocument;
 
 //typedef InheritedHelperInterfaceImpl1< ov::excel::XRange >  ScVbaRange_BASE;
 typedef ScVbaFormat< ov::excel::XRange > ScVbaRange_BASE;
@@ -274,6 +277,8 @@
 	static css::uno::Reference< ov::excel::XRange > ApplicationRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException);
 	virtual sal_Bool SAL_CALL GoalSeek( const css::uno::Any& Goal, const css::uno::Reference< ov::excel::XRange >& ChangingCell ) throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL SpecialCells( const css::uno::Any& _oType, const css::uno::Any& _oValue) throw ( css::script::BasicErrorException );  
+	// XErrorQuery
+	virtual ::sal_Bool SAL_CALL hasError(  ) throw (css::uno::RuntimeException);
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
Index: sc/source/ui/vba/vbaworkbook.hxx
===================================================================
--- sc/source/ui/vba/vbaworkbook.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworkbook.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,21 +32,20 @@
 
 #include <com/sun/star/frame/XModel.hpp>
 #include <ooo/vba/excel/XWorkbook.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadocumentbase.hxx>
 
 class ScModelObj;
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XWorkbook > ScVbaWorkbook_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaDocumentBase, ov::excel::XWorkbook > ScVbaWorkbook_BASE;
 
 class ScVbaWorkbook : public ScVbaWorkbook_BASE
 {
-	css::uno::Reference< css::frame::XModel > mxModel;
 	static css::uno::Sequence< sal_Int32 > ColorData;
 	void initColorData( const css::uno::Sequence< sal_Int32 >& sColors );
 	void init();
 protected:
 
-	virtual css::uno::Reference< css::frame::XModel >  getModel() { return mxModel; }
 	ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext);
 public:
 	ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,
@@ -55,25 +54,16 @@
 	virtual ~ScVbaWorkbook() {}
 
     // Attributes
-	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
-	virtual ::rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
-	virtual ::rtl::OUString SAL_CALL getFullName() throw (css::uno::RuntimeException);
 	virtual ::sal_Bool SAL_CALL getProtectStructure() throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XWorksheet > SAL_CALL getActiveSheet() throw (css::uno::RuntimeException);
-	virtual sal_Bool SAL_CALL getSaved() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setSaved( sal_Bool bSave ) throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL getPrecisionAsDisplayed() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setPrecisionAsDisplayed( sal_Bool _precisionAsDisplayed ) throw (css::uno::RuntimeException);
 
 	// Methods
 	virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Close( const css::uno::Any &bSaveChanges,
-								 const css::uno::Any &aFileName,
-								 const css::uno::Any &bRouteWorkbook ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Unprotect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Save() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
     // Amelia Wang
     virtual css::uno::Any SAL_CALL Names( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 
Index: sc/source/ui/vba/service.cxx
===================================================================
--- sc/source/ui/vba/service.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/service.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -61,14 +61,22 @@
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
-namespace  userform
+namespace hyperlink 
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
-namespace hyperlink 
+namespace application 
 {
 extern sdecl::ServiceDecl const serviceDecl;
 }
+namespace vbaeventshelper
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+namespace textframe 
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
 
 extern "C"
 {
@@ -83,10 +91,10 @@
         lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
     {
 		OSL_TRACE("In component_writeInfo");
-
+#if 0
 	// Component registration
         if ( component_writeInfoHelper( pServiceManager, pRegistryKey, 
-		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl ) )
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl ) )
 		{
 			// Singleton registration
 			try
@@ -106,6 +114,12 @@
 			}
 		}
 		return sal_False;
+#else
+	// Component registration
+        return component_writeInfoHelper( pServiceManager, pRegistryKey, 
+		range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl ) && component_writeInfoHelper( pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl, textframe::serviceDecl );
+#endif
+	
     }
 
     SAL_DLLPUBLIC_EXPORT void * SAL_CALL component_getFactory( 
@@ -114,7 +128,9 @@
     {
 		OSL_TRACE("In component_getFactory for %s", pImplName );
 	void* pRet =  component_getFactoryHelper(
-        	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, userform::serviceDecl, window::serviceDecl, hyperlink::serviceDecl );
+        	pImplName, pServiceManager, pRegistryKey, range::serviceDecl, workbook::serviceDecl, worksheet::serviceDecl, globals::serviceDecl, window::serviceDecl, hyperlink::serviceDecl, application::serviceDecl );
+    if( !pRet )
+        pRet = component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey, vbaeventshelper::serviceDecl, textframe::serviceDecl );
 	OSL_TRACE("Ret is 0x%x", pRet);
 	return pRet;
     }
Index: sc/source/ui/vba/vbanames.hxx
===================================================================
--- sc/source/ui/vba/vbanames.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbanames.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,8 +34,11 @@
 #include <ooo/vba/XCollection.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/sheet/XNamedRanges.hpp>
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
+class ScDocument;
+class ScDocShell;
+
 typedef CollTestImplHelper< ov::excel::XNames > ScVbaNames_BASE;
 
 class ScVbaNames : public ScVbaNames_BASE
Index: sc/source/ui/vba/vbarange.cxx.pathched
===================================================================
--- sc/source/ui/vba/vbarange.cxx.pathched	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbarange.cxx.pathched	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,5441 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbarange.cxx,v $
+ * $Revision: 1.8.30.2 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+
+#include <comphelper/unwrapargs.hxx>
+#include <comphelper/processfactory.hxx>
+#include <sfx2/objsh.hxx>
+
+#include <com/sun/star/script/ArrayWrapper.hpp>
+#include <com/sun/star/sheet/XDatabaseRange.hpp>
+#include <com/sun/star/sheet/XDatabaseRanges.hpp>
+#include <com/sun/star/sheet/XGoalSeek.hpp>
+#include <com/sun/star/sheet/XSheetOperation.hpp>
+#include <com/sun/star/sheet/CellFlags.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
+#include <com/sun/star/table/CellContentType.hpp>
+#include <com/sun/star/sheet/XCellSeries.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/sheet/XSheetCellCursor.hpp>
+#include <com/sun/star/sheet/XArrayFormulaRange.hpp>
+#include <com/sun/star/sheet/XNamedRange.hpp>
+#include <com/sun/star/sheet/XPrintAreas.hpp>
+#include <com/sun/star/sheet/XCellRangesQuery.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/table/XCellCursor.hpp>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/table/TableSortField.hpp>
+#include <com/sun/star/util/XMergeable.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/util/XNumberFormats.hpp>
+#include <com/sun/star/util/NumberFormat.hpp>
+#include <com/sun/star/util/XNumberFormatTypes.hpp>
+#include <com/sun/star/util/XReplaceable.hpp>
+#include <com/sun/star/util/XSortable.hpp>
+#include <com/sun/star/sheet/XCellRangeMovement.hpp>
+#include <com/sun/star/sheet/XCellRangeData.hpp>
+#include <com/sun/star/sheet/FormulaResult.hpp>
+#include <com/sun/star/sheet/FilterOperator2.hpp>
+#include <com/sun/star/sheet/TableFilterField.hpp>
+#include <com/sun/star/sheet/TableFilterField2.hpp>
+#include <com/sun/star/sheet/XSheetFilterDescriptor2.hpp>
+#include <com/sun/star/sheet/XSheetFilterable.hpp>
+#include <com/sun/star/sheet/FilterConnection.hpp>
+#include <com/sun/star/util/CellProtection.hpp>
+
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/awt/XDevice.hpp>
+
+//#include <com/sun/star/sheet/CellDeleteMode.hpp>
+#include <com/sun/star/sheet/XCellRangeMovement.hpp>
+#include <com/sun/star/sheet/XSubTotalCalculatable.hpp>
+#include <com/sun/star/sheet/XSubTotalDescriptor.hpp>
+#include <com/sun/star/sheet/GeneralFunction.hdl>
+
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XSheetAnnotations.hpp>
+#include <ooo/vba/excel/XlPasteSpecialOperation.hpp>
+#include <ooo/vba/excel/XlPasteType.hpp>
+#include <ooo/vba/excel/Constants.hpp>
+#include <ooo/vba/excel/XlFindLookIn.hpp>
+#include <ooo/vba/excel/XlLookAt.hpp>
+#include <ooo/vba/excel/XlSearchOrder.hpp>
+#include <ooo/vba/excel/XlSortOrder.hpp>
+#include <ooo/vba/excel/XlYesNoGuess.hpp>
+#include <ooo/vba/excel/XlSortOrientation.hpp>
+#include <ooo/vba/excel/XlSortMethod.hpp>
+#include <ooo/vba/excel/XlDirection.hpp>
+#include <ooo/vba/excel/XlSortDataOption.hpp>
+#include <ooo/vba/excel/XlDeleteShiftDirection.hpp>
+#include <ooo/vba/excel/XlInsertShiftDirection.hpp>
+#include <ooo/vba/excel/XlReferenceStyle.hpp>
+#include <ooo/vba/excel/XlBordersIndex.hpp>
+#include <ooo/vba/excel/XlPageBreak.hpp>
+#include <ooo/vba/excel/XlAutoFilterOperator.hpp>
+#include <ooo/vba/excel/XlAutoFillType.hpp>
+#include <ooo/vba/excel/XlTextParsingType.hpp>
+#include <ooo/vba/excel/XlTextQualifier.hpp>
+#include <ooo/vba/excel/XlCellType.hpp>
+#include <ooo/vba/excel/XlSpecialCellsValue.hpp>
+#include <ooo/vba/excel/XlConsolidationFunction.hpp>
+#include <ooo/vba/excel/XlSearchDirection.hpp>
+
+#include <scitems.hxx>
+#include <svx/srchitem.hxx>
+#include <cellsuno.hxx>
+#include <dbcolect.hxx>
+#include "docfunc.hxx"
+
+#include <sfx2/dispatch.hxx>
+#include <sfx2/app.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/request.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/itemwrapper.hxx>
+#include <sc.hrc>
+#include <globstr.hrc>
+#include <unonames.hxx>
+
+#include "vbarange.hxx"
+#include "vbafont.hxx"
+#include "vbacomment.hxx"
+#include "vbainterior.hxx"
+#include "vbacharacters.hxx"
+#include "vbaborders.hxx"
+#include "vbaworksheet.hxx"
+#include "vbavalidation.hxx"
+
+#include "tabvwsh.hxx"
+#include "rangelst.hxx"
+#include "convuno.hxx"
+#include "compiler.hxx"
+#include "attrib.hxx"
+#include "undodat.hxx"
+#include "dbdocfun.hxx"
+#include "patattr.hxx"
+#include "olinetab.hxx"
+#include <comphelper/anytostring.hxx>
+
+#include <global.hxx>
+
+#include "vbaglobals.hxx"
+#include "vbastyle.hxx"
+#include <vector>
+#include <vbahelper/vbacollectionimpl.hxx>
+// begin test includes
+#include <com/sun/star/sheet/FunctionArgument.hpp>
+// end test includes
+
+#include <ooo/vba/excel/Range.hpp>
+#include <com/sun/star/bridge/oleautomation/Date.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+using ::std::vector;
+
+//    * 1 point = 1/72 inch = 20 twips
+//    * 1 inch = 72 points = 1440 twips
+//    * 1 cm = 567 twips
+double lcl_hmmToPoints( double nVal ) { return ( (double)((nVal /1000 ) * 567 ) / 20 ); }
+
+static const sal_Int16 supportedIndexTable[] = {  excel::XlBordersIndex::xlEdgeLeft, excel::XlBordersIndex::xlEdgeTop, excel::XlBordersIndex::xlEdgeBottom, excel::XlBordersIndex::xlEdgeRight, excel::XlBordersIndex::xlDiagonalDown, excel::XlBordersIndex::xlDiagonalUp, excel::XlBordersIndex::xlInsideVertical, excel::XlBordersIndex::xlInsideHorizontal };
+
+USHORT lcl_pointsToTwips( double nVal ) 
+{ 
+	nVal = nVal * static_cast<double>(20);
+	short nTwips = static_cast<short>(nVal);
+	return nTwips;
+}
+double lcl_TwipsToPoints( USHORT nVal ) 
+{ 
+	double nPoints = nVal;
+	return nPoints / 20; 
+}
+
+double lcl_Round2DecPlaces( double nVal )
+{
+	nVal  = (nVal * (double)100);
+	long tmp = static_cast<long>(nVal);
+	if ( ( ( nVal - tmp ) >= 0.5 ) )
+		++tmp;
+	nVal = tmp;
+	nVal = nVal/100;
+	return nVal;
+}
+
+uno::Any lcl_makeRange( uno::Reference< uno::XComponentContext >& xContext, const uno::Any aAny, bool bIsRows, bool bIsColumns )
+{
+	uno::Reference< table::XCellRange > xCellRange( aAny, uno::UNO_QUERY_THROW );
+	// #FIXME need proper (WorkSheet) parent
+	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xCellRange, bIsRows, bIsColumns ) ) );
+}
+
+uno::Reference< excel::XRange > lcl_makeXRangeFromSheetCellRanges( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRanges >& xLocSheetCellRanges, ScDocShell* pDoc )
+{
+	uno::Reference< excel::XRange > xRange;
+	uno::Sequence< table::CellRangeAddress  > sAddresses = xLocSheetCellRanges->getRangeAddresses();
+	ScRangeList aCellRanges;
+	sal_Int32 nLen = sAddresses.getLength();
+	if ( nLen )
+       	{ 
+	for ( sal_Int32 index = 0; index < nLen; ++index )
+	{
+		ScRange refRange;
+		ScUnoConversion::FillScRange( refRange, sAddresses[ index ] );
+		aCellRanges.Append( refRange );
+	}
+	// Single range
+	if ( aCellRanges.First() == aCellRanges.Last() )
+	{
+		uno::Reference< table::XCellRange > xTmpRange( new ScCellRangeObj( pDoc, *aCellRanges.First() ) );
+		// #FIXME need proper (WorkSheet) parent
+		xRange = new ScVbaRange( xParent, xContext, xTmpRange );
+	}
+	else
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pDoc, aCellRanges ) );
+		// #FIXME need proper (WorkSheet) parent
+		xRange = new ScVbaRange( xParent, xContext, xRanges );
+	}
+	}
+	return xRange;
+}
+
+ScCellRangeObj*  ScVbaRange::getCellRangeObj() throw ( uno::RuntimeException )
+{
+	uno::Reference< uno::XInterface > xIf;
+	if ( mxRanges.is() )
+		xIf.set( mxRanges, uno::UNO_QUERY_THROW );
+	else 
+		xIf.set( mxRange, uno::UNO_QUERY_THROW );
+	ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
+	return pUnoCellRange;
+}
+
+SfxItemSet*  ScVbaRange::getCurrentDataSet( ) throw ( uno::RuntimeException )
+{
+	ScCellRangeObj* pUnoCellRange = getCellRangeObj();
+	SfxItemSet* pDataSet = excel::ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
+	if ( !pDataSet )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't access Itemset for range" ) ), uno::Reference< uno::XInterface >() );
+	return pDataSet;	
+}
+
+class SingleRangeEnumeration : public EnumerationHelper_BASE
+{
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > mxContext;
+	bool bHasMore;
+public:
+
+	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), mxContext( xContext ), bHasMore( true ) { }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) { return bHasMore; }
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{
+		if ( !bHasMore )
+			throw container::NoSuchElementException();
+		bHasMore = false;
+		return uno::makeAny( m_xRange );
+	}
+};
+
+// very simple class to pass to ScVbaCollectionBaseImpl containing
+// just one item
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > SingleRange_BASE;
+
+class SingleRangeIndexAccess : public SingleRange_BASE
+{
+private:
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > mxContext;
+	SingleRangeIndexAccess(); // not defined
+public:
+	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), mxContext( xContext ) {}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount() throw (::uno::RuntimeException) { return 1; }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+	{ 
+		if ( Index != 0 )
+			throw lang::IndexOutOfBoundsException();
+		return uno::makeAny( m_xRange ); 
+	}
+        // XElementAccess
+        virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return table::XCellRange::static_type(0); }
+ 
+        virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException) { return sal_True; }
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( mxContext, m_xRange ); }
+
+};
+
+
+
+class RangesEnumerationImpl : public EnumerationHelperImpl
+{
+	bool mbIsRows;
+	bool mbIsColumns;
+public:
+
+	RangesEnumerationImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration, bool bIsRows, bool bIsColumns ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), mbIsRows( bIsRows ), mbIsColumns( bIsColumns ) {}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		return lcl_makeRange( m_xContext, m_xEnumeration->nextElement(), mbIsRows, mbIsColumns );
+	}
+};
+
+
+class ScVbaRangeAreas : public ScVbaCollectionBaseImpl
+{
+	bool mbIsRows;
+	bool mbIsColumns;
+public:
+	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess, bool bIsRows, bool bIsColumns ) : ScVbaCollectionBaseImpl( uno::Reference< XHelperInterface >(), xContext, xIndexAccess ), mbIsRows( bIsRows ), mbIsColumns( bIsColumns ) {}
+
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException);
+
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return excel::XRange::static_type(0); }
+
+	virtual uno::Any createCollectionObject( const uno::Any& aSource );
+
+	virtual rtl::OUString& getServiceImplName() { static rtl::OUString sDummy; return sDummy; }
+
+	virtual uno::Sequence< rtl::OUString > getServiceNames() { return uno::Sequence< rtl::OUString >(); } 
+
+}; 
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaRangeAreas::createEnumeration() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new RangesEnumerationImpl( mxContext, xEnumAccess->createEnumeration(), mbIsRows, mbIsColumns );
+
+}
+
+uno::Any 
+ScVbaRangeAreas::createCollectionObject( const uno::Any& aSource )
+{
+	return lcl_makeRange( mxContext, aSource, mbIsRows, mbIsColumns );
+}
+
+// assume that xIf is infact a ScCellRangesBase
+ScDocShell*
+getDocShellFromIf( const uno::Reference< uno::XInterface >& xIf ) throw ( uno::RuntimeException )
+{
+	ScCellRangesBase* pUno= dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	if ( !pUno )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying uno range object" ) ), uno::Reference< uno::XInterface >()  );
+	return pUno->GetDocShell();
+}
+
+ScDocShell* 
+getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException )
+{
+	// need the ScCellRangesBase to get docshell
+	uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
+	return getDocShellFromIf(xIf );
+}
+
+uno::Reference< frame::XModel > getModelFromXIf( const uno::Reference< uno::XInterface >& xIf ) throw ( uno::RuntimeException )
+{
+	ScDocShell* pDocShell = getDocShellFromIf(xIf );
+	return pDocShell->GetModel();
+}
+
+uno::Reference< frame::XModel > getModelFromRange( const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException )
+{
+	uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
+	return getModelFromXIf( xIf );
+}
+
+ScDocument* 
+getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
+{
+	ScDocShell* pDocShell = getDocShellFromRange( xRange );
+	if ( !pDocShell )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying docshell from uno range object" ) ), uno::Reference< uno::XInterface >() );
+	ScDocument* pDoc = pDocShell->GetDocument();
+	return pDoc;
+}
+
+
+ScDocument* 
+ScVbaRange::getScDocument()
+{
+	if ( mxRanges.is() )
+	{
+		uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xRange( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+		return getDocumentFromRange( xRange );
+	}
+	return getDocumentFromRange( mxRange );
+}
+
+ScDocShell* 
+ScVbaRange::getScDocShell()
+{
+	if ( mxRanges.is() )
+	{
+		uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xRange( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+		return getDocShellFromRange( xRange );
+	}
+	return getDocShellFromRange( mxRange );
+}
+
+class NumFormatHelper
+{
+	uno::Reference< util::XNumberFormatsSupplier > mxSupplier;
+	uno::Reference< beans::XPropertySet > mxRangeProps;
+	uno::Reference< util::XNumberFormats > mxFormats;
+public:
+	NumFormatHelper( const uno::Reference< table::XCellRange >& xRange )
+	{
+		mxSupplier.set( getModelFromRange( xRange ), uno::UNO_QUERY_THROW );
+		mxRangeProps.set( xRange, uno::UNO_QUERY_THROW);
+		mxFormats = mxSupplier->getNumberFormats();
+	}
+	uno::Reference< beans::XPropertySet > getNumberProps()
+	{	
+		long nIndexKey = 0;
+		uno::Any aValue = mxRangeProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat")));
+		aValue >>= nIndexKey;
+
+		if ( mxFormats.is() )
+			return  mxFormats->getByKey( nIndexKey );
+		return	uno::Reference< beans::XPropertySet > ();
+	}
+
+	bool isBooleanType()
+	{
+	
+		if ( getNumberFormat() & util::NumberFormat::LOGICAL )
+			return true;
+		return false;
+	}
+
+	bool isDateType()
+	{
+		sal_Int16 nType = getNumberFormat();
+		if(( nType & util::NumberFormat::DATETIME ))
+		{
+			return true;
+		}
+		return false;
+	}
+	
+	rtl::OUString getNumberFormatString()
+	{
+		uno::Reference< uno::XInterface > xIf( mxRangeProps, uno::UNO_QUERY_THROW );
+		ScCellRangeObj* pUnoCellRange = dynamic_cast<  ScCellRangeObj* >( xIf.get() );
+		if ( pUnoCellRange )
+		{
+			
+			SfxItemSet* pDataSet = 	excel::ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
+			SfxItemState eState = pDataSet->GetItemState( ATTR_VALUE_FORMAT, TRUE, NULL);
+			// one of the cells in the range is not like the other ;-)
+			// so return a zero length format to indicate that
+			if ( eState == SFX_ITEM_DONTCARE )
+				return rtl::OUString();
+		}
+		
+	
+		uno::Reference< beans::XPropertySet > xNumberProps( getNumberProps(), uno::UNO_QUERY_THROW );
+		::rtl::OUString aFormatString;
+		uno::Any aString = xNumberProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FormatString")));
+		aString >>= aFormatString;
+		return aFormatString;
+	}
+
+	sal_Int16 getNumberFormat()
+	{
+		uno::Reference< beans::XPropertySet > xNumberProps = getNumberProps(); 	
+		sal_Int16 nType = ::comphelper::getINT16(
+        	xNumberProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Type" ) ) );
+		return nType;
+	}
+
+	bool setNumberFormat( const  rtl::OUString& rFormat )
+	{
+		lang::Locale aLocale;
+		uno::Reference< beans::XPropertySet > xNumProps = getNumberProps(); 	
+		xNumProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Locale" ) ) >>= aLocale;
+		sal_Int32 nNewIndex = mxFormats->queryKey(rFormat, aLocale, false );
+		if ( nNewIndex == -1 ) // format not defined
+		{
+			nNewIndex = mxFormats->addNew( rFormat, aLocale );
+		}
+		mxRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat") ), uno::makeAny( nNewIndex ) );				
+		return true;
+	}
+
+	bool setNumberFormat( sal_Int16 nType )
+	{
+		uno::Reference< beans::XPropertySet > xNumberProps = getNumberProps(); 	
+		lang::Locale aLocale;
+		xNumberProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Locale" ) ) >>= aLocale;
+		uno::Reference<util::XNumberFormatTypes> xTypes( mxFormats, uno::UNO_QUERY );
+		if ( xTypes.is() )
+		{
+			sal_Int32 nNewIndex = xTypes->getStandardFormat( nType, aLocale );
+       		mxRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat") ), uno::makeAny( nNewIndex ) );				
+			return true;
+		}
+		return false;
+	}
+
+};
+
+struct CellPos
+{
+	CellPos():m_nRow(-1), m_nCol(-1), m_nArea(0) {};
+	CellPos( sal_Int32 nRow, sal_Int32 nCol, sal_Int32 nArea ):m_nRow(nRow), m_nCol(nCol), m_nArea( nArea ) {};
+sal_Int32 m_nRow;
+sal_Int32 m_nCol;
+sal_Int32 m_nArea;
+};
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > CellsEnumeration_BASE;
+typedef ::std::vector< CellPos > vCellPos;
+
+// #FIXME - QUICK
+// we could probably could and should modify CellsEnumeration below
+// to handle rows and columns ( but I do this seperately for now 
+// and.. this class only handles singe areas ( does it have to handle
+// multi area ranges?? ) 
+class ColumnsRowEnumeration: public CellsEnumeration_BASE
+{
+	uno::Reference< uno::XComponentContext > mxContext;
+        uno::Reference< excel::XRange > mxRange;
+	sal_Int32 mMaxElems;
+	sal_Int32 mCurElem;
+        
+public:
+	ColumnsRowEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< excel::XRange >& xRange, sal_Int32 nElems ) : mxContext( xContext ), mxRange( xRange ), mMaxElems( nElems ), mCurElem( 0 )
+        {
+	}
+
+	virtual ::sal_Bool SAL_CALL hasMoreElements() throw (::uno::RuntimeException){ return mCurElem < mMaxElems; }
+
+	virtual uno::Any SAL_CALL nextElement() throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		sal_Int32 vbaIndex = 1 + mCurElem++; 
+		return uno::makeAny( mxRange->Item( uno::makeAny( vbaIndex ), uno::Any() ) ); 
+	}
+};
+
+class CellsEnumeration : public CellsEnumeration_BASE
+{
+	uno::Reference< uno::XComponentContext > mxContext;
+	uno::Reference< XCollection > m_xAreas;
+	vCellPos m_CellPositions;	
+	vCellPos::const_iterator m_it; 
+	uno::Reference< table::XCellRange > getArea( sal_Int32 nVBAIndex ) throw ( uno::RuntimeException )
+	{
+		if ( nVBAIndex < 1 || nVBAIndex > m_xAreas->getCount() )
+			throw uno::RuntimeException();
+		uno::Reference< excel::XRange > xRange( m_xAreas->Item( uno::makeAny(nVBAIndex), uno::Any() ), uno::UNO_QUERY_THROW );
+		ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+		uno::Reference< table::XCellRange > xCellRange;
+		if ( !pRange )
+			throw uno::RuntimeException();
+		xCellRange.set( pRange->getCellRange(), uno::UNO_QUERY_THROW );;
+		return xCellRange;
+		
+	}
+        void populateArea( sal_Int32 nVBAIndex )
+	{
+		uno::Reference< table::XCellRange > xRange = getArea( nVBAIndex );
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(xRange, uno::UNO_QUERY_THROW );
+		sal_Int32 nRowCount =  xColumnRowRange->getRows()->getCount();
+		sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+		for ( sal_Int32 i=0; i<nRowCount; ++i )
+		{
+			for ( sal_Int32 j=0; j<nColCount; ++j )
+				m_CellPositions.push_back( CellPos( i,j,nVBAIndex ) );
+		}
+	}
+public:
+	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCollection >& xAreas ): mxContext( xContext ), m_xAreas( xAreas )
+	{
+		sal_Int32 nItems = m_xAreas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+        		populateArea( index );
+		}
+		m_it = m_CellPositions.begin();
+	}
+	virtual ::sal_Bool SAL_CALL hasMoreElements() throw (::uno::RuntimeException){ return m_it != m_CellPositions.end(); }
+
+	virtual uno::Any SAL_CALL nextElement() throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		CellPos aPos = *(m_it)++;
+		
+		uno::Reference< table::XCellRange > xRangeArea = getArea( aPos.m_nArea );
+		uno::Reference< table::XCellRange > xCellRange( xRangeArea->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
+		// #FIXME need proper (WorkSheet) parent
+		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< XHelperInterface >(), mxContext, xCellRange ) ) );
+
+	}
+};
+
+
+const static ::rtl::OUString ISVISIBLE(  RTL_CONSTASCII_USTRINGPARAM( "IsVisible"));
+const static ::rtl::OUString WIDTH(  RTL_CONSTASCII_USTRINGPARAM( "Width"));
+const static ::rtl::OUString HEIGHT(  RTL_CONSTASCII_USTRINGPARAM( "Height"));
+const static ::rtl::OUString POSITION(  RTL_CONSTASCII_USTRINGPARAM( "Position"));
+const static rtl::OUString EQUALS( RTL_CONSTASCII_USTRINGPARAM("=") );
+const static rtl::OUString NOTEQUALS( RTL_CONSTASCII_USTRINGPARAM("<>") );
+const static rtl::OUString GREATERTHAN( RTL_CONSTASCII_USTRINGPARAM(">") );
+const static rtl::OUString GREATERTHANEQUALS( RTL_CONSTASCII_USTRINGPARAM(">=") );
+const static rtl::OUString LESSTHAN( RTL_CONSTASCII_USTRINGPARAM("<") );
+const static rtl::OUString LESSTHANEQUALS( RTL_CONSTASCII_USTRINGPARAM("<=") );
+const static rtl::OUString CONTS_HEADER( RTL_CONSTASCII_USTRINGPARAM("ContainsHeader" ));
+const static rtl::OUString INSERTPAGEBREAKS( RTL_CONSTASCII_USTRINGPARAM("InsertPageBreaks" ));
+const static rtl::OUString STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY( RTL_CONSTASCII_USTRINGPARAM("The command you chose cannot be performed with multiple selections.\nSelect a single range and click the command again") );
+const static rtl::OUString STR_ERRORMESSAGE_NOCELLSWEREFOUND( RTL_CONSTASCII_USTRINGPARAM("No cells were found") );
+const static rtl::OUString STR_ERRORMESSAGE_APPLIESTOROWCOLUMNSONLY( RTL_CONSTASCII_USTRINGPARAM("Property only applicable for Columns and Rows") );
+const static rtl::OUString CELLSTYLE( RTL_CONSTASCII_USTRINGPARAM("CellStyle") );
+
+class CellValueSetter : public ValueSetter
+{
+protected:
+	uno::Any maValue;
+	uno::TypeClass mTypeClass;
+public:
+	CellValueSetter( const uno::Any& aValue );
+	virtual bool processValue( const uno::Any& aValue,  const uno::Reference< table::XCell >& xCell );
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell );
+		
+};
+
+CellValueSetter::CellValueSetter( const uno::Any& aValue ): maValue( aValue ), mTypeClass( aValue.getValueTypeClass() ) {}
+
+void
+CellValueSetter::visitNode( sal_Int32 /*i*/, sal_Int32 /*j*/, const uno::Reference< table::XCell >& xCell )
+{
+	processValue( maValue, xCell );
+}
+
+bool
+CellValueSetter::processValue( const uno::Any& aValue, const uno::Reference< table::XCell >& xCell )
+{
+
+	bool isExtracted = false;
+	switch ( aValue.getValueTypeClass() )
+	{
+		case  uno::TypeClass_BOOLEAN:
+		{
+			sal_Bool bState = sal_False;
+			if ( aValue >>= bState 	 )
+			{
+				uno::Reference< table::XCellRange > xRange( xCell, uno::UNO_QUERY_THROW );
+				if ( bState )
+					xCell->setValue( (double) 1 );
+				else
+					xCell->setValue( (double) 0 );
+				NumFormatHelper cellNumFormat( xRange );
+				cellNumFormat.setNumberFormat( util::NumberFormat::LOGICAL );
+			}
+			break;
+		}
+		case uno::TypeClass_STRING:
+		{
+			rtl::OUString aString;
+			if ( aValue >>= aString )
+			{
+				uno::Reference< text::XTextRange > xTextRange( xCell, uno::UNO_QUERY_THROW );
+				xTextRange->setString( aString );
+			}
+			else
+				isExtracted = false;	
+			break;
+		}
+		default:
+		{
+			double nDouble = 0.0;
+			if ( aValue >>= nDouble )
+				xCell->setValue( nDouble );
+			else
+				isExtracted = false;	
+			break;
+		}
+	}
+	return isExtracted;
+		
+}
+
+
+class CellValueGetter : public ValueGetter
+{
+protected:
+	uno::Any maValue;
+	uno::TypeClass mTypeClass;
+public:
+	CellValueGetter() {}
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell );
+	virtual void processValue( sal_Int32 x, sal_Int32 y, const uno::Any& aValue );
+	const uno::Any& getValue() const { return maValue; }
+		
+};
+
+void
+CellValueGetter::processValue(  sal_Int32 /*x*/, sal_Int32 /*y*/, const uno::Any& aValue )
+{
+	maValue = aValue;
+}
+void CellValueGetter::visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+{
+	uno::Any aValue;
+	table::CellContentType eType = xCell->getType();
+	if( eType == table::CellContentType_VALUE || eType == table::CellContentType_FORMULA )
+	{
+		if ( eType == table::CellContentType_FORMULA )
+		{
+				
+			rtl::OUString sFormula = xCell->getFormula();
+			if ( sFormula.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=TRUE()") ) ) )
+				aValue <<= sal_True;
+			else if ( sFormula.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=FALSE()") ) ) )
+				aValue <<= sal_False;
+			else 	
+			{
+				uno::Reference< beans::XPropertySet > xProp( xCell, uno::UNO_QUERY_THROW );
+				
+				table::CellContentType eFormulaType = table::CellContentType_VALUE;
+				// some formulas give textual results
+				xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FormulaResultType" ) ) ) >>= eFormulaType;
+
+				if ( eFormulaType == table::CellContentType_TEXT )
+				{
+					uno::Reference< text::XTextRange > xTextRange(xCell, ::uno::UNO_QUERY_THROW);
+					aValue <<= xTextRange->getString();
+				}
+				else	
+					aValue <<= xCell->getValue();
+			}
+		}
+		else
+		{
+			uno::Reference< table::XCellRange > xRange( xCell, uno::UNO_QUERY_THROW );
+			NumFormatHelper cellFormat( xRange );
+			if ( cellFormat.isBooleanType() )
+				aValue = uno::makeAny( ( xCell->getValue() != 0.0 ) );
+			else if ( cellFormat.isDateType() )
+				aValue = uno::makeAny( bridge::oleautomation::Date( xCell->getValue() ) );
+			else
+				aValue <<= xCell->getValue();
+		}
+	}
+	if( eType == table::CellContentType_TEXT )
+	{
+		uno::Reference< text::XTextRange > xTextRange(xCell, ::uno::UNO_QUERY_THROW);
+		aValue <<= xTextRange->getString();
+	}
+	processValue( x,y,aValue );
+}
+
+class CellFormulaValueSetter : public CellValueSetter
+{
+private:
+	ScDocument*  m_pDoc;
+    formula::FormulaGrammar::Grammar m_eGrammar;
+public:
+	CellFormulaValueSetter( const uno::Any& aValue, ScDocument* pDoc, formula::FormulaGrammar::Grammar eGram ):CellValueSetter( aValue ),  m_pDoc( pDoc ), m_eGrammar( eGram ){}
+protected:
+	bool processValue( const uno::Any& aValue, const uno::Reference< table::XCell >& xCell )
+	{
+		rtl::OUString sFormula;
+		double aDblValue = 0.0;
+		if ( aValue >>= sFormula )
+		{
+            // convert to GRAM_PODF_A1 style grammar because XCell::setFormula
+            // always compile it in that grammar. Perhaps
+            // css.sheet.FormulaParser should be used in future to directly
+            // pass formula tokens when that API stabilizes.
+            if ( m_eGrammar != formula::FormulaGrammar::GRAM_PODF_A1 && ( sFormula.trim().indexOf('=') == 0 ) )	
+			{
+				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
+				ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+				if ( pUnoRangesBase )
+				{
+					ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();	
+					ScCompiler aCompiler( m_pDoc, aCellRanges.First()->aStart );
+                    aCompiler.SetGrammar(m_eGrammar);
+					// compile the string in the format passed in
+					aCompiler.CompileString( sFormula );
+					// set desired convention to that of the document
+                    aCompiler.SetGrammar( formula::FormulaGrammar::GRAM_PODF_A1 );
+					String sConverted;
+					aCompiler.CreateStringFromTokenArray(sConverted);
+					sFormula = EQUALS + sConverted;
+				}
+			}
+
+			xCell->setFormula( sFormula );
+			return true;
+		}
+		else if ( aValue >>= aDblValue )
+		{
+			xCell->setValue( aDblValue );
+			return true;
+		}
+		return false;
+	}
+		
+};
+
+class CellFormulaValueGetter : public CellValueGetter
+{
+private:
+	ScDocument*  m_pDoc;
+    formula::FormulaGrammar::Grammar m_eGrammar;
+public:
+	CellFormulaValueGetter(ScDocument* pDoc, formula::FormulaGrammar::Grammar eGram ) : CellValueGetter( ), m_pDoc( pDoc ), m_eGrammar( eGram ) {}
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		uno::Any aValue;
+		aValue <<= xCell->getFormula();	
+		rtl::OUString sVal;
+		aValue >>= sVal;
+		uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
+		ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+		if ( ( xCell->getType() == table::CellContentType_FORMULA ) &&
+			pUnoRangesBase )
+		{
+			ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();	
+			ScCompiler aCompiler( m_pDoc, aCellRanges.First()->aStart );
+            aCompiler.SetGrammar(formula::FormulaGrammar::GRAM_DEFAULT);
+			aCompiler.CompileString( sVal );
+			// set desired convention
+            aCompiler.SetGrammar( m_eGrammar );
+			String sConverted;
+			aCompiler.CreateStringFromTokenArray(sConverted);
+			sVal = EQUALS + sConverted;
+			aValue <<= sVal;
+		}
+
+		processValue( x,y,aValue );
+	}
+		
+};
+
+
+class Dim2ArrayValueGetter : public ArrayVisitor
+{
+protected:
+	uno::Any maValue;
+	ValueGetter& mValueGetter;
+	virtual void processValue( sal_Int32 x, sal_Int32 y, const uno::Any& aValue )
+	{
+		uno::Sequence< uno::Sequence< uno::Any > >& aMatrix = *( uno::Sequence< uno::Sequence< uno::Any > >* )( maValue.getValue() );
+		aMatrix[x][y] = aValue;
+	}
+
+public:
+	Dim2ArrayValueGetter(sal_Int32 nRowCount, sal_Int32 nColCount, ValueGetter& rValueGetter ): mValueGetter(rValueGetter) 
+	{
+		uno::Sequence< uno::Sequence< uno::Any > > aMatrix;
+		aMatrix.realloc( nRowCount );	
+		for ( sal_Int32 index = 0; index < nRowCount; ++index )
+			aMatrix[index].realloc( nColCount );
+		maValue <<= aMatrix;
+	}
+	void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+
+	{
+		mValueGetter.visitNode( x, y, xCell );
+		processValue( x, y, mValueGetter.getValue() );
+	}
+	const uno::Any& getValue() const { return maValue; }
+
+};
+
+const static rtl::OUString sNA = rtl::OUString::createFromAscii("#N/A"); 
+
+class Dim1ArrayValueSetter : public ArrayVisitor
+{
+	uno::Sequence< uno::Any > aMatrix;
+	sal_Int32 nColCount;
+	ValueSetter& mCellValueSetter;
+public:
+	Dim1ArrayValueSetter( const uno::Any& aValue, ValueSetter& rCellValueSetter ):mCellValueSetter( rCellValueSetter )
+	{
+		aValue >>= aMatrix;
+		nColCount = aMatrix.getLength();
+	}
+	virtual void visitNode( sal_Int32 /*x*/, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		if ( y < nColCount )
+			mCellValueSetter.processValue( aMatrix[ y ], xCell );
+		else
+			mCellValueSetter.processValue( uno::makeAny( sNA ), xCell );
+	}
+};
+
+
+
+class Dim2ArrayValueSetter : public ArrayVisitor
+{
+	uno::Sequence< uno::Sequence< uno::Any > > aMatrix;
+	ValueSetter& mCellValueSetter;
+	sal_Int32 nRowCount;
+	sal_Int32 nColCount;
+public:
+	Dim2ArrayValueSetter( const uno::Any& aValue, ValueSetter& rCellValueSetter ) : mCellValueSetter( rCellValueSetter )
+	{
+		aValue >>= aMatrix;
+		nRowCount = aMatrix.getLength();
+		nColCount = aMatrix[0].getLength();  
+	}
+
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		if ( x < nRowCount && y < nColCount )
+			mCellValueSetter.processValue( aMatrix[ x ][ y ], xCell );
+		else
+			mCellValueSetter.processValue( uno::makeAny( sNA ), xCell );
+			
+	}
+};
+
+class RangeProcessor
+{
+public:
+	virtual void process( const uno::Reference< excel::XRange >& xRange ) = 0;
+};
+
+class RangeValueProcessor : public RangeProcessor
+{
+	const uno::Any& m_aVal;
+public:
+	RangeValueProcessor( const uno::Any& rVal ):m_aVal( rVal ) {}
+	virtual void process( const uno::Reference< excel::XRange >& xRange )
+	{
+		xRange->setValue( m_aVal );
+	}
+};
+
+class RangeFormulaProcessor : public RangeProcessor
+{
+	const uno::Any& m_aVal;
+public:
+	RangeFormulaProcessor( const uno::Any& rVal ):m_aVal( rVal ) {}
+	virtual void process( const uno::Reference< excel::XRange >& xRange ) 
+	{
+		xRange->setFormula( m_aVal );
+	}
+};
+
+class RangeCountProcessor : public RangeProcessor
+{
+	sal_Int32 nCount;
+public:
+	RangeCountProcessor():nCount(0){}
+	virtual void process( const uno::Reference< excel::XRange >& xRange )
+	{
+		nCount = nCount + xRange->getCount();
+	}
+	sal_Int32 value() { return nCount; }
+};
+class AreasVisitor
+{
+private:
+	uno::Reference< XCollection > m_Areas;
+public:
+	AreasVisitor( const uno::Reference< XCollection >& rAreas ):m_Areas( rAreas ){} 
+	
+	void visit( RangeProcessor& processor )
+	{
+		if ( m_Areas.is() )
+		{
+			sal_Int32 nItems = m_Areas->getCount();
+			for ( sal_Int32 index=1; index <= nItems; ++index )
+			{
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+				processor.process( xRange ); 
+			}
+		}	
+	}
+};
+
+class RangeHelper
+{
+	uno::Reference< table::XCellRange > m_xCellRange;
+	
+public:
+	RangeHelper( const uno::Reference< table::XCellRange >& xCellRange ) throw (uno::RuntimeException) : m_xCellRange( xCellRange ) 
+	{
+		if ( !m_xCellRange.is() )
+			throw uno::RuntimeException();
+	}
+	RangeHelper( const uno::Any aCellRange ) throw (uno::RuntimeException)
+	{
+		m_xCellRange.set( aCellRange, uno::UNO_QUERY_THROW );
+	}
+	uno::Reference< sheet::XSheetCellRange > getSheetCellRange() throw (uno::RuntimeException)
+	{
+		return uno::Reference< sheet::XSheetCellRange >(m_xCellRange, uno::UNO_QUERY_THROW);
+	}
+	uno::Reference< sheet::XSpreadsheet >  getSpreadSheet() throw (uno::RuntimeException)
+	{
+		return getSheetCellRange()->getSpreadsheet();
+	}	
+
+	uno::Reference< table::XCellRange > getCellRangeFromSheet() throw (uno::RuntimeException)
+	{
+		return uno::Reference< table::XCellRange >(getSpreadSheet(), uno::UNO_QUERY_THROW );
+	}
+
+	uno::Reference< sheet::XCellRangeAddressable >  getCellRangeAddressable() throw (uno::RuntimeException)
+	{
+		return uno::Reference< sheet::XCellRangeAddressable >(m_xCellRange, ::uno::UNO_QUERY_THROW);
+
+	}
+
+	uno::Reference< sheet::XSheetCellCursor > getSheetCellCursor() throw ( uno::RuntimeException )
+	{
+		return 	uno::Reference< sheet::XSheetCellCursor >( getSpreadSheet()->createCursorByRange( getSheetCellRange() ), uno::UNO_QUERY_THROW );
+	}	
+
+	static uno::Reference< excel::XRange > createRangeFromRange( const uno::Reference<uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, const uno::Reference< sheet::XCellRangeAddressable >& xCellRangeAddressable, sal_Int32 nStartColOffset = 0, sal_Int32 nStartRowOffset = 0,
+ sal_Int32 nEndColOffset = 0, sal_Int32 nEndRowOffset = 0 )
+	{
+		// #FIXME need proper (WorkSheet) parent
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, 
+			xRange->getCellRangeByPosition(
+				xCellRangeAddressable->getRangeAddress().StartColumn + nStartColOffset,
+				xCellRangeAddressable->getRangeAddress().StartRow + nStartRowOffset,
+				xCellRangeAddressable->getRangeAddress().EndColumn + nEndColOffset,
+				xCellRangeAddressable->getRangeAddress().EndRow + nEndRowOffset ) ) );
+	}
+	
+};
+
+bool
+getCellRangesForAddress( USHORT& rResFlags, const rtl::OUString& sAddress, ScDocShell* pDocSh, ScRangeList& rCellRanges, formula::FormulaGrammar::AddressConvention& eConv )
+{
+	
+	ScDocument* pDoc = NULL;
+	if ( pDocSh )
+	{
+		pDoc = pDocSh->GetDocument();
+		String aString(sAddress);
+		USHORT nMask = SCA_VALID;
+		//USHORT nParse = rCellRanges.Parse( sAddress, pDoc, nMask, formula::FormulaGrammar::CONV_XL_A1 );
+		rResFlags = rCellRanges.Parse( sAddress, pDoc, nMask, eConv, 0 );
+		if ( rResFlags & SCA_VALID )
+		{
+			return true;
+		}
+	} 
+	return false;
+} 
+
+bool getScRangeListForAddress( const rtl::OUString& sName, ScDocShell* pDocSh, ScRange& refRange, ScRangeList& aCellRanges, formula::FormulaGrammar::AddressConvention aConv = formula::FormulaGrammar::CONV_XL_A1 ) throw ( uno::RuntimeException )
+{
+	// see if there is a match with a named range
+	uno::Reference< beans::XPropertySet > xProps( pDocSh->GetModel(), uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NamedRanges") ) ), uno::UNO_QUERY_THROW );
+	// Strangly enough you can have Range( "namedRange1, namedRange2, etc," )	
+	// loop around each ',' seperated name
+	std::vector< rtl::OUString > vNames;
+	sal_Int32 nIndex = 0;
+	do 
+	{
+		rtl::OUString aToken = sName.getToken( 0, ',', nIndex );
+		vNames.push_back( aToken );
+	} while ( nIndex >= 0 );
+
+	if ( !vNames.size() )
+		vNames.push_back( sName );
+
+	std::vector< rtl::OUString >::iterator it = vNames.begin(); 
+	std::vector< rtl::OUString >::iterator it_end = vNames.end(); 
+	for ( ; it != it_end; ++it )
+	{
+		
+		formula::FormulaGrammar::AddressConvention eConv = aConv; 
+		// spaces are illegal ( but the user of course can enter them )
+		rtl::OUString sAddress = (*it).trim();
+		if ( xNameAccess->hasByName( sAddress ) )
+		{
+			uno::Reference< sheet::XNamedRange > xNamed( xNameAccess->getByName( sAddress ), uno::UNO_QUERY_THROW );
+			sAddress = xNamed->getContent();
+			// As the address comes from OOO, the addressing
+			// style is may not be XL_A1
+			eConv = pDocSh->GetDocument()->GetAddressConvention();
+		}	
+
+		USHORT nFlags = 0;
+		if ( !getCellRangesForAddress( nFlags, sAddress, pDocSh, aCellRanges, eConv ) )
+			return false;
+	
+		bool bTabFromReferrer = !( nFlags & SCA_TAB_3D );
+
+		for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+		{
+			pRange->aStart.SetCol( refRange.aStart.Col() + pRange->aStart.Col() );
+			pRange->aStart.SetRow( refRange.aStart.Row() + pRange->aStart.Row() );
+			pRange->aStart.SetTab( bTabFromReferrer ? refRange.aStart.Tab()  : pRange->aStart.Tab() );
+			pRange->aEnd.SetCol( refRange.aStart.Col() + pRange->aEnd.Col() );
+			pRange->aEnd.SetRow( refRange.aStart.Row() + pRange->aEnd.Row() );
+			pRange->aEnd.SetTab( bTabFromReferrer ? refRange.aEnd.Tab()  : pRange->aEnd.Tab() );
+		}
+	}
+	return true;
+}
+
+
+ScVbaRange*
+getRangeForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sName, ScDocShell* pDocSh, table::CellRangeAddress& pAddr, formula::FormulaGrammar::AddressConvention eConv = formula::FormulaGrammar::CONV_XL_A1 ) throw ( uno::RuntimeException )
+{
+	ScRangeList aCellRanges;
+	ScRange refRange;
+	ScUnoConversion::FillScRange( refRange, pAddr );
+	if ( !getScRangeListForAddress ( sName, pDocSh, refRange, aCellRanges, eConv ) ) 
+		throw uno::RuntimeException();
+	// Single range
+	if ( aCellRanges.First() == aCellRanges.Last() )
+	{
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pDocSh, *aCellRanges.First() ) );
+		// #FIXME need proper (WorkSheet) parent
+		return new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xRange );
+	}
+	uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pDocSh, aCellRanges ) );
+ 	
+	// #FIXME need proper (WorkSheet) parent
+	return new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xRanges );
+}
+
+css::uno::Reference< excel::XRange >
+ScVbaRange::getRangeObjectForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sRangeName, ScDocShell* pDocSh, formula::FormulaGrammar::AddressConvention eConv ) throw ( uno::RuntimeException )
+{
+	table::CellRangeAddress refAddr;
+	return getRangeForName( xContext, sRangeName, pDocSh, refAddr, eConv );
+}
+
+
+table::CellRangeAddress getCellRangeAddressForVBARange( const uno::Any& aParam, ScDocShell* pDocSh,  formula::FormulaGrammar::AddressConvention aConv = formula::FormulaGrammar::CONV_XL_A1) throw ( uno::RuntimeException )
+{
+	uno::Reference< table::XCellRange > xRangeParam;
+	switch ( aParam.getValueTypeClass() )
+	{
+		case uno::TypeClass_STRING:
+		{
+			rtl::OUString rString;
+			aParam >>= rString;
+			ScRangeList aCellRanges;
+			ScRange refRange;
+			if ( getScRangeListForAddress ( rString, pDocSh, refRange, aCellRanges, aConv ) ) 			
+			{
+				if ( aCellRanges.First() == aCellRanges.Last() )
+				{
+					table::CellRangeAddress aRangeAddress;
+					ScUnoConversion::FillApiRange( aRangeAddress, *aCellRanges.First() );
+					return aRangeAddress;
+				}
+			}
+		}
+		case uno::TypeClass_INTERFACE:
+		{
+			uno::Reference< excel::XRange > xRange;
+			aParam >>= xRange;
+			if ( xRange.is() )
+				xRange->getCellRange() >>= xRangeParam;
+			break;
+		}
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't extact CellRangeAddress from type" ) ), uno::Reference< uno::XInterface >() );
+	}
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRangeParam, uno::UNO_QUERY_THROW );
+	return xAddressable->getRangeAddress();
+
+}
+
+uno::Reference< XCollection >
+lcl_setupBorders( const uno::Reference< excel::XRange >& xParentRange, const uno::Reference<uno::XComponentContext>& xContext,  const uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
+{
+	uno::Reference< XHelperInterface > xParent( xParentRange, uno::UNO_QUERY_THROW ); 
+	ScDocument* pDoc = getDocumentFromRange(xRange);
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
+ 	uno::Reference< XCollection > borders( new ScVbaBorders( xParent, xContext, xRange, aPalette ) );
+	return borders;
+}
+
+ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
+    uno::Reference< uno::XComponentContext> const & xContext )  throw ( lang::IllegalArgumentException ) : ScVbaRange_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext, getXSomethingFromArgs< beans::XPropertySet >( args, 1, false ), getModelFromXIf( getXSomethingFromArgs< uno::XInterface >( args, 1 ) ), true ), mbIsRows( sal_False ), mbIsColumns( sal_False )
+{
+	mxRange.set( mxPropertySet, uno::UNO_QUERY );
+	mxRanges.set( mxPropertySet, uno::UNO_QUERY );
+	uno::Reference< container::XIndexAccess >  xIndex;
+	if ( mxRange.is() )
+	{
+		xIndex = new SingleRangeIndexAccess( mxContext, mxRange );
+	}
+	else if ( mxRanges.is() )
+	{
+		xIndex.set( mxRanges, uno::UNO_QUERY_THROW );
+	}
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex, mbIsRows, mbIsColumns );
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRange, uno::UNO_QUERY_THROW ), getModelFromRange( xRange), true ), mxRange( xRange ),
+                mbIsRows( bIsRows ),
+                mbIsColumns( bIsColumns )
+{
+	if  ( !xContext.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "context is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+	if  ( !xRange.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "range is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, xRange ) );
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex, mbIsRows, mbIsColumns );
+
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext, uno::Reference< beans::XPropertySet >( xRanges, uno::UNO_QUERY_THROW ), getModelFromXIf( uno::Reference< uno::XInterface >( xRanges, uno::UNO_QUERY_THROW ) ), true ), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
+
+{
+	uno::Reference< container::XIndexAccess >  xIndex( mxRanges, uno::UNO_QUERY_THROW );
+	m_Areas	 = new ScVbaRangeAreas( mxContext, xIndex, mbIsRows, mbIsColumns );
+
+}
+
+ScVbaRange::~ScVbaRange()
+{
+}
+
+uno::Reference< XCollection >& ScVbaRange::getBorders()
+{
+	if ( !m_Borders.is() )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		m_Borders = lcl_setupBorders( this, mxContext, uno::Reference< table::XCellRange >( xRange->getCellRange(), uno::UNO_QUERY_THROW ) );
+	}
+	return m_Borders;
+}
+
+void
+ScVbaRange::visitArray( ArrayVisitor& visitor )
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	sal_Int32 nRowCount = xColumnRowRange->getRows()->getCount();
+	sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+	for ( sal_Int32 i=0; i<nRowCount; ++i )
+	{
+		for ( sal_Int32 j=0; j<nColCount; ++j )
+		{
+			uno::Reference< table::XCell > xCell( mxRange->getCellByPosition( j, i ), uno::UNO_QUERY_THROW );
+
+			visitor.visitNode( i, j, xCell );
+		}
+	}
+}
+
+
+
+uno::Any 
+ScVbaRange::getValue( ValueGetter& valueGetter) throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	// single cell range
+	if ( isSingleCellRange() )
+	{
+		visitArray( valueGetter );
+		return valueGetter.getValue();
+	}
+	sal_Int32 nRowCount = xColumnRowRange->getRows()->getCount();
+	sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+	// multi cell range ( return array )
+	Dim2ArrayValueGetter arrayGetter( nRowCount, nColCount, valueGetter );
+	visitArray( arrayGetter );
+	return uno::makeAny( script::ArrayWrapper( sal_False, arrayGetter.getValue() ) );
+}
+
+uno::Any SAL_CALL
+ScVbaRange::getValue() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getValue();
+	}
+
+	CellValueGetter valueGetter;
+	return getValue( valueGetter );
+
+}
+
+
+void 
+ScVbaRange::setValue(  const uno::Any  &aValue,  ValueSetter& valueSetter ) throw (uno::RuntimeException)
+{
+	uno::TypeClass aClass = aValue.getValueTypeClass();
+	if ( aClass == uno::TypeClass_SEQUENCE )
+	{
+		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+		uno::Any aConverted;
+		try
+		{
+			// test for single dimension, could do 
+			// with a better test than this	
+			if ( aValue.getValueTypeName().indexOf('[') ==  aValue.getValueTypeName().lastIndexOf('[') )
+			{
+				aConverted = xConverter->convertTo( aValue, getCppuType((uno::Sequence< uno::Any >*)0) );
+				Dim1ArrayValueSetter setter( aConverted, valueSetter );
+				visitArray( setter );
+			}
+			else
+			{
+				aConverted = xConverter->convertTo( aValue, getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0) );
+				Dim2ArrayValueSetter setter( aConverted, valueSetter );
+				visitArray( setter );
+			}
+		}
+		catch ( uno::Exception& e )
+		{
+			OSL_TRACE("Bahhh, caught exception %s", 
+				rtl::OUStringToOString( e.Message,
+					RTL_TEXTENCODING_UTF8 ).getStr() );
+		}
+	}
+	else
+	{
+		visitArray( valueSetter );
+	}
+}
+
+void SAL_CALL
+ScVbaRange::setValue( const uno::Any  &aValue ) throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setValue over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeValueProcessor valueProcessor( aValue );	
+		aVisitor.visit( valueProcessor );
+		return;
+	}	
+	CellValueSetter valueSetter( aValue );
+	setValue( aValue, valueSetter );
+}
+
+void
+ScVbaRange::Clear() throw (uno::RuntimeException)
+{
+	sal_Int32 nFlags = sheet::CellFlags::VALUE | sheet::CellFlags::STRING | sheet::CellFlags::HARDATTR | sheet::CellFlags::FORMATTED | sheet::CellFlags::EDITATTR | sheet::CellFlags::FORMULA;
+	ClearContents( nFlags );
+}
+
+//helper ClearContent
+void
+ScVbaRange::ClearContents( sal_Int32 nFlags ) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+			if ( pRange )
+				pRange->ClearContents( nFlags );	
+		}
+		return;
+	}
+
+
+	uno::Reference< sheet::XSheetOperation > xSheetOperation(mxRange, uno::UNO_QUERY_THROW);
+	xSheetOperation->clearContents( nFlags );
+}
+void
+ScVbaRange::ClearComments() throw (uno::RuntimeException)
+{
+	ClearContents( sheet::CellFlags::ANNOTATION );
+}
+
+void
+ScVbaRange::ClearContents() throw (uno::RuntimeException)
+{
+	sal_Int32 nClearFlags = ( sheet::CellFlags::VALUE |
+		sheet::CellFlags::STRING |  sheet::CellFlags::DATETIME | 
+		sheet::CellFlags::FORMULA );
+	ClearContents( nClearFlags );
+}
+
+void
+ScVbaRange::ClearFormats() throw (uno::RuntimeException)
+{
+	//FIXME: need to check if we need to combine sheet::CellFlags::FORMATTED
+	sal_Int32 nClearFlags = sheet::CellFlags::HARDATTR | sheet::CellFlags::FORMATTED | sheet::CellFlags::EDITATTR;
+	ClearContents( nClearFlags );
+}
+
+void
+ScVbaRange::setFormulaValue( const uno::Any& rFormula, formula::FormulaGrammar::Grammar eGram ) throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setFormula over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeFormulaProcessor valueProcessor( rFormula );	
+		aVisitor.visit( valueProcessor );
+		return;
+	}	
+	CellFormulaValueSetter formulaValueSetter( rFormula, getScDocument(), eGram );
+	setValue( rFormula, formulaValueSetter );
+}
+
+uno::Any 
+ScVbaRange::getFormulaValue( formula::FormulaGrammar::Grammar eGram ) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getFormula();
+	}
+	CellFormulaValueGetter valueGetter( getScDocument(), eGram );
+	return getValue( valueGetter );
+		
+}
+
+void
+ScVbaRange::setFormula(const uno::Any &rFormula ) throw (uno::RuntimeException)
+{
+	// #FIXME converting "=$a$1" e.g. CONV_XL_A1 -> CONV_OOO                        	// results in "=$a$1:a1", temporalily disable conversion
+	setFormulaValue( rFormula,formula::FormulaGrammar::GRAM_PODF_XL_A1 );;
+}
+
+uno::Any
+ScVbaRange::getFormulaR1C1() throw (::com::sun::star::uno::RuntimeException)
+{
+	return getFormulaValue( formula::FormulaGrammar::GRAM_PODF_XL_R1C1 );
+}
+
+void
+ScVbaRange::setFormulaR1C1(const uno::Any& rFormula ) throw (uno::RuntimeException)
+{
+	setFormulaValue( rFormula,formula::FormulaGrammar::GRAM_PODF_XL_R1C1 );
+}
+
+uno::Any
+ScVbaRange::getFormula() throw (::com::sun::star::uno::RuntimeException)
+{
+	return getFormulaValue( formula::FormulaGrammar::GRAM_PODF_XL_A1 );
+}
+
+sal_Int32 
+ScVbaRange::getCount() throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setValue over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeCountProcessor valueProcessor;
+		aVisitor.visit( valueProcessor );
+		return valueProcessor.value();
+	}	
+	sal_Int32 rowCount = 0;
+	sal_Int32 colCount = 0;
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	rowCount = xColumnRowRange->getRows()->getCount();
+	colCount = xColumnRowRange->getColumns()->getCount();
+
+	if( IsRows() )
+		return rowCount;	
+	if( IsColumns() )
+		return colCount;
+	return rowCount * colCount;
+}
+
+sal_Int32 
+ScVbaRange::getRow() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getRow();
+	}
+	uno::Reference< sheet::XCellAddressable > xCellAddressable(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	return xCellAddressable->getCellAddress().Row + 1; // Zero value indexing 
+}	
+		
+sal_Int32 
+ScVbaRange::getColumn() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getColumn();
+	}
+	uno::Reference< sheet::XCellAddressable > xCellAddressable(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	return xCellAddressable->getCellAddress().Column + 1; // Zero value indexing
+}
+
+uno::Any
+ScVbaRange::HasFormula() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult = aNULL();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			// if the HasFormula for any area is different to another
+			// return null
+			if ( index > 1 )
+				if ( aResult != xRange->HasFormula() )
+					return aNULL();
+			aResult = xRange->HasFormula();	
+			if ( aNULL() == aResult ) 
+				return aNULL();
+		}
+		return aResult;
+	}
+	uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
+	ScCellRangesBase* pThisRanges = dynamic_cast< ScCellRangesBase * > ( xIf.get() );
+	if ( pThisRanges )
+	{
+		uno::Reference<uno::XInterface>  xRanges( pThisRanges->queryFormulaCells( ( sheet::FormulaResult::ERROR | sheet::FormulaResult::VALUE |  sheet::FormulaResult::STRING ) ), uno::UNO_QUERY_THROW );
+		ScCellRangesBase* pFormulaRanges = dynamic_cast< ScCellRangesBase * > ( xRanges.get() );
+		// check if there are no formula cell, return false
+		if ( pFormulaRanges->GetRangeList().Count() == 0 ) 
+			return uno::makeAny(sal_False);
+		
+		// chech if there are holes (where some cells are not formulas)
+		// or returned range is not equal to this range	 
+		if ( ( pFormulaRanges->GetRangeList().Count() > 1 ) 
+		|| ( pFormulaRanges->GetRangeList().GetObject(0)->aStart != pThisRanges->GetRangeList().GetObject(0)->aStart ) 
+		|| ( pFormulaRanges->GetRangeList().GetObject(0)->aEnd != pThisRanges->GetRangeList().GetObject(0)->aEnd ) )
+			return aNULL(); // should return aNULL;
+	}
+	return uno::makeAny( sal_True );
+}
+void
+ScVbaRange::fillSeries( sheet::FillDirection nFillDirection, sheet::FillMode nFillMode, sheet::FillDateMode nFillDateMode, double fStep, double fEndValue ) throw( uno::RuntimeException )
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		// Multi-Area Range
+		uno::Reference< XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
+		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+			ScVbaRange* pThisRange = dynamic_cast< ScVbaRange* >( xRange.get() );
+			pThisRange->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
+				
+		}
+		return;	
+	}
+	
+	uno::Reference< sheet::XCellSeries > xCellSeries(mxRange, uno::UNO_QUERY_THROW );
+	xCellSeries->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
+}
+
+void 
+ScVbaRange::FillLeft() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_LEFT, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillRight() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_RIGHT, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillUp() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_TOP, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillDown() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_BOTTOM, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+::rtl::OUString
+ScVbaRange::getText() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getText();
+	}
+	uno::Reference< text::XTextRange > xTextRange(mxRange->getCellByPosition(0,0), uno::UNO_QUERY_THROW );
+	return xTextRange->getString();
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Offset( const ::uno::Any &nRowOff, const uno::Any &nColOff ) throw (uno::RuntimeException)
+{
+	SCROW nRowOffset = 0;
+	SCCOL nColOffset = 0;
+	sal_Bool bIsRowOffset = ( nRowOff >>= nRowOffset );
+	sal_Bool bIsColumnOffset = ( nColOff >>= nColOffset );
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+
+	ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+	
+
+	for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+	{
+		if ( bIsColumnOffset )
+		{
+			pRange->aStart.SetCol( pRange->aStart.Col() + nColOffset );
+			pRange->aEnd.SetCol( pRange->aEnd.Col() + nColOffset );
+		}
+		if ( bIsRowOffset )
+		{
+			pRange->aStart.SetRow( pRange->aStart.Row() + nRowOffset );
+			pRange->aEnd.SetRow( pRange->aEnd.Row() + nRowOffset );
+		}
+	}
+
+	if ( aCellRanges.Count() > 1 ) // Multi-Area
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
+		return new ScVbaRange( getParent(), mxContext, xRanges );
+	}
+	// normal range
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
+	return new ScVbaRange( getParent(), mxContext, xRange  );
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::CurrentRegion() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->CurrentRegion();
+	}
+	
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = 
+		helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentRegion();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::CurrentArray() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->CurrentArray();
+	}
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = 
+		helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentArray();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+}
+
+uno::Any
+ScVbaRange::getFormulaArray() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getFormulaArray();
+	}
+	
+	uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+	uno::Any aMatrix;
+
+	//VBA, minz@cn.ibm.com
+	uno::Sequence< uno::Sequence<rtl::OUString> > aFmArray = xCellRangeFormula->getFormulaArray();
+	if( aFmArray.getLength() )
+	{
+		if( aFmArray.getLength() == 1 && aFmArray[0].getLength() == 1 )
+			aMatrix <<= aFmArray[0][0];
+		else	
+			aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+	}	
+	return aMatrix;
+}
+
+void 
+ScVbaRange::setFormulaArray(const uno::Any& rFormula) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->setFormulaArray( rFormula );
+	}
+	// #TODO need to distinguish between getFormula and getFormulaArray e.g. (R1C1)
+	// but for the moment its just easier to treat them the same for setting
+
+	setFormula( rFormula );
+}
+
+::rtl::OUString
+ScVbaRange::Characters(const uno::Any& Start, const uno::Any& Length) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Characters( Start, Length );
+	}
+
+	long nIndex = 0, nCount = 0;
+	::rtl::OUString rString;
+	uno::Reference< text::XTextRange > xTextRange(mxRange, ::uno::UNO_QUERY_THROW );
+	rString = xTextRange->getString();
+	if( !( Start >>= nIndex ) && !( Length >>= nCount ) )
+		return rString;
+	if(!( Start >>= nIndex ) )
+		nIndex = 1;
+	if(!( Length >>= nCount ) )
+		nIndex = rString.getLength();
+	return rString.copy( --nIndex, nCount ); // Zero value indexing
+}
+
+::rtl::OUString
+ScVbaRange::Address(  const uno::Any& RowAbsolute, const uno::Any& ColumnAbsolute, const uno::Any& ReferenceStyle, const uno::Any& External, const uno::Any& RelativeTo ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		// Multi-Area Range
+		rtl::OUString sAddress;
+		uno::Reference< XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
+                uno::Any aExternalCopy = External;
+		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+			if ( index > 1 )
+			{
+				sAddress += rtl::OUString( ',' );
+                                // force external to be false
+                                // only first address should have the
+                                // document and sheet specifications
+                                aExternalCopy = uno::makeAny(sal_False);
+			}
+			sAddress += xRange->Address( RowAbsolute, ColumnAbsolute, ReferenceStyle, aExternalCopy, RelativeTo );
+		}
+		return sAddress;	
+		
+	}
+	ScAddress::Details dDetails( formula::FormulaGrammar::CONV_XL_A1, 0, 0 );
+	if ( ReferenceStyle.hasValue() )
+	{
+		sal_Int32 refStyle = excel::XlReferenceStyle::xlA1;
+		ReferenceStyle >>= refStyle;
+		if ( refStyle == excel::XlReferenceStyle::xlR1C1 )
+			dDetails = ScAddress::Details( formula::FormulaGrammar::CONV_XL_R1C1, 0, 0 );
+	}
+	USHORT nFlags = SCA_VALID;
+	ScDocShell* pDocShell =  getScDocShell();
+	ScDocument* pDoc =  pDocShell->GetDocument();
+
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
+	String sRange;
+	USHORT ROW_ABSOLUTE = ( SCA_ROW_ABSOLUTE | SCA_ROW2_ABSOLUTE );
+	USHORT COL_ABSOLUTE = ( SCA_COL_ABSOLUTE | SCA_COL2_ABSOLUTE );
+	// default
+	nFlags |= ( SCA_TAB_ABSOLUTE | SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE | SCA_TAB2_ABSOLUTE | SCA_COL2_ABSOLUTE | SCA_ROW2_ABSOLUTE );
+	if ( RowAbsolute.hasValue() )
+	{
+		sal_Bool bVal = sal_True;
+		RowAbsolute >>= bVal;
+		if ( !bVal )
+			nFlags &= ~ROW_ABSOLUTE;
+	}
+	if ( ColumnAbsolute.hasValue() )
+	{
+		sal_Bool bVal = sal_True;
+		ColumnAbsolute >>= bVal;
+		if ( !bVal )
+			nFlags &= ~COL_ABSOLUTE;
+	}
+	sal_Bool bLocal = sal_False;
+	if ( External.hasValue() )
+	{
+		External >>= bLocal;
+		if (  bLocal )
+			nFlags |= SCA_TAB_3D | SCA_FORCE_DOC;
+	}
+	if ( RelativeTo.hasValue() )
+	{
+		// #TODO should I throw an error if R1C1 is not set?
+		
+		table::CellRangeAddress refAddress = getCellRangeAddressForVBARange( RelativeTo, pDocShell );
+		dDetails = ScAddress::Details( formula::FormulaGrammar::CONV_XL_R1C1, static_cast< SCROW >( refAddress.StartRow ), static_cast< SCCOL >( refAddress.StartColumn ) );
+	}
+	aRange.Format( sRange,  nFlags, pDoc, dDetails ); 
+	return sRange;
+}
+
+uno::Reference < excel::XFont >
+ScVbaRange::Font() throw ( script::BasicErrorException, uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY );
+	ScDocument* pDoc = getScDocument();
+	if ( mxRange.is() )
+		xProps.set(mxRange, ::uno::UNO_QUERY );
+	else if ( mxRanges.is() )
+		xProps.set(mxRanges, ::uno::UNO_QUERY );
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );	
+	ScCellRangeObj* pRangeObj = NULL;
+	try
+	{
+		pRangeObj = getCellRangeObj();
+	}
+	catch( uno::Exception& ) 
+	{
+	}
+	return  new ScVbaFont( this, mxContext, aPalette, xProps, pRangeObj );
+}
+                                                                                                                             
+uno::Reference< excel::XRange >
+ScVbaRange::Cells( const uno::Any &nRowIndex, const uno::Any &nColumnIndex ) throw(uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Cells( nRowIndex, nColumnIndex );
+	}
+
+	sal_Int32 nRow = 0, nColumn = 0;
+
+	sal_Bool bIsIndex = nRowIndex.hasValue();
+	sal_Bool bIsColumnIndex = nColumnIndex.hasValue();
+
+	// Sometimes we might get a float or a double or whatever
+	// set in the Any, we should convert as appropriate
+	// #FIXME - perhaps worth turning this into some sort of
+	// convertion routine e.g. bSuccess = getValueFromAny( nRow, nRowIndex, getCppuType((sal_Int32*)0) )
+	if ( nRowIndex.hasValue() && !( nRowIndex >>= nRow ) )
+	{
+		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+		uno::Any aConverted;
+		try
+		{
+			aConverted = xConverter->convertTo( nRowIndex, getCppuType((sal_Int32*)0) );
+			bIsIndex = ( aConverted >>= nRow );
+		}
+		catch( uno::Exception& ) {} // silence any errors
+	}
+	if ( bIsColumnIndex && !( nColumnIndex >>= nColumn ) )
+	{
+		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
+		uno::Any aConverted;
+		try
+		{
+			aConverted = xConverter->convertTo( nColumnIndex, getCppuType((sal_Int32*)0) );
+			bIsColumnIndex = ( aConverted >>= nColumn );
+		}
+		catch( uno::Exception& ) {} // silence any errors
+	}
+                                                                                                                       
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisRangeAddress =  thisRange.getCellRangeAddressable()->getRangeAddress();
+	uno::Reference< table::XCellRange > xSheetRange = thisRange.getCellRangeFromSheet();
+	if( !bIsIndex && !bIsColumnIndex ) // .Cells
+		// #FIXE needs proper parent ( Worksheet )
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< XHelperInterface >(), mxContext, mxRange ) );
+
+	sal_Int32 nIndex = --nRow;
+	if( bIsIndex && !bIsColumnIndex ) // .Cells(n)
+	{
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, ::uno::UNO_QUERY_THROW);
+		sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+
+		if ( !nIndex || nIndex < 0 )
+			nRow = 0;
+		else
+			nRow = nIndex / nColCount;
+		nColumn = nIndex % nColCount;
+	}
+	else
+		--nColumn;
+	nRow = nRow + thisRangeAddress.StartRow;
+	nColumn =  nColumn + thisRangeAddress.StartColumn;	
+	return new ScVbaRange( getParent(), mxContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) );
+}
+
+void
+ScVbaRange::Select() throw (uno::RuntimeException)
+{
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+	if ( !pUnoRangesBase )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying uno range object" ) ), uno::Reference< uno::XInterface >()  );
+	ScDocShell* pShell = pUnoRangesBase->GetDocShell();
+	if ( pShell )
+	{
+		uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY_THROW );
+		uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+		if ( mxRanges.is() )
+			xSelection->select( uno::makeAny( mxRanges ) );
+		else
+			xSelection->select( uno::makeAny( mxRange ) );
+		// set focus on document e.g.
+		// ThisComponent.CurrentController.Frame.getContainerWindow.SetFocus
+		try
+		{
+			uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+			uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY_THROW );
+			uno::Reference< awt::XWindow > xWin( xFrame->getContainerWindow(), uno::UNO_QUERY_THROW );
+			xWin->setFocus();
+		}
+		catch( uno::Exception& )
+		{
+		}		
+
+	}
+}
+
+bool cellInRange( const table::CellRangeAddress& rAddr, const sal_Int32& nCol, const sal_Int32& nRow )
+{
+	if ( nCol >= rAddr.StartColumn && nCol <= rAddr.EndColumn &&
+		nRow >= rAddr.StartRow && nRow <= rAddr.EndRow )
+		return true;
+	return false;
+}
+
+void setCursor(  const SCCOL& nCol, const SCROW& nRow, const uno::Reference< frame::XModel >& xModel,  bool bInSel = true )
+{
+	ScTabViewShell* pShell = excel::getBestViewShell( xModel );
+	if ( pShell )
+	{
+		if ( bInSel )
+			pShell->SetCursor( nCol, nRow );
+		else
+			pShell->MoveCursorAbs( nCol, nRow, SC_FOLLOW_NONE, FALSE, FALSE, TRUE, FALSE );
+	}
+}
+
+void
+ScVbaRange::Activate() throw (uno::RuntimeException)
+{
+	// get first cell of current range
+	uno::Reference< table::XCellRange > xCellRange;
+	if ( mxRanges.is() )
+	{
+		uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW  );
+		xCellRange.set( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+	}
+	else
+		xCellRange.set( mxRange, uno::UNO_QUERY_THROW );
+
+	RangeHelper thisRange( xCellRange );
+	uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
+	table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
+        uno::Reference< frame::XModel > xModel;	
+        ScDocShell* pShell = getScDocShell();
+
+        if ( pShell )
+            xModel = pShell->GetModel();
+
+        if ( !xModel.is() )
+            throw uno::RuntimeException(); 
+
+	// get current selection
+	uno::Reference< sheet::XCellRangeAddressable > xRange( xModel->getCurrentSelection(), ::uno::UNO_QUERY);
+
+	uno::Reference< sheet::XSheetCellRanges > xRanges( xModel->getCurrentSelection(), ::uno::UNO_QUERY);
+
+	if ( xRanges.is() )
+	{
+		uno::Sequence< table::CellRangeAddress > nAddrs = xRanges->getRangeAddresses();
+		for ( sal_Int32 index = 0; index < nAddrs.getLength(); ++index )
+		{
+			if ( cellInRange( nAddrs[index], thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
+			{
+				setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel );
+				return;
+			}
+			
+		}
+	}	
+
+	if ( xRange.is() && cellInRange( xRange->getRangeAddress(), thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
+		setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel );
+	else
+	{
+		// if this range is multi cell select the range other
+		// wise just position the cell at this single range position
+		if ( isSingleCellRange() ) 
+			// This top-leftmost cell of this Range is not in the current
+			// selection so just select this range
+			setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel, false  );
+		else
+			Select();
+	}
+
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	SCROW nStartRow = 0;
+	SCROW nEndRow = 0;
+
+	sal_Int32 nValue = 0;
+	rtl::OUString sAddress;
+
+	if ( aIndex.hasValue() )
+	{
+		ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+		ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+
+		ScRange aRange = *aCellRanges.First();
+		if( aIndex >>= nValue )
+		{
+			aRange.aStart.SetRow( aRange.aStart.Row() + --nValue );
+			aRange.aEnd.SetRow( aRange.aStart.Row() );
+		}
+		
+		else if ( aIndex >>= sAddress ) 
+		{
+			ScAddress::Details dDetails( formula::FormulaGrammar::CONV_XL_A1, 0, 0 );
+			ScRange tmpRange;
+			tmpRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartRow = tmpRange.aStart.Row();
+			nEndRow = tmpRange.aEnd.Row();
+
+			aRange.aStart.SetRow( aRange.aStart.Row() + nStartRow );
+			aRange.aEnd.SetRow( aRange.aStart.Row() + ( nEndRow  - nStartRow ));
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
+		
+		if ( aRange.aStart.Row() < 0 || aRange.aEnd.Row() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+		// return a normal range ( even for multi-selection
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+		return new ScVbaRange( getParent(), mxContext, xRange, true  );
+	}
+	// Rows() - no params
+	if ( m_Areas->getCount() > 1 )
+		return new ScVbaRange(  getParent(), mxContext, mxRanges, true );
+	return new ScVbaRange(  getParent(), mxContext, mxRange, true );
+}	
+
+uno::Reference< excel::XRange >
+ScVbaRange::Columns(const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	SCCOL nStartCol = 0;
+	SCCOL nEndCol = 0;
+
+	sal_Int32 nValue = 0;
+	rtl::OUString sAddress;
+
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+	ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+
+	ScRange aRange = *aCellRanges.First();
+	if ( aIndex.hasValue() )
+	{
+		if ( aIndex >>= nValue )
+		{
+			aRange.aStart.SetCol( aRange.aStart.Col() + static_cast< SCCOL > ( --nValue ) );
+			aRange.aEnd.SetCol( aRange.aStart.Col() );
+		}
+		
+		else if ( aIndex >>= sAddress ) 
+		{
+			ScAddress::Details dDetails( formula::FormulaGrammar::CONV_XL_A1, 0, 0 );
+			ScRange tmpRange;
+			tmpRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartCol = tmpRange.aStart.Col();
+			nEndCol = tmpRange.aEnd.Col();
+
+			aRange.aStart.SetCol( aRange.aStart.Col() + nStartCol );
+			aRange.aEnd.SetCol( aRange.aStart.Col() + ( nEndCol  - nStartCol ));
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
+		
+		if ( aRange.aStart.Col() < 0 || aRange.aEnd.Col() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+	}
+	// Columns() - no params
+	//return new ScVbaRange(  getParent(), mxContext, mxRange, false, true );
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+	return new ScVbaRange( getParent(), mxContext, xRange, false, true  );
+}	
+
+void
+ScVbaRange::setMergeCells( const uno::Any& aIsMerged ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	sal_Bool bIsMerged = sal_False;
+	aIsMerged >>= bIsMerged;
+	uno::Reference< util::XMergeable > xMerge( mxRange, ::uno::UNO_QUERY_THROW );
+	//FIXME need to check whether all the cell contents are retained or lost by popping up a dialog 
+	xMerge->merge( bIsMerged );
+}
+                                                                                                                             
+uno::Any
+ScVbaRange::getMergeCells() throw (script::BasicErrorException, uno::RuntimeException)
+{
+	sal_Int32 nItems = m_Areas->getCount();
+	
+	if ( nItems > 1 )
+	{
+		uno::Any aResult = aNULL();	
+		for ( sal_Int32 index=1; index != nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			if ( index > 1 )
+				if ( aResult != xRange->getMergeCells() )
+					return aNULL();
+			aResult = xRange->getMergeCells();	
+			if ( aNULL() == aResult ) 
+				return aNULL();
+		}
+		return aResult;
+		
+	}
+	uno::Reference< util::XMergeable > xMerge( mxRange, ::uno::UNO_QUERY_THROW );
+	return uno::makeAny( xMerge->getIsMerged() );
+}
+                                                                                                                             
+void
+ScVbaRange::Copy(const ::uno::Any& Destination) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+	if ( Destination.hasValue() )
+	{
+		uno::Reference< excel::XRange > xRange( Destination, uno::UNO_QUERY_THROW );
+		uno::Any aRange = xRange->getCellRange();
+		uno::Reference< table::XCellRange > xCellRange;
+		aRange >>= xCellRange;
+		uno::Reference< sheet::XSheetCellRange > xSheetCellRange(xCellRange, ::uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XSpreadsheet > xSheet = xSheetCellRange->getSpreadsheet();
+		uno::Reference< table::XCellRange > xDest( xSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeMovement > xMover( xSheet, uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XCellAddressable > xDestination( xDest->getCellByPosition(
+												xRange->getColumn()-1,xRange->getRow()-1), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
+		xMover->copyRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
+	}
+	else
+	{
+		uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+		Select();
+		excel::implnCopy( xModel );
+	}
+}
+
+void
+ScVbaRange::Cut(const ::uno::Any& Destination) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+	if (Destination.hasValue())
+	{
+		uno::Reference< excel::XRange > xRange( Destination, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xCellRange( xRange->getCellRange(), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSheetCellRange > xSheetCellRange(xCellRange, ::uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSpreadsheet > xSheet = xSheetCellRange->getSpreadsheet();
+		uno::Reference< table::XCellRange > xDest( xSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeMovement > xMover( xSheet, uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XCellAddressable > xDestination( xDest->getCellByPosition(
+												xRange->getColumn()-1,xRange->getRow()-1), uno::UNO_QUERY);
+		uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
+		xMover->moveRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
+	}
+	//VBA, minz@cn.ibm.com.
+	else {
+		uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+		Select();
+		excel::implnCut( xModel );
+	}
+}
+                                                                                                                             
+void
+ScVbaRange::setNumberFormat( const uno::Any& aFormat ) throw ( script::BasicErrorException, uno::RuntimeException)
+{
+	rtl::OUString sFormat;
+	aFormat >>= sFormat;
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->setNumberFormat( aFormat );	
+		}
+		return;
+	}
+	NumFormatHelper numFormat( mxRange );
+	numFormat.setNumberFormat( sFormat );
+}
+                                                                                                                             
+uno::Any
+ScVbaRange::getNumberFormat() throw ( script::BasicErrorException, uno::RuntimeException)
+{
+
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult = aNULL();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			// if the numberformat of one area is different to another
+			// return null
+			if ( index > 1 )
+				if ( aResult != xRange->getNumberFormat() )
+					return aNULL();
+			aResult = xRange->getNumberFormat();	
+			if ( aNULL() == aResult ) 
+				return aNULL();
+		}
+		return aResult;
+	}
+	NumFormatHelper numFormat( mxRange );
+	rtl::OUString sFormat = numFormat.getNumberFormatString();
+	if ( sFormat.getLength() > 0 )
+		return uno::makeAny( sFormat );
+	return aNULL();
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Resize( const uno::Any &RowSize, const uno::Any &ColumnSize ) throw (uno::RuntimeException)
+{
+	long nRowSize = 0, nColumnSize = 0;
+	sal_Bool bIsRowChanged = ( RowSize >>= nRowSize ), bIsColumnChanged = ( ColumnSize >>= nColumnSize );
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, ::uno::UNO_QUERY_THROW);
+	uno::Reference< sheet::XSheetCellRange > xSheetRange(mxRange, ::uno::UNO_QUERY_THROW);
+	uno::Reference< sheet::XSheetCellCursor > xCursor( xSheetRange->getSpreadsheet()->createCursorByRange(xSheetRange), ::uno::UNO_QUERY_THROW );
+
+	if( !bIsRowChanged )
+		nRowSize = xColumnRowRange->getRows()->getCount();
+	if( !bIsColumnChanged )
+		nColumnSize = xColumnRowRange->getColumns()->getCount();
+
+	xCursor->collapseToSize( nColumnSize, nRowSize );
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xCursor, ::uno::UNO_QUERY_THROW );
+	uno::Reference< table::XCellRange > xRange( xSheetRange->getSpreadsheet(), ::uno::UNO_QUERY_THROW );
+	return new ScVbaRange( getParent(), mxContext,xRange->getCellRangeByPosition(
+										xCellRangeAddressable->getRangeAddress().StartColumn,
+										xCellRangeAddressable->getRangeAddress().StartRow,
+										xCellRangeAddressable->getRangeAddress().EndColumn,
+										xCellRangeAddressable->getRangeAddress().EndRow ) );
+}
+                                                                                                                             
+void
+ScVbaRange::setWrapText( const uno::Any& aIsWrapped ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult;
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->setWrapText( aIsWrapped );	
+		}
+		return;
+	}
+
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY_THROW );
+	xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsTextWrapped" ) ), aIsWrapped );
+}
+                                                                                                                             
+uno::Any
+ScVbaRange::getWrapText() throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult;
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+				if ( index > 1 )
+				if ( aResult != xRange->getWrapText() )
+					return aNULL();
+			aResult = xRange->getWrapText(); 
+		}
+		return aResult;
+	}
+
+	SfxItemSet* pDataSet = getCurrentDataSet();
+	
+	SfxItemState eState = pDataSet->GetItemState( ATTR_LINEBREAK, TRUE, NULL);
+	if ( eState == SFX_ITEM_DONTCARE )
+		return aNULL();
+	
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY_THROW );
+	uno::Any aValue = xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsTextWrapped" ) ) );
+	return aValue;
+}
+
+uno::Reference< excel::XInterior > ScVbaRange::Interior( ) throw ( script::BasicErrorException, uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
+        return new ScVbaInterior ( this, mxContext, xProps, getScDocument() );
+}                                                                                                                             
+uno::Reference< excel::XRange >
+ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2 ) throw (uno::RuntimeException)
+{
+    return Range( Cell1, Cell2, false );
+}
+uno::Reference< excel::XRange >
+ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2, bool bForceUseInpuRangeTab ) throw (uno::RuntimeException)
+
+{
+	uno::Reference< table::XCellRange > xCellRange = mxRange;
+
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
+		xCellRange.set( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+	}
+	else
+		xCellRange.set( mxRange );
+
+	RangeHelper thisRange( xCellRange );
+	uno::Reference< table::XCellRange > xRanges = thisRange.getCellRangeFromSheet();
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRanges, uno::UNO_QUERY_THROW );
+
+	uno::Reference< table::XCellRange > xReferrer = 
+		xRanges->getCellRangeByPosition( getColumn()-1, getRow()-1, 
+				xAddressable->getRangeAddress().EndColumn, 
+				xAddressable->getRangeAddress().EndRow );
+	// xAddressable now for this range	
+	xAddressable.set( xReferrer, uno::UNO_QUERY_THROW );
+
+	
+	if( !Cell1.hasValue() )
+		throw uno::RuntimeException(
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Invalid Argument " ) ),
+			uno::Reference< XInterface >() );
+
+	table::CellRangeAddress resultAddress;
+	table::CellRangeAddress parentRangeAddress = xAddressable->getRangeAddress();
+
+	ScRange aRange;
+	// Cell1 defined only
+	if ( !Cell2.hasValue() )
+	{
+		rtl::OUString sName;
+		Cell1 >>= sName;
+		RangeHelper referRange( xReferrer );		
+		table::CellRangeAddress referAddress = referRange.getCellRangeAddressable()->getRangeAddress();
+		return getRangeForName( mxContext, sName, getScDocShell(), referAddress );
+ 
+	}
+	else
+	{
+		table::CellRangeAddress  cell1, cell2;
+		cell1 = getCellRangeAddressForVBARange( Cell1, getScDocShell() ); 	
+		// Cell1 & Cell2 defined
+		// Excel seems to combine the range as the range defined by
+		// the combination of Cell1 & Cell2
+	
+		cell2 = getCellRangeAddressForVBARange( Cell2, getScDocShell() ); 	
+
+		resultAddress.StartColumn = ( cell1.StartColumn <  cell2.StartColumn ) ? cell1.StartColumn : cell2.StartColumn;
+		resultAddress.StartRow = ( cell1.StartRow <  cell2.StartRow ) ? cell1.StartRow : cell2.StartRow;
+		resultAddress.EndColumn = ( cell1.EndColumn >  cell2.EndColumn ) ? cell1.EndColumn : cell2.EndColumn;
+		resultAddress.EndRow = ( cell1.EndRow >  cell2.EndRow ) ? cell1.EndRow : cell2.EndRow;
+		if ( bForceUseInpuRangeTab )
+		{
+			// this is a call from Application.Range( x,y )
+			// its possiblefor x or y to specify a different sheet from
+			// the current or active on ( but they must be the same )
+			if ( cell1.Sheet != cell2.Sheet )
+				throw uno::RuntimeException();
+			parentRangeAddress.Sheet = cell1.Sheet;
+		}
+		else
+		{
+			// this is not a call from Application.Range( x,y )
+			// if a different sheet from this range is specified it's
+			// an error
+			if ( parentRangeAddress.Sheet != cell1.Sheet 
+			|| parentRangeAddress.Sheet != cell2.Sheet 
+			)
+				throw uno::RuntimeException();
+
+		}
+		ScUnoConversion::FillScRange( aRange, resultAddress );
+	}
+	ScRange parentAddress;
+	ScUnoConversion::FillScRange( parentAddress, parentRangeAddress);	
+	if ( aRange.aStart.Col() >= 0 && aRange.aStart.Row() >= 0 && aRange.aEnd.Col() >= 0 && aRange.aEnd.Row() >= 0 )
+	{
+		sal_Int32 nStartX = parentAddress.aStart.Col() + aRange.aStart.Col();
+		sal_Int32 nStartY = parentAddress.aStart.Row() + aRange.aStart.Row();
+		sal_Int32 nEndX = parentAddress.aStart.Col() + aRange.aEnd.Col();
+		sal_Int32 nEndY = parentAddress.aStart.Row() + aRange.aEnd.Row();
+
+		if ( nStartX <= nEndX && nEndX <= parentAddress.aEnd.Col() &&
+			 nStartY <= nEndY && nEndY <= parentAddress.aEnd.Row() )
+		{
+			ScRange aNew( (SCCOL)nStartX, (SCROW)nStartY, parentAddress.aStart.Tab(),
+						  (SCCOL)nEndX, (SCROW)nEndY, parentAddress.aEnd.Tab() );
+			xCellRange = new ScCellRangeObj( getScDocShell(), aNew );
+		}
+	}
+		
+	return new ScVbaRange( getParent(), mxContext, xCellRange );
+
+}
+
+// Allow access to underlying openoffice uno api ( useful for debugging
+// with openoffice basic ) 
+::com::sun::star::uno::Any SAL_CALL
+ScVbaRange::getCellRange(  ) throw (::com::sun::star::uno::RuntimeException)
+{
+	uno::Any aAny;
+	if ( mxRanges.is() )
+		aAny <<= mxRanges;
+	else if ( mxRange.is() )
+		aAny <<= mxRange;
+	return aAny;
+}
+
+static USHORT 
+getPasteFlags (sal_Int32 Paste)
+{
+	USHORT nFlags = IDF_NONE;	
+	switch (Paste) {
+        case excel::XlPasteType::xlPasteComments: 
+		nFlags = IDF_NOTE;break;
+        case excel::XlPasteType::xlPasteFormats: 
+		nFlags = IDF_ATTRIB;break;
+        case excel::XlPasteType::xlPasteFormulas: 
+		nFlags = IDF_FORMULA;break;
+        case excel::XlPasteType::xlPasteFormulasAndNumberFormats : 
+        case excel::XlPasteType::xlPasteValues: 
+#ifdef VBA_OOBUILD_HACK
+		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
+#else
+		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING ); break;
+#endif
+        case excel::XlPasteType::xlPasteValuesAndNumberFormats:
+		nFlags = IDF_VALUE | IDF_ATTRIB; break;
+        case excel::XlPasteType::xlPasteColumnWidths:
+        case excel::XlPasteType::xlPasteValidation: 
+		nFlags = IDF_NONE;break;
+	case excel::XlPasteType::xlPasteAll: 
+        case excel::XlPasteType::xlPasteAllExceptBorders: 
+	default:
+		nFlags = IDF_ALL;break;
+	};
+return nFlags;
+}
+
+static USHORT 
+getPasteFormulaBits( sal_Int32 Operation)
+{
+	USHORT nFormulaBits = PASTE_NOFUNC ;
+	switch (Operation)
+	{
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationAdd: 
+		nFormulaBits = PASTE_ADD;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationSubtract: 
+		nFormulaBits = PASTE_SUB;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationMultiply: 
+		nFormulaBits = PASTE_MUL;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationDivide:
+		nFormulaBits = PASTE_DIV;break;
+
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationNone: 
+	default:
+		nFormulaBits = PASTE_NOFUNC; break;
+	};
+	
+return nFormulaBits;
+}
+void SAL_CALL 
+ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, const uno::Any& SkipBlanks, const uno::Any& Transpose ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+        ScDocShell* pShell = getScDocShell(); 
+  
+        uno::Reference< frame::XModel > xModel( ( pShell ? pShell->GetModel() : NULL ), uno::UNO_QUERY_THROW );
+	uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	// save old selection
+	uno::Reference< uno::XInterface > xSel( xModel->getCurrentSelection() );
+	// select this range
+	xSelection->select( uno::makeAny( mxRange ) );
+	// set up defaults	
+	sal_Int32 nPaste = excel::XlPasteType::xlPasteAll;
+	sal_Int32 nOperation = excel::XlPasteSpecialOperation::xlPasteSpecialOperationNone;
+	sal_Bool bTranspose = sal_False;
+	sal_Bool bSkipBlanks = sal_False;
+
+	if ( Paste.hasValue() )
+		Paste >>= nPaste;
+	if ( Operation.hasValue() )
+		Operation >>= nOperation;
+	if ( SkipBlanks.hasValue() )
+		SkipBlanks >>= bSkipBlanks;
+	if ( Transpose.hasValue() )
+		Transpose >>= bTranspose;
+
+	USHORT nFlags = getPasteFlags(nPaste);
+	USHORT nFormulaBits = getPasteFormulaBits(nOperation);
+	excel::implnPasteSpecial(pShell->GetModel(), nFlags,nFormulaBits,bSkipBlanks,bTranspose);
+	// restore selection
+	xSelection->select( uno::makeAny( xSel ) );
+}
+
+uno::Reference< excel::XRange > 
+ScVbaRange::getEntireColumnOrRow( bool bColumn ) throw (uno::RuntimeException)
+{
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+	// copy the range list
+	ScRangeList aCellRanges = pUnoRangesBase->GetRangeList(); 
+
+	for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+	{
+		if ( bColumn ) 
+		{
+			pRange->aStart.SetRow( 0 );
+			pRange->aEnd.SetRow( MAXROW );
+		}	
+		else
+		{
+			pRange->aStart.SetCol( 0 );
+			pRange->aEnd.SetCol( MAXCOL );
+		}
+	}
+	if ( aCellRanges.Count() > 1 ) // Multi-Area
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
+		
+		return new ScVbaRange( getParent(), mxContext, xRanges, !bColumn, bColumn );
+	}
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
+	return new ScVbaRange( getParent(), mxContext, xRange, !bColumn, bColumn  );
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::getEntireRow() throw (uno::RuntimeException)
+{
+	return getEntireColumnOrRow(false);
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::getEntireColumn() throw (uno::RuntimeException)
+{
+	return getEntireColumnOrRow();
+}
+
+uno::Reference< excel::XComment > SAL_CALL 
+ScVbaRange::AddComment( const uno::Any& Text ) throw (uno::RuntimeException)
+{
+
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
+        // if there is existing text then error
+	if ( Text.hasValue() && xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+            throw uno::RuntimeException(); 
+        // failed to write text? ( can this happen ?? )
+	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength()  )
+		return NULL;	
+	return xComment;
+}
+
+uno::Reference< excel::XComment > SAL_CALL
+ScVbaRange::getComment() throw (uno::RuntimeException)
+{
+	// intentional behavior to return a null object if no
+	// comment defined
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
+	if ( !xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+		return NULL;
+	return xComment;
+	
+}
+
+uno::Reference< beans::XPropertySet >
+getRowOrColumnProps( const uno::Reference< table::XCellRange >& xCellRange, bool bRows ) throw ( uno::RuntimeException )
+{
+	uno::Reference< table::XColumnRowRange > xColRow( xCellRange, uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps;
+	if ( bRows )
+		xProps.set( xColRow->getRows(), uno::UNO_QUERY_THROW );
+	else
+		xProps.set( xColRow->getColumns(), uno::UNO_QUERY_THROW );
+	return xProps;	
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getHidden() throw (uno::RuntimeException)
+{
+	// if multi-area result is the result of the 
+	// first area
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xRange->getHidden();	
+	}
+	bool bIsVisible = false;
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps = getRowOrColumnProps( mxRange, mbIsRows );
+		if ( !( xProps->getPropertyValue( ISVISIBLE ) >>= bIsVisible ) )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to get IsVisible property")), uno::Reference< uno::XInterface >() );
+	}
+	catch( uno::Exception& e )
+	{
+		throw uno::RuntimeException( e.Message, uno::Reference< uno::XInterface >() );
+	}
+	return uno::makeAny( !bIsVisible ); 
+}
+
+void SAL_CALL 
+ScVbaRange::setHidden( const uno::Any& _hidden ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->setHidden( _hidden );	
+		}
+		return;
+	}
+
+	sal_Bool bHidden = sal_False;
+	_hidden >>= bHidden;
+
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps = getRowOrColumnProps( mxRange, mbIsRows );
+		xProps->setPropertyValue( ISVISIBLE, uno::makeAny( !bHidden ) );
+	}
+	catch( uno::Exception& e )
+	{
+		throw uno::RuntimeException( e.Message, uno::Reference< uno::XInterface >() );
+	}	
+}
+
+::sal_Bool SAL_CALL 
+ScVbaRange::Replace( const ::rtl::OUString& What, const ::rtl::OUString& Replacement, const uno::Any& LookAt, const uno::Any& SearchOrder, const uno::Any& MatchCase, const uno::Any& MatchByte, const uno::Any& SearchFormat, const uno::Any& ReplaceFormat  ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		for ( sal_Int32 index = 1; index <= m_Areas->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->Replace( What, Replacement,  LookAt, SearchOrder, MatchCase, MatchByte, SearchFormat, ReplaceFormat );
+		}
+		return sal_True; // seems to return true always ( or at least I haven't found the trick of 
+	}	
+
+	// sanity check required params
+	if ( !What.getLength() /*|| !Replacement.getLength()*/ )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, missing params" )) , uno::Reference< uno::XInterface >() );
+	rtl::OUString sWhat = VBAToRegexp( What);
+	// #TODO #FIXME SearchFormat & ReplacesFormat are not processed
+	// What do we do about MatchByte.. we don't seem to support that
+	const SvxSearchItem& globalSearchOptions = ScGlobal::GetSearchItem();
+	SvxSearchItem newOptions( globalSearchOptions );
+
+	sal_Int16 nLook =  globalSearchOptions.GetWordOnly() ?  excel::XlLookAt::xlPart : excel::XlLookAt::xlWhole; 
+	sal_Int16 nSearchOrder = globalSearchOptions.GetRowDirection() ? excel::XlSearchOrder::xlByRows : excel::XlSearchOrder::xlByColumns;
+
+	sal_Bool bMatchCase = sal_False;
+	uno::Reference< util::XReplaceable > xReplace( mxRange, uno::UNO_QUERY );
+	if ( xReplace.is() )
+	{
+		uno::Reference< util::XReplaceDescriptor > xDescriptor =
+			xReplace->createReplaceDescriptor();
+		
+		xDescriptor->setSearchString( sWhat); 		
+		xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHREGEXP ) ), uno::makeAny( sal_True ) ); 	
+		xDescriptor->setReplaceString( Replacement); 		
+		if ( LookAt.hasValue() )
+		{
+			// sets SearchWords ( true is Cell match )
+			nLook =  ::comphelper::getINT16( LookAt );
+			sal_Bool bSearchWords = sal_False;
+			if ( nLook == excel::XlLookAt::xlPart )
+				bSearchWords = sal_False;
+			else if ( nLook == excel::XlLookAt::xlWhole )
+				bSearchWords = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for LookAt" )) , uno::Reference< uno::XInterface >() );
+			// set global search props ( affects the find dialog
+			// and of course the defaults for this method
+			newOptions.SetWordOnly( bSearchWords );
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHWORDS ) ), uno::makeAny( bSearchWords ) ); 	
+		}
+		// sets SearchByRow ( true for Rows )
+		if ( SearchOrder.hasValue() )
+		{
+			nSearchOrder =  ::comphelper::getINT16( SearchOrder );
+			sal_Bool bSearchByRow = sal_False;
+			if ( nSearchOrder == excel::XlSearchOrder::xlByColumns )
+				bSearchByRow = sal_False;
+			else if ( nSearchOrder == excel::XlSearchOrder::xlByRows )
+				bSearchByRow = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for SearchOrder" )) , uno::Reference< uno::XInterface >() );
+			
+			newOptions.SetRowDirection( bSearchByRow ); 
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHBYROW ) ), uno::makeAny( bSearchByRow ) ); 	
+		}			
+		if ( MatchCase.hasValue() )
+		{
+			// SearchCaseSensitive
+			MatchCase >>= bMatchCase;	
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHCASE ) ), uno::makeAny( bMatchCase ) ); 	
+		}			
+
+		ScGlobal::SetSearchItem( newOptions );	
+		// ignore MatchByte for the moment, its not supported in
+		// OOo.org afaik
+
+		uno::Reference< util::XSearchDescriptor > xSearch( xDescriptor, uno::UNO_QUERY );
+		xReplace->replaceAll( xSearch );
+	}
+	return sal_True; // always
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::Find( const uno::Any& What, const uno::Any& After, const uno::Any& LookIn, const uno::Any& LookAt, const uno::Any& SearchOrder, const uno::Any& SearchDirection, const uno::Any& MatchCase, const uno::Any& /*MatchByte*/, const uno::Any& /*SearchFormat*/ ) throw (uno::RuntimeException)
+{
+    // return a Range object that represents the first cell where that information is found.
+    rtl::OUString sWhat;
+    sal_Int32 nWhat = 0;
+    float fWhat = 0.0;
+    
+    // string.
+    if( What >>= sWhat )
+    {
+        if( !sWhat.getLength() )
+		    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Find, missing params" )) , uno::Reference< uno::XInterface >() );
+    }
+    else if( What >>= nWhat )
+    {
+        sWhat = rtl::OUString::valueOf( nWhat );
+    }
+    else if( What >>= fWhat )
+    {
+        sWhat = rtl::OUString::valueOf( fWhat );
+    }
+    else
+	    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Find, missing params" )) , uno::Reference< uno::XInterface >() );
+
+    rtl::OUString sSearch = VBAToRegexp( sWhat );
+
+	const SvxSearchItem& globalSearchOptions = ScGlobal::GetSearchItem();
+	SvxSearchItem newOptions( globalSearchOptions );
+
+	sal_Int16 nLookAt =  globalSearchOptions.GetWordOnly() ?  excel::XlLookAt::xlPart : excel::XlLookAt::xlWhole; 
+	sal_Int16 nSearchOrder = globalSearchOptions.GetRowDirection() ? excel::XlSearchOrder::xlByRows : excel::XlSearchOrder::xlByColumns;
+
+	uno::Reference< util::XSearchable > xSearch( mxRange, uno::UNO_QUERY );
+    if( xSearch.is() )
+    {
+        uno::Reference< util::XSearchDescriptor > xDescriptor = xSearch->createSearchDescriptor();
+        xDescriptor->setSearchString( sSearch );
+
+        uno::Reference< excel::XRange > xAfterRange;
+        uno::Reference< table::XCellRange > xStartCell;
+        if( After >>= xAfterRange )
+        {
+            // After must be a single cell in the range
+            if( xAfterRange->getCount() > 1 )
+		        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("After must be a single cell." )) , uno::Reference< uno::XInterface >() );
+            uno::Reference< excel::XRange > xCell( Cells( uno::makeAny( xAfterRange->getRow() ), uno::makeAny( xAfterRange->getColumn() ) ), uno::UNO_QUERY );
+            if( !xCell.is() )
+		        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("After must be in range." )) , uno::Reference< uno::XInterface >() );
+            xStartCell.set( xAfterRange->getCellRange(), uno::UNO_QUERY_THROW );
+        }
+
+        // LookIn
+        if( LookIn.hasValue() )
+        {
+            sal_Int32 nLookIn = 0;
+            if( LookIn >>= nLookIn )
+            {
+                sal_Int16 nSearchType = 0; 
+                switch( nLookIn )
+                {
+                    case excel::XlFindLookIn::xlComments :
+                        nSearchType = SVX_SEARCHIN_NOTE; // Notes
+                    break;
+                    case excel::XlFindLookIn::xlFormulas :
+                        nSearchType = SVX_SEARCHIN_FORMULA;
+                    break;
+                    case excel::XlFindLookIn::xlValues :
+                        nSearchType = SVX_SEARCHIN_VALUE;
+                    break;
+                    default:
+		                throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for LookIn." )) , uno::Reference< uno::XInterface >() );
+                }
+                newOptions.SetCellType( nSearchType );
+                xDescriptor->setPropertyValue( rtl::OUString::createFromAscii( "SearchType" ), uno::makeAny( nSearchType ) );
+            }
+        }
+
+        // LookAt
+		if ( LookAt.hasValue() )
+		{
+			nLookAt =  ::comphelper::getINT16( LookAt );
+			sal_Bool bSearchWords = sal_False;
+			if ( nLookAt == excel::XlLookAt::xlPart )
+				bSearchWords = sal_False;
+			else if ( nLookAt == excel::XlLookAt::xlWhole )
+				bSearchWords = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for LookAt" )) , uno::Reference< uno::XInterface >() );
+			newOptions.SetWordOnly( bSearchWords );
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHWORDS ) ), uno::makeAny( bSearchWords ) ); 	
+        }
+
+        // SearchOrder
+		if ( SearchOrder.hasValue() )
+		{
+			nSearchOrder =  ::comphelper::getINT16( SearchOrder );
+			sal_Bool bSearchByRow = sal_False;
+			if ( nSearchOrder == excel::XlSearchOrder::xlByColumns )
+				bSearchByRow = sal_False;
+			else if ( nSearchOrder == excel::XlSearchOrder::xlByRows )
+				bSearchByRow = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for SearchOrder" )) , uno::Reference< uno::XInterface >() );
+			
+			newOptions.SetRowDirection( bSearchByRow ); 
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHBYROW ) ), uno::makeAny( bSearchByRow ) ); 	
+		}			
+
+        // SearchDirection
+        if ( SearchDirection.hasValue() )
+        {
+            sal_Int32 nSearchDirection = 0;
+            if( SearchDirection >>= nSearchDirection )
+            {
+                sal_Bool bSearchBackwards = sal_False;
+                if ( nSearchDirection == excel::XlSearchDirection::xlNext )
+                    bSearchBackwards = sal_False; 
+                else if( nSearchDirection == excel::XlSearchDirection::xlPrevious )
+                    bSearchBackwards = sal_True;
+                else
+				    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for SearchDirection" )) , uno::Reference< uno::XInterface >() );
+                newOptions.SetBackward( bSearchBackwards );
+                xDescriptor->setPropertyValue( rtl::OUString::createFromAscii( "SearchBackwards" ), uno::makeAny( bSearchBackwards ) );
+            }
+        }
+
+        // MatchCase
+        sal_Bool bMatchCase = sal_False;
+		if ( MatchCase.hasValue() )
+		{
+			// SearchCaseSensitive
+			if( !( MatchCase >>= bMatchCase ) )
+			    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for MatchCase" )) , uno::Reference< uno::XInterface >() );
+		}			
+        xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHCASE ) ), uno::makeAny( bMatchCase ) ); 	
+
+        // MatchByte
+        // SearchFormat
+        // ignore
+
+		ScGlobal::SetSearchItem( newOptions );	
+
+		uno::Reference< util::XSearchDescriptor > xSearchDescriptor( xDescriptor, uno::UNO_QUERY );
+		uno::Reference< uno::XInterface > xInterface = xStartCell.is() ? xSearch->findNext( xStartCell, xSearchDescriptor) : xSearch->findFirst( xSearchDescriptor );
+		uno::Reference< table::XCellRange > xCellRange( xInterface, uno::UNO_QUERY );
+        if ( xCellRange.is() )
+        {
+            uno::Reference< excel::XRange > xResultRange = new ScVbaRange( this, mxContext, xCellRange );
+            if( xResultRange.is() )
+            {
+                xResultRange->Select();
+                return xResultRange;
+            }
+        }
+
+    }
+
+    return uno::Reference< excel::XRange >();
+}
+
+uno::Reference< table::XCellRange > processKey( const uno::Any& Key, uno::Reference<  uno::XComponentContext >& xContext, ScDocShell* pDocSh )
+{
+	uno::Reference< excel::XRange > xKeyRange;
+	if ( Key.getValueType() == excel::XRange::static_type() )
+	{
+		xKeyRange.set( Key, uno::UNO_QUERY_THROW );
+	}
+	else if ( Key.getValueType() == ::getCppuType( static_cast< const rtl::OUString* >(0) )  )
+			
+	{
+		rtl::OUString sRangeName = ::comphelper::getString( Key );
+		table::CellRangeAddress  aRefAddr;
+		if ( !pDocSh )
+			throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort no docshell to calculate key param")), uno::Reference< uno::XInterface >() );
+		xKeyRange = getRangeForName( xContext, sRangeName, pDocSh, aRefAddr ); 
+	}
+	else
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort illegal type value for key param")), uno::Reference< uno::XInterface >() );
+	uno::Reference< table::XCellRange > xKey;
+	xKey.set( xKeyRange->getCellRange(), uno::UNO_QUERY_THROW );
+	return xKey;
+}
+
+// helper method for Sort
+sal_Int32 findSortPropertyIndex( const uno::Sequence< beans::PropertyValue >& props,
+const rtl::OUString& sPropName ) throw( uno::RuntimeException )
+{
+	const beans::PropertyValue* pProp = props.getConstArray();
+	sal_Int32 nItems = props.getLength();
+
+	 sal_Int32 count=0;
+	for ( ; count < nItems; ++count, ++pProp )
+		if ( pProp->Name.equals( sPropName ) )
+			return count;
+	if ( count == nItems )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort unknown sort property")), uno::Reference< uno::XInterface >() );
+	return -1; //should never reach here ( satisfy compiler )
+}
+
+// helper method for Sort
+void updateTableSortField( const uno::Reference< table::XCellRange >& xParentRange,
+	const uno::Reference< table::XCellRange >& xColRowKey, sal_Int16 nOrder, 
+	table::TableSortField& aTableField, sal_Bool bIsSortColumn, sal_Bool bMatchCase ) throw ( uno::RuntimeException )
+{
+		RangeHelper parentRange( xParentRange );	
+		RangeHelper colRowRange( xColRowKey );	
+
+		table::CellRangeAddress parentRangeAddress = parentRange.getCellRangeAddressable()->getRangeAddress();
+
+		table::CellRangeAddress colRowKeyAddress = colRowRange.getCellRangeAddressable()->getRangeAddress();
+
+		// make sure that upper left poing of key range is within the
+		// parent range
+		if (  ( !bIsSortColumn && colRowKeyAddress.StartColumn >= parentRangeAddress.StartColumn &&
+			colRowKeyAddress.StartColumn <= parentRangeAddress.EndColumn ) || ( bIsSortColumn && 
+			colRowKeyAddress.StartRow >= parentRangeAddress.StartRow &&
+			colRowKeyAddress.StartRow <= parentRangeAddress.EndRow  ) )
+		{
+			//determine col/row index
+			if ( bIsSortColumn )
+				aTableField.Field = colRowKeyAddress.StartRow - parentRangeAddress.StartRow;			 
+			else
+				aTableField.Field = colRowKeyAddress.StartColumn - parentRangeAddress.StartColumn;			 
+			aTableField.IsCaseSensitive = bMatchCase;
+
+			if ( nOrder ==  excel::XlSortOrder::xlAscending ) 
+				aTableField.IsAscending = sal_True; 
+			else	
+				aTableField.IsAscending = sal_False; 
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Illegal Key param" ) ), uno::Reference< uno::XInterface >() );
+
+						
+} 
+
+void SAL_CALL
+ScVbaRange::Sort( const uno::Any& Key1, const uno::Any& Order1, const uno::Any& Key2, const uno::Any& /*Type*/, const uno::Any& Order2, const uno::Any& Key3, const uno::Any& Order3, const uno::Any& Header, const uno::Any& OrderCustom, const uno::Any& MatchCase, const uno::Any& Orientation, const uno::Any& SortMethod,  const uno::Any& DataOption1, const uno::Any& DataOption2, const uno::Any& DataOption3  ) throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# can we do something with Type
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+
+	sal_Int16 nDataOption1 = excel::XlSortDataOption::xlSortNormal;
+	sal_Int16 nDataOption2 = excel::XlSortDataOption::xlSortNormal;;
+	sal_Int16 nDataOption3 = excel::XlSortDataOption::xlSortNormal;
+
+	ScDocument* pDoc = getScDocument();
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisRangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	ScSortParam aSortParam;
+	SCTAB nTab = thisRangeAddress.Sheet;
+	pDoc->GetSortParam( aSortParam, nTab );
+
+	if ( DataOption1.hasValue() )
+		DataOption1 >>= nDataOption1;
+	if ( DataOption2.hasValue() )
+		DataOption2 >>= nDataOption2;
+	if ( DataOption3.hasValue() )
+		DataOption3 >>= nDataOption3;
+
+	// 1) #TODO #FIXME need to process DataOption[1..3] not used currently
+	// 2) #TODO #FIXME need to refactor this ( below ) into a IsSingleCell() method
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+			
+	// 'Fraid I don't remember what I was trying to achieve here ???
+/* 
+	if (  isSingleCellRange() )
+	{
+		uno::Reference< XRange > xCurrent = CurrentRegion();
+		xCurrent->Sort( Key1, Order1, Key2, Type, Order2, Key3, Order3, Header, OrderCustom, MatchCase, Orientation, SortMethod, DataOption1, DataOption2, DataOption3 );
+		return; 
+	}
+*/
+	// set up defaults
+
+	sal_Int16 nOrder1 = aSortParam.bAscending[0] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+	sal_Int16 nOrder2 = aSortParam.bAscending[1] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+	sal_Int16 nOrder3 = aSortParam.bAscending[2] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+
+	sal_Int16 nCustom = aSortParam.nUserIndex;
+	sal_Int16 nSortMethod = excel::XlSortMethod::xlPinYin;
+	sal_Bool bMatchCase = aSortParam.bCaseSens;
+
+	// seems to work opposite to expected, see below
+	sal_Int16 nOrientation = aSortParam.bByRow ?  excel::XlSortOrientation::xlSortColumns :  excel::XlSortOrientation::xlSortRows;
+
+	if ( Orientation.hasValue() )
+	{
+		// Documentation says xlSortRows is default but that doesn't appear to be 
+		// the case. Also it appears that xlSortColumns is the default which 
+		// strangely enought sorts by Row
+		nOrientation = ::comphelper::getINT16( Orientation );
+		// persist new option to be next calls default
+		if ( nOrientation == excel::XlSortOrientation::xlSortRows )
+			aSortParam.bByRow = FALSE;
+		else
+			aSortParam.bByRow = TRUE;
+
+	}
+
+	sal_Bool bIsSortColumns=sal_False; // sort by row
+
+	if ( nOrientation == excel::XlSortOrientation::xlSortRows )
+		bIsSortColumns = sal_True;
+	sal_Int16 nHeader = 0;
+#ifdef VBA_OOBUILD_HACK
+	nHeader = aSortParam.nCompatHeader;
+#endif
+	sal_Bool bContainsHeader = sal_False;
+
+	if ( Header.hasValue() )
+	{
+		nHeader = ::comphelper::getINT16( Header );
+#ifdef VBA_OOBUILD_HACK
+		aSortParam.nCompatHeader = nHeader;
+#endif
+	}			
+
+	if ( nHeader == excel::XlYesNoGuess::xlGuess )
+	{
+		bool bHasColHeader = pDoc->HasColHeader(  static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), static_cast< SCCOL >( thisRangeAddress.EndColumn ), static_cast< SCROW >( thisRangeAddress.EndRow ), static_cast< SCTAB >( thisRangeAddress.Sheet ));
+		bool bHasRowHeader = pDoc->HasRowHeader(  static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), static_cast< SCCOL >( thisRangeAddress.EndColumn ), static_cast< SCROW >( thisRangeAddress.EndRow ), static_cast< SCTAB >( thisRangeAddress.Sheet ) );
+		if ( bHasColHeader || bHasRowHeader )
+			nHeader =  excel::XlYesNoGuess::xlYes; 
+		else
+			nHeader =  excel::XlYesNoGuess::xlNo; 
+#ifdef VBA_OOBUILD_HACK 
+		aSortParam.nCompatHeader = nHeader;
+#endif
+	}
+
+	if ( nHeader == excel::XlYesNoGuess::xlYes )
+		bContainsHeader = sal_True;
+
+	if ( SortMethod.hasValue() )
+	{
+		nSortMethod = ::comphelper::getINT16( SortMethod );
+	}
+	
+	if ( OrderCustom.hasValue() )
+	{
+		OrderCustom >>= nCustom;
+		--nCustom; // 0-based in OOo
+		aSortParam.nUserIndex = nCustom;
+	}
+
+	if ( MatchCase.hasValue() )
+	{
+		MatchCase >>= bMatchCase;
+		aSortParam.bCaseSens = bMatchCase;
+	}
+
+	if ( Order1.hasValue() )
+	{
+		nOrder1 = ::comphelper::getINT16(Order1);
+		if (  nOrder1 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[0]  = TRUE;
+		else
+			aSortParam.bAscending[0]  = FALSE;
+
+	}
+	if ( Order2.hasValue() )
+	{
+		nOrder2 = ::comphelper::getINT16(Order2);
+		if ( nOrder2 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[1]  = TRUE;
+		else
+			aSortParam.bAscending[1]  = FALSE;
+	}
+	if ( Order3.hasValue() )
+	{
+		nOrder3 = ::comphelper::getINT16(Order3);
+		if ( nOrder3 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[2]  = TRUE;
+		else
+			aSortParam.bAscending[2]  = FALSE;
+	}
+
+	uno::Reference< table::XCellRange > xKey1;	
+	uno::Reference< table::XCellRange > xKey2;	
+	uno::Reference< table::XCellRange > xKey3;	
+	ScDocShell* pDocShell = getScDocShell();
+	xKey1 = processKey( Key1, mxContext, pDocShell );
+	if ( !xKey1.is() )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort needs a key1 param")), uno::Reference< uno::XInterface >() );
+
+	if ( Key2.hasValue() )
+		xKey2 = processKey( Key2, mxContext, pDocShell );
+	if ( Key3.hasValue() )
+		xKey3 = processKey( Key3, mxContext, pDocShell );
+
+	uno::Reference< util::XSortable > xSort( mxRange, uno::UNO_QUERY_THROW );
+	uno::Sequence< beans::PropertyValue > sortDescriptor = xSort->createSortDescriptor();
+	sal_Int32 nTableSortFieldIndex = findSortPropertyIndex( sortDescriptor, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SortFields") ) );
+
+	uno::Sequence< table::TableSortField > sTableFields(1);
+	sal_Int32 nTableIndex = 0;
+	updateTableSortField(  mxRange, xKey1, nOrder1, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+
+	if ( xKey2.is() ) 
+	{
+		sTableFields.realloc( sTableFields.getLength() + 1 );
+		updateTableSortField(  mxRange, xKey2, nOrder2, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+	}
+	if ( xKey3.is()  ) 
+	{
+		sTableFields.realloc( sTableFields.getLength() + 1 );
+		updateTableSortField(  mxRange, xKey3, nOrder3, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+	}
+	sortDescriptor[ nTableSortFieldIndex ].Value <<= sTableFields;
+
+	sal_Int32 nIndex = 	findSortPropertyIndex( sortDescriptor,  rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("IsSortColumns")) );
+	sortDescriptor[ nIndex ].Value <<= bIsSortColumns;
+
+	nIndex = 	findSortPropertyIndex( sortDescriptor, CONTS_HEADER );
+	sortDescriptor[ nIndex ].Value <<= bContainsHeader;
+
+	pDoc->SetSortParam( aSortParam, nTab );
+	xSort->sort( sortDescriptor );
+
+	// #FIXME #TODO
+	// The SortMethod param is not processed ( not sure what its all about, need to
+
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::End( ::sal_Int32 Direction )  throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->End( Direction );
+	}
+
+	
+	// #FIXME #TODO
+	// euch! found my orig implementation sucked, so 
+	// trying this even suckier one ( really need to use/expose code in
+	// around  ScTabView::MoveCursorArea(), thats the bit that calcutes
+	// where the cursor should go ) 
+	// Main problem with this method is the ultra hacky attempt to preserve
+	// the ActiveCell, there should be no need to go to these extreems
+	
+	// Save ActiveCell pos ( to restore later )
+	uno::Any aDft;
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	rtl::OUString sActiveCell = xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+
+	// position current cell upper left of this range
+	Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
+
+        uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+
+	SfxViewFrame* pViewFrame = excel::getViewFrame( xModel );
+	if ( pViewFrame )
+	{
+		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
+		// Hoping this will make sure this slot is called
+		// synchronously
+		SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
+		aArgs.Put( sfxAsync, sfxAsync.Which() );
+		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
+
+		USHORT nSID = 0;
+	
+		switch( Direction )
+		{
+			case excel::XlDirection::xlDown:
+				nSID = SID_CURSORBLKDOWN;
+				break;
+			case excel::XlDirection::xlUp:
+				nSID = SID_CURSORBLKUP;
+				break;
+			case excel::XlDirection::xlToLeft:
+				nSID = SID_CURSORBLKLEFT;
+				break;
+			case excel::XlDirection::xlToRight:
+				nSID = SID_CURSORBLKRIGHT;
+				break;
+			default:
+				throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ": Invalid ColumnIndex" ) ), uno::Reference< uno::XInterface >() ); 
+		}
+		if ( pDispatcher )
+		{
+			pDispatcher->Execute( nSID, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
+		}
+	}
+
+	// result is the ActiveCell		
+	rtl::OUString sMoved =	xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+
+	// restore old ActiveCell		
+	uno::Any aVoid;
+
+	uno::Reference< excel::XRange > xOldActiveCell( xApplication->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
+	xOldActiveCell->Select();
+
+	uno::Reference< excel::XRange > resultCell;
+	
+	resultCell.set( xApplication->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
+
+	// return result
+	
+	return resultCell;
+}
+
+bool
+ScVbaRange::isSingleCellRange()
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY);
+	if ( xColumnRowRange.is() && xColumnRowRange->getRows()->getCount() == 1 && xColumnRowRange->getColumns()->getCount() == 1 )
+		return true;
+	return false;
+}
+
+uno::Reference< excel::XCharacters > SAL_CALL 
+ScVbaRange::characters( const uno::Any& Start, const uno::Any& Length ) throw (uno::RuntimeException)
+{
+	if ( !isSingleCellRange() )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't create Characters property for multicell range ") ), uno::Reference< uno::XInterface >() );
+	uno::Reference< text::XSimpleText > xSimple(mxRange->getCellByPosition(0,0) , uno::UNO_QUERY_THROW );
+	ScDocument* pDoc = getDocumentFromRange(mxRange);
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
+	return  new ScVbaCharacters( this, mxContext, aPalette, xSimple, Start, Length );
+}
+
+ void SAL_CALL 
+ScVbaRange::Delete( const uno::Any& Shift ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->Delete( Shift );	
+		}
+		return;
+	}
+	sheet::CellDeleteMode mode = sheet::CellDeleteMode_NONE ; 
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	if ( Shift.hasValue() )		
+	{
+		sal_Int32 nShift = 0;
+		Shift >>= nShift;
+		switch ( nShift )
+		{
+			case excel::XlDeleteShiftDirection::xlShiftUp:
+				mode = sheet::CellDeleteMode_UP;
+				break;
+			case excel::XlDeleteShiftDirection::xlShiftToLeft:
+				mode = sheet::CellDeleteMode_LEFT;
+				break;
+			default:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("Illegal paramater ") ), uno::Reference< uno::XInterface >() );
+		}
+	}
+	else
+        {
+		bool bFullRow = ( thisAddress.StartColumn == 0 && thisAddress.EndColumn == MAXCOL );
+	        sal_Int32 nCols = thisAddress.EndColumn - thisAddress.StartColumn;
+	        sal_Int32 nRows = thisAddress.EndRow - thisAddress.StartRow;
+		if ( mbIsRows || bFullRow || ( nCols >=  nRows ) )
+			mode = sheet::CellDeleteMode_UP;
+		else
+			mode = sheet::CellDeleteMode_LEFT;
+	}
+	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+	xCellRangeMove->removeRange( thisAddress, mode ); 
+	
+}
+
+//XElementAccess
+sal_Bool SAL_CALL 
+ScVbaRange::hasElements() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY );
+	if ( xColumnRowRange.is() )
+		if ( xColumnRowRange->getRows()->getCount() ||
+			xColumnRowRange->getColumns()->getCount() )
+			return sal_True;
+	return sal_False;
+}
+
+// XEnumerationAccess
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaRange::createEnumeration() throw (uno::RuntimeException)
+{
+	if ( mbIsColumns || mbIsRows )
+	{
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY );
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+                sal_Int32 nElems = 0;
+		if ( mbIsColumns )	
+			nElems = xColumnRowRange->getColumns()->getCount();
+		else
+			nElems = xColumnRowRange->getRows()->getCount();
+                return new ColumnsRowEnumeration( mxContext, xRange, nElems );
+		
+	}
+	return new CellsEnumeration( mxContext, m_Areas );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaRange::getDefaultMethodName(  ) throw (uno::RuntimeException)
+{
+	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
+	return sName;
+}
+
+
+uno::Reference< awt::XDevice > 
+getDeviceFromDoc( const uno::Reference< frame::XModel >& xModel ) throw( uno::RuntimeException )
+{
+	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XFrame> xFrame( xController->getFrame(), uno::UNO_QUERY_THROW );
+	uno::Reference< awt::XDevice > xDevice( xFrame->getComponentWindow(), uno::UNO_QUERY_THROW );
+	return xDevice;
+}
+
+// returns calc internal col. width ( in points )
+double 
+ScVbaRange::getCalcColWidth( const table::CellRangeAddress& rAddress) throw (uno::RuntimeException)
+{
+	ScDocument* pDoc = getScDocument();
+	USHORT nWidth = pDoc->GetOriginalWidth( static_cast< SCCOL >( rAddress.StartColumn ), static_cast< SCTAB >( rAddress.Sheet ) );
+	double nPoints = lcl_TwipsToPoints( nWidth );
+	nPoints = lcl_Round2DecPlaces( nPoints );
+	return nPoints;
+}
+
+double
+ScVbaRange::getCalcRowHeight( const table::CellRangeAddress& rAddress ) throw (uno::RuntimeException)
+{
+	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	USHORT nWidth = pDoc->GetOriginalHeight( rAddress.StartRow, rAddress.Sheet );
+	double nPoints = lcl_TwipsToPoints( nWidth );
+	nPoints = lcl_Round2DecPlaces( nPoints );
+	return nPoints;	
+}
+
+// return Char Width in points
+double getDefaultCharWidth( const uno::Reference< frame::XModel >& xModel ) throw ( uno::RuntimeException )
+{
+	const static rtl::OUString sDflt( RTL_CONSTASCII_USTRINGPARAM("Default")); 
+	const static rtl::OUString sCharFontName( RTL_CONSTASCII_USTRINGPARAM("CharFontName")); 
+	const static rtl::OUString sPageStyles( RTL_CONSTASCII_USTRINGPARAM("PageStyles")); 
+	// get the font from the default style
+	uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( xModel, uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess( xStyleSupplier->getStyleFamilies(), uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess2( xNameAccess->getByName( sPageStyles ), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps( xNameAccess2->getByName( sDflt ), uno::UNO_QUERY_THROW );
+	rtl::OUString sFontName;
+	xProps->getPropertyValue( sCharFontName ) >>= sFontName;
+
+	uno::Reference< awt::XDevice > xDevice = getDeviceFromDoc( xModel );
+	awt::FontDescriptor aDesc;
+	aDesc.Name = sFontName;
+	uno::Reference< awt::XFont > xFont( xDevice->getFont( aDesc ), uno::UNO_QUERY_THROW );
+	double nCharPixelWidth =  xFont->getCharWidth( (sal_Int8)'0' );	
+
+	double nPixelsPerMeter = xDevice->getInfo().PixelPerMeterX;
+	double nCharWidth = nCharPixelWidth /  nPixelsPerMeter;
+	nCharWidth = nCharWidth * (double)56700;// in twips
+	return lcl_TwipsToPoints( (USHORT)nCharWidth );	
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getColumnWidth() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = m_Areas->getCount();
+	if ( nLen > 1 ) 
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xRange->getColumnWidth();
+	}
+
+	double nColWidth = 	0;
+	ScDocShell* pShell = getScDocShell();
+	if ( pShell )
+	{
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		double defaultCharWidth = getDefaultCharWidth( xModel );
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
+		sal_Int32 nStartCol = thisAddress.StartColumn;
+		sal_Int32 nEndCol = thisAddress.EndColumn;
+		USHORT nColTwips = 0;
+		for( sal_Int32 nCol = nStartCol ; nCol <= nEndCol; ++nCol )
+		{
+			thisAddress.StartColumn = nCol;
+			USHORT nCurTwips = pShell->GetDocument()->GetOriginalWidth( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCTAB >( thisAddress.Sheet ) );
+			if ( nCol == nStartCol ) 
+				nColTwips =  nCurTwips;
+			if ( nColTwips != nCurTwips )
+				return aNULL();
+		}
+		nColWidth = lcl_Round2DecPlaces( lcl_TwipsToPoints( nColTwips ) );
+		if ( xModel.is() )
+			nColWidth = nColWidth / defaultCharWidth;
+	}
+	nColWidth = lcl_Round2DecPlaces( nColWidth );
+	return uno::makeAny( nColWidth );
+}
+
+void SAL_CALL 
+ScVbaRange::setColumnWidth( const uno::Any& _columnwidth ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = m_Areas->getCount();
+	if ( nLen > 1 ) 
+	{
+		for ( sal_Int32 index = 1; index != nLen; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(index) ), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->setColumnWidth( _columnwidth );
+		}
+		return;
+	}
+	double nColWidth = 0;
+	_columnwidth >>= nColWidth;
+	nColWidth = lcl_Round2DecPlaces( nColWidth );
+        ScDocShell* pDocShell = getScDocShell();
+        if ( pDocShell )
+        {
+                uno::Reference< frame::XModel > xModel = pDocShell->GetModel();
+                if ( xModel.is() )
+                {
+
+			nColWidth = ( nColWidth * getDefaultCharWidth( xModel ) );
+			RangeHelper thisRange( mxRange );	
+			table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+			USHORT nTwips = lcl_pointsToTwips( nColWidth );
+			
+			ScDocFunc aFunc(*pDocShell);
+			SCCOLROW nColArr[2];
+			nColArr[0] = thisAddress.StartColumn;
+			nColArr[1] = thisAddress.EndColumn;
+			aFunc.SetWidthOrHeight( TRUE, 1, nColArr, thisAddress.Sheet, SC_SIZE_ORIGINAL,
+		                                                                        nTwips, TRUE, TRUE );		
+			
+		}
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getWidth() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 ) 
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xRange->getWidth();
+	}
+	uno::Reference< table::XColumnRowRange > xColRowRange( mxRange, uno::UNO_QUERY_THROW );			
+	uno::Reference< container::XIndexAccess > xIndexAccess( xColRowRange->getColumns(), uno::UNO_QUERY_THROW ); 
+	sal_Int32 nElems = xIndexAccess->getCount();	
+	double nWidth = 0;
+	for ( sal_Int32 index=0; index<nElems; ++index )
+	{
+		uno::Reference< sheet::XCellRangeAddressable > xAddressable( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ); 
+		double nTmpWidth = getCalcColWidth( xAddressable->getRangeAddress() );
+		nWidth += nTmpWidth;
+	}
+	return uno::makeAny( nWidth );
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::Areas( const uno::Any& item) throw (uno::RuntimeException)
+{
+	if ( !item.hasValue() )
+		return uno::makeAny( m_Areas );
+	return m_Areas->Item( item, uno::Any() );	
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::getArea( sal_Int32 nIndex ) throw( css::uno::RuntimeException )
+{
+	if ( !m_Areas.is() )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("No areas available")), uno::Reference< uno::XInterface >() );
+	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ), uno::Any() ), uno::UNO_QUERY_THROW );
+	return xRange;
+}
+
+uno::Any
+ScVbaRange::Borders( const uno::Any& item ) throw( script::BasicErrorException, uno::RuntimeException )
+{
+	if ( !item.hasValue() )
+		return uno::makeAny( getBorders() );
+	return getBorders()->Item( item, uno::Any() );
+}
+
+uno::Any SAL_CALL
+ScVbaRange::BorderAround( const css::uno::Any& LineStyle, const css::uno::Any& Weight,
+                const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nCount = getBorders()->getCount();
+
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        const sal_Int32 nLineType = supportedIndexTable[i];
+        switch( nLineType )
+        {
+            case excel::XlBordersIndex::xlEdgeLeft:
+            case excel::XlBordersIndex::xlEdgeTop:
+            case excel::XlBordersIndex::xlEdgeBottom:
+            case excel::XlBordersIndex::xlEdgeRight:
+            {
+                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ), uno::Any() ), uno::UNO_QUERY_THROW );
+                if( LineStyle.hasValue() )
+                {
+                    xBorder->setLineStyle( LineStyle );
+                }
+                if( Weight.hasValue() )
+                {
+                    xBorder->setWeight( Weight );
+                }
+                if( ColorIndex.hasValue() )
+                {
+                    xBorder->setColorIndex( ColorIndex );
+                }
+                if( Color.hasValue() )
+                {
+                    xBorder->setColor( Color );
+                }
+                break;
+            }
+            case excel::XlBordersIndex::xlInsideVertical:
+            case excel::XlBordersIndex::xlInsideHorizontal:
+            case excel::XlBordersIndex::xlDiagonalDown:
+            case excel::XlBordersIndex::xlDiagonalUp:
+                break;
+            default:
+                return uno::makeAny( sal_False );
+        }
+    }
+    return uno::makeAny( sal_True );
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getRowHeight() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = m_Areas->getCount();
+	if ( nLen > 1 ) 
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xRange->getRowHeight();
+	}	
+
+	// if any row's RowHeight in the 
+	// range is different from any other then return NULL
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	
+	sal_Int32 nStartRow = thisAddress.StartRow;
+	sal_Int32 nEndRow = thisAddress.EndRow;
+        USHORT nRowTwips = 0;
+	// #TODO probably possible to use the SfxItemSet ( and see if
+	//  SFX_ITEM_DONTCARE is set ) to improve performance
+// #CHECKME looks like this is general behaviour not just row Range specific
+//	if ( mbIsRows ) 
+	ScDocShell* pShell = getScDocShell();
+	if ( pShell )
+	{
+		for ( sal_Int32 nRow = nStartRow ; nRow <= nEndRow; ++nRow )
+		{
+			thisAddress.StartRow = nRow;
+			USHORT nCurTwips = pShell->GetDocument()->GetOriginalHeight( thisAddress.StartRow, thisAddress.Sheet );
+			if ( nRow == nStartRow )
+				nRowTwips = nCurTwips;
+			if ( nRowTwips != nCurTwips )
+				return aNULL();
+		}
+	}
+	double nHeight = lcl_Round2DecPlaces( lcl_TwipsToPoints( nRowTwips ) );
+	return uno::makeAny( nHeight );
+}
+
+void SAL_CALL 
+ScVbaRange::setRowHeight( const uno::Any& _rowheight) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = m_Areas->getCount();
+	if ( nLen > 1 ) 
+	{
+		for ( sal_Int32 index = 1; index != nLen; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(index) ), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->setRowHeight( _rowheight );
+		}
+		return;
+	}
+	double nHeight = 0; // Incomming height is in points
+        _rowheight >>= nHeight;
+	nHeight = lcl_Round2DecPlaces( nHeight );
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	USHORT nTwips = lcl_pointsToTwips( nHeight );
+	
+	ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+	ScDocFunc aFunc(*pDocShell);
+	SCCOLROW nRowArr[2];
+	nRowArr[0] = thisAddress.StartRow;
+	nRowArr[1] = thisAddress.EndRow;
+	aFunc.SetWidthOrHeight( FALSE, 1, nRowArr, thisAddress.Sheet, SC_SIZE_ORIGINAL,
+                                                                        nTwips, TRUE, TRUE );		
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getPageBreak() throw (uno::RuntimeException)
+{
+	sal_Int32 nPageBreak = excel::XlPageBreak::xlPageBreakNone;
+	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	if ( pShell )
+	{
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		BOOL bColumn = FALSE;
+		
+		if (thisAddress.StartRow==0)
+		    bColumn = TRUE;
+		
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		if ( xModel.is() )
+		{
+	        ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	        
+			BYTE nFlag = 0;
+			if ( !bColumn )
+			    nFlag = pDoc -> GetRowFlags(thisAddress.StartRow, thisAddress.Sheet);
+			else
+			    nFlag = pDoc -> GetColFlags(static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.Sheet);
+			    
+			if ( nFlag & CR_PAGEBREAK)
+			    nPageBreak = excel::XlPageBreak::xlPageBreakAutomatic;
+			    
+			if ( nFlag & CR_MANUALBREAK)
+			    nPageBreak = excel::XlPageBreak::xlPageBreakManual;
+		}		
+	}
+
+	return uno::makeAny( nPageBreak );
+}
+
+void SAL_CALL 
+ScVbaRange::setPageBreak( const uno::Any& _pagebreak) throw (uno::RuntimeException)
+{
+	sal_Int32 nPageBreak = 0; 
+    _pagebreak >>= nPageBreak;
+		
+	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	if ( pShell )
+	{
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		if ((thisAddress.StartColumn==0) && (thisAddress.StartRow==0))
+		    return;
+		BOOL bColumn = FALSE;
+		
+		if (thisAddress.StartRow==0)
+		    bColumn = TRUE;
+		
+		ScAddress aAddr( static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.StartRow, thisAddress.Sheet );	
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		if ( xModel.is() )
+		{
+			ScTabViewShell* pViewShell = excel::getBestViewShell( xModel );
+			if ( nPageBreak == excel::XlPageBreak::xlPageBreakManual )
+			    pViewShell->InsertPageBreak( bColumn, TRUE, &aAddr);
+			else if ( nPageBreak == excel::XlPageBreak::xlPageBreakNone )
+			    pViewShell->DeletePageBreak( bColumn, TRUE, &aAddr);
+		}
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getHeight() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 ) 
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(1) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xRange->getHeight();
+	}
+	
+	uno::Reference< table::XColumnRowRange > xColRowRange( mxRange, uno::UNO_QUERY_THROW );			
+	uno::Reference< container::XIndexAccess > xIndexAccess( xColRowRange->getRows(), uno::UNO_QUERY_THROW ); 
+	sal_Int32 nElems = xIndexAccess->getCount();
+	double nHeight = 0;
+	for ( sal_Int32 index=0; index<nElems; ++index )
+	{
+        	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ); 
+		nHeight += getCalcRowHeight(xAddressable->getRangeAddress() );
+	}
+	return uno::makeAny( nHeight );
+}
+
+awt::Point 
+ScVbaRange::getPosition() throw ( uno::RuntimeException )
+{
+        awt::Point aPoint;
+	uno::Reference< beans::XPropertySet > xProps;
+	if ( mxRange.is() )
+		xProps.set( mxRange, uno::UNO_QUERY_THROW );
+	else
+		xProps.set( mxRanges, uno::UNO_QUERY_THROW );
+	xProps->getPropertyValue(POSITION) >>= aPoint;
+	return aPoint;
+}
+uno::Any SAL_CALL 
+ScVbaRange::getLeft() throw (uno::RuntimeException)
+{
+	// helperapi returns the first ranges left ( and top below )
+	if ( m_Areas->getCount() > 1 )
+		return getArea( 0 )->getLeft();
+        awt::Point aPoint = getPosition();
+	return uno::makeAny( lcl_hmmToPoints( aPoint.X ) );
+}
+
+
+uno::Any SAL_CALL 
+ScVbaRange::getTop() throw (uno::RuntimeException)
+{		
+	// helperapi returns the first ranges top
+	if ( m_Areas->getCount() > 1 )
+		return getArea( 0 )->getTop();
+        awt::Point aPoint= getPosition();
+	return uno::makeAny( lcl_hmmToPoints( aPoint.Y ) );
+}
+
+uno::Reference< excel::XWorksheet >
+ScVbaRange::getWorksheet() throw (uno::RuntimeException)
+{
+	// #TODO #FIXME parent should always be set up ( currently thats not
+	// the case )
+	uno::Reference< excel::XWorksheet > xSheet( getParent(), uno::UNO_QUERY );
+	if ( !xSheet.is() )
+	{
+		uno::Reference< table::XCellRange > xRange = mxRange;
+
+		if ( mxRanges.is() ) // assign xRange to first range
+		{
+			uno::Reference< container::XIndexAccess > xIndex( mxRanges, uno::UNO_QUERY_THROW );
+			xRange.set( xIndex->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+		}
+		ScDocShell* pDocShell = getDocShellFromRange(xRange);
+		RangeHelper rHelper(xRange);
+		// parent should be Thisworkbook
+       	xSheet.set( new ScVbaWorksheet( uno::Reference< XHelperInterface >(), mxContext,rHelper.getSpreadSheet(),pDocShell->GetModel()) );
+	}	
+	return xSheet;
+}
+
+ScCellRangesBase*
+ScVbaRange::getCellRangesBase() throw( uno::RuntimeException )
+{
+	ScCellRangesBase* pUnoRangesBase = NULL;
+	if ( mxRanges.is() )
+	{
+		uno::Reference< uno::XInterface > xIf( mxRanges, uno::UNO_QUERY_THROW );
+		pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	}
+	else if ( mxRange.is() )
+	{
+		uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
+		pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	}
+	else
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("General Error creating range - Unknown" ), uno::Reference< uno::XInterface >() );
+	return pUnoRangesBase;
+}
+
+// #TODO remove this ugly application processing
+// Process an application Range request e.g. 'Range("a1,b2,a4:b6")
+uno::Reference< excel::XRange >
+ScVbaRange::ApplicationRange( const uno::Reference< uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException)
+{
+	// Althought the documentation seems clear that Range without a 
+	// qualifier then its a shortcut for ActiveSheet.Range
+	// however, similarly Application.Range is apparently also a 
+	// shortcut for ActiveSheet.Range
+	// The is however a subtle behavioural difference I've come across 
+	// wrt to named ranges.
+	// If a named range "test" exists { Sheet1!$A1 } and the active sheet
+	// is Sheet2 then the following will fail
+	// msgbox ActiveSheet.Range("test").Address ' failes
+	// msgbox WorkSheets("Sheet2").Range("test").Address
+	// but !!!
+	// msgbox Range("test").Address ' works
+	// msgbox Application.Range("test").Address ' works
+
+	// Single param Range 
+	rtl::OUString sRangeName;
+	Cell1 >>= sRangeName;
+	if ( Cell1.hasValue() && !Cell2.hasValue() && sRangeName.getLength() )
+	{
+		const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+		uno::Reference< beans::XPropertySet > xPropSet( getCurrentExcelDoc(xContext), uno::UNO_QUERY_THROW );
+		
+		uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+		try
+		{
+			xReferrer.set ( xNamed->getByName( sRangeName ), uno::UNO_QUERY );
+		}
+		catch( uno::Exception& /*e*/ )
+		{
+			// do nothing
+		}
+		if ( xReferrer.is() )
+		{
+			uno::Reference< table::XCellRange > xRange = xReferrer->getReferredCells();
+			if ( xRange.is() )
+			{
+				// #FIXME need proper (WorkSheet) parent
+				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xRange );
+				return xVbRange;
+			}
+		}
+	}
+	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentExcelDoc(xContext)->getCurrentController(), uno::UNO_QUERY );
+	uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
+	ScVbaRange* pRange = new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xSheetRange );
+	uno::Reference< excel::XRange > xVbSheetRange( pRange );
+	return pRange->Range( Cell1, Cell2, true ); 
+}
+
+uno::Reference< sheet::XDatabaseRanges > 
+lcl_GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
+{
+	uno::Reference< frame::XModel > xModel;
+	if ( pShell )
+		xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
+	return xDBRanges;	
+}
+// returns the XDatabaseRange for the autofilter on sheet (nSheet)
+// also populates sName with the name of range
+uno::Reference< sheet::XDatabaseRange > 
+lcl_GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName )
+{
+	uno::Reference< container::XIndexAccess > xIndexAccess( lcl_GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
+	table::CellRangeAddress dbAddress;
+	for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
+	{
+		uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+		uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
+		// autofilters work weirdly with openoffice, unnamed is the default 
+		// named range which is used to create an autofilter, but
+		// its also possible that another name could be used
+		//     this also causes problems when an autofilter is created on
+		//     another sheet
+		// ( but.. you can use any named range )
+		dbAddress = xDBRange->getDataArea();
+		if ( dbAddress.Sheet == nSheet )
+		{
+			sal_Bool bHasAuto = sal_False;
+			uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
+			if ( bHasAuto )
+			{
+				sName = xNamed->getName();	
+				xDataBaseRange=xDBRange;
+				break;
+			}
+		}
+	}
+	return xDataBaseRange;
+} 
+
+// Helper functions for AutoFilter
+ScDBData* lcl_GetDBData_Impl( ScDocShell* pDocShell, sal_Int16 nSheet )
+{
+	rtl::OUString sName;
+	lcl_GetAutoFiltRange( pDocShell, nSheet, sName );
+	OSL_TRACE("lcl_GetDBData_Impl got autofilter range %s for sheet %d",
+		rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
+	ScDBData* pRet = NULL;
+	if (pDocShell)
+	{
+		ScDBCollection* pNames = pDocShell->GetDocument()->GetDBCollection();
+		if (pNames)
+		{
+			USHORT nPos = 0;
+			if (pNames->SearchName( sName , nPos ))
+				pRet = (*pNames)[nPos];
+		}
+	}
+	return pRet;
+}
+
+void lcl_SelectAll( ScDocShell* pDocShell, ScQueryParam& aParam )
+{
+	if ( pDocShell )
+	{	
+		ScViewData* pViewData = pDocShell->GetViewData();
+		if ( pViewData )
+		{
+			OSL_TRACE("Pushing out SelectAll query");
+			pViewData->GetView()->Query( aParam, NULL, TRUE );
+		}
+	}
+}
+
+ScQueryParam lcl_GetQueryParam( ScDocShell* pDocShell, sal_Int16 nSheet )
+{
+	ScDBData* pDBData = lcl_GetDBData_Impl( pDocShell, nSheet );	
+	ScQueryParam aParam;	
+	if (pDBData)
+	{
+		pDBData->GetQueryParam( aParam );
+	}
+	return aParam;
+}
+
+void lcl_SetAllQueryForField( ScQueryParam& aParam, SCCOLROW nField )
+{
+	bool bFound = false;
+	SCSIZE i = 0;
+	for (; i<MAXQUERY && !bFound; i++)
+	{
+		ScQueryEntry& rEntry = aParam.GetEntry(i);
+		if ( rEntry.nField == nField)
+		{
+			OSL_TRACE("found at pos %d", i );
+			bFound = true;
+		}
+	}
+	if ( bFound )
+	{
+		OSL_TRACE("field %d to delete at pos %d", nField, ( i - 1 ) );
+		aParam.DeleteQuery(--i);
+	}
+}
+
+
+void lcl_SetAllQueryForField( ScDocShell* pDocShell, SCCOLROW nField, sal_Int16 nSheet )
+{
+	ScQueryParam aParam = lcl_GetQueryParam( pDocShell, nSheet );
+	lcl_SetAllQueryForField( aParam, nField );
+	lcl_SelectAll( pDocShell, aParam );
+}
+
+// Modifies sCriteria, and nOp depending on the value of sCriteria
+void lcl_setTableFieldsFromCriteria( rtl::OUString& sCriteria1, uno::Reference< beans::XPropertySet >& xDescProps, sheet::TableFilterField2& rFilterField )
+{
+	// #TODO make this more efficient and cycle through 
+	// sCriteria1 character by character to pick up <,<>,=, * etc.
+	// right now I am more concerned with just getting it to work right
+
+	sCriteria1 = sCriteria1.trim();
+	// table of translation of criteria text to FilterOperators
+	// <>searchtext - NOT_EQUAL
+	//  =searchtext - EQUAL
+	//  *searchtext - startwith
+	//  <>*searchtext - doesn't startwith
+	//  *searchtext* - contains
+	//  <>*searchtext* - doesn't contain
+	// [>|>=|<=|...]searchtext for GREATER_value, GREATER_EQUAL_value etc.
+	sal_Int32 nPos = 0;
+	bool bIsNumeric = false;
+	if ( ( nPos = sCriteria1.indexOf( EQUALS ) ) == 0 )
+	{
+		if ( sCriteria1.getLength() == EQUALS.getLength() )
+            rFilterField.Operator = sheet::FilterOperator2::EMPTY;
+		else
+		{
+            rFilterField.Operator = sheet::FilterOperator2::EQUAL;
+			sCriteria1 = sCriteria1.copy( EQUALS.getLength() );
+			sCriteria1 = VBAToRegexp( sCriteria1 );	
+			// UseRegularExpressions 
+			if ( xDescProps.is() )
+				xDescProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "UseRegularExpressions" ) ), uno::Any( sal_True ) );
+		}
+
+	}
+	else if ( ( nPos = sCriteria1.indexOf( NOTEQUALS ) ) == 0 ) 
+	{
+		if ( sCriteria1.getLength() == NOTEQUALS.getLength() )
+            rFilterField.Operator = sheet::FilterOperator2::NOT_EMPTY;	
+		else
+		{
+            rFilterField.Operator = sheet::FilterOperator2::NOT_EQUAL;
+			sCriteria1 = sCriteria1.copy( NOTEQUALS.getLength() );
+			sCriteria1 = VBAToRegexp( sCriteria1 );	
+			// UseRegularExpressions 
+			if ( xDescProps.is() )
+				xDescProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "UseRegularExpressions" ) ), uno::Any( sal_True ) );
+		}
+	}	
+	else if ( ( nPos = sCriteria1.indexOf( GREATERTHAN ) ) == 0 ) 
+	{
+		bIsNumeric = true;
+		if ( ( nPos = sCriteria1.indexOf( GREATERTHANEQUALS ) ) == 0 )
+		{
+			sCriteria1 = sCriteria1.copy( GREATERTHANEQUALS.getLength() );
+            rFilterField.Operator = sheet::FilterOperator2::GREATER_EQUAL;
+		}
+		else
+		{
+			sCriteria1 = sCriteria1.copy( GREATERTHAN.getLength() );
+            rFilterField.Operator = sheet::FilterOperator2::GREATER;
+		}
+
+	}
+	else if ( ( nPos = sCriteria1.indexOf( LESSTHAN ) ) == 0 ) 
+	{
+		bIsNumeric = true;
+		if ( ( nPos = sCriteria1.indexOf( LESSTHANEQUALS ) ) == 0 )
+		{
+			sCriteria1 = sCriteria1.copy( LESSTHANEQUALS.getLength() );
+            rFilterField.Operator = sheet::FilterOperator2::LESS_EQUAL;
+		}
+		else
+		{
+			sCriteria1 = sCriteria1.copy( LESSTHAN.getLength() );
+            rFilterField.Operator = sheet::FilterOperator2::LESS;
+		}
+
+	}
+	else
+        rFilterField.Operator = sheet::FilterOperator2::EQUAL;
+
+	if ( bIsNumeric )
+	{
+		rFilterField.IsNumeric= sal_True;
+		rFilterField.NumericValue = sCriteria1.toDouble();
+	}
+	rFilterField.StringValue = sCriteria1;	
+}
+
+void SAL_CALL 
+ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const uno::Any& Operator, const uno::Any& Criteria2, const uno::Any& VisibleDropDown ) throw (uno::RuntimeException)
+{
+	// Is there an existing autofilter	
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	sal_Int16 nSheet = thisAddress.Sheet;
+	ScDocShell* pShell = getScDocShell();
+	sal_Bool bHasAuto = sal_False;	
+	rtl::OUString sAutofiltRangeName;
+	uno::Reference< sheet::XDatabaseRange > xDataBaseRange = lcl_GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
+	if ( xDataBaseRange.is() )
+		bHasAuto = true;	
+
+	uno::Reference< table::XCellRange > xFilterRange;
+	if ( !bHasAuto )
+	{
+		if (  m_Areas->getCount() > 1 )
+			throw uno::RuntimeException( STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY, uno::Reference< uno::XInterface >() );
+
+		table::CellRangeAddress autoFiltAddress; 
+		//CurrentRegion()
+		if ( isSingleCellRange() )
+		{
+			uno::Reference< excel::XRange > xCurrent( CurrentRegion() );
+			if ( xCurrent.is() )
+			{
+				ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xCurrent.get() );
+				if ( pRange->isSingleCellRange() )
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't create AutoFilter") ), uno::Reference< uno::XInterface >() );
+				if ( pRange )
+				{
+					RangeHelper currentRegion( pRange->mxRange );
+					autoFiltAddress = currentRegion.getCellRangeAddressable()->getRangeAddress();
+				}
+			}
+		} 
+		else // multi-cell range
+		{
+			RangeHelper multiCellRange( mxRange );
+			autoFiltAddress = multiCellRange.getCellRangeAddressable()->getRangeAddress();
+		}
+
+		uno::Reference< sheet::XDatabaseRanges > xDBRanges = lcl_GetDataBaseRanges( pShell );
+		if ( xDBRanges.is() )
+		{
+			rtl::OUString sGenName( RTL_CONSTASCII_USTRINGPARAM("VBA_Autofilter_") );
+			sGenName += rtl::OUString::valueOf( static_cast< sal_Int32 >( nSheet ) );
+			OSL_TRACE("Going to add new autofilter range.. name %s",
+				rtl::OUStringToOString( sGenName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
+			if ( !xDBRanges->hasByName( sGenName ) )
+				xDBRanges->addNewByName(  sGenName, autoFiltAddress );
+			xDataBaseRange.set( xDBRanges->getByName(  sGenName ), uno::UNO_QUERY_THROW );
+		}
+		if ( !xDataBaseRange.is() )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Failed to find the autofilter placeholder range" ) ), uno::Reference< uno::XInterface >() );		
+
+		uno::Reference< beans::XPropertySet > xDBRangeProps( xDataBaseRange, uno::UNO_QUERY_THROW );
+		// set autofilt
+		xDBRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::Any(sal_True) ); 
+		// set header
+		uno::Reference< beans::XPropertySet > xFiltProps( xDataBaseRange->getFilterDescriptor(), uno::UNO_QUERY_THROW );
+		sal_Bool bHasColHeader = sal_False;
+		ScDocument* pDoc = pShell ? pShell->GetDocument() : NULL;
+		
+		bHasColHeader = pDoc->HasColHeader(  static_cast< SCCOL >( autoFiltAddress.StartColumn ), static_cast< SCROW >( autoFiltAddress.StartRow ), static_cast< SCCOL >( autoFiltAddress.EndColumn ), static_cast< SCROW >( autoFiltAddress.EndRow ), static_cast< SCTAB >( autoFiltAddress.Sheet ) ) ? sal_True : sal_False;
+		xFiltProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ContainsHeader") ), uno::Any( bHasColHeader ) );	
+	}
+
+
+	sal_Int32 nField = 0; // *IS* 1 based
+	rtl::OUString sCriteria1;
+	sal_Int32 nOperator = excel::XlAutoFilterOperator::xlAnd;
+	
+	sal_Bool bVisible = sal_True;
+	bool  bChangeDropDown = false;
+	VisibleDropDown >>= bVisible;
+
+	if ( bVisible == bHasAuto ) // dropdown is displayed/notdisplayed as
+								// required
+		bVisible = sal_False;
+	else
+		bChangeDropDown = true;	
+	sheet::FilterConnection nConn = sheet::FilterConnection_AND;		
+	double nCriteria1 = 0;
+
+	bool bHasCritValue = Criteria1.hasValue();
+	bool bCritHasNumericValue = sal_False; // not sure if a numeric criteria is possible
+	if ( bHasCritValue )
+		bCritHasNumericValue = ( Criteria1 >>= nCriteria1 );
+
+	if (  !Field.hasValue() && ( Criteria1.hasValue() || Operator.hasValue() || Criteria2.hasValue() ) ) 
+		throw uno::RuntimeException();
+	// Use the normal uno api, sometimes e.g. when you want to use ALL as the filter
+	// we can't use refresh as the uno interface doesn't have a concept of ALL
+	// in this case we just call the core calc functionality - 
+	bool bAll = false;;
+	if ( ( Field >>= nField )  )
+	{
+        uno::Reference< sheet::XSheetFilterDescriptor2 > xDesc(
+                xDataBaseRange->getFilterDescriptor(), uno::UNO_QUERY );
+        if ( xDesc.is() )
+        {
+            uno::Sequence< sheet::TableFilterField2 > sTabFilts;
+            uno::Reference< beans::XPropertySet > xDescProps( xDesc, uno::UNO_QUERY_THROW );
+		if ( Criteria1.hasValue() )
+		{ 
+			sTabFilts.realloc( 1 );
+            sTabFilts[0].Operator = sheet::FilterOperator2::EQUAL;// sensible default
+			if ( !bCritHasNumericValue )
+			{ 
+				Criteria1 >>= sCriteria1;
+				sTabFilts[0].IsNumeric = bCritHasNumericValue;
+				if ( bHasCritValue && sCriteria1.getLength() )
+					lcl_setTableFieldsFromCriteria( sCriteria1, xDescProps, sTabFilts[0]  );
+				else
+					bAll = true;
+			}
+			else // numeric
+			{
+				sTabFilts[0].IsNumeric = sal_True;
+				sTabFilts[0].NumericValue = nCriteria1;
+			}
+		}
+		else // no value specified
+			bAll = true;
+		// not sure what the relationship between Criteria1 and Operator is,
+		// e.g. can you have a Operator without a Criteria ? in openoffice it 	
+		if ( Operator.hasValue()  && ( Operator >>= nOperator ) )
+		{
+			// if its a bottom/top Ten(Percent/Value) and there
+			// is no value specified for critera1 set it to 10
+			if ( !bCritHasNumericValue && !sCriteria1.getLength() && ( nOperator != excel::XlAutoFilterOperator::xlOr ) && ( nOperator != excel::XlAutoFilterOperator::xlAnd ) )
+			{
+				sTabFilts[0].IsNumeric = sal_True;	
+				sTabFilts[0].NumericValue = 10;	
+				bAll = false;
+			}
+			switch ( nOperator )
+			{
+				case excel::XlAutoFilterOperator::xlBottom10Items:
+                    sTabFilts[0].Operator = sheet::FilterOperator2::BOTTOM_VALUES;
+					break;
+				case excel::XlAutoFilterOperator::xlBottom10Percent:
+                    sTabFilts[0].Operator = sheet::FilterOperator2::BOTTOM_PERCENT;
+					break;
+				case excel::XlAutoFilterOperator::xlTop10Items:
+                    sTabFilts[0].Operator = sheet::FilterOperator2::TOP_VALUES;
+					break;
+				case excel::XlAutoFilterOperator::xlTop10Percent:
+                    sTabFilts[0].Operator = sheet::FilterOperator2::TOP_PERCENT;
+					break;
+				case excel::XlAutoFilterOperator::xlOr:
+					nConn = sheet::FilterConnection_OR;
+					break;
+				case excel::XlAutoFilterOperator::xlAnd:
+					nConn = sheet::FilterConnection_AND;
+					break;
+				default:
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UnknownOption") ), uno::Reference< uno::XInterface >() );
+					
+			}	
+
+		}		
+		if ( !bAll )
+		{
+			sTabFilts[0].Connection = sheet::FilterConnection_AND;	
+			sTabFilts[0].Field = (nField - 1);	
+
+			rtl::OUString sCriteria2;
+			if ( Criteria2.hasValue() ) // there is a Criteria2
+			{
+				sTabFilts.realloc(2);
+				sTabFilts[1].Field = sTabFilts[0].Field;
+				sTabFilts[1].Connection = nConn;	
+
+				if ( Criteria2 >>= sCriteria2 )
+				{
+					if ( sCriteria2.getLength() > 0 )
+					{
+						uno::Reference< beans::XPropertySet > xProps;
+						lcl_setTableFieldsFromCriteria( sCriteria2, xProps,  sTabFilts[1] );
+						sTabFilts[1].IsNumeric = sal_False;
+					}
+				}
+				else // numeric
+				{
+					Criteria2 >>= sTabFilts[1].NumericValue;
+					sTabFilts[1].IsNumeric = sal_True;
+                    sTabFilts[1].Operator = sheet::FilterOperator2::EQUAL;
+				}
+			}
+		}
+
+        xDesc->setFilterFields2( sTabFilts );
+		if ( !bAll )
+		{
+			xDataBaseRange->refresh();
+		}
+		else
+			// was 0 based now seems to be 1 
+			lcl_SetAllQueryForField( pShell, nField, nSheet );
+        }
+	}
+	else 
+	{
+		// this is just to toggle autofilter on and off ( not to be confused with 
+		// a VisibleDropDown option combined with a field, in that case just the 
+		// button should be disabled ) - currently we don't support that
+		bChangeDropDown = true;	
+		uno::Reference< beans::XPropertySet > xDBRangeProps( xDataBaseRange, uno::UNO_QUERY_THROW );
+		if ( bHasAuto )
+		{
+			// find the any field with the query and select all
+			ScQueryParam aParam = lcl_GetQueryParam( pShell, nSheet );
+			SCSIZE i = 0;
+			for (; i<MAXQUERY; i++)
+			{
+				ScQueryEntry& rEntry = aParam.GetEntry(i);
+				if ( rEntry.bDoQuery )
+					lcl_SetAllQueryForField( pShell, rEntry.nField, nSheet );
+			}
+			// remove exising filters
+            uno::Reference< sheet::XSheetFilterDescriptor2 > xSheetFilterDescriptor(
+                    xDataBaseRange->getFilterDescriptor(), uno::UNO_QUERY );
+            if( xSheetFilterDescriptor.is() )
+			    xSheetFilterDescriptor->setFilterFields2( uno::Sequence< sheet::TableFilterField2 >() );
+		}
+		xDBRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::Any(!bHasAuto) );
+
+	}
+}
+
+void SAL_CALL 
+ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& CopyOrigin ) throw (uno::RuntimeException)
+{
+	sal_Bool bCopyOrigin = sal_True;
+	CopyOrigin >>= bCopyOrigin;
+	// It appears ( from the web ) that the undocumented CopyOrigin
+	// param should contain member of enum XlInsertFormatOrigin
+	// which can have values xlFormatFromLeftOrAbove or xlFormatFromRightOrBelow
+	// #TODO investigate resultant behaviour using these constants
+	// currently just processing Shift
+
+	sheet::CellInsertMode mode = sheet::CellInsertMode_NONE; 
+	if ( Shift.hasValue() )
+	{
+		sal_Int32 nShift = 0;
+		Shift >>= nShift;
+		switch ( nShift )
+		{
+			case excel::XlInsertShiftDirection::xlShiftToRight:
+				mode = sheet::CellInsertMode_RIGHT;
+				break;
+			case excel::XlInsertShiftDirection::xlShiftDown:
+				mode = sheet::CellInsertMode_DOWN;
+				break;
+			default:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("Illegal paramater ") ), uno::Reference< uno::XInterface >() );
+		}
+	}
+	else 
+	{
+		if ( getRow() >=  getColumn() )
+			mode = sheet::CellInsertMode_DOWN;
+		else
+			mode = sheet::CellInsertMode_RIGHT;
+	}
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
+	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );	
+	xCellRangeMove->insertCells( thisAddress, mode );
+	if ( bCopyOrigin )
+	{
+		// After the insert ( this range ) actually has moved
+		ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
+	 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getDocShellFromRange( mxRange ) , aRange ) );
+		uno::Reference< excel::XRange > xVbaRange( new ScVbaRange( getParent(), mxContext, xRange, mbIsRows, mbIsColumns ) );	
+		xVbaRange->PasteSpecial( uno::Any(), uno::Any(), uno::Any(), uno::Any() );
+	}
+}
+
+void SAL_CALL
+ScVbaRange::Autofit() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = m_Areas->getCount();
+	if ( nLen > 1 ) 
+	{
+		for ( sal_Int32 index = 1; index != nLen; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32(index) ), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->Autofit();
+		}
+		return;
+	}
+		// if the range is a not a row or column range autofit will
+		// throw an error
+
+		if ( !( mbIsColumns || mbIsRows ) )
+			DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString()); 			
+        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        if ( pDocShell )
+        {
+			RangeHelper thisRange( mxRange );	
+			table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+			
+			ScDocFunc aFunc(*pDocShell);
+			SCCOLROW nColArr[2];
+			nColArr[0] = thisAddress.StartColumn;
+			nColArr[1] = thisAddress.EndColumn;
+			BOOL bDirection = TRUE;
+			if ( mbIsRows )
+			{
+				bDirection = FALSE;
+				nColArr[0] = thisAddress.StartRow;
+				nColArr[1] = thisAddress.EndRow;
+			}
+			aFunc.SetWidthOrHeight( bDirection, 1, nColArr, thisAddress.Sheet, SC_SIZE_OPTIMAL,
+		                                                                        0, TRUE, TRUE );		
+			
+	}	
+}
+
+/***************************************************************************************
+ * interface for text: 
+ * com.sun.star.text.XText, com.sun.star.table.XCell, com.sun.star.container.XEnumerationAccess
+ * com.sun.star.text.XTextRange, 
+ * the main problem is to recognize the numeric and date, which assosiate with DecimalSeparator, ThousandsSeparator, 
+ * TrailingMinusNumbers and FieldInfo.
+***************************************************************************************/
+void SAL_CALL
+ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
+        const css::uno::Any& ConsecutinveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma,
+        const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& /*FieldInfo*/,
+        const css::uno::Any& DecimalSeparator, const css::uno::Any& ThousandsSeparator, const css::uno::Any& /*TrailingMinusNumbers*/  ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< excel::XRange > xRange;
+    if( Destination.hasValue() )
+    {
+        if( !( Destination >>= xRange ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Destination parameter should be a range" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set range\n");
+    }
+    else
+    {
+        //set as current
+        xRange = this;
+        OSL_TRACE("set range as himself\n");
+    }
+
+   sal_Int16 xlTextParsingType = excel::XlTextParsingType::xlDelimited;
+    if ( DataType.hasValue() )
+    {
+        if( !( DataType >>= xlTextParsingType ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "DataType parameter should be a short" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Datatype\n" );
+    }
+    sal_Bool bDilimited = ( xlTextParsingType == excel::XlTextParsingType::xlDelimited );
+
+    sal_Int16 xlTextQualifier = excel::XlTextQualifier::xlTextQualifierDoubleQuote; 
+    if( TextQualifier.hasValue() )
+    {
+        if( !( TextQualifier >>= xlTextQualifier ))
+             throw uno::RuntimeException( rtl::OUString::createFromAscii( "TextQualifier parameter should be a short" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set TextQualifier\n");
+    }
+
+    sal_Bool bConsecutinveDelimiter = sal_False;
+    if( ConsecutinveDelimiter.hasValue() )
+    {
+        if( !( ConsecutinveDelimiter >>= bConsecutinveDelimiter ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ConsecutinveDelimiter parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set ConsecutinveDelimiter\n");
+    }
+
+    sal_Bool bTab = sal_False;
+    if( Tab.hasValue() && bDilimited )
+    {
+        if( !( Tab >>= bTab ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Tab parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Tab\n");
+    }
+
+    sal_Bool bSemicolon = sal_False;
+    if( Semicolon.hasValue() && bDilimited )
+    {
+        if( !( Semicolon >>= bSemicolon ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Semicolon parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Semicolon\n");
+    }
+    sal_Bool bComma = sal_False;
+    if( Comma.hasValue() && bDilimited )
+    {
+        if( !( Comma >>= bComma ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Comma parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Comma\n");
+    }
+    sal_Bool bSpace = sal_False;
+    if( Space.hasValue() && bDilimited )
+    {
+        if( !( Space >>= bSpace ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Space parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Space\n");
+    }
+    sal_Bool bOther = sal_False;
+    rtl::OUString sOtherChar;
+    if( Other.hasValue() && bDilimited )
+    {
+        if( Other >>= bOther )
+        {
+            if( OtherChar.hasValue() )
+                if( !( OtherChar >>= sOtherChar ) )
+                    throw uno::RuntimeException( rtl::OUString::createFromAscii( "OtherChar parameter should be a String" ),
+                        uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set OtherChar\n" );
+        }
+     else if( bOther )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Other parameter should be a True" ),
+                    uno::Reference< uno::XInterface >() );
+    }
+ //TODO* FieldInfo   Optional Variant. An array containing parse information for the individual columns of data. The interpretation depends on the value of DataType. When the data is delimited, this argument is an array of two-element arrays, with each two-element array specifying the conversion options for a particular column. The first element is the column number (1-based), and the second element is one of the xlColumnDataType  constants specifying how the column is parsed.
+
+    rtl::OUString sDecimalSeparator;
+    if( DecimalSeparator.hasValue() )
+    {
+        if( !( DecimalSeparator >>= sDecimalSeparator ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "DecimalSeparator parameter should be a String" ),
+                uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set DecimalSeparator\n" );
+    }
+    rtl::OUString sThousandsSeparator;
+    if( ThousandsSeparator.hasValue() )
+    {
+        if( !( ThousandsSeparator >>= sThousandsSeparator ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ThousandsSeparator parameter should be a String" ),
+                uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set ThousandsSpeparator\n" );
+    }
+ //TODO* TrailingMinusNumbers  Optional Variant. Numbers that begin with a minus character.
+}
+
+css::uno::Reference< excel::XValidation > SAL_CALL 
+ScVbaRange::getValidation() throw (css::uno::RuntimeException)
+{
+	if ( !m_xValidation.is() )	
+		m_xValidation = new ScVbaValidation( this, mxContext, mxRange );
+	return m_xValidation;
+}
+
+uno::Any ScVbaRange::getFormulaHidden() throw ( script::BasicErrorException, css::uno::RuntimeException)
+{
+	SfxItemSet* pDataSet = getCurrentDataSet();
+	const ScProtectionAttr& rProtAttr = (const ScProtectionAttr &)
+		pDataSet->Get(ATTR_PROTECTION, TRUE);
+	SfxItemState eState = pDataSet->GetItemState(ATTR_PROTECTION, TRUE, NULL);
+	if(eState == SFX_ITEM_DONTCARE)
+		return aNULL();
+	return uno::makeAny(rProtAttr.GetHideFormula());
+
+}
+void ScVbaRange::setFormulaHidden(const uno::Any& Hidden) throw ( script::BasicErrorException, css::uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY_THROW);
+	util::CellProtection rCellAttr;
+	xProps->getPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_CELLPRO))) >>= rCellAttr;
+	Hidden >>= rCellAttr.IsFormulaHidden;
+	xProps->setPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(SC_UNONAME_CELLPRO)), uno::makeAny(rCellAttr));
+}
+
+uno::Any ScVbaRange::getShowDetail() throw ( css::uno::RuntimeException)
+{
+	// #FIXME, If the specified range is in a PivotTable report
+
+	// In MSO VBA, the specified range must be a single summary column or row in an outline. otherwise throw exception
+	if( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can not get Range.ShowDetail attribute ")), uno::Reference< uno::XInterface >() );
+	
+	sal_Bool bShowDetail = sal_False;
+
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentRegion();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	table::CellRangeAddress aOutlineAddress = xCellRangeAddressable->getRangeAddress();
+
+	// check if the specified range is a single summary column or row.
+	table::CellRangeAddress thisAddress = helper.getCellRangeAddressable()->getRangeAddress();
+	if( (thisAddress.StartRow == thisAddress.EndRow &&  thisAddress.EndRow == aOutlineAddress.EndRow ) ||
+		(thisAddress.StartColumn == thisAddress.EndColumn && thisAddress.EndColumn == aOutlineAddress.EndColumn ))
+	{
+		sal_Bool bColumn =thisAddress.StartRow == thisAddress.EndRow ? sal_False:sal_True; 
+		ScDocument* pDoc = getDocumentFromRange( mxRange );
+		ScOutlineTable* pOutlineTable = pDoc->GetOutlineTable(static_cast<SCTAB>(thisAddress.Sheet), sal_True);
+		const ScOutlineArray* pOutlineArray =  bColumn ? pOutlineTable->GetColArray(): pOutlineTable->GetRowArray();
+		if( pOutlineArray )
+		{
+			SCCOLROW nPos = bColumn ? (SCCOLROW)(thisAddress.EndColumn-1):(SCCOLROW)(thisAddress.EndRow-1);
+			ScOutlineEntry* pEntry = pOutlineArray->GetEntryByPos( 0, nPos );
+			if( pEntry )
+			{
+				bShowDetail = !pEntry->IsHidden();
+				return uno::makeAny( bShowDetail );
+			}
+		}
+	}
+	else
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can not set Range.ShowDetail attribute ")), uno::Reference< uno::XInterface >() );
+	}
+    return aNULL();
+}
+
+void ScVbaRange::setShowDetail(const uno::Any& aShowDetail) throw ( css::uno::RuntimeException)
+{
+	// #FIXME, If the specified range is in a PivotTable report
+
+	// In MSO VBA, the specified range must be a single summary column or row in an outline. otherwise throw exception
+	if( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can not set Range.ShowDetail attribute ")), uno::Reference< uno::XInterface >() );
+	
+	sal_Bool bShowDetail = sal_False;
+	aShowDetail >>= bShowDetail;
+
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentRegion();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	table::CellRangeAddress aOutlineAddress = xCellRangeAddressable->getRangeAddress();
+
+	// check if the specified range is a single summary column or row.
+	table::CellRangeAddress thisAddress = helper.getCellRangeAddressable()->getRangeAddress();
+	if( (thisAddress.StartRow == thisAddress.EndRow &&  thisAddress.EndRow == aOutlineAddress.EndRow ) ||
+		(thisAddress.StartColumn == thisAddress.EndColumn && thisAddress.EndColumn == aOutlineAddress.EndColumn ))
+	{			
+		// #FIXME, seems there is a different behavior between MSO and OOo. 
+		//	In OOo, the showDetail will show all the level entrys, while only show the first level entry in MSO
+		uno::Reference< sheet::XSheetOutline > xSheetOutline( helper.getSpreadSheet(), uno::UNO_QUERY_THROW );
+		if( bShowDetail )
+			xSheetOutline->showDetail( aOutlineAddress );
+		else
+			xSheetOutline->hideDetail( aOutlineAddress );
+	}
+	else
+	{
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can not set Range.ShowDetail attribute ")), uno::Reference< uno::XInterface >() );
+	}
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::MergeArea() throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< sheet::XSheetCellRange > xMergeShellCellRange(mxRange->getCellRangeByPosition(0,0,0,0), uno::UNO_QUERY_THROW);
+    uno::Reference< sheet::XSheetCellCursor > xMergeSheetCursor(xMergeShellCellRange->getSpreadsheet()->createCursorByRange( xMergeShellCellRange ), uno::UNO_QUERY_THROW);
+    if( xMergeSheetCursor.is() )
+    {
+        xMergeSheetCursor->collapseToMergedArea();
+        uno::Reference<sheet::XCellRangeAddressable> xMergeCellAddress(xMergeSheetCursor, uno::UNO_QUERY_THROW);
+        if( xMergeCellAddress.is() )
+        {
+            table::CellRangeAddress aCellAddress = xMergeCellAddress->getRangeAddress();
+            if( aCellAddress.StartColumn ==0 && aCellAddress.EndColumn==0 &&
+                aCellAddress.StartRow==0 && aCellAddress.EndRow==0)
+            {
+                return new ScVbaRange( getParent(),mxContext,mxRange );
+            }
+            else
+            {
+                ScRange refRange( static_cast< SCCOL >( aCellAddress.StartColumn ), static_cast< SCROW >( aCellAddress.StartRow ), static_cast< SCTAB >( aCellAddress.Sheet ), 
+                                  static_cast< SCCOL >( aCellAddress.EndColumn ), static_cast< SCROW >( aCellAddress.EndRow ), static_cast< SCTAB >( aCellAddress.Sheet ) );
+                uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getScDocShell() , refRange ) );
+                return new ScVbaRange( getParent(),mxContext,xRange );
+            }
+        }
+    }
+    return new ScVbaRange( getParent(),mxContext,mxRange );
+}
+
+void SAL_CALL 
+ScVbaRange::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& ActivePrinter, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& PrToFileName ) throw (uno::RuntimeException)
+{
+	ScDocShell* pShell = NULL;
+
+	sal_Int32 nItems = m_Areas->getCount();
+	uno::Sequence< 	table::CellRangeAddress > printAreas( nItems );
+	uno::Reference< sheet::XPrintAreas > xPrintAreas;
+	for ( sal_Int32 index=1; index <= nItems; ++index )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+
+		RangeHelper thisRange( xRange->getCellRange() );
+		table::CellRangeAddress rangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		if ( index == 1 )
+		{
+			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+			// initialise the doc shell and the printareas
+			pShell = getDocShellFromRange( pRange->mxRange );
+			xPrintAreas.set( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+		}
+		printAreas[ index - 1 ] = rangeAddress;
+	}
+	if ( pShell )
+	{
+		if ( xPrintAreas.is() )
+		{
+			xPrintAreas->setPrintAreas( printAreas );
+			uno::Reference< frame::XModel > xModel = pShell->GetModel();
+			PrintOutHelper( excel::getBestViewShell( xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, sal_True );
+		}
+	}
+}
+
+void SAL_CALL
+ScVbaRange::AutoFill(  const uno::Reference< excel::XRange >& Destination, const uno::Any& Type ) throw (uno::RuntimeException) 
+{
+	uno::Reference< excel::XRange > xDest( Destination, uno::UNO_QUERY_THROW );
+	ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xDest.get() );
+	RangeHelper destRangeHelper( pRange->mxRange );
+	table::CellRangeAddress destAddress = destRangeHelper.getCellRangeAddressable()->getRangeAddress();	
+	
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
+	ScRange sourceRange;
+	ScRange destRange;
+
+	ScUnoConversion::FillScRange( destRange, destAddress );	
+	ScUnoConversion::FillScRange( sourceRange, thisAddress );
+	
+	
+	// source is valid
+//	if (  !sourceRange.In( destRange ) )
+//		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "source not in destination" ) ), uno::Reference< uno::XInterface >() );
+
+	FillDir eDir = FILL_TO_BOTTOM;
+	double fStep = 1.0;
+
+	ScRange aRange( destRange );
+	ScRange aSourceRange( destRange );
+
+	// default to include the number of Rows in the source range;
+	SCCOLROW nSourceCount = ( sourceRange.aEnd.Row() - sourceRange.aStart.Row() ) + 1;
+	SCCOLROW nCount = 0;	
+
+	if ( sourceRange != destRange )
+	{
+		// Find direction of fill, vertical or horizontal
+		if ( sourceRange.aStart == destRange.aStart )
+		{
+			if ( sourceRange.aEnd.Row() == destRange.aEnd.Row() )
+			{
+				nSourceCount = ( sourceRange.aEnd.Col() - sourceRange.aStart.Col() + 1 );
+				aSourceRange.aEnd.SetCol( static_cast<SCCOL>( aSourceRange.aStart.Col() + nSourceCount - 1 ) );
+				eDir = FILL_TO_RIGHT;			
+				nCount = aRange.aEnd.Col() - aSourceRange.aEnd.Col();
+			}
+			else if ( sourceRange.aEnd.Col() == destRange.aEnd.Col() )
+			{
+				aSourceRange.aEnd.SetRow( static_cast<SCROW>( aSourceRange.aStart.Row() + nSourceCount ) - 1 );
+				nCount = aRange.aEnd.Row() - aSourceRange.aEnd.Row();
+				eDir = FILL_TO_BOTTOM;
+			}
+		}
+
+		else if ( aSourceRange.aEnd == destRange.aEnd ) 
+		{
+			if ( sourceRange.aStart.Col() == destRange.aStart.Col() )
+			{
+				aSourceRange.aStart.SetRow( static_cast<SCROW>( aSourceRange.aEnd.Row() - nSourceCount + 1 ) );
+				nCount = aSourceRange.aStart.Row() - aRange.aStart.Row();
+				eDir = FILL_TO_TOP;			
+				fStep = -fStep;
+			}
+			else if ( sourceRange.aStart.Row() == destRange.aStart.Row() )
+			{
+				nSourceCount = ( sourceRange.aEnd.Col() - sourceRange.aStart.Col() ) + 1;
+				aSourceRange.aStart.SetCol( static_cast<SCCOL>( aSourceRange.aEnd.Col() - nSourceCount + 1 ) );
+				nCount = aSourceRange.aStart.Col() - aRange.aStart.Col();
+				eDir = FILL_TO_LEFT;			
+				fStep = -fStep;
+			}
+		}
+	}	
+	ScDocShell* pDocSh= getDocShellFromRange( mxRange );
+
+	FillCmd eCmd = FILL_AUTO;
+	FillDateCmd eDateCmd = FILL_DAY;	
+
+#ifdef VBA_OOBUILD_HACK
+	double fEndValue =  MAXDOUBLE;
+#endif
+
+	if ( Type.hasValue() )
+	{
+		sal_Int16 nFillType = excel::XlAutoFillType::xlFillDefault; 	
+		Type >>= nFillType;
+		switch ( nFillType )
+		{
+			case excel::XlAutoFillType::xlFillCopy:
+				eCmd = 	FILL_SIMPLE;
+				fStep = 0.0;
+				break;
+			case excel::XlAutoFillType::xlFillDays:
+				eCmd = FILL_DATE;
+				break;
+			case excel::XlAutoFillType::xlFillMonths:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_MONTH;
+				break;
+			case excel::XlAutoFillType::xlFillWeekdays:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_WEEKDAY;
+				break;
+			case excel::XlAutoFillType::xlFillYears:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_YEAR;
+				break;
+			case excel::XlAutoFillType::xlGrowthTrend:
+				eCmd = FILL_GROWTH;
+				break;
+			case excel::XlAutoFillType::xlFillFormats:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "xlFillFormat not supported for AutoFill" ) ), uno::Reference< uno::XInterface >() );
+			case excel::XlAutoFillType::xlFillValues:
+			case excel::XlAutoFillType::xlFillSeries:
+			case excel::XlAutoFillType::xlLinearTrend:
+				eCmd = FILL_LINEAR;
+				break;
+			case excel::XlAutoFillType::xlFillDefault:
+			default:
+				eCmd = 	FILL_AUTO;
+				break;
+		}	
+	}
+	ScDocFunc aFunc(*pDocSh);
+#ifdef VBA_OOBUILD_HACK
+	aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd, nCount, fStep, fEndValue, TRUE, TRUE );
+#endif
+}
+sal_Bool SAL_CALL
+ScVbaRange::GoalSeek( const uno::Any& Goal, const uno::Reference< excel::XRange >& ChangingCell ) throw (uno::RuntimeException)
+{
+	ScDocShell* pDocShell = getScDocShell();
+	sal_Bool bRes = sal_True;
+	ScVbaRange* pRange = static_cast< ScVbaRange* >( ChangingCell.get() );
+	if ( pDocShell && pRange )
+	{
+		uno::Reference< sheet::XGoalSeek > xGoalSeek(  pDocShell->GetModel(), uno::UNO_QUERY_THROW );
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		RangeHelper changingCellRange( pRange->mxRange );
+		table::CellRangeAddress changingCellAddr = changingCellRange.getCellRangeAddressable()->getRangeAddress();
+		rtl::OUString sGoal = getAnyAsString( Goal );
+		table::CellAddress thisCell( thisAddress.Sheet, thisAddress.StartColumn, thisAddress.StartRow );
+		table::CellAddress changingCell( changingCellAddr.Sheet, changingCellAddr.StartColumn, changingCellAddr.StartRow );
+		sheet::GoalResult res = xGoalSeek->seekGoal( thisCell, changingCell, sGoal );
+		ChangingCell->setValue( uno::makeAny( res.Result ) );
+		
+		// openoffice behaves differently, result is 0 if the divergence is too great
+                // but... if it detects 0 is the value it requires then it will use that
+		// e.g. divergence & result both = 0.0 does NOT mean there is an error
+		if ( ( res.Divergence != 0.0 ) && ( res.Result == 0.0 ) )
+			bRes = sal_False;
+	}
+	else
+		bRes = sal_False;
+	return bRes;
+}
+
+void
+ScVbaRange::Calculate(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	getWorksheet()->Calculate();
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::Item( const uno::Any& row, const uno::Any& column ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( mbIsRows || mbIsColumns )
+	{
+		if ( column.hasValue() )
+			DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+		uno::Reference< excel::XRange > xRange;
+		if ( mbIsColumns )
+			xRange = Columns( row );
+		else
+			xRange = Rows( row );
+		return xRange;
+	}
+	return Cells( row, column );	
+}
+
+void
+ScVbaRange::AutoOutline(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	// #TODO #FIXME needs to check for summary row/col ( whatever they are )
+	// not valid for multi Area Addresses
+	if ( m_Areas->getCount() > 1 )
+		DebugHelper::exception(SbERR_METHOD_FAILED, STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY); 			
+	// So needs to either span an entire Row or a just be a single cell 
+	// ( that contains a summary RowColumn )
+	// also the Single cell cause doesn't seem to be handled specially in 
+	// this code ( ported from the helperapi RangeImpl.java, 
+	// RangeRowsImpl.java, RangesImpl.java, RangeSingleCellImpl.java
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+
+	if ( isSingleCellRange() || mbIsRows )
+	{
+		uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+       		 xSheetOutline->autoOutline( thisAddress );	
+	}
+	else
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+}
+
+void SAL_CALL
+ScVbaRange:: ClearOutline(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->ClearOutline();	
+		}
+		return;
+	}
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+        xSheetOutline->clearOutline();	
+}
+
+void 
+ScVbaRange::groupUnGroup( bool bUnGroup ) throw ( script::BasicErrorException, uno::RuntimeException )
+{
+	if ( m_Areas->getCount() > 1 )
+		 DebugHelper::exception(SbERR_METHOD_FAILED, STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY);
+	table::TableOrientation nOrient = table::TableOrientation_ROWS;
+	if ( mbIsColumns )
+		nOrient = table::TableOrientation_COLUMNS;
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	uno::Reference< sheet::XSheetOutline > xSheetOutline( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+	if ( bUnGroup )
+	        xSheetOutline->ungroup( thisAddress, nOrient );
+	else
+	        xSheetOutline->group( thisAddress, nOrient );
+}
+
+void SAL_CALL 
+ScVbaRange::Group(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	groupUnGroup();	
+}
+void SAL_CALL 
+ScVbaRange::Ungroup(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	groupUnGroup(true);	
+}
+
+void lcl_mergeCellsOfRange( const uno::Reference< table::XCellRange >& xCellRange, sal_Bool _bMerge = sal_True ) throw ( uno::RuntimeException )
+{
+        uno::Reference< util::XMergeable > xMergeable( xCellRange, uno::UNO_QUERY_THROW );
+        xMergeable->merge(_bMerge);            
+}
+void SAL_CALL 
+ScVbaRange::Merge( const uno::Any& Across ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->Merge(Across);	
+		}
+		return;
+	}
+	uno::Reference< table::XCellRange > oCellRange;	
+	sal_Bool bAcross = sal_False;
+	Across >>= bAcross;
+	if ( !bAcross )
+		lcl_mergeCellsOfRange( mxRange );
+	else
+	{
+		uno::Reference< excel::XRange > oRangeRowsImpl = Rows( uno::Any() );
+		// #TODO #FIXME this seems incredibly lame, this can't be right
+		for (sal_Int32 i=1; i <= oRangeRowsImpl->getCount();i++)
+		{
+               		oRangeRowsImpl->Cells( uno::makeAny( i ), uno::Any() )->Merge( uno::makeAny( sal_False ) );
+           	}
+	}
+}
+
+void SAL_CALL 
+ScVbaRange::UnMerge(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+			xRange->UnMerge();	
+		}
+		return;
+	}
+	lcl_mergeCellsOfRange( mxRange, sal_False);
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getStyle() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32( 1 ) ), uno::Any() ), uno::UNO_QUERY_THROW  );
+		return xRange->getStyle();
+	}
+	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
+	rtl::OUString sStyleName;
+    xProps->getPropertyValue(CELLSTYLE) >>= sStyleName;
+	ScDocShell* pShell = getScDocShell();
+	uno::Reference< frame::XModel > xModel( pShell->GetModel() ); 
+	uno::Reference< excel::XStyle > xStyle = new ScVbaStyle( this, mxContext,  sStyleName, xModel );
+	return uno::makeAny( xStyle );
+}
+void SAL_CALL 
+ScVbaRange::setStyle( const uno::Any& _style ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32( 1 ) ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xRange->setStyle( _style );
+		return;
+	}
+	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
+	uno::Reference< excel::XStyle > xStyle;
+	_style >>= xStyle;
+	xProps->setPropertyValue(CELLSTYLE, uno::makeAny(xStyle->getName()));
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::PreviousNext( bool bIsPrevious )
+{ 
+	ScMarkData markedRange;
+	ScRange refRange;	
+	RangeHelper thisRange( mxRange );
+	
+	ScUnoConversion::FillScRange( refRange, thisRange.getCellRangeAddressable()->getRangeAddress());
+	markedRange. SetMarkArea( refRange );
+	short nMove = bIsPrevious ? -1 : 1;
+
+	SCCOL nNewX = refRange.aStart.Col();
+	SCROW nNewY = refRange.aStart.Row();
+	SCTAB nTab = refRange.aStart.Tab();
+
+	ScDocument* pDoc = getScDocument(); 
+	pDoc->GetNextPos( nNewX,nNewY, nTab, nMove,0, TRUE,TRUE, markedRange );	
+	refRange.aStart.SetCol( nNewX );
+	refRange.aStart.SetRow( nNewY );
+	refRange.aStart.SetTab( nTab );
+	refRange.aEnd.SetCol( nNewX );
+	refRange.aEnd.SetRow( nNewY );
+	refRange.aEnd.SetTab( nTab );
+
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getScDocShell() , refRange ) );
+	
+	return new ScVbaRange( getParent(), mxContext, xRange );
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::Next() throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32( 1 ) ), uno::Any() ) , uno::UNO_QUERY_THROW  );
+		return xRange->Next();
+	}
+	return PreviousNext( false );
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::Previous() throw (script::BasicErrorException, uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( sal_Int32( 1 ) ), uno::Any() ), uno::UNO_QUERY_THROW  );
+		return xRange->Previous();
+	}
+	return PreviousNext( true );
+}
+
+uno::Reference< excel::XRange > SAL_CALL
+ScVbaRange::SpecialCells( const uno::Any& _oType, const uno::Any& _oValue) throw ( script::BasicErrorException )
+{
+	bool bIsSingleCell = isSingleCellRange(); 
+	bool bIsMultiArea = ( m_Areas->getCount() > 1 );
+	ScVbaRange* pRangeToUse = this;
+	sal_Int32 nType = 0;
+	if ( !( _oType >>= nType ) )
+		DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+	switch(nType)
+	{
+		case excel::XlCellType::xlCellTypeSameFormatConditions:
+		case excel::XlCellType::xlCellTypeAllValidation:
+		case excel::XlCellType::xlCellTypeSameValidation:
+			DebugHelper::exception(SbERR_NOT_IMPLEMENTED, rtl::OUString()); 
+			break;
+		case excel::XlCellType::xlCellTypeBlanks:
+		case excel::XlCellType::xlCellTypeComments:
+		case excel::XlCellType::xlCellTypeConstants:
+		case excel::XlCellType::xlCellTypeFormulas:
+		case excel::XlCellType::xlCellTypeVisible:
+		case excel::XlCellType::xlCellTypeLastCell:
+		{
+			if ( bIsMultiArea )
+			{
+				// need to process each area, gather the results and
+				// create a new range from those
+				std::vector< table::CellRangeAddress > rangeResults;
+				sal_Int32 nItems = ( m_Areas->getCount() + 1 );
+				for ( sal_Int32 index=1; index <= nItems; ++index )
+				{
+					uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+					xRange = xRange->SpecialCells( _oType,  _oValue);
+					ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+					if ( xRange.is() && pRange )
+					{
+						sal_Int32 nElems = ( pRange->m_Areas->getCount() + 1 );
+						for ( sal_Int32 nArea = 1; nArea < nElems; ++nArea )
+						{
+							uno::Reference< excel::XRange > xTmpRange( m_Areas->Item( uno::makeAny( nArea ), uno::Any() ), uno::UNO_QUERY_THROW );
+							RangeHelper rHelper( xTmpRange->getCellRange() );
+							rangeResults.push_back( rHelper.getCellRangeAddressable()->getRangeAddress() );
+						}	
+					}
+				}	
+				ScRangeList aCellRanges;
+				std::vector< table::CellRangeAddress >::iterator it = rangeResults.begin();
+				std::vector< table::CellRangeAddress >::iterator it_end = rangeResults.end();
+				for ( ; it != it_end; ++ it )
+				{
+					ScRange refRange;
+					ScUnoConversion::FillScRange( refRange, *it );
+					aCellRanges.Append( refRange );
+				}
+				// Single range
+				if ( aCellRanges.First() == aCellRanges.Last() )
+				{
+					uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getScDocShell(), *aCellRanges.First() ) );
+				// #FIXME need proper (WorkSheet) parent
+					return new ScVbaRange( getParent(), mxContext, xRange );
+				}
+				uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( getScDocShell(), aCellRanges ) );
+ 	
+				// #FIXME need proper (WorkSheet) parent
+				return new ScVbaRange( getParent(), mxContext, xRanges );
+			}
+			else if ( bIsSingleCell )
+			{
+				uno::Reference< excel::XRange > xUsedRange = getWorksheet()->getUsedRange();
+				pRangeToUse = static_cast< ScVbaRange* >( xUsedRange.get() );	
+			}
+		
+			break;
+		}			
+		default:
+		DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+			break;
+	}
+	if ( !pRangeToUse )
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString() );
+	return pRangeToUse->SpecialCellsImpl( nType, _oValue );	
+}
+
+sal_Int32 lcl_getFormulaResultFlags(const uno::Any& aType) throw ( script::BasicErrorException )
+{
+	sal_Int32 nType = excel::XlSpecialCellsValue::xlNumbers;
+	aType >>= nType;
+	sal_Int32 nRes = sheet::FormulaResult::VALUE;
+
+	switch(nType)
+	{
+		case excel::XlSpecialCellsValue::xlErrors:
+			nRes= sheet::FormulaResult::ERROR;
+			break;	
+		case excel::XlSpecialCellsValue::xlLogical:
+			//TODO bc93774: ask NN if this is really an appropriate substitute
+			nRes = sheet::FormulaResult::VALUE;
+			break;
+		case excel::XlSpecialCellsValue::xlNumbers:
+			nRes = sheet::FormulaResult::VALUE;
+			break;
+		case excel::XlSpecialCellsValue::xlTextValues:
+			nRes = sheet::FormulaResult::STRING;
+			break;
+		default:
+			DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+	}
+	return nRes;
+}
+
+uno::Reference< excel::XRange > 
+ScVbaRange::SpecialCellsImpl( sal_Int32 nType, const uno::Any& _oValue) throw ( script::BasicErrorException )
+{
+	uno::Reference< excel::XRange > xRange;
+	try
+	{
+		uno::Reference< sheet::XCellRangesQuery > xQuery( mxRange, uno::UNO_QUERY_THROW );
+		uno::Reference< excel::XRange > oLocRangeImpl;
+		uno::Reference< sheet::XSheetCellRanges > xLocSheetCellRanges;
+		switch(nType)
+		{
+			case excel::XlCellType::xlCellTypeAllFormatConditions:
+			case excel::XlCellType::xlCellTypeSameFormatConditions:
+			case excel::XlCellType::xlCellTypeAllValidation:
+			case excel::XlCellType::xlCellTypeSameValidation:
+				// Shouldn't get here ( should be filtered out by 
+				// ScVbaRange::SpecialCells()
+				DebugHelper::exception(SbERR_NOT_IMPLEMENTED, rtl::OUString()); 
+				break;
+			case excel::XlCellType::xlCellTypeBlanks:
+				xLocSheetCellRanges = xQuery->queryEmptyCells();
+				break;
+			case excel::XlCellType::xlCellTypeComments:
+				xLocSheetCellRanges = xQuery->queryContentCells(sheet::CellFlags::ANNOTATION);
+				break;
+			case excel::XlCellType::xlCellTypeConstants:
+				xLocSheetCellRanges = xQuery->queryContentCells(23);	      
+				break;
+			case excel::XlCellType::xlCellTypeFormulas:
+			{
+				sal_Int32 nFormulaResult = lcl_getFormulaResultFlags(_oValue);
+				xLocSheetCellRanges = xQuery->queryFormulaCells(nFormulaResult);
+				break;
+			}
+			case excel::XlCellType::xlCellTypeLastCell:
+				xRange = Cells( uno::makeAny( getCount() ), uno::Any() );
+			case excel::XlCellType::xlCellTypeVisible:
+				xLocSheetCellRanges = xQuery->queryVisibleCells();	      
+				break;
+			default:
+				DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+				break;
+		}
+		if (xLocSheetCellRanges.is())
+		{
+			xRange = lcl_makeXRangeFromSheetCellRanges( getParent(), mxContext, xLocSheetCellRanges, getScDocShell() );
+		}
+	}
+	catch (uno::Exception& )
+	{
+		DebugHelper::exception(SbERR_METHOD_FAILED, STR_ERRORMESSAGE_NOCELLSWEREFOUND);                    
+	}
+	return xRange;
+}
+
+void SAL_CALL 
+ScVbaRange::RemoveSubtotal(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	uno::Reference< sheet::XSubTotalCalculatable > xSub( mxRange, uno::UNO_QUERY_THROW );
+	xSub->removeSubTotals();	
+}
+
+void SAL_CALL 
+ScVbaRange::Subtotal( ::sal_Int32 _nGroupBy, ::sal_Int32 _nFunction, const uno::Sequence< ::sal_Int32 >& _nTotalList, const uno::Any& aReplace, const uno::Any& PageBreaks, const uno::Any& /*SummaryBelowData*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+	try
+	{
+		sal_Bool bDoReplace = sal_False;
+		aReplace >>= bDoReplace;
+		sal_Bool bAddPageBreaks = sal_False;
+		PageBreaks >>= bAddPageBreaks;
+
+		uno::Reference< sheet::XSubTotalCalculatable> xSub(mxRange, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSubTotalDescriptor > xSubDesc = xSub->createSubTotalDescriptor(sal_True);
+		uno::Reference< beans::XPropertySet > xSubDescPropertySet( xSubDesc, uno::UNO_QUERY_THROW );
+		xSubDescPropertySet->setPropertyValue(INSERTPAGEBREAKS, uno::makeAny( bAddPageBreaks));
+		sal_Int32 nLen = _nTotalList.getLength();
+		uno::Sequence< sheet::SubTotalColumn > aColumns( nLen );
+		for (int i = 0; i < nLen; i++)
+		{
+			aColumns[i].Column = _nTotalList[i] - 1;
+			switch (_nFunction)
+			{
+				case excel::XlConsolidationFunction::xlAverage:
+					aColumns[i].Function = sheet::GeneralFunction_AVERAGE;
+					break;
+				case excel::XlConsolidationFunction::xlCount:
+					aColumns[i].Function = sheet::GeneralFunction_COUNT;
+					break;
+				case excel::XlConsolidationFunction::xlCountNums:
+					aColumns[i].Function = sheet::GeneralFunction_COUNTNUMS;
+					break;
+				case excel::XlConsolidationFunction::xlMax:
+					aColumns[i].Function = sheet::GeneralFunction_MAX;
+					break;
+				case excel::XlConsolidationFunction::xlMin:
+					aColumns[i].Function = sheet::GeneralFunction_MIN;
+					break;
+				case excel::XlConsolidationFunction::xlProduct:
+					aColumns[i].Function = sheet::GeneralFunction_PRODUCT;
+					break;
+				case excel::XlConsolidationFunction::xlStDev:
+					aColumns[i].Function = sheet::GeneralFunction_STDEV;
+					break;
+				case excel::XlConsolidationFunction::xlStDevP:
+					aColumns[i].Function = sheet::GeneralFunction_STDEVP;
+					break;
+				case excel::XlConsolidationFunction::xlSum:
+					aColumns[i].Function = sheet::GeneralFunction_SUM;
+					break;
+				case excel::XlConsolidationFunction::xlUnknown:
+					aColumns[i].Function = sheet::GeneralFunction_NONE;
+					break;
+				case excel::XlConsolidationFunction::xlVar:
+					aColumns[i].Function = sheet::GeneralFunction_VAR;
+					break;
+				case excel::XlConsolidationFunction::xlVarP:
+					aColumns[i].Function = sheet::GeneralFunction_VARP;
+					break;
+				default:
+					DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString()) ;
+					return;
+			}
+		}
+		xSubDesc->addNew(aColumns, _nGroupBy - 1);
+		xSub->applySubTotals(xSubDesc, bDoReplace);
+	}
+	catch (uno::Exception& )
+	{
+		DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+	}
+}
+
+rtl::OUString& 
+ScVbaRange::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaRange") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaRange::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Range" ) );
+	}
+	return aServiceNames;
+}
+
+sal_Bool SAL_CALL
+ScVbaRange::hasError() throw (uno::RuntimeException)
+{
+    double dResult = sal_False;
+    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+    uno::Reference< script::XInvocation > xInvoc( xApplication->WorksheetFunction(), uno::UNO_QUERY_THROW );
+
+    static rtl::OUString FunctionName( RTL_CONSTASCII_USTRINGPARAM("IsError" ) );
+    uno::Sequence< uno::Any > Params(1);
+    uno::Reference< excel::XRange > aRange( this );
+    Params[0] = uno::makeAny( aRange );
+    uno::Sequence< sal_Int16 > OutParamIndex;
+    uno::Sequence< uno::Any > OutParam;
+    xInvoc->invoke( FunctionName, Params, OutParamIndex, OutParam ) >>= dResult;
+    if ( dResult > 0.0 )
+         return sal_True;
+    return sal_False;
+}
+
+namespace range
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaRange, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SvVbaRange",
+    "ooo.vba.excel.Range" );
+}
Index: sc/source/ui/vba/vbapropvalue.hxx
===================================================================
--- sc/source/ui/vba/vbapropvalue.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapropvalue.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,7 +32,7 @@
 #include <ooo/vba/XPropValue.hpp>
 #include <cppuhelper/implbase1.hxx>
 
-#include "vbahelper.hxx"
+#include "excelvbahelper.hxx"
 
 typedef ::cppu::WeakImplHelper1< ov::XPropValue > PropValueImpl_BASE;
 
Index: sc/source/ui/vba/vbastyles.cxx
===================================================================
--- sc/source/ui/vba/vbastyles.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbastyles.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -29,6 +29,7 @@
  ************************************************************************/
 #include "vbastyles.hxx"
 #include "vbastyle.hxx"
+#include <ooo/vba/excel/XRange.hpp>
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
Index: sc/source/ui/vba/vbaformatconditions.hxx
===================================================================
--- sc/source/ui/vba/vbaformatconditions.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaformatconditions.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,7 +35,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/sheet/XSheetConditionalEntries.hpp>
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 typedef CollTestImplHelper< ov::excel::XFormatConditions > ScVbaFormatConditions_BASE;
 class ScVbaFormatConditions: public ScVbaFormatConditions_BASE
Index: sc/source/ui/vba/vbamenus.cxx
===================================================================
--- sc/source/ui/vba/vbamenus.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenus.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,145 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenus.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenus::ScVbaMenus( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : Menus_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenus::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenu::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenus::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenus::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenus::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenus::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() != office::MsoControlType::msoControlPopup )
+        throw uno::RuntimeException();
+    return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+}
+
+uno::Reference< excel::XMenu > SAL_CALL ScVbaMenus::Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlPopup;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    return uno::Reference< excel::XMenu >( new ScVbaMenu( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenus::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenus") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenus::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menus" ) );
+    }
+    return aServiceNames;
+}
+
Index: sc/source/ui/vba/vbacharts.hxx
===================================================================
--- sc/source/ui/vba/vbacharts.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacharts.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,8 +31,8 @@
 #define SC_VBA_CHARTS_HXX
 #include <ooo/vba/excel/XCharts.hpp>
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
-#include"vbacollectionimpl.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "excelvbahelper.hxx"
 #include <hash_map>
 
 typedef CollTestImplHelper< ov::excel::XCharts > Charts_BASE;
@@ -43,7 +43,7 @@
 	css::uno::Reference< css::sheet::XSpreadsheetDocument > xSpreadsheetDocument;
 	css::uno::Reference< css::lang::XComponent > xComponent;
 public:
-	ScVbaCharts( const css::uno::Reference< ov::XHelperInterface >& _xParent, const css::uno::Reference< css::uno::XComponentContext >& _xContext );
+	ScVbaCharts( const css::uno::Reference< ov::XHelperInterface >& _xParent, const css::uno::Reference< css::uno::XComponentContext >& _xContext, const css::uno::Reference< css::frame::XModel >& xModel );
 	// XCharts
 	virtual css::uno::Any SAL_CALL Add() throw (css::script::BasicErrorException, css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XChart > SAL_CALL getActiveChart(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
Index: sc/source/ui/vba/vbapivotcache.hxx
===================================================================
--- sc/source/ui/vba/vbapivotcache.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapivotcache.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,7 +34,7 @@
 #include <com/sun/star/sheet/XDataPilotTable.hpp>
 
 #include <ooo/vba/excel/XPivotCache.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1<ov::excel::XPivotCache > PivotCacheImpl_BASE;
 
Index: sc/source/ui/vba/vbapalette.cxx
===================================================================
--- sc/source/ui/vba/vbapalette.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapalette.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -92,7 +92,7 @@
 }
 
 uno::Reference< container::XIndexAccess >
-ScVbaPalette::getPalette()
+ScVbaPalette::getPalette() const
 {
 	uno::Reference< container::XIndexAccess > xIndex;
 	uno::Reference< beans::XPropertySet > xProps;
Index: sc/source/ui/vba/vbawsfunction.cxx
===================================================================
--- sc/source/ui/vba/vbawsfunction.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbawsfunction.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -74,13 +74,58 @@
 
 	for (int i=0; i < Params.getLength();i++) 
 	{
+        aArrayTemp[i]= aArray[i];
 		uno::Reference<excel::XRange> myRange( aArray[ i ], uno::UNO_QUERY );
 		if ( myRange.is() ) 
 		{
 			aArrayTemp[i] = myRange->getCellRange();
 			continue;
 		}
-		aArrayTemp[i]= aArray[i];
+                else if (  aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_BOOLEAN )
+		{
+			sal_Bool bValue( sal_False );
+			aArray[ i ] >>= bValue;
+			if ( bValue )
+				aArrayTemp[ i ] <<= double( 1.0 ); 
+			else
+				aArrayTemp[ i ] <<= double( 0.0 ); 
+                        
+		}
+        else if ( aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_SEQUENCE )
+        {
+            // the sheet.FunctionAccess service doesn't deal with Sequences, only Sequences of Sequence
+            uno::Type aType = aArray[ i ].getValueType();
+            if ( aType.equals( getCppuType( (uno::Sequence<sal_Int16>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< sal_Int16 > >  aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<sal_Int32>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< sal_Int32 > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<double>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< double > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<rtl::OUString>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence< rtl::OUString > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+            else if ( aType.equals( getCppuType( (uno::Sequence<uno::Any>*)0 ) ) )
+            {
+                uno::Sequence< uno::Sequence<uno::Any > > aTmp(1);
+                aArray[ i ] >>= aTmp[ 0 ];
+                aArrayTemp[i] <<= aTmp;
+            }
+        }
 	}
 
 	for ( int count=0; count < aParamTemp.getLength(); ++count )
@@ -88,12 +133,13 @@
 			count, rtl::OUStringToOString( comphelper::anyToString( aParamTemp[count] ), RTL_TEXTENCODING_UTF8 ).getStr()  );
 	
 	uno::Any aRet = xFunctionAccess->callFunction(FunctionName,aParamTemp);
+
 	// MATCH function should alwayse return a double value, but currently if the first argument is XCellRange, MATCH function returns an array instead of a double value. Don't know why?
 	// To fix this issue in safe, current solution is to convert this array to a double value just for MATCH function.
 	String aUpper( FunctionName );
 	ScCompiler aCompiler( NULL, ScAddress() ); 
 	OpCode eOp = aCompiler.GetEnglishOpCode( aUpper.ToUpperAscii() );
-	if( eOp == ocMatch )
+	if( eOp == ocMatch || eOp == ocIsError )
 	{
 		double fVal = 0.0;
 		if( aRet >>= fVal )
Index: sc/source/ui/vba/vbacomment.cxx
===================================================================
--- sc/source/ui/vba/vbacomment.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacomment.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,6 +34,7 @@
 #include <com/sun/star/sheet/XSheetAnnotationAnchor.hpp>
 #include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
 #include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/table/XCell.hpp>
 #include <com/sun/star/text/XText.hpp>
@@ -161,8 +162,7 @@
 	aText >>= sText;
 
 	uno::Reference< text::XSimpleText > xAnnoText( getAnnotation(), uno::UNO_QUERY_THROW );
-	rtl::OUString sAnnoText = xAnnoText->getString();
-
+        
 	if ( aStart.hasValue() )
 	{
 		sal_Int16 nStart = 0;
@@ -194,8 +194,13 @@
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaComment::Text - bad Start value " ) ), uno::Reference< uno::XInterface >() );
 	}
 	else if ( aText.hasValue() )
-		xAnnoText->setString( sText );
+	{
+		uno::Reference< sheet::XCellAddressable > xCellAddr(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+		table::CellAddress aAddress = xCellAddr->getCellAddress();
+		getAnnotations()->insertNew( aAddress, sText );
+	}
 
+	rtl::OUString sAnnoText = xAnnoText->getString();
 	return sAnnoText;
 }
 
Index: sc/source/ui/vba/vbaoleobject.cxx
===================================================================
--- sc/source/ui/vba/vbaoleobject.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaoleobject.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,6 +33,7 @@
 #include <com/sun/star/view/XControlAccess.hpp>
 #include <com/sun/star/container/XChild.hpp>
 #include <com/sun/star/drawing/XShape.hpp>
+#include <ooo/vba/XControlProvider.hpp>
 
 #include "vbaoleobject.hxx"
 
@@ -61,8 +62,9 @@
     xChild.set( xChild->getParent(), uno::UNO_QUERY_THROW );
     xChild.set( xChild->getParent(), uno::UNO_QUERY_THROW );
     css::uno::Reference< css::frame::XModel > xModel( xChild->getParent(), uno::UNO_QUERY_THROW );
-    css::uno::Reference< css::view::XControlAccess > xControlAccess( xModel->getCurrentController(), css::uno::UNO_QUERY_THROW );
-    m_xWindowPeer = xControlAccess->getControl( xControlModel )->getPeer();
+    uno::Reference<lang::XMultiComponentFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< XControlProvider > xControlProvider( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.ControlProvider" ) ), mxContext ), uno::UNO_QUERY_THROW );
+    m_xControl.set( xControlProvider->createControl(  xControlShape, xModel ) );
 }
 
 uno::Reference< uno::XInterface > SAL_CALL 
@@ -74,98 +76,76 @@
 sal_Bool SAL_CALL 
 ScVbaOLEObject::getEnabled() throw (uno::RuntimeException)
 {
-    uno::Reference< css::awt::XWindow2 > xWindow2( m_xWindowPeer, css::uno::UNO_QUERY_THROW );
-    return xWindow2->isEnabled();
+    return m_xControl->getEnabled();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setEnabled( sal_Bool _enabled ) throw (uno::RuntimeException)
 {
-    uno::Reference< css::awt::XWindow2 > xWindow2( m_xWindowPeer, css::uno::UNO_QUERY_THROW );
-    xWindow2->setEnable( _enabled );
+    m_xControl->setEnabled( _enabled );
 }
 
 sal_Bool SAL_CALL 
 ScVbaOLEObject::getVisible() throw (uno::RuntimeException)
 {
-    uno::Reference< css::awt::XWindow2 > xWindow2( m_xWindowPeer, css::uno::UNO_QUERY_THROW );
-    return xWindow2->isVisible();
+    OSL_TRACE("OleObject %s returning visible %s", rtl::OUStringToOString( m_xControl->getName(), RTL_TEXTENCODING_UTF8 ).getStr(), m_xControl->getVisible() ? "true" : "false" );
+    return m_xControl->getVisible();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
 {
-    uno::Reference< css::awt::XWindow2 > xWindow2( m_xWindowPeer, css::uno::UNO_QUERY_THROW );
-    xWindow2->setVisible( _visible );
+    OSL_TRACE("OleObject %s set visible %s", rtl::OUStringToOString( m_xControl->getName(), RTL_TEXTENCODING_UTF8 ).getStr(), _visible ? "true" : "false" );
+    m_xControl->setVisible( _visible );
 }
 
 double SAL_CALL 
 ScVbaOLEObject::getLeft() throw (uno::RuntimeException)
 {
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    return mm2pt( xShape->getPosition().X / 100 );
+    return m_xControl->getLeft();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setLeft( double _left ) throw (uno::RuntimeException)
 {
-    awt::Point oldPosition;
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    oldPosition = xShape->getPosition();
-    oldPosition.X = pt2mm( _left ) * 100;
-    xShape->setPosition( oldPosition );
+    m_xControl->setLeft( _left );
 
 }
 
 double SAL_CALL 
 ScVbaOLEObject::getTop() throw (uno::RuntimeException)
 {
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    return mm2pt( xShape->getPosition().Y / 100 );
+    return m_xControl->getTop();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setTop( double _top ) throw (uno::RuntimeException)
 {
-    awt::Point oldPosition;
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    oldPosition = xShape->getPosition();
-    oldPosition.Y = pt2mm( _top ) * 100;;
-    xShape->setPosition( oldPosition );
+    m_xControl->setTop( _top );
 }
 
 double SAL_CALL 
 ScVbaOLEObject::getHeight() throw (uno::RuntimeException)
 {
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    return mm2pt( xShape->getSize().Height / 100 );//1pt = 1/72in
+    return m_xControl->getHeight();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setHeight( double _height ) throw (uno::RuntimeException)
 {
-    awt::Size oldSize;
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    oldSize = xShape->getSize();
-    oldSize.Height = pt2mm( _height ) * 100;
-    xShape->setSize( oldSize );
+    m_xControl->setHeight( _height );
 }
 
 double SAL_CALL 
 ScVbaOLEObject::getWidth() throw (uno::RuntimeException)
 {
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    return mm2pt ( xShape->getSize().Width / 100 );
+    return m_xControl->getWidth();
 }
 
 void SAL_CALL 
 ScVbaOLEObject::setWidth( double _width ) throw (uno::RuntimeException)
 {
-    awt::Size oldSize;
-    uno::Reference< drawing::XShape > xShape( m_xControlShape, uno::UNO_QUERY_THROW );
-    oldSize = xShape->getSize();
-    oldSize.Width = pt2mm( _width ) * 100;
-    xShape->setSize( oldSize );
+    m_xControl->setWidth( _width );
 }
 rtl::OUString& 
 ScVbaOLEObject::getServiceImplName()
Index: sc/source/ui/vba/vbamenuitems.cxx
===================================================================
--- sc/source/ui/vba/vbamenuitems.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenuitems.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,159 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitems.hxx"
+#include "vbamenuitem.hxx"
+#include "vbamenu.hxx"
+#include <ooo/vba/office/MsoControlType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuEnumeration_BASE;
+
+class MenuEnumeration : public MenuEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menu
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBarControl > xCommandBarControl( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+            {
+                uno::Reference< excel::XMenu > xMenu( new ScVbaMenu( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenu );
+            }
+            else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+            {
+                uno::Reference< excel::XMenuItem > xMenuItem( new ScVbaMenuItem( m_xParent, m_xContext, xCommandBarControl ) );
+                return uno::makeAny( xMenuItem );
+            }
+            nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuItems::ScVbaMenuItems( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBarControls >& xCommandBarControls ) throw ( uno::RuntimeException ) : MenuItems_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBarControls( xCommandBarControls )
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuItems::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuItem::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuItems::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBarControls, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuItems::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuItems::getCount() throw(css::uno::RuntimeException)
+{
+    // FIXME: should check if it is a popup menu
+    return m_xCommandBarControls->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuItems::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    uno::Reference< XCommandBarControl > xCommandBarControl( m_xCommandBarControls->Item( aIndex, uno::Any() ), uno::UNO_QUERY_THROW );
+    if( xCommandBarControl->getType() == office::MsoControlType::msoControlPopup )
+        return uno::makeAny( uno::Reference< excel::XMenu > ( new ScVbaMenu( this, mxContext, xCommandBarControl ) ) );
+    else if( xCommandBarControl->getType() == office::MsoControlType::msoControlButton )
+        return uno::makeAny( uno::Reference< excel::XMenuItem > ( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) ) );
+    throw uno::RuntimeException();    
+}
+
+uno::Reference< excel::XMenuItem > SAL_CALL ScVbaMenuItems::Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& /*ShortcutKey*/, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& /*StatusBar*/, const css::uno::Any& /*HelpFile*/, const css::uno::Any& /*HelpContextID*/ ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    sal_Int32 nType = office::MsoControlType::msoControlButton;
+    uno::Reference< XCommandBarControl > xCommandBarControl = m_xCommandBarControls->Add( uno::makeAny( nType ), uno::Any(), uno::Any(), Before, Restore );
+    xCommandBarControl->setCaption( Caption );
+    if( OnAction.hasValue() )
+    {
+        rtl::OUString sAction;
+        OnAction >>= sAction;
+        xCommandBarControl->setOnAction( sAction );
+    }
+    return uno::Reference< excel::XMenuItem >( new ScVbaMenuItem( this, mxContext, xCommandBarControl ) );
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuItems::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItems") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItems::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItems" ) );
+    }
+    return aServiceNames;
+}
+
Index: sc/source/ui/vba/vbawindow.cxx
===================================================================
--- sc/source/ui/vba/vbawindow.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbawindow.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,10 +27,11 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 #include "vbawindow.hxx"
 #include "vbaworksheets.hxx"
 #include "vbaworksheet.hxx"
+#include "vbaglobals.hxx"
 #include "vbapane.hxx"
 #include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
@@ -57,6 +58,9 @@
 using namespace ::ooo::vba;
 using namespace ::ooo::vba::excel::XlWindowState;
 
+// nameExists defined in vbaworksheet.cxx
+bool nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException );
+
 typedef  std::hash_map< rtl::OUString,
 SCTAB, ::rtl::OUStringHash,
 ::std::equal_to< ::rtl::OUString > > NameIndexHash;
@@ -118,7 +122,7 @@
 		ScDocShell* pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
 		if ( !pDocShell )
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain docshell" ) ), uno::Reference< uno::XInterface >() );
-		ScTabViewShell* pViewShell = getBestViewShell( m_xModel );
+		ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );
 		if ( !pViewShell )
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain view shell" ) ), uno::Reference< uno::XInterface >() );
 			
@@ -202,14 +206,13 @@
 
 };
 
-ScVbaWindow::ScVbaWindow( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : WindowImpl_BASE( xParent, xContext ), m_xModel( xModel ) 
+ScVbaWindow::ScVbaWindow( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : WindowImpl_BASE( xParent, xContext, xModel )
 {
     init();
 }
 
 ScVbaWindow::ScVbaWindow( uno::Sequence< uno::Any > const & args, uno::Reference< uno::XComponentContext > const & xContext )  
-        : WindowImpl_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext ),
-          m_xModel( getXSomethingFromArgs< frame::XModel >( args, 1 ) )
+        : WindowImpl_BASE( args, xContext )
 {
     init();
 }
@@ -306,8 +309,7 @@
 		if ( ( nCrudLen + nCrudIndex ) == sTitle.getLength() )
 		{
 			sTitle = sTitle.copy( 0, nCrudIndex );
-            uno::Reference< ov::XGlobals > xTemp( ScVbaGlobals::getGlobalsImpl( mxContext )); // temporary needed for g++ 3.3.5
-			ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( xTemp->getApplication(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
+			ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
 			rtl::OUString sName = workbook.getName();
 			// rather bizare hack to make sure the name behavior
 			// is like XL
@@ -343,7 +345,7 @@
 ScVbaWindow::getScrollRow() throw (uno::RuntimeException)
 {	
     sal_Int32 nValue = 0;
-    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+    ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
 	if ( pViewShell )
 	{
 	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
@@ -356,7 +358,7 @@
 void SAL_CALL 
 ScVbaWindow::setScrollRow( const uno::Any& _scrollrow ) throw (uno::RuntimeException)
 {
-	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
 	if ( pViewShell )
 	{
 		sal_Int32 scrollRow = 0;	
@@ -371,7 +373,7 @@
 ScVbaWindow::getScrollColumn() throw (uno::RuntimeException)
 {	
     sal_Int32 nValue = 0;
-    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+    ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
 	if ( pViewShell )
 	{
 	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
@@ -384,7 +386,7 @@
 void SAL_CALL 
 ScVbaWindow::setScrollColumn( const uno::Any& _scrollcolumn ) throw (uno::RuntimeException)
 {
-	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
 	if ( pViewShell )
 	{
 		sal_Int32 scrollColumn = 0;	
@@ -399,7 +401,7 @@
 ScVbaWindow::getWindowState() throw (uno::RuntimeException)
 {	
     sal_Int32 nwindowState = xlNormal;
-    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+    ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
     SfxViewFrame* pViewFrame = pViewShell -> GetViewFrame();
 	SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
 	if ( pTop )
@@ -421,7 +423,7 @@
 {
 	sal_Int32 nwindowState = xlMaximized;
 	_windowstate >>= nwindowState;
-	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );	
 	SfxViewFrame* pViewFrame = pViewShell -> GetViewFrame();
 	SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
 	if ( pTop )
@@ -444,8 +446,7 @@
 void
 ScVbaWindow::Activate() throw (css::uno::RuntimeException)
 {
-    uno::Reference< ov::XGlobals > xTemp( ScVbaGlobals::getGlobalsImpl( mxContext )); // temporary needed for g++ 3.3.5
-	ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( xTemp->getApplication(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
+	ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
 
 	workbook.Activate();
 }
@@ -453,8 +454,7 @@
 void
 ScVbaWindow::Close( const uno::Any& SaveChanges, const uno::Any& FileName, const uno::Any& RouteWorkBook ) throw (uno::RuntimeException)
 {
-    uno::Reference< ov::XGlobals > xTemp( ScVbaGlobals::getGlobalsImpl( mxContext )); // temporary needed for g++ 3.3.5
-	ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( xTemp->getApplication(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
+	ScVbaWorkbook workbook( uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
 	workbook.Close(SaveChanges, FileName, RouteWorkBook );
 }
 
@@ -467,13 +467,15 @@
 uno::Reference< excel::XRange > SAL_CALL 
 ScVbaWindow::ActiveCell(  ) throw (script::BasicErrorException, uno::RuntimeException)
 {
-	return ScVbaGlobals::getGlobalsImpl( mxContext )->getApplication()->getActiveCell();
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	return xApplication->getActiveCell();
 }
 
 uno::Any SAL_CALL 
 ScVbaWindow::Selection(  ) throw (script::BasicErrorException, uno::RuntimeException)
 {
-	return ScVbaGlobals::getGlobalsImpl( mxContext )->getApplication()->getSelection();
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	return xApplication->getSelection();
 }
 
 ::sal_Bool SAL_CALL 
@@ -736,30 +738,25 @@
 void SAL_CALL 
 ScVbaWindow::setZoom( const uno::Any& _zoom ) throw (uno::RuntimeException)
 {
-	uno::Reference< beans::XPropertySet > xProps( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-	rtl::OUString sZoomType( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_ZOOMTYPE ) );
-	sal_Int16 nZoomType = view::DocumentZoomType::PAGE_WIDTH;
-	if( _zoom.getValueTypeClass() == uno::TypeClass_BOOLEAN )
-	{		
-		//zoom type is PAGE_WIDTH_EXACT in helperapi, it seems that there is a issue for this zoom type in current OOo.
-		// so PAGE_WIDTH is used.   	
-		xProps->setPropertyValue(sZoomType, uno::makeAny( nZoomType ));
-	}					
-	else
-	{
-		nZoomType = view::DocumentZoomType::BY_VALUE;
-		rtl::OUString sZoomValue( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_ZOOMVALUE ));
-		sal_Int16 nZoomValue = 100;
-		_zoom >>= nZoomValue;
-		xProps->setPropertyValue( sZoomType, uno::makeAny( nZoomType ));
-		xProps->setPropertyValue( sZoomValue, uno::makeAny( nZoomValue ));
-	}			
+    sal_Int16 nZoom = 100;
+    _zoom >>= nZoom;
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( m_xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XWorksheet > xActiveSheet = ActiveSheet();
+    SCTAB nTab = 0;
+    rtl::OUString sName = xActiveSheet->getName();
+    bool bSheetExists = nameExists (xSpreadDoc, sName, nTab);
+    if ( !bSheetExists )
+        throw uno::RuntimeException();
+    std::vector< SCTAB > vTabs;
+    vTabs.push_back( nTab );
+    excel::implSetZoom( m_xModel, nZoom, vTabs );
 }
 
 uno::Reference< excel::XWorksheet > SAL_CALL 
 ScVbaWindow::ActiveSheet(  ) throw (script::BasicErrorException, uno::RuntimeException)
 {
-	return ScVbaGlobals::getGlobalsImpl(mxContext)->getApplication()->getActiveSheet();
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	return xApplication->getActiveSheet();
 }
 
 uno::Any SAL_CALL
@@ -787,124 +784,12 @@
 		default:
 			DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
 	}
-	dispatchExecute( m_xModel, nSlot );
+	ScTabViewShell* pViewShell = excel::getBestViewShell( m_xModel );
+	if ( pViewShell )
+		dispatchExecute( pViewShell, nSlot );
 }
 
-sal_Bool SAL_CALL
-ScVbaWindow::getVisible() throw (uno::RuntimeException)
-{
-	sal_Bool bVisible = sal_True;	
-	uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
-	uno::Reference< css::awt::XWindow2 > xWindow2 (xWindow, uno::UNO_QUERY_THROW );
-	if( xWindow2.is() )
-	{
-		bVisible = xWindow2->isVisible();	
-	}
-	return bVisible;
-}
-
-void SAL_CALL
-ScVbaWindow::setVisible(sal_Bool _visible) throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
-	if( xWindow.is() )
-	{
-		xWindow->setVisible( _visible );	
-	}
-}
-
-css::awt::Rectangle getPosSize( const uno::Reference< frame::XModel >& xModel )
-{
-	css::awt::Rectangle aRect;
-	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
-	if( xWindow.is() )
-	{
-		aRect = xWindow->getPosSize();
-	}
-	return aRect;
-}
-
-void setPosSize( const uno::Reference< frame::XModel >& xModel, sal_Int32 nValue, USHORT nFlag )
-{
-	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
-	if( xWindow.is() )
-	{
-		css::awt::Rectangle aRect = xWindow->getPosSize();
-		switch( nFlag )
-		{
-			case css::awt::PosSize::X:
-				xWindow->setPosSize( nValue, aRect.Y,	0, 0, css::awt::PosSize::X );
-				break;
-			case css::awt::PosSize::Y:
-				xWindow->setPosSize( aRect.X, nValue,	0, 0, css::awt::PosSize::Y );
-				break;
-			case css::awt::PosSize::WIDTH:
-				xWindow->setPosSize( 0, 0,	nValue, aRect.Height, css::awt::PosSize::WIDTH );
-				break;
-			case css::awt::PosSize::HEIGHT:
-				xWindow->setPosSize( 0, 0,	aRect.Width, nValue, css::awt::PosSize::HEIGHT );
-				break;
-			default:
-				break;
-		}
-	}
-}	
-
 sal_Int32 SAL_CALL 
-ScVbaWindow::getHeight() throw (uno::RuntimeException)
-{
-	css::awt::Rectangle aRect = getPosSize(m_xModel);
-	return aRect.Height;
-}
-
-void SAL_CALL 
-ScVbaWindow::setHeight( sal_Int32 _height ) throw (uno::RuntimeException)
-{
-	setPosSize(m_xModel, _height, css::awt::PosSize::HEIGHT);
-}
-
-sal_Int32 SAL_CALL 
-ScVbaWindow::getLeft() throw (uno::RuntimeException)
-{
-	css::awt::Rectangle aRect = getPosSize(m_xModel);
-	return aRect.X;
-}
-
-void SAL_CALL 
-ScVbaWindow::setLeft( sal_Int32 _left ) throw (uno::RuntimeException)
-{
-	setPosSize(m_xModel, _left, css::awt::PosSize::X);
-}
-sal_Int32 SAL_CALL 
-ScVbaWindow::getTop() throw (uno::RuntimeException)
-{
-	css::awt::Rectangle aRect = getPosSize(m_xModel);
-	return aRect.Y;
-}
-
-void SAL_CALL 
-ScVbaWindow::setTop( sal_Int32 _top ) throw (uno::RuntimeException)
-{
-	setPosSize(m_xModel, _top, css::awt::PosSize::Y);
-}
-sal_Int32 SAL_CALL 
-ScVbaWindow::getWidth() throw (uno::RuntimeException)
-{
-	css::awt::Rectangle aRect = getPosSize(m_xModel);
-	return aRect.Width;
-}
-
-void SAL_CALL 
-ScVbaWindow::setWidth( sal_Int32 _width ) throw (uno::RuntimeException)
-{
-	setPosSize(m_xModel, _width, css::awt::PosSize::WIDTH);
-}
-
-sal_Int32 SAL_CALL 
 ScVbaWindow::PointsToScreenPixelsX(sal_Int32 _points) throw (css::script::BasicErrorException, css::uno::RuntimeException)
 {
 	sal_Int32 nHundredthsofOneMillimeters = Millimeter::getInHundredthsOfOneMillimeter( _points );
@@ -924,14 +809,14 @@
 ScVbaWindow::PrintOut( const css::uno::Any& From, const css::uno::Any&To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
 {
 	// need test, print current active sheet	
-	PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, m_xModel, sal_True );
+	PrintOutHelper( excel::getBestViewShell( m_xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, sal_True );
 }
 
 void SAL_CALL 
 ScVbaWindow::PrintPreview( const css::uno::Any& EnableChanges ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
 {
 	// need test, print preview current active sheet	
-	PrintPreviewHelper( EnableChanges, m_xModel );	
+	PrintPreviewHelper( EnableChanges, excel::getBestViewShell( m_xModel ) );	
 }
 
 rtl::OUString& 
Index: sc/source/ui/vba/vbaseriescollection.hxx
===================================================================
--- sc/source/ui/vba/vbaseriescollection.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaseriescollection.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,9 +31,9 @@
 #define SC_VBA_SERIESCOLLECTION_HXX
 
 #include <ooo/vba/excel/XSeriesCollection.hpp>
-#include "vbahelperinterface.hxx"
-#include "vbacollectionimpl.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "excelvbahelper.hxx"
 
 
 typedef CollTestImplHelper< ov::excel::XSeriesCollection > SeriesCollection_BASE;
Index: sc/source/ui/vba/vbapagebreak.hxx
===================================================================
--- sc/source/ui/vba/vbapagebreak.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagebreak.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,12 +33,13 @@
 #include <cppuhelper/implbase1.hxx>
 #include <ooo/vba/excel/XPageBreak.hpp>
 #include <ooo/vba/excel/XHPageBreak.hpp>
+#include <ooo/vba/excel/XVPageBreak.hpp>
 #include <ooo/vba/excel/XRange.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/script/BasicErrorException.hpp>
 #include <com/sun/star/sheet/TablePageBreakData.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 template< typename Ifc1 >
 class ScVbaPageBreak : public InheritedHelperInterfaceImpl1< Ifc1 >
@@ -84,4 +85,22 @@
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
 };
 
+//VPageBreak
+typedef ScVbaPageBreak < ov::excel::XVPageBreak > ScVbaVPageBreak_BASE;
+
+class ScVbaVPageBreak :  public ScVbaVPageBreak_BASE
+{
+public:
+	ScVbaVPageBreak( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+					 const css::uno::Reference< css::uno::XComponentContext >& xContext,
+					 css::uno::Reference< css::beans::XPropertySet >& xProps,
+					 css::sheet::TablePageBreakData aTablePageBreakData) throw (css::uno::RuntimeException);
+            
+	virtual ~ScVbaVPageBreak();
+	
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
 #endif
Index: sc/source/ui/vba/vbapane.hxx
===================================================================
--- sc/source/ui/vba/vbapane.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapane.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,7 +34,7 @@
 #include<com/sun/star/sheet/XViewPane.hpp>
 #include<ooo/vba/excel/XPane.hpp>
 
-#include"vbahelper.hxx"
+#include"excelvbahelper.hxx"
 
 typedef cppu::WeakImplHelper1< ov::excel::XPane > PaneImpl_Base;
 
Index: sc/source/ui/vba/vbawindows.cxx
===================================================================
--- sc/source/ui/vba/vbawindows.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbawindows.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -37,6 +37,7 @@
 
 #include <tools/urlobj.hxx>
 #include "vbawindow.hxx"
+#include "vbaglobals.hxx"
 //#include "vbaworkbook.hxx"
 
 using namespace ::com::sun::star;
@@ -47,15 +48,15 @@
 ::std::equal_to< ::rtl::OUString > > NameIndexHash;
 
 
-uno::Reference< XHelperInterface > lcl_createWorkbookHIParent( const uno::Reference< frame::XModel >& xModel, const uno::Reference< uno::XComponentContext >& xContext )
+uno::Reference< XHelperInterface > lcl_createWorkbookHIParent( const uno::Reference< frame::XModel >& xModel, const uno::Reference< uno::XComponentContext >& xContext, const uno::Any& aApplication )
 {
-	return new ScVbaWorkbook( uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( xContext )->getApplication(), uno::UNO_QUERY_THROW ), xContext,  xModel );
+	return new ScVbaWorkbook( uno::Reference< XHelperInterface >( aApplication, uno::UNO_QUERY_THROW ), xContext,  xModel );
 }
 
-uno::Any ComponentToWindow( const uno::Any& aSource, uno::Reference< uno::XComponentContext > & xContext )
+uno::Any ComponentToWindow( const uno::Any& aSource, uno::Reference< uno::XComponentContext > & xContext, const uno::Any& aApplication )
 {
 	uno::Reference< frame::XModel > xModel( aSource, uno::UNO_QUERY_THROW );
-	uno::Reference< excel::XWindow > xWin( new ScVbaWindow( lcl_createWorkbookHIParent( xModel, xContext ), xContext,xModel ) );
+	uno::Reference< excel::XWindow > xWin( new ScVbaWindow( lcl_createWorkbookHIParent( xModel, xContext, aApplication ), xContext,xModel ) );
 	return uno::makeAny( xWin );
 }
 
@@ -108,12 +109,13 @@
 
 class WindowEnumImpl : public  WindowComponentEnumImpl
 {
+	uno::Any m_aApplication;
 public:
-	WindowEnumImpl(const uno::Reference< uno::XComponentContext >& xContext, const Components& components ):WindowComponentEnumImpl( xContext, components ) {}
-	WindowEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ): WindowComponentEnumImpl( xContext ) {}
+	WindowEnumImpl(const uno::Reference< uno::XComponentContext >& xContext, const Components& components, const uno::Any& aApplication ):WindowComponentEnumImpl( xContext, components ), m_aApplication( aApplication ){}
+	WindowEnumImpl( const uno::Reference< uno::XComponentContext >& xContext,  const uno::Any& aApplication ): WindowComponentEnumImpl( xContext ), m_aApplication( aApplication ) {}
 	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
 	{
-		return ComponentToWindow( WindowComponentEnumImpl::nextElement(), m_xContext );
+		return ComponentToWindow( WindowComponentEnumImpl::nextElement(), m_xContext, m_aApplication );
 	}
 };
 
@@ -212,16 +214,19 @@
 {
 }
 
+ScVbaWindows::ScVbaWindows( const uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) : ScVbaWindows_BASE( xParent, xContext, uno::Reference< container::XIndexAccess > ( new WindowsAccessImpl( xContext ) ) )
+{
+}
 uno::Reference< container::XEnumeration >
 ScVbaWindows::createEnumeration() throw (uno::RuntimeException)
 {
-	return new WindowEnumImpl( mxContext );
+	return new WindowEnumImpl( mxContext, Application() );
 }
 
 uno::Any
 ScVbaWindows::createCollectionObject( const css::uno::Any& aSource )
 {
-	return ComponentToWindow( aSource,  mxContext );
+	return ComponentToWindow( aSource,  mxContext, Application() );
 }
 
 uno::Type 
@@ -230,12 +235,6 @@
 	return excel::XWindows::static_type(0);
 }
 
-uno::Reference< XCollection >
-ScVbaWindows::Windows( const css::uno::Reference< css::uno::XComponentContext >& xContext )
-{
-	uno::Reference< container::XIndexAccess > xIndex( new WindowsAccessImpl( xContext ) );
-	return  new ScVbaWindows( uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( xContext )->getApplication(), uno::UNO_QUERY_THROW ), xContext , xIndex );	
-}
 
 void SAL_CALL 
 ScVbaWindows::Arrange( ::sal_Int32 /*ArrangeStyle*/, const uno::Any& /*ActiveWorkbook*/, const uno::Any& /*SyncHorizontal*/, const uno::Any& /*SyncVertical*/ ) throw (uno::RuntimeException)
Index: sc/source/ui/vba/vbaformat.hxx
===================================================================
--- sc/source/ui/vba/vbaformat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -39,7 +39,7 @@
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/lang/Locale.hpp>
 #include <com/sun/star/beans/XPropertyState.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 template< typename Ifc1 >
 class ScVbaFormat : public InheritedHelperInterfaceImpl1< Ifc1 >
Index: sc/source/ui/vba/vbaworksheets.cxx
===================================================================
--- sc/source/ui/vba/vbaworksheets.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworksheets.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -209,16 +209,29 @@
 	Count >>= nNewSheets;
 	Type >>= nType;
 	SCTAB nCount = 0;
-	Before >>= aStringSheet;
-	if (!aStringSheet.getLength())
+
+	uno::Reference< excel::XWorksheet > xBeforeAfterSheet;
+
+	if ( Before.hasValue() )
 	{
-		After >>= aStringSheet;
+        	if ( Before >>= xBeforeAfterSheet )
+			aStringSheet = xBeforeAfterSheet->getName();
+		else
+			Before >>= aStringSheet;
+	}
+
+	if (!aStringSheet.getLength() && After.hasValue() )
+	{
+        	if ( After >>= xBeforeAfterSheet )
+			aStringSheet = xBeforeAfterSheet->getName();
+		else
+			After >>= aStringSheet;
 		bBefore = sal_False;
 	}
 	if (!aStringSheet.getLength())
 	{
-		aStringSheet = ScVbaGlobals::getGlobalsImpl( 
-			mxContext )->getApplication()->getActiveWorkbook()->getActiveSheet()->getName();
+		uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+		aStringSheet = xApplication->getActiveWorkbook()->getActiveSheet()->getName();
 		bBefore = sal_True;
 	}
 		nCount = static_cast< SCTAB >( m_xIndexAccess->getCount() );
@@ -252,7 +265,9 @@
 		m_xSheets->insertNewByName(aStringName, nSheetIndex + i);
 		result = getItemByStringIndex( aStringName );
 	}
-	
+	uno::Reference< excel::XWorksheet > xNewSheet( result, uno::UNO_QUERY );
+	if ( xNewSheet.is() )
+		xNewSheet->Activate();	
 	return  result;
 }
 
@@ -295,7 +310,7 @@
 		if ( isSelectedSheets() )
 			bSelection = sal_True;
 
-	PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, mxModel, bSelection );
+	PrintOutHelper( excel::getBestViewShell( mxModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, bSelection );
 }
 
 uno::Any SAL_CALL 
@@ -336,7 +351,7 @@
 void SAL_CALL 
 ScVbaWorksheets::Select( const uno::Any& Replace ) throw (uno::RuntimeException)
 {
-	ScTabViewShell* pViewShell = getBestViewShell( mxModel );
+	ScTabViewShell* pViewShell = excel::getBestViewShell( mxModel );
 	if ( !pViewShell )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain view shell" ) ), uno::Reference< uno::XInterface >() );
 			
Index: sc/source/ui/vba/vbamenubar.hxx
===================================================================
--- sc/source/ui/vba/vbamenubar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenubar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBAR_HXX
+#define SC_VBA_MENUBAR_HXX
+
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBar.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenuBar > MenuBar_BASE;
+
+class ScVbaMenuBar : public MenuBar_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBar > m_xCommandBar;
+
+public:
+    ScVbaMenuBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBar >& xCommandBar ) throw( css::uno::RuntimeException );
+    
+    virtual css::uno::Any SAL_CALL Menus( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENUBAR_HXX
Index: sc/source/ui/vba/vbatextframe.cxx
===================================================================
--- sc/source/ui/vba/vbatextframe.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextframe.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,6 +27,7 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
 #include <com/sun/star/drawing/TextFitToSizeType.hpp>
 #include <com/sun/star/text/XText.hpp>
 #include "vbatextframe.hxx"
@@ -35,121 +36,19 @@
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-ScVbaTextFrame::ScVbaTextFrame( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, uno::Reference< drawing::XShape > xShape ) : ScVbaTextFrame_BASE( xParent, xContext ), m_xShape( xShape )
+ScVbaTextFrame::ScVbaTextFrame( uno::Sequence< uno::Any> const & args, uno::Reference< uno::XComponentContext> const & xContext ) throw ( lang::IllegalArgumentException ) :  ScVbaTextFrame_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext, getXSomethingFromArgs< drawing::XShape >( args, 1, false ) )
 {
-    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
 }
 
-void
-ScVbaTextFrame::setAsMSObehavior()
-{
-    //set property TextWordWrap default as False.
-    // TextFitToSize control the text content. it seems we should set the default as False.
-    // com.sun.star.drawing.TextFitToSizeType.NONE
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextWordWrap" ), uno::makeAny( sal_False ) );
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextFitToSize" ), uno::makeAny( drawing::TextFitToSizeType_NONE ) );
-}
-
-sal_Int32 ScVbaTextFrame::getMargin( rtl::OUString sMarginType )
-{
-    sal_Int32 nMargin = 0;
-    uno::Any aMargin = m_xPropertySet->getPropertyValue( sMarginType );
-    aMargin >>= nMargin;
-    return nMargin;
-}
-
-void ScVbaTextFrame::setMargin( rtl::OUString sMarginType, float fMargin )
-{
-    sal_Int32 nMargin = Millimeter::getInHundredthsOfOneMillimeter( fMargin );
-    m_xPropertySet->setPropertyValue( sMarginType, uno::makeAny( nMargin ) );
-}
-
-// Attributes
-sal_Bool SAL_CALL 
-ScVbaTextFrame::getAutoSize() throw (uno::RuntimeException)
-{
-    // I don't know why, but in OOo, TextAutoGrowHeight is the property control autosize. not TextFitToSize.
-    // TextFitToSize control the text content. 
-    // and in mso, there isnot option TextWordWrap which means auto wrap. the default is False.
-    sal_Bool bAutosize = sal_False;
-    uno::Any aTextAutoGrowHeight = m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "TextAutoGrowHeight" ) );
-    aTextAutoGrowHeight >>= bAutosize;
-    return bAutosize;
-}
-
-void SAL_CALL 
-ScVbaTextFrame::setAutoSize( sal_Bool _autosize ) throw (uno::RuntimeException)
-{
-    setAsMSObehavior();
-    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextAutoGrowHeight" ), uno::makeAny( _autosize ) );
-}
-
-float SAL_CALL 
-ScVbaTextFrame::getMarginBottom() throw (uno::RuntimeException)
-{
-    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextLowerDistance" ) );
-    float fMargin = (float)Millimeter::getInPoints( nMargin );
-    return fMargin;
-}
-
-void SAL_CALL 
-ScVbaTextFrame::setMarginBottom( float _marginbottom ) throw (uno::RuntimeException)
-{
-    setMargin( rtl::OUString::createFromAscii( "TextLowerDistance" ), _marginbottom );
-}
-
-float SAL_CALL 
-ScVbaTextFrame::getMarginTop() throw (uno::RuntimeException)
-{
-    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextUpperDistance" ) );
-    float fMargin = (float)Millimeter::getInPoints( nMargin );
-    return fMargin;
-}
-
-void SAL_CALL 
-ScVbaTextFrame::setMarginTop( float _margintop ) throw (uno::RuntimeException)
-{
-    setMargin( rtl::OUString::createFromAscii( "TextUpperDistance" ), _margintop );
-}
-
-float SAL_CALL 
-ScVbaTextFrame::getMarginLeft() throw (uno::RuntimeException)
-{
-    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextLeftDistance" ) );
-    float fMargin = (float)Millimeter::getInPoints( nMargin );
-    return fMargin;
-}
-
-void SAL_CALL 
-ScVbaTextFrame::setMarginLeft( float _marginleft ) throw (uno::RuntimeException)
-{
-    setMargin( rtl::OUString::createFromAscii( "TextLeftDistance" ), _marginleft );
-}
-
-float SAL_CALL 
-ScVbaTextFrame::getMarginRight() throw (uno::RuntimeException)
-{
-    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextRightDistance" ) );
-    float fMargin = (float)Millimeter::getInPoints( nMargin );
-    return fMargin;
-}
-
-void SAL_CALL 
-ScVbaTextFrame::setMarginRight( float _marginright ) throw (uno::RuntimeException)
-{
-    setMargin( rtl::OUString::createFromAscii( "TextRightDistance" ), _marginright );
-}
-
-
 // Methods
-uno::Reference< ov::excel::XCharacters > SAL_CALL 
+uno::Any SAL_CALL 
 ScVbaTextFrame::Characters() throw (uno::RuntimeException)
 {
     uno::Reference< text::XSimpleText > xSimpleText( m_xShape, uno::UNO_QUERY_THROW );
     ScVbaPalette aPalette( SfxObjectShell::Current() );
     uno::Any aStart( sal_Int32( 1 ) );
     uno::Any aLength(sal_Int32( -1 ) );
-    return uno::Reference< ov::excel::XCharacters >( new ScVbaCharacters( this, mxContext, aPalette, xSimpleText, aStart, aLength, sal_True ) );
+    return uno::makeAny( uno::Reference< ov::excel::XCharacters >( new ScVbaCharacters( this, mxContext, aPalette, xSimpleText, aStart, aLength, sal_True ) ) );
 }
 
 rtl::OUString&
@@ -171,3 +70,12 @@
     return aServiceNames;
 }
 
+namespace textframe 
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaTextFrame, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaTextFrame",
+    "ooo.vba.excel.TextFrame" );
+}
Index: sc/source/ui/vba/vbadialog.cxx
===================================================================
--- sc/source/ui/vba/vbadialog.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbadialog.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,82 +27,70 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include <comphelper/processfactory.hxx>
-
-#include <com/sun/star/lang/XMultiComponentFactory.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-#include <ooo/vba/excel/XApplication.hpp>
-
-#include <tools/string.hxx>
-
-#include "vbahelper.hxx"
 #include "vbadialog.hxx"
-#include "vbaglobals.hxx"
 
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-// fails silently
-void
-ScVbaDialog::Show() throw(uno::RuntimeException)
+//liuchen 2009-7-27 
+//solve the problem that "Application.Dialogs.Item(***).Show" and "Application.Dialogs.Count" cannot get the correct result
+struct DialogMatch
 {
-	rtl::OUString aURL;
-        uno::Reference< frame::XModel > xModel = getCurrentDocument();
-	if ( xModel.is() )
-	{
-		aURL = mapIndexToName( mnIndex );
-		if( aURL.getLength()  )
-			throw uno::RuntimeException(
-				::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Unable to open the specified dialog " ) ),
-				uno::Reference< XInterface > () );
-		dispatchRequests( xModel, aURL );
-	}
-}	
+	sal_Int32 		nVbaDlgIndex;
+	rtl::OUString	aOODlgName;
+};
 
-
-static const rtl::OUString aStringList[]=
+static const DialogMatch aDialogMatchList[] = 
 {
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation") ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ),
-	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) )	
+	{ 1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ) },						// xlDialogOpen -> .uno:Open
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ) },			// ??? -> .uno:FormatCellDialog
+	{ 55, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ) },				// xlDialogInsert -> .uno:InsertCell
+	{ 8, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ) },						// xlDialogPrint -> .uno:Print
+	{ 9,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PrinterSetup" ) ) }, 				// xlDialogPrinterSetup -> .uno:PrinterSetup
+	{ 53, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ) },				// xlDialogPasteSpecial -> .uno:PasteSpecial
+	{ 28, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ) },	// xlDialogProtectDocument -> uno:ToolProtectionDocument
+	{ 47,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ) },				// xlDialogColumnWidth -> .uno:ColumnWidth
+	{ 61,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ) },				// xlDialogDefineName -> .uno:DefineName
+	{ -1, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ) },			// ??? -> .uno:ConfigureDialog
+	{ 596, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ) },			// xlDialogInsertHyperlink -> .uno:HyperlinkDialog
+	{ 342,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ) },				// xlDialogInsertPicture -> .uno:InsertGraphic
+	{ 259, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ) },				// xlDialogInsertObject -> .uno:InsertObject
+	{ 7,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ) },			// xlDialogPageSetup -> .uno:PageFormatDialog
+	{ 39,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ) },					// xlDialogSort -> .uno:DataSort
+	{ 127, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ) },					// xlDialogRowHeight -> .uno:RowHeight
+	{ 485,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ) },			// xlDialogAutoCorrect -> .uno:AutoCorrectDlg
+	{ 583, 	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ) },	// xlDialogCondiationalFormatting -> .uno:ConditionalFormatDialog
+	{ 191,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ) },			// xlDialogConsolidate -> .uno:DataConsolidate
+	{ 62,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ) },				// xlDialogCreateNames -> .uno:CreateNames
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ) },				// ??? -> .uno:FillSeries
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation" ) ) },				// ??? -> .uno:Validation"
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ) },			// ??? -> .uno:DefineLabelRange
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ) },		// ??? -> .uno:DataFilterAutoFilter
+	{ -1,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ) }, 	// ??? -> .uno:DataFilterSpecialFilter
+	{ 269,	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) ) }					// xlDialogFormatAuto -> .uno:AutoFormat
 };
 
-const sal_Int32 nDialogSize = sizeof( aStringList ) / sizeof( aStringList[ 0 ] );
+const sal_Int32 nDialogSize = sizeof( aDialogMatchList ) / sizeof( aDialogMatchList[ 0 ] );
 
+//liuchen modified 2009-2-27
 rtl::OUString 
 ScVbaDialog::mapIndexToName( sal_Int32 nIndex )
 {
-	if( nIndex < nDialogSize )
-		return aStringList[ nIndex ];
+	for (int i = 0; i < nDialogSize; i++)
+	{
+		if ( aDialogMatchList[i].nVbaDlgIndex == nIndex )
+		{
+			return aDialogMatchList[i].aOODlgName;
+		}
+	}
+	
 	return rtl::OUString();
 }
 
 rtl::OUString& 
 ScVbaDialog::getServiceImplName()
 {
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaPivotTable") );
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaDialog") );
 	return sImplName;
 }
 
@@ -113,7 +101,13 @@
 	if ( aServiceNames.getLength() == 0 )
 	{
 		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.PivotTable" ) );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Dialog" ) );
 	}
 	return aServiceNames;
 }
+
+//liuchen add 2009-7-27
+sal_Int32 ScVbaDialog::GetSupportedDialogCount()
+{
+	return nDialogSize;
+}
\ No newline at end of file
Index: sc/source/ui/vba/excelvbahelper.cxx
===================================================================
--- sc/source/ui/vba/excelvbahelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/excelvbahelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,222 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.cxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <docuno.hxx>
+#include "excelvbahelper.hxx"
+#include "tabvwsh.hxx"
+#include "transobj.hxx"
+#include "scmod.hxx"
+#include "cellsuno.hxx"
+#include <comphelper/processfactory.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+namespace ooo
+{
+namespace vba
+{
+namespace excel
+{
+void implSetZoom( const uno::Reference< frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs )
+{
+    ScTabViewShell* pViewSh = excel::getBestViewShell( xModel );
+    Fraction aFract( nZoom, 100 );
+    pViewSh->GetViewData()->SetZoom( aFract, aFract, nTabs );
+    pViewSh->RefreshZoom();
+}
+bool isInPrintPreview( SfxViewFrame* pView )
+{
+	sal_uInt16 nViewNo = SID_VIEWSHELL1 - SID_VIEWSHELL0;
+	if ( pView->GetObjectShell()->GetFactory().GetViewFactoryCount() >
+nViewNo && !pView->GetObjectShell()->IsInPlaceActive() )
+	{
+		SfxViewFactory &rViewFactory =
+			pView->GetObjectShell()->GetFactory().GetViewFactory(nViewNo);
+		if (  pView->GetCurViewId() == rViewFactory.GetOrdinal() )
+			return true;
+	}
+	return false;
+}
+
+const ::rtl::OUString REPLACE_CELLS_WARNING(  RTL_CONSTASCII_USTRINGPARAM( "ReplaceCellsWarning"));
+
+class PasteCellsWarningReseter
+{
+private:
+	bool bInitialWarningState;
+	static uno::Reference< beans::XPropertySet > getGlobalSheetSettings() throw ( uno::RuntimeException )
+	{
+		static uno::Reference< beans::XPropertySet > xTmpProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		static uno::Reference<uno::XComponentContext > xContext( xTmpProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		static uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+				xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+		static uno::Reference< beans::XPropertySet > xProps( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sheet.GlobalSheetSettings" ) ) ,xContext ), uno::UNO_QUERY_THROW );
+		return xProps;
+	}
+
+	bool getReplaceCellsWarning() throw ( uno::RuntimeException )
+	{
+		sal_Bool res = sal_False;
+		getGlobalSheetSettings()->getPropertyValue( REPLACE_CELLS_WARNING ) >>= res;
+		return ( res == sal_True );
+	}
+
+	void setReplaceCellsWarning( bool bState ) throw ( uno::RuntimeException )
+	{
+		getGlobalSheetSettings()->setPropertyValue( REPLACE_CELLS_WARNING, uno::makeAny( bState ) );
+	}
+public:
+	PasteCellsWarningReseter() throw ( uno::RuntimeException )
+	{
+		bInitialWarningState = getReplaceCellsWarning();
+		if ( bInitialWarningState )
+			setReplaceCellsWarning( false );
+	}
+	~PasteCellsWarningReseter()
+	{
+		if ( bInitialWarningState )
+		{
+			// don't allow dtor to throw
+			try
+			{
+				setReplaceCellsWarning( true );
+			}
+			catch ( uno::Exception& /*e*/ ){}
+		}
+	}
+};
+
+void
+implnPaste( const uno::Reference< frame::XModel>& xModel )
+{
+	PasteCellsWarningReseter resetWarningBox;
+	ScTabViewShell* pViewShell = getBestViewShell( xModel );
+	if ( pViewShell )
+	{
+		pViewShell->PasteFromSystem();
+		pViewShell->CellContentChanged();
+	}
+}
+
+
+void
+implnCopy( const uno::Reference< frame::XModel>& xModel )
+{
+	ScTabViewShell* pViewShell = getBestViewShell( xModel );
+	if ( pViewShell )
+		pViewShell->CopyToClip(NULL,false,false,true);
+}
+
+void 
+implnCut( const uno::Reference< frame::XModel>& xModel )
+{
+	ScTabViewShell* pViewShell =  getBestViewShell( xModel );
+	if ( pViewShell )
+		pViewShell->CutToClip( NULL, TRUE );
+}
+
+void implnPasteSpecial( const uno::Reference< frame::XModel>& xModel, USHORT nFlags,USHORT nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose)
+{
+	PasteCellsWarningReseter resetWarningBox;
+	sal_Bool bAsLink(sal_False), bOtherDoc(sal_False);
+	InsCellCmd eMoveMode = INS_NONE;
+
+	ScTabViewShell* pTabViewShell = getBestViewShell( xModel );
+	if ( pTabViewShell )
+	{
+		ScViewData* pView = pTabViewShell->GetViewData();	
+		Window* pWin = ( pView != NULL ) ? pView->GetActiveWin() : NULL;
+		if ( pView && pWin )
+		{
+			if ( bAsLink && bOtherDoc )
+				pTabViewShell->PasteFromSystem(0);//SOT_FORMATSTR_ID_LINK
+			else 
+			{
+				ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( pWin );
+				ScDocument* pDoc = NULL; 
+				if ( pOwnClip )
+					pDoc = pOwnClip->GetDocument();	
+				pTabViewShell->PasteFromClip( nFlags, pDoc,
+					nFunction, bSkipEmpty, bTranspose, bAsLink,
+					eMoveMode, IDF_NONE, TRUE );
+				pTabViewShell->CellContentChanged();
+			}
+		}
+	}
+
+}
+
+ScDocShell* 
+getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) 
+{
+	uno::Reference< uno::XInterface > xIf( xModel, uno::UNO_QUERY_THROW );
+	ScModelObj* pModel = dynamic_cast< ScModelObj* >( xIf.get() );
+	ScDocShell* pDocShell = NULL;
+	if ( pModel )
+		pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
+	return pDocShell;
+
+}
+
+ScTabViewShell* 
+getBestViewShell( const css::uno::Reference< css::frame::XModel>& xModel )
+{
+	ScDocShell* pDocShell = getDocShell( xModel );
+	if ( pDocShell )
+		return pDocShell->GetBestViewShell();
+	return NULL;
+}
+
+ScTabViewShell* 
+getCurrentBestViewShell(  const uno::Reference< uno::XComponentContext >& xContext )
+{ 
+	uno::Reference< frame::XModel > xModel = getCurrentExcelDoc( xContext );
+	return getBestViewShell( xModel );
+}
+
+SfxViewFrame* 
+getViewFrame( const uno::Reference< frame::XModel >& xModel )
+{
+	ScTabViewShell* pViewShell = getBestViewShell( xModel );	
+	if ( pViewShell )
+		return pViewShell->GetViewFrame();
+	return NULL;
+}
+
+SfxItemSet*
+ScVbaCellRangeAccess::GetDataSet( ScCellRangeObj* pRangeObj )
+{
+	SfxItemSet* pDataSet = pRangeObj ? pRangeObj->GetCurrentDataSet( true ) : NULL ;
+	return pDataSet;
+	
+}
+} //excel
+} //vba 
+} //ooo 
Index: sc/source/ui/vba/vbapivottables.hxx
===================================================================
--- sc/source/ui/vba/vbapivottables.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapivottables.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,9 +36,9 @@
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
  
-#include "vbahelper.hxx"
-#include "vbahelperinterface.hxx"
-#include "vbacollectionimpl.hxx"
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
 
 
 typedef CollTestImplHelper< ov::excel::XPivotTables > ScVbaPivotTables_BASE;
Index: sc/source/ui/vba/vbapagesetup.hxx
===================================================================
--- sc/source/ui/vba/vbapagesetup.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagesetup.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,39 +35,28 @@
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/sheet/XSpreadsheet.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbapagesetupbase.hxx>
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XPageSetup > ScVbaPageSetup_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaPageSetupBase, ov::excel::XPageSetup > ScVbaPageSetup_BASE;
 
 class ScVbaPageSetup :  public ScVbaPageSetup_BASE 
 {
     css::uno::Reference< css::sheet::XSpreadsheet > mxSheet;
-    css::uno::Reference< css::beans::XPropertySet > mxPageProps;
-    css::uno::Reference< css::frame::XModel > mxModel;
 public:
 	ScVbaPageSetup( const css::uno::Reference< ov::XHelperInterface >& xParent, 
                     const css::uno::Reference< css::uno::XComponentContext >& xContext,
 		            const css::uno::Reference< css::sheet::XSpreadsheet>& xSheet,
-                    const css::uno::Reference< css::frame::XModel >& xModlel) throw (css::uno::RuntimeException); 
+                    const css::uno::Reference< css::frame::XModel >& xModel) throw (css::uno::RuntimeException); 
 	virtual ~ScVbaPageSetup(){}
     
     // Attribute
 	virtual rtl::OUString SAL_CALL getPrintArea() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setPrintArea( const rtl::OUString& rAreas ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getTopMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setTopMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getBottomMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setBottomMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getRightMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setRightMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getLeftMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setLeftMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getHeaderMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setHeaderMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual double SAL_CALL getFooterMargin() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setFooterMargin( double margin ) throw (css::uno::RuntimeException);
-	virtual sal_Int32 SAL_CALL getOrientation() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setOrientation( sal_Int32 orientation ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getHeaderMargin() throw (css::uno::RuntimeException);
+    void SAL_CALL setHeaderMargin( double margin ) throw (css::uno::RuntimeException);
+    double SAL_CALL getFooterMargin() throw (css::uno::RuntimeException);
+    void SAL_CALL setFooterMargin( double margin ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL getFitToPagesTall() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setFitToPagesTall( const css::uno::Any& fitToPagesTall ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL getFitToPagesWide() throw (css::uno::RuntimeException);
Index: sc/source/ui/vba/vbaapplication.cxx
===================================================================
--- sc/source/ui/vba/vbaapplication.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaapplication.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -43,6 +43,7 @@
 #include <ooo/vba/excel/XlMousePointer.hpp>
 #include <com/sun/star/sheet/XNamedRanges.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include<ooo/vba/XCommandBars.hpp>
 
 #include "vbaapplication.hxx"
 #include "vbaworkbooks.hxx"
@@ -54,14 +55,15 @@
 #include "vbawindow.hxx"
 #include "vbawindows.hxx"
 #include "vbaglobals.hxx"
+#include "vbamenubars.hxx"
 #include "tabvwsh.hxx"
 #include "gridwin.hxx"
 #include "vbanames.hxx"
-#include "vbashape.hxx"
+#include <vbahelper/vbashape.hxx>
 #include "vbatextboxshape.hxx"
 #include "vbaassistant.hxx"
-#include "vbacommandbars.hxx"
 #include "sc.hrc"
+#include "macromgr.hxx"
 
 #include <osl/file.hxx>
 
@@ -84,10 +86,24 @@
 
 #include "convuno.hxx"
 #include "cellsuno.hxx"
+#include "miscuno.hxx"
+#include "unonames.hxx"
 #include "docsh.hxx"
+#include <vbahelper/helperdecl.hxx>
+#include "excelvbahelper.hxx"
 
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbx.hxx>
+#include <basic/sbxobj.hxx>
+#include <basic/sbuno.hxx>
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::rtl::OUString;
 
 // Enable our own join detection for Intersection and Union
 // should be more efficient than using ScRangeList::Join ( because
@@ -102,20 +118,20 @@
 #define FILE_PATH_SEPERATOR "\\"
 #endif 
 
-#define EXCELVERSION "11.0"
+uno::Any sbxToUnoValue( SbxVariable* pVar );
 
 class ActiveWorkbook : public ScVbaWorkbook
 {
 protected:
 	virtual uno::Reference< frame::XModel > getModel()
 	{ 	
-		return getCurrentDocument(); 
+		return getCurrentExcelDoc(mxContext); 
 	}
 public:
 	ActiveWorkbook( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext) : ScVbaWorkbook(  xParent, xContext ){}
 };
 
-ScVbaApplication::ScVbaApplication( uno::Reference<uno::XComponentContext >& xContext ): ScVbaApplication_BASE( uno::Reference< XHelperInterface >(), xContext ), m_xCalculation( excel::XlCalculation::xlCalculationAutomatic )
+ScVbaApplication::ScVbaApplication( const uno::Reference<uno::XComponentContext >& xContext ): ScVbaApplication_BASE( xContext ), m_xCalculation( excel::XlCalculation::xlCalculationAutomatic )
 {
 }
 
@@ -123,8 +139,11 @@
 {
 }
 	
+SfxObjectShell* ScVbaApplication::GetDocShell( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    return static_cast< SfxObjectShell* >( excel::getDocShell( xModel ) );
+}
 
-
 uno::Reference< excel::XWorkbook >
 ScVbaApplication::getActiveWorkbook() throw (uno::RuntimeException)
 {
@@ -143,23 +162,35 @@
 }
 
 uno::Any SAL_CALL
-ScVbaApplication::CommandBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
-{
-    uno::Reference< XCommandBars > xCommandBars( new ScVbaCommandBars( this, mxContext, uno::Reference< container::XIndexAccess >() ) );
-    if( aIndex.hasValue() )
-        return uno::makeAny( xCommandBars->Item( aIndex, uno::Any() ) );
-    return uno::makeAny( xCommandBars );
-}
-
-uno::Any SAL_CALL
 ScVbaApplication::getSelection() throw (uno::RuntimeException)
 {
     OSL_TRACE("** ScVbaApplication::getSelection() ** ");
-    uno::Reference< lang::XServiceInfo > xServiceInfo( getCurrentDocument()->getCurrentSelection(), uno::UNO_QUERY_THROW );
-    rtl::OUString sImpementaionName = xServiceInfo->getImplementationName();
-    if( sImpementaionName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+    uno::Reference< frame::XModel > xModel( getCurrentDocument() );
+
+    Reference< view::XSelectionSupplier > xSelSupp( xModel->getCurrentController(), UNO_QUERY_THROW );
+    Reference< beans::XPropertySet > xPropSet( xSelSupp, UNO_QUERY_THROW );
+    OUString aPropName = OUString::createFromAscii( SC_UNO_FILTERED_RANGE_SELECTION );
+    uno::Any aOldVal = xPropSet->getPropertyValue( aPropName );
+    uno::Any any;
+    any <<= sal_False;
+    xPropSet->setPropertyValue( aPropName, any );
+    uno::Reference< uno::XInterface > aSelection = ScUnoHelpFunctions::AnyToInterface(
+        xSelSupp->getSelection() );
+    xPropSet->setPropertyValue( aPropName, aOldVal );
+
+    if (!aSelection.is())
     {
-        uno::Reference< drawing::XShapes > xShapes( getCurrentDocument()->getCurrentSelection(), uno::UNO_QUERY_THROW );
+        throw uno::RuntimeException( 
+            rtl::OUString::createFromAscii("failed to obtain current selection"), 
+            uno::Reference< uno::XInterface >() );
+    }
+
+    uno::Reference< lang::XServiceInfo > xServiceInfo( aSelection, uno::UNO_QUERY_THROW );
+    rtl::OUString sImplementationName = xServiceInfo->getImplementationName();
+
+    if( sImplementationName.equalsIgnoreAsciiCaseAscii("com.sun.star.drawing.SvxShapeCollection") )
+    {
+        uno::Reference< drawing::XShapes > xShapes( aSelection, uno::UNO_QUERY_THROW );
         uno::Reference< container::XIndexAccess > xIndexAccess( xShapes, uno::UNO_QUERY_THROW );
         uno::Reference< drawing::XShape > xShape( xIndexAccess->getByIndex(0), uno::UNO_QUERY_THROW );
 	// if ScVbaShape::getType( xShape ) == office::MsoShapeType::msoAutoShape
@@ -170,18 +201,18 @@
 		uno::Reference< lang::XServiceInfo > xShapeServiceInfo( xShape, uno::UNO_QUERY_THROW );
 		if ( xShapeServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.Text" ) ) )  )
 		{
-        		return uno::makeAny( uno::Reference< msforms::XTextBoxShape >(new ScVbaTextBoxShape( mxContext, xShape, xShapes, getCurrentDocument() ) ) );
+                return uno::makeAny( uno::Reference< msforms::XTextBoxShape >(new ScVbaTextBoxShape( mxContext, xShape, xShapes, xModel ) ) );
 		}
 	}
-        return uno::makeAny( uno::Reference< msforms::XShape >(new ScVbaShape( this, mxContext, xShape, xShapes, ScVbaShape::getType( xShape ) ) ) );
+        return uno::makeAny( uno::Reference< msforms::XShape >(new ScVbaShape( this, mxContext, xShape, xShapes, xModel, ScVbaShape::getType( xShape ) ) ) );
     }
     else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRange")) ||
              xServiceInfo->supportsService( rtl::OUString::createFromAscii("com.sun.star.sheet.SheetCellRanges")))
     {
-	    uno::Reference< table::XCellRange > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	    uno::Reference< table::XCellRange > xRange( aSelection, ::uno::UNO_QUERY);
 	    if ( !xRange.is() )
 	    {
-		    uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+		    uno::Reference< sheet::XSheetCellRangeContainer > xRanges( aSelection, ::uno::UNO_QUERY);
 		    if ( xRanges.is() )
 			    return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( this, mxContext, xRanges ) ) );
 
@@ -190,7 +221,7 @@
     }
     else
     {
-        throw uno::RuntimeException( sImpementaionName + rtl::OUString::createFromAscii(" donot be surpported"), uno::Reference< uno::XInterface >() );
+        throw uno::RuntimeException( sImplementationName + rtl::OUString::createFromAscii(" not surpported"), uno::Reference< uno::XInterface >() );
     }
 }
 
@@ -199,7 +230,7 @@
 {
 	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY_THROW );
 	uno::Reference< table::XCellRange > xRange( xView->getActiveSheet(), ::uno::UNO_QUERY_THROW);
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	ScTabViewShell* pViewShell = excel::getCurrentBestViewShell(mxContext);
 	if ( !pViewShell )
 		throw uno::RuntimeException( rtl::OUString::createFromAscii("No ViewShell available"), uno::Reference< uno::XInterface >() );
 	ScViewData* pTabView = pViewShell->GetViewData();
@@ -212,65 +243,6 @@
 	return  new ScVbaRange( this, mxContext, xRange->getCellRangeByPosition( nCursorX, nCursorY, nCursorX, nCursorY ) );
 }
 
-sal_Bool
-ScVbaApplication::getScreenUpdating() throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-	return !xModel->hasControllersLocked();
-}
-
-void
-ScVbaApplication::setScreenUpdating(sal_Bool bUpdate) throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-	if (bUpdate)
-		xModel->unlockControllers();
-	else
-		xModel->lockControllers();
-}
-
-sal_Bool
-ScVbaApplication::getDisplayStatusBar() throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
-
-    if( xProps.is() ){
-        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
-        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
-        if( xLayoutManager.is() && xLayoutManager->isElementVisible( url ) ){
-            return sal_True;
-        }
-    }
-    return sal_False;
-}
-
-void
-ScVbaApplication::setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
-
-    if( xProps.is() ){
-        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
-        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
-        if( xLayoutManager.is() ){
-            if( bDisplayStatusBar && !xLayoutManager->isElementVisible( url ) ){
-                if( !xLayoutManager->showElement( url ) )
-                    xLayoutManager->createElement( url );
-                return;
-            }
-            else if( !bDisplayStatusBar && xLayoutManager->isElementVisible( url ) ){
-                xLayoutManager->hideElement( url ); 
-                return;
-            }
-        }
-    }
-    return;
-}
-
 uno::Any SAL_CALL
 ScVbaApplication::Workbooks( const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
@@ -319,7 +291,7 @@
 uno::Any 
 ScVbaApplication::Dialogs( const uno::Any &aIndex ) throw (uno::RuntimeException)
 {
-	uno::Reference< excel::XDialogs > xDialogs( new ScVbaDialogs( uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( mxContext )->getApplication(), uno::UNO_QUERY_THROW ), mxContext ) );
+	uno::Reference< excel::XDialogs > xDialogs( new ScVbaDialogs( uno::Reference< XHelperInterface >( this ), mxContext, getCurrentDocument() ) );
 	if( !aIndex.hasValue() )
 		return uno::Any( xDialogs );
 	return uno::Any( xDialogs->Item( aIndex ) );
@@ -341,12 +313,6 @@
 	return result;
 }
 
-::rtl::OUString
-ScVbaApplication::getVersion() throw (uno::RuntimeException)
-{
-	return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(EXCELVERSION));
-}
-
 void SAL_CALL 
 ScVbaApplication::setCutCopyMode( const uno::Any& /*_cutcopymode*/ ) throw (uno::RuntimeException)
 {
@@ -432,7 +398,7 @@
 uno::Any SAL_CALL 
 ScVbaApplication::Windows( const uno::Any& aIndex  ) throw (uno::RuntimeException)
 {
-	uno::Reference< XCollection >  xWindows = ScVbaWindows::Windows( mxContext );
+	uno::Reference< excel::XWindows >  xWindows( new ScVbaWindows( this, mxContext ) );
 	if ( aIndex.getValueTypeClass() == uno::TypeClass_VOID )
 		return uno::Any( xWindows );
 	return uno::Any( xWindows->Item( aIndex, uno::Any() ) );	
@@ -543,11 +509,11 @@
                 xModel->getCurrentController(), uno::UNO_QUERY_THROW );
         uno::Reference< sheet::XSpreadsheet > xDoc = xSpreadsheet->getActiveSheet();
 
-        ScTabViewShell* pShell = getCurrentBestViewShell();
+        ScTabViewShell* pShell = excel::getCurrentBestViewShell( mxContext );
         ScGridWindow* gridWindow = (ScGridWindow*)pShell->GetWindow(); 
         try
         {
-            uno::Reference< excel::XRange > xVbaSheetRange = ScVbaRange::getRangeObjectForName( mxContext, sRangeName, getDocShell( xModel ), formula::FormulaGrammar::CONV_XL_R1C1 );
+            uno::Reference< excel::XRange > xVbaSheetRange = ScVbaRange::getRangeObjectForName( mxContext, sRangeName, excel::getDocShell( xModel ), formula::FormulaGrammar::CONV_XL_R1C1 );
 ;
             if( bScroll )
             {
@@ -585,7 +551,7 @@
     if( Reference >>= xRange )
     {
         uno::Reference< excel::XRange > xVbaRange( Reference, uno::UNO_QUERY );
-        ScTabViewShell* pShell = getCurrentBestViewShell();
+        ScTabViewShell* pShell = excel::getCurrentBestViewShell( mxContext );
         ScGridWindow* gridWindow = (ScGridWindow*)pShell->GetWindow(); 
         if ( xVbaRange.is() )
         {
@@ -615,38 +581,10 @@
             uno::Reference< uno::XInterface >() );
 }
 
-namespace
-{
-    static uno::Reference< frame::XController > lcl_getCurrentController()
-    {
-        const uno::Reference< frame::XModel > xWorkingDoc( SfxObjectShell::GetCurrentComponent(), uno::UNO_QUERY );
-        uno::Reference< frame::XController > xController;
-        if ( xWorkingDoc.is() )
-            xController.set( xWorkingDoc->getCurrentController(), uno::UNO_SET_THROW );
-        else
-            xController.set( SfxObjectShell::GetCurrentComponent(), uno::UNO_QUERY_THROW );
-        return xController;
-    }
-}
-
 sal_Int32 SAL_CALL
 ScVbaApplication::getCursor() throw (uno::RuntimeException)
 {
-    sal_Int32 nPointerStyle( POINTER_ARROW );
-    try
-    {
-        const uno::Reference< frame::XController > xController( lcl_getCurrentController(),     uno::UNO_SET_THROW );
-        const uno::Reference< frame::XFrame >      xFrame     ( xController->getFrame(),        uno::UNO_SET_THROW );
-        const uno::Reference< awt::XWindow >       xWindow    ( xFrame->getContainerWindow(),   uno::UNO_SET_THROW );
-        // why the heck isn't there an XWindowPeer::getPointer, but a setPointer only?
-        const Window* pWindow = VCLUnoHelper::GetWindow( xWindow );
-        if ( pWindow )
-            nPointerStyle = pWindow->GetSystemWindow()->GetPointer().GetStyle();
-    }
-    catch( const uno::Exception& )
-    {
-    	DBG_UNHANDLED_EXCEPTION();
-    }
+    sal_Int32 nPointerStyle =  getPointerStyle(getCurrentDocument());
 
     switch( nPointerStyle )
     {
@@ -668,82 +606,35 @@
 {
     try
     {
-        ::std::vector< uno::Reference< frame::XController > > aControllers;
-
-        const uno::Reference< frame::XModel2 > xModel2( SfxObjectShell::GetCurrentComponent(), uno::UNO_QUERY );
-        if ( xModel2.is() )
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+        switch( _cursor )
         {
-            const uno::Reference< container::XEnumeration > xEnumControllers( xModel2->getControllers(), uno::UNO_SET_THROW );
-            while ( xEnumControllers->hasMoreElements() )
+            case excel::XlMousePointer::xlNorthwestArrow:
             {
-                const uno::Reference< frame::XController > xController( xEnumControllers->nextElement(), uno::UNO_QUERY_THROW );
-                aControllers.push_back( xController );
+                const Pointer& rPointer( POINTER_ARROW );
+                setCursorHelper( xModel, rPointer, sal_False );
+                break;
             }
-        }
-        else
-        {
-            const uno::Reference< frame::XModel > xModel( SfxObjectShell::GetCurrentComponent(), uno::UNO_QUERY );
-            if ( xModel.is() )
+            case excel::XlMousePointer::xlWait:
+            case excel::XlMousePointer::xlIBeam:
             {
-                const uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_SET_THROW );
-                aControllers.push_back( xController );
+                const Pointer& rPointer( static_cast< PointerStyle >( _cursor ) );
+                //It will set the edit window, toobar and statusbar's mouse pointer.
+                setCursorHelper( xModel, rPointer, sal_True );
+                break;
             }
-            else
+            case excel::XlMousePointer::xlDefault:
             {
-                const uno::Reference< frame::XController > xController( SfxObjectShell::GetCurrentComponent(), uno::UNO_QUERY_THROW );
-                aControllers.push_back( xController );
+                const Pointer& rPointer( POINTER_NULL );
+                setCursorHelper( xModel, rPointer, sal_False );
+                break;
             }
-        }
-
-        for (   ::std::vector< uno::Reference< frame::XController > >::const_iterator controller = aControllers.begin();
-                controller != aControllers.end();
-                ++controller
-            )
-        {
-            const uno::Reference< frame::XFrame >      xFrame     ( (*controller)->getFrame(),       uno::UNO_SET_THROW   );
-            const uno::Reference< awt::XWindow >       xWindow    ( xFrame->getContainerWindow(),    uno::UNO_SET_THROW   );
-
-            Window* pWindow = VCLUnoHelper::GetWindow( xWindow );
-            OSL_ENSURE( pWindow, "ScVbaApplication::setCursor: no window!" );
-            if ( !pWindow )
-                continue;
-
-            switch( _cursor )
-            {
-                case excel::XlMousePointer::xlNorthwestArrow:
-                {
-                    const Pointer& rPointer( POINTER_ARROW );
-                    pWindow->GetSystemWindow()->SetPointer( rPointer );
-                    pWindow->GetSystemWindow()->EnableChildPointerOverwrite( sal_False );
-                    break;
-                }
-                case excel::XlMousePointer::xlWait:
-                case excel::XlMousePointer::xlIBeam:
-                {
-                    const Pointer& rPointer( static_cast< PointerStyle >( _cursor ) );
-                    //It will set the edit window, toobar and statusbar's mouse pointer.
-                    pWindow->GetSystemWindow()->SetPointer( rPointer );
-                    pWindow->GetSystemWindow()->EnableChildPointerOverwrite( sal_True );
-                    //It only set the edit window's mouse pointer
-                    //pWindow->.SetPointer( rPointer );
-                    //pWindow->.EnableChildPointerOverwrite( sal_True );
-                    //printf("\nset Cursor...%d\n", pWindow->.GetType());
-                    break;
-                }
-                case excel::XlMousePointer::xlDefault:
-                {
-                    const Pointer& rPointer( POINTER_NULL );
-                    pWindow->GetSystemWindow()->SetPointer( rPointer );
-                    pWindow->GetSystemWindow()->EnableChildPointerOverwrite( sal_False );
-                    break;
-                }
-                default:
-                    throw uno::RuntimeException( rtl::OUString( 
-                            RTL_CONSTASCII_USTRINGPARAM("Unknown value for Cursor pointer")), uno::Reference< uno::XInterface >() );
-                    // TODO: isn't this a flaw in the API? It should be allowed to throw an
-                    // IllegalArgumentException, or so
-            }
-        }
+            default:
+                throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Unknown value for Cursor pointer")), uno::Reference< uno::XInterface >() );
+                // TODO: isn't this a flaw in the API? It should be allowed to throw an
+                // IllegalArgumentException, or so
+        }        
     }
     catch( const uno::Exception& )
     {
@@ -1117,7 +1008,7 @@
 	}
 
 	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-	ScDocShell* pDocShell = getDocShell( xModel );
+	ScDocShell* pDocShell = excel::getDocShell( xModel );
 	if ( aCellRanges.Count() == 1 )
 	{
 		xRefRange = new ScVbaRange( uno::Reference< XHelperInterface >(), mxContext, new ScCellRangeObj( pDocShell, *aCellRanges.First() ) );
@@ -1206,7 +1097,7 @@
 		aCellRanges.Append( *it );
 
 	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-    ScDocShell* pDocShell = getDocShell( xModel ); 
+    ScDocShell* pDocShell = excel::getDocShell( xModel ); 
 	if ( aCellRanges.Count() == 1 ) 
 	{
 	// normal range
@@ -1227,30 +1118,24 @@
 {
 	sal_Bool bVolatile = sal_True;
 	aVolatile >>= bVolatile;
-	return; 
-/*
-	if ( bVolatile )
-		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Volatile - not supported" ) ), uno::Reference< uno::XInterface >() );
-	// bVoloatile is false - currently this only would make sense if 
-	// the autocalculate mode is set to be true.
+    SbMethod* pMeth = StarBASIC::GetActiveMethod();
+    if ( pMeth )
+    {
+        OSL_TRACE("ScVbaApplication::Volatile() In method ->%s<-", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+        uno::Reference< frame::XModel > xModel( getCurrentDocument() );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        pDoc->GetMacroManager()->SetUserFuncVolatile( pMeth->GetName(), bVolatile);
+    }
 
-	// so really this is crap, #TODO try and understand how ( or if ) 
-	// the calculation mode and volatile interoperate
-	if ( ! getCalculation() == excel::XlCalculation::xlCalculationAutomatic )
-		setCalculation(  excel::XlCalculation::xlCalculationAutomatic );
-*/
+// this is bound to break when loading the document
+	return; 
 }
 
-void SAL_CALL
-ScVbaApplication::DoEvents() throw ( uno::RuntimeException )
-{
-}
-
 ::sal_Bool SAL_CALL 
 ScVbaApplication::getDisplayFormulaBar() throw ( css::uno::RuntimeException )
 {
 	sal_Bool bRes = sal_False;
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	ScTabViewShell* pViewShell = excel::getCurrentBestViewShell( mxContext );
 	if ( pViewShell )
 	{
 		SfxBoolItem sfxFormBar( FID_TOGGLEINPUTLINE);
@@ -1268,7 +1153,7 @@
 void SAL_CALL 
 ScVbaApplication::setDisplayFormulaBar( ::sal_Bool _displayformulabar ) throw ( css::uno::RuntimeException )
 {
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	ScTabViewShell* pViewShell = excel::getCurrentBestViewShell( mxContext );
 	if ( pViewShell && ( _displayformulabar !=  getDisplayFormulaBar() ) )
 	{
 		SfxBoolItem sfxFormBar( FID_TOGGLEINPUTLINE, _displayformulabar);
@@ -1278,6 +1163,44 @@
 	}	
 }
 
+uno::Any SAL_CALL 
+ScVbaApplication::Caller( const uno::Any& /*aIndex*/ ) throw ( uno::RuntimeException )
+{
+	StarBASIC* pBasic = SFX_APP()->GetBasic();
+	SFX_APP()->EnterBasicCall();
+	SbMethod* pMeth = (SbMethod*)pBasic->GetRtl()->Find( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FuncCaller") ), SbxCLASS_METHOD );
+	uno::Any aRet;	
+	if ( pMeth )
+	{
+		SbxVariableRef refTemp = pMeth;
+		// forces a broadcast
+		SbxVariableRef pNew = new  SbxMethod( *((SbxMethod*)pMeth));
+                OSL_TRACE("pNew has type %d and string value %s", pNew->GetType(), rtl::OUStringToOString( pNew->GetString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+		aRet = sbxToUnoValue( pNew );
+	}
+	SFX_APP()->LeaveBasicCall();
+	return aRet;
+}
+
+uno::Reference< frame::XModel > 
+ScVbaApplication::getCurrentDocument() throw (css::uno::RuntimeException)
+{
+    return getCurrentExcelDoc(mxContext);
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCommandBars > xCommandBars( CommandBars( uno::Any() ), uno::UNO_QUERY_THROW );
+	uno::Reference< XCollection > xMenuBars( new ScVbaMenuBars( this, mxContext, xCommandBars ) );
+	if (  aIndex.hasValue() )
+	{
+	    return uno::Any ( xMenuBars->Item( aIndex, uno::Any() ) );
+	}
+
+	return uno::Any( xMenuBars );
+}
+
 rtl::OUString& 
 ScVbaApplication::getServiceImplName()
 {
@@ -1296,3 +1219,13 @@
 	}
 	return aServiceNames;
 }
+
+namespace application
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaApplication, sdecl::with_args<false> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaApplication",
+    "ooo.vba.excel.Application" );
+}
Index: sc/source/ui/vba/vbapagebreaks.cxx
===================================================================
--- sc/source/ui/vba/vbapagebreaks.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagebreaks.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -90,8 +90,8 @@
 	virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException);
 	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
 	{
-		//if( m_bColumn )
-			// return excel::XVPageBreak::static_type(0);
+		if( m_bColumn )
+			 return excel::XVPageBreak::static_type(0);
 		return  excel::XHPageBreak::static_type(0);
 	}
 	virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
@@ -118,10 +118,13 @@
     for( sal_Int32 i=0; i<nLength; i++ )
     {
         sal_Int32 nPos = aTablePageBreakData[i].Position;
-        if( nPos > nUsedEnd )
-            return nCount;
-        if( nPos >= nUsedStart )
-            nCount++;
+
+		// VBA. minz@cn.ibm.com. All page breaks before the used range should be counted. 
+		// And the page break at the end of the used range also should be counted.
+		if(  nPos <= nUsedEnd + 1 )
+			nCount++;
+		else
+			return nCount;
     }
 
     return nCount;
@@ -137,8 +140,8 @@
         if( (nPos < xIndexAccess->getCount()) && (nPos > -1) )
         {
             uno::Reference< beans::XPropertySet > xRowColPropertySet( xIndexAccess->getByIndex(nPos), uno::UNO_QUERY_THROW );
-			//if( m_bColumn )
-			//	return uno::makeAny( uno::Reference< excel::XVPageBreak >( new ScVbaVPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
+			if( m_bColumn )
+				return uno::makeAny( uno::Reference< excel::XVPageBreak >( new ScVbaVPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
 			return uno::makeAny( uno::Reference< excel::XHPageBreak >( new ScVbaHPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
         }
     }
@@ -156,17 +159,9 @@
     uno::Sequence<sheet::TablePageBreakData> aTablePageBreakDataList = getAllPageBreaks();
 
     sal_Int32 nLength = aTablePageBreakDataList.getLength();
-    for( sal_Int32 i=0; i<nLength; i++ )
-    {
-        aTablePageBreakData = aTablePageBreakDataList[i];
-        sal_Int32 nPos = aTablePageBreakData.Position;
-        if( nPos >= nUsedStart )
-            index++;
-        if( nPos > nUsedEnd )
-            DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
-        if( index == nAPIItemIndex )
-            return aTablePageBreakData;
-    }
+    //VBA. minz@cn.ibm.com. No need to filter the page break. All page breaks before the used range are counted.
+    if ( nAPIItemIndex < nLength && nAPIItemIndex>=0 )
+        aTablePageBreakData = aTablePageBreakDataList[nAPIItemIndex];
 
     return aTablePageBreakData;
 }
@@ -187,8 +182,8 @@
 	sheet::TablePageBreakData aTablePageBreakData;
 	aTablePageBreakData.ManualBreak = sal_True;
 	aTablePageBreakData.Position = nAPIRowColIndex;
-	//if( m_bColumn )
-	//	return uno::makeAny( uno::Reference< excel::XVPageBreak >( new ScVbaVPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
+	if( m_bColumn )
+		return uno::makeAny( uno::Reference< excel::XVPageBreak >( new ScVbaVPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
 	return uno::makeAny( uno::Reference< excel::XHPageBreak >( new ScVbaHPageBreak( mxParent, mxContext, xRowColPropertySet, aTablePageBreakData) ));
 }
 
@@ -267,3 +262,64 @@
 	return aServiceNames;
 }
 
+//VPageBreak
+ScVbaVPageBreaks::ScVbaVPageBreaks( const uno::Reference< XHelperInterface >& xParent, 
+                                    const uno::Reference< uno::XComponentContext >& xContext,
+            		                uno::Reference< sheet::XSheetPageBreak >& xSheetPageBreak ) throw ( uno::RuntimeException )
+:   ScVbaVPageBreaks_BASE( xParent, xContext, new RangePageBreaks( xParent, xContext, xSheetPageBreak, sal_True ) ), 
+	mxSheetPageBreak( xSheetPageBreak )
+{
+}
+
+ScVbaVPageBreaks::~ScVbaVPageBreaks()
+{
+}
+
+uno::Any SAL_CALL 
+ScVbaVPageBreaks::Add( const uno::Any& Before ) throw ( script::BasicErrorException, uno::RuntimeException )
+{
+	RangePageBreaks* pPageBreaks = dynamic_cast< RangePageBreaks* >( m_xIndexAccess.get() );
+	if( pPageBreaks )
+	{
+		return pPageBreaks->Add( Before );
+	}
+	return uno::Any();
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaVPageBreaks::createEnumeration() throw ( uno::RuntimeException )
+{
+	return new RangePageBreaksEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+ScVbaVPageBreaks::createCollectionObject( const css::uno::Any& aSource )
+{
+	return aSource; // its already a pagebreak object
+}
+
+uno::Type 
+ScVbaVPageBreaks::getElementType() throw ( uno::RuntimeException )
+{
+	return excel::XVPageBreak::static_type( 0 );
+}
+
+rtl::OUString& 
+ScVbaVPageBreaks::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM( "ScVbaVPageBreaks" ) );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaVPageBreaks::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.excel.VPageBreaks" ) );
+	}
+	return aServiceNames;
+}
+
Index: sc/source/ui/vba/vbaeventshelper.cxx
===================================================================
--- sc/source/ui/vba/vbaeventshelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbaeventshelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,1070 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.cxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaeventshelper.hxx"
+#include <vbahelper/helperdecl.hxx>
+#include <sfx2/objsh.hxx> 
+#include "scextopt.hxx"
+#include <sfx2/evntconf.hxx>
+#include <sfx2/event.hxx>
+#include <sfx2/sfx.hrc>
+#include <toolkit/unohlp.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/table/XCell.hpp> 
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/WindowEvent.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/util/XCloseListener.hpp>
+#include <com/sun/star/util/XCloseBroadcaster.hpp>
+#include <com/sun/star/frame/XControllerBorder.hpp>
+#include <com/sun/star/frame/XBorderResizeListener.hpp>
+#include <com/sun/star/util/XChangesListener.hpp>
+#include <com/sun/star/util/ElementChange.hpp>
+#include <com/sun/star/util/XChangesNotifier.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <cellsuno.hxx> 
+#include <convuno.hxx>
+#include <map>
+#include <svx/msvbahelper.hxx>
+#include <vcl/svapp.hxx>
+
+using namespace std;
+using namespace com::sun::star;
+using namespace ooo::vba;
+using namespace com::sun::star::document::VbaEventId;
+
+typedef ::cppu::WeakImplHelper1< util::XChangesListener > WorksheetChangeListener_BASE;
+
+class WorksheetChangeListener : public WorksheetChangeListener_BASE
+{
+private:
+    ScVbaEventsHelper* pVbaEventsHelper;
+public:
+    WorksheetChangeListener(ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper ){}
+    virtual void SAL_CALL changesOccurred(const util::ChangesEvent& aEvent) throw (uno::RuntimeException);
+    virtual void SAL_CALL disposing(const lang::EventObject& aSource) throw(uno::RuntimeException){}
+};
+
+void WorksheetChangeListener::changesOccurred(const util::ChangesEvent& aEvent) throw (uno::RuntimeException)
+{
+    sal_Int32 nCount = aEvent.Changes.getLength();
+    if( nCount == 0 )
+        return;
+    
+    util::ElementChange aChange = aEvent.Changes[ 0 ];
+    rtl::OUString sOperation;
+    aChange.Accessor >>= sOperation;
+    if( !sOperation.equalsIgnoreAsciiCaseAscii("cell-change") )
+        return;
+
+    if( nCount == 1 )
+    {
+        uno::Reference< table::XCellRange > xRangeObj;
+        aChange.ReplacedElement >>= xRangeObj;
+        if( xRangeObj.is() )
+        {
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[0] <<= xRangeObj;
+            pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CHANGE, aArgs );
+        }    
+        return;
+    }
+
+    ScRangeList aRangeList;
+    for( sal_Int32 nIndex = 0; nIndex < nCount; ++nIndex )
+    {
+        aChange = aEvent.Changes[ nIndex ];
+        aChange.Accessor >>= sOperation;
+        uno::Reference< table::XCellRange > xRangeObj;
+        aChange.ReplacedElement >>= xRangeObj;
+        if( xRangeObj.is() && sOperation.equalsIgnoreAsciiCaseAscii("cell-change") )
+        {
+            uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( xRangeObj, uno::UNO_QUERY );
+            if( xCellRangeAddressable.is() )
+            {
+                ScRange aRange;
+                ScUnoConversion::FillScRange( aRange, xCellRangeAddressable->getRangeAddress() );
+                aRangeList.Append( aRange );
+            }
+        }
+    }
+    
+    if( aRangeList.Count() > 0 )
+    {
+        uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pVbaEventsHelper->getDocumentShell(), aRangeList ) );
+        uno::Sequence< uno::Any > aArgs(1);
+        aArgs[0] <<= xRanges;
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_CHANGE, aArgs );
+    }
+}
+
+typedef ::cppu::WeakImplHelper3< awt::XWindowListener, util::XCloseListener, frame::XBorderResizeListener > WindowListener_BASE;
+
+// This class is to process Workbook window related event
+class VbaEventsListener : public WindowListener_BASE
+{
+    ::osl::Mutex m_aMutex;
+    ScVbaEventsHelper* pVbaEventsHelper;
+    uno::Reference< frame::XModel > m_xModel;
+    sal_Bool m_bWindowResized;
+    sal_Bool m_bBorderChanged;
+protected :
+    uno::Reference< awt::XWindow > GetContainerWindow();
+    uno::Reference< frame::XFrame > GetFrame();
+    sal_Bool IsMouseReleased();
+    DECL_LINK( fireResizeMacro, void* );
+    void processWindowResizeMacro();
+public :
+    VbaEventsListener( ScVbaEventsHelper* pHelper );
+    ~VbaEventsListener();
+    void startEventsLinstener();
+    void stopEventsLinstener();
+    // XWindowListener
+    virtual void SAL_CALL windowResized( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowMoved( const awt::WindowEvent& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowShown( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL windowHidden( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    virtual void SAL_CALL disposing( const lang::EventObject& aEvent ) throw ( uno::RuntimeException );
+    // XCloseListener
+    virtual void SAL_CALL queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException);
+    virtual void SAL_CALL notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException);
+    // XBorderResizeListener
+    virtual void SAL_CALL borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException);
+};
+VbaEventsListener::VbaEventsListener( ScVbaEventsHelper* pHelper ) : pVbaEventsHelper( pHelper )
+{
+    OSL_TRACE("VbaEventsListener::VbaEventsListener( 0x%x ) - ctor ", this );
+    m_xModel.set( pVbaEventsHelper->getDocument()->GetDocumentShell()->GetModel(), uno::UNO_QUERY );
+    m_bWindowResized = sal_False;
+    m_bBorderChanged = sal_False;
+}
+
+VbaEventsListener::~VbaEventsListener()
+{
+    OSL_TRACE("VbaEventsListener::~VbaEventsListener( 0x%x ) - dtor ", this );
+}
+uno::Reference< frame::XFrame > 
+VbaEventsListener::GetFrame()
+{
+    try
+    {
+        if( pVbaEventsHelper )
+        {
+            if( m_xModel.is() )
+            {
+                uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+                if( xController.is() )
+                {
+                    uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY );
+                    if( xFrame.is() )
+                    {
+                            return xFrame;
+                    }
+                }
+            }
+        }
+    }
+	catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< frame::XFrame >();
+}
+uno::Reference< awt::XWindow > 
+VbaEventsListener::GetContainerWindow() 
+{
+    try
+    {
+        uno::Reference< frame::XFrame > xFrame( GetFrame(), uno::UNO_QUERY );
+        if( xFrame.is() )
+        {
+            uno::Reference< awt::XWindow > xWindow( xFrame->getContainerWindow(), uno::UNO_QUERY );
+            if( xWindow.is() )
+                return xWindow;
+        }
+    }
+	catch( uno::Exception& /*e*/ )
+    {
+    }
+    return uno::Reference< awt::XWindow >();
+}
+sal_Bool
+VbaEventsListener::IsMouseReleased()
+{
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow )
+    {
+        Window::PointerState aPointerState = pWindow->GetPointerState();
+        if( !aPointerState.mnState & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
+            return sal_True; 
+    }
+    return sal_False;
+}
+void
+VbaEventsListener::startEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        // add window listener
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+            xWindow->addWindowListener( this );
+        // add close listener
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->addCloseListener( this );
+        }
+        // add Border resize listener
+        uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+        if( xController.is() )
+        {
+            uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+            if( xControllerBorder.is() )
+            {
+                xControllerBorder->addBorderResizeListener( this );
+            }
+        }
+    }
+}
+void
+VbaEventsListener::stopEventsLinstener()
+{
+    if( m_xModel.is() )
+    {
+        uno::Reference< awt::XWindow > xWindow( GetContainerWindow(), uno::UNO_QUERY );
+        if( xWindow.is() )
+        {
+            xWindow->removeWindowListener( this );
+        }
+        //uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( GetFrame(), uno::UNO_QUERY );
+        uno::Reference< util::XCloseBroadcaster > xCloseBroadcaster( m_xModel, uno::UNO_QUERY );
+        if( xCloseBroadcaster.is() )
+        {
+            xCloseBroadcaster->removeCloseListener( this );
+        }
+        uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY );
+        if( xController.is() )
+        {
+            uno::Reference< frame::XControllerBorder > xControllerBorder( xController, uno::UNO_QUERY );
+            if( xControllerBorder.is() )
+            {
+                xControllerBorder->removeBorderResizeListener( this );
+            }
+        }
+        pVbaEventsHelper = NULL;
+    }
+}
+
+void
+VbaEventsListener::processWindowResizeMacro()
+{
+    OSL_TRACE("**** Attempt to FIRE MACRO **** ");
+    if( pVbaEventsHelper )
+        pVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWRESIZE, uno::Sequence< uno::Any >() );
+}
+
+IMPL_LINK( VbaEventsListener, fireResizeMacro, void*, pParam )
+{
+    if ( pVbaEventsHelper ) 
+    {
+        if( IsMouseReleased() )
+                processWindowResizeMacro();
+    }
+    release();
+    return 0;
+}
+
+void SAL_CALL
+VbaEventsListener::windowResized(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    // Workbook_window_resize event
+    m_bWindowResized = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+
+    if( pWindow && m_bBorderChanged )
+    {
+        m_bBorderChanged = m_bWindowResized = sal_False;
+        acquire(); // ensure we don't get deleted before the event is handled
+        Application::PostUserEvent( LINK( this, VbaEventsListener, fireResizeMacro ), NULL );
+    }
+}
+void SAL_CALL
+VbaEventsListener::windowMoved(  const awt::WindowEvent& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowShown(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::windowHidden(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    // not interest this time
+}
+void SAL_CALL
+VbaEventsListener::disposing(  const lang::EventObject& /*aEvent*/ ) throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    OSL_TRACE("VbaEventsListener::disposing(0x%x)", this);
+    pVbaEventsHelper = NULL;
+}
+void SAL_CALL 
+VbaEventsListener::queryClosing( const lang::EventObject& Source, ::sal_Bool GetsOwnership ) throw (util::CloseVetoException, uno::RuntimeException)
+{
+     // it can cancel the close, but need to throw a CloseVetoException, and it will be transmit to caller.
+}
+void SAL_CALL 
+VbaEventsListener::notifyClosing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    stopEventsLinstener();
+}
+void SAL_CALL 
+VbaEventsListener::borderWidthsChanged( const uno::Reference< uno::XInterface >& aObject, const frame::BorderWidths& aNewSize ) throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    // work with WindowResized event to guard Window Resize event.
+    m_bBorderChanged = sal_True;
+    Window* pWindow = (VCLUnoHelper::GetWindow(  GetContainerWindow() ) );
+    if( pWindow && m_bWindowResized )
+    {
+        m_bWindowResized = m_bBorderChanged = sal_False;
+        acquire(); // ensure we don't get deleted before the timer fires.
+        Application::PostUserEvent( LINK( this, VbaEventsListener, fireResizeMacro ), NULL );
+    }
+}
+
+class ImplVbaEventNameInfo
+{
+private:
+    map< sal_Int32, rtl::OUString > m_aEventNameMap;
+
+protected:
+    static ImplVbaEventNameInfo* pImplVbaEventNameInfo;
+    ImplVbaEventNameInfo() { InitImplVbaEventNameInfo(); }
+private:
+    void insert( const sal_Int32 nId, const rtl::OUString& sEventName )
+    {
+        m_aEventNameMap.insert( make_pair( nId, sEventName ) );
+    }
+    void InitImplVbaEventNameInfo();
+public:
+    virtual ~ImplVbaEventNameInfo();
+    rtl::OUString getEventName( const sal_Int32 nId )
+    {
+        map< sal_Int32, rtl::OUString >::iterator iter = m_aEventNameMap.find( nId );
+        if( iter != m_aEventNameMap.end() )
+            return iter->second;
+        return rtl::OUString();
+    }
+    static ImplVbaEventNameInfo* GetImplVbaEventNameInfo();
+};
+ImplVbaEventNameInfo* ImplVbaEventNameInfo::pImplVbaEventNameInfo = NULL;
+
+ImplVbaEventNameInfo::~ImplVbaEventNameInfo()
+{
+    if( pImplVbaEventNameInfo )
+    {
+        delete pImplVbaEventNameInfo;
+        pImplVbaEventNameInfo = NULL;
+    }
+}
+
+ImplVbaEventNameInfo* 
+ImplVbaEventNameInfo::GetImplVbaEventNameInfo()
+{
+    if( !pImplVbaEventNameInfo )
+    {
+        pImplVbaEventNameInfo = new ImplVbaEventNameInfo;
+    }
+    return pImplVbaEventNameInfo;
+}
+
+#define CREATEOUSTRING(asciistr) rtl::OUString::createFromAscii(asciistr)
+
+#define INSERT_EVENT_INFO( Object, Event, ObjectName, EventName ) \
+        insert( VBAEVENT_##Object##_##Event, ObjectName + CREATEOUSTRING( EventName ) )
+
+#define INSERT_WORKSHEET_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO( WORKSHEET, Event,CREATEOUSTRING("Worksheet_"), EventName ); \
+        INSERT_EVENT_INFO( WORKBOOK_SHEET, Event, CREATEOUSTRING("Workbook_Sheet"), EventName )
+
+#define INSERT_WORKBOOK_EVENT_INFO( Event, EventName ) \
+        INSERT_EVENT_INFO(  WORKBOOK, Event, CREATEOUSTRING("Workbook_"), EventName )
+
+void ImplVbaEventNameInfo::InitImplVbaEventNameInfo()
+{
+    INSERT_WORKSHEET_EVENT_INFO( ACTIVATE, "Activate");
+    INSERT_WORKSHEET_EVENT_INFO( BEFOREDOUBLECLICK, "BeforeDoubleClick" );
+    INSERT_WORKSHEET_EVENT_INFO( BEFORERIGHTCLICK, "BeforeRightClick" );
+    INSERT_WORKSHEET_EVENT_INFO( CALCULATE, "Calculate" );
+    INSERT_WORKSHEET_EVENT_INFO( CHANGE, "Change" );
+    INSERT_WORKSHEET_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKSHEET_EVENT_INFO( FOLLOWHYPERLINK, "FollowHyperlink" );
+    INSERT_WORKSHEET_EVENT_INFO( PIVOTTABLEUPDATE, "PivotTableUpdate" );
+    INSERT_WORKSHEET_EVENT_INFO( SELECTIONCHANGE, "SelectionChange" );
+
+    // Workbook
+    INSERT_WORKBOOK_EVENT_INFO( ACTIVATE, "Activate" );
+    INSERT_WORKBOOK_EVENT_INFO( DEACTIVATE, "Deactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( OPEN, "Open" );
+    // AUTOOPEN doesn't be used. TODO, this should be "auto_open"
+    insert( VBAEVENT_WORKBOOK_AUTOOPEN, CREATEOUSTRING("Auto_Open") );                       
+    INSERT_WORKBOOK_EVENT_INFO( BEFORECLOSE, "BeforeClose" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFOREPRINT, "BeforePrint" );
+    INSERT_WORKBOOK_EVENT_INFO( BEFORESAVE, "BeforeSave" );
+    INSERT_WORKBOOK_EVENT_INFO( NEWSHEET, "NewSheet" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWACTIVATE, "WindowActivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWDEACTIVATE, "WindowDeactivate" );
+    INSERT_WORKBOOK_EVENT_INFO( WINDOWRESIZE, "WindowResize" );
+}
+
+ScVbaEventsHelper::ScVbaEventsHelper( uno::Sequence< css::uno::Any > const& aArgs, uno::Reference< uno::XComponentContext > const& xContext )
+    : m_xContext( xContext ), mbOpened( sal_False ), mbIgnoreEvents( sal_False )
+{
+    uno::Reference< frame::XModel > xModel ( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ), uno::UNO_QUERY );
+    pDocShell = excel::getDocShell( xModel );
+    pDoc = pDocShell->GetDocument();
+    // Add worksheet change listener
+    uno::Reference< util::XChangesNotifier > xChangesNotifier( xModel, uno::UNO_QUERY );
+    if( xChangesNotifier.is() )
+        xChangesNotifier->addChangesListener( uno::Reference< util::XChangesListener >( new WorksheetChangeListener( this ) ) );
+}
+
+ScVbaEventsHelper::~ScVbaEventsHelper()
+{
+}
+
+rtl::OUString
+ScVbaEventsHelper::getEventName( const sal_Int32 nId )
+{
+    rtl::OUString sEventName;
+    ImplVbaEventNameInfo* pEventInfo = ImplVbaEventNameInfo::GetImplVbaEventNameInfo();
+    if( pEventInfo )
+        sEventName = pEventInfo->getEventName( nId );
+    return sEventName;
+}
+
+uno::Any ScVbaEventsHelper::createWorkSheet( SfxObjectShell* pShell, SCTAB nTab )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		// Eventually we will be able to pull the Workbook/Worksheet objects
+		// directly from basic and register them as listeners
+
+		// create Workbook
+		uno::Sequence< uno::Any > aArgs(2);
+		aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+		aArgs[1] = uno::Any( pShell->GetModel() );
+		uno::Reference< uno::XInterface > xWorkbook( ov::createVBAUnoAPIServiceWithArgs( pShell, "ooo.vba.excel.Workbook", aArgs ), uno::UNO_QUERY );
+
+		// create WorkSheet
+		String sSheetName;
+		pDoc->GetName( nTab, sSheetName );
+		aArgs = uno::Sequence< uno::Any >(3);
+		aArgs[ 0 ] <<= xWorkbook;
+		aArgs[ 1 ] <<= pShell->GetModel();
+		aArgs[ 2 ] = uno::makeAny( rtl::OUString( sSheetName ) );
+		aRet <<= ov::createVBAUnoAPIServiceWithArgs( pShell, "ooo.vba.excel.Worksheet", aArgs );
+	}
+	catch( uno::Exception& e )
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createRange( const uno::Any& aRange )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( 	aRange, uno::UNO_QUERY );
+		uno::Reference< table::XCellRange > xRange( aRange, uno::UNO_QUERY );
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW );
+		if (  xRanges.is() || xRange.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			if ( xRanges.is() )
+			{
+				aArgs[1] <<= xRanges;
+			}
+			else if ( xRange.is() )
+			{
+				aArgs[1] <<= xRange;
+			}
+			else
+			{
+				throw uno::RuntimeException(); // 
+			}
+			aRet <<= ov::createVBAUnoAPIServiceWithArgs( pDoc->GetDocumentShell(), "ooo.vba.excel.Range", aArgs );	
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createHyperlink( const uno::Any& rCell )
+{
+	uno::Any aRet;
+	try
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xSMgr, uno::UNO_QUERY_THROW ); 
+		uno::Reference< table::XCell > xCell( rCell, uno::UNO_QUERY );
+		if( xCell.is() )
+		{
+			uno::Reference<uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+			uno::Sequence< uno::Any > aArgs(2);
+			aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() ); // dummy parent
+			aArgs[1] <<= rCell;
+			
+			aRet <<= ov::createVBAUnoAPIServiceWithArgs( pDoc->GetDocumentShell(), "ooo.vba.excel.Hyperlink", aArgs );	
+		}
+		else
+		{
+			throw uno::RuntimeException(); // 
+		}
+	}
+	catch( uno::Exception& e ) 
+	{
+	}
+	return aRet;
+}
+
+uno::Any ScVbaEventsHelper::createWindow( SfxObjectShell* pShell )
+{
+    try
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY );
+        uno::Reference< frame::XModel > xModel( pShell->GetModel(), uno::UNO_QUERY );
+        uno::Sequence< uno::Any > aWindowArgs(2);
+        aWindowArgs[0] = uno::Any( uno::Reference< uno::XInterface > () );
+        aWindowArgs[1] = uno::Any( xModel );
+        uno::Reference< uno::XInterface > xWindow( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Window" ) ), aWindowArgs ), uno::UNO_QUERY );
+        if( xWindow.is() )
+            return uno::makeAny( xWindow );
+    }
+	catch( uno::Exception& e )
+	{
+	}
+    return uno::Any();
+}
+
+String ScVbaEventsHelper::getSheetModuleName( SCTAB nTab )
+{
+	ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+	String aCodeName;
+	pDoc->GetName( nTab, aCodeName);
+	// Use code name if that exists
+	if ( pExtOptions )
+		aCodeName = pExtOptions->GetCodeName( nTab );
+	return aCodeName;	
+}
+
+rtl::OUString
+ScVbaEventsHelper::getMacroPath( const sal_Int32 nEventId, const SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+    String sMacroName = getEventName( nEventId );
+    VBAMacroResolvedInfo sMacroResolvedInfo;
+    switch( nEventId )
+    {
+        // Worksheet
+    	case VBAEVENT_WORKSHEET_ACTIVATE                      :
+    	case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK             :
+    	case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK              :
+    	case VBAEVENT_WORKSHEET_CALCULATE                     :
+    	case VBAEVENT_WORKSHEET_CHANGE                        :
+    	case VBAEVENT_WORKSHEET_DEACTIVATE                    :
+    	case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK               :
+    	case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE              :
+    	case VBAEVENT_WORKSHEET_SELECTIONCHANGE               :
+        {
+            String  aSheetModuleName = getSheetModuleName( nTab );
+            sMacroName.Insert( '.', 0 ).Insert( aSheetModuleName, 0);
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+        // Workbook
+    	case VBAEVENT_WORKBOOK_ACTIVATE                       :
+    	case VBAEVENT_WORKBOOK_DEACTIVATE                     :
+    	case VBAEVENT_WORKBOOK_OPEN                           :
+    	case VBAEVENT_WORKBOOK_BEFORECLOSE                    :
+    	case VBAEVENT_WORKBOOK_BEFOREPRINT                    :
+    	case VBAEVENT_WORKBOOK_BEFORESAVE                     :
+    	case VBAEVENT_WORKBOOK_NEWSHEET                       :
+    	case VBAEVENT_WORKBOOK_WINDOWACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_WINDOWRESIZE                   :
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE                 :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK        :
+    	case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK         :
+    	case VBAEVENT_WORKBOOK_SHEET_CALCULATE                :
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE                   :
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE               :
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK          :
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE         :
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE          :
+        {
+	        ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+            String sWorkbookModuleName = pDoc->GetCodeName();
+            if( pExtOptions )
+            {
+                ScExtDocSettings aExtDocSettings = pExtOptions->GetDocSettings();
+                sWorkbookModuleName = aExtDocSettings.maGlobCodeName;
+            }
+           
+            sMacroName.Insert( '.', 0 ).Insert( sWorkbookModuleName, 0);
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_AUTOOPEN                       :
+        {
+            sMacroResolvedInfo = resolveVBAMacro( pShell, sMacroName );
+            break;
+        }
+        default:
+            break;
+    }
+    return sMacroResolvedInfo.ResolvedMacro();
+}
+
+sal_Bool ScVbaEventsHelper::processVbaEvent( const sal_Int32 nEventId, const uno::Sequence< uno::Any >& rArgs, const SCTAB nTab )
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+
+	sal_Bool result = sal_False;
+    sal_Bool bCancel = sal_False;
+	uno::Sequence< uno::Any > aArgs;
+	uno::Any aRet;
+	uno::Any aDummyCaller;
+    
+    // For most cases, there is no corresponsible event macro in the document. 
+    // It is better fo check if the event macro exists before process the arguments to improve performance.
+    rtl::OUString sMacroPath = getMacroPath( nEventId, nTab );
+	if( sMacroPath.getLength() )
+	{
+		switch( nEventId )
+		{
+			case VBAEVENT_WORKSHEET_ACTIVATE:
+			case VBAEVENT_WORKSHEET_CALCULATE:
+			case VBAEVENT_WORKSHEET_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_ACTIVATE:
+            case VBAEVENT_WORKBOOK_DEACTIVATE:
+            case VBAEVENT_WORKBOOK_OPEN:
+    	    case VBAEVENT_WORKBOOK_AUTOOPEN:
+			{
+				// no arguments
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+            case VBAEVENT_WORKBOOK_NEWSHEET:
+            {
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = createWorkSheet( pShell, nTab ); 
+				break;
+            }
+			case VBAEVENT_WORKSHEET_CHANGE:
+			case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+			{
+				// one argument: range
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aRange;
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+    	    case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				break;
+            }
+			case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+			case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+			{
+				// two aruments: range and cancel
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = aRange;
+				aArgs[1] <<= bCancel;
+				// TODO: process "cancel" action  
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+    	    case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+            {
+				uno::Any aRange = createRange( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(3);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aRange;
+				aArgs[2] <<= bCancel;
+				// TODO: process "cancel" action  
+				break;
+            }
+			case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+			{
+				// one argument: hyperlink
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(1);
+				aArgs[0] = aHyperlink;
+				break;
+			}
+    	    case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+            {
+				uno::Any aHyperlink = createHyperlink( rArgs[0] );
+				aArgs = uno::Sequence< uno::Any >(2);
+				aArgs[0] = createWorkSheet( pShell, nTab );
+				aArgs[1] = aHyperlink;
+				break;
+            }
+			case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+    	    case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+			{
+				// one argument: pivottable
+                // TODO: not support yet
+				return result;
+			}
+            case VBAEVENT_WORKBOOK_BEFORECLOSE:
+            case VBAEVENT_WORKBOOK_BEFOREPRINT:
+            {
+                // process Cancel argument
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                aArgs[0] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_BEFORESAVE:
+            {
+                // two arguments: SaveAs and Cancel
+                aArgs = uno::Sequence< uno::Any >(2);
+                aArgs[0] = rArgs[0];
+                aArgs[1] <<= bCancel;
+                executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+                aArgs[1] >>= bCancel;
+                return bCancel;
+            }
+            case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+            case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+            {
+                // one argument: windows
+                aArgs = uno::Sequence< uno::Any >(1);
+                aArgs[0] = createWindow( pShell );
+                break;
+            }
+            default:
+                return result;
+		}
+    
+        // excute the macro
+        result = executeMacro( pShell, sMacroPath, aArgs, aRet, aDummyCaller );
+	}
+    
+	return result;
+}
+
+SCTAB ScVbaEventsHelper::getTabFromArgs( const uno::Sequence< uno::Any > aArgs, const sal_Int32 nPos )
+{
+    SCTAB nTab = -1;
+    uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable( getXSomethingFromArgs< sheet::XCellRangeAddressable >( aArgs, nPos ), uno::UNO_QUERY );
+    if( xCellRangeAddressable.is() )
+    {
+        table::CellRangeAddress aAddress = xCellRangeAddressable->getRangeAddress();
+        nTab = aAddress.Sheet;
+    }
+    else
+    {
+        uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getXSomethingFromArgs< sheet::XSheetCellRangeContainer >( aArgs, nPos ), uno::UNO_QUERY );
+        if( xRanges.is() )
+        {
+            uno::Sequence< table::CellRangeAddress > aRangeAddresses = xRanges->getRangeAddresses();
+            if( aRangeAddresses.getLength() > 0 )
+            {
+                nTab = aRangeAddresses[ 0 ].Sheet;
+            }
+        }
+    }
+    return nTab;
+}
+
+sal_Bool SAL_CALL 
+ScVbaEventsHelper::ProcessCompatibleVbaEvent( sal_Int32 nEventId, const uno::Sequence< uno::Any >& aArgs ) throw (uno::RuntimeException)
+{
+	SfxObjectShell* pShell = pDoc->GetDocumentShell();
+	if( !pShell || mbIgnoreEvents)
+		return sal_False;
+    
+    // In order to better support "withevents" in the future, 
+    // it is better to process a event at a time
+    SCTAB nTab = INVALID_TAB;
+    switch( nEventId )
+    {
+        // Worksheet
+		case VBAEVENT_WORKSHEET_ACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                // process the event
+                processVbaEvent( nEventId, aArgs, nTab );
+                // recursive process related workbook sheet event.
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_ACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_BEFORERIGHTCLICK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CALCULATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CALCULATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_CHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_CHANGE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_DEACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_FOLLOWHYPERLINK:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE:
+            // TODO
+            break;
+		case VBAEVENT_WORKSHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE, aArgs );
+            }
+            break;
+        }
+        // Workbook_sheet
+    	case VBAEVENT_WORKBOOK_SHEET_ACTIVATE:
+        case VBAEVENT_WORKBOOK_SHEET_CALCULATE:
+    	case VBAEVENT_WORKBOOK_SHEET_DEACTIVATE:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK:
+        case VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK:
+    	case VBAEVENT_WORKBOOK_SHEET_CHANGE:
+    	case VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK:
+    	case VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE:
+        {
+            nTab = getTabFromArgs( aArgs );
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+    	case VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE:
+        // TODO
+            break;
+		// Workbook
+		case VBAEVENT_WORKBOOK_ACTIVATE:
+        {
+            // if workbook open event do not be fired. fired it before 
+            // workbook activate event to compatible with MSO.
+            if( mbOpened )
+            {
+                // process workbook activate event
+                processVbaEvent( nEventId, aArgs );
+                // process workbook window activate event at the same time
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWACTIVATE, aArgs );
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_DEACTIVATE:
+        {
+            processVbaEvent( nEventId, aArgs );
+            // same as workbook window deactivate
+            ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_WINDOWDEACTIVATE, aArgs );
+            break;
+        }
+		case VBAEVENT_WORKBOOK_OPEN:
+        {
+            // process workbook open macro
+            // does auto open work here?
+            if( !mbOpened )
+            {
+                processVbaEvent( nEventId, aArgs );
+                processVbaEvent( VBAEVENT_WORKBOOK_AUTOOPEN, aArgs );
+                mbOpened = sal_True;
+                ProcessCompatibleVbaEvent( VBAEVENT_WORKBOOK_ACTIVATE, aArgs );
+            }
+            // register the window listener.
+            if( !m_xVbaEventsListener.is() )
+            {
+                m_xVbaEventsListener = new VbaEventsListener( this );
+                VbaEventsListener* pEventsListener = dynamic_cast< VbaEventsListener* >( m_xVbaEventsListener.get() );
+                pEventsListener->startEventsLinstener();
+            }
+            break;
+        }
+		case VBAEVENT_WORKBOOK_BEFORECLOSE:
+        {
+            sal_Bool bCancel = processVbaEvent( nEventId, aArgs ); 
+            if( m_xVbaEventsListener.is() && !bCancel )
+            {
+                VbaEventsListener* pEventsListener = dynamic_cast< VbaEventsListener* >( m_xVbaEventsListener.get() );
+                pEventsListener->stopEventsLinstener();
+                m_xVbaEventsListener = NULL;
+            }
+            return bCancel;
+        }
+		case VBAEVENT_WORKBOOK_BEFOREPRINT:
+		case VBAEVENT_WORKBOOK_BEFORESAVE:
+		case VBAEVENT_WORKBOOK_WINDOWACTIVATE:
+		case VBAEVENT_WORKBOOK_WINDOWDEACTIVATE:
+		case VBAEVENT_WORKBOOK_WINDOWRESIZE:
+        {
+            return processVbaEvent( nEventId, aArgs );
+        }
+		case VBAEVENT_WORKBOOK_NEWSHEET:
+        {
+            aArgs[0] >>= nTab;
+            if( nTab != INVALID_TAB )
+            {
+                processVbaEvent( nEventId, aArgs, nTab );
+            }
+            break;
+        }
+        default:
+            OSL_TRACE( "Invalid Event" );
+    }
+
+    return sal_True;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaEventsHelper::getIgnoreEvents() throw (uno::RuntimeException)
+{
+    return mbIgnoreEvents;
+}
+
+void SAL_CALL 
+ScVbaEventsHelper::setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (uno::RuntimeException)
+{
+    mbIgnoreEvents = _ignoreevents;
+}
+
+
+namespace vbaeventshelper
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ScVbaEventsHelper, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaEventsHelper",
+    "com.sun.star.document.VbaEventsHelper" );
+}
Index: sc/source/ui/vba/vbaborders.hxx
===================================================================
--- sc/source/ui/vba/vbaborders.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaborders.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,7 +38,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 
  
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 typedef CollTestImplHelper< ov::excel::XBorders > ScVbaBorders_BASE;
 class ScVbaPalette;
Index: sc/source/ui/vba/vbahyperlink.cxx
===================================================================
--- sc/source/ui/vba/vbahyperlink.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbahyperlink.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,7 +32,7 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 #include "vbahyperlink.hxx"
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/text/XTextFieldsSupplier.hpp> 
Index: sc/source/ui/vba/vbafont.cxx
===================================================================
--- sc/source/ui/vba/vbafont.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbafont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -46,37 +46,14 @@
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
-// use local constants there is no need to expose these constants
-// externally. Looking at the Format->Character dialog it seem that
-// these may infact be even be calculated. Leave hardcoded for now
-// #FIXEME #TBD investigate the code for dialog mentioned above
-
-// The font baseline is not specified.
-const short NORMAL = 0;
-
-// specifies a superscripted.
-const short SUPERSCRIPT = 33;
-
-// specifies a subscripted.
-const short SUBSCRIPT = -33;
-
-// specifies a hight of superscripted font
- const sal_Int8 SUPERSCRIPTHEIGHT = 58;
-
-// specifies a hight of subscripted font
-const sal_Int8 SUBSCRIPTHEIGHT = 58;
-
-// specifies a hight of normal font
-const short NORMALHEIGHT = 100;
-
-ScVbaFont::ScVbaFont( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const ScVbaPalette& dPalette, uno::Reference< beans::XPropertySet > xPropertySet, ScCellRangeObj* pRangeObj  ) throw ( uno::RuntimeException ) : ScVbaFont_BASE( xParent, xContext ), mxFont( xPropertySet, css::uno::UNO_QUERY_THROW ), mPalette( dPalette ),  mpRangeObj( pRangeObj )
+ScVbaFont::ScVbaFont( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const ScVbaPalette& dPalette, uno::Reference< beans::XPropertySet > xPropertySet, ScCellRangeObj* pRangeObj  ) throw ( uno::RuntimeException ) : ScVbaFont_BASE( xParent, xContext, dPalette.getPalette(), xPropertySet ), mPalette( dPalette ),  mpRangeObj( pRangeObj )
 {
 }
 
 SfxItemSet*  
 ScVbaFont::GetDataSet()
 {
-    SfxItemSet* pDataSet = ScVbaCellRangeAccess::GetDataSet( mpRangeObj );
+    SfxItemSet* pDataSet = excel::ScVbaCellRangeAccess::GetDataSet( mpRangeObj );
     return pDataSet;
 }
 
@@ -243,19 +220,13 @@
 	return uno::makeAny( ( nValue == SUBSCRIPT ) );
 }
 
-void SAL_CALL
-ScVbaFont::setSize( const uno::Any& aValue ) throw( uno::RuntimeException )
-{
-	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ), aValue );
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getSize() throw ( uno::RuntimeException )
 {
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT_HEIGHT, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-        return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ) );
+        return ScVbaFont_BASE::getSize();
 }
 
 void SAL_CALL
@@ -267,43 +238,22 @@
 	// handled properly here
 
 	if ( !nIndex || ( nIndex == excel::XlColorIndex::xlColorIndexAutomatic ) )
+        {
 		nIndex = 1;  // check defualt ( assume black )
-	--nIndex; // OOo indices are zero bases
-	uno::Reference< container::XIndexAccess > xIndex = mPalette.getPalette();
-	// setColor expects colors in XL RGB values
-	// #FIXME this is daft we convert OO RGB val to XL RGB val and
-	// then back again to OO RGB value
-	setColor( OORGBToXLRGB(xIndex->getByIndex( nIndex )) );
+                ScVbaFont_BASE::setColorIndex( uno::makeAny( nIndex ) );
+        }
+        else
+            ScVbaFont_BASE::setColorIndex( _colorindex );
 }
 
 
 uno::Any SAL_CALL
 ScVbaFont::getColorIndex() throw ( uno::RuntimeException )
 {
-	sal_Int32 nColor = 0;
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT_COLOR, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-
-	// getColor returns Xl ColorValue, need to convert it to OO val
-	// as the palette deals with OO RGB values
-	// #FIXME this is daft in getColor we convert OO RGB val to XL RGB val
-	// and then back again to OO RGB value
-	XLRGBToOORGB( getColor() ) >>= nColor;
-	uno::Reference< container::XIndexAccess > xIndex = mPalette.getPalette();
-	sal_Int32 nElems = xIndex->getCount();
-	sal_Int32 nIndex = -1;
-	for ( sal_Int32 count=0; count<nElems; ++count )
-       	{
-		sal_Int32 nPaletteColor = 0;
-		xIndex->getByIndex( count ) >>= nPaletteColor;
-		if ( nPaletteColor == nColor )
-		{
-			nIndex = count + 1; // 1 based
-			break;
-		}
-	}
-	return uno::makeAny( nIndex );
+	return ScVbaFont_BASE::getColorIndex();
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -396,28 +346,13 @@
     return uno::makeAny( aStyles.makeStringAndClear() );
 }
 
-void SAL_CALL
-ScVbaFont::setBold( const uno::Any& aValue ) throw( uno::RuntimeException )
-{
-	sal_Bool bValue = sal_False;
-	aValue >>= bValue;
-	double fBoldValue = awt::FontWeight::NORMAL;
-	if( bValue )
-		fBoldValue = awt::FontWeight::BOLD;
-	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ), ( uno::Any )fBoldValue );
-
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getBold() throw ( uno::RuntimeException )
 {
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT_WEIGHT, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-
-	double fValue = 0.0;
-	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ) ) >>= fValue;
-	return uno::makeAny( fValue == awt::FontWeight::BOLD );
+	return ScVbaFont_BASE::getBold();
 }
 
 void SAL_CALL
@@ -481,54 +416,24 @@
 	return uno::makeAny( nValue );
 }
 
-void SAL_CALL
-ScVbaFont::setStrikethrough( const uno::Any& aValue ) throw ( uno::RuntimeException )
-{
-	sal_Bool bValue = sal_False;
-	aValue >>= bValue;
-	short nValue = awt::FontStrikeout::NONE;
-	if( bValue )
-		nValue = awt::FontStrikeout::SINGLE;
-	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ), ( uno::Any )nValue );
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getStrikethrough() throw ( uno::RuntimeException )
 {
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT_CROSSEDOUT, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-	short nValue = 0;
-	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ) ) >>= nValue;
-	return uno::Any( nValue == awt::FontStrikeout::SINGLE );
+	return ScVbaFont_BASE::getStrikethrough();
 }
 
-void  SAL_CALL
-ScVbaFont::setShadow( const uno::Any& aValue ) throw ( uno::RuntimeException )
-{
-	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ), aValue );
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getShadow() throw (uno::RuntimeException)
 {
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT_SHADOWED, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ) );
+	return ScVbaFont_BASE::getShadow();
 }
 
-void  SAL_CALL
-ScVbaFont::setItalic( const uno::Any& aValue ) throw ( uno::RuntimeException )
-{
-	sal_Bool bValue = sal_False;
-	aValue >>= bValue;
-	short nValue = awt::FontSlant_NONE;
-	if( bValue )
-		nValue = awt::FontSlant_ITALIC;
-    mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ), ( uno::Any )nValue );
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getItalic() throw ( uno::RuntimeException )
 {
@@ -536,41 +441,26 @@
 		if (  GetDataSet()->GetItemState( ATTR_FONT_POSTURE, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
 
-    awt::FontSlant aFS;
-	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ) ) >>= aFS;
-	return uno::makeAny( aFS == awt::FontSlant_ITALIC );
+	return ScVbaFont_BASE::getItalic();
 }
 
-void  SAL_CALL
-ScVbaFont::setName( const uno::Any& aValue ) throw ( uno::RuntimeException )
-{
-	rtl::OUString sString;
-	aValue >>= sString;
-	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ), aValue);
-}
-
 uno::Any SAL_CALL
 ScVbaFont::getName() throw ( uno::RuntimeException )
 {
 	if ( GetDataSet() )
 		if (  GetDataSet()->GetItemState( ATTR_FONT, TRUE, NULL) == SFX_ITEM_DONTCARE )
 			return aNULL();
-	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ) );
+	return ScVbaFont_BASE::getName();
 }
 uno::Any
 ScVbaFont::getColor() throw (uno::RuntimeException)
 {
+	// #TODO #FIXME - behave like getXXX above ( wrt. GetDataSet )
 	uno::Any aAny;
 	aAny = OORGBToXLRGB( mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ) ) );
 	return aAny;
 }
 
-void
-ScVbaFont::setColor( const uno::Any& _color  ) throw (uno::RuntimeException)
-{
-	mxFont->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ) , XLRGBToOORGB(_color));
-}
-
 void  SAL_CALL
 ScVbaFont::setOutlineFont( const uno::Any& aValue ) throw ( uno::RuntimeException )
 {
Index: sc/source/ui/vba/vbaaxis.hxx
===================================================================
--- sc/source/ui/vba/vbaaxis.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaaxis.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,8 +32,8 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <ooo/vba/excel/XAxis.hpp>
 #include <ooo/vba/excel/XChart.hpp>
-#include "vbahelperinterface.hxx"
-
+#include <vbahelper/vbahelperinterface.hxx>
+#include <memory>
 typedef InheritedHelperInterfaceImpl1< ov::excel::XAxis >  ScVbaAxis_BASE;
 class ScVbaChart;
 class ScVbaAxis : public ScVbaAxis_BASE
Index: sc/source/ui/vba/vbamenubars.cxx
===================================================================
--- sc/source/ui/vba/vbamenubars.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenubars.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,146 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenubars.hxx"
+#include "vbamenubar.hxx"
+#include <ooo/vba/excel/XlSheetType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > MenuBarEnumeration_BASE;
+
+class MenuBarEnumeration : public MenuBarEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< container::XEnumeration > m_xEnumeration;
+public:
+    MenuBarEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), m_xEnumeration( xEnumeration )
+    {
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        return m_xEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menubar
+        if( hasMoreElements() )
+        {
+            uno::Reference< XCommandBar > xCommandBar( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+            uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( m_xParent, m_xContext, xCommandBar ) );
+            return uno::makeAny( xMenuBar );
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaMenuBars::ScVbaMenuBars( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XCommandBars >& xCommandBars ) throw ( uno::RuntimeException ) : MenuBars_BASE( xParent, xContext, uno::Reference< container::XIndexAccess>() ), m_xCommandBars( xCommandBars )
+{
+}
+
+ScVbaMenuBars::~ScVbaMenuBars()
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaMenuBars::getElementType() throw ( uno::RuntimeException )
+{
+    return excel::XMenuBar::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaMenuBars::createEnumeration() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xCommandBars, uno::UNO_QUERY_THROW );
+    return uno::Reference< container::XEnumeration >( new MenuBarEnumeration( this, mxContext, xEnumAccess->createEnumeration() ) );
+}
+
+uno::Any
+ScVbaMenuBars::createCollectionObject( const uno::Any& aSource )
+{
+    // make no sense
+    return aSource;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaMenuBars::getCount() throw(css::uno::RuntimeException)
+{
+    return m_xCommandBars->getCount();
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaMenuBars::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    sal_Int16 nIndex = 0;
+    aIndex >>= nIndex;
+    if( nIndex == excel::XlSheetType::xlWorksheet )
+    {
+        uno::Any aSource;
+        aSource <<= rtl::OUString::createFromAscii( "Worksheet Menu Bar" );
+        uno::Reference< XCommandBar > xCommandBar( m_xCommandBars->Item( aSource, uno::Any() ), uno::UNO_QUERY_THROW );
+        uno::Reference< excel::XMenuBar > xMenuBar( new ScVbaMenuBar( this, mxContext, xCommandBar ) );
+        return uno::makeAny( xMenuBar );
+    }
+
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    
+    return uno::Any();
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaMenuBars::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuBars") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuBars::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuBars" ) );
+    }
+    return aServiceNames;
+}
+
Index: sc/source/ui/vba/vbadialogs.cxx
===================================================================
--- sc/source/ui/vba/vbadialogs.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbadialogs.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,18 +27,8 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include <comphelper/processfactory.hxx>
-
-#include <com/sun/star/lang/XMultiComponentFactory.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-#include <ooo/vba/excel/XApplication.hpp>
 #include <ooo/vba/excel/XDialog.hpp>
-
-#include <tools/string.hxx>
-
-#include "vbahelper.hxx"
 #include "vbadialogs.hxx"
-#include "vbaglobals.hxx"
 #include "vbadialog.hxx"
 
 using namespace ::ooo::vba;
@@ -49,26 +39,19 @@
 {
 }
 
-::sal_Int32
-ScVbaDialogs::getCount() throw (uno::RuntimeException)
-{
-	//#TODO #FIXEME
-	//SC_VBA_STUB();
-	return 0;
-}
-
 uno::Any
 ScVbaDialogs::Item( const uno::Any &aItem ) throw (uno::RuntimeException)
 {
 	sal_Int32 nIndex = 0;
 	aItem >>= nIndex;
-	uno::Reference< excel::XDialog > aDialog( new ScVbaDialog( uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( mxContext )->getApplication(), uno::UNO_QUERY_THROW ), nIndex, mxContext ) );
+	uno::Reference< excel::XDialog > aDialog( new ScVbaDialog( uno::Reference< XHelperInterface >( Application(),uno::UNO_QUERY_THROW ), mxContext, m_xModel, nIndex ) );
 	return uno::Any( aDialog );
 }
+
 rtl::OUString& 
 ScVbaDialogs::getServiceImplName()
 {
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaWorksheet") );
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaDialogs") );
 	return sImplName;
 }
 
@@ -79,10 +62,18 @@
 	if ( aServiceNames.getLength() == 0 )
 	{
 		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Worksheet" ) );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Dialogs" ) );
 	}
 	return aServiceNames;
 }
 
+//liuchen 2009-7-27
+::sal_Int32
+ScVbaDialogs::getCount() throw (uno::RuntimeException)
+{	
+	return ScVbaDialog::GetSupportedDialogCount();
+}
 
 
+
+
Index: sc/source/ui/vba/vbaglobals.cxx
===================================================================
--- sc/source/ui/vba/vbaglobals.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaglobals.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,13 +27,14 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 #include "vbaglobals.hxx"
 
 #include <comphelper/unwrapargs.hxx>
 
 #include <com/sun/star/lang/XMultiComponentFactory.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
+#include <cppuhelper/component_context.hxx>
 
 #include "vbaapplication.hxx"
 #include "vbaworksheet.hxx"
@@ -49,11 +50,20 @@
 // ScVbaGlobals
 // =============================================================================
 
-ScVbaGlobals::ScVbaGlobals(  css::uno::Reference< css::uno::XComponentContext >const& rxContext )
-        :m_xContext( rxContext )
+//ScVbaGlobals::ScVbaGlobals(  css::uno::Reference< css::uno::XComponentContext >const& rxContext,  ) : ScVbaGlobals_BASE( uno::Reference< XHelperInterface >(), rxContext )
+rtl::OUString sDocCtxName( RTL_CONSTASCII_USTRINGPARAM("ExcelDocumentContext") );
+
+ScVbaGlobals::ScVbaGlobals( uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& rxContext ) : ScVbaGlobals_BASE( uno::Reference< XHelperInterface >(), rxContext, sDocCtxName )
 {
 	OSL_TRACE("ScVbaGlobals::ScVbaGlobals()");
-	mxApplication = uno::Reference< excel::XApplication > ( new ScVbaApplication( m_xContext) );
+
+        uno::Sequence< beans::PropertyValue > aInitArgs( 2 );
+        aInitArgs[ 0 ].Name = rtl::OUString::createFromAscii("Application");
+        aInitArgs[ 0 ].Value = uno::makeAny( getApplication() );
+        aInitArgs[ 1 ].Name = sDocCtxName;
+        aInitArgs[ 1 ].Value = uno::makeAny( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ) );
+        
+        init( aInitArgs );
 }
 
 ScVbaGlobals::~ScVbaGlobals()
@@ -61,23 +71,6 @@
 	OSL_TRACE("ScVbaGlobals::~ScVbaGlobals");
 }
 
-// Will throw if singleton can't be accessed 
-uno::Reference< XGlobals >
-ScVbaGlobals::getGlobalsImpl( const uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException )
-{
-	uno::Reference< XGlobals > xGlobals( 
-		xContext->getValueByName( ::rtl::OUString::createFromAscii( 
-			"/singletons/ooo.vba.theGlobals") ), uno::UNO_QUERY);
-
-	if ( !xGlobals.is() )
-	{
-		throw uno::RuntimeException(
-                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ": Couldn't access Globals" ) ),
-                    uno::Reference< XInterface >() );
-	}
-	return xGlobals;
-}
-
 // =============================================================================
 // XGlobals
 // =============================================================================
@@ -85,14 +78,16 @@
 ScVbaGlobals::getApplication() throw (uno::RuntimeException)
 {
 //	OSL_TRACE("In ScVbaGlobals::getApplication");	
-    return mxApplication;
+        if ( !mxApplication.is() )
+	    mxApplication.set( new ScVbaApplication( mxContext) );
+   	return mxApplication; 
 }
 
 uno::Reference< excel::XWorkbook > SAL_CALL 
 ScVbaGlobals::getActiveWorkbook() throw (uno::RuntimeException)
 {
 //	OSL_TRACE("In ScVbaGlobals::getActiveWorkbook");	
-    uno::Reference< excel::XWorkbook > xWorkbook( mxApplication->getActiveWorkbook(), uno::UNO_QUERY);
+    uno::Reference< excel::XWorkbook > xWorkbook( getApplication()->getActiveWorkbook(), uno::UNO_QUERY);
     if ( xWorkbook.is() )
     {
         return xWorkbook;    
@@ -103,22 +98,28 @@
 }
 
 
+uno::Reference< excel::XWindow > SAL_CALL 
+ScVbaGlobals::getActiveWindow() throw (uno::RuntimeException)
+{
+    return getApplication()->getActiveWindow();
+}
+
 uno::Reference< excel::XWorksheet > SAL_CALL 
 ScVbaGlobals::getActiveSheet() throw (uno::RuntimeException)
 {
-    return mxApplication->getActiveSheet();
+    return getApplication()->getActiveSheet();
 }
 
 uno::Any SAL_CALL 
 ScVbaGlobals::WorkBooks( const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	return uno::Any( mxApplication->Workbooks(aIndex) );
+	return uno::Any( getApplication()->Workbooks(aIndex) );
 }
 
 uno::Any SAL_CALL
 ScVbaGlobals::WorkSheets(const uno::Any& aIndex) throw (uno::RuntimeException)
 {
-	return mxApplication->Worksheets( aIndex );
+	return getApplication()->Worksheets( aIndex );
 }
 uno::Any SAL_CALL
 ScVbaGlobals::Sheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
@@ -126,26 +127,6 @@
 	return WorkSheets( aIndex );
 }
 
-::uno::Sequence< ::uno::Any > SAL_CALL
-ScVbaGlobals::getGlobals(  ) throw (::uno::RuntimeException)
-{
-	sal_uInt32 nMax = 0;
-	uno::Sequence< uno::Any > maGlobals(4);
-	maGlobals[ nMax++ ] <<= ScVbaGlobals::getGlobalsImpl(m_xContext);
-	maGlobals[ nMax++ ] <<= mxApplication;
-
-	uno::Reference< excel::XWorkbook > xWorkbook = mxApplication->getActiveWorkbook();
-	if( xWorkbook.is() )
-	{
-		maGlobals[ nMax++ ] <<= xWorkbook;
-		uno::Reference< excel::XWorksheet > xWorksheet = xWorkbook->getActiveSheet();
-		if( xWorksheet.is() )
-			maGlobals[ nMax++ ] <<= xWorksheet;
-	}
-	maGlobals.realloc( nMax );
-	return maGlobals;
-}
-
 uno::Any SAL_CALL 
 ScVbaGlobals::Range( const uno::Any& Cell1, const uno::Any& Cell2 ) throw (uno::RuntimeException)
 {
@@ -158,13 +139,146 @@
 	return getApplication()->Names( aIndex );
 }
 
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaGlobals::getActiveCell() throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveCell();
+}
+
+uno::Reference< XAssistant > SAL_CALL 
+ScVbaGlobals::getAssistant() throw (uno::RuntimeException)
+{
+	return getApplication()->getAssistant();
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::getSelection() throw (uno::RuntimeException)
+{
+	return getApplication()->getSelection();
+}
+
+uno::Reference< excel::XWorkbook > SAL_CALL 
+ScVbaGlobals::getThisWorkbook() throw (uno::RuntimeException)
+{
+	return getApplication()->getThisWorkbook();
+}
+void SAL_CALL 
+ScVbaGlobals::Calculate()  throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException)
+{
+	return getApplication()->Calculate();
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaGlobals::Cells( const uno::Any& RowIndex, const uno::Any& ColumnIndex ) throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveSheet()->Cells( RowIndex, ColumnIndex );
+}
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaGlobals::Columns( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveSheet()->Columns( aIndex );
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::CommandBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< XApplicationBase > xBase( getApplication(), uno::UNO_QUERY_THROW );
+	return xBase->CommandBars( aIndex );
+}
+
+css::uno::Reference< ov::excel::XRange > SAL_CALL 
+ScVbaGlobals::Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+	return getApplication()->Union(  Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20, Arg21, Arg22, Arg23, Arg24, Arg25, Arg26, Arg27, Arg28, Arg29, Arg30 );
+}
+css::uno::Reference< ov::excel::XRange > SAL_CALL 
+ScVbaGlobals::Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+	return getApplication()->Intersect(  Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20, Arg21, Arg22, Arg23, Arg24, Arg25, Arg26, Arg27, Arg28, Arg29, Arg30 );
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::Evaluate( const ::rtl::OUString& Name ) throw (uno::RuntimeException)
+{
+	return getApplication()->Evaluate( Name );
+}
+
+css::uno::Any SAL_CALL 
+ScVbaGlobals::WorksheetFunction(  ) throw (css::uno::RuntimeException)
+{
+	return getApplication()->WorksheetFunction();
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::Windows( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return getApplication()->Windows( aIndex );
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaGlobals::Rows( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveSheet()->Rows( aIndex );
+	
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::MenuBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return uno::Any( getApplication()->MenuBars(aIndex) );
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL 
+ScVbaGlobals::getAvailableServiceNames(  ) throw (uno::RuntimeException)
+{
+    static bool bInit = false;
+    static uno::Sequence< rtl::OUString > serviceNames( ScVbaGlobals_BASE::getAvailableServiceNames() );
+    if ( !bInit )
+    {
+         rtl::OUString names[] = { 
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Range" ) ),
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Workbook" ) ),
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Window" ) ),
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Worksheet" ) ),
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Application" ) ),
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.excel.Hyperlink" ) ),
+          };
+        sal_Int32 nExcelServices = ( sizeof( names )/ sizeof( names[0] ) );
+        sal_Int32 startIndex = serviceNames.getLength();
+        serviceNames.realloc( serviceNames.getLength() + nExcelServices );
+        for ( sal_Int32 index = 0; index < nExcelServices; ++index )
+             serviceNames[ startIndex + index ] = names[ index ];
+        bInit = true;
+    }
+    return serviceNames;
+}
+
+rtl::OUString&
+ScVbaGlobals::getServiceImplName()
+{
+        static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaGlobals") );
+        return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+ScVbaGlobals::getServiceNames()
+{
+        static uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+                aServiceNames.realloc( 1 );
+                aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Globals" ) );
+        }
+        return aServiceNames;
+}
+
 namespace globals
 {
 namespace sdecl = comphelper::service_decl;
-sdecl::class_<ScVbaGlobals, sdecl::with_args<false> > serviceImpl;
+sdecl::vba_service_class_<ScVbaGlobals, sdecl::with_args<true> > serviceImpl;
 extern sdecl::ServiceDecl const serviceDecl(
     serviceImpl,
     "ScVbaGlobals",
-    "ooo.vba.Globals" );
+    "ooo.vba.excel.Globals" );
 }
 
Index: sc/source/ui/vba/vbacharacters.hxx
===================================================================
--- sc/source/ui/vba/vbacharacters.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacharacters.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,7 +36,7 @@
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/text/XSimpleText.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 #include "vbapalette.hxx"
 typedef InheritedHelperInterfaceImpl1< ov::excel::XCharacters > ScVbaCharacters_BASE;
 
Index: sc/source/ui/vba/vbastyles.hxx
===================================================================
--- sc/source/ui/vba/vbastyles.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbastyles.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,7 +31,7 @@
 #define SC_VBA_STYLES_HXX
 #include <ooo/vba/excel/XStyles.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 typedef CollTestImplHelper< ov::excel::XStyles > ScVbaStyles_BASE;
 class ScVbaStyles: public ScVbaStyles_BASE
Index: sc/source/ui/vba/vbamenus.hxx
===================================================================
--- sc/source/ui/vba/vbamenus.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenus.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUS_HXX
+#define SC_VBA_MENUS_HXX
+
+#include <ooo/vba/excel/XMenus.hpp>
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenus > Menus_BASE;
+
+class ScVbaMenus : public Menus_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenus( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenu > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& Before, const css::uno::Any& Restore ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUS_HXX
Index: sc/source/ui/vba/vbaoleobjects.hxx
===================================================================
--- sc/source/ui/vba/vbaoleobjects.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaoleobjects.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,8 +33,8 @@
 #include <cppuhelper/implbase1.hxx>
 #include <ooo/vba/excel/XOLEObjects.hpp>
 
-#include "vbacollectionimpl.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "excelvbahelper.hxx"
 
 typedef CollTestImplHelper< ov::excel::XOLEObjects > OLEObjectsImpl_BASE;
 
Index: sc/source/ui/vba/vbapalette.hxx
===================================================================
--- sc/source/ui/vba/vbapalette.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapalette.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -30,7 +30,7 @@
 #ifndef SC_VBAPALETTE_HXX
 #define SC_VBAPALETTE_HXX
 
-#include "vbahelper.hxx"
+#include "excelvbahelper.hxx"
 #include <document.hxx>
 #include <com/sun/star/container/XIndexAccess.hpp>
 
@@ -42,7 +42,7 @@
 	ScVbaPalette(  SfxObjectShell* pShell = NULL ) : m_pShell( pShell ){}
 	// if no palette available e.g. because the document doesn't have a 
 	// palette defined then a default palette will be returned.
-	css::uno::Reference< css::container::XIndexAccess > getPalette();
+	css::uno::Reference< css::container::XIndexAccess > getPalette() const;
 	static css::uno::Reference< css::container::XIndexAccess > getDefaultPalette();
 };
 
Index: sc/source/ui/vba/vbamenu.cxx
===================================================================
--- sc/source/ui/vba/vbamenu.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenu.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenu.hxx" 
+#include "vbamenuitems.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenu::ScVbaMenu( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : Menu_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenu::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenu::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+void SAL_CALL
+ScVbaMenu::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+uno::Any SAL_CALL 
+ScVbaMenu::MenuItems( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< XCommandBarControls > xCommandBarControls( m_xCommandBarControl->Controls( uno::Any() ), uno::UNO_QUERY_THROW );
+    uno::Reference< excel::XMenuItems > xMenuItems( new ScVbaMenuItems( this, mxContext, xCommandBarControls ) );
+    if( aIndex.hasValue() )
+    {
+        return xMenuItems->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xMenuItems );
+}
+
+rtl::OUString& 
+ScVbaMenu::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenu") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenu::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Menu" ) );
+	}
+	return aServiceNames;
+}
Index: sc/source/ui/vba/vbacomment.hxx
===================================================================
--- sc/source/ui/vba/vbacomment.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacomment.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -39,7 +39,7 @@
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XComment > ScVbaComment_BASE;
 
Index: sc/source/ui/vba/vbamenuitems.hxx
===================================================================
--- sc/source/ui/vba/vbamenuitems.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenuitems.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUITEMS_HXX
+#define SC_VBA_MENUITEMS_HXX
+
+#include <ooo/vba/excel/XMenuItems.hpp>
+#include <ooo/vba/excel/XMenuItem.hpp>
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuItems > MenuItems_BASE;
+
+class ScVbaMenuItems : public MenuItems_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControls > m_xCommandBarControls;
+
+public:
+    ScVbaMenuItems( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBarControls >& xCommandBarControls ) throw( css::uno::RuntimeException );
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::excel::XMenuItem > SAL_CALL Add( const rtl::OUString& Caption, const css::uno::Any& OnAction, const css::uno::Any& ShortcutKey, const css::uno::Any& Before, const css::uno::Any& Restore, const css::uno::Any& StatusBar, const css::uno::Any& HelpFile, const css::uno::Any& HelpContextID ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUITEMS_HXX
Index: sc/source/ui/vba/vbaoleobject.hxx
===================================================================
--- sc/source/ui/vba/vbaoleobject.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaoleobject.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,20 +32,20 @@
 
 #include <cppuhelper/implbase1.hxx>
 #include <com/sun/star/drawing/XControlShape.hpp>
-#include <com/sun/star/awt/XWindowPeer.hpp>
 #include <ooo/vba/excel/XOLEObject.hpp>
+#include <ooo/vba/msforms/XControl.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XOLEObject > OLEObjectImpl_BASE;
 
 class ScVbaOLEObject : public OLEObjectImpl_BASE
 {
-    css::uno::Reference< css::awt::XWindowPeer > m_xWindowPeer;
 protected:
     css::uno::Reference< css::drawing::XControlShape > m_xControlShape;
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    css::uno::Reference< ov::msforms::XControl> m_xControl;
 public:
     ScVbaOLEObject( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,
             css::uno::Reference< css::drawing::XControlShape > xControlShape );
Index: sc/source/ui/vba/vbawindow.hxx
===================================================================
--- sc/source/ui/vba/vbawindow.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbawindow.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -39,15 +39,16 @@
 #include <ooo/vba/excel/XPane.hpp>
 #include <com/sun/star/awt/XDevice.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbawindowbase.hxx>
 #include "vbaworkbook.hxx"
 
-typedef InheritedHelperInterfaceImpl1<ov::excel::XWindow > WindowImpl_BASE;
+//typedef InheritedHelperInterfaceImpl1<ov::excel::XWindow > WindowImpl_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaWindowBase, ov::excel::XWindow > WindowImpl_BASE;
 
 class ScVbaWindow : public WindowImpl_BASE
 {		
 private:		
-	css::uno::Reference< css::frame::XModel > m_xModel;
 	css::uno::Reference< css::sheet::XViewPane > m_xViewPane;
 	css::uno::Reference< css::sheet::XViewFreezable > m_xViewFreezable;
 	css::uno::Reference< css::sheet::XViewSplitable > m_xViewSplitable;
@@ -82,10 +83,6 @@
 	virtual void SAL_CALL setDisplayWorkbookTabs( ::sal_Bool _bDisplayWorkbookTabs ) throw (css::uno::RuntimeException);
 	virtual ::sal_Bool SAL_CALL getFreezePanes() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setFreezePanes( ::sal_Bool _bFreezePanes ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getHeight() throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL setHeight( sal_Int32 _height ) throw (css::uno::RuntimeException) ;
-    virtual sal_Int32 SAL_CALL getLeft() throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL setLeft( sal_Int32 _left ) throw (css::uno::RuntimeException) ;
 	virtual ::sal_Bool SAL_CALL getSplit() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setSplit( ::sal_Bool _bSplit ) throw (css::uno::RuntimeException);
     virtual sal_Int32 SAL_CALL getSplitColumn() throw (css::uno::RuntimeException) ;
@@ -100,14 +97,8 @@
     virtual void SAL_CALL setScrollRow( const css::uno::Any& _scrollrow ) throw (css::uno::RuntimeException) ;
     virtual css::uno::Any SAL_CALL getScrollColumn() throw (css::uno::RuntimeException) ;
     virtual void SAL_CALL setScrollColumn( const css::uno::Any& _scrollcolumn ) throw (css::uno::RuntimeException) ;
-    virtual sal_Int32 SAL_CALL getTop() throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL setTop( sal_Int32 _top ) throw (css::uno::RuntimeException) ;
     virtual css::uno::Any SAL_CALL getView() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setView( const css::uno::Any& _view ) throw (css::uno::RuntimeException);
-    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
-    virtual sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw (css::uno::RuntimeException) ;
     virtual css::uno::Any SAL_CALL getWindowState() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setWindowState( const css::uno::Any& _windowstate ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getZoom() throw (css::uno::RuntimeException);
Index: sc/source/ui/vba/vbatextboxshape.cxx
===================================================================
--- sc/source/ui/vba/vbatextboxshape.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextboxshape.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -41,7 +41,7 @@
 using namespace com::sun::star;
 using namespace ooo::vba;
 
-ScVbaTextBoxShape::ScVbaTextBoxShape( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< drawing::XShapes >& xShapes, const uno::Reference< frame::XModel >& xModel ) : TextBoxShapeImpl_BASE( uno::Reference< XHelperInterface >(), xContext, xShape, xShapes, ScVbaShape::getType( xShape )  )
+ScVbaTextBoxShape::ScVbaTextBoxShape( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< drawing::XShapes >& xShapes, const uno::Reference< frame::XModel >& xModel ) : TextBoxShapeImpl_BASE( uno::Reference< XHelperInterface >(), xContext, xShape, xShapes, xModel, ScVbaShape::getType( xShape )  )
 {
     m_xTextRange.set( xShape , uno::UNO_QUERY_THROW );
     m_xModel.set( xModel );
@@ -62,7 +62,7 @@
 uno::Reference< excel::XCharacters > SAL_CALL 
 ScVbaTextBoxShape::characters( const uno::Any& Start, const uno::Any& Length ) throw (uno::RuntimeException)
 {
-    ScDocShell* pDocShell = getDocShell( m_xModel );
+    ScDocShell* pDocShell = excel::getDocShell( m_xModel );
     ScDocument* pDoc = pDocShell ? pDocShell->GetDocument() : NULL;
 
     if ( !pDoc )
Index: sc/source/ui/vba/helperdecl.hxx
===================================================================
--- sc/source/ui/vba/helperdecl.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/helperdecl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,107 +32,25 @@
 
 namespace comphelper {
 namespace service_decl {
-
-namespace detail {
-namespace css = ::com::sun::star;
-template <typename ImplT>
-class OwnServiceImpl
-    : public ImplT,
-      private ::boost::noncopyable
-{
-    typedef ImplT BaseT;
-    
-public:    
-    OwnServiceImpl(
-        ServiceDecl const& rServiceDecl,
-        css::uno::Sequence<css::uno::Any> const& args,
-        css::uno::Reference<css::uno::XComponentContext> const& xContext )
-        :BaseT(args, xContext), m_rServiceDecl(rServiceDecl) {}
-    OwnServiceImpl(
-        ServiceDecl const& rServiceDecl,
-        css::uno::Reference<css::uno::XComponentContext> const& xContext )
-        : BaseT(xContext), m_rServiceDecl(rServiceDecl) {}
-    
-    // XServiceInfo
-    virtual ::rtl::OUString SAL_CALL getImplementationName()
-        throw (css::uno::RuntimeException) {
-        return m_rServiceDecl.getImplementationName();
-    }
-    virtual sal_Bool SAL_CALL supportsService( ::rtl::OUString const& name )
-        throw (css::uno::RuntimeException) {
-        return m_rServiceDecl.supportsService(name);
-    }
-    virtual css::uno::Sequence< ::rtl::OUString>
-    SAL_CALL getSupportedServiceNames() throw (css::uno::RuntimeException) {
-        return m_rServiceDecl.getSupportedServiceNames();
-    }
-    
-private:
-    ServiceDecl const& m_rServiceDecl;
-};
-
-
-template <typename ImplT, typename WithArgsT>
-struct OwnCreateFunc;
-
-template <typename ImplT>
-struct OwnCreateFunc<ImplT, with_args<false> > {
-    explicit OwnCreateFunc(  )
-         {}
-    
-    css::uno::Reference<css::uno::XInterface>
-    operator()( ServiceDecl const& rServiceDecl,
-                css::uno::Sequence<css::uno::Any> const&,
-                css::uno::Reference<css::uno::XComponentContext>
-                const& xContext ) const
-    {
-        return css::uno::Reference< ooo::vba::XHelperInterface >(new OwnServiceImpl<ImplT>( rServiceDecl, xContext ));
-    }
-};
-
-template <typename ImplT>
-struct OwnCreateFunc<ImplT, with_args<true> > {
-    explicit OwnCreateFunc( )
-         {}
-    
-    css::uno::Reference<css::uno::XInterface>
-    operator()( ServiceDecl const& rServiceDecl,
-                css::uno::Sequence<css::uno::Any> const& args,
-                css::uno::Reference<css::uno::XComponentContext>
-                const& xContext ) const
-    {
-        css::uno::Reference< ooo::vba::XHelperInterface > xHelp(
-            new OwnServiceImpl<ImplT>( rServiceDecl, args, xContext ) );
-	css::uno::Reference< css::uno::XInterface > xIf( xHelp, css::uno::UNO_QUERY ) ;
-	return xIf;
-    }
-};
-
-} // namespace detail
-
-/** Defines a service implementation class.
-    
-    @tpl ImplT_ service implementation class
-    @WithArgsT whether the implementation class ctor expects arguments
-               (uno::Sequence<uno::Any>, uno::Reference<uno::XComponentContext>)
-               or just (uno::Reference<uno::XComponentContext>)
-*/
 template <typename ImplT_, typename WithArgsT = with_args<false> >
-struct vba_service_class_ {
-    typedef ImplT_ ImplT;
-    typedef detail::OwnServiceImpl<ImplT_ > ServiceImplT;
-    
-    detail::CreateFuncF const m_createFunc;
-    
+struct vba_service_class_ : public serviceimpl_base< detail::OwnServiceImpl<ImplT_>, WithArgsT >
+{
+    typedef serviceimpl_base< detail::OwnServiceImpl<ImplT_>, WithArgsT > baseT;
     /** Default ctor.  Implementation class without args, expecting
         component context as single argument.
     */
-    vba_service_class_() : m_createFunc(
-        detail::OwnCreateFunc<ImplT, WithArgsT>() ) {}
-
+    vba_service_class_() : baseT() {}
+    template <typename PostProcessFuncT>
+    /** Ctor to pass a post processing function/functor.
+        
+        @tpl PostProcessDefaultT let your compiler deduce this
+        @param postProcessFunc function/functor that gets the yet unacquired
+                               ImplT_ pointer returning a
+                               uno::Reference<uno::XInterface>
+    */
+    explicit vba_service_class_( PostProcessFuncT const& postProcessFunc ) : baseT( postProcessFunc ) {}
 };
 
-
 } // namespace service_decl
 } // namespace comphelper
 
Index: sc/source/ui/vba/vbachartobject.cxx
===================================================================
--- sc/source/ui/vba/vbachartobject.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbachartobject.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -120,10 +120,11 @@
 {
 	try
 	{
-		// #TODO #FIXME should be ThisWorkbook or equivelant
-		// XModel
+		// #TODO #FIXME should be ThisWorkbook or equivelant, or in
+		// fact probably the chart object should be created with 
+		// the XModel owner
 		//uno::Reference< view::XSelectionSupplier > xSelectionSupplier( getXModel().getCurrentController());
-		uno::Reference< view::XSelectionSupplier > xSelectionSupplier( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY_THROW );
+		uno::Reference< view::XSelectionSupplier > xSelectionSupplier( getCurrentExcelDoc(mxContext)->getCurrentController(), uno::UNO_QUERY_THROW );
 		xSelectionSupplier->select(uno::makeAny(xShape));
 	}
 	catch (uno::Exception& )
Index: sc/source/ui/vba/vbainterior.cxx
===================================================================
--- sc/source/ui/vba/vbainterior.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbainterior.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -162,11 +162,19 @@
 {
 	sal_Int32 nIndex = 0;
 	_colorindex >>= nIndex;
-	
-	// setColor expects colors in XL RGB values
-	// #FIXME this is daft we convert OO RGB val to XL RGB val and
-	// then back again to OO RGB value
-	setColor( OORGBToXLRGB( GetIndexColor( nIndex ) ) );
+
+    // hackly for excel::XlColorIndex::xlColorIndexNone
+    if( nIndex == excel::XlColorIndex::xlColorIndexNone )
+    {
+        m_xProps->setPropertyValue( BACKCOLOR, uno::makeAny( sal_Int32( -1 ) ) );
+    }
+    else
+    {
+	    // setColor expects colors in XL RGB values
+    	// #FIXME this is daft we convert OO RGB val to XL RGB val and
+	    // then back again to OO RGB value
+    	setColor( OORGBToXLRGB( GetIndexColor( nIndex ) ) );
+    }
 }
 uno::Any
 ScVbaInterior::GetIndexColor( const sal_Int32& nColorIndex )
@@ -204,13 +212,21 @@
 ScVbaInterior::getColorIndex() throw ( css::uno::RuntimeException )
 {
 	sal_Int32 nColor = 0;
+    // hackly for excel::XlColorIndex::xlColorIndexNone
+    uno::Any aColor = m_xProps->getPropertyValue( BACKCOLOR ); 
+    if( ( aColor >>= nColor ) && ( nColor == -1 ) )
+    {
+        nColor = excel::XlColorIndex::xlColorIndexNone;
+        return uno::makeAny( nColor );
+    }
+
 	// getColor returns Xl ColorValue, need to convert it to OO val
 	// as the palette deals with OO RGB values 
 	// #FIXME this is daft in getColor we convert OO RGB val to XL RGB val 
 	// and then back again to OO RGB value
 	XLRGBToOORGB( getColor() ) >>= nColor; 
      
-	return uno::makeAny( GetIndexColor( nColor ) );
+	return uno::makeAny( GetColorIndex( nColor ) );
 }
 Color
 ScVbaInterior::GetPatternColor( const Color& rPattColor, const Color& rBackColor, sal_uInt32 nXclPattern )
Index: sc/source/ui/vba/vbawindows.hxx
===================================================================
--- sc/source/ui/vba/vbawindows.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbawindows.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,8 +35,8 @@
 
 #include <com/sun/star/uno/XComponentContext.hpp>
  
-#include "vbahelper.hxx"
-#include "vbacollectionimpl.hxx"
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 
 typedef CollTestImplHelper< ov::excel::XWindows > ScVbaWindows_BASE;
@@ -45,6 +45,7 @@
 {
 public:
 	ScVbaWindows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+	ScVbaWindows( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext );
 	virtual ~ScVbaWindows() {}
 
 	// XEnumerationAccess
@@ -57,8 +58,6 @@
 	// ScVbaCollectionBaseImpl	
 	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
 
-	static css::uno::Reference< ov::XCollection > Windows(  const css::uno::Reference< css::uno::XComponentContext >& xContext );
-
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
Index: sc/source/ui/vba/vbaworksheets.hxx
===================================================================
--- sc/source/ui/vba/vbaworksheets.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworksheets.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,9 +36,8 @@
 #include <com/sun/star/sheet/XSpreadsheets.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
-#include <ooo/vba/XGlobals.hpp>
  
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 class ScModelObj;
 
Index: sc/source/ui/vba/vbadialog.hxx
===================================================================
--- sc/source/ui/vba/vbadialog.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbadialog.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,30 +31,26 @@
 #define SC_VBA_DIALOG_HXX
 
 #include <cppuhelper/implbase1.hxx>
-
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <ooo/vba/XGlobals.hpp>
-#include <ooo/vba/excel/XApplication.hpp>
 #include <ooo/vba/excel/XDialog.hpp>
- 
-#include "vbahelperinterface.hxx"
-#include "vbadialog.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadialogbase.hxx>
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XDialog > ScVbaDialog_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaDialogBase, ov::excel::XDialog > ScVbaDialog_BASE;
 
 class ScVbaDialog : public ScVbaDialog_BASE
 {
-	sal_Int32 mnIndex;
 public:
-	ScVbaDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, sal_Int32 nIndex, const css::uno::Reference< css::uno::XComponentContext > xContext ):ScVbaDialog_BASE( xParent, xContext ), mnIndex( nIndex ) {}
+	ScVbaDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< css::frame::XModel >& xModel, sal_Int32 nIndex ):ScVbaDialog_BASE( xParent, xContext, xModel, nIndex ) {}
 	virtual ~ScVbaDialog() {}
 
 	// Methods
-	virtual void SAL_CALL Show() throw (css::uno::RuntimeException);
-	rtl::OUString mapIndexToName( sal_Int32 nIndex );
+	virtual rtl::OUString mapIndexToName( sal_Int32 nIndex );
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	//liuchen 2009-7-27
+	static sal_Int32 GetSupportedDialogCount();
 };
 
 #endif /* SC_VBA_DIALOG_HXX */
Index: sc/source/ui/vba/vbatextframe.hxx
===================================================================
--- sc/source/ui/vba/vbatextframe.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextframe.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -29,45 +29,23 @@
  ************************************************************************/
 #ifndef SC_VBA_TEXTFRAME_HXX
 #define SC_VBA_TEXTFRAME_HXX
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <ooo/vba/excel/XCharacters.hpp>
 #include <ooo/vba/excel/XTextFrame.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbatextframe.hxx>
 
-#include "vbahelperinterface.hxx"
-#include "vbapalette.hxx"
+//typedef InheritedHelperInterfaceImpl1< ov::excel::XTextFrame > ScVbaTextFrame_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaTextFrame, ov::excel::XTextFrame > ScVbaTextFrame_BASE;
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XTextFrame > ScVbaTextFrame_BASE;
-
 class ScVbaTextFrame : public ScVbaTextFrame_BASE
 {
-private:
-    css::uno::Reference< ov::excel::XCharacters > m_xCharacters;
-    css::uno::Reference< css::drawing::XShape > m_xShape;
-    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
-protected:
-    virtual rtl::OUString& getServiceImplName();
-    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
-    virtual void setAsMSObehavior();
-    sal_Int32 getMargin( rtl::OUString sMarginType );
-    void setMargin( rtl::OUString sMarginType, float fMargin );
 public:
-    ScVbaTextFrame( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext , css::uno::Reference< css::drawing::XShape > xShape);
+	ScVbaTextFrame( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext ) throw ( css::lang::IllegalArgumentException );
     virtual ~ScVbaTextFrame() {}
-    // Attributes
-    virtual sal_Bool SAL_CALL getAutoSize() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setAutoSize( sal_Bool _autosize ) throw (css::uno::RuntimeException);
-    virtual float SAL_CALL getMarginBottom() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMarginBottom( float _marginbottom ) throw (css::uno::RuntimeException);
-    virtual float SAL_CALL getMarginTop() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMarginTop( float _margintop ) throw (css::uno::RuntimeException);
-    virtual float SAL_CALL getMarginLeft() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMarginLeft( float _marginleft ) throw (css::uno::RuntimeException);
-    virtual float SAL_CALL getMarginRight() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setMarginRight( float _marginright ) throw (css::uno::RuntimeException);
-
     // Methods
-    virtual css::uno::Reference< ov::excel::XCharacters > SAL_CALL Characters(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Characters(  ) throw (css::uno::RuntimeException);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
 
 };
 
Index: sc/source/ui/vba/excelvbahelper.hxx
===================================================================
--- sc/source/ui/vba/excelvbahelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/excelvbahelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_EXCEL_VBA_HELPER_HXX
+#define SC_EXCEL_VBA_HELPER_HXX
+
+#include<vbahelper/vbahelper.hxx>
+#include <docsh.hxx>
+
+class ScCellRangeObj;
+
+namespace ooo 
+{
+	namespace vba 
+	{
+	namespace excel
+        { 
+                // nTabs empty means apply zoom to all sheets
+                void implSetZoom( const css::uno::Reference< css::frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs );
+		void implnCopy( const css::uno::Reference< css::frame::XModel>& xModel );
+		void implnPaste ( const css::uno::Reference< css::frame::XModel>& xModel );
+		void implnCut( const css::uno::Reference< css::frame::XModel>& xModel );
+		void implnPasteSpecial( const css::uno::Reference< css::frame::XModel>& xModel, sal_uInt16 nFlags,sal_uInt16 nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose);
+		ScTabViewShell* getBestViewShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
+		ScDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
+		ScTabViewShell* getCurrentBestViewShell( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+		SfxViewFrame* getViewFrame( const css::uno::Reference< css::frame::XModel >& xModel );
+            class ScVbaCellRangeAccess
+            {
+            public:
+                static SfxItemSet* GetDataSet( ScCellRangeObj* pRangeObj );
+            };
+}
+}
+}
+#endif
Index: sc/source/ui/vba/vbaapplication.hxx
===================================================================
--- sc/source/ui/vba/vbaapplication.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaapplication.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,21 +35,25 @@
 #include <ooo/vba/excel/XApplication.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbaapplicationbase.hxx>
+#include <cppuhelper/implbase1.hxx>
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XApplication > ScVbaApplication_BASE;
+//typedef InheritedHelperInterfaceImpl1< ov::excel::XApplication > ScVbaApplication_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaApplicationBase, ov::excel::XApplication > ScVbaApplication_BASE;
 
 class ScVbaApplication : public ScVbaApplication_BASE
 {
 private:
 	sal_Int32 m_xCalculation;
 	rtl::OUString getOfficePath( const rtl::OUString& sPath ) throw ( css::uno::RuntimeException );
+protected:
+        virtual css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException);
 public:
-	ScVbaApplication( css::uno::Reference< css::uno::XComponentContext >& m_xContext );
+	ScVbaApplication( const css::uno::Reference< css::uno::XComponentContext >& m_xContext );
 	virtual ~ScVbaApplication();
 
-	// XHelperInterface ( parent is itself )
-	virtual css::uno::Reference< ov::XHelperInterface > SAL_CALL getParent(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { return this; }
+    virtual SfxObjectShell* GetDocShell( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
 
 	// XApplication
 	virtual ::rtl::OUString SAL_CALL PathSeparator(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
@@ -68,15 +72,10 @@
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL getActiveCell() throw ( css::uno::RuntimeException);
  virtual css::uno::Reference< ov::excel::XWindow > SAL_CALL getActiveWindow() throw (css::uno::RuntimeException);
  virtual css::uno::Reference< ov::excel::XWorksheet > SAL_CALL getActiveSheet() throw (css::uno::RuntimeException);
-	virtual sal_Bool SAL_CALL getScreenUpdating() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setScreenUpdating(sal_Bool bUpdate) throw (css::uno::RuntimeException);
-	virtual sal_Bool SAL_CALL getDisplayStatusBar() throw (css::uno::RuntimeException);
-	virtual void SAL_CALL setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (css::uno::RuntimeException);
 	virtual ::sal_Bool SAL_CALL getDisplayFormulaBar() throw ( css::uno::RuntimeException );
 	virtual void SAL_CALL setDisplayFormulaBar( ::sal_Bool _displayformulabar ) throw ( css::uno::RuntimeException );
 
     virtual css::uno::Reference< ov::XAssistant > SAL_CALL getAssistant() throw (css::uno::RuntimeException);
-    virtual css::uno::Any SAL_CALL CommandBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XWorkbook > SAL_CALL getThisWorkbook() throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Workbooks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
@@ -85,7 +84,6 @@
 	virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& DialogIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL getCutCopyMode() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setCutCopyMode( const css::uno::Any& _cutcopymode ) throw (css::uno::RuntimeException);
-	virtual ::rtl::OUString SAL_CALL getVersion() throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL getStatusBar() throw (css::uno::RuntimeException);
 	virtual void SAL_CALL setStatusBar( const css::uno::Any& _statusbar ) throw (css::uno::RuntimeException);
 	virtual ::sal_Int32 SAL_CALL getCursor() throw (css::uno::RuntimeException);
@@ -102,7 +100,8 @@
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
 	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
 	virtual void SAL_CALL Volatile( const css::uno::Any& Volatile ) throw (css::uno::RuntimeException );
-	virtual void SAL_CALL DoEvents() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Caller( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	// XHelperInterface
 	virtual rtl::OUString& getServiceImplName();
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
Index: sc/source/ui/vba/vbaeventshelper.hxx
===================================================================
--- sc/source/ui/vba/vbaeventshelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbaeventshelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: vbaeventshelper.hxx,v $
+ *
+ *  $Revision: 1.0 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/12/07 10:42:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_VBAEVENTS_HXX
+#define SC_VBAEVENTS_HXX
+
+#include "document.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/document/VbaEventId.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/awt/XWindowListener.hpp>
+#include "excelvbahelper.hxx"
+
+#define INVALID_TAB -1
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::document::XVbaEventsHelper > VBAWorkbookEvent_BASE;
+
+class VbaEventsListener;
+class ScDocShell;
+class ScVbaEventsHelper : public VBAWorkbookEvent_BASE
+{
+private:
+	ScDocument* pDoc;
+	ScDocShell* pDocShell;
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    css::uno::Reference< css::awt::XWindowListener > m_xVbaEventsListener;
+    sal_Bool mbOpened;
+    sal_Bool mbIgnoreEvents;
+
+	String getSheetModuleName( SCTAB nTab );
+	css::uno::Any createWorkSheet( SfxObjectShell* pShell, SCTAB nTab );
+	css::uno::Any createRange( const css::uno::Any& aRange );
+	css::uno::Any createHyperlink( const css::uno::Any& rCell );
+	css::uno::Any createWindow( SfxObjectShell* pShell );
+    SCTAB getTabFromArgs( const css::uno::Sequence< css::uno::Any > aArgs, const sal_Int32 nPos = 0 );
+    rtl::OUString getEventName( const sal_Int32 nEventId );
+    rtl::OUString getMacroPath( const sal_Int32 nEventId, const SCTAB nTab = INVALID_TAB );
+    sal_Bool processVbaEvent( const sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& rArgs, const SCTAB nTab = INVALID_TAB );
+
+public:
+	ScVbaEventsHelper( ScDocument* pDocument ):pDoc( pDocument ), mbOpened( sal_False ){};
+    ScVbaEventsHelper( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+    ~ScVbaEventsHelper();
+	ScDocument* getDocument() { return pDoc; };
+	ScDocShell* getDocumentShell() { return pDocShell; };
+    // XVBAWorkbookEventHelper
+    virtual sal_Bool SAL_CALL ProcessCompatibleVbaEvent( sal_Int32 nEventId, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreEvents( ::sal_Bool _ignoreevents ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getIgnoreEvents() throw (css::uno::RuntimeException);
+};
+
+#endif
+
Index: sc/source/ui/vba/vbapagebreaks.hxx
===================================================================
--- sc/source/ui/vba/vbapagebreaks.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbapagebreaks.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,6 +33,8 @@
 #include <cppuhelper/implbase1.hxx>
 #include <ooo/vba/excel/XHPageBreaks.hpp>
 #include <ooo/vba/excel/XHPageBreak.hpp>
+#include <ooo/vba/excel/XVPageBreaks.hpp>
+#include <ooo/vba/excel/XVPageBreak.hpp>
 #include <ooo/vba/excel/XRange.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/script/BasicErrorException.hpp>
@@ -41,8 +43,8 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/table/XColumnRowRange.hpp>
-#include "vbahelperinterface.hxx"
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
 
 typedef CollTestImplHelper< ov::excel::XHPageBreaks > ScVbaHPageBreaks_BASE;
 
@@ -68,4 +70,31 @@
 	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
 };
 
+//VPageBreaks
+typedef CollTestImplHelper< ov::excel::XVPageBreaks > ScVbaVPageBreaks_BASE;
+
+class ScVbaVPageBreaks : public ScVbaVPageBreaks_BASE
+{
+	css::uno::Reference< css::sheet::XSheetPageBreak > mxSheetPageBreak;
+
+public:
+	ScVbaVPageBreaks( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+					  const css::uno::Reference< css::uno::XComponentContext >& xContext,
+            		  css::uno::Reference< css::sheet::XSheetPageBreak >& xSheetPageBreak ) throw ( css::uno::RuntimeException );
+
+	virtual ~ScVbaVPageBreaks();
+
+	// XVPageBreaks 
+	virtual css::uno::Any SAL_CALL Add( const css::uno::Any& Before ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw ( css::uno::RuntimeException );
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw ( css::uno::RuntimeException );	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
 #endif
Index: sc/source/ui/vba/vbahyperlink.hxx
===================================================================
--- sc/source/ui/vba/vbahyperlink.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbahyperlink.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,7 +40,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <ooo/vba/excel/XRange.hpp>
 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XHyperlink > HyperlinkImpl_BASE;
 
Index: sc/source/ui/vba/vbafont.hxx
===================================================================
--- sc/source/ui/vba/vbafont.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbafont.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,19 +32,19 @@
 
 #include <cppuhelper/implbase1.hxx>
 
-#include <ooo/vba/excel/XFont.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
-#include "vbahelperinterface.hxx"
+#include <ooo/vba/excel/XFont.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbafontbase.hxx>
 #include "vbapalette.hxx"
 
 class ScTableSheetsObj;
 class ScCellRangeObj;
 
-typedef  InheritedHelperInterfaceImpl1< ov::excel::XFont > ScVbaFont_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaFontBase, ov::excel::XFont > ScVbaFont_BASE;
 
 class ScVbaFont : public ScVbaFont_BASE
 {
-    css::uno::Reference< css::beans::XPropertySet > mxFont;
     ScVbaPalette mPalette;
     ScCellRangeObj* mpRangeObj;
     SfxItemSet*  GetDataSet();
@@ -54,7 +54,6 @@
 
 	// Attributes
     virtual css::uno::Any SAL_CALL getSize() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setSize( const css::uno::Any& _size ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getStandardFontSize() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setStandardFontSize( const css::uno::Any& _standardfontsize ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getStandardFont() throw (css::uno::RuntimeException);
@@ -64,23 +63,17 @@
     virtual css::uno::Any SAL_CALL getColorIndex() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getBold() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setBold( const css::uno::Any& _bold ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getUnderline() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setUnderline( const css::uno::Any& _underline ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getStrikethrough() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setStrikethrough( const css::uno::Any& _strikethrough ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getShadow() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setShadow( const css::uno::Any& _shadow ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getItalic() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setItalic( const css::uno::Any& _italic ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getSubscript() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setSubscript( const css::uno::Any& _subscript ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getSuperscript() throw (css::uno::RuntimeException);
     virtual void SAL_CALL setSuperscript( const css::uno::Any& _superscript ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getName() throw (css::uno::RuntimeException);
-    virtual void SAL_CALL setName( const css::uno::Any& _name ) throw (css::uno::RuntimeException);
     virtual css::uno::Any SAL_CALL getColor() throw (css::uno::RuntimeException) ;
-    virtual void SAL_CALL setColor( const css::uno::Any& _color ) throw (css::uno::RuntimeException) ;
     virtual css::uno::Any SAL_CALL getOutlineFont() throw (css::uno::RuntimeException) ;
     virtual void SAL_CALL setOutlineFont( const css::uno::Any& _outlinefont ) throw (css::uno::RuntimeException) ;
     // XHelperInterface
Index: sc/source/ui/vba/vbaassistant.hxx
===================================================================
--- sc/source/ui/vba/vbaassistant.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaassistant.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,8 +40,8 @@
 
 #include <sfx2/sfxhelp.hxx>
 
-#include "vbahelper.hxx"
-#include "vbahelperinterface.hxx"
+#include "excelvbahelper.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef ::cppu::WeakImplHelper1< ov::XAssistant > Assistant;
 typedef InheritedHelperInterfaceImpl< Assistant > ScVbaAssistantImpl_BASE;
Index: sc/source/ui/vba/vbaname.cxx
===================================================================
--- sc/source/ui/vba/vbaname.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaname.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,7 +27,7 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
@@ -64,7 +64,8 @@
 css::uno::Reference< ov::excel::XWorksheet >
 ScVbaName::getWorkSheet() throw (css::uno::RuntimeException)
 {
-	return ScVbaGlobals::getGlobalsImpl( mxContext )->getActiveSheet();
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	return xApplication->getActiveSheet();
 }
 
 ::rtl::OUString
@@ -234,7 +235,7 @@
 css::uno::Reference< ov::excel::XRange >
 ScVbaName::getRefersToRange() throw (css::uno::RuntimeException)
 {
-    uno::Reference< ov::excel::XRange > xRange = ScVbaRange::getRangeObjectForName( mxContext, mxNamedRange->getName(), getDocShell( mxModel ), formula::FormulaGrammar::CONV_XL_R1C1 );
+    uno::Reference< ov::excel::XRange > xRange = ScVbaRange::getRangeObjectForName( mxContext, mxNamedRange->getName(), excel::getDocShell( mxModel ), formula::FormulaGrammar::CONV_XL_R1C1 );
 	return xRange;
 }
 
Index: sc/source/ui/vba/vbaworkbooks.cxx
===================================================================
--- sc/source/ui/vba/vbaworkbooks.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworkbooks.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -56,7 +56,7 @@
 #include "vbaglobals.hxx"
 #include "vbaworkbook.hxx"
 #include "vbaworkbooks.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbahelper.hxx>
 
 #include <hash_map>
 #include <osl/file.hxx>
@@ -65,181 +65,34 @@
 
 const sal_Int16 CUSTOM_CHAR = 5;
 
-typedef  std::hash_map< rtl::OUString,
-sal_Int32, ::rtl::OUStringHash,
-::std::equal_to< ::rtl::OUString > > NameIndexHash;
-
-typedef std::vector < uno::Reference< sheet::XSpreadsheetDocument > > WorkBooks;
-
-typedef ::cppu::WeakImplHelper1< container::XEnumeration > SpreadSheetDocEnumImpl_BASE;
-
 static uno::Any
-getWorkbook( uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSpreadsheetDocument > &xDoc )
+getWorkbook( uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSpreadsheetDocument > &xDoc, const uno::Any& aApplication )
 {
 	// FIXME: fine as long as ScVbaWorkbook is stateless ...
 	uno::Reference< frame::XModel > xModel( xDoc, uno::UNO_QUERY );
 	if( !xModel.is() )
 		return uno::Any();
 	
-	ScVbaWorkbook *pWb = new ScVbaWorkbook(  uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( xContext )->getApplication(), uno::UNO_QUERY_THROW ), xContext, xModel );
+	ScVbaWorkbook *pWb = new ScVbaWorkbook(  uno::Reference< XHelperInterface >( aApplication, uno::UNO_QUERY_THROW ), xContext, xModel );
 	return uno::Any( uno::Reference< excel::XWorkbook > (pWb) );
 }
 
-
-// #FIXME clearly this is a candidate for some sort of helper base class as
-// this is a copy of SelectedSheetsEnum ( vbawindow.cxx )
-
-class SpreadSheetDocEnumImpl : public SpreadSheetDocEnumImpl_BASE
-{
-	uno::Reference< uno::XComponentContext > m_xContext;
-	WorkBooks m_books;
-	WorkBooks::const_iterator m_it;
-
-public:
-	SpreadSheetDocEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const WorkBooks& books ) throw ( uno::RuntimeException ) :  m_xContext( xContext ), m_books( books )
-	{
-		m_it = m_books.begin();
-	}
-	SpreadSheetDocEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException ) :  m_xContext( xContext )
-	{
-		uno::Reference< lang::XMultiComponentFactory > xSMgr(
-			m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
-
-		uno::Reference< frame::XDesktop > xDesktop
-			(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), m_xContext), uno::UNO_QUERY_THROW );
-		uno::Reference< container::XEnumeration > mxComponents = xDesktop->getComponents()->createEnumeration();
-		while( mxComponents->hasMoreElements() )
-		{
-			uno::Reference< sheet::XSpreadsheetDocument > xNext( mxComponents->nextElement(), uno::UNO_QUERY );
-			if ( xNext.is() )
-				m_books.push_back( xNext );
-		}
-		m_it = m_books.begin();
-	}
-	// XEnumeration
-	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
-	{ 
-		return m_it != m_books.end();
-	}
-
-	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
-	{ 
-		if ( !hasMoreElements() )
-		{
-			throw container::NoSuchElementException();
-		}
-		return makeAny( *(m_it++) );
-	}
-};
-
 class WorkBookEnumImpl : public EnumerationHelperImpl
 {
+	uno::Any m_aApplication;
 public:
-	WorkBookEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ){}
+	WorkBookEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration, const uno::Any& aApplication ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), m_aApplication( aApplication ) {}
 
 	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
 	{ 
 		uno::Reference< sheet::XSpreadsheetDocument > xDoc( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
-		return getWorkbook( m_xContext, xDoc );
+		return getWorkbook( m_xContext, xDoc, m_aApplication );
 	}
 
 };
 
-// #FIXME clearly this is also a candidate for some sort of helper base class as
-// a very similar one is used in vbawindow ( SelectedSheetsEnumAccess )
-// Maybe a template base class that does all of the operations on the hashmap
-// and vector only, and the sub-class does everything else
-// => ctor, createEnumeration & factory method need be defined ( to be called 
-// by getByIndex, getByName )
-typedef ::cppu::WeakImplHelper3< container::XEnumerationAccess 
-	, com::sun::star::container::XIndexAccess
-	, com::sun::star::container::XNameAccess
-	> WorkBooksAccessImpl_BASE;
-
-class WorkBooksAccessImpl : public WorkBooksAccessImpl_BASE
+ScVbaWorkbooks::ScVbaWorkbooks( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< css::uno::XComponentContext >& xContext ) : ScVbaWorkbooks_BASE( xParent, xContext, VbaDocumentsBase::EXCEL_DOCUMENT )
 {
-	uno::Reference< uno::XComponentContext > m_xContext;
-	WorkBooks m_books;
-	NameIndexHash namesToIndices;
-public:	
-	WorkBooksAccessImpl( const uno::Reference< uno::XComponentContext >& xContext ):m_xContext( xContext )
-	{
-		uno::Reference< container::XEnumeration > xEnum = new SpreadSheetDocEnumImpl( m_xContext );
-		sal_Int32 nIndex=0;
-		while( xEnum->hasMoreElements() )
-		{
-			uno::Reference< sheet::XSpreadsheetDocument > xNext( xEnum->nextElement(), uno::UNO_QUERY );
-			if ( xNext.is() )
-			{
-				m_books.push_back( xNext );
-				uno::Reference< frame::XModel > xModel( xNext, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
-				INetURLObject aURL( xModel->getURL() );
-				namesToIndices[ aURL.GetLastName() ] = nIndex++;
-			}
-		}
-			
-	}
-	
-	//XEnumerationAccess
-	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
-	{
-		return new SpreadSheetDocEnumImpl( m_xContext, m_books ); 
-	}
-	// XIndexAccess
-	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) 
-	{ 
-		return m_books.size();
-	}
-	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw ( lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
-	{ 
-		if ( Index < 0 
-			|| static_cast< WorkBooks::size_type >(Index) >= m_books.size() ) 
-			throw lang::IndexOutOfBoundsException();
-		return makeAny( m_books[ Index ] ); // returns xspreadsheetdoc
-	}
-
-	//XElementAccess
-	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
-	{ 
-		return sheet::XSpreadsheetDocument::static_type(0); 
-	}
-
-	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
-	{ 
-		return (m_books.size() > 0);
-	}
-
-	//XNameAccess
-	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
-	{ 
-		NameIndexHash::const_iterator it = namesToIndices.find( aName );
-		if ( it == namesToIndices.end() )
-			throw container::NoSuchElementException();
-		return makeAny( m_books[ it->second ] );
-		
-	}
-
-	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException) 
-	{ 
-		uno::Sequence< ::rtl::OUString > names( namesToIndices.size() );
-		::rtl::OUString* pString = names.getArray();
-		NameIndexHash::const_iterator it = namesToIndices.begin();
-		NameIndexHash::const_iterator it_end = namesToIndices.end();
-		for ( ; it != it_end; ++it, ++pString )
-			*pString = it->first;	
-		return names;	
-	}
-
-	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException) 
-	{ 
-		NameIndexHash::const_iterator it = namesToIndices.find( aName );
-		return (it != namesToIndices.end());
-	}
-
-};
-
-ScVbaWorkbooks::ScVbaWorkbooks( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< css::uno::XComponentContext >& xContext ) : ScVbaWorkbooks_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new WorkBooksAccessImpl( xContext ) ) )
-{
 }
 // XEnumerationAccess
 uno::Type
@@ -254,46 +107,32 @@
 	// the state of this object ( although it should ) would be 
 	// safer to create an enumeration based on this objects state
 	// rather than one effectively based of the desktop component
-	return new WorkBookEnumImpl( mxContext, uno::Reference< container::XEnumeration >( new SpreadSheetDocEnumImpl(mxContext) ) );
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new WorkBookEnumImpl( mxContext, xEnumerationAccess->createEnumeration(), Application() );
 }
 
 uno::Any
 ScVbaWorkbooks::createCollectionObject( const css::uno::Any& aSource )
 {
-	uno::Reference< sheet::XSpreadsheetDocument > xDoc( aSource, uno::UNO_QUERY );
-	return getWorkbook( mxContext, xDoc );
+	uno::Reference< sheet::XSpreadsheetDocument > xDoc( aSource, uno::UNO_QUERY_THROW );
+	return getWorkbook( mxContext, xDoc, Application() );
 }
 
 
 uno::Any SAL_CALL
 ScVbaWorkbooks::Add() throw (uno::RuntimeException)
 {
-	uno::Reference< lang::XMultiComponentFactory > xSMgr(
-        mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-
-	 uno::Reference< frame::XComponentLoader > xLoader(
-        xSMgr->createInstanceWithContext(
-            ::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
-                mxContext), uno::UNO_QUERY_THROW );
-	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL(
-									   rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("private:factory/scalc") ),
-									   rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_blank") ), 0, 
-									   uno::Sequence< beans::PropertyValue >(0) );			   
-    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xComponent, uno::UNO_QUERY_THROW );
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( VbaDocumentsBase::Add() , uno::UNO_QUERY_THROW );
                                                                                                                              
     if( xSpreadDoc.is() )
-        return getWorkbook( mxContext, xSpreadDoc );
+        return getWorkbook( mxContext, xSpreadDoc, Application() );
     return uno::Any();
 }
 
 void
 ScVbaWorkbooks::Close() throw (uno::RuntimeException)
 {
-	uno::Reference< lang::XMultiComponentFactory > xSMgr(
-		mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
-	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CloseDoc"));
-	dispatchRequests(xModel,url);
+    VbaDocumentsBase::Close();
 }
 
 bool 
@@ -337,24 +176,15 @@
 ScVbaWorkbooks::Open( const rtl::OUString& rFileName, const uno::Any& /*UpdateLinks*/, const uno::Any& ReadOnly, const uno::Any& Format, const uno::Any& /*Password*/, const uno::Any& /*WriteResPassword*/, const uno::Any& /*IgnoreReadOnlyRecommended*/, const uno::Any& /*Origin*/, const uno::Any& Delimiter, const uno::Any& /*Editable*/, const uno::Any& /*Notify*/, const uno::Any& /*Converter*/, const uno::Any& /*AddToMru*/ ) throw (uno::RuntimeException)
 {
 	// we need to detect if this is a URL, if not then assume its a file path
-        rtl::OUString aURL;
-        INetURLObject aObj;
+    rtl::OUString aURL;
+    INetURLObject aObj;
 	aObj.SetURL( rFileName );
 	bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
 	if ( bIsURL )
 		aURL = rFileName;
 	else
 		osl::FileBase::getFileURLFromSystemPath( rFileName, aURL );
-	uno::Reference< lang::XMultiComponentFactory > xSMgr(
-		mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
-	uno::Reference< frame::XDesktop > xDesktop
-		(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop")                    , mxContext),
-		uno::UNO_QUERY_THROW );
-	uno::Reference< frame::XComponentLoader > xLoader(
-		xSMgr->createInstanceWithContext(
-		::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
-		mxContext),
-		uno::UNO_QUERY_THROW );
+
 	uno::Sequence< beans::PropertyValue > sProps(0);
 	sal_Int32 nIndex = 0;
 	
@@ -421,30 +251,20 @@
 	else if ( !isSpreadSheetFile( sType ) )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Bad Format")), uno::Reference< uno::XInterface >() );
 	
-	if ( ReadOnly.hasValue()  )
-	{
-		sal_Bool bIsReadOnly = sal_False; ReadOnly >>= bIsReadOnly;
-		if ( bIsReadOnly )
-		{
-			static const rtl::OUString sReadOnly( RTL_CONSTASCII_USTRINGPARAM("ReadOnly") );
-			sProps.realloc( sProps.getLength() + 1 );
-			sProps[ nIndex ].Name = sReadOnly;
-			sProps[ nIndex++ ].Value = uno::makeAny( (sal_Bool)sal_True );
-		}
-	}
-
-	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL( aURL,
-		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_default") ),
-		frame::FrameSearchFlag::CREATE,
-		sProps);
-	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xComponent, uno::UNO_QUERY_THROW );
-	uno::Any aRet = getWorkbook( mxContext, xSpreadDoc );
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( VbaDocumentsBase::Open( rFileName, ReadOnly, sProps ), uno::UNO_QUERY_THROW );
+	uno::Any aRet = getWorkbook( mxContext, xSpreadDoc, Application() );
 	uno::Reference< excel::XWorkbook > xWBook( aRet, uno::UNO_QUERY );
 	if ( xWBook.is() )
 		xWBook->Activate();
 	return aRet;
 }
 
+uno::Any
+ScVbaWorkbooks::Open( const rtl::OUString& Filename, const uno::Any& ReadOnly, const uno::Sequence< beans::PropertyValue >& rProps ) throw (css::uno::RuntimeException)
+{
+	return VbaDocumentsBase::Open( Filename, ReadOnly, rProps );
+}
+
 rtl::OUString& 
 ScVbaWorkbooks::getServiceImplName()
 {
Index: sc/source/ui/vba/vbamenubars.hxx
===================================================================
--- sc/source/ui/vba/vbamenubars.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenubars.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENUBARS_HXX
+#define SC_VBA_MENUBARS_HXX
+
+#include <ooo/vba/excel/XMenuBars.hpp>
+#include <ooo/vba/excel/XMenuBar.hpp>
+#include <ooo/vba/XCommandBars.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::excel::XMenuBars > MenuBars_BASE;
+
+class ScVbaMenuBars : public MenuBars_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBars > m_xCommandBars;
+
+public:
+    ScVbaMenuBars( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XCommandBars >& xCommandBars ) throw (css::uno::RuntimeException);
+    virtual ~ScVbaMenuBars();
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& aIndex, const css::uno::Any& /*aIndex2*/ ) throw( css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_MENUBARS_HXX
Index: sc/source/ui/vba/vbamenuitem.cxx
===================================================================
--- sc/source/ui/vba/vbamenuitem.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenuitem.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamenuitem.hxx" 
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaMenuItem::ScVbaMenuItem( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, const uno::Reference< XCommandBarControl >& xCommandBarControl ) throw( uno::RuntimeException ) : MenuItem_BASE( xParent, xContext ), m_xCommandBarControl( xCommandBarControl )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getCaption() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getCaption();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setCaption( _caption );
+}
+
+::rtl::OUString SAL_CALL
+ScVbaMenuItem::getOnAction() throw ( uno::RuntimeException )
+{
+    return m_xCommandBarControl->getOnAction();
+}
+
+void SAL_CALL
+ScVbaMenuItem::setOnAction( const ::rtl::OUString& _onaction ) throw (uno::RuntimeException)
+{
+    m_xCommandBarControl->setOnAction( _onaction );
+}
+
+void SAL_CALL
+ScVbaMenuItem::Delete( ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    m_xCommandBarControl->Delete();
+}
+
+rtl::OUString& 
+ScVbaMenuItem::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMenuItem") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaMenuItem::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.MenuItem" ) );
+	}
+	return aServiceNames;
+}
Index: sc/source/ui/vba/vbadialogs.hxx
===================================================================
--- sc/source/ui/vba/vbadialogs.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbadialogs.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -30,26 +30,24 @@
 #ifndef SC_VBA_DIALOGS_HXX
 #define SC_VBA_DIALOGS_HXX
 
-#include <cppuhelper/implbase1.hxx>
-
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <ooo/vba/excel/XDialogs.hpp>
 #include <ooo/vba/XCollection.hpp>
-#include "vbahelperinterface.hxx" 
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadialogsbase.hxx>
+#include <cppuhelper/implbase1.hxx>
 
-class ScModelObj;
+typedef cppu::ImplInheritanceHelper1< VbaDialogsBase, ov::excel::XDialogs > ScVbaDialogs_BASE;
 
-typedef InheritedHelperInterfaceImpl1< ov::excel::XDialogs > ScVbaDialogs_BASE;
-
 class ScVbaDialogs : public ScVbaDialogs_BASE
 {
 public:
-	ScVbaDialogs( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext ): ScVbaDialogs_BASE( xParent, xContext ) {} 
+	ScVbaDialogs( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel ): ScVbaDialogs_BASE( xParent, xContext, xModel ) {} 
 	virtual ~ScVbaDialogs() {}
 
 	// XCollection
-	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException); //liuchen 2009-7-27
 
 	// XDialogs
 	virtual void SAL_CALL Dummy() throw (css::uno::RuntimeException);
Index: sc/source/ui/vba/vbaglobals.hxx
===================================================================
--- sc/source/ui/vba/vbaglobals.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaglobals.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,43 +33,67 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
-#include <ooo/vba/XGlobals.hpp>
+#include <ooo/vba/excel/XGlobals.hpp>
+#include <ooo/vba/excel/XApplication.hpp>
 
 #include <cppuhelper/implbase1.hxx>
-#include "vbahelper.hxx"
+#include "excelvbahelper.hxx"
 
+#include <vbahelper/vbaglobalbase.hxx>
     // =============================================================================
     // class ScVbaGlobals
     // =============================================================================
 
-    typedef ::cppu::WeakImplHelper1<    
- ov::XGlobals > ScVbaGlobals_BASE;
+typedef ::cppu::ImplInheritanceHelper1< VbaGlobalsBase, ov::excel::XGlobals > ScVbaGlobals_BASE;
 
-
     class ScVbaGlobals : public ScVbaGlobals_BASE
     {
-    private:
-            css::uno::Reference< css::uno::XComponentContext > m_xContext;
-            css::uno::Reference< ov::excel::XApplication > mxApplication;
+        css::uno::Reference< ov::excel::XApplication > mxApplication;
+        virtual css::uno::Reference<
+ ov::excel::XApplication > SAL_CALL getApplication()
+                        throw (css::uno::RuntimeException);
     public:
 	
-        ScVbaGlobals(
+        ScVbaGlobals( css::uno::Sequence< css::uno::Any > const& aArgs,
             css::uno::Reference< css::uno::XComponentContext >const& rxContext );
+        //ScVbaGlobals(
+        //    css::uno::Reference< css::uno::XComponentContext >const& rxContext,  );
         virtual ~ScVbaGlobals();
 
-		static 	css::uno::Reference< ov::XGlobals > getGlobalsImpl(const css::uno::Reference< css::uno::XComponentContext >& ) throw (css::uno::RuntimeException);
-
         // XGlobals
-        virtual css::uno::Reference<
- ov::excel::XApplication > SAL_CALL getApplication()
-                        throw (css::uno::RuntimeException);
         virtual css::uno::Reference< ov::excel::XWorkbook > SAL_CALL getActiveWorkbook() throw (css::uno::RuntimeException);
+        virtual css::uno::Reference< ov::excel::XWindow > SAL_CALL getActiveWindow() throw (css::uno::RuntimeException);
         virtual css::uno::Reference< ov::excel::XWorksheet > SAL_CALL getActiveSheet() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::XAssistant > SAL_CALL getAssistant() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Calculate(  ) throw (::com::sun::star::script::BasicErrorException, ::com::sun::star::uno::RuntimeException);
+
+	virtual css::uno::Any SAL_CALL getSelection() throw (css::uno::RuntimeException);
+        virtual css::uno::Reference< ov::excel::XRange > SAL_CALL getActiveCell() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::excel::XWorkbook > SAL_CALL getThisWorkbook() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Cells( const css::uno::Any& RowIndex, const css::uno::Any& ColumnIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Columns( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL CommandBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Evaluate( const ::rtl::OUString& Name ) throw (css::uno::RuntimeException);
+
         virtual css::uno::Any SAL_CALL WorkSheets(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
         virtual css::uno::Any SAL_CALL WorkBooks(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL WorksheetFunction(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
-	virtual css::uno::Sequence< css::uno::Any > SAL_CALL getGlobals(  ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Range( const css::uno::Any& Cell1, const css::uno::Any& Cell2 ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< ::ooo::vba::excel::XRange > SAL_CALL Rows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
 	virtual css::uno::Any SAL_CALL Names( const css::uno::Any& aIndex ) throw ( css::uno::RuntimeException );
+	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Intersect( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+	virtual css::uno::Reference< ov::excel::XRange > SAL_CALL Union( const css::uno::Reference< ov::excel::XRange >& Arg1, const css::uno::Reference< ov::excel::XRange >& Arg2, const css::uno::Any& Arg3, const css::uno::Any& Arg4, const css::uno::Any& Arg5, const css::uno::Any& Arg6, const css::uno::Any& Arg7, const css::uno::Any& Arg8, const css::uno::Any& Arg9, const css::uno::Any& Arg10, const css::uno::Any& Arg11, const css::uno::Any& Arg12, const css::uno::Any& Arg13, const css::uno::Any& Arg14, const css::uno::Any& Arg15, const css::uno::Any& Arg16, const css::uno::Any& Arg17, const css::uno::Any& Arg18, const css::uno::Any& Arg19, const css::uno::Any& Arg20, const css::uno::Any& Arg21, const css::uno::Any& Arg22, const css::uno::Any& Arg23, const css::uno::Any& Arg24, const css::uno::Any& Arg25, const css::uno::Any& Arg26, const css::uno::Any& Arg27, const css::uno::Any& Arg28, const css::uno::Any& Arg29, const css::uno::Any& Arg30 ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+    virtual css::uno::Any SAL_CALL MenuBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
+
+
+    // XMultiServiceFactory
+    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getAvailableServiceNames(  ) throw (css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
     };
 #endif // 
Index: sc/source/ui/vba/vbavalidation.hxx
===================================================================
--- sc/source/ui/vba/vbavalidation.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbavalidation.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,7 +33,7 @@
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <ooo/vba/excel/XValidation.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1<ov::excel::XValidation > ValidationImpl_BASE;
 
Index: sc/source/ui/vba/vbamenu.hxx
===================================================================
--- sc/source/ui/vba/vbamenu.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/vbamenu.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MENU_HXX
+#define SC_VBA_MENU_HXX
+
+#include <ooo/vba/excel/XMenu.hpp>
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::excel::XMenu > Menu_BASE;
+
+class ScVbaMenu : public Menu_BASE
+{
+private:
+    css::uno::Reference< ov::XCommandBarControl > m_xCommandBarControl;
+
+public:
+    ScVbaMenu( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< ov::XCommandBarControl >& xCommandBarControl ) throw( css::uno::RuntimeException );
+    
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL MenuItems( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_MENU_HXX
Index: sc/source/ui/vba/vbaworksheet.cxx
===================================================================
--- sc/source/ui/vba/vbaworksheet.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworksheet.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,11 +27,12 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 #include <cppuhelper/queryinterface.hxx>
 
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XIntrospectionAccess.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 #include <com/sun/star/util/XProtectable.hpp>
 #include <com/sun/star/table/XCellRange.hpp>
@@ -58,6 +59,8 @@
 #include <com/sun/star/drawing/XControlShape.hpp>
 #include <com/sun/star/form/FormComponentType.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
+#include <ooo/vba/excel/XlEnableSelection.hpp>
+#include <ooo/vba/XControlProvider.hpp>
 
 #include <comphelper/processfactory.hxx>
 
@@ -74,7 +77,9 @@
 
 #include "cellsuno.hxx"
 #include "drwlayer.hxx"
-
+#ifdef CWSSCSHEETPROTECTION
+#include "tabprotection.hxx"
+#endif
 #include "scextopt.hxx"
 #include "vbaoutline.hxx"
 #include "vbarange.hxx"
@@ -82,10 +87,9 @@
 #include "vbaworksheet.hxx"
 #include "vbachartobjects.hxx"
 #include "vbapivottables.hxx"
-#include "vbacombobox.hxx"
 #include "vbaoleobject.hxx"
 #include "vbaoleobjects.hxx"
-#include "vbashapes.hxx"
+#include <vbahelper/vbashapes.hxx>
 #include "vbapagesetup.hxx"
 #include "vbapagebreaks.hxx"
 
@@ -94,7 +98,7 @@
 #define DOESNOTEXIST -1
 using namespace com::sun::star;
 using namespace ooo::vba;
-static bool
+bool
 nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
 {
 	if (!xSpreadDoc.is())
@@ -257,6 +261,83 @@
 	return getSheetID() + 1;
 }
 
+sal_Int32
+ScVbaWorksheet::getEnableSelection() throw (uno::RuntimeException)
+{
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+    SCTAB nTab = 0;
+    rtl::OUString aSheetName = getName();
+    bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
+    if ( bSheetExists )
+    {
+        uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+		sal_Bool bLockedCells = sal_False;
+		sal_Bool bUnlockedCells = sal_False;
+		if( pProtect )
+		{
+        	bLockedCells   = pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        	bUnlockedCells = pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+		}
+        if( bLockedCells )
+            return excel::XlEnableSelection::xlNoRestrictions;
+        if( bUnlockedCells )
+            return excel::XlEnableSelection::xlUnlockedCells;
+        return excel::XlEnableSelection::xlNoSelection;    
+    }
+    else
+		throw uno::RuntimeException(::rtl::OUString(
+                                RTL_CONSTASCII_USTRINGPARAM( "Sheet Name does not exist. ") ),
+                                uno::Reference< XInterface >() );
+    return excel::XlEnableSelection::xlNoSelection;
+}    
+
+
+void
+ScVbaWorksheet::setEnableSelection( sal_Int32 nSelection ) throw (uno::RuntimeException)
+{
+    if( (nSelection != excel::XlEnableSelection::xlNoRestrictions) &&
+        (nSelection != excel::XlEnableSelection::xlUnlockedCells) &&
+        (nSelection != excel::XlEnableSelection::xlNoSelection) )
+    {
+        DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+    SCTAB nTab = 0;
+    rtl::OUString aSheetName = getName();
+    bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
+    if ( bSheetExists )
+    {
+        uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+        ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+        ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+        // default is xlNoSelection
+        sal_Bool bLockedCells = sal_False;
+        sal_Bool bUnlockedCells = sal_False;
+        if( nSelection == excel::XlEnableSelection::xlNoRestrictions )
+        {
+            bLockedCells = sal_True;
+            bUnlockedCells = sal_True;
+        }
+        else if( nSelection == excel::XlEnableSelection::xlUnlockedCells )
+        {
+            bUnlockedCells = sal_True;
+        }
+		if( pProtect )
+		{
+        	pProtect->setOption( ScTableProtection::SELECT_LOCKED_CELLS, bLockedCells );
+        	pProtect->setOption( ScTableProtection::SELECT_UNLOCKED_CELLS, bUnlockedCells );
+		}	
+    }
+    else
+		throw uno::RuntimeException(::rtl::OUString(
+                                RTL_CONSTASCII_USTRINGPARAM( "Sheet Name does not exist. ") ),
+                                uno::Reference< XInterface >() );
+
+}
+
 uno::Reference< excel::XRange > 
 ScVbaWorksheet::getUsedRange() throw (uno::RuntimeException)
 {
@@ -292,6 +373,16 @@
    return uno::makeAny( xHPageBreaks );
 }
 
+uno::Any
+ScVbaWorksheet::VPageBreaks( const uno::Any& aIndex ) throw ( uno::RuntimeException )
+{
+	uno::Reference< sheet::XSheetPageBreak > xSheetPageBreak( getSheet(), uno::UNO_QUERY_THROW );
+	uno::Reference< excel::XVPageBreaks > xVPageBreaks( new ScVbaVPageBreaks( this, mxContext, xSheetPageBreak ) ); 
+	if( aIndex.hasValue() )
+		return xVPageBreaks->Item( aIndex, uno::Any()); 
+	return uno::makeAny( xVPageBreaks );
+}
+
 sal_Int32 
 ScVbaWorksheet::getStandardWidth() throw (uno::RuntimeException)
 {
@@ -320,6 +411,22 @@
 sal_Bool 
 ScVbaWorksheet::getProtectDrawingObjects() throw (uno::RuntimeException) 
 {
+#ifdef CWSSCSHEETPROTECTION
+	SCTAB nTab = 0;
+	rtl::OUString aSheetName = getName();
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+	bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
+	if ( bSheetExists )
+	{
+		uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+		ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+		ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+		if ( pProtect )
+			return pProtect->getOption( ScTableProtection::OBJECTS ); 
+        }
+#else
+	return getProtectContents(); // fallback
+#endif 
 	return false;
 }
 
@@ -353,11 +460,11 @@
 		uno::Reference<excel::XRange> xRange =  new ScVbaRange( this, mxContext, xRange1);
 		if (xRange.is())
 			xRange->Select();
-		implnCopy();
+		excel::implnCopy(mxModel);
 		uno::Reference<frame::XModel> xModel = openNewDoc(aCurrSheetName);
 		if (xModel.is()) 
 		{
-			implnPaste();
+			excel::implnPaste(xModel);
 			Delete();
 		}
 		return ;
@@ -391,11 +498,11 @@
 		uno::Reference<excel::XRange> xRange =  new ScVbaRange( this, mxContext, xRange1);
 		if (xRange.is())
 			xRange->Select();
-		implnCopy();
+		excel::implnCopy(mxModel);
 		uno::Reference<frame::XModel> xModel = openNewDoc(aCurrSheetName);
 		if (xModel.is())
 		{
-			implnPaste();
+			excel::implnPaste(xModel);
 		}
 		return;
 	}
@@ -424,7 +531,7 @@
 	uno::Reference<excel::XRange> xRange( Destination, uno::UNO_QUERY );
 	if ( xRange.is() )
 		xRange->Select();
-	implnPaste();
+	excel::implnPaste( mxModel );
 }
 
 void 
@@ -468,13 +575,25 @@
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getNext() throw (uno::RuntimeException)
 {
-	return getSheetAtOffset(static_cast<SCTAB>(1));
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(static_cast<SCTAB>(1));
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 uno::Reference< excel::XWorksheet >
 ScVbaWorksheet::getPrevious() throw (uno::RuntimeException)
 {
-	return getSheetAtOffset(-1);
+	//VBA, minz@cn.ibm.com. catch the exception for index out of bound
+	try{
+		return getSheetAtOffset(-1);
+	}catch( lang::IndexOutOfBoundsException& /*e*/ )
+	{
+		return NULL;
+	}
 }
 
 
@@ -558,7 +677,7 @@
 		uno::Reference< table::XTableChartsSupplier > xChartSupplier( getSheet(), uno::UNO_QUERY_THROW );
 		uno::Reference< table::XTableCharts > xTableCharts = xChartSupplier->getCharts();
 		
-		uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( getSheet(), uno::UNO_QUERY_THROW ); //VBA, minz@cn.ibm.com.
 		mxCharts = new ScVbaChartObjects(  this, mxContext, xTableCharts, xDrawPageSupplier );
 	}
 	if ( Index.hasValue() )
@@ -624,7 +743,7 @@
     uno::Reference< drawing::XShapes > xShapes( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
     uno::Reference< container::XIndexAccess > xIndexAccess( xShapes, uno::UNO_QUERY_THROW );
 
-   uno::Reference< msforms::XShapes> xVbaShapes( new ScVbaShapes( this, mxContext, xIndexAccess ) );
+   uno::Reference< msforms::XShapes> xVbaShapes( new ScVbaShapes( this, mxContext, xIndexAccess, getModel() ) );
    if ( aIndex.hasValue() )
       return xVbaShapes->Item( aIndex, uno::Any() ); 
    return uno::makeAny( xVbaShapes );
@@ -635,7 +754,7 @@
 {
 #ifdef VBA_OOBUILD_HACK 
 	uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
-	ScTabViewShell* pTabViewShell = getBestViewShell( xModel );
+	ScTabViewShell* pTabViewShell = excel::getBestViewShell( xModel );
 
 	ScAbstractDialogFactory* pFact = ScAbstractDialogFactory::Create();
 	DBG_ASSERT(pFact, "ScAbstractFactory create fail!");//CHINA001
@@ -676,17 +795,19 @@
 }
 
 void SAL_CALL 
-ScVbaWorksheet::setValue( const ::rtl::OUString& /*aPropertyName*/, const uno::Any& /*aValue*/ ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+ScVbaWorksheet::setValue( const ::rtl::OUString& aPropertyName, const uno::Any& aValue ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
 {
-	throw uno::RuntimeException(); // unsupported operation
+    setDefaultPropByIntrospection( uno::makeAny( getValue( aPropertyName ) ), aValue );
 }
 uno::Any SAL_CALL 
 ScVbaWorksheet::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::UnknownPropertyException, uno::RuntimeException)
 {
     uno::Reference< drawing::XControlShape > xControlShape( getControlShape( aPropertyName ), uno::UNO_QUERY_THROW );
-    ScVbaControlFactory controlFactory( mxContext, xControlShape, getModel() );
-    uno::Reference< msforms::XControl > xControl( controlFactory.createControl( getModel() ) );
-	return uno::makeAny( xControl );
+    
+    uno::Reference<lang::XMultiComponentFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< XControlProvider > xControlProvider( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.ControlProvider" ) ), mxContext ), uno::UNO_QUERY_THROW );
+    uno::Reference< msforms::XControl > xControl( xControlProvider->createControl(  xControlShape, getModel() ) );
+    return uno::makeAny( xControl );
 }
 
 ::sal_Bool SAL_CALL 
@@ -794,7 +915,7 @@
 rtl::OUString SAL_CALL
 ScVbaWorksheet::getCodeName() throw (css::uno::RuntimeException)
 {
-#ifdef VBA_OOBUILD_HACK 
+#if 0
     uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
     SCTAB nTab = 0;
     rtl::OUString aSheetName = getName();
@@ -815,7 +936,7 @@
 	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
 #endif
 }
-#ifdef VBA_OOBUILD_HACK 
+#if 0
 void SAL_CALL
 ScVbaWorksheet::setCodeName( const rtl::OUString& sCodeName ) throw (css::uno::RuntimeException)
 {
@@ -845,7 +966,7 @@
 sal_Int16
 ScVbaWorksheet::getSheetID() throw (uno::RuntimeException)
 {
-	uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxSheet, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( getSheet(), uno::UNO_QUERY_THROW ); //VBA. minz@cn.ibm.com. if ActiveSheet, mxSheet is null.
 	return xAddressable->getRangeAddress().Sheet;
 }
 
@@ -869,10 +990,9 @@
 		bSelection = sal_True;
 
     uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );  
-	PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, xModel, bSelection );
+	PrintOutHelper( excel::getBestViewShell( xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, bSelection );
 }
 
-
 namespace worksheet
 {
 namespace sdecl = comphelper::service_decl;
Index: sc/source/ui/vba/testvba/TestDocuments/PageSetup.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: sc/source/ui/vba/testvba/TestDocuments/Ranges.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: sc/source/ui/vba/testvba/TestDocuments/TestAddress.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: sc/source/ui/vba/testvba/TestDocuments/TestUnion.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/TestUnion.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/testvba/TestDocuments/CalcFont.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/CalcFont.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/testvba/TestDocuments/window2.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: sc/source/ui/vba/testvba/TestDocuments/MiscOperatorTests.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/MiscOperatorTests.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/testvba/TestDocuments/pagesetup.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/pagesetup.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream


Index: sc/source/ui/vba/testvba/TestDocuments/VariantTest.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/VariantTest.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/testvba/TestDocuments/TestIntersection.xls
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/TestDocuments/TestIntersection.xls
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/testvba/runTests.pl
===================================================================
--- sc/source/ui/vba/testvba/runTests.pl	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/testvba/runTests.pl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -20,7 +20,7 @@
 my $officepath = shift || die "please specify path to office installation program dir";
 my $DocName = shift || "";
 my $programpath = "$officepath"."3/program:$officepath/program:";
-my $basiclibrarypath = "$officepath/basis3.1/program";
+my $basiclibrarypath = "$officepath/basis3.2/program";
 my $urelibpath = "$officepath/ure/lib";
 my $binext = "";
 my $testDocDir = "$binDir/TestDocuments";
Index: sc/source/ui/vba/testvba/testvba.cxx
===================================================================
--- sc/source/ui/vba/testvba/testvba.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/testvba/testvba.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -159,15 +159,15 @@
                         Reference< script::provider::XScript > xScript;
 						try
                         {
-						    xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.TestMacros.Main?language=Basic&location=document" ));
+						    xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.TestMacros.Main?language=Basic&location=document" ));
                         } catch ( uno::Exception& e )
                         {
                             try
                             {
-						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMacro.Main?language=Basic&location=document" ));
+						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMacro.Main?language=Basic&location=document" ));
                             } catch ( uno::Exception& e2 )
                             {
-						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.testMain.Main?language=Basic&location=document" ));
+						        xScript = xProv->getScript( rtl::OUString::createFromAscii( "vnd.sun.star.script:VBAProject.testMain.Main?language=Basic&location=document" ));
                             }
                         }
 						OSL_TRACE("Got script for doc %s", rtl::OUStringToOString( sUrl, RTL_TEXTENCODING_UTF8 ).getStr() );
Index: sc/source/ui/vba/testvba/list1
===================================================================
--- sc/source/ui/vba/testvba/list1	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/testvba/list1	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,28 @@
+AutoFilter
+bytearraystring
+CalcFont
+dateserial
+datevalue
+format
+MiscOperatorTests
+MiscRangeTests
+PageBreaks
+PageSetup
+partition
+range-4
+Ranges-2
+Ranges-3
+Ranges
+replace
+Shapes
+StrConv-test
+stringplusdouble
+Template
+TestAddress
+TestCalc_Rangetest2
+TestCalc_Rangetest
+TestIntersection
+TestUnion
+VariantTest
+window2
+Window
Index: sc/source/ui/vba/testvba/list2
===================================================================
--- sc/source/ui/vba/testvba/list2	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/testvba/list2	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,28 @@
+AutoFilter
+bytearraystring
+CalcFont
+dateserial
+datevalue
+format
+MiscOperatorTests
+MiscRangeTests
+PageBreaks
+PageSetup
+partition
+range-4
+Ranges-2
+Ranges-3
+Ranges
+replace
+Shapes
+StrConv-test
+stringplusdouble
+Template
+TestAddress
+TestCalc_Rangetest2
+TestCalc_Rangetest
+TestIntersection
+TestUnion
+VariantTest
+window2
+Window
Index: sc/source/ui/vba/testvba/list3
===================================================================
--- sc/source/ui/vba/testvba/list3	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/vba/testvba/list3	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,28 @@
+AutoFilter
+bytearraystring
+CalcFont
+dateserial
+datevalue
+format
+MiscOperatorTests
+MiscRangeTests
+PageBreaks
+pagesetup
+partition
+range-4
+Ranges-2
+Ranges-3
+Ranges
+replace
+Shapes
+StrConv-test
+stringplusdouble
+Template
+TestAddress
+TestCalc_Rangetest2
+TestCalc_Rangetest
+TestIntersection
+TestUnion
+VariantTest
+window2
+Window
Index: sc/source/ui/vba/testvba/testclient
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: sc/source/ui/vba/testvba/testclient
___________________________________________________________________
Added: svn:executable
   + *
Added: svn:mime-type
   + application/octet-stream

Index: sc/source/ui/vba/vbahelper.cxx
===================================================================
--- sc/source/ui/vba/vbahelper.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbahelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,828 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbahelper.cxx,v $
- * $Revision: 1.5.32.1 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <cppuhelper/bootstrap.hxx>
-#include <com/sun/star/util/XURLTransformer.hpp>
-#include <com/sun/star/frame/XDispatchProvider.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-#include <com/sun/star/frame/XFrame.hpp>
-#include <com/sun/star/frame/XDesktop.hpp>
-#include <com/sun/star/frame/XController.hpp>
-#include <com/sun/star/uno/XComponentContext.hpp>
-#include <com/sun/star/lang/XMultiComponentFactory.hpp>
-#include <com/sun/star/beans/XPropertySet.hpp>
-#include <com/sun/star/beans/XIntrospection.hpp>
-
-#include <comphelper/processfactory.hxx>
-
-#include <sfx2/objsh.hxx>
-#include <sfx2/viewfrm.hxx>
-#include <sfx2/dispatch.hxx>
-#include <sfx2/app.hxx>
-#include <svtools/stritem.hxx>
-
-#include <docuno.hxx>
-
-#include <basic/sbx.hxx>
-#include <basic/sbstar.hxx>
-#include <rtl/math.hxx>
-
-#include <math.h>
-#include "vbahelper.hxx"
-#include "tabvwsh.hxx"
-#include "transobj.hxx"
-#include "scmod.hxx"
-#include "vbashape.hxx"
-#include "unonames.hxx"
-#include "cellsuno.hxx"
-using namespace ::com::sun::star;
-using namespace ::ooo::vba;
-
-#define POINTTO100THMILLIMETERFACTOR 35.27778
-void unoToSbxValue( SbxVariable* pVar, const uno::Any& aValue );
-
-uno::Any sbxToUnoValue( SbxVariable* pVar );
-
-
-namespace ooo
-{
-namespace vba
-{
-
-const double Millimeter::factor =  35.27778;
-
-uno::Reference< beans::XIntrospectionAccess >
-getIntrospectionAccess( const uno::Any& aObject ) throw (uno::RuntimeException)
-{
-	static uno::Reference< beans::XIntrospection > xIntrospection;
-	if( !xIntrospection.is() )
-	{
-		uno::Reference< lang::XMultiServiceFactory > xFactory( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-		xIntrospection.set( xFactory->createInstance( rtl::OUString::createFromAscii("com.sun.star.beans.Introspection") ), uno::UNO_QUERY_THROW );
-	}
-	return xIntrospection->inspect( aObject );
-}
-
-uno::Reference< script::XTypeConverter >
-getTypeConverter( const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
-{
-	static uno::Reference< script::XTypeConverter > xTypeConv( xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), xContext ), uno::UNO_QUERY_THROW );
-	return xTypeConv;
-}
-// helper method to determine if the view ( calc ) is in print-preview mode
-bool isInPrintPreview( SfxViewFrame* pView )
-{
-	sal_uInt16 nViewNo = SID_VIEWSHELL1 - SID_VIEWSHELL0;
-	if ( pView->GetObjectShell()->GetFactory().GetViewFactoryCount() >
-nViewNo && !pView->GetObjectShell()->IsInPlaceActive() )
-	{
-		SfxViewFactory &rViewFactory =
-			pView->GetObjectShell()->GetFactory().GetViewFactory(nViewNo);
-		if (  pView->GetCurViewId() == rViewFactory.GetOrdinal() )
-			return true;
-	}
-	return false;
-}
-const ::rtl::OUString REPLACE_CELLS_WARNING(  RTL_CONSTASCII_USTRINGPARAM( "ReplaceCellsWarning"));
-const uno::Any&
-aNULL()
-{
- 	static  uno::Any aNULLL = uno::makeAny( uno::Reference< uno::XInterface >() );
-	return aNULLL;
-}
-
-class PasteCellsWarningReseter
-{
-private:
-	bool bInitialWarningState;
-	static uno::Reference< beans::XPropertySet > getGlobalSheetSettings() throw ( uno::RuntimeException )
-	{
-		static uno::Reference< beans::XPropertySet > xTmpProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-		static uno::Reference<uno::XComponentContext > xContext( xTmpProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-		static uno::Reference<lang::XMultiComponentFactory > xServiceManager(
-				xContext->getServiceManager(), uno::UNO_QUERY_THROW );
-		static uno::Reference< beans::XPropertySet > xProps( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sheet.GlobalSheetSettings" ) ) ,xContext ), uno::UNO_QUERY_THROW );
-		return xProps;
-	}
-
-	bool getReplaceCellsWarning() throw ( uno::RuntimeException )
-	{
-		sal_Bool res = sal_False;
-		getGlobalSheetSettings()->getPropertyValue( REPLACE_CELLS_WARNING ) >>= res;
-		return ( res == sal_True );
-	}
-
-	void setReplaceCellsWarning( bool bState ) throw ( uno::RuntimeException )
-	{
-		getGlobalSheetSettings()->setPropertyValue( REPLACE_CELLS_WARNING, uno::makeAny( bState ) );
-	}
-public:
-	PasteCellsWarningReseter() throw ( uno::RuntimeException )
-	{
-		bInitialWarningState = getReplaceCellsWarning();
-		if ( bInitialWarningState )
-			setReplaceCellsWarning( false );
-	}
-	~PasteCellsWarningReseter()
-	{
-		if ( bInitialWarningState )
-		{
-			// don't allow dtor to throw
-			try
-			{
-				setReplaceCellsWarning( true );
-			}
-			catch ( uno::Exception& /*e*/ ){}
-		}
-	}
-};
-
-void
-dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl, uno::Sequence< beans::PropertyValue >& sProps )
-{
-
-	util::URL  url ;
-	url.Complete = aUrl;
-	rtl::OUString emptyString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "" ));
-	uno::Reference<frame::XController> xController = xModel->getCurrentController();
-	uno::Reference<frame::XFrame> xFrame = xController->getFrame();
-	uno::Reference<frame::XDispatchProvider> xDispatchProvider (xFrame,uno::UNO_QUERY_THROW);
-	try
-	{
-		uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-		uno::Reference<uno::XComponentContext > xContext( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW  );
-		if ( !xContext.is() )
-		{
-			return ;
-		}
-
-		uno::Reference<lang::XMultiComponentFactory > xServiceManager(
-				xContext->getServiceManager() );
-		if ( !xServiceManager.is() )
-		{
-			return ;
-		}
-		uno::Reference<util::XURLTransformer> xParser( xServiceManager->createInstanceWithContext(     rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.util.URLTransformer" ) )
-			,xContext), uno::UNO_QUERY_THROW );
-		if (!xParser.is())
-			return;
-		xParser->parseStrict (url);
-	}
-	catch ( uno::Exception & /*e*/ )
-	{
-		return ;
-	}
-
-	uno::Reference<frame::XDispatch> xDispatcher = xDispatchProvider->queryDispatch(url,emptyString,0);
-
-	uno::Sequence<beans::PropertyValue> dispatchProps(1);
-
-	sal_Int32 nProps = sProps.getLength();
-	beans::PropertyValue* pDest = dispatchProps.getArray();
-	if ( nProps )
-	{
-		dispatchProps.realloc( nProps + 1 );
-		// need to reaccquire pDest after realloc
-		pDest = dispatchProps.getArray();
-		beans::PropertyValue* pSrc = sProps.getArray();
-		for ( sal_Int32 index=0; index<nProps; ++index, ++pSrc, ++pDest )
-			*pDest = *pSrc;
-	}
-
-	(*pDest).Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Silent" ));
-	(*pDest).Value <<= (sal_Bool)sal_True;
-
-	if (xDispatcher.is())
-		xDispatcher->dispatch( url, dispatchProps );
-}
-
-void
-dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl) 
-{
-	uno::Sequence<beans::PropertyValue> dispatchProps;
-	dispatchRequests( xModel, aUrl, dispatchProps );
-}
-
-
-void dispatchExecute(css::uno::Reference< css::frame::XModel>& xModel, USHORT nSlot, SfxCallMode nCall)
-{
-	ScTabViewShell* pViewShell = getBestViewShell( xModel );
-	SfxViewFrame* pViewFrame = NULL;
-	if ( pViewShell )
-		pViewFrame = pViewShell->GetViewFrame();
-	if ( pViewFrame )
-	{
-		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
-		if( pDispatcher )
-		{
-			pDispatcher->Execute( nSlot , nCall );
-		}
-	}	
-}
-		
-void
-implnPaste()
-{
-	PasteCellsWarningReseter resetWarningBox;
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();
-	if ( pViewShell )
-	{
-		pViewShell->PasteFromSystem();
-		pViewShell->CellContentChanged();
-	}
-}
-
-
-void
-implnCopy()
-{
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();
-	if ( pViewShell )
-		pViewShell->CopyToClip(NULL,false,false,true);
-}
-
-void 
-implnCut()
-{
-	ScTabViewShell* pViewShell =  getCurrentBestViewShell();
-	if ( pViewShell )
-		pViewShell->CutToClip( NULL, TRUE );
-}
-
-void implnPasteSpecial(USHORT nFlags,USHORT nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose)
-{
-	PasteCellsWarningReseter resetWarningBox;
-	sal_Bool bAsLink(sal_False), bOtherDoc(sal_False);
-	InsCellCmd eMoveMode = INS_NONE;
-
-	ScTabViewShell* pTabViewShell = ScTabViewShell::GetActiveViewShell();
-	if ( !pTabViewShell ) 
-		// none active, try next best
-		pTabViewShell = getCurrentBestViewShell();
-	if ( pTabViewShell )
-	{
-		ScViewData* pView = pTabViewShell->GetViewData();	
-		Window* pWin = ( pView != NULL ) ? pView->GetActiveWin() : NULL;
-		if ( pView && pWin )
-		{
-			if ( bAsLink && bOtherDoc )
-				pTabViewShell->PasteFromSystem(0);//SOT_FORMATSTR_ID_LINK
-			else 
-			{
-				ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( pWin );
-				ScDocument* pDoc = NULL; 
-				if ( pOwnClip )
-					pDoc = pOwnClip->GetDocument();	
-				pTabViewShell->PasteFromClip( nFlags, pDoc,
-					nFunction, bSkipEmpty, bTranspose, bAsLink,
-					eMoveMode, IDF_NONE, TRUE );
-				pTabViewShell->CellContentChanged();
-			}
-		}
-	}
-
-}
-
- uno::Reference< frame::XModel > 
-getCurrentDocument() throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XModel > xModel;
-	SbxObject* pBasic = dynamic_cast< SbxObject* > ( SFX_APP()->GetBasic() );
-	SbxObject* basicChosen =  pBasic ;
-	if ( basicChosen == NULL)
-	{
-		OSL_TRACE("getModelFromBasic() StarBASIC* is NULL" );
-		return xModel;
-	}    
-    SbxObject* p = pBasic;
-    SbxObject* pParent = p->GetParent();
-    SbxObject* pParentParent = pParent ? pParent->GetParent() : NULL;
-
-    if( pParentParent )
-    {
-        basicChosen = pParentParent;
-    }
-    else if( pParent )
-    {
-        basicChosen = pParent;
-    }
-
-
-    uno::Any aModel; 
-    SbxVariable *pCompVar = basicChosen->Find(  UniString(RTL_CONSTASCII_USTRINGPARAM("ThisComponent")), SbxCLASS_OBJECT );
-
-	if ( pCompVar )
-	{
-		aModel = sbxToUnoValue( pCompVar );
-		if ( sal_False == ( aModel >>= xModel ) ||
-			!xModel.is() )
-		{
-			// trying last gasp try the current component
-			uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
-			// test if vba service is present
-			uno::Reference< uno::XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
-			uno::Reference<lang::XMultiComponentFactory > xSMgr( xCtx->getServiceManager(), uno::UNO_QUERY_THROW );
-			uno::Reference< frame::XDesktop > xDesktop (xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), xCtx), uno::UNO_QUERY_THROW );
-			xModel.set( xDesktop->getCurrentComponent(), uno::UNO_QUERY );
-			if ( !xModel.is() )
-			{
-				throw uno::RuntimeException( 
-					rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't extract model from basic ( its obviously not set yet ) therefore don't know the currently selected document") ), uno::Reference< uno::XInterface >() );
-			}
-			return xModel;
-		}
-		else
-		{
-			OSL_TRACE("Have model ThisComponent points to url %s",
-			::rtl::OUStringToOString( xModel->getURL(),
-				RTL_TEXTENCODING_ASCII_US ).pData->buffer );
-		}
-	}
-	else
-	{
-		OSL_TRACE("Failed to get ThisComponent");
-		throw uno::RuntimeException( 
-			rtl::OUString( 
-				RTL_CONSTASCII_USTRINGPARAM(
-					"Can't determine the currently selected document") ),
-			uno::Reference< uno::XInterface >() );
-	}
-	return xModel;
-}
-
-ScDocShell* 
-getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) 
-{
-	uno::Reference< uno::XInterface > xIf( xModel, uno::UNO_QUERY_THROW );
-	ScModelObj* pModel = dynamic_cast< ScModelObj* >( xIf.get() );
-	ScDocShell* pDocShell = NULL;
-	if ( pModel )
-		pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
-	return pDocShell;
-
-}
-
-ScTabViewShell* 
-getBestViewShell(  css::uno::Reference< css::frame::XModel>& xModel )
-{
-	ScDocShell* pDocShell = getDocShell( xModel );
-	if ( pDocShell )
-		return pDocShell->GetBestViewShell();
-	return NULL;
-}
-
-ScTabViewShell* 
-getCurrentBestViewShell()
-{ 
-	uno::Reference< frame::XModel > xModel = getCurrentDocument();
-	return getBestViewShell( xModel );
-}
-
-SfxViewFrame* 
-getCurrentViewFrame()
-{
-	ScTabViewShell* pViewShell = getCurrentBestViewShell();	
-	if ( pViewShell )
-		return pViewShell->GetViewFrame();
-	return NULL;
-}
-
-sal_Int32 
-OORGBToXLRGB( sal_Int32 nCol )
-{
-	sal_Int32 nRed = nCol;
-	nRed &= 0x00FF0000;
-	nRed >>= 16;
-	sal_Int32 nGreen = nCol;
-	nGreen &= 0x0000FF00;
-	nGreen >>= 8;
-	sal_Int32 nBlue = nCol;
-	nBlue &= 0x000000FF;
-	sal_Int32 nRGB =  ( (nBlue << 16) | (nGreen << 8) | nRed );
-	return nRGB;
-}
-sal_Int32 
-XLRGBToOORGB( sal_Int32 nCol )
-{
-	sal_Int32 nBlue = nCol;
-	nBlue &= 0x00FF0000;
-	nBlue >>= 16;
-	sal_Int32 nGreen = nCol;
-	nGreen &= 0x0000FF00;
-	nGreen >>= 8;
-	sal_Int32 nRed = nCol;
-	nRed &= 0x000000FF;
-	sal_Int32 nRGB =  ( (nRed << 16) | (nGreen << 8) | nBlue );
-	return nRGB;
-}
-uno::Any 
-OORGBToXLRGB( const uno::Any& aCol )
-{
-	sal_Int32 nCol=0;
-	aCol >>= nCol;
-	nCol = OORGBToXLRGB( nCol );
-	return uno::makeAny( nCol );
-}
-uno::Any 
-XLRGBToOORGB(  const uno::Any& aCol )
-{
-	sal_Int32 nCol=0;
-	aCol >>= nCol;
-	nCol = XLRGBToOORGB( nCol );
-	return uno::makeAny( nCol );
-}
-
-void PrintOutHelper( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& /*ActivePrinter*/, const uno::Any& /*PrintToFile*/, const uno::Any& Collate, const uno::Any& PrToFileName, css::uno::Reference< frame::XModel >& xModel, sal_Bool bUseSelection  )
-{
-	sal_Int32 nTo = 0;
-	sal_Int32 nFrom = 0;
-	sal_Int16 nCopies = 1;
-	sal_Bool bPreview = sal_False;
-	sal_Bool bCollate = sal_False;
-	sal_Bool bSelection = bUseSelection;
-	From >>= nFrom;
-	To >>= nTo;
-	Copies >>= nCopies;
-	Preview >>= bPreview;
-	if ( nCopies > 1 ) // Collate only useful when more that 1 copy
-		Collate >>= bCollate;
-
-	rtl::OUString sRange(  RTL_CONSTASCII_USTRINGPARAM( "-" ) );
-	rtl::OUString sFileName;
-	
-	if (( nFrom || nTo ) )
-	{
-		if ( nFrom )
-			sRange = ( ::rtl::OUString::valueOf( nFrom ) + sRange );
-		if ( nTo )
-			sRange += ::rtl::OUString::valueOf( nTo );
-	}
-
-	if (  PrToFileName.getValue() )
-	{
-		PrToFileName >>= sFileName;
-	}
-	ScTabViewShell* pViewShell = getBestViewShell( xModel );
-	SfxViewFrame* pViewFrame = NULL;
-	if ( pViewShell )
-		pViewFrame = pViewShell->GetViewFrame();
-	if ( pViewFrame )
-	{
-		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
-				
-		SfxBoolItem sfxCollate( SID_PRINT_COLLATE, bCollate );
-		aArgs.Put( sfxCollate, sfxCollate.Which() );
-		SfxInt16Item sfxCopies( SID_PRINT_COPIES, nCopies );
-		aArgs.Put( sfxCopies, sfxCopies.Which() );
-		if ( sFileName.getLength() )
-		{
-			SfxStringItem sfxFileName( SID_FILE_NAME, sFileName);
-			aArgs.Put( sfxFileName, sfxFileName.Which() );
-		
-		}
-		if (  sRange.getLength() )
-		{
-			SfxStringItem sfxRange( SID_PRINT_PAGES, sRange );
-			aArgs.Put( sfxRange, sfxRange.Which() );
-		}
-		SfxBoolItem sfxSelection( SID_SELECTION, bSelection );
-		aArgs.Put( sfxSelection, sfxSelection.Which() );
-		SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
-		aArgs.Put( sfxAsync, sfxAsync.Which() );
-		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
-
-		if ( pDispatcher )
-		{
-			if ( bPreview )
-			{
-				if ( !pViewFrame->GetFrame()->IsInPlace() ) 	
-				{
-					SC_MOD()->InputEnterHandler();
-					pViewFrame->GetDispatcher()->Execute( SID_VIEWSHELL1, SFX_CALLMODE_SYNCHRON );
-					while ( isInPrintPreview( pViewFrame ) )
-						Application::Yield();
-				}
-			}
-			else
-				pDispatcher->Execute( (USHORT)SID_PRINTDOC, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
-		}
-			
-	}
-	
-	// #FIXME #TODO
-	// 1 ActivePrinter ( how/can we switch a printer via API? )
-	// 2 PrintToFile ( ms behaviour if this option is specified but no 
-	//   filename supplied 'PrToFileName' then the user will be prompted )
-	// 3 Need to check behaviour of Selected sheets with range ( e.g. From & To
-	//    values ) in oOO these options are mutually exclusive
-	// 4 There is a pop up to do with transparent objects in the print source
-	//   should be able to disable that via configuration for the duration
-	//   of this method
-}
-
- void PrintPreviewHelper( const css::uno::Any& /*EnableChanges*/, css::uno::Reference< css::frame::XModel >& xModel )
-{
-	dispatchExecute( xModel, SID_VIEWSHELL1 );
-}
-
-rtl::OUString getAnyAsString( const uno::Any& pvargItem ) throw ( uno::RuntimeException )
-{
-	uno::Type aType = pvargItem.getValueType();
-	uno::TypeClass eTypeClass = aType.getTypeClass();
-	rtl::OUString sString;
-	switch ( eTypeClass )
-	{
-		case uno::TypeClass_BOOLEAN:
-		{
-			sal_Bool bBool = sal_False;
-			pvargItem >>= bBool;
-			sString = rtl::OUString::valueOf( bBool );
-			break;
-		}
-		case uno::TypeClass_STRING:
-			pvargItem >>= sString;
-			break;
-		case uno::TypeClass_FLOAT:
-			{
-				float aFloat = 0;
-				pvargItem >>= aFloat;
-				sString = rtl::OUString::valueOf( aFloat );
-				break;
-			}
-		case uno::TypeClass_DOUBLE:
-			{
-				double aDouble = 0;
-				pvargItem >>= aDouble;
-				sString = rtl::OUString::valueOf( aDouble );
-				break;
-			}
-		case uno::TypeClass_SHORT:
-		case uno::TypeClass_LONG:
-		case uno::TypeClass_BYTE:
-			{
-				sal_Int32 aNum = 0;
-				pvargItem >>= aNum;
-				sString = rtl::OUString::valueOf( aNum );
-				break;
-			}
-
-		case uno::TypeClass_HYPER:
-			{
-				sal_Int64 aHyper = 0;
-				pvargItem >>= aHyper;
-				sString = rtl::OUString::valueOf( aHyper );
-				break;
-			}
-		default:
-       			throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid type, can't convert" ), uno::Reference< uno::XInterface >() );
-	}
-	return sString;
-}
-
-
-rtl::OUString 
-ContainerUtilities::getUniqueName( const uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator)
-{
-	return getUniqueName(_slist, _sElementName, _sSuffixSeparator, sal_Int32(2));
-}
-
-rtl::OUString 
-ContainerUtilities::getUniqueName( const uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix)
-{
-	sal_Int32 a = _nStartSuffix;
-	rtl::OUString scompname = _sElementName;
-	bool bElementexists = true;
-	sal_Int32 nLen = _slist.getLength();
-	if ( nLen == 0 )
-		return _sElementName;
-
-	while (bElementexists == true) 
-	{
-		for (sal_Int32 i = 0; i < nLen; i++)
-		{
-			if (FieldInList(_slist, scompname) == -1)
-			{
-				return scompname;
-			}
-		}
-		scompname = _sElementName + _sSuffixSeparator + rtl::OUString::valueOf( a++ );
-	}
-	return rtl::OUString();
-}
-
-sal_Int32 
-ContainerUtilities::FieldInList( const uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString )
-{
-	sal_Int32 FieldLen = SearchList.getLength();
-	sal_Int32 retvalue = -1;
-	for (sal_Int32 i = 0; i < FieldLen; i++) 
-	{
-		// I wonder why comparing lexicographically is done
-		// when its a match is whats interesting?
-		//if (SearchList[i].compareTo(SearchString) == 0) 
-		if ( SearchList[i].equals( SearchString ) ) 
-		{
-			retvalue = i;
-			break;
-		}
-	}
-	return retvalue;
-
-}
-bool NeedEsc(sal_Unicode cCode)
-{
-	String sEsc(RTL_CONSTASCII_USTRINGPARAM(".^$+\\|{}()"));
-	return (STRING_NOTFOUND != sEsc.Search(cCode));
-}
-
-rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike )
-{
-	rtl::OUStringBuffer sResult;
-	const sal_Unicode *start = rIn.getStr();
-	const sal_Unicode *end = start + rIn.getLength();
-
-	int seenright = 0;
-	if ( bForLike )
-		sResult.append(static_cast<sal_Unicode>('^'));
-
-	while (start < end) 
-	{
-		switch (*start)
-		{
-			case '?':
-				sResult.append(static_cast<sal_Unicode>('.'));
-				start++;
-				break;
-			case '*':
-				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(".*")));
-				start++;
-				break;
-			case '#':
-				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[0-9]")));
-				start++;
-				break;
-			case '~':
-				sResult.append(static_cast<sal_Unicode>('\\'));
-				sResult.append(*(++start));
-				start++;
-				break;
-				// dump the ~ and escape the next characture
-			case ']':
-				sResult.append(static_cast<sal_Unicode>('\\'));
-				sResult.append(*start++);
-				break;
-			case '[':
-				sResult.append(*start++);
-				seenright = 0;
-				while (start < end && !seenright)
-				{
-					switch (*start)
-					{
-						case '[':
-						case '?':
-						case '*':
-						sResult.append(static_cast<sal_Unicode>('\\'));
-						sResult.append(*start);
-							break;
-						case ']':
-						sResult.append(*start);
-							seenright = 1;
-							break;
-						case '!':
-							sResult.append(static_cast<sal_Unicode>('^'));
-							break;
-						default:
-						if (NeedEsc(*start))
-							sResult.append(static_cast<sal_Unicode>('\\'));
-						sResult.append(*start);
-							break;
-					}
-					start++;
-				}
-				break;
-			default:
-				if (NeedEsc(*start))
-					sResult.append(static_cast<sal_Unicode>('\\'));
-				sResult.append(*start++);
-		}
-	}
-
-	if ( bForLike )
-		sResult.append(static_cast<sal_Unicode>('$'));
-
-	return sResult.makeStringAndClear( );
-}
-
-double getPixelTo100thMillimeterConversionFactor( css::uno::Reference< css::awt::XDevice >& xDevice, sal_Bool bVertical)
-{
-	double fConvertFactor = 1.0;
-	if( bVertical )
-	{
-		fConvertFactor = xDevice->getInfo().PixelPerMeterY/100000;
-	}
-	else
-	{
-		fConvertFactor = xDevice->getInfo().PixelPerMeterX/100000;	
-	}
-	return fConvertFactor;
-}
-
-double PointsToPixels( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical)
-{
-	double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
-	return fPoints * POINTTO100THMILLIMETERFACTOR * fConvertFactor;
-}
-double PixelsToPoints( css::uno::Reference< css::awt::XDevice >& xDevice, double fPixels, sal_Bool bVertical)
-{
-	double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
-	return (fPixels/fConvertFactor)/POINTTO100THMILLIMETERFACTOR;
-}
-
-ConcreteXShapeGeometryAttributes::ConcreteXShapeGeometryAttributes( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape )
-{
-	m_xShape = new ScVbaShape( xContext, xShape );
-}
-
-#define VBA_LEFT "PositionX"
-#define VBA_TOP "PositionY"
-UserFormGeometryHelper::UserFormGeometryHelper( const uno::Reference< uno::XComponentContext >& /*xContext*/, const uno::Reference< awt::XControl >& xControl )
-{
-    mxModel.set( xControl->getModel(), uno::UNO_QUERY_THROW );
-}
-    double UserFormGeometryHelper::getLeft()
-    {
-	sal_Int32 nLeft = 0;
-	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ) ) >>= nLeft;	
-	return Millimeter::getInPoints( nLeft );
-    }
-    void UserFormGeometryHelper::setLeft( double nLeft )
-    {
-        mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nLeft ) ) );
-    }
-    double UserFormGeometryHelper::getTop()
-    {
-	sal_Int32 nTop = 0;
-	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	VBA_TOP ) ) ) >>= nTop;	
-	return Millimeter::getInPoints( nTop );
-    }
-    void UserFormGeometryHelper::setTop( double nTop )
-    {
-	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	VBA_TOP ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nTop ) ) );
-    }
-    double UserFormGeometryHelper::getHeight()
-    {
-	sal_Int32 nHeight = 0;
-	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLHGT ) ) ) >>= nHeight;	
-	return Millimeter::getInPoints( nHeight );
-    }
-    void UserFormGeometryHelper::setHeight( double nHeight )
-    {
-	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLHGT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nHeight ) ) );
-    }
-    double UserFormGeometryHelper::getWidth()
-    {
-	sal_Int32 nWidth = 0;
-	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLWID ) ) ) >>= nWidth;	
-	return Millimeter::getInPoints( nWidth );
-    }
-    void UserFormGeometryHelper::setWidth( double nWidth)
-    {
-	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	SC_UNONAME_CELLWID ) ), uno::makeAny(  Millimeter::getInHundredthsOfOneMillimeter( nWidth ) ) );
-    }
-
-SfxItemSet*
-ScVbaCellRangeAccess::GetDataSet( ScCellRangeObj* pRangeObj )
-{
-	SfxItemSet* pDataSet = pRangeObj ? pRangeObj->GetCurrentDataSet( true ) : NULL ;
-	return pDataSet;
-	
-}
-
-} // openoffice
-} //org
Index: sc/source/ui/vba/vbacontrol.cxx
===================================================================
--- sc/source/ui/vba/vbacontrol.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacontrol.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,468 +0,0 @@
-/*************************************************************************
- *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
- *
- * OpenOffice.org - a multi-platform office productivity suite
- *
- * $RCSfile: vbacontrol.cxx,v $
- * $Revision: 1.3 $
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
-#include <com/sun/star/form/FormComponentType.hpp>
-#include <com/sun/star/awt/XControlModel.hpp>
-#include <com/sun/star/awt/XControl.hpp>
-#include <com/sun/star/awt/XWindow2.hpp>
-#include <com/sun/star/lang/XEventListener.hpp>
-#include <com/sun/star/drawing/XShape.hpp>
-#include <com/sun/star/frame/XModel.hpp>
-#include <com/sun/star/view/XControlAccess.hpp>
-#include <com/sun/star/container/XChild.hpp>
-#include <com/sun/star/form/binding/XBindableValue.hpp>
-#include <com/sun/star/form/binding/XListEntrySink.hpp>
-#include <com/sun/star/table/CellAddress.hpp>
-#include <com/sun/star/table/CellRangeAddress.hpp>
-#ifdef VBA_OOBUILD_HACK
-#include <svtools/bindablecontrolhelper.hxx>
-#endif
-#include"vbacontrol.hxx"
-#include"vbacombobox.hxx"
-#include "vbabutton.hxx"
-#include "vbalabel.hxx"
-#include "vbatextbox.hxx"
-#include "vbaradiobutton.hxx"
-#include "vbalistbox.hxx"
-#include "vbatogglebutton.hxx"
-#include "vbacheckbox.hxx"
-#include "vbaframe.hxx"
-#include "vbascrollbar.hxx"
-#include "vbaprogressbar.hxx"
-#include "vbamultipage.hxx"
-#include "vbaspinbutton.hxx"
-#include "vbaimage.hxx"
-
-
-using namespace com::sun::star;
-using namespace ooo::vba;
-
-uno::Reference< css::awt::XWindowPeer > 
-ScVbaControl::getWindowPeer() throw (uno::RuntimeException)
-{
-    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY );
-
-    uno::Reference< awt::XControlModel > xControlModel;
-    uno::Reference< css::awt::XWindowPeer >  xWinPeer;
-    if ( !xControlShape.is() ) 
-    { 
-        // would seem to be a Userform control
-        uno::Reference< awt::XControl > xControl( m_xControl, uno::UNO_QUERY_THROW );
-        xWinPeer =  xControl->getPeer();
-	return xWinPeer;
-    }
-    // form control
-    xControlModel.set( xControlShape->getControl(), uno::UNO_QUERY_THROW );
-
-    uno::Reference< view::XControlAccess > xControlAccess( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
-    try
-    {
-        uno::Reference< awt::XControl > xControl( xControlAccess->getControl( xControlModel ), uno::UNO_QUERY );
-        xWinPeer =  xControl->getPeer();
-    }
-    catch( uno::Exception )
-    {
-        throw uno::RuntimeException( rtl::OUString::createFromAscii( "The Control does not exsit" ),
-                uno::Reference< uno::XInterface >() );
-    }
-    return xWinPeer;
-}
-
-//ScVbaControlListener
-class ScVbaControlListener: public cppu::WeakImplHelper1< lang::XEventListener >
-{
-private:
-    ScVbaControl *pControl;
-public:
-    ScVbaControlListener( ScVbaControl *pTmpControl );
-    virtual ~ScVbaControlListener();
-    virtual void SAL_CALL disposing( const lang::EventObject& rEventObject ) throw( uno::RuntimeException );
-};
-
-ScVbaControlListener::ScVbaControlListener( ScVbaControl *pTmpControl ): pControl( pTmpControl )
-{
-}
-
-ScVbaControlListener::~ScVbaControlListener()
-{
-}
-
-void SAL_CALL
-ScVbaControlListener::disposing( const lang::EventObject& ) throw( uno::RuntimeException )
-{
-    if( pControl )
-    {
-        pControl->removeResouce();
-        pControl = NULL;
-    }
-}
-
-//ScVbaControl
-
-ScVbaControl::ScVbaControl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< ::uno::XInterface >& xControl,  const css::uno::Reference< css::frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ControlImpl_BASE( xParent, xContext ),  m_xControl( xControl ), m_xModel( xModel )
-{
-    //add listener
-    m_xEventListener.set( new ScVbaControlListener( this ) );
-    setGeometryHelper( pGeomHelper );
-    uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
-    xComponent->addEventListener( m_xEventListener );
-   
-    //init m_xProps
-    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY ) ;
-    uno::Reference< awt::XControl> xUserFormControl( m_xControl, uno::UNO_QUERY ) ;
-    if ( xControlShape.is() ) // form control
-        m_xProps.set( xControlShape->getControl(), uno::UNO_QUERY_THROW );
-    else if ( xUserFormControl.is() ) // userform control
-        m_xProps.set( xUserFormControl->getModel(), uno::UNO_QUERY_THROW );
-}
-
-ScVbaControl::~ScVbaControl()
-{
-    if( m_xControl.is() )
-{
-        uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
-    xComponent->removeEventListener( m_xEventListener );
-}
-}
-
-void 
-ScVbaControl::setGeometryHelper( AbstractGeometryAttributes* pHelper )
-{
-    mpGeometryHelper.reset( pHelper );
-}
-
-void ScVbaControl::removeResouce() throw( uno::RuntimeException )
-{
-    uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
-    xComponent->removeEventListener( m_xEventListener );
-    m_xControl= NULL;
-    m_xProps = NULL;
-}
-
-//In design model has different behavior
-sal_Bool SAL_CALL ScVbaControl::getEnabled() throw (uno::RuntimeException)
-{
-    uno::Any aValue = m_xProps->getPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Enabled" ) ) );
-    sal_Bool bRet = false;
-    aValue >>= bRet;
-    return bRet;
-}
-
-void SAL_CALL ScVbaControl::setEnabled( sal_Bool bVisible ) throw (uno::RuntimeException)
-{
-    uno::Any aValue( bVisible );
-    m_xProps->setPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Enabled" ) ), aValue);
-
-}
-
-sal_Bool SAL_CALL ScVbaControl::getVisible() throw (uno::RuntimeException)
-{
-    sal_Bool bVisible = sal_False;
-    m_xProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) ) ) >>= bVisible;
-    return bVisible;
-}
-
-void SAL_CALL ScVbaControl::setVisible( sal_Bool bVisible ) throw (uno::RuntimeException)
-{
-    m_xProps->setPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) ), uno::makeAny( bVisible ) );
-}
-double SAL_CALL ScVbaControl::getHeight() throw (uno::RuntimeException)
-{
-    return mpGeometryHelper->getHeight();
-}
-void SAL_CALL ScVbaControl::setHeight( double _height ) throw (uno::RuntimeException)
-{
-    mpGeometryHelper->setHeight( _height );
-}
-
-double SAL_CALL ScVbaControl::getWidth() throw (uno::RuntimeException)
-{
-    return mpGeometryHelper->getWidth();
-}
-void SAL_CALL ScVbaControl::setWidth( double _width ) throw (uno::RuntimeException)
-{
-    mpGeometryHelper->setWidth( _width );
-}
-
-double SAL_CALL
-ScVbaControl::getLeft() throw (uno::RuntimeException)
-{
-    return mpGeometryHelper->getLeft();
-}
-
-void SAL_CALL
-ScVbaControl::setLeft( double _left ) throw (uno::RuntimeException)
-{
-    mpGeometryHelper->setLeft( _left );
-
-}
-
-double SAL_CALL
-ScVbaControl::getTop() throw (uno::RuntimeException)
-{
-    return mpGeometryHelper->getTop();
-}
-
-void SAL_CALL
-ScVbaControl::setTop( double _top ) throw (uno::RuntimeException)
-{
-    mpGeometryHelper->setTop( _top );
-}
-
-uno::Reference< uno::XInterface > SAL_CALL
-ScVbaControl::getObject() throw (uno::RuntimeException)
-{
-	uno::Reference< msforms::XControl > xRet( this );
-	return xRet;
-}
-
-void SAL_CALL ScVbaControl::SetFocus() throw (uno::RuntimeException) 
-{
-    uno::Reference< awt::XWindow > xWin( m_xControl, uno::UNO_QUERY_THROW );
-    xWin->setFocus();
-}
-
-rtl::OUString SAL_CALL 
-ScVbaControl::getControlSource() throw (uno::RuntimeException)
-{
-// #FIXME I *hate* having these upstream differences
-// but this is necessary until I manage to upstream other
-// dependant parts
-#ifdef VBA_OOBUILD_HACK
-	rtl::OUString sControlSource;
-	uno::Reference< form::binding::XBindableValue > xBindable( m_xProps, uno::UNO_QUERY );
-	if ( xBindable.is() )
-	{
-		try
-		{
-			uno::Reference< lang::XMultiServiceFactory > xFac( m_xModel, uno::UNO_QUERY_THROW );
-			uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.table.CellAddressConversion" ))), uno::UNO_QUERY );
-			uno::Reference< beans::XPropertySet > xProps( xBindable->getValueBinding(), uno::UNO_QUERY_THROW );
-			table::CellAddress aAddress;
-			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BoundCell") ) ) >>= aAddress;
-			xConvertor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Address") ), uno::makeAny( aAddress ) );
-                	xConvertor->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("XL_A1_Representation") ) ) >>= sControlSource;
-		}
-		catch( uno::Exception& )
-		{
-		}	
-	}
-	return sControlSource;
-#else
-	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getControlSource not supported") ), uno::Reference< uno::XInterface >()); // not supported
-#endif
-}
-
-void SAL_CALL 
-ScVbaControl::setControlSource( const rtl::OUString& _controlsource ) throw (uno::RuntimeException)
-{
-#ifdef VBA_OOBUILD_HACK
-    rtl::OUString sEmpty;
-    svt::BindableControlHelper::ApplyListSourceAndBindableData( m_xModel, m_xProps, _controlsource, sEmpty );
-#else
-	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setControlSource not supported ") ).concat( _controlsource ), uno::Reference< uno::XInterface >()); // not supported
-#endif
-}
-
-rtl::OUString SAL_CALL 
-ScVbaControl::getRowSource() throw (uno::RuntimeException)
-{
-#ifdef VBA_OOBUILD_HACK
-	rtl::OUString sRowSource;
-	uno::Reference< form::binding::XListEntrySink > xListSink( m_xProps, uno::UNO_QUERY );
-	if ( xListSink.is() )
-    {
-		try
-		{
-			uno::Reference< lang::XMultiServiceFactory > xFac( m_xModel, uno::UNO_QUERY_THROW );
-			uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.table.CellRangeAddressConversion" ))), uno::UNO_QUERY );
-
-			uno::Reference< beans::XPropertySet > xProps( xListSink->getListEntrySource(), uno::UNO_QUERY_THROW );
-			table::CellRangeAddress aAddress;
-			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CellRange") ) ) >>= aAddress;
-			xConvertor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Address")), uno::makeAny( aAddress ) );
-			xConvertor->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("XL_A1_Representation") ) ) >>= sRowSource;
-		}
-		catch( uno::Exception& )
-		{
-		}	
-	}
-	return sRowSource;
-#else
-	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getRowSource not supported") ), uno::Reference< uno::XInterface >()); // not supported
-#endif
-}
-
-void SAL_CALL 
-ScVbaControl::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
-{
-#ifdef VBA_OOBUILD_HACK
-    rtl::OUString sEmpty;
-    svt::BindableControlHelper::ApplyListSourceAndBindableData( m_xModel, m_xProps, sEmpty, _rowsource );
-#else
-	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setRowSource not supported ") ).concat( _rowsource ), uno::Reference< uno::XInterface >()); // not supported
-#endif
-}
-
-rtl::OUString SAL_CALL 
-ScVbaControl::getName() throw (uno::RuntimeException)
-{
-	rtl::OUString sName;
-	m_xProps->getPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ) ) >>= sName;
-	return sName;
-
-}
-
-void SAL_CALL
-ScVbaControl::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
-{
-	m_xProps->setPropertyValue
-            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ), uno::makeAny( _name ) );
-    }
-//ScVbaControlFactory
-
-ScVbaControlFactory::ScVbaControlFactory( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel ): m_xContext( xContext ), m_xControl( xControl ), m_xModel( xModel )
-{
-}
-
-ScVbaControl* ScVbaControlFactory::createControl()  throw (uno::RuntimeException)
-{
-    return createControl( m_xModel );
-}
-ScVbaControl* ScVbaControlFactory::createControl( const uno::Reference< uno::XInterface >& xParent )  throw (uno::RuntimeException)
-{
-    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY );
-    if ( xControlShape.is() ) // form controls
-        return createControl( xControlShape, xParent );
-    uno::Reference< awt::XControl > xControl( m_xControl, uno::UNO_QUERY );
-    if ( !xControl.is() )
-        throw uno::RuntimeException(); // really we should be more informative
-    return createControl( xControl, xParent );
-    
-}
-
-ScVbaControl* ScVbaControlFactory::createControl(const uno::Reference< drawing::XControlShape >& xControlShape,  const uno::Reference< uno::XInterface >& /*xParent*/ )  throw (uno::RuntimeException)
-{
-    uno::Reference< beans::XPropertySet > xProps( xControlShape->getControl(), uno::UNO_QUERY_THROW );
-    sal_Int32 nClassId = -1;
-    const static rtl::OUString sClassId( RTL_CONSTASCII_USTRINGPARAM("ClassId") );
-    xProps->getPropertyValue( sClassId ) >>= nClassId;
-    uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
-    switch( nClassId )
-    {
-        case form::FormComponentType::COMBOBOX:
-            return new ScVbaComboBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::COMMANDBUTTON:
-            return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::FIXEDTEXT:
-            return new ScVbaLabel( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::TEXTFIELD:
-            return new ScVbaTextBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::RADIOBUTTON:
-            return new ScVbaRadioButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::LISTBOX:
-            return new ScVbaListBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::SPINBUTTON:
-            return new ScVbaSpinButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        case form::FormComponentType::IMAGECONTROL:
-            return new ScVbaImage( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
-        default:
-            throw uno::RuntimeException( rtl::OUString::createFromAscii(
-                    "Donot support this Control Type." ), uno::Reference< uno::XInterface >() );
-    }
-}
-
-ScVbaControl* ScVbaControlFactory::createControl( const uno::Reference< awt::XControl >& xControl,  const uno::Reference< uno::XInterface >& xParent  )  throw (uno::RuntimeException)
-{
-    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
-    uno::Reference< lang::XServiceInfo > xServiceInfo( xProps, uno::UNO_QUERY_THROW );
-    ScVbaControl* pControl = NULL;
-    uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
-    if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlCheckBoxModel") ) ) )
-	pControl = new ScVbaCheckbox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );	
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) ) )
-	pControl = new ScVbaRadioButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );	
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlEditModel") ) ) )
-        pControl = new ScVbaTextBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), true );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlButtonModel") ) ) )
-    {
-        sal_Bool bToggle = sal_False;
-        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toggle") ) ) >>= bToggle;
-        if ( bToggle )
-            pControl = new ScVbaToggleButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-        else
-            pControl = new ScVbaButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    }
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlComboBoxModel") ) ) )
-        pControl = new ScVbaComboBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), true );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) ) )
-	pControl = new ScVbaListBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFixedTextModel") ) ) )
-	pControl = new ScVbaLabel( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlImageControlModel") ) ) )
-	pControl = new ScVbaImage( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlProgressBarModel") ) ) )
-	pControl = new ScVbaProgressBar( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) ) )
-	pControl = new ScVbaFrame( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlScrollBarModel") ) ) )
-	pControl = new ScVbaScrollBar( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) ) )
-	pControl = new ScVbaMultiPage( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), xParent );
-    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlSpinButtonModel") ) ) )
-	pControl = new ScVbaSpinButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
-    else
-        throw uno::RuntimeException( rtl::OUString::createFromAscii("Unsupported control " ), uno::Reference< uno::XInterface >() );
-    return pControl;
-}
-
-rtl::OUString& 
-ScVbaControl::getServiceImplName()
-{
-	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaControl") );
-	return sImplName;
-}
-
-uno::Sequence< rtl::OUString > 
-ScVbaControl::getServiceNames()
-{
-	static uno::Sequence< rtl::OUString > aServiceNames;
-	if ( aServiceNames.getLength() == 0 )
-	{
-		aServiceNames.realloc( 1 );
-		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Control" ) );
-    }
-	return aServiceNames;
-}
-
-
Index: sc/source/ui/vba/vbatextboxshape.hxx
===================================================================
--- sc/source/ui/vba/vbatextboxshape.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatextboxshape.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -37,8 +37,8 @@
 #include <cppuhelper/implbase1.hxx>
 #include <com/sun/star/text/XTextRange.hpp>
 #include <ooo/vba/msforms/XTextBoxShape.hpp>
-#include "vbashape.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbashape.hxx>
+#include "excelvbahelper.hxx"
 #include "vbacharacters.hxx"
 
 typedef cppu::ImplInheritanceHelper1< ScVbaShape, ov::msforms::XTextBoxShape > TextBoxShapeImpl_BASE;
Index: sc/source/ui/vba/vbatitle.hxx
===================================================================
--- sc/source/ui/vba/vbatitle.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbatitle.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -30,14 +30,15 @@
 #ifndef SC_VBA_TITLE_HXX
 #define SC_VBA_TITLE_HXX
 
-#include "vbahelperinterface.hxx"
-#include "vbahelper.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
+#include "excelvbahelper.hxx"
 #include "vbainterior.hxx"
 #include "vbafont.hxx"
 #include "vbapalette.hxx"
 #include <com/sun/star/drawing/XShape.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <ooo/vba/excel/XTitle.hpp>
+#include <ooo/vba/excel/XCharacters.hpp>
 #include <basic/sberrors.hxx>
 #include <memory>
 
Index: sc/source/ui/vba/vbacondition.hxx
===================================================================
--- sc/source/ui/vba/vbacondition.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacondition.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,7 +31,7 @@
 #define SC_VBA_CONDITION_HXX
 #include <com/sun/star/sheet/XSheetCondition.hpp> 
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp> 
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 #include <com/sun/star/sheet/ConditionOperator.hpp>
 
 template< typename Ifc1 >
Index: sc/source/ui/vba/vbarange.cxx
===================================================================
--- sc/source/ui/vba/vbarange.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbarange.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,7 +27,7 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 
 #include <comphelper/unwrapargs.hxx>
 #include <comphelper/processfactory.hxx>
@@ -94,6 +94,8 @@
 #include <com/sun/star/sheet/XSubTotalDescriptor.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hdl>
 
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XSheetAnnotations.hpp>
 #include <ooo/vba/excel/XlPasteSpecialOperation.hpp>
 #include <ooo/vba/excel/XlPasteType.hpp>
 #include <ooo/vba/excel/Constants.hpp>
@@ -149,7 +151,6 @@
 #include "rangelst.hxx"
 #include "convuno.hxx"
 #include "compiler.hxx"
-#include "formula/grammar.hxx"
 #include "attrib.hxx"
 #include "undodat.hxx"
 #include "dbdocfun.hxx"
@@ -162,7 +163,7 @@
 #include "vbaglobals.hxx"
 #include "vbastyle.hxx"
 #include <vector>
-#include <vbacollectionimpl.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
 // begin test includes
 #include <com/sun/star/sheet/FunctionArgument.hpp>
 // end test includes
@@ -256,7 +257,7 @@
 SfxItemSet*  ScVbaRange::getCurrentDataSet( ) throw ( uno::RuntimeException )
 {
 	ScCellRangeObj* pUnoCellRange = getCellRangeObj();
-	SfxItemSet* pDataSet = ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
+	SfxItemSet* pDataSet = excel::ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
 	if ( !pDataSet )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't access Itemset for range" ) ), uno::Reference< uno::XInterface >() );
 	return pDataSet;	
@@ -473,7 +474,7 @@
 		if ( pUnoCellRange )
 		{
 			
-			SfxItemSet* pDataSet = 	ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
+			SfxItemSet* pDataSet = 	excel::ScVbaCellRangeAccess::GetDataSet( pUnoCellRange );
 			SfxItemState eState = pDataSet->GetItemState( ATTR_VALUE_FORMAT, TRUE, NULL);
 			// one of the cells in the range is not like the other ;-)
 			// so return a zero length format to indicate that
@@ -795,9 +796,10 @@
 		double aDblValue = 0.0;
 		if ( aValue >>= sFormula )
 		{
-            // convert to CONV_OOO style formula string because XCell::setFormula
-            // always compile it in CONV_OOO style.  Perhaps css.sheet.FormulaParser
-            // should be used in future to directly pass formula tokens.
+            // convert to GRAM_PODF_A1 style grammar because XCell::setFormula
+            // always compile it in that grammar. Perhaps
+            // css.sheet.FormulaParser should be used in future to directly
+            // pass formula tokens when that API stabilizes.
             if ( m_eGrammar != formula::FormulaGrammar::GRAM_PODF_A1 && ( sFormula.trim().indexOf('=') == 0 ) )	
 			{
 				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
@@ -1740,7 +1742,16 @@
 	uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
 	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
 	uno::Any aMatrix;
-	aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+
+	//VBA, minz@cn.ibm.com
+	uno::Sequence< uno::Sequence<rtl::OUString> > aFmArray = xCellRangeFormula->getFormulaArray();
+	if( aFmArray.getLength() )
+	{
+		if( aFmArray.getLength() == 1 && aFmArray[0].getLength() == 1 )
+			aMatrix <<= aFmArray[0][0];
+		else	
+			aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+	}	
 	return aMatrix;
 }
 
@@ -1979,7 +1990,7 @@
 		// ThisComponent.CurrentController.Frame.getContainerWindow.SetFocus
 		try
 		{
-			uno::Reference< frame::XController > xController( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY_THROW );
+			uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
 			uno::Reference< frame::XFrame > xFrame( xController->getFrame(), uno::UNO_QUERY_THROW );
 			uno::Reference< awt::XWindow > xWin( xFrame->getContainerWindow(), uno::UNO_QUERY_THROW );
 			xWin->setFocus();
@@ -1999,9 +2010,9 @@
 	return false;
 }
 
-void setCursor(  const SCCOL& nCol, const SCROW& nRow, bool bInSel = true )
+void setCursor(  const SCCOL& nCol, const SCROW& nRow, const uno::Reference< frame::XModel >& xModel,  bool bInSel = true )
 {
-	ScTabViewShell* pShell = getCurrentBestViewShell();
+	ScTabViewShell* pShell = excel::getBestViewShell( xModel );
 	if ( pShell )
 	{
 		if ( bInSel )
@@ -2027,11 +2038,19 @@
 	RangeHelper thisRange( xCellRange );
 	uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
 	table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
-	
+        uno::Reference< frame::XModel > xModel;	
+        ScDocShell* pShell = getScDocShell();
+
+        if ( pShell )
+            xModel = pShell->GetModel();
+
+        if ( !xModel.is() )
+            throw uno::RuntimeException(); 
+
 	// get current selection
-	uno::Reference< sheet::XCellRangeAddressable > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	uno::Reference< sheet::XCellRangeAddressable > xRange( xModel->getCurrentSelection(), ::uno::UNO_QUERY);
 
-	uno::Reference< sheet::XSheetCellRanges > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	uno::Reference< sheet::XSheetCellRanges > xRanges( xModel->getCurrentSelection(), ::uno::UNO_QUERY);
 
 	if ( xRanges.is() )
 	{
@@ -2040,7 +2059,7 @@
 		{
 			if ( cellInRange( nAddrs[index], thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
 			{
-				setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ) );
+				setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel );
 				return;
 			}
 			
@@ -2048,7 +2067,7 @@
 	}	
 
 	if ( xRange.is() && cellInRange( xRange->getRangeAddress(), thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
-		setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ) );
+		setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel );
 	else
 	{
 		// if this range is multi cell select the range other
@@ -2056,7 +2075,7 @@
 		if ( isSingleCellRange() ) 
 			// This top-leftmost cell of this Range is not in the current
 			// selection so just select this range
-			setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), false  );
+			setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), xModel, false  );
 		else
 			Select();
 	}
@@ -2211,8 +2230,9 @@
 	}
 	else
 	{
+		uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
 		Select();
-		implnCopy();
+		excel::implnCopy( xModel );
 	}
 }
 
@@ -2234,9 +2254,11 @@
 		uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
 		xMover->moveRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
 	}
-	{
+	//VBA, minz@cn.ibm.com.
+	else {
+		uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
 		Select();
-		implnCut();
+		excel::implnCut( xModel );
 	}
 }
                                                                                                                              
@@ -2544,9 +2566,12 @@
 {
 	if ( m_Areas->getCount() > 1 )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
-	uno::Reference< view::XSelectionSupplier > xSelection( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY_THROW );
+        ScDocShell* pShell = getScDocShell(); 
+  
+        uno::Reference< frame::XModel > xModel( ( pShell ? pShell->GetModel() : NULL ), uno::UNO_QUERY_THROW );
+	uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
 	// save old selection
-	uno::Reference< uno::XInterface > xSel(  getCurrentDocument()->getCurrentSelection() );
+	uno::Reference< uno::XInterface > xSel( xModel->getCurrentSelection() );
 	// select this range
 	xSelection->select( uno::makeAny( mxRange ) );
 	// set up defaults	
@@ -2566,7 +2591,7 @@
 
 	USHORT nFlags = getPasteFlags(nPaste);
 	USHORT nFormulaBits = getPasteFormulaBits(nOperation);
-	implnPasteSpecial(nFlags,nFormulaBits,bSkipBlanks,bTranspose);
+	excel::implnPasteSpecial(pShell->GetModel(), nFlags,nFormulaBits,bSkipBlanks,bTranspose);
 	// restore selection
 	xSelection->select( uno::makeAny( xSel ) );
 }
@@ -2618,11 +2643,12 @@
 {
 
 	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
-	// if you don't pass a valid text or if there is already a comment
-	// associated with the range then return NULL
-	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength() 
-	||   xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
-		return NULL;
+        // if there is existing text then error
+	if ( Text.hasValue() && xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+            throw uno::RuntimeException(); 
+        // failed to write text? ( can this happen ?? )
+	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength()  )
+		return NULL;	
 	return xComment;
 }
 
@@ -3235,13 +3261,15 @@
 	
 	// Save ActiveCell pos ( to restore later )
 	uno::Any aDft;
-	rtl::OUString sActiveCell =	ScVbaGlobals::getGlobalsImpl(
-                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+	uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+	rtl::OUString sActiveCell = xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// position current cell upper left of this range
 	Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
 
-	SfxViewFrame* pViewFrame = getCurrentViewFrame();
+        uno::Reference< frame::XModel > xModel = getModelFromRange( mxRange );
+
+	SfxViewFrame* pViewFrame = excel::getViewFrame( xModel );
 	if ( pViewFrame )
 	{
 		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
@@ -3277,18 +3305,17 @@
 	}
 
 	// result is the ActiveCell		
-	rtl::OUString sMoved =	ScVbaGlobals::getGlobalsImpl(
-                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+	rtl::OUString sMoved =	xApplication->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// restore old ActiveCell		
 	uno::Any aVoid;
-	uno::Reference< excel::XRange > xOldActiveCell( ScVbaGlobals::getGlobalsImpl(
-		mxContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
+
+	uno::Reference< excel::XRange > xOldActiveCell( xApplication->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
 	xOldActiveCell->Select();
 
 	uno::Reference< excel::XRange > resultCell;
-	resultCell.set( ScVbaGlobals::getGlobalsImpl(
-		mxContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
+	
+	resultCell.set( xApplication->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
 
 	// return result
 	
@@ -3321,7 +3348,6 @@
  void SAL_CALL 
 ScVbaRange::Delete( const uno::Any& Shift ) throw (uno::RuntimeException)
 {
-	
 	if ( m_Areas->getCount() > 1 )
 	{
 		sal_Int32 nItems = m_Areas->getCount();
@@ -3333,6 +3359,8 @@
 		return;
 	}
 	sheet::CellDeleteMode mode = sheet::CellDeleteMode_NONE ; 
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
 	if ( Shift.hasValue() )		
 	{
 		sal_Int32 nShift = 0;
@@ -3350,13 +3378,17 @@
 		}
 	}
 	else
-		if ( getRow() >  getColumn() )
+        {
+		bool bFullRow = ( thisAddress.StartColumn == 0 && thisAddress.EndColumn == MAXCOL );
+	        sal_Int32 nCols = thisAddress.EndColumn - thisAddress.StartColumn;
+	        sal_Int32 nRows = thisAddress.EndRow - thisAddress.StartRow;
+		if ( mbIsRows || bFullRow || ( nCols >=  nRows ) )
 			mode = sheet::CellDeleteMode_UP;
 		else
 			mode = sheet::CellDeleteMode_LEFT;
-	RangeHelper thisRange( mxRange );
+	}
 	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
-	xCellRangeMove->removeRange( thisRange.getCellRangeAddressable()->getRangeAddress(), mode ); 
+	xCellRangeMove->removeRange( thisAddress, mode ); 
 	
 }
 
@@ -3394,7 +3426,7 @@
 ::rtl::OUString SAL_CALL 
 ScVbaRange::getDefaultMethodName(  ) throw (uno::RuntimeException)
 {
-	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Cells") );
+	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
 	return sName;
 }
 
@@ -3751,7 +3783,7 @@
 		uno::Reference< frame::XModel > xModel = pShell->GetModel();
 		if ( xModel.is() )
 		{
-			ScTabViewShell* pViewShell = getBestViewShell( xModel );
+			ScTabViewShell* pViewShell = excel::getBestViewShell( xModel );
 			if ( nPageBreak == excel::XlPageBreak::xlPageBreakManual )
 			    pViewShell->InsertPageBreak( bColumn, TRUE, &aAddr);
 			else if ( nPageBreak == excel::XlPageBreak::xlPageBreakNone )
@@ -3881,7 +3913,7 @@
 	if ( Cell1.hasValue() && !Cell2.hasValue() && sRangeName.getLength() )
 	{
 		const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
-		uno::Reference< beans::XPropertySet > xPropSet( getCurrentDocument(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xPropSet( getCurrentExcelDoc(xContext), uno::UNO_QUERY_THROW );
 		
 		uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
 		uno::Reference< sheet::XCellRangeReferrer > xReferrer;
@@ -3904,7 +3936,7 @@
 			}
 		}
 	}
-	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY );
+	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentExcelDoc(xContext)->getCurrentController(), uno::UNO_QUERY );
 	uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
 	ScVbaRange* pRange = new ScVbaRange( uno::Reference< XHelperInterface >(), xContext, xSheetRange );
 	uno::Reference< excel::XRange > xVbSheetRange( pRange );
@@ -4351,8 +4383,10 @@
 }
 
 void SAL_CALL 
-ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& /*CopyOrigin*/ ) throw (uno::RuntimeException)
+ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& CopyOrigin ) throw (uno::RuntimeException)
 {
+	sal_Bool bCopyOrigin = sal_True;
+	CopyOrigin >>= bCopyOrigin;
 	// It appears ( from the web ) that the undocumented CopyOrigin
 	// param should contain member of enum XlInsertFormatOrigin
 	// which can have values xlFormatFromLeftOrAbove or xlFormatFromRightOrBelow
@@ -4384,8 +4418,17 @@
 			mode = sheet::CellInsertMode_RIGHT;
 	}
 	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
 	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );	
-	xCellRangeMove->insertCells( thisRange.getCellRangeAddressable()->getRangeAddress(), mode );
+	xCellRangeMove->insertCells( thisAddress, mode );
+	if ( bCopyOrigin )
+	{
+		// After the insert ( this range ) actually has moved
+		ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
+	 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( getDocShellFromRange( mxRange ) , aRange ) );
+		uno::Reference< excel::XRange > xVbaRange( new ScVbaRange( getParent(), mxContext, xRange, mbIsRows, mbIsColumns ) );	
+		xVbaRange->PasteSpecial( uno::Any(), uno::Any(), uno::Any(), uno::Any() );
+	}
 }
 
 void SAL_CALL
@@ -4720,7 +4763,7 @@
 		{
 			xPrintAreas->setPrintAreas( printAreas );
 			uno::Reference< frame::XModel > xModel = pShell->GetModel();
-			PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, xModel, sal_True );
+			PrintOutHelper( excel::getBestViewShell( xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, sal_True );
 		}
 	}
 }
@@ -5034,6 +5077,7 @@
 	}
 	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
 	rtl::OUString sStyleName;
+    xProps->getPropertyValue(CELLSTYLE) >>= sStyleName;
 	ScDocShell* pShell = getScDocShell();
 	uno::Reference< frame::XModel > xModel( pShell->GetModel() ); 
 	uno::Reference< excel::XStyle > xStyle = new ScVbaStyle( this, mxContext,  sStyleName, xModel );
@@ -5367,6 +5411,25 @@
 	return aServiceNames;
 }
 
+sal_Bool SAL_CALL
+ScVbaRange::hasError() throw (uno::RuntimeException)
+{
+    double dResult = sal_False;
+    uno::Reference< excel::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+    uno::Reference< script::XInvocation > xInvoc( xApplication->WorksheetFunction(), uno::UNO_QUERY_THROW );
+
+    static rtl::OUString FunctionName( RTL_CONSTASCII_USTRINGPARAM("IsError" ) );
+    uno::Sequence< uno::Any > Params(1);
+    uno::Reference< excel::XRange > aRange( this );
+    Params[0] = uno::makeAny( aRange );
+    uno::Sequence< sal_Int16 > OutParamIndex;
+    uno::Sequence< uno::Any > OutParam;
+    xInvoc->invoke( FunctionName, Params, OutParamIndex, OutParam ) >>= dResult;
+    if ( dResult > 0.0 )
+         return sal_True;
+    return sal_False;
+}
+
 namespace range
 {
 namespace sdecl = comphelper::service_decl;
Index: sc/source/ui/vba/vbachartobject.hxx
===================================================================
--- sc/source/ui/vba/vbachartobject.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbachartobject.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,7 +36,7 @@
 #include <com/sun/star/container/XNamed.hpp>
 #include <com/sun/star/document/XEmbeddedObjectSupplier.hpp>
 #include <ooo/vba/excel/XChartObject.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 #include <memory>
 
 typedef InheritedHelperInterfaceImpl1<ov::excel::XChartObject > ChartObjectImpl_BASE;
Index: sc/source/ui/vba/vbaworkbook.cxx
===================================================================
--- sc/source/ui/vba/vbaworkbook.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaworkbook.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,7 +27,7 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 #include <tools/urlobj.hxx>
 #include <comphelper/unwrapargs.hxx>
 
@@ -46,12 +46,13 @@
 #include "vbaworkbook.hxx"
 #include "vbawindows.hxx"
 #include "vbastyles.hxx"
-#include "vbahelper.hxx"
+#include "excelvbahelper.hxx"
 #include "vbapalette.hxx"
 #include <osl/file.hxx>
 #include <stdio.h>
 #include "vbanames.hxx"  // Amelia Wang
 #include "nameuno.hxx"
+#include "docoptio.hxx"
 
 // Much of the impl. for the equivalend UNO module is
 // sc/source/ui/unoobj/docuno.cxx, viewuno.cxx
@@ -64,7 +65,7 @@
 protected:
 	virtual uno::Reference< frame::XModel > getModel()
 	{ 	
-		return getCurrentDocument(); 
+		return getCurrentExcelDoc( mxContext ); 
 	}
 	virtual uno::Reference< sheet::XSpreadsheet > getSheet()
 	{ 
@@ -192,7 +193,7 @@
 	if ( !ColorData.getLength() )
 		ResetColors();
 }
-ScVbaWorkbook::ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext) :ScVbaWorkbook_BASE( xParent, xContext ), mxModel(NULL)
+ScVbaWorkbook::ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext) :ScVbaWorkbook_BASE( xParent, xContext )
 {
 	//#FIXME this persists the color data per office instance and
 	// not per workbook instance, need to hook the data into XModel
@@ -203,58 +204,27 @@
 	init();
 }
 
-ScVbaWorkbook::ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, css::uno::Reference< css::frame::XModel > xModel ) : ScVbaWorkbook_BASE( xParent, xContext ),  mxModel( xModel ) 
+ScVbaWorkbook::ScVbaWorkbook( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, css::uno::Reference< css::frame::XModel > xModel ) : ScVbaWorkbook_BASE( xParent, xContext, xModel )
 { 
 	init();
 }
 
 ScVbaWorkbook::ScVbaWorkbook( uno::Sequence< uno::Any> const & args,
-    uno::Reference< uno::XComponentContext> const & xContext ) : ScVbaWorkbook_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext ),  mxModel( getXSomethingFromArgs< frame::XModel >( args, 1 ) ) 
+    uno::Reference< uno::XComponentContext> const & xContext ) : ScVbaWorkbook_BASE( args, xContext )
 
 {
 	init();
 }
 
-::rtl::OUString
-ScVbaWorkbook::getName() throw (uno::RuntimeException)
-{
-	rtl::OUString sName = getModel()->getURL();
-	if ( sName.getLength() )
-	{
-
-		INetURLObject aURL( getModel()->getURL() );
-		::osl::File::getSystemPathFromFileURL( aURL.GetLastName(), sName );
-	}
-	else
-	{
-		const static rtl::OUString sTitle( RTL_CONSTASCII_USTRINGPARAM("Title" ) );
-		// process "UntitledX - $(PRODUCTNAME)"
-		uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-		uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
-		xProps->getPropertyValue(sTitle ) >>= sName;
-		sal_Int32 pos = 0;
-		sName = sName.getToken(0,' ',pos);	
-	}
-	return sName;
-}
-::rtl::OUString
-ScVbaWorkbook::getPath() throw (uno::RuntimeException)
-{
-	INetURLObject aURL( getModel()->getURL() );
-	aURL.CutLastName();
-	return aURL.GetURLPath();
-}
-
-::rtl::OUString
-ScVbaWorkbook::getFullName() throw (uno::RuntimeException)
-{
-	INetURLObject aURL( getModel()->getURL() );
-	return aURL.GetURLPath();
-}
 uno::Reference< excel::XWorksheet >
 ScVbaWorkbook::getActiveSheet() throw (uno::RuntimeException)
 {
-	return new ActiveSheet( this, mxContext );
+	uno::Reference< frame::XModel > xModel( getCurrentExcelDoc( mxContext ) );	
+	uno::Reference< sheet::XSpreadsheet > xSheet;
+	uno::Reference< sheet::XSpreadsheetView > xView( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	if ( xView.is() )
+		xSheet = xView->getActiveSheet();
+	return new ScVbaWorksheet( this, mxContext, xSheet, xModel );
 }
 uno::Any SAL_CALL
 ScVbaWorkbook::Sheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
@@ -281,91 +251,19 @@
 uno::Any SAL_CALL
 ScVbaWorkbook::Windows( const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	uno::Reference< XCollection >  xWindows = ScVbaWindows::Windows( mxContext );
+
+	uno::Reference< excel::XWindows >  xWindows( new ScVbaWindows( getParent(), mxContext ) );
 	if ( aIndex.getValueTypeClass() == uno::TypeClass_VOID )
 		return uno::Any( xWindows );
 	return uno::Any( xWindows->Item( aIndex, uno::Any() ) );
 }
-void
-ScVbaWorkbook::Close( const uno::Any &rSaveArg, const uno::Any &rFileArg,
-					  const uno::Any &rRouteArg ) throw (uno::RuntimeException)
-{
-	sal_Bool bSaveChanges = sal_False;
-	rtl::OUString aFileName;
-	sal_Bool bRouteWorkbook = sal_True;
 
-	rSaveArg >>= bSaveChanges;
-	sal_Bool bFileName =  ( rFileArg >>= aFileName );
-	rRouteArg >>= bRouteWorkbook;
-	uno::Reference< frame::XStorable > xStorable( getModel(), uno::UNO_QUERY_THROW );
-	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
-
-	if( bSaveChanges )
-	{
-		if( xStorable->isReadonly() )
-		{	
-			throw uno::RuntimeException(::rtl::OUString( 
-				RTL_CONSTASCII_USTRINGPARAM( "Unable to save to a read only file ") ),
-                        	uno::Reference< XInterface >() );
-		}
-		if( bFileName )
-			xStorable->storeAsURL( aFileName, uno::Sequence< beans::PropertyValue >(0) ); 
-		else
-			xStorable->store();
-	}	
-	else
-		xModifiable->setModified( false );		
-
-	uno::Reference< util::XCloseable > xCloseable( getModel(), uno::UNO_QUERY );
-
-	if( xCloseable.is() )
-		// use close(boolean DeliverOwnership)
-	
-		// The boolean parameter DeliverOwnership tells objects vetoing the close process that they may
-		// assume ownership if they object the closure by throwing a CloseVetoException
-		// Here we give up ownership. To be on the safe side, catch possible veto exception anyway.
-		xCloseable->close(sal_True);
-	// If close is not supported by this model - try to dispose it.
-	// But if the model disagree with a reset request for the modify state
-	// we shouldn't do so. Otherwhise some strange things can happen.
-	else
-	{
-		uno::Reference< lang::XComponent > xDisposable ( getCurrentDocument(), uno::UNO_QUERY );
-		if ( xDisposable.is() )
-			xDisposable->dispose();
-	}
-}
-
-void
-ScVbaWorkbook::Protect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+void SAL_CALL
+ScVbaWorkbook::Activate() throw (uno::RuntimeException)
 {
-	rtl::OUString rPassword;
-	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
-	SC_VBA_FIXME(("Workbook::Protect stub"));
-	if(  aPassword >>= rPassword )
-		xProt->protect( rPassword );
-	else
-		xProt->protect( rtl::OUString() );
+    VbaDocumentBase::Activate();
 }
 
-void 
-ScVbaWorkbook::Unprotect( const uno::Any &aPassword ) throw (uno::RuntimeException)
-{
-	rtl::OUString rPassword;
-	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
-	if( !getProtectStructure() )
-		throw uno::RuntimeException(::rtl::OUString(
-			RTL_CONSTASCII_USTRINGPARAM( "File is already unprotected" ) ),
-			uno::Reference< XInterface >() );
-	else
-	{
-		if( aPassword >>= rPassword )
-			xProt->unprotect( rPassword );
-		else
-			xProt->unprotect( rtl::OUString() );
-	}
-}
-		
 ::sal_Bool
 ScVbaWorkbook::getProtectStructure() throw (uno::RuntimeException)
 {
@@ -373,29 +271,23 @@
 	return xProt->isProtected();
 }
 
-void 
-ScVbaWorkbook::setSaved( sal_Bool bSave ) throw (uno::RuntimeException)
+::sal_Bool SAL_CALL ScVbaWorkbook::getPrecisionAsDisplayed() throw (uno::RuntimeException)
 {
-	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
-	xModifiable->setModified( bSave );
+    uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+    ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+    return pDoc->GetDocOptions().IsCalcAsShown();
 }
 
-sal_Bool
-ScVbaWorkbook::getSaved() throw (uno::RuntimeException)
+void SAL_CALL ScVbaWorkbook::setPrecisionAsDisplayed( sal_Bool _precisionAsDisplayed ) throw (uno::RuntimeException)
 {
-	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
-	return xModifiable->isModified();
+    uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
+    ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
+    ScDocOptions aOpt = pDoc->GetDocOptions();
+    aOpt.SetCalcAsShown( _precisionAsDisplayed );
+    pDoc->SetDocOptions( aOpt );
 }
 
 void
-ScVbaWorkbook::Save() throw (uno::RuntimeException)
-{
-	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Save"));
-	uno::Reference< frame::XModel > xModel = getModel();
-	dispatchRequests(xModel,url);
-}
-
-void
 ScVbaWorkbook::SaveCopyAs( const rtl::OUString& sFileName ) throw ( uno::RuntimeException)
 {
 	rtl::OUString aURL;
@@ -407,13 +299,6 @@
 	xStor->storeToURL( aURL, storeProps );
 }
 
-void 
-ScVbaWorkbook::Activate() throw (uno::RuntimeException)
-{
-	uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
-	xFrame->activate();
-}	
-
 css::uno::Any SAL_CALL 
 ScVbaWorkbook::Styles( const::uno::Any& Item ) throw (uno::RuntimeException)
 {
@@ -465,7 +350,7 @@
 {
 #ifdef VBA_OOBUILD_HACK 
     uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
-    ScDocument* pDoc = getDocShell( xModel )->GetDocument();
+    ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
     ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
     ScExtDocSettings pExtSettings = pExtOptions->GetDocSettings();
     ::rtl::OUString sGlobCodeName = pExtSettings.maGlobCodeName;
@@ -479,7 +364,7 @@
 ScVbaWorkbook::setCodeName( const ::rtl::OUString& sGlobCodeName ) throw (css::uno::RuntimeException)
 {
     uno::Reference< frame::XModel > xModel( getModel(), uno::UNO_QUERY_THROW );
-    ScDocument* pDoc = getDocShell( xModel )->GetDocument();
+    ScDocument* pDoc = excel::getDocShell( xModel )->GetDocument();
     ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
     ScExtDocSettings pExtSettings = pExtOptions->GetDocSettings();
     pExtSettings.maGlobCodeName = sGlobCodeName;
Index: sc/source/ui/vba/vbainterior.hxx
===================================================================
--- sc/source/ui/vba/vbainterior.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbainterior.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,9 +34,10 @@
 #include <com/sun/star/uno/XComponentContext.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
 
 #include <com/sun/star/script/XInvocation.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 class ScDocument;
 
Index: sc/source/ui/vba/vbanames.cxx
===================================================================
--- sc/source/ui/vba/vbanames.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbanames.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -27,7 +27,7 @@
  * for a copy of the LGPLv3 License.
  *
  ************************************************************************/
-#include "helperdecl.hxx"
+#include <vbahelper/helperdecl.hxx>
 
 #include <com/sun/star/table/XCellRange.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
@@ -81,7 +81,7 @@
 ScVbaNames::getScDocument()
 {
 	uno::Reference< frame::XModel > xModel( getModel() , uno::UNO_QUERY_THROW );
-	ScTabViewShell * pTabViewShell = getBestViewShell( xModel );
+	ScTabViewShell * pTabViewShell = excel::getBestViewShell( xModel );
 	if ( !pTabViewShell )
 		throw uno::RuntimeException( rtl::OUString::createFromAscii("No ViewShell available"), uno::Reference< uno::XInterface >() );
 	ScViewData* pViewData = pTabViewShell->GetViewData();
Index: sc/source/ui/vba/vbaaxes.hxx
===================================================================
--- sc/source/ui/vba/vbaaxes.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaaxes.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,7 +32,7 @@
 #include <ooo/vba/excel/XAxes.hpp>
 #include <ooo/vba/excel/XAxis.hpp>
 #include <ooo/vba/excel/XChart.hpp>
-#include "vbacollectionimpl.hxx"
+#include <vbahelper/vbacollectionimpl.hxx>
 
 typedef CollTestImplHelper< ov::excel::XAxes > ScVbaAxes_BASE;
 class ScVbaAxes : public ScVbaAxes_BASE
Index: sc/source/ui/vba/vbachart.hxx
===================================================================
--- sc/source/ui/vba/vbachart.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbachart.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -41,7 +41,7 @@
 #include <ooo/vba/excel/XChart.hpp>
 #include <ooo/vba/excel/XDataLabels.hpp>
 #include <ooo/vba/excel/XSeries.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1<ov::excel::XChart > ChartImpl_BASE;
 
Index: sc/source/ui/vba/vbaformatconditions.cxx
===================================================================
--- sc/source/ui/vba/vbaformatconditions.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaformatconditions.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,6 +36,7 @@
 #include "vbaformatcondition.hxx"
 #include "vbaworkbook.hxx"
 #include "vbastyles.hxx"
+#include "vbaglobals.hxx"
 using namespace ::ooo::vba;
 using namespace ::com::sun::star;
 
@@ -50,7 +51,7 @@
 ScVbaFormatConditions::ScVbaFormatConditions( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< sheet::XSheetConditionalEntries >& _xSheetConditionalEntries, const uno::Reference< frame::XModel >& xModel ) : ScVbaFormatConditions_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( _xSheetConditionalEntries, uno::UNO_QUERY_THROW ) ), mxSheetConditionalEntries( _xSheetConditionalEntries )
 {
 	mxRangeParent.set( xParent, uno::UNO_QUERY_THROW );
-	uno::Reference< excel::XWorkbook > xWorkbook = new ScVbaWorkbook(  uno::Reference< XHelperInterface >( ScVbaGlobals::getGlobalsImpl( xContext )->getApplication(), uno::UNO_QUERY_THROW ), xContext, xModel );
+	uno::Reference< excel::XWorkbook > xWorkbook = new ScVbaWorkbook(  uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), xContext, xModel );
 	mxStyles.set( xWorkbook->Styles( uno::Any() ), uno::UNO_QUERY_THROW );
 	uno::Reference< sheet::XCellRangeAddressable > xCellRange( mxRangeParent->getCellRange(), uno::UNO_QUERY_THROW );
 	mxParentRangePropertySet.set( xCellRange, uno::UNO_QUERY_THROW );
Index: sc/source/ui/vba/vbacharts.cxx
===================================================================
--- sc/source/ui/vba/vbacharts.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbacharts.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,11 +35,9 @@
 using namespace ::ooo::vba;
 
 
-ScVbaCharts::ScVbaCharts( const css::uno::Reference< ov::XHelperInterface >& _xParent, const css::uno::Reference< css::uno::XComponentContext >& _xContext ) : Charts_BASE(_xParent, _xContext, uno::Reference< container::XIndexAccess >() )
+ScVbaCharts::ScVbaCharts( const css::uno::Reference< ov::XHelperInterface >& _xParent, const css::uno::Reference< css::uno::XComponentContext >& _xContext, const uno::Reference< frame::XModel >& xModel ) : Charts_BASE(_xParent, _xContext, uno::Reference< container::XIndexAccess >())
 {
-	// #TODO #FIXME surely this is wrong, you should never use the 
-	// currently documement ( it could be anything )
-	xComponent.set( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	xComponent.set( xModel, uno::UNO_QUERY_THROW );
 	xSpreadsheetDocument.set( xComponent, uno::UNO_QUERY_THROW );
 }
 
Index: sc/source/ui/vba/vbaoutline.hxx
===================================================================
--- sc/source/ui/vba/vbaoutline.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/vba/vbaoutline.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -34,7 +34,7 @@
 #include <cppuhelper/implbase1.hxx>
 #include <ooo/vba/excel/XOutline.hpp>
 #include <com/sun/star/uno/XComponentContext.hpp>
-#include "vbahelperinterface.hxx"
+#include <vbahelper/vbahelperinterface.hxx>
 
 typedef InheritedHelperInterfaceImpl1< ov::excel::XOutline > ScVbaOutline_BASE;
 
Index: sc/source/ui/inc/docsh.hxx
===================================================================
--- sc/source/ui/inc/docsh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/docsh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,6 +47,7 @@
 #include "refreshtimer.hxx"
 
 #include <hash_map>
+#include <cppuhelper/implbase1.hxx>
 
 class ScEditEngineDefaulter;
 class FontList;
Index: sc/source/ui/inc/tabvwsh.hxx
===================================================================
--- sc/source/ui/inc/tabvwsh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/tabvwsh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -252,7 +252,7 @@
 
 	virtual			~ScTabViewShell();
 
-	Window*			GetDialogParent();
+	SC_DLLPUBLIC Window* GetDialogParent();
 
     bool            IsRefInputMode() const;
 	void			ExecuteInputDirect();
Index: sc/source/ui/inc/undodat.hxx
===================================================================
--- sc/source/ui/inc/undodat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/undodat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -530,8 +530,44 @@
 	void				Init();
 };
 
+// amelia
+class ScUndoDataForm: public ScBlockUndo
+{
+public:
+					TYPEINFO();
+					ScUndoDataForm( ScDocShell* pNewDocShell,
+								SCCOL nStartX, SCROW nStartY, SCTAB nStartZ,
+								SCCOL nEndX, SCROW nEndY, SCTAB nEndZ,
+								const ScMarkData& rMark,
+								ScDocument* pNewUndoDoc, ScDocument* pNewRedoDoc,
+								USHORT nNewFlags,
+								ScRefUndoData* pRefData, void* pFill1, void* pFill2, void* pFill3,
+								BOOL bRedoIsFilled = TRUE
+								 );
+	virtual		~ScUndoDataForm();
 
+	virtual	void	Undo();
+	virtual	void	Redo();
+	virtual void	Repeat(SfxRepeatTarget& rTarget);
+	virtual BOOL	CanRepeat(SfxRepeatTarget& rTarget) const;
 
+	virtual String	GetComment() const;
 
+private:
+	ScMarkData		aMarkData;
+	ScDocument*		pUndoDoc;
+	ScDocument*		pRedoDoc;
+	USHORT			nFlags;
+	ScRefUndoData*		pRefUndoData;
+	ScRefUndoData*		pRefRedoData;
+	ULONG			nStartChangeAction;
+	ULONG			nEndChangeAction;
+	BOOL			bRedoFilled;
+
+	void			DoChange( const BOOL bUndo );
+	void			SetChangeTrack();
+};
+
+
 #endif
 
Index: sc/source/ui/inc/tabview.hxx
===================================================================
--- sc/source/ui/inc/tabview.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/tabview.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -292,7 +292,7 @@
 
 	void			TabChanged();
 	void			SetZoom( const Fraction& rNewX, const Fraction& rNewY, BOOL bAll );
-    void            RefreshZoom();
+	SC_DLLPUBLIC void            RefreshZoom();
 	void			SetPagebreakMode( BOOL bSet );
 
 	void			UpdateLayerLocks();
Index: sc/source/ui/inc/viewdata.hxx
===================================================================
--- sc/source/ui/inc/viewdata.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/viewdata.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -225,6 +225,7 @@
 
 	SC_DLLPRIVATE void			CalcPPT();
     SC_DLLPRIVATE void          CreateTabData( SCTAB nNewTab );
+    SC_DLLPRIVATE void          CreateTabData( std::vector< SCTAB >& rvTabs );
     SC_DLLPRIVATE void          CreateSelectedTabData();
 
 public:
@@ -311,6 +312,8 @@
 	void			SetPagebreakMode( BOOL bSet );
 
     void            SetZoomType( SvxZoomType eNew, BOOL bAll );
+    void            SetZoomType( SvxZoomType eNew, std::vector< SCTAB >& tabs );
+    void            SetZoom( const Fraction& rNewX, const Fraction& rNewY, std::vector< SCTAB >& tabs );
     void            SetZoom( const Fraction& rNewX, const Fraction& rNewY, BOOL bAll );
     void            RefreshZoom();
 
Index: sc/source/ui/inc/datafdlg.hxx
===================================================================
--- sc/source/ui/inc/datafdlg.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/inc/datafdlg.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hxx,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:20:35 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DATAFDLG_HXX
+#define SC_DATAFDLG_HXX
+
+
+#ifndef _SV_DIALOG_HXX //autogen
+#include <vcl/dialog.hxx>
+#endif
+
+#ifndef _SV_BUTTON_HXX //autogen
+#include <vcl/imagebtn.hxx>
+#endif
+
+#ifndef _SV_FIXED_HXX //autogen
+#include <vcl/fixed.hxx>
+#endif
+
+
+#include "global.hxx"
+
+#include <tabvwsh.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/dispatch.hxx>
+
+#define MAX_DATAFORM_COLS   256
+#define MAX_DATAFORM_ROWS   32000
+#define CTRL_HEIGHT         22
+#define FIXED_WIDTH         60
+#define EDIT_WIDTH          140 
+#define FIXED_LEFT          12
+#define EDIT_LEFT           78
+#define LINE_HEIGHT         30
+
+//zhangyun
+class ScDataFormDlg : public ModalDialog
+{
+private:
+
+    PushButton      aBtnNew;
+    PushButton      aBtnDelete;
+    PushButton      aBtnRestore;
+    PushButton      aBtnLast;
+    PushButton      aBtnNext;
+    PushButton      aBtnClose;
+    ScrollBar       aSlider;
+    FixedText       aFixedText;
+    //FixedText       aFixedText1;
+    //Edit            aEdit1;
+    
+    ScTabViewShell* pTabViewShell;
+    ScDocument*     pDoc;
+    sal_uInt16      aColLength;
+    SCROW           aCurrentRow;
+    SCCOL           nStartCol;
+    SCCOL           nEndCol;
+    SCROW           nStartRow;
+    SCROW           nEndRow;
+    SCTAB           nTab;
+    BOOL            bNoSelection;
+    
+    FixedText** pFixedTexts;
+    Edit** pEdits;
+
+public:
+    ScDataFormDlg( Window* pParent, ScTabViewShell* pTabViewShell);
+    ~ScDataFormDlg();
+    
+    void FillCtrls(SCROW nCurrentRow);
+private:
+
+    void SetButtonState();
+
+    // Handler:
+    DECL_LINK( Impl_NewHdl,     PushButton*    );
+    DECL_LINK( Impl_LastHdl,    PushButton*    );
+    DECL_LINK( Impl_NextHdl,    PushButton*    );
+    
+    DECL_LINK( Impl_RestoreHdl, PushButton*    );
+    DECL_LINK( Impl_DeleteHdl,  PushButton*    );
+    DECL_LINK( Impl_CloseHdl,   PushButton*    );
+    
+    DECL_LINK( Impl_ScrollHdl,  ScrollBar*    );
+    DECL_LINK( Impl_DataModifyHdl,  Edit*    );
+};
+#endif // SC_DATAFDLG_HXX
+
+
Index: sc/source/ui/inc/viewfunc.hxx
===================================================================
--- sc/source/ui/inc/viewfunc.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/viewfunc.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -334,6 +334,13 @@
 	void			ForgetFormatArea()		{ bFormatValid = FALSE; }
 	BOOL			SelectionEditable( BOOL* pOnlyNotBecauseOfMatrix = NULL );
 
+        // Amelia Wang
+        SC_DLLPUBLIC void                   DataFormPutData( SCROW nCurrentRow ,
+                                                             SCROW nStartRow , SCCOL nStartCol ,
+                                                             SCROW nEndRow , SCCOL nEndCol ,
+                                                             Edit** pEdits ,
+                                                             sal_uInt16 aColLength );
+
 												// interne Hilfsfunktionen
 protected:
 	void			UpdateLineAttrs( SvxBorderLine&		  rLine,
Index: sc/source/ui/inc/datafdlg.hrc
===================================================================
--- sc/source/ui/inc/datafdlg.hrc	(.../tags/DEV300_m58)	(revision 0)
+++ sc/source/ui/inc/datafdlg.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: datafdlg.hrc,v $
+ *
+ *  $Revision: 1.00 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:37:12 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sc.hrc"	// -> RID_SCDLG_DATAFORM
+
+//dataform
+#define BTN_DATAFORM_NEW          1001
+#define BTN_DATAFORM_DELETE       1002
+#define BTN_DATAFORM_RESTORE      1003
+#define BTN_DATAFORM_LAST         1004
+#define BTN_DATAFORM_NEXT         1005
+#define BTN_DATAFORM_CLOSE        1007
+#define WND_DATAFORM_SCROLLBAR    1008
+#define LAB_DATAFORM_RECORDNO     1009
+
+#define FT_DATAFORM_FIXEDTEXT1    2001
+#define ED_DATAFORM_EDIT1         2002
\ No newline at end of file
Index: sc/source/ui/inc/docfunc.hxx
===================================================================
--- sc/source/ui/inc/docfunc.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/docfunc.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -161,6 +161,8 @@
 								double fStart, double fStep, double fMax,
 								BOOL bRecord, BOOL bApi );
 					// FillAuto: rRange wird von Source-Range auf Dest-Range angepasst
+	SC_DLLPUBLIC	BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark, FillDir eDir, FillCmd eCmd, FillDateCmd	eDateCmd, ULONG nCount, double fStep, double fMax, BOOL bRecord, BOOL bApi );
+
 	BOOL			FillAuto( ScRange& rRange, const ScMarkData* pTabMark,
 								FillDir eDir, ULONG nCount, BOOL bRecord, BOOL bApi );
 
Index: sc/source/ui/inc/drawsh.hxx
===================================================================
--- sc/source/ui/inc/drawsh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/inc/drawsh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,9 +47,7 @@
 
     DECL_LINK( NameObjectHdl, AbstractSvxNameDialog* );
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk );
-#endif
 
 protected:
 	ScViewData*	GetViewData()	{ return pViewData; }
Index: sc/source/ui/drawfunc/fusel.cxx
===================================================================
--- sc/source/ui/drawfunc/fusel.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/fusel.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -205,7 +205,6 @@
                    }
 
                    ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj, TRUE );
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                    // For interoperability favour links over macros if both are defined
                    if ( pInfo->GetHlink().getLength() > 0 )
                    {
@@ -213,20 +212,27 @@
                        sURL = pInfo->GetHlink();
                    }
                    else if ( pInfo->GetMacro().getLength() > 0 )
-#else
-                   if ( pInfo->GetMacro().getLength() > 0 )
-#endif
                    {
                        SfxObjectShell* pObjSh = SfxObjectShell::Current();
                        if ( pObjSh && SfxApplication::IsXScriptURL( pInfo->GetMacro() ) )
                        {
+                           uno::Reference< beans::XPropertySet > xProps( pObj->getUnoShape(), uno::UNO_QUERY );
+                           uno::Any aCaller;
+                           if ( xProps.is() )
+                           {
+                               try
+                               {
+                                   aCaller = xProps->getPropertyValue( rtl::OUString::createFromAscii("Name") );
+                               }
+                               catch( uno::Exception& ) {}
+                           }
                            uno::Any aRet;
                            uno::Sequence< sal_Int16 > aOutArgsIndex;
                            uno::Sequence< uno::Any > aOutArgs;
                            uno::Sequence< uno::Any >* pInArgs =
                                new uno::Sequence< uno::Any >(0);
                            pObjSh->CallXScript( pInfo->GetMacro(),
-                               *pInArgs, aRet, aOutArgsIndex, aOutArgs);
+                               *pInArgs, aRet, aOutArgsIndex, aOutArgs, true, &aCaller );
                            pViewShell->FakeButtonUp( pViewShell->GetViewData()->GetActivePart() );
                            return TRUE;        // kein CaptureMouse etc.
                        }
Index: sc/source/ui/drawfunc/makefile.mk
===================================================================
--- sc/source/ui/drawfunc/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -79,6 +79,7 @@
         $(SLO)$/mediash.obj
 
 EXCEPTIONSFILES= \
+        $(SLO)$/fusel.obj \
         $(SLO)$/fuins2.obj
 
 NOOPTFILES=\
Index: sc/source/ui/drawfunc/fudraw.cxx
===================================================================
--- sc/source/ui/drawfunc/fudraw.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/fudraw.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -831,11 +831,7 @@
 			SdrObjMacroHitRec aHitRec;	//! muss da noch irgendwas gesetzt werden ????
 			pViewShell->SetActivePointer( pObj->GetMacroPointer(aHitRec) );
 		}
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         else if ( !bAlt && pInfo && ((pInfo->GetMacro().getLength() > 0) || (pInfo->GetHlink().getLength() > 0)) )
-#else
-        else if ( !bAlt && pInfo && (pInfo->GetMacro().getLength() > 0) )
-#endif
 			pWindow->SetPointer( Pointer( POINTER_REFHAND ) );
 		else if ( IsDetectiveHit( aPnt ) )
 			pViewShell->SetActivePointer( Pointer( POINTER_DETECTIVE ) );
Index: sc/source/ui/drawfunc/drawsh.cxx
===================================================================
--- sc/source/ui/drawfunc/drawsh.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/drawsh.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -211,7 +211,6 @@
 			ExecuteTextAttrDlg( rReq );
 			break;
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         case SID_DRAW_HLINK_EDIT:
             if ( pSingleSelectedObj )
                 pViewData->GetDispatcher().Execute( SID_HYPERLINK_DIALOG );
@@ -239,7 +238,6 @@
                     ScGlobal::OpenURL( pInfo->GetHlink(), String::EmptyString() );
             }
             break;
-#endif
 
 		case SID_ATTR_TRANSFORM:
 			{
@@ -494,7 +492,6 @@
 	delete( pDlg );
 }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 void ScDrawShell::SetHlinkForObject( SdrObject* pObj, const rtl::OUString& rHlnk )
 {
     if ( pObj )
@@ -504,5 +501,4 @@
         lcl_setModified( GetObjectShell() );
     }
 }
-#endif
 
Index: sc/source/ui/drawfunc/drawsh2.cxx
===================================================================
--- sc/source/ui/drawfunc/drawsh2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/drawsh2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -200,24 +200,20 @@
 	BOOL bCanRename = FALSE;
     if ( nMarkCount > 1 )
     {
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         // no hypelink options for a selected group
         rSet.DisableItem( SID_DRAW_HLINK_EDIT );
         rSet.DisableItem( SID_DRAW_HLINK_DELETE );
         rSet.DisableItem( SID_OPEN_HYPERLINK );
-#endif
     }
     else if ( nMarkCount == 1 )
 	{
         SdrObject* pObj = rMarkList.GetMark( 0 )->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( !pInfo || (pInfo->GetHlink().getLength() == 0) )
         {
             rSet.DisableItem( SID_DRAW_HLINK_DELETE );
             rSet.DisableItem( SID_OPEN_HYPERLINK );
         }
-#endif
         SdrLayerID nLayerID = pObj->GetLayer();
         if ( nLayerID != SC_LAYER_INTERN )
             bCanRename = TRUE;                          // #i51351# anything except internal objects can be renamed
Index: sc/source/ui/drawfunc/drawsh5.cxx
===================================================================
--- sc/source/ui/drawfunc/drawsh5.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/drawsh5.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -95,14 +95,12 @@
     if ( nMarkCount == 1 )              // URL-Button markiert ?
     {
         SdrObject* pObj = rMarkList.GetMark(0)->GetMarkedSdrObj();
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
         ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
         if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
         {
             aHLinkItem.SetURL( pInfo->GetHlink() );
             aHLinkItem.SetInsertMode(HLINK_FIELD);
         }
-#endif
         SdrUnoObj* pUnoCtrl = PTR_CAST(SdrUnoObj, pObj);
         if (pUnoCtrl && FmFormInventor == pUnoCtrl->GetObjInventor())
         {
@@ -245,13 +243,11 @@
                                     bDone = TRUE;
                                 }
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             else
                             {
                                 SetHlinkForObject( pObj, rURL );
                                 bDone = TRUE;
                             }
-#endif
                         }
                     }
 
Index: sc/source/ui/drawfunc/objdraw.src
===================================================================
--- sc/source/ui/drawfunc/objdraw.src	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/drawfunc/objdraw.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -189,7 +189,6 @@
         ITEM_FORMAT_PARA_DLG\
     };
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 #define MN_EDITLNK \
     MenuItem\
     {\
@@ -205,7 +204,6 @@
         HelpID = SID_DRAW_HLINK_DELETE ; \
         Text [ en-US ] = "~Remove Hyperlink" ; \
 	};
-#endif
 
 #define MN_DRWTXTATTR \
     MenuItem\
@@ -1298,14 +1296,12 @@
 		MenuItem { Separator = TRUE ; };
 		 //------------------------------
 		ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 		 //------------------------------
 		MenuItem { Separator = TRUE ; };
 		 //------------------------------
 		MN_EDITLNK
 		MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
 	};
 };
 
@@ -1375,14 +1371,12 @@
 		MenuItem { Separator = TRUE ; };
 		 //------------------------------
 		ITEM_GROUP_MENU
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 		 //------------------------------
 		MenuItem { Separator = TRUE ; };
 		 //------------------------------
 		MN_EDITLNK
 		MN_DELLNK
         MenuItem { ITEM_OPEN_HYPERLINK };
-#endif
 	};
 };
 
Index: sc/source/ui/view/gridwin5.cxx
===================================================================
--- sc/source/ui/view/gridwin5.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/gridwin5.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -346,14 +346,12 @@
                                     if ( pDrView->PickObj(aMDPos, pDrView->getHitTolLog(), pHit, pPV, SDRSEARCH_DEEP ) )
                                         pObj = pHit;
                             }
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
                             ScMacroInfo* pInfo = ScDrawLayer::GetMacroInfo( pObj );
                             if ( pInfo && (pInfo->GetHlink().getLength() > 0) )
                             {
                                 aPixRect = LogicToPixel(aVEvt.pObj->GetLogicRect());
                                 aHelpText = pInfo->GetHlink();
                             }
-#endif
                         }
                     }
                 }
Index: sc/source/ui/view/viewfun2.cxx
===================================================================
--- sc/source/ui/view/viewfun2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/viewfun2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -57,6 +57,11 @@
 #include <vcl/sound.hxx>
 #include <vcl/waitobj.hxx>
 
+#include <basic/sbstar.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+using namespace com::sun::star;
+
 #include "viewfunc.hxx"
 
 #include "sc.hrc"
@@ -2139,15 +2144,42 @@
 	return bSuccess;
 }
 
+void lcl_DeleteModule( ScDocShell* rDocSh, String& sModuleName )
+{
+    SFX_APP()->EnterBasicCall();
+    uno::Reference< script::XLibraryContainer > xLibContainer = rDocSh->GetBasicContainer();
+    DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+    uno::Reference< container::XNameContainer > xLib;
+    if( xLibContainer.is() )
+    {
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        uno::Any aLibAny = xLibContainer->getByName( aLibName );
+        aLibAny >>= xLib;
+    }
+    if( xLib.is() )
+    {
+        if( xLib->hasByName( sModuleName ) )
+        {
+            xLib->removeByName( sModuleName );
+        }
+    }
+    SFX_APP()->LeaveBasicCall();
+}
+
 BOOL ScViewFunc::DeleteTables(const SvShorts &TheTabs, BOOL bRecord )
 {
 	ScDocShell* pDocSh	= GetViewData()->GetDocShell();
 	ScDocument* pDoc 	= pDocSh->GetDocument();
+    StarBASIC* pStarBASIC = pDocSh->GetBasic();
+    BOOL bVbaEnabled = pStarBASIC->isVBAEnabled();
 	SCTAB		nNewTab = TheTabs[0];
 	int			i;
 	WaitObject aWait( GetFrameWin() );
 	if (bRecord && !pDoc->IsUndoEnabled())
 		bRecord = FALSE;
+    if ( bVbaEnabled )
+        bRecord = FALSE;
 
 	while ( nNewTab > 0 && !pDoc->IsVisible( nNewTab ) )
 		--nNewTab;
@@ -2214,9 +2246,18 @@
 
 	for(i=TheTabs.Count()-1;i>=0;i--)
 	{
+        String sCodeName;
+        BOOL bHasCodeName = pDoc->GetCodeName( TheTabs[sal::static_int_cast<USHORT>(i)], sCodeName );
         if (pDoc->DeleteTab( TheTabs[sal::static_int_cast<USHORT>(i)], pUndoDoc ))
 		{
 			bDelDone = TRUE;
+            if( bVbaEnabled )
+            {
+                if( bHasCodeName )
+                {
+                    lcl_DeleteModule( pDocSh, sCodeName );
+                }
+            }
             pDocSh->Broadcast( ScTablesHint( SC_TAB_DELETED, TheTabs[sal::static_int_cast<USHORT>(i)] ) );
 		}
 	}
@@ -2244,6 +2285,7 @@
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
 
+
         SfxApplication* pSfxApp = SFX_APP();                                // Navigator
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
         pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
Index: sc/source/ui/view/viewfun3.cxx
===================================================================
--- sc/source/ui/view/viewfun3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/viewfun3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -213,6 +213,7 @@
 #include "drwtrans.hxx"
 #include "docuno.hxx"
 #include "clipparam.hxx"
+#include "undodat.hxx"   // Amelia Wang
 
 using namespace com::sun::star;
 
@@ -1787,6 +1788,85 @@
 	return TRUE;
 }
 
+void ScViewFunc::DataFormPutData( SCROW nCurrentRow ,
+                                  SCROW nStartRow , SCCOL nStartCol ,
+                                  SCROW nEndRow , SCCOL nEndCol ,
+                                  Edit** pEdits ,
+                                  sal_uInt16 aColLength )
+{
+    ScDocument* pDoc = GetViewData()->GetDocument();
+    ScDocShell* pDocSh = GetViewData()->GetDocShell();
+    ScMarkData& rMark = GetViewData()->GetMarkData();
+    ScDocShellModificator aModificator( *pDocSh );
+    SfxUndoManager* pUndoMgr = pDocSh->GetUndoManager();
+    if ( pDoc )
+    {
+        const BOOL bRecord( pDoc->IsUndoEnabled());
+        ScDocument* pUndoDoc = NULL;
+        ScDocument* pRedoDoc = NULL;
+        ScDocument* pRefUndoDoc = NULL;
+        ScRefUndoData* pUndoData = NULL;
+        SCTAB nTab = GetViewData()->GetTabNo();
+        SCTAB nStartTab = nTab;
+        SCTAB nEndTab = nTab;
+        
+        {
+                ScChangeTrack* pChangeTrack = pDoc->GetChangeTrack();
+                if ( pChangeTrack )
+                        pChangeTrack->ResetLastCut();   // kein CutMode mehr
+        }
+        ScRange aUserRange( nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );
+        BOOL bColInfo = ( nStartRow==0 && nEndRow==MAXROW );
+        BOOL bRowInfo = ( nStartCol==0 && nEndCol==MAXCOL );
+        SCCOL nUndoEndCol = nStartCol+aColLength-1;
+        SCROW nUndoEndRow = nCurrentRow;
+        USHORT nUndoFlags = IDF_NONE;
 
+        if ( bRecord )
+        {
+            pUndoDoc = new ScDocument( SCDOCMODE_UNDO );
+            pUndoDoc->InitUndoSelected( pDoc , rMark , bColInfo , bRowInfo );
+            pDoc->CopyToDocument( aUserRange , 1 , FALSE , pUndoDoc );
+        }
+        USHORT nExtFlags = 0;
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nStartRow, nStartTab , nEndCol, nEndRow, nEndTab ); // content before the change
+        //rMark.SetMarkArea( aUserRange );
+        pDoc->BeginDrawUndo();
+        
+        for(sal_uInt16 i = 0; i < aColLength; i++)
+        {
+            if (pEdits[i])
+            {
+                String  aFieldName=pEdits[i]->GetText();
+                pDoc->SetString( nStartCol + i, nCurrentRow, nTab, aFieldName );
+            }
+        }
+        //pDoc->ExtendMergeSel( nStartCol, nStartRow, nEndCol, nEndRow, rMark, TRUE );    // Refresh
+        pDocSh->UpdatePaintExt( nExtFlags, nStartCol, nCurrentRow, nStartTab, nEndCol, nCurrentRow, nEndTab );  // content after the change
+        SfxUndoAction* pUndo = new ScUndoDataForm( pDocSh,
+                                                                nStartCol, nCurrentRow, nStartTab,
+                                                                nUndoEndCol, nUndoEndRow, nEndTab, rMark,
+                                                                pUndoDoc, pRedoDoc, nUndoFlags,
+                                                                pUndoData, NULL, NULL, NULL,
+                                                                FALSE );           // FALSE = Redo data not yet copied
+        pUndoMgr->AddUndoAction( new ScUndoWrapper( pUndo ), TRUE );
+        
+        USHORT nPaint = PAINT_GRID;
+        if (bColInfo)
+        {
+                nPaint |= PAINT_TOP;
+                nUndoEndCol = MAXCOL;                           // nur zum Zeichnen !
+        }
+        if (bRowInfo)
+        {
+                nPaint |= PAINT_LEFT;
+                nUndoEndRow = MAXROW;                           // nur zum Zeichnen !
+        }
 
+        pDocSh->PostPaint( nStartCol, nCurrentRow, nStartTab,
+                                                nUndoEndCol, nUndoEndRow, nEndTab, nPaint, nExtFlags );
+        pDocSh->UpdateOle(GetViewData());
+    }
+}
 
+
Index: sc/source/ui/view/tabview3.cxx
===================================================================
--- sc/source/ui/view/tabview3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/tabview3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -82,7 +82,11 @@
 #include "tabprotection.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
 
+using namespace com::sun::star::document::VbaEventId;
+
 namespace
 {
 
@@ -1463,10 +1467,15 @@
 	{
 		SCCOL nAlignX = rRange.aStart.Col();
 		SCROW nAlignY = rRange.aStart.Row();
-		if ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL )
-			nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
-		if ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW )
-			nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
+		bool bCol = ( rRange.aStart.Col() == 0 && rRange.aEnd.Col() == MAXCOL );
+		bool bRow = ( rRange.aStart.Row() == 0 && rRange.aEnd.Row() == MAXROW );
+		if ( !bCol && !bRow )
+		{
+			if ( bCol ) 
+				nAlignX = aViewData.GetPosX(WhichH(aViewData.GetActivePart()));
+			if ( bRow )
+				nAlignY = aViewData.GetPosY(WhichV(aViewData.GetActivePart()));
+		}
 		AlignToCursor( nAlignX, nAlignY, SC_FOLLOW_JUMP );
 	}
 	InitBlockMode( rRange.aStart.Col(), rRange.aStart.Row(), nTab );
@@ -1583,6 +1592,17 @@
 										//	nicht InputEnterHandler wegen Referenzeingabe !
 
 		ScDocument* pDoc = aViewData.GetDocument();
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_DEACTIVATE, aArgs );
+            }
+		}
+			
 		pDoc->MakeTable( nTab );
 
         // Update pending row heights before switching the sheet, so Reschedule from the progress bar
@@ -1687,8 +1707,20 @@
 					if ( pGridWin[i]->IsVisible() )
 						pGridWin[i]->UpdateEditViewPos();
 		}
+		
+		TabChanged();										// DrawView
 
-		TabChanged();										// DrawView
+		if( !bNew )
+		{
+            uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pDoc->GetVbaEventsHelper(), uno::UNO_QUERY );
+            if( xVbaEventsHelper.is() )
+            {
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[0] <<= aViewData.GetTabNo();
+			    xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_ACTIVATE,  aArgs );
+            }
+		}
+			
 		aViewData.GetViewShell()->WindowChanged();			// falls das aktive Fenster anders ist
         if ( !bUnoRefDialog )
             aViewData.GetViewShell()->DisconnectAllClients();   // important for floating frames
Index: sc/source/ui/view/viewdata.cxx
===================================================================
--- sc/source/ui/view/viewdata.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/viewdata.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -597,66 +597,103 @@
 		pView		= NULL;
 	}
 }
+void ScViewData::CreateTabData( std::vector< SCTAB >& rvTabs )
+{
+    std::vector< SCTAB >::iterator it_end = rvTabs.end();
+    for ( std::vector< SCTAB >::iterator it = rvTabs.begin(); it != it_end; ++it )
+        if ( !pTabData[*it] )
+            CreateTabData( *it );
+}
 
-void ScViewData::SetZoomType( SvxZoomType eNew, BOOL bAll )
+void ScViewData::SetZoomType( SvxZoomType eNew, std::vector< SCTAB >& tabs )
 {
-    if ( !bAll )
-        CreateSelectedTabData();    // if zoom is set for a table, it must be stored
+    BOOL bAll = ( tabs.size() == 0 );
 
-    for ( SCTAB i = 0; i <= MAXTAB; i++ )
-        if ( pTabData[i] && ( bAll || aMarkData.GetTableSelect(i) ) )
+    if ( !bAll ) // create associated table data
+        CreateTabData( tabs );
+
+    std::vector< SCTAB >::iterator it_end = tabs.end();
+    std::vector< SCTAB >::iterator it = tabs.begin();
+    for ( SCTAB i = ( bAll ? 0 : *it ); ( bAll ? i <= MAXTAB :  it != it_end  ); ++i , ++it )
+    {
+        if ( pTabData[i] )
             pTabData[i]->eZoomType = eNew;
+    } 
 
     if ( bAll )
         eDefZoomType = eNew;
 }
 
-void ScViewData::SetZoom( const Fraction& rNewX, const Fraction& rNewY, BOOL bAll )
+void ScViewData::SetZoomType( SvxZoomType eNew, BOOL bAll )
 {
-    if ( !bAll )
-        CreateSelectedTabData();    // if zoom is set for a table, it must be stored
+    std::vector< SCTAB > vTabs; // Empty for all tabs
+    if ( !bAll ) // get selected tabs
+    {
+        SCTAB nTabCount = pDoc->GetTableCount();
+        for (SCTAB i=0; i<nTabCount; i++)
+        {
+            if ( aMarkData.GetTableSelect(i)  )
+                vTabs.push_back( i );
+        }
+    } 
+    SetZoomType( eNew, vTabs );
+}
 
-	Fraction aFrac20( 1,5 );
-	Fraction aFrac400( 4,1 );
+void ScViewData::SetZoom( const Fraction& rNewX, const Fraction& rNewY, std::vector< SCTAB >& tabs )
+{
+    BOOL bAll = ( tabs.size() == 0 );
+    if ( !bAll ) // create associated table data
+        CreateTabData( tabs );
+    Fraction aFrac20( 1,5 );
+    Fraction aFrac400( 4,1 );
 
-	Fraction aValidX = rNewX;
-	if (aValidX<aFrac20) aValidX = aFrac20;
-	if (aValidX>aFrac400) aValidX = aFrac400;
+    Fraction aValidX = rNewX;
+    if (aValidX<aFrac20)
+        aValidX = aFrac20;
+    if (aValidX>aFrac400)
+        aValidX = aFrac400;
 
-	Fraction aValidY = rNewY;
-	if (aValidY<aFrac20) aValidY = aFrac20;
-	if (aValidY>aFrac400) aValidY = aFrac400;
+    Fraction aValidY = rNewY;
+    if (aValidY<aFrac20)
+        aValidY = aFrac20;
+    if (aValidY>aFrac400)
+        aValidY = aFrac400;
 
-	if ( bPagebreak )
-	{
-        for ( SCTAB i = 0; i <= MAXTAB; i++ )
-            if ( pTabData[i] && ( bAll || aMarkData.GetTableSelect(i) ) )
+    std::vector< SCTAB >::iterator it_end = tabs.end();
+    std::vector< SCTAB >::iterator it = tabs.begin();
+
+    for ( SCTAB i = ( bAll ? 0 : *it ); ( bAll ? i <= MAXTAB :  it != it_end  ); ++i , ++it )
+    {
+        if ( pTabData[i] )
+        {
+            if ( bPagebreak )
             {
                 pTabData[i]->aPageZoomX = aValidX;
                 pTabData[i]->aPageZoomY = aValidY;
             }
-        if ( bAll )
-        {
-            aDefPageZoomX = aValidX;
-            aDefPageZoomY = aValidY;
-        }
-	}
-	else
-	{
-        for ( SCTAB i = 0; i <= MAXTAB; i++ )
-            if ( pTabData[i] && ( bAll || aMarkData.GetTableSelect(i) ) )
+            else
             {
                 pTabData[i]->aZoomX = aValidX;
                 pTabData[i]->aZoomY = aValidY;
             }
-        if ( bAll )
+        }
+    }
+    RefreshZoom();
+}
+
+void ScViewData::SetZoom( const Fraction& rNewX, const Fraction& rNewY, BOOL bAll )
+{
+    std::vector< SCTAB > vTabs;
+    if ( !bAll ) // get selected tabs
+    {
+        SCTAB nTabCount = pDoc->GetTableCount();
+        for (SCTAB i=0; i<nTabCount; i++)
         {
-            aDefZoomX = aValidX;
-            aDefZoomY = aValidY;
+            if ( aMarkData.GetTableSelect(i)  )
+                vTabs.push_back( i );
         }
-	}
-
-	RefreshZoom();
+    } 
+    SetZoom( rNewX, rNewY, vTabs );
 }
 
 void ScViewData::RefreshZoom()
Index: sc/source/ui/view/cellsh2.cxx
===================================================================
--- sc/source/ui/view/cellsh2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/cellsh2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -336,6 +336,20 @@
 			}
 			break;
 
+		case SID_DATA_FORM:
+			{
+				ScAbstractDialogFactory* pFact = ScAbstractDialogFactory::Create();
+	            DBG_ASSERT(pFact, "ScAbstractFactory create fail!");//CHINA001
+
+	            AbstractScDataFormDlg* pDlg = pFact->CreateScDataFormDlg( pTabViewShell->GetDialogParent(),RID_SCDLG_DATAFORM, pTabViewShell);
+	            DBG_ASSERT(pDlg, "Dialog create fail!");//CHINA001
+
+	            pDlg->Execute();
+	            
+				rReq.Done();
+			}
+			break;
+			
 		case SID_SUBTOTALS:
 			{
 				const SfxItemSet* pArgs = rReq.GetArgs();
Index: sc/source/ui/view/gridwin.cxx
===================================================================
--- sc/source/ui/view/gridwin.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/source/ui/view/gridwin.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -128,7 +128,13 @@
 #include <vcl/svapp.hxx>
 #include <svx/sdr/overlay/overlayselection.hxx>
 
+#include "cellsuno.hxx"
+
+#include <com/sun/star/document/XVbaEventsHelper.hpp>
+#include <com/sun/star/document/VbaEventId.hpp>
+
 using namespace com::sun::star;
+using namespace com::sun::star::document::VbaEventId;
 using ::com::sun::star::uno::Sequence;
 using ::com::sun::star::uno::Any;
 
@@ -352,6 +358,32 @@
     }
 }
 
+sal_Bool lcl_GetHyperlinkCell(ScDocument* pDoc, SCCOL& rPosX, SCROW& rPosY, SCTAB nTab, ScBaseCell*& rpCell )
+{
+	BOOL bFound = FALSE;
+	do
+	{
+		pDoc->GetCell( rPosX, rPosY, nTab, rpCell );
+		if ( !rpCell || rpCell->GetCellType() == CELLTYPE_NOTE )
+		{
+			if ( rPosX <= 0 )
+				return FALSE;							// alles leer bis links
+			else
+				--rPosX;								// weitersuchen
+		}
+                else if ( rpCell->GetCellType() == CELLTYPE_EDIT)
+                    bFound = TRUE;
+                else if (rpCell->GetCellType() == CELLTYPE_FORMULA &&
+                  static_cast<ScFormulaCell*>(rpCell)->IsHyperLinkCell())
+                    bFound = TRUE;
+	    else
+			return FALSE;								// andere Zelle
+	}
+	while ( !bFound );
+
+	return bFound;
+}
+
 // ---------------------------------------------------------------------------
 //	WB_DIALOGCONTROL noetig fuer UNO-Controls
 ScGridWindow::ScGridWindow( Window* pParent, ScViewData* pData, ScSplitPos eWhichPos )
@@ -1431,6 +1463,7 @@
 	SCCOL	nOldColFBox	  = bWasFilterBox ? pFilterBox->GetCol() : 0;
 	SCROW  nOldRowFBox	  = bWasFilterBox ? pFilterBox->GetRow() : 0;
 #endif
+#include "cellsuno.hxx" 
 
 	ClickExtern();	// loescht FilterBox, wenn vorhanden
 
@@ -2104,6 +2137,26 @@
 		{
 			nMouseStatus = SC_GM_NONE;				// keinen Doppelklick anfangen
 			ScGlobal::OpenURL( aUrl, aTarget );
+			
+			// fire worksheet_followhyperlink event
+			Point aPos = rMEvt.GetPosPixel();
+	        SCsCOL nPosX;
+    	    SCsROW nPosY;
+        	SCTAB nTab = pViewData->GetTabNo();
+        	pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
+			ScBaseCell* pCell = NULL;
+
+			BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+			if( bFound )
+			{
+				ScAddress aCellPos( nPosX, nPosY, nTab );
+				ScCellObj* pObj = new ScCellObj( pViewData->GetDocShell(), aCellPos );
+				uno::Sequence< uno::Any > aArgs(1);
+				aArgs[0] = uno::makeAny(uno::Reference<uno::XInterface>(static_cast<cppu::OWeakObject*>(pObj)));
+                uno::Reference< document::XVbaEventsHelper > xVbaEventsHelper ( pViewData->GetDocument()->GetVbaEventsHelper(), uno::UNO_QUERY );
+                if( xVbaEventsHelper.is() )
+			        xVbaEventsHelper->ProcessCompatibleVbaEvent( VBAEVENT_WORKSHEET_FOLLOWHYPERLINK, aArgs );
+			}
 			return;
 		}
 	}
@@ -2425,7 +2478,7 @@
 			                lcl_InitMouseEvent( aEvent, *rNEvt.GetMouseEvent() );
 	                        if ( rNEvt.GetWindow() )
 		                        aEvent.Source = rNEvt.GetWindow()->GetComponentInterface();
-                            if ( nType == EVENT_MOUSEBUTTONDOWN)
+                            if ( nType == EVENT_MOUSEBUTTONDOWN )
 					            pImp->MousePressed( aEvent );
                             else
                                 pImp->MouseReleased( aEvent );
@@ -4784,26 +4837,9 @@
 	ScDocument* pDoc = pDocSh->GetDocument();
 	ScBaseCell* pCell = NULL;
 
-	BOOL bFound = FALSE;
-	do
-	{
-		pDoc->GetCell( nPosX, nPosY, nTab, pCell );
-		if ( !pCell || pCell->GetCellType() == CELLTYPE_NOTE )
-		{
-			if ( nPosX <= 0 )
-				return FALSE;							// alles leer bis links
-			else
-				--nPosX;								// weitersuchen
-		}
-                else if ( pCell->GetCellType() == CELLTYPE_EDIT)
-                    bFound = TRUE;
-                else if (pCell->GetCellType() == CELLTYPE_FORMULA &&
-                  static_cast<ScFormulaCell*>(pCell)->IsHyperLinkCell())
-                    bFound = TRUE;
-	    else
-			return FALSE;								// andere Zelle
-	}
-	while ( !bFound );
+	BOOL bFound = lcl_GetHyperlinkCell( pDoc, nPosX, nPosY, nTab, pCell );
+	if( !bFound )
+		return FALSE;
 
 	ScHideTextCursor aHideCursor( pViewData, eWhich );	// before GetEditArea (MapMode is changed)
 
Index: sc/uiconfig/scalc/menubar/menubar.xml
===================================================================
--- sc/uiconfig/scalc/menubar/menubar.xml	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/uiconfig/scalc/menubar/menubar.xml	(.../cws/vbasupportdev300)	(revision 277097)
@@ -391,6 +391,7 @@
 					<menu:menuitem menu:id=".uno:DataFilterHideAutoFilter"/>
 				</menu:menupopup>
 			</menu:menu>
+			<menu:menuitem menu:id=".uno:DataForm"/>
 			<menu:menuitem menu:id=".uno:DataSubTotals"/>
 			<menu:menuitem menu:id=".uno:Validation"/>
 			<menu:menuseparator/>
Index: sc/inc/scabstdlg.hxx
===================================================================
--- sc/inc/scabstdlg.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/scabstdlg.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -42,6 +42,8 @@
 #include "global.hxx"
 #include "pivot.hxx"
 
+#include <tabvwsh.hxx>
+
 class ScAsciiOptions;
 class ScAutoFormat;
 class ScAutoFormatData;
@@ -111,6 +113,12 @@
 	virtual DelCellCmd GetDelCellCmd() const = 0;
 };
 
+//for dataform
+class AbstractScDataFormDlg : public VclAbstractDialog  //add for ScDeleteCellDlg
+{
+
+};
+
 class AbstractScDeleteContentsDlg: public VclAbstractDialog  //add for ScDeleteContentsDlg
 {
 public:
@@ -293,7 +301,7 @@
 class ScAbstractDialogFactory
 {
 public:
-	static ScAbstractDialogFactory* 	Create();
+	SC_DLLPUBLIC static ScAbstractDialogFactory* 	Create();
 
 	virtual 	AbstractScImportAsciiDlg * CreateScImportAsciiDlg( Window* pParent, String aDatName, //add for ScImportAsciiDlg
 																	SvStream* pInStream, int nId,
@@ -325,6 +333,9 @@
 
 	virtual AbstractScDeleteCellDlg * CreateScDeleteCellDlg( Window* pParent, int nId, BOOL bDisallowCellMove = FALSE ) = 0 ; //add for ScDeleteCellDlg
 
+	//for dataform
+	virtual AbstractScDataFormDlg * CreateScDataFormDlg( Window* pParent, int nId, ScTabViewShell*      pTabViewShell ) = 0 ; //add for ScDataFormDlg
+
 	virtual AbstractScDeleteContentsDlg * CreateScDeleteContentsDlg(Window* pParent,int nId, //add for ScDeleteContentsDlg
 																 USHORT  nCheckDefaults = 0 ) = 0;
 	virtual AbstractScFillSeriesDlg * CreateScFillSeriesDlg( Window*		pParent, //add for ScFillSeriesDlg
Index: sc/inc/sc.hrc
===================================================================
--- sc/inc/sc.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/sc.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -593,11 +593,9 @@
 // #i59082# assign macro to shape
 #define SID_ASSIGNMACRO                 (SC_VIEW_START + 95)
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
 // #i66550# hyperlinks in shapes
 #define SID_DRAW_HLINK_EDIT             (SC_VIEW_START + 96)
 #define SID_DRAW_HLINK_DELETE           (SC_VIEW_START + 97)
-#endif
 
 // "Zoom / Synchronize sheets" in options dialog
 #define SID_SC_OPT_SYNCZOOM             (SC_VIEW_START + 98)
@@ -1650,6 +1648,13 @@
 #define MID_3   3
 #define MID_4   4
 
+#define SC_OOO_BUILD_START          (SC_DIALOGS_END)
+
+// Data Form
+#define SID_DATAFORM_NEW            (SC_OOO_BUILD_START + 1) // message
+#define SID_DATA_FORM               (SC_OOO_BUILD_START + 2) // menu (in Data menu)
+#define RID_SCDLG_DATAFORM          (SC_OOO_BUILD_START + 3) // dialog
+
 #endif
 
 
Index: sc/inc/table.hxx
===================================================================
--- sc/inc/table.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/table.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -89,6 +89,7 @@
 	ScColumn		aCol[MAXCOLCOUNT];
 
 	String			aName;
+	String			aCodeName;
 	String			aComment;
 	BOOL			bScenario;
 	BOOL			bLayoutRTL;
@@ -229,6 +230,9 @@
 	void		GetName( String& rName ) const;
 	void		SetName( const String& rNewName );
 
+	void		GetCodeName( String& rName ) const {  rName = aCodeName; }
+	void		SetCodeName( const String& rNewName ) { aCodeName = rNewName; }
+
     const String&   GetUpperName() const;
 
 	const String&	GetPageStyle() const					{ return aPageStyle; }
Index: sc/inc/addruno.hxx
===================================================================
--- sc/inc/addruno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/addruno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -50,7 +50,7 @@
     sal_Int32               nRefSheet;
     sal_Bool                bIsRange;
 
-    sal_Bool                ParseUIString( const String& rUIString );
+    sal_Bool                ParseUIString( const String& rUIString, ::formula::FormulaGrammar::AddressConvention eConv = ::formula::FormulaGrammar::CONV_OOO );
 
 public:
 
Index: sc/inc/cell.hxx
===================================================================
--- sc/inc/cell.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/cell.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -358,7 +358,7 @@
 								const formula::FormulaGrammar::Grammar = formula::FormulaGrammar::GRAM_DEFAULT ) const;
 
 	void			SetDirty();
-	inline void		SetDirtyVar() { bDirty = TRUE; }
+	void			SetDirtyVar();
     // If setting entire document dirty after load, no broadcasts but still append to FormulaTree.
     void            SetDirtyAfterLoad();
 	inline void		ResetTableOpDirtyVar() { bTableOpDirty = FALSE; }
Index: sc/inc/address.hxx
===================================================================
--- sc/inc/address.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/address.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -230,6 +230,9 @@
 #define SCA_VALID_ROW       0x0100
 #define SCA_VALID_COL       0x0200
 #define SCA_VALID_TAB       0x0400
+// SCA_BITS is a convience for 
+// (SCA_VALID_TAB | SCA_VALID_COL | SCA_VALID_ROW | SCA_TAB_3D | SCA_TAB_ABSOLUTE | SCA_ROW_ABSOLUTE | SCA_COL_ABSOLUTE)
+#define SCA_BITS            0x070F
 // somewhat cheesy kludge to force the display of the document name even for
 // local references.  Requires TAB_3D to be valid
 #define SCA_FORCE_DOC       0x0800
Index: sc/inc/global.hxx
===================================================================
--- sc/inc/global.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/global.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -227,6 +227,7 @@
 const USHORT IDF_STYLES     = 0x0040;   /// Cell styles.
 const USHORT IDF_OBJECTS    = 0x0080;   /// Drawing objects.
 const USHORT IDF_EDITATTR   = 0x0100;   /// Rich-text attributes.
+const USHORT IDF_SPECIAL_BOOLEAN = 0x1000;
 const USHORT IDF_ATTRIB     = IDF_HARDATTR | IDF_STYLES;
 const USHORT IDF_CONTENTS   = IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_NOTE | IDF_FORMULA;
 const USHORT IDF_ALL        = IDF_CONTENTS | IDF_ATTRIB | IDF_OBJECTS;
Index: sc/inc/docuno.hxx
===================================================================
--- sc/inc/docuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/docuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -56,6 +56,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/sheet/XCellRangesAccess.hpp>
 #include <com/sun/star/util/XChangesNotifier.hpp>
+#include <com/sun/star/document/XDocumentEventCompatibleHelper.hpp>
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
@@ -90,6 +91,7 @@
 					public com::sun::star::view::XRenderable,
 					public com::sun::star::document::XLinkTargetSupplier,
 					public com::sun::star::beans::XPropertySet,
+                    public com::sun::star::document::XDocumentEventCompatibleHelper,
 					public SvxFmMSFactory,	// derived from XMultiServiceFactory
                     public com::sun::star::lang::XServiceInfo,
                     public ::com::sun::star::util::XChangesNotifier
@@ -319,6 +321,8 @@
     virtual void SAL_CALL removeChangesListener( const ::com::sun::star::uno::Reference<
                                     ::com::sun::star::util::XChangesListener >& aListener )
                                 throw (::com::sun::star::uno::RuntimeException);
+                            // XVbaEventHelper
+    virtual sal_Bool SAL_CALL processCompatibleEvent( sal_Int16 nEventId ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 
Index: sc/inc/servuno.hxx
===================================================================
--- sc/inc/servuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/servuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -93,8 +93,9 @@
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
-
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_VBACODENAMEPROVIDER   41
+#define SC_SERVICE_COUNT        42
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
Index: sc/inc/scextopt.hxx
===================================================================
--- sc/inc/scextopt.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/scextopt.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -124,6 +124,8 @@
     const String&       GetCodeName( size_t nIdx ) const;
     /** Appends a codename for a sheet. */
     void                AppendCodeName( const String& rCodeName );
+    void                SetCodeName( const String& rCodeName, size_t nIdx );
+    void                DeleteCodeName( size_t nIdx );
 
 private:
     ::std::auto_ptr< ScExtDocOptionsImpl > mxImpl;
Index: sc/inc/viewuno.hxx
===================================================================
--- sc/inc/viewuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/viewuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -198,6 +198,7 @@
 	XMouseClickHandlerArr_Impl              aMouseClickHandlers;
 	XActivationEventListenerArr_Impl        aActivationListeners;
 	sal_Bool								bDrawSelModeSet;
+    sal_Bool                                bFilteredRangeSelection;
 
 	ScViewPaneObj*			GetObjectByIndex_Impl(USHORT nIndex) const;
     INT16                   GetZoom(void) const;
Index: sc/inc/document.hxx
===================================================================
--- sc/inc/document.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/document.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,6 +96,7 @@
 class ScExtDocOptions;
 class ScExternalRefManager;
 class ScFormulaCell;
+class ScMacroManager;
 class ScMarkData;
 class ScOutlineTable;
 class ScPatternAttr;
@@ -155,6 +156,9 @@
     }
 } } }
 
+namespace com { namespace sun { namespace star { namespace document {
+    class XVbaEventsHelper;
+} } } }
 #include <svtools/zforlist.hxx>
 /*
 #ifdef _ZFORLIST_DECLARE_TABLE
@@ -285,12 +289,15 @@
     ::std::auto_ptr<ScClipParam>     mpClipParam;
 
     ::std::auto_ptr<ScExternalRefManager> pExternalRefMgr;
+    ::std::auto_ptr<ScMacroManager> mpMacroMgr;
 
+
     // mutable for lazy construction
     mutable ::std::auto_ptr< ScFormulaParserPool >
                         mxFormulaParserPool;            /// Pool for all external formula parsers used by this document.
 
 	String              aDocName;                       // opt: Dokumentname
+	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
 	ScRangePairListRef	xRowNameRanges;
 
@@ -317,6 +324,8 @@
 
 	Timer				aTrackTimer;
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > mxVbaEventsHelper;
+
 public:
     ScTabOpList         aTableOpList;		            // list of ScInterpreterTableOpParams currently in use
     ScInterpreterTableOpParams  aLastTableOpParams;     // remember last params
@@ -418,6 +427,9 @@
 
 	inline BOOL 		RowHidden( SCROW nRow, SCTAB nTab );		// FillInfo
 
+	// for worksheet calculate event
+	::std::vector< SCTAB > maTabs;
+
 public:
 	SC_DLLPUBLIC ULONG			GetCellCount() const;		// alle Zellen
 	ULONG			GetWeightedCount() const;	// Formeln und Edit staerker gewichtet
@@ -435,6 +447,8 @@
 
 	SC_DLLPUBLIC const String& 	GetName() const { return aDocName; }
 	void			SetName( const String& r ) { aDocName = r; }
+	const String& 	GetCodeName() const { return aDocCodeName; }
+	void			SetCodeName( const String& r ) { aDocCodeName = r; }
 
 	void			GetDocStat( ScDocStat& rDocStat );
 
@@ -520,6 +534,8 @@
 
 	SC_DLLPUBLIC BOOL			HasTable( SCTAB nTab ) const;
 	SC_DLLPUBLIC BOOL			GetName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			GetCodeName( SCTAB nTab, String& rName ) const;
+	SC_DLLPUBLIC BOOL			SetCodeName( SCTAB nTab, String& rName );
 	SC_DLLPUBLIC BOOL			GetTable( const String& rName, SCTAB& rTab ) const;
 	SC_DLLPUBLIC inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
@@ -862,6 +878,10 @@
 	BOOL			IsForcedFormulaPending() const { return bForcedFormulaPending; }
 					// if CalcFormulaTree() is currently running
 	BOOL			IsCalculatingFormulaTree() { return bCalculatingFormulaTree; }
+	
+					// for worksheet calculate event
+	BOOL			FireCalculateEvent( SCTAB nTab );
+	void			AddCalculateTable( SCTAB nTab );
 
 	USHORT			GetErrCode( const ScAddress& ) const;
 
@@ -908,7 +928,7 @@
 							   SCROW nStartRow, SCSIZE nSize,
                                ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL,
                                const ScMarkData* pTabMark = NULL );
-	void			DeleteRow( const ScRange& rRange,
+	SC_DLLPUBLIC void	DeleteRow( const ScRange& rRange,
 							   ScDocument* pRefUndoDoc = NULL, BOOL* pUndoOutline = NULL );
 	BOOL			InsertCol( SCROW nStartRow, SCTAB nStartTab,
 							   SCROW nEndRow,   SCTAB nEndTab,
@@ -1493,6 +1513,7 @@
 	SC_DLLPUBLIC ScLkUpdMode		GetLinkMode() const				{ return eLinkMode ;}
 	void			SetLinkMode( ScLkUpdMode nSet )	{ 	eLinkMode  = nSet;}
 
+    SC_DLLPUBLIC ScMacroManager* GetMacroManager();
 
 private:
     ScDocument(const ScDocument& r); // disabled with no definition
@@ -1702,6 +1723,8 @@
 	void GetSortParam( ScSortParam& rParam, SCTAB nTab );
 	void SetSortParam( ScSortParam& rParam, SCTAB nTab );
 
+    com::sun::star::uno::Reference< com::sun::star::document::XVbaEventsHelper > GetVbaEventsHelper();
+
     /** Should only be GRAM_PODF or GRAM_ODFF. */
     void                SetStorageGrammar( formula::FormulaGrammar::Grammar eGrammar );
     formula::FormulaGrammar::Grammar  GetStorageGrammar() const
Index: sc/inc/globstr.hrc
===================================================================
--- sc/inc/globstr.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/globstr.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -573,7 +573,23 @@
 #define STR_UNDO_SET_TAB_BG_COLOR       435
 #define STR_UNDO_SET_MULTI_TAB_BG_COLOR 436
 
-#define STR_COUNT                   437
+#define STR_SHAPE_AUTOSHAPE         437
+#define STR_SHAPE_RECTANGLE         438
+#define STR_SHAPE_LINE              439
+#define STR_SHAPE_OVAL              440
+#define STR_SHAPE_TEXTBOX           441
+                                       
+#define STR_FORM_BUTTON             442
+#define STR_FORM_CHECKBOX           443
+#define STR_FORM_OPTIONBUTTON       444
+#define STR_FORM_LABEL              445
+#define STR_FORM_LISTBOX            446
+#define STR_FORM_GROUPBOX           447
+#define STR_FORM_DROPDOWN           448
+#define STR_FORM_SPINNER            449
+#define STR_FORM_SCROLLBAR          450
+                                       
+#define STR_COUNT                   451
 
 #endif
 
Index: sc/inc/cellsuno.hxx
===================================================================
--- sc/inc/cellsuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/cellsuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -152,8 +152,10 @@
 namespace ooo
 {
     namespace vba {
+        namespace excel {
 	class ScVbaCellRangeAccess;  // Vba Helper class
     }
+    }
 }
 
 class SC_DLLPUBLIC ScCellRangesBase : public com::sun::star::beans::XPropertySet,
@@ -175,7 +177,7 @@
 {
 	friend class ScTabViewObj;		// fuer select()
 	friend class ScTableSheetObj;	// fuer createCursorByRange()
- 	friend class ooo::vba::ScVbaCellRangeAccess;
+ 	friend class ooo::vba::excel::ScVbaCellRangeAccess;
 
 private:
 	const SfxItemPropertySet* pPropSet;
Index: sc/inc/unonames.hxx
===================================================================
--- sc/inc/unonames.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/unonames.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -186,6 +186,8 @@
 #define SC_UNONAME_ANCHOR           "Anchor"
 #define SC_UNONAME_HORIPOS          "HoriOrientPosition"
 #define SC_UNONAME_VERTPOS          "VertOrientPosition"
+//     #i66550 HLINK_FOR_SHAPES
+#define SC_UNONAME_HYPERLINK        "Hyperlink" 
 
 //	other cell properties
 #define SC_UNONAME_CHCOLHDR			"ChartColumnAsLabel"
@@ -529,8 +531,9 @@
 #define SC_UNO_ZOOMTYPE             "ZoomType"
 #define SC_UNO_ZOOMVALUE            "ZoomValue"
 #define SC_UNO_UPDTEMPL             "UpdateFromTemplate"
 #define SC_UNO_TABCOLOR             "TabColor"
 
+#define SC_UNO_FILTERED_RANGE_SELECTION       "FilteredRangeSelection"
 /*Stampit enable/disable print cancel */
 #define SC_UNO_ALLOWPRINTJOBCANCEL  "AllowPrintJobCancel"
 
@@ -595,6 +598,7 @@
 #define SC_UNONAME_ADDRESS          "Address"
 #define SC_UNONAME_UIREPR           "UserInterfaceRepresentation"
 #define SC_UNONAME_PERSREPR         "PersistentRepresentation"
+#define SC_UNONAME_XL_A1_REPR       "XL_A1_Representation"
 #define SC_UNONAME_REFSHEET         "ReferenceSheet"
 
 // --> PB 2004-08-23 #i33095# Security Options
Index: sc/inc/userdat.hxx
===================================================================
--- sc/inc/userdat.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/userdat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -102,16 +102,12 @@
     void            SetMacro( const rtl::OUString& rMacro ) { maMacro = rMacro; }
     const rtl::OUString& GetMacro() const { return maMacro; }
 
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     void            SetHlink( const rtl::OUString& rHlink ) { maHlink = rHlink; }
     const rtl::OUString& GetHlink() const { return maHlink; }
-#endif
 
 private:
     rtl::OUString   maMacro;
-#ifdef ISSUE66550_HLINK_FOR_SHAPES
     rtl::OUString   maHlink;
-#endif
 };
 
 //-------------------------------------------------------------------------
Index: sc/inc/sc.hrc.patched
===================================================================
--- sc/inc/sc.hrc.patched	(.../tags/DEV300_m58)	(revision 0)
+++ sc/inc/sc.hrc.patched	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,1660 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: sc.hrc,v $
+ * $Revision: 1.63 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_SC_HRC
+#define SC_SC_HRC
+
+#ifndef _SFX_HRC
+#include <sfx2/sfx.hrc>      // ->#include <solar.hrc>
+#endif
+
+#ifndef _SVX_DIALOGS_HRC
+#include <svx/dialogs.hrc>  // ->Svx-IDs
+#endif
+
+#define VAR_ARGS				30 // variable Parameter in scfuncs.src
+
+#define RID_HANDLEBITMAP		10005
+
+// Bereiche ------------------------------------------------------------------
+
+#define SC_VIEW_START			(SID_SC_START)
+#define SC_VIEW_END				(SID_SC_START + 99)
+#define SC_MESSAGE_START		(SID_SC_START + 100)
+#define SC_MESSAGE_END			(SID_SC_START + 199)
+#define SC_FUNCTION_START 		(SID_SC_START + 200)
+#define SC_FUNCTION_END			(SID_SC_START + 299)
+#define SC_PARAM_START			(SID_SC_START + 300)
+#define SC_PARAM_END			(SID_SC_START + 399)
+
+//	kompatibel zu frueher bleiben:
+#define SC_RESOURCE_START		(RID_APP_START+5000)
+#define SC_RESOURCE_END			(RID_APP_END)
+
+// ---------------------------------------------------------------------------
+// Hilfe IDs -----------------------------------------------------------------
+//	Calc hat einen Bereich von 2000 IDs
+//	Die Funktionen brauchen 11*90 = 990 IDs
+
+#define HID_SC_FUNC_START		(HID_SC_START + 0)
+#define HID_INSWIN_START		(HID_SC_START + 1000)
+#define HID_SC_SHEET_START		(HID_SC_START + 1010)
+#define HID_SC_SHELL_START		(HID_SC_START + 1030)
+#define HID_SC_WIN_START		(HID_SC_START + 1050)
+#define HID_SC_CONTROL_START	(HID_SC_START + 1070)
+#define HID_SC_DLG_START		(HID_SC_START + 1100)
+#define HID_SC_TOOLBOX_START	(HID_SC_START + 1170)
+#define HID_SC_MENU_START		(HID_SC_START + 1180)
+#define HID_SC_OTHER_START		(HID_SC_START + 1230)
+#define HID_SC_AAI_FUNCS_START	(HID_SC_START + 1300)		// Analysis Addin Functions
+#define HID_SC_DAI_FUNCS_START  (HID_SC_START + 1420)       // DateFunc Addin Functions
+
+// ---------------------------------------------------------------------------
+
+#define HID_INSWIN_POS			(HID_INSWIN_START + 0 )
+#define HID_INSWIN_CALC			(HID_INSWIN_START + 1 )
+#define HID_INSWIN_CANCEL		(HID_INSWIN_START + 2 )
+#define HID_INSWIN_OK			(HID_INSWIN_START + 3 )
+#define HID_INSWIN_SUMME		(HID_INSWIN_START + 4 )
+#define HID_INSWIN_FUNC			(HID_INSWIN_START + 5 )
+#define HID_INSWIN_INPUT		(HID_INSWIN_START + 6 )
+
+// Hilfe IDs fuer Vorlagen ---------------------------------------------------
+#define HID_SC_SHEET_CELL_STD	(HID_SC_SHEET_START +0 )
+#define HID_SC_SHEET_CELL_ERG	(HID_SC_SHEET_START +1 )
+#define HID_SC_SHEET_CELL_ERG1	(HID_SC_SHEET_START +2 )
+#define HID_SC_SHEET_CELL_UEB	(HID_SC_SHEET_START +3 )
+#define HID_SC_SHEET_CELL_UEB1	(HID_SC_SHEET_START +4 )
+#define HID_SC_SHEET_PAGE_STD	(HID_SC_SHEET_START +10 )
+#define HID_SC_SHEET_PAGE_REP	(HID_SC_SHEET_START +11 )
+
+// Hilfe IDs fuer Shells (Helferlein) (max.20) -------------------------------
+#define HID_SCSHELL_APP			(HID_SC_SHELL_START +0 )
+#define HID_SCSHELL_DOCSH		(HID_SC_SHELL_START +1 )
+#define HID_SCSHELL_DRAWSH		(HID_SC_SHELL_START +2 )
+#define HID_SCSHELL_DRTXTOB		(HID_SC_SHELL_START +3 )
+#define HID_SCSHELL_PIVOTSH		(HID_SC_SHELL_START +4 )
+#define HID_SCSHELL_PREVWSH		(HID_SC_SHELL_START +5 )
+#define HID_SCSHELL_TABVWSH		(HID_SC_SHELL_START +6 )
+#define HID_SCSHELL_AUDIT		(HID_SC_SHELL_START +7 )
+#define HID_SCSHELL_DRAWFORMSH	(HID_SC_SHELL_START +8 )
+#define HID_SCSHELL_CELLSH		(HID_SC_SHELL_START +9 )
+#define HID_SCSHELL_FORMATSH	(HID_SC_SHELL_START +10)
+#define HID_SCSHELL_OLEOBEJCTSH	(HID_SC_SHELL_START +11)
+#define HID_SCSHELL_CHARTSH		(HID_SC_SHELL_START +12)
+#define HID_SCSHELL_GRAPHIC		(HID_SC_SHELL_START +13)
+#define HID_SCSHELL_PAGEBREAK	(HID_SC_SHELL_START +14)
+#define HID_SCSHELL_MEDIA		(HID_SC_SHELL_START +15)
+
+// Hilfe IDs fuer Dokumentfenster --------------------------------------------
+#define HID_SC_WIN_GRIDWIN		( HID_SC_WIN_START )
+#define HID_SC_WIN_PREVIEW		( HID_SC_WIN_START + 1 )
+
+// Hilfe IDs fuer einzelne Controls (max.30) ---------------------------------
+//	Kopf/Fusszeilen Editfenster: Header/Footer links/rechts links/mitte/rechts
+#define HID_SC_HF_HLL			( HID_SC_CONTROL_START + 0 )
+#define HID_SC_HF_HLC			( HID_SC_CONTROL_START + 1 )
+#define HID_SC_HF_HLR			( HID_SC_CONTROL_START + 2 )
+#define HID_SC_HF_HRL			( HID_SC_CONTROL_START + 3 )
+#define HID_SC_HF_HRC			( HID_SC_CONTROL_START + 4 )
+#define HID_SC_HF_HRR			( HID_SC_CONTROL_START + 5 )
+#define HID_SC_HF_FLL			( HID_SC_CONTROL_START + 6 )
+#define HID_SC_HF_FLC			( HID_SC_CONTROL_START + 7 )
+#define HID_SC_HF_FLR			( HID_SC_CONTROL_START + 8 )
+#define HID_SC_HF_FRL			( HID_SC_CONTROL_START + 9 )
+#define HID_SC_HF_FRC			( HID_SC_CONTROL_START + 10 )
+#define HID_SC_HF_FRR			( HID_SC_CONTROL_START + 11 )
+//	"Spalten" in Teilergebnissen: Gruppe 1/2/3 - nicht mehr!
+//#define HID_SC_SUBT_COLS_1		( HID_SC_CONTROL_START + 12 )
+//#define HID_SC_SUBT_COLS_2		( HID_SC_CONTROL_START + 13 )
+//#define HID_SC_SUBT_COLS_3		( HID_SC_CONTROL_START + 14 )
+//	Eintraege im Navigator
+#define HID_SC_NAVIPI_ENTRIES	( HID_SC_CONTROL_START + 15 )
+#define HID_SC_NAVIPI_ROW		( HID_SC_CONTROL_START + 16 )
+#define HID_SC_NAVIPI_COL		( HID_SC_CONTROL_START + 17 )
+#define HID_SC_NAVIPI_DOC		( HID_SC_CONTROL_START + 18 )
+#define HID_SC_NAVIPI_DATA		( HID_SC_CONTROL_START + 19 )
+#define HID_SC_NAVIPI_UP		( HID_SC_CONTROL_START + 20 )
+#define HID_SC_NAVIPI_DOWN		( HID_SC_CONTROL_START + 21 )
+#define HID_SC_NAVIPI_ZOOM		( HID_SC_CONTROL_START + 22 )
+#define HID_SC_NAVIPI_ROOT		( HID_SC_CONTROL_START + 23 )
+#define HID_SC_NAVIPI_SCEN		( HID_SC_CONTROL_START + 24 )
+#define HID_SC_NAVIPI_DROP		( HID_SC_CONTROL_START + 25 )
+//	Teilergebnisse
+#define HID_SC_SUBT_GROUP		( HID_SC_CONTROL_START + 26 )
+#define HID_SC_SUBT_COLS		( HID_SC_CONTROL_START + 27 )
+#define HID_SC_SUBT_FUNC		( HID_SC_CONTROL_START + 28 )
+//
+#define HID_SC_NAVIPI_TOOLBOX	( HID_SC_CONTROL_START + 29 )
+//	Bereich ist voll!
+
+// Hilfe IDs fuer Dialoge / Pages (max.70) -----------------------------------
+#define HID_SC_AUTOFORMAT		(HID_SC_DLG_START )
+#define HID_SC_PIVOTFILTER		(HID_SC_DLG_START +1 )
+#define HID_SC_INPORTOPT		(HID_SC_DLG_START +2 )
+#define HID_SC_PIVOTSUBT		(HID_SC_DLG_START +3 )
+#define HID_SC_FORM_ARGS		(HID_SC_DLG_START +4 )
+#define HID_SCPAGE_SORT_FIELDS	(HID_SC_DLG_START +5 )
+#define HID_SCPAGE_SORT_OPTIONS	(HID_SC_DLG_START +6 )
+#define HID_SCPAGE_SUBT_OPTIONS	(HID_SC_DLG_START +7 )
+#define HID_SCPAGE_SUBT_GROUP	(HID_SC_DLG_START +8 )
+#define HID_SCPAGE_PROTECTION	(HID_SC_DLG_START +9 )
+#define HID_SCPAGE_VIEW			(HID_SC_DLG_START +10 )
+#define HID_SCPAGE_CALC			(HID_SC_DLG_START +11 )
+#define HID_SCPAGE_USERLISTS	(HID_SC_DLG_START +12 )
+#define HID_SCPAGE_HFEDIT		(HID_SC_DLG_START +13 )
+#define HID_SCPAGE_AREAS		(HID_SC_DLG_START +14 )
+#define HID_SCPAGE_TABLE		(HID_SC_DLG_START +15 )
+#define HID_SCPAGE_PRINT		(HID_SC_DLG_START +16 )
+
+#define HID_SCPAGE_SUBT_GROUP1	(HID_SC_DLG_START +17 )
+#define HID_SCPAGE_SUBT_GROUP2	(HID_SC_DLG_START +18 )
+#define HID_SCPAGE_SUBT_GROUP3	(HID_SC_DLG_START +19 )
+
+#define HID_SCPAGE_HFED_HL		(HID_SC_DLG_START +20 )
+#define HID_SCPAGE_HFED_HR		(HID_SC_DLG_START +21 )
+#define HID_SCPAGE_HFED_FL		(HID_SC_DLG_START +22 )
+#define HID_SCPAGE_HFED_FR		(HID_SC_DLG_START +23 )
+
+#define HID_SCPAGE_CONTENT		(HID_SC_DLG_START +24 )
+#define HID_SCPAGE_LAYOUT		(HID_SC_DLG_START +25 )
+#define HID_SCPAGE_INPUT		(HID_SC_DLG_START +26 )
+
+#define HID_SC_NAVIGATOR		(HID_SC_DLG_START +27 )
+
+#define HID_SC_MTRIN_VAL		(HID_SC_DLG_START +28 )
+#define HID_SC_MTRIN_DEF		(HID_SC_DLG_START +29 )
+#define HID_SC_SELENTRY_LIST	(HID_SC_DLG_START +30 )
+#define HID_SC_GROUP_COLS		(HID_SC_DLG_START +31 )
+#define HID_SC_GROUP_ROWS		(HID_SC_DLG_START +32 )
+
+#define HID_SC_HF_TEXT			(HID_SC_DLG_START +33 )
+#define HID_SC_HF_FILE			(HID_SC_DLG_START +34 )
+#define HID_SC_HF_TABLE			(HID_SC_DLG_START +35 )
+#define HID_SC_HF_PAGE			(HID_SC_DLG_START +36 )
+#define HID_SC_HF_PAGES			(HID_SC_DLG_START +37 )
+#define HID_SC_HF_DATE			(HID_SC_DLG_START +38 )
+#define HID_SC_HF_TIME			(HID_SC_DLG_START +39 )
+
+#define HID_SC_HEADER_EDIT		(HID_SC_DLG_START +40 )
+#define HID_SC_FOOTER_EDIT		(HID_SC_DLG_START +41 )
+
+#define HID_SC_SCENWIN_TOP		(HID_SC_DLG_START +42 )
+#define HID_SC_SCENWIN_BOTTOM	(HID_SC_DLG_START +43 )
+
+#define HID_SC_INPUTWIN			(HID_SC_DLG_START +44 )
+
+#define HID_SC_RENAME_NAME		(HID_SC_DLG_START +45 )
+#define HID_SC_APPEND_NAME		(HID_SC_DLG_START +46 )
+
+//	Funktionsautopilot: nur als Unique-IDs
+#define HID_SC_FAP_PAGE			(HID_SC_DLG_START +47 )
+#define HID_SC_FAP_EDIT1		(HID_SC_DLG_START +48 )
+#define HID_SC_FAP_EDIT2		(HID_SC_DLG_START +49 )
+#define HID_SC_FAP_EDIT3		(HID_SC_DLG_START +50 )
+#define HID_SC_FAP_EDIT4		(HID_SC_DLG_START +51 )
+
+#define HID_SC_ADD_AUTOFMT		(HID_SC_DLG_START +52 )
+#define HID_SC_AUTOFMT_NAME		(HID_SC_DLG_START +53 )
+
+#define HID_SC_DROPMODE_URL		(HID_SC_DLG_START +54 )
+#define HID_SC_DROPMODE_LINK	(HID_SC_DLG_START +55 )
+#define HID_SC_DROPMODE_COPY	(HID_SC_DLG_START +56 )
+
+#define HID_SC_FAP_STRUCT		(HID_SC_DLG_START +57 )
+#define HID_SC_ASCII_TABCTR		(HID_SC_DLG_START +58 )
+
+#define HID_SC_SCENARIO_DELETE	(HID_SC_DLG_START +59 )
+#define HID_SC_SCENARIO_EDIT	(HID_SC_DLG_START +60 )
+
+#define HID_SCDLG_FORMULA		(HID_SC_DLG_START +61 )
+#define HID_SCDLG_CONDFORMAT	(HID_SC_DLG_START +62 )
+#define HID_COLROWNAMERANGES	(HID_SC_DLG_START +63 )
+
+#define HID_FUNCTION_BOX		(HID_SC_DLG_START +64 )
+#define HID_SCPAGE_OPREDLINE	(HID_SC_DLG_START +65 )
+#define HID_SC_REDLIN_CTR		(HID_SC_DLG_START +66 )
+
+//Kopf/FusszeilenDlg: Contextmenue fuer Dateiname
+#define HID_FCOMMAND_TITEL		(HID_SC_DLG_START +67 )
+#define HID_FCOMMAND_FILENAME	(HID_SC_DLG_START +68 )
+#define HID_FCOMMAND_PATH		(HID_SC_DLG_START +69 )
+
+
+// Hilfe IDs fuer Objekt- und Werkzeugleisten (max.10) -----------------------
+
+#define HID_SC_TOOLBOX_TOOLS	( HID_SC_TOOLBOX_START )
+#define HID_SC_TOOLBOX_TABLE	( HID_SC_TOOLBOX_START + 1 )
+#define HID_SC_TOOLBOX_DRAW		( HID_SC_TOOLBOX_START + 2 )
+#define HID_SC_TOOLBOX_DRTEXT	( HID_SC_TOOLBOX_START + 3 )
+#define HID_SC_TOOLBOX_PREVIEW	( HID_SC_TOOLBOX_START + 4 )
+
+//	wrong group - HID_SC_DLG_START is full
+#define HID_SC_RENAME_AUTOFMT	( HID_SC_TOOLBOX_START + 5 )
+#define HID_SC_REN_AFMT_NAME	( HID_SC_TOOLBOX_START + 6 )
+
+#define HID_SC_TOOLBOX_GRAPHIC	( HID_SC_TOOLBOX_START + 7 )
+
+#define HID_CHG_PROTECT         ( HID_SC_TOOLBOX_START + 8 )
+
+#define HID_SC_RENAME_OBJECT	( HID_SC_TOOLBOX_START + 9 )
+
+// Hilfe IDs fuer Submenus (max.50) ------------------------------------------
+#define HID_SCMENU_EDIT			( HID_SC_MENU_START )
+#define HID_SCMENU_FILL			( HID_SC_MENU_START + 1 )
+#define HID_SCMENU_DELBREAK		( HID_SC_MENU_START + 2 )
+#define HID_SCMENU_VIEW			( HID_SC_MENU_START + 3 )
+#define HID_SCMENU_TOOLBARS		( HID_SC_MENU_START + 4 )
+#define HID_SCMENU_INSERT		( HID_SC_MENU_START + 5 )
+#define HID_SCMENU_INSBREAK		( HID_SC_MENU_START + 6 )
+#define HID_SCMENU_NAME			( HID_SC_MENU_START + 7 )
+#define HID_SCMENU_GRAPHIC		( HID_SC_MENU_START + 8 )
+#define HID_SCMENU_DATA			( HID_SC_MENU_START + 9 )
+#define HID_SCMENU_FILTER		( HID_SC_MENU_START + 10 )
+#define HID_SCMENU_OUTLINE		( HID_SC_MENU_START + 11 )
+#define HID_SCMENU_PIVOT		( HID_SC_MENU_START + 12 )
+#define HID_SCMENU_EXTRA		( HID_SC_MENU_START + 13 )
+#define HID_SCMENU_SPELLING		( HID_SC_MENU_START + 14 )
+#define HID_SCMENU_AUDIT		( HID_SC_MENU_START + 15 )
+#define HID_SCMENU_PROTECT		( HID_SC_MENU_START + 16 )
+#define HID_SCMENU_CELLCONT		( HID_SC_MENU_START + 17 )
+#define HID_SCMENU_ROW			( HID_SC_MENU_START + 18 )
+#define HID_SCMENU_COL			( HID_SC_MENU_START + 19 )
+#define HID_SCMENU_TAB			( HID_SC_MENU_START + 20 )
+#define HID_SCMENU_MERGE		( HID_SC_MENU_START + 21 )
+#define HID_SCMENU_AREA			( HID_SC_MENU_START + 22 )
+#define HID_SCMENU_OBJMIRROR	( HID_SC_MENU_START + 23 )
+#define HID_SCMENU_OBJARRANGE	( HID_SC_MENU_START + 24 )
+#define HID_SCMENU_ANCHOR		( HID_SC_MENU_START + 25 )
+#define HID_SCMENU_SENDTO		( HID_SC_MENU_START + 26 )
+#define HID_SCMENU_CHANGES		( HID_SC_MENU_START + 27 )
+
+#define HID_SC_FAP_BTN_FX1		( HID_SC_MENU_START + 28 )
+#define HID_SC_FAP_BTN_FX2		( HID_SC_MENU_START + 29 )
+#define HID_SC_FAP_BTN_FX3		( HID_SC_MENU_START + 30 )
+#define HID_SC_FAP_BTN_FX4		( HID_SC_MENU_START + 31 )
+#define HID_SC_FAP_BTN_REF1		( HID_SC_MENU_START + 32 )
+#define HID_SC_FAP_BTN_REF2		( HID_SC_MENU_START + 33 )
+#define HID_SC_FAP_BTN_REF3		( HID_SC_MENU_START + 34 )
+#define HID_SC_FAP_BTN_REF4		( HID_SC_MENU_START + 35 )
+#define HID_SC_FAP_FORMULA		( HID_SC_MENU_START + 36 )
+
+#define HID_SC_SORT_ACTION		( HID_SC_MENU_START + 37 )
+#define HID_SC_SORT_AUTHOR		( HID_SC_MENU_START + 38 )
+#define HID_SC_SORT_DATE		( HID_SC_MENU_START + 39 )
+#define HID_SC_SORT_COMMENT		( HID_SC_MENU_START + 40 )
+#define HID_SORT_POSITION		( HID_SC_MENU_START + 41 )
+#define HID_SC_CHANGES_COMMENT  ( HID_SC_MENU_START + 42 )
+#define HID_SC_FUNCTIONLIST		( HID_SC_MENU_START + 43 )
+#define HID_SCPAGE_OPTLOAD		( HID_SC_MENU_START + 44 )
+#define HID_PASSWD_TABLE		( HID_SC_MENU_START + 45 )
+#define HID_PASSWD_DOC			( HID_SC_MENU_START + 46 )
+
+#define HID_DATAPILOT_TYPE		( HID_SC_MENU_START + 47 )
+#define HID_DATAPILOT_DATABASE	( HID_SC_MENU_START + 48 )
+#define HID_DATAPILOT_SERVICE	( HID_SC_MENU_START + 49 )
+
+// Other help IDs (max.70) ---------------------------------------------------
+#define HID_SCDLG_LINKAREAURL   ( HID_SC_OTHER_START )
+#define HID_SCMENU_EDIT_TABLE   ( HID_SC_OTHER_START + 1 )
+
+#define HID_SELECTTABLES        ( HID_SC_OTHER_START + 2 )
+#define HID_SC_REPLCELLSWARN    ( HID_SC_OTHER_START + 3 )
+
+// data pilot layout dialog
+#define HID_SC_DPLAY_PAGE       ( HID_SC_OTHER_START + 4 )
+#define HID_SC_DPLAY_COLUMN     ( HID_SC_OTHER_START + 5 )
+#define HID_SC_DPLAY_ROW        ( HID_SC_OTHER_START + 6 )
+#define HID_SC_DPLAY_DATA       ( HID_SC_OTHER_START + 7 )
+#define HID_SC_DPLAY_SELECT     ( HID_SC_OTHER_START + 8 )
+
+#define HID_SC_DRAW_RENAME      ( HID_SC_OTHER_START + 9 )
+
+#define HID_SC_DPDATAFIELD      ( HID_SC_OTHER_START + 10 )
+#define HID_SC_DPSUBT_OPT       ( HID_SC_OTHER_START + 11 )
+#define HID_SC_DPSUBT_HIDE      ( HID_SC_OTHER_START + 12 )
+#define HID_SC_DPNUMGROUP       ( HID_SC_OTHER_START + 13 )
+#define HID_SC_DPDATEGROUP      ( HID_SC_OTHER_START + 14 )
+#define HID_SC_DPDATEGROUP_LB   ( HID_SC_OTHER_START + 15 )
+#define HID_SC_DPSHOWDETAIL     ( HID_SC_OTHER_START + 16 )
+
+// #i68101#
+#define HID_SC_TITLE_DESCRIPTION_OBJECT	( HID_SC_OTHER_START + 17 )
+
+#define HID_SC_SOLVEROPTIONS    ( HID_SC_OTHER_START + 18 )
+#define HID_SC_SOLVEROPTIONS_LB ( HID_SC_OTHER_START + 19 )
+#define HID_SC_SOLVER_INTEGER   ( HID_SC_OTHER_START + 20 )
+#define HID_SC_SOLVER_DOUBLE    ( HID_SC_OTHER_START + 21 )
+#define HID_SC_SOLVER_PROGRESS  ( HID_SC_OTHER_START + 22 )
+#define HID_SC_SOLVER_NOSOLUTION ( HID_SC_OTHER_START + 23 )
+#define HID_SC_SOLVER_SUCCESS   ( HID_SC_OTHER_START + 24 )
+
+#define HID_SCDLG_CONFLICTS     ( HID_SC_OTHER_START + 25 )
+
+#define HID_SC_HF_HL_DEFINED    ( HID_SC_OTHER_START + 26 )
+#define HID_SC_HF_HR_DEFINED    ( HID_SC_OTHER_START + 27 )
+#define HID_SC_HF_FL_DEFINED    ( HID_SC_OTHER_START + 28 )
+#define HID_SC_HF_FR_DEFINED    ( HID_SC_OTHER_START + 29 )
+
+// Analysis Addin Functions (max.120) ----------------------------------------
+#define HID_AAI_FUNC_WORKDAY		( HID_SC_AAI_FUNCS_START )
+#define HID_AAI_FUNC_YEARFRAC		( HID_SC_AAI_FUNCS_START + 1 )
+#define HID_AAI_FUNC_EDATE			( HID_SC_AAI_FUNCS_START + 2 )
+#define HID_AAI_FUNC_WEEKNUM		( HID_SC_AAI_FUNCS_START + 3 )
+#define HID_AAI_FUNC_EOMONTH		( HID_SC_AAI_FUNCS_START + 4 )
+#define HID_AAI_FUNC_NETWORKDAYS	( HID_SC_AAI_FUNCS_START + 5 )
+#define HID_AAI_FUNC_AMORDEGRC		( HID_SC_AAI_FUNCS_START + 6 )
+#define HID_AAI_FUNC_AMORLINC		( HID_SC_AAI_FUNCS_START + 7 )
+#define HID_AAI_FUNC_ACCRINT		( HID_SC_AAI_FUNCS_START + 8 )
+#define HID_AAI_FUNC_ACCRINTM		( HID_SC_AAI_FUNCS_START + 9 )
+#define HID_AAI_FUNC_RECEIVED		( HID_SC_AAI_FUNCS_START + 10 )
+#define HID_AAI_FUNC_DISC			( HID_SC_AAI_FUNCS_START + 11 )
+#define HID_AAI_FUNC_DURATION		( HID_SC_AAI_FUNCS_START + 12 )
+#define HID_AAI_FUNC_EFFECT			( HID_SC_AAI_FUNCS_START + 13 )
+#define HID_AAI_FUNC_CUMPRINC		( HID_SC_AAI_FUNCS_START + 14 )
+#define HID_AAI_FUNC_CUMIPMT		( HID_SC_AAI_FUNCS_START + 15 )
+#define HID_AAI_FUNC_PRICE			( HID_SC_AAI_FUNCS_START + 16 )
+#define HID_AAI_FUNC_PRICEDISC		( HID_SC_AAI_FUNCS_START + 17 )
+#define HID_AAI_FUNC_PRICEMAT		( HID_SC_AAI_FUNCS_START + 18 )
+#define HID_AAI_FUNC_MDURATION		( HID_SC_AAI_FUNCS_START + 19 )
+#define HID_AAI_FUNC_NOMINAL		( HID_SC_AAI_FUNCS_START + 20 )
+#define HID_AAI_FUNC_DOLLARFR		( HID_SC_AAI_FUNCS_START + 21 )
+#define HID_AAI_FUNC_DOLLARDE		( HID_SC_AAI_FUNCS_START + 22 )
+#define HID_AAI_FUNC_YIELD			( HID_SC_AAI_FUNCS_START + 23 )
+#define HID_AAI_FUNC_YIELDDISC		( HID_SC_AAI_FUNCS_START + 24 )
+#define HID_AAI_FUNC_YIELDMAT		( HID_SC_AAI_FUNCS_START + 25 )
+#define HID_AAI_FUNC_TBILLEQ		( HID_SC_AAI_FUNCS_START + 26 )
+#define HID_AAI_FUNC_TBILLPRICE		( HID_SC_AAI_FUNCS_START + 27 )
+#define HID_AAI_FUNC_TBILLYIELD		( HID_SC_AAI_FUNCS_START + 28 )
+#define HID_AAI_FUNC_ODDFPRICE		( HID_SC_AAI_FUNCS_START + 29 )
+#define HID_AAI_FUNC_ODDFYIELD		( HID_SC_AAI_FUNCS_START + 30 )
+#define HID_AAI_FUNC_ODDLPRICE		( HID_SC_AAI_FUNCS_START + 31 )
+#define HID_AAI_FUNC_ODDLYIELD		( HID_SC_AAI_FUNCS_START + 32 )
+#define HID_AAI_FUNC_XIRR			( HID_SC_AAI_FUNCS_START + 33 )
+#define HID_AAI_FUNC_XNPV			( HID_SC_AAI_FUNCS_START + 34 )
+#define HID_AAI_FUNC_INTRATE		( HID_SC_AAI_FUNCS_START + 35 )
+#define HID_AAI_FUNC_COUPNCD		( HID_SC_AAI_FUNCS_START + 36 )
+#define HID_AAI_FUNC_COUPDAYS		( HID_SC_AAI_FUNCS_START + 37 )
+#define HID_AAI_FUNC_COUPDAYSNC		( HID_SC_AAI_FUNCS_START + 38 )
+#define HID_AAI_FUNC_COUPDAYBS		( HID_SC_AAI_FUNCS_START + 39 )
+#define HID_AAI_FUNC_COUPPCD		( HID_SC_AAI_FUNCS_START + 40 )
+#define HID_AAI_FUNC_COUPNUM		( HID_SC_AAI_FUNCS_START + 41 )
+#define HID_AAI_FUNC_FVSCHEDULE		( HID_SC_AAI_FUNCS_START + 42 )
+#define HID_AAI_FUNC_ISEVEN			( HID_SC_AAI_FUNCS_START + 43 )
+#define HID_AAI_FUNC_ISODD			( HID_SC_AAI_FUNCS_START + 44 )
+#define HID_AAI_FUNC_GCD			( HID_SC_AAI_FUNCS_START + 45 )
+#define HID_AAI_FUNC_LCM			( HID_SC_AAI_FUNCS_START + 46 )
+#define HID_AAI_FUNC_MULTINOMIAL	( HID_SC_AAI_FUNCS_START + 47 )
+#define HID_AAI_FUNC_SERIESSUM		( HID_SC_AAI_FUNCS_START + 48 )
+#define HID_AAI_FUNC_QUOTIENT		( HID_SC_AAI_FUNCS_START + 49 )
+#define HID_AAI_FUNC_MROUND			( HID_SC_AAI_FUNCS_START + 50 )
+#define HID_AAI_FUNC_SQRTPI			( HID_SC_AAI_FUNCS_START + 51 )
+#define HID_AAI_FUNC_RANDBETWEEN	( HID_SC_AAI_FUNCS_START + 52 )
+#define HID_AAI_FUNC_BESSELI		( HID_SC_AAI_FUNCS_START + 53 )
+#define HID_AAI_FUNC_BESSELJ		( HID_SC_AAI_FUNCS_START + 54 )
+#define HID_AAI_FUNC_BESSELK		( HID_SC_AAI_FUNCS_START + 55 )
+#define HID_AAI_FUNC_BESSELY		( HID_SC_AAI_FUNCS_START + 56 )
+#define HID_AAI_FUNC_BIN2DEC		( HID_SC_AAI_FUNCS_START + 57 )
+#define HID_AAI_FUNC_BIN2HEX		( HID_SC_AAI_FUNCS_START + 58 )
+#define HID_AAI_FUNC_BIN2OCT		( HID_SC_AAI_FUNCS_START + 59 )
+#define HID_AAI_FUNC_DELTA			( HID_SC_AAI_FUNCS_START + 60 )
+#define HID_AAI_FUNC_DEC2BIN		( HID_SC_AAI_FUNCS_START + 61 )
+#define HID_AAI_FUNC_DEC2HEX		( HID_SC_AAI_FUNCS_START + 62 )
+#define HID_AAI_FUNC_DEC2OCT		( HID_SC_AAI_FUNCS_START + 63 )
+#define HID_AAI_FUNC_ERF			( HID_SC_AAI_FUNCS_START + 64 )
+#define HID_AAI_FUNC_ERFC			( HID_SC_AAI_FUNCS_START + 65 )
+#define HID_AAI_FUNC_GESTEP			( HID_SC_AAI_FUNCS_START + 66 )
+#define HID_AAI_FUNC_HEX2BIN		( HID_SC_AAI_FUNCS_START + 67 )
+#define HID_AAI_FUNC_HEX2DEC		( HID_SC_AAI_FUNCS_START + 68 )
+#define HID_AAI_FUNC_HEX2OCT		( HID_SC_AAI_FUNCS_START + 69 )
+#define HID_AAI_FUNC_IMABS			( HID_SC_AAI_FUNCS_START + 70 )
+#define HID_AAI_FUNC_IMAGINARY		( HID_SC_AAI_FUNCS_START + 71 )
+#define HID_AAI_FUNC_IMPOWER		( HID_SC_AAI_FUNCS_START + 72 )
+#define HID_AAI_FUNC_IMARGUMENT		( HID_SC_AAI_FUNCS_START + 73 )
+#define HID_AAI_FUNC_IMCOS			( HID_SC_AAI_FUNCS_START + 74 )
+#define HID_AAI_FUNC_IMDIV			( HID_SC_AAI_FUNCS_START + 75 )
+#define HID_AAI_FUNC_IMEXP			( HID_SC_AAI_FUNCS_START + 76 )
+#define HID_AAI_FUNC_IMCONJUGATE	( HID_SC_AAI_FUNCS_START + 77 )
+#define HID_AAI_FUNC_IMLN			( HID_SC_AAI_FUNCS_START + 78 )
+#define HID_AAI_FUNC_IMLOG10		( HID_SC_AAI_FUNCS_START + 79 )
+#define HID_AAI_FUNC_IMLOG2			( HID_SC_AAI_FUNCS_START + 80 )
+#define HID_AAI_FUNC_IMPRODUCT		( HID_SC_AAI_FUNCS_START + 81 )
+#define HID_AAI_FUNC_IMREAL			( HID_SC_AAI_FUNCS_START + 82 )
+#define HID_AAI_FUNC_IMSIN			( HID_SC_AAI_FUNCS_START + 83 )
+#define HID_AAI_FUNC_IMSUB			( HID_SC_AAI_FUNCS_START + 84 )
+#define HID_AAI_FUNC_IMSUM			( HID_SC_AAI_FUNCS_START + 85 )
+#define HID_AAI_FUNC_IMSQRT			( HID_SC_AAI_FUNCS_START + 86 )
+#define HID_AAI_FUNC_COMPLEX		( HID_SC_AAI_FUNCS_START + 87 )
+#define HID_AAI_FUNC_OCT2BIN		( HID_SC_AAI_FUNCS_START + 88 )
+#define HID_AAI_FUNC_OCT2DEZ		( HID_SC_AAI_FUNCS_START + 89 )
+#define HID_AAI_FUNC_OCT2HEX		( HID_SC_AAI_FUNCS_START + 90 )
+#define HID_AAI_FUNC_CONVERT		( HID_SC_AAI_FUNCS_START + 91 )
+#define HID_AAI_FUNC_FACTDOUBLE		( HID_SC_AAI_FUNCS_START + 92 )
+
+// DateFunc Addin Functions (max.20) -----------------------------------------
+#define HID_DAI_FUNC_DAYSINMONTH    ( HID_SC_DAI_FUNCS_START )
+#define HID_DAI_FUNC_DAYSINYEAR     ( HID_SC_DAI_FUNCS_START + 1 )
+#define HID_DAI_FUNC_WEEKSINYEAR    ( HID_SC_DAI_FUNCS_START + 2 )
+#define HID_DAI_FUNC_DIFFMONTHS     ( HID_SC_DAI_FUNCS_START + 3 )
+#define HID_DAI_FUNC_DIFFWEEKS      ( HID_SC_DAI_FUNCS_START + 4 )
+#define HID_DAI_FUNC_DIFFYEARS      ( HID_SC_DAI_FUNCS_START + 5 )
+#define HID_DAI_FUNC_ROT13          ( HID_SC_DAI_FUNCS_START + 6 )
+
+// Ende Hilfe IDs ------------------------------------------------------------
+// ---------------------------------------------------------------------------
+
+// View-Funktionen (max. 100) ------------------------------------------------
+
+#define FID_TESTFUNC0			(SC_VIEW_START)
+#define FID_TESTFUNC1			(SC_VIEW_START + 1)
+#define FID_TESTFUNC2			(SC_VIEW_START + 2)
+#define FID_TESTFUNC3			(SC_VIEW_START + 3)
+#define FID_TESTFUNC4			(SC_VIEW_START + 4)
+#define FID_TESTFUNC5			(SC_VIEW_START + 5)
+#define FID_TESTFUNC6			(SC_VIEW_START + 6)
+#define FID_TESTFUNC7			(SC_VIEW_START + 7)
+#define FID_TESTFUNC8			(SC_VIEW_START + 8)
+#define FID_TESTFUNC9			(SC_VIEW_START + 9)
+#define FID_SCALESTATUS			(SC_VIEW_START + 10)
+#define FID_COLOR				(SC_VIEW_START + 11)
+//aus sfx: #define SID_REPAINT				(SC_VIEW_START + 12)
+#define SID_UPDATECHART			(SC_VIEW_START + 13)
+#define FID_MARKLEFT			(SC_VIEW_START + 14)
+#define FID_MARKRIGHT			(SC_VIEW_START + 15)
+#define FID_MARKUP				(SC_VIEW_START + 16)
+#define FID_MARKDOWN			(SC_VIEW_START + 17)
+#define FID_MARKPAGEUP			(SC_VIEW_START + 18)
+#define FID_MARKPAGEDOWN		(SC_VIEW_START + 19)
+
+// Slot-IDs fuer Attribute:
+
+#define SID_SCATTR_HOR_JUSTIFY	(SC_VIEW_START + 30)	// Alignment-Page
+#define SID_SCATTR_VER_JUSTIFY	(SC_VIEW_START + 31)
+#define SID_SCATTR_MARGIN		(SC_VIEW_START + 32)
+#define SID_SCATTR_STACKED      (SC_VIEW_START + 33)
+#define SID_SCATTR_LINEBREAK	(SC_VIEW_START + 35)
+#define	SID_SCATTR_PROTECTION	(SC_VIEW_START + 36)	// Protection-Page
+
+// sonstige Slot-IDs:
+
+#define SID_SCUSERLISTS         (SC_VIEW_START + 37)    // Benutzerdef.Listen
+#define RES_TBX_DUMMY			(SC_VIEW_START + 38)    // Dummy-Item
+#define SID_SCVIEWOPTIONS       (SC_VIEW_START + 39)
+#define SID_SCDOCOPTIONS        (SC_VIEW_START + 40)
+
+// Cursorbewegungen als Properties:
+
+#define	SID_CURRENTCELL			(SC_VIEW_START + 41)
+#define	SID_CURRENTTAB			(SC_VIEW_START + 42)
+#define SID_CURRENTDOC			(SC_VIEW_START + 43)
+#define SID_CURRENTOBJECT		(SC_VIEW_START + 44)
+
+// Slot-IDs fuer spez. ToolBox-Funktionen:
+
+#define SID_NUMBER_CURRENCY		(SC_VIEW_START + 45)
+#define SID_NUMBER_PERCENT		(SC_VIEW_START + 46)
+
+// "Slot" Ids fuer Eingabezeilen Images:
+#define SID_INPUT_FUNCTION		(SC_VIEW_START + 47)
+#define SID_INPUT_SUM			(SC_VIEW_START + 48)
+#define SID_INPUT_EQUAL			(SC_VIEW_START + 49)
+#define SID_INPUT_CANCEL		(SC_VIEW_START + 50)
+#define SID_INPUT_OK			(SC_VIEW_START + 51)
+
+#define SID_NUMBER_STANDARD		(SC_VIEW_START + 52)
+#define SID_NUMBER_DATE			(SC_VIEW_START + 53)
+#define SID_NUMBER_TWODEC		(SC_VIEW_START + 54)
+#define SID_NUMBER_SCIENTIFIC	(SC_VIEW_START + 55)
+#define SID_NUMBER_TIME			(SC_VIEW_START + 56)
+#define SID_NUMBER_INCDEC		(SC_VIEW_START + 57)
+#define SID_NUMBER_DECDEC		(SC_VIEW_START + 58)
+
+// Sonstiges:
+#define SID_LINKS				(SC_VIEW_START + 60)
+#define SID_INSERT_SIMAGE		(SC_VIEW_START + 61)
+#define SID_INSERT_SCHART		(SC_VIEW_START + 62)
+#define SID_INSERT_SMATH        (SC_VIEW_START + 63)
+#define SID_STANDARD_FONTS		(SC_VIEW_START + 64)
+#define SID_MIRROR_VERTICAL		(SC_VIEW_START + 65)
+#define SID_MIRROR_HORIZONTAL	(SC_VIEW_START + 66)
+#define SID_CELL_FORMAT_RESET	(SC_VIEW_START + 67)
+#define SID_SCPRINTOPTIONS      (SC_VIEW_START + 68)
+#define SID_WINDOW_SPLIT		(SC_VIEW_START + 69)
+#define SID_WINDOW_FIX			(SC_VIEW_START + 70)
+#ifdef SID_DRAW_CHART
+#undef SID_DRAW_CHART
+#endif
+#define SID_DRAW_CHART			(SC_VIEW_START + 71)
+#define SID_UPDATETABLINKS		(SC_VIEW_START + 72)
+
+//TabPage Eingabe
+#define SID_SC_INPUT_SELECTION          (SC_VIEW_START + 73)
+#define SID_SC_INPUT_SELECTIONPOS       (SC_VIEW_START + 74)
+#define SID_SC_INPUT_EDITMODE           (SC_VIEW_START + 75)
+#define SID_SC_INPUT_FMT_EXPAND         (SC_VIEW_START + 76)
+#define SID_SC_INPUT_RANGEFINDER        (SC_VIEW_START + 77)
+#define SID_SC_INPUT_REF_EXPAND			(SC_VIEW_START + 78)
+#define SID_SC_INPUT_MARK_HEADER		(SC_VIEW_START + 79)
+
+#define SID_REIMPORT_AFTER_LOAD	(SC_VIEW_START + 80)
+#define SID_DRAW_NOTEEDIT		(SC_VIEW_START + 81)
+
+#define SID_CHOOSE_DESIGN		(SC_VIEW_START + 82)
+#define SID_EURO_CONVERTER		(SC_VIEW_START + 83)
+//#define SID_CHG_PROTECT         (SC_VIEW_START + 84)		-> moved to SVX
+#define SID_EXTERNAL_SOURCE     (SC_VIEW_START + 85)
+
+#define SID_SC_INPUT_TEXTWYSIWYG		(SC_VIEW_START + 86)
+
+#define SID_ENABLE_HYPHENATION          (SC_VIEW_START + 87)
+
+#define SID_RENAME_OBJECT				(SC_VIEW_START + 88)
+#define SID_FOCUS_INPUTLINE				(SC_VIEW_START + 89)
+#define SID_SELECT_TABLES               (SC_VIEW_START + 90)
+
+// #97776# new entry "Filter..." in DP popup menu
+#define SID_DP_FILTER                   (SC_VIEW_START + 91)
+
+// #101160# Replace cell contents warning
+#define SID_SC_INPUT_REPLCELLSWARN      (SC_VIEW_START + 92)
+
+// additional IDs for list/range validity
+#define FID_VALID_LISTTYPE              (SC_VIEW_START + 93)
+
+// #i68101# ID for changing Title & Descriptopn of an Object
+#define SID_TITLE_DESCRIPTION_OBJECT	(SC_VIEW_START + 94)
+
+// #i59082# assign macro to shape
+#define SID_ASSIGNMACRO                 (SC_VIEW_START + 95)
+
+// #i66550# hyperlinks in shapes
+#define SID_DRAW_HLINK_EDIT             (SC_VIEW_START + 96)
+#define SID_DRAW_HLINK_DELETE           (SC_VIEW_START + 97)
+
+// "Zoom / Synchronize sheets" in options dialog
+#define SID_SC_OPT_SYNCZOOM             (SC_VIEW_START + 98)
+
+// NOTE: last valid ID is (SC_VIEW_START + 99)
+
+// Nachrichten -------------------------------------------------------------
+
+#define FID_INPUTLINE_STATUS	(SC_MESSAGE_START)
+#define FID_INPUTLINE_ENTER		(SC_MESSAGE_START + 1)
+#define FID_REPAINT				(SC_MESSAGE_START + 2)
+#define FID_DATACHANGED			(SC_MESSAGE_START + 3)
+#define FID_REFMODECHANGED		(SC_MESSAGE_START + 4)
+#define FID_KILLEDITVIEW		(SC_MESSAGE_START + 5)
+#define SID_SOLVE               (SC_MESSAGE_START + 6)
+#define FID_FONT_SELECTED       (SC_MESSAGE_START + 7)
+#define FID_FILTER_OK           (SC_MESSAGE_START + 8)
+#define SC_HINT_DRWLAYER_NEW	(SC_MESSAGE_START + 9)
+#define SID_TABDELETED			(SC_MESSAGE_START + 10)
+#define FID_INPUTLINE_MATRIX	(SC_MESSAGE_START + 11)
+#define SID_DLG_RETOK           (SC_MESSAGE_START + 12)
+#define FID_ANYDATACHANGED		(SC_MESSAGE_START + 13)
+#define SID_STATUS_DOCPOS       (SC_MESSAGE_START + 14)
+#define SID_STATUS_PAGESTYLE    (SC_MESSAGE_START + 15)
+#define SID_STATUS_SELMODE	    (SC_MESSAGE_START + 16)
+#define FID_KILLEDITVIEW_NOPAINT (SC_MESSAGE_START + 17)
+#define SID_DLG_MATRIX          (SC_MESSAGE_START + 18)
+#define SC_HINT_DBAREAS_CHANGED (SC_MESSAGE_START + 19)
+#define SC_HINT_AREAS_CHANGED   (SC_MESSAGE_START + 20)
+#define SC_HINT_TABLES_CHANGED  (SC_MESSAGE_START + 21)
+
+#define SID_STATUS_SELMODE_ERG  (SC_MESSAGE_START + 22)
+#define SID_STATUS_SELMODE_ERW  (SC_MESSAGE_START + 23)
+#define SID_STATUS_SELMODE_NORM (SC_MESSAGE_START + 24)
+
+#define SID_CHART_SOURCE		(SC_MESSAGE_START + 25)
+#define SID_CHART_NAME			(SC_MESSAGE_START + 26)
+#define SID_CHART_ADDSOURCE		(SC_MESSAGE_START + 27)
+
+#define SID_AUTO_STYLE			(SC_MESSAGE_START + 28)
+
+#define FID_INPUTLINE_BLOCK		(SC_MESSAGE_START + 29)
+
+#define SID_STATUS_SUM			(SC_MESSAGE_START + 30)
+
+#define SC_HINT_DRAW_CHANGED	(SC_MESSAGE_START + 31)
+#define SC_HINT_DOCNAME_CHANGED	(SC_MESSAGE_START + 32)
+#define SC_HINT_AREALINKS_CHANGED (SC_MESSAGE_START + 33)
+#define SC_HINT_SHOWRANGEFINDER	(SC_MESSAGE_START + 34)
+#define SC_HINT_DOC_SAVED		(SC_MESSAGE_START + 35)
+#define SC_HINT_FORCESETTAB		(SC_MESSAGE_START + 36)
+
+// Nachricht zum Oeffnen von Dialogen:
+#define SID_OPENDLG_CONSOLIDATE		(SC_MESSAGE_START + 50)
+#define SID_OPENDLG_PIVOTTABLE 		(SC_MESSAGE_START + 51)
+#define SID_OPENDLG_FUNCTION		(SC_MESSAGE_START + 52)
+#define SID_OPENDLG_SOLVE      		(SC_MESSAGE_START + 53)
+#define SID_OPENDLG_TABOP			(SC_MESSAGE_START + 54)
+//#define SID_OPENDLG_CHART			(SC_MESSAGE_START + 55)
+#define SID_OPENDLG_EDITFUNCTION	(SC_MESSAGE_START + 56)
+#define SID_OPENDLG_ARGUMENT		(SC_MESSAGE_START + 57)
+//#define SID_OPENDLG_MODCHART		(SC_MESSAGE_START + 58)
+#define SID_OPENDLG_CONDFRMT		(SC_MESSAGE_START + 59)
+#define SID_OPENDLG_OPTSOLVER       (SC_MESSAGE_START + 60)
+
+#define SC_HINT_NAVIGATOR_UPDATEALL  (SC_MESSAGE_START + 65)
+
+// Funktionen ------------------------------------------------------------
+
+
+//#define FID_PRINT_PREVIEW		(SC_FUNCTION_START)
+#define FID_DOC_MANAGER 		(SC_FUNCTION_START + 1)
+#define FID_CURSOR_ENTER		(SC_FUNCTION_START + 2)
+#define SID_MAIL                (SC_FUNCTION_START + 3)
+#define FILE_MENU_END			(SC_FUNCTION_START + 20)
+
+#define EDIT_MENU_START 		(FILE_MENU_END)
+#define FID_PASTE_CONTENTS		(EDIT_MENU_START)
+#define FID_DELETE_CELLCONTENTS	(EDIT_MENU_START + 1)
+#define FID_DELETE_CELL			(EDIT_MENU_START + 2)
+#define FID_DELETE_TABLE		(EDIT_MENU_START + 3)
+#define FID_FILL_TO_BOTTOM		(EDIT_MENU_START + 4)
+#define FID_FILL_TO_RIGHT		(EDIT_MENU_START + 5)
+#define FID_FILL_TO_TOP			(EDIT_MENU_START + 6)
+#define FID_FILL_TO_LEFT		(EDIT_MENU_START + 7)
+#define FID_FILL_TAB			(EDIT_MENU_START + 8)
+#define FID_FILL_SERIES			(EDIT_MENU_START + 9)
+#define FID_SEARCH_REPLACE_DLG	(EDIT_MENU_START + 10)
+#define FID_EDIT_OBJECT			(EDIT_MENU_START + 11)
+#define SID_SC_NAVIGATOR		(EDIT_MENU_START + 12)
+#define SID_SC_WIZARD		    (EDIT_MENU_START + 13)
+#define SID_SC_EDIT_OBJECT	    (EDIT_MENU_START + 14)
+#define SID_HFEDIT              (EDIT_MENU_START + 15)
+
+#define SID_DEL_ROWS            (EDIT_MENU_START + 16)//JN
+#define SID_DEL_COLS            (EDIT_MENU_START + 17)//JN
+
+//#define	FID_CHG_RECORD			(EDIT_MENU_START + 18)	-> moved to SVX
+#define	FID_CHG_SHOW			(EDIT_MENU_START + 19)
+
+#define EDIT_MENU_END			(EDIT_MENU_START + 20)
+#define VIEW_MENU_START 		(EDIT_MENU_END)
+
+#define FID_TOGGLEOBJECT		(VIEW_MENU_START)
+#define FID_TOGGLEINPUTLINE 	(VIEW_MENU_START + 1)
+#define FID_TOGGLEHEADERS		(VIEW_MENU_START + 2)
+#define FID_SCALE				(VIEW_MENU_START + 4)
+#define FID_TOGGLESYNTAX		(VIEW_MENU_START + 5)
+#define FID_SCREEN_OPTIONS		(VIEW_MENU_START + 6)
+#define FID_PAGEBREAKMODE		(VIEW_MENU_START + 7)
+#define FID_FUNCTION_BOX		(VIEW_MENU_START + 8)
+#define FID_NORMALVIEWMODE      (VIEW_MENU_START + 9)
+#define FID_TOGGLEFORMULA		(VIEW_MENU_START + 10)
+// Compare/Merge jetzt aus Sfx
+//#define FID_CHG_COMPARE		(VIEW_MENU_START + 16)// DANGER DIRTY ID
+//#define FID_CHG_MERGE			(VIEW_MENU_START + 17)// DANGER DIRTY ID
+#define	FID_CHG_ACCEPT			(VIEW_MENU_START + 18)// DANGER DIRTY ID
+#define	FID_CHG_COMMENT			(VIEW_MENU_START + 19)// DANGER DIRTY ID
+#define VIEW_MENU_END			(VIEW_MENU_START + 20)
+
+#define INSERT_MENU_START		(VIEW_MENU_END)
+#define FID_PAGEBREAK			(INSERT_MENU_START)
+#define FID_INS_ROWBRK			(INSERT_MENU_START + 1)
+#define FID_INS_COLBRK			(INSERT_MENU_START + 2)
+#define FID_DEL_ROWBRK			(INSERT_MENU_START + 3)
+#define FID_DEL_COLBRK			(INSERT_MENU_START + 4)
+#define FID_INS_CELL_CONTENTS	(INSERT_MENU_START + 5)
+#define FID_INS_CELL			(INSERT_MENU_START + 6)
+#define FID_INS_ROW 			(INSERT_MENU_START + 7)
+#define FID_INS_COLUMN			(INSERT_MENU_START + 8)
+#define FID_INS_TABLE			(INSERT_MENU_START + 9)
+#define SID_INS_FUNCTION		(INSERT_MENU_START + 10)
+#define FID_DEFINE_NAME 		(INSERT_MENU_START + 11)
+#define FID_INSERT_NAME 		(INSERT_MENU_START + 12)
+#define FID_USE_NAME			(INSERT_MENU_START + 13)
+#define FID_APPLY_NAME			(INSERT_MENU_START + 14)
+#define FID_INS_TABLE_EXT       (INSERT_MENU_START + 15)
+//#define SID_CHARMAP				(INSERT_MENU_START + 15)//!!! kommt von sfx
+//aus sfx: #define SID_INSERT_POSTIT       (INSERT_MENU_START + 16)
+#define SID_INSERT_CLIPART      (INSERT_MENU_START + 17) //!!! sollte vom Svx kommen
+#define FID_INS_CELLSDOWN		(INSERT_MENU_START + 18)
+#define FID_INS_CELLSRIGHT		(INSERT_MENU_START + 19)
+#define INSERT_MENU_END 		(INSERT_MENU_START + 20)
+
+#define FORMAT_MENU_START		(INSERT_MENU_END)
+#define FID_CELL_FORMAT 		(FORMAT_MENU_START)
+#define FID_ROW_HEIGHT			(FORMAT_MENU_START + 1)
+#define FID_ROW_OPT_HEIGHT		(FORMAT_MENU_START + 2)
+#define FID_ROW_HIDE			(FORMAT_MENU_START + 3)
+#define FID_ROW_SHOW			(FORMAT_MENU_START + 4)
+#define FID_COL_WIDTH			(FORMAT_MENU_START + 5)
+#define FID_COL_OPT_WIDTH		(FORMAT_MENU_START + 6)
+#define FID_COL_HIDE			(FORMAT_MENU_START + 7)
+#define FID_COL_SHOW			(FORMAT_MENU_START + 8)
+#define FID_TABLE_HIDE			(FORMAT_MENU_START + 9)
+#define FID_TABLE_SHOW			(FORMAT_MENU_START + 10)
+#define FID_CONDITIONAL_FORMAT	(FORMAT_MENU_START + 11)
+#define SID_SCSTYLES	 		(FORMAT_MENU_START + 12)
+#define FID_MERGE_ON			(FORMAT_MENU_START + 13)
+#define FID_MERGE_OFF			(FORMAT_MENU_START + 14)
+#define SID_FORMATPAGE          (FORMAT_MENU_START + 15)
+#define SID_TEXT_STANDARD       (FORMAT_MENU_START + 16)
+#define SID_DRAWTEXT_ATTR_DLG	(FORMAT_MENU_START + 17)
+#define FID_TABLE_VISIBLE		(FORMAT_MENU_START + 18)
+#define FID_COL_OPT_DIRECT		(FORMAT_MENU_START + 19)
+#define FORMAT_MENU_END 		(FORMAT_MENU_START + 20)
+
+#define EXTRA_MENU_START		(FORMAT_MENU_END)
+#define FID_VOICE_CONTROL 		(EXTRA_MENU_START + 1)
+#define SID_RECALC_TITLE        (EXTRA_MENU_START + 2)
+#define FID_AUTO_CALC	 		(EXTRA_MENU_START + 3)
+#define FID_RECALC		 		(EXTRA_MENU_START + 4)
+#define FID_UPDATE_DIAGRAMS	 	(EXTRA_MENU_START + 5)
+#define FID_PROTECT_TABLE		(EXTRA_MENU_START + 6)
+#define FID_PROTECT_DOC			(EXTRA_MENU_START + 7)
+#define SID_EDIT_MACRO			(EXTRA_MENU_START + 8)
+#define SID_SCOPTIONS			(EXTRA_MENU_START + 9)
+#define SID_MACRO_CHOOSER		(EXTRA_MENU_START + 10)
+#define SID_SHARE_DOC           (EXTRA_MENU_START + 11)
+#define SID_SCENARIOS			(EXTRA_MENU_START + 12)
+#define SID_ADD_IN_MANAGER		(EXTRA_MENU_START + 13)
+#define SID_PIVOT_RECALC        (EXTRA_MENU_START + 14)
+#define SID_PIVOT_KILL          (EXTRA_MENU_START + 15)
+
+// hier falsch, aber erstmal
+#define SID_SC_HELP_PI			(EXTRA_MENU_START + 16)
+#define SID_SC_SHOW_KEYBOARD_HELP (EXTRA_MENU_START + 17)
+
+#define FID_HARD_RECALC		 	(EXTRA_MENU_START + 18)
+#define FID_AUTOCOMPLETE		(EXTRA_MENU_START + 19)
+
+#define EXTRA_MENU_END	 		(EXTRA_MENU_START + 20)
+
+#define DATA_MENU_START			(EXTRA_MENU_END)
+#define SID_DEFINE_DBNAME		(DATA_MENU_START)
+#define SID_SELECT_DB			(DATA_MENU_START + 1)
+#define SID_SORT                (DATA_MENU_START + 2)
+#define SID_FILTER              (DATA_MENU_START + 3)
+#define SID_SPECIAL_FILTER      (DATA_MENU_START + 4)
+#define SID_AUTO_FILTER         (DATA_MENU_START + 5)
+#define SID_UNFILTER	        (DATA_MENU_START + 6)
+#define SID_QUERY               (DATA_MENU_START + 7)
+#define SID_SUBTOTALS           (DATA_MENU_START + 8)
+//aus sfx: #define SID_OUTLINE_HIDE        (DATA_MENU_START + 9)
+//aus sfx: #define SID_OUTLINE_SHOW        (DATA_MENU_START + 10)
+//aus sfx: #define SID_OUTLINE_MAKE        (DATA_MENU_START + 11)
+//aus sfx: #define SID_OUTLINE_REMOVE      (DATA_MENU_START + 12)
+#define SID_AUTO_OUTLINE		(DATA_MENU_START + 13)
+//aus sfx: #define SID_OUTLINE_DELETEALL   (DATA_MENU_START + 14)
+#define SID_IMPORT_DATA         (DATA_MENU_START + 15)
+#define SID_REIMPORT_DATA       (DATA_MENU_START + 16)
+#define SID_PIVOT_TABLE			(DATA_MENU_START + 17)
+#define SID_TABOP				(DATA_MENU_START + 18)
+#define SID_TEXT_TO_COLUMNS		(DATA_MENU_START + 19)
+#define SID_CONSOLIDATE			(DATA_MENU_START + 20)
+#define SID_AUTOFILTER_HIDE		(DATA_MENU_START + 21)
+
+#define SID_SBA_IMPORT			(DATA_MENU_START + 22)
+
+#define SID_SORT_DESCENDING		(DATA_MENU_START + 23)
+#define SID_SORT_ASCENDING		(DATA_MENU_START + 24)
+//
+//
+#define DATA_MENU_END           (DATA_MENU_START + 25)
+
+#define TAB_POPUP_START			(DATA_MENU_END)
+#define RID_POPUP_TAB			(TAB_POPUP_START)
+#define FID_TAB_MENU_RENAME		(TAB_POPUP_START+1)
+#define FID_TAB_RENAME			(TAB_POPUP_START+2)
+#define FID_TAB_MOVE			(TAB_POPUP_START+3)
+#define FID_TAB_SELECTALL		(TAB_POPUP_START+4)
+#define FID_TAB_APPEND			(TAB_POPUP_START+5)
+#define FID_TAB_INDEX			(TAB_POPUP_START+6)
+#define FID_TAB_RTL				(TAB_POPUP_START+7)
+#define FID_TAB_DESELECTALL     (TAB_POPUP_START+8)
+
+#define TAB_POPUP_END			(DATA_MENU_END + 20)
+
+#define OBJBAR_FORMAT_START		(TAB_POPUP_END)
+#define SID_ALIGNLEFT			(OBJBAR_FORMAT_START+6)
+#define SID_ALIGNRIGHT			(OBJBAR_FORMAT_START+7)
+#define SID_ALIGNCENTERHOR 		(OBJBAR_FORMAT_START+8)
+#define SID_ALIGNBLOCK			(OBJBAR_FORMAT_START+9)
+#define SID_ALIGNTOP			(OBJBAR_FORMAT_START+10)
+#define SID_ALIGNBOTTOM			(OBJBAR_FORMAT_START+11)
+#define SID_ALIGNCENTERVER 		(OBJBAR_FORMAT_START+12)
+#define SID_SELECT_SCENARIO		(OBJBAR_FORMAT_START+13)
+
+#define SID_V_ALIGNCELL			(OBJBAR_FORMAT_START+14)
+#define SID_H_ALIGNCELL			(OBJBAR_FORMAT_START+15)
+
+#define OBJBAR_FORMAT_END		(OBJBAR_FORMAT_START+20)
+
+#define RID_INPUTBAR_START		(OBJBAR_FORMAT_END)
+#define SID_INPUT_WINDOW		(RID_INPUTBAR_START)
+#define RID_INPUTBAR_END		(RID_INPUTBAR_START+1)
+
+#define DRAW_BAR_START			(RID_INPUTBAR_END)
+//! SID_OBJECT_MIRROR wird sicher mal allgemein
+#define SID_OBJECT_MIRROR		(DRAW_BAR_START)
+#define SID_DRAWTOABOVE			(DRAW_BAR_START+15)
+#define SID_DRAWTOBELOW			(DRAW_BAR_START+16)
+//#define SID_GROUP				(DRAW_BAR_START+17)
+//#define SID_UNGROUP				(DRAW_BAR_START+18)
+#define SID_FRAMETOTOP			(DRAW_BAR_START+19)
+#define SID_FRAMETOBOTTOM		(DRAW_BAR_START+20)
+//aus sfx: #define SID_FRAME_UP			(DRAW_BAR_START+21)
+//aus sfx: #define SID_FRAME_DOWN			(DRAW_BAR_START+22)
+#define SID_TOOL_TEXT           (DRAW_BAR_START+23)
+#define SID_ANCHOR_PAGE         (DRAW_BAR_START+24)
+#define SID_ANCHOR_CELL         (DRAW_BAR_START+25)
+#define SID_ANCHOR_TOGGLE       (DRAW_BAR_START+26)
+#define SID_ORIGINALSIZE		(DRAW_BAR_START+27)
+
+#define DRAW_BAR_END			(DRAW_BAR_START+50)
+
+#define DRAWTEXTBAR_START		(DRAW_BAR_END)
+#define SID_TEXT_LINESPACING_1	(DRAWTEXTBAR_START)
+#define SID_TEXT_LINESPACING_2	(DRAWTEXTBAR_START+1)
+#define SID_TEXT_LINESPACING_3	(DRAWTEXTBAR_START+2)
+#define DRAWTEXTBAR_END			(DRAWTEXTBAR_START+20)
+
+#define DETECTIVE_START			(DRAWTEXTBAR_END)
+#define SID_DETECTIVE_ADD_PRED  (DETECTIVE_START)
+#define SID_DETECTIVE_DEL_PRED  (DETECTIVE_START+1)
+#define SID_DETECTIVE_ADD_SUCC  (DETECTIVE_START+2)
+#define SID_DETECTIVE_DEL_SUCC  (DETECTIVE_START+3)
+#define SID_DETECTIVE_ADD_ERR   (DETECTIVE_START+4)
+#define SID_DETECTIVE_DEL_ALL   (DETECTIVE_START+5)
+
+#define SID_DETECTIVE_FILLMODE	(DETECTIVE_START+6)
+#define SID_FILL_ADD_PRED		(DETECTIVE_START+7)
+#define SID_FILL_DEL_PRED		(DETECTIVE_START+8)
+#define SID_FILL_ADD_SUCC		(DETECTIVE_START+9)
+#define SID_FILL_DEL_SUCC		(DETECTIVE_START+10)
+#define SID_FILL_NONE			(DETECTIVE_START+11)
+#define SID_FILL_SELECT			(DETECTIVE_START+12)
+
+#define SID_DETECTIVE_INVALID   (DETECTIVE_START+13)
+
+#define SID_DETECTIVE_REFRESH   (DETECTIVE_START+14)
+#define SID_DETECTIVE_AUTO      (DETECTIVE_START+15)
+
+#define DETECTIVE_END			(DETECTIVE_START+20)
+
+#define SID_API_SLOTS			(DETECTIVE_END)
+//aus sfx: #define SID_ENTER_STRING		(SID_API_SLOTS)
+#define SID_INSERT_MATRIX		(SID_API_SLOTS+1)
+
+#define SID_DELETE_NOTE         (SID_API_SLOTS+2)
+
+
+#define SID_PREVIEW_START		(SID_API_SLOTS+20)
+#define SID_PREVIEW_NEXT		(SID_PREVIEW_START)
+#define SID_PREVIEW_PREVIOUS	(SID_PREVIEW_START+1)
+#define SID_PREVIEW_FIRST		(SID_PREVIEW_START+2)
+#define SID_PREVIEW_LAST		(SID_PREVIEW_START+3)
+#define SID_PREVIEW_GOTO		(SID_PREVIEW_START+4)
+#define SID_PREVIEW_ZOOMIN		(SID_PREVIEW_START+5)
+#define SID_PREVIEW_ZOOMOUT		(SID_PREVIEW_START+6)
+#define SID_PREVIEW_CLOSE		(SID_PREVIEW_START+7)
+#define SID_PREVIEW_MARGIN      (SID_PREVIEW_START+8)
+#define SID_PREVIEW_SCALINGFACTOR   (SID_PREVIEW_START+9)
+#define SID_PREVIEW_END			(SID_PREVIEW_START+20)
+
+//aus sfx: #define SID_KEYFUNC_START		(SID_PREVIEW_END+5)
+#define SID_CURSORDOWN_SEL		(SID_KEYFUNC_START + 0)
+#define SID_CURSORUP_SEL		(SID_KEYFUNC_START + 1)
+#define SID_CURSORLEFT_SEL		(SID_KEYFUNC_START + 2)
+#define SID_CURSORRIGHT_SEL		(SID_KEYFUNC_START + 3)
+#define SID_CURSORPAGEDOWN_SEL	(SID_KEYFUNC_START + 4)
+#define SID_CURSORPAGEUP_SEL	(SID_KEYFUNC_START + 5)
+
+#define SID_CURSORPAGELEFT_		(SID_KEYFUNC_START + 6)
+#define SID_CURSORPAGELEFT_SEL	(SID_KEYFUNC_START + 7)
+#define SID_CURSORPAGERIGHT_	(SID_KEYFUNC_START + 8)
+#define SID_CURSORPAGERIGHT_SEL	(SID_KEYFUNC_START + 9)
+
+#define SID_CURSORTOPOFFILE_SEL	(SID_KEYFUNC_START + 10)
+#define SID_CURSORENDOFFILE_SEL	(SID_KEYFUNC_START + 11)
+#define SID_CURSORHOME_SEL		(SID_KEYFUNC_START + 12)
+#define SID_CURSOREND_SEL		(SID_KEYFUNC_START + 13)
+#define SID_CURSORBLKUP			(SID_KEYFUNC_START + 14)
+#define SID_CURSORBLKDOWN		(SID_KEYFUNC_START + 15)
+#define SID_CURSORBLKLEFT		(SID_KEYFUNC_START + 16)
+#define SID_CURSORBLKRIGHT		(SID_KEYFUNC_START + 17)
+#define SID_CURSORBLKUP_SEL		(SID_KEYFUNC_START + 18)
+#define SID_CURSORBLKDOWN_SEL	(SID_KEYFUNC_START + 19)
+#define SID_CURSORBLKLEFT_SEL	(SID_KEYFUNC_START + 20)
+#define SID_CURSORBLKRIGHT_SEL	(SID_KEYFUNC_START + 21)
+
+#define SID_NEXT_TABLE			(SID_KEYFUNC_START + 22)
+#define SID_PREV_TABLE			(SID_KEYFUNC_START + 23)
+
+#define SID_NEXT_UNPROTECT		(SID_KEYFUNC_START + 24)
+#define SID_PREV_UNPROTECT		(SID_KEYFUNC_START + 25)
+
+#define SID_SELECT_COL			(SID_KEYFUNC_START + 26)
+#define SID_SELECT_ROW			(SID_KEYFUNC_START + 27)
+#define SID_SELECT_NONE			(SID_KEYFUNC_START + 28)
+#define SID_ALIGNCURSOR			(SID_KEYFUNC_START + 29)
+#define SID_MARKDATAAREA		(SID_KEYFUNC_START + 30)
+#define SID_SETINPUTMODE		(SID_KEYFUNC_START + 31)
+#define SID_DELETE_CONTENTS		(SID_KEYFUNC_START + 32)
+
+#define SID_MARKAREA			(SID_KEYFUNC_START + 33)
+
+#define SID_AUTOFILL			(SID_KEYFUNC_START + 34)
+#define FID_FILL_AUTO			(SID_KEYFUNC_START + 35)
+#define SID_CANCEL				(SID_KEYFUNC_START + 36)
+
+#define SID_CURSORENTERUP		(SID_KEYFUNC_START + 37)
+#define SID_CURSORENTERDOWN		(SID_KEYFUNC_START + 38)
+
+#define SID_MARKARRAYFORMULA    (SID_KEYFUNC_START + 39)
+
+#define SID_NEXT_TABLE_SEL      (SID_KEYFUNC_START + 40)
+#define SID_PREV_TABLE_SEL      (SID_KEYFUNC_START + 41)
+
+#define SID_KEYFUNC_END			(SID_KEYFUNC_START + 50)
+
+#define SID_NEW_SLOTS			(SID_KEYFUNC_END)
+#define SID_NEW_SLOTS_END		(SID_NEW_SLOTS+100)
+
+#define SID_NEW_TABLENAME		(SID_NEW_SLOTS+1)
+#define SID_COL_START			(SID_NEW_SLOTS+2)
+#define SID_ROW_START			(SID_NEW_SLOTS+3)
+#define SID_COL_END				(SID_NEW_SLOTS+4)
+#define SID_ROW_END				(SID_NEW_SLOTS+5)
+#define SID_KEEP_MARK			(SID_NEW_SLOTS+6)
+#define SID_FILL_DIR			(SID_NEW_SLOTS+7)
+#define SID_FILL_COUNT			(SID_NEW_SLOTS+8)
+#define SID_WITH_UNDO			(SID_NEW_SLOTS+9)
+#define FID_MERGE_TOGGLE        (SID_NEW_SLOTS+10)
+//aus sfx: #define SID_ATTR_SECIALCHAR		(SID_NEW_SLOTS+10)
+#define SID_ATTR_ROWHEADERS		(SID_NEW_SLOTS+11)
+#define SID_ATTR_COLHEADERS		(SID_NEW_SLOTS+12)
+
+#define SID_SC_CELLS			(SID_NEW_SLOTS+13)
+#define SID_SC_RANGE			(SID_NEW_SLOTS+14)
+#define SID_SC_SELECTION		(SID_NEW_SLOTS+15)
+#define SID_SC_CELLTEXT			(SID_NEW_SLOTS+16)
+
+#define SID_SC_NAME_TITLE		(SID_NEW_SLOTS+17)
+
+#define SID_SC_ACTIVECELL		(SID_NEW_SLOTS+18)
+#define SID_SC_ACTIVETAB		(SID_NEW_SLOTS+19)
+#define SID_RANGE_ROW			(SID_NEW_SLOTS+20)
+#define SID_RANGE_COL			(SID_NEW_SLOTS+21)
+#define SID_RANGE_TABLE			(SID_NEW_SLOTS+22)
+#define SID_RANGE_VALUE			(SID_NEW_SLOTS+23)
+#define SID_RANGE_FORMULA		(SID_NEW_SLOTS+24)
+#define SID_RANGE_TEXT			(SID_NEW_SLOTS+25)
+#define SID_RANGE_TEXTVALUE		(SID_NEW_SLOTS+26)
+#define SID_TABLE_ACTIVATE		(SID_NEW_SLOTS+27)
+#define SID_TABLES_GET			(SID_NEW_SLOTS+28)
+#define SID_PROP_INTERIOR		(SID_NEW_SLOTS+29)
+#define SID_PROP_FONT			(SID_NEW_SLOTS+30)
+
+#define SID_DEFINE_PRINTAREA		(SID_NEW_SLOTS+31)
+#define SID_DELETE_PRINTAREA		(SID_NEW_SLOTS+32)
+#define SID_CHANGE_PRINTAREA        (SID_NEW_SLOTS+33)
+#define SID_OPENDLG_EDIT_PRINTAREA	(SID_NEW_SLOTS+34)
+
+#define SID_OLE_OBJECT			(SID_NEW_SLOTS+35)
+#define SID_OLE_ACTIVATE		(SID_NEW_SLOTS+36)
+#define SID_OLE_DEACTIVATE		(SID_NEW_SLOTS+37)
+
+#define SID_TOGGLE_REL			(SID_NEW_SLOTS+38)
+#define SID_DATA_SELECT			(SID_NEW_SLOTS+39)
+
+//	Suchen & Ersetzen
+#define FID_SEARCH				(SID_NEW_SLOTS+40)
+#define FID_REPEAT_SEARCH		(SID_NEW_SLOTS+41)
+#define FID_REPLACE				(SID_NEW_SLOTS+42)
+#define FID_SEARCH_ALL			(SID_NEW_SLOTS+43)
+#define FID_REPLACE_ALL			(SID_NEW_SLOTS+44)
+#define FID_SEARCH_COUNT		(SID_NEW_SLOTS+45)
+
+#define SID_SC_SETTEXT			(SID_NEW_SLOTS+46)
+#define SID_RANGE_ADDRESS		(SID_NEW_SLOTS+47)
+#define SID_RANGE_OFFSET		(SID_NEW_SLOTS+48)
+#define SID_NUMBER_FORMAT		(SID_NEW_SLOTS+49)
+
+#define SID_OLE_SELECT			(SID_NEW_SLOTS+50)
+#define SID_SC_ACTIVEOBJECT		(SID_NEW_SLOTS+51)
+
+#define SID_RANGE_NOTETEXT		(SID_NEW_SLOTS+52)
+#define FID_INSERT_FILE			(SID_NEW_SLOTS+53)
+
+#define FID_VALIDATION			(SID_NEW_SLOTS+54)
+
+//	Slots fuer Toolbox Controller in der Werkzeugleiste
+#define SID_TBXCTL_INSERT		(SID_NEW_SLOTS+55)
+#define SID_TBXCTL_INSCELLS		(SID_NEW_SLOTS+56)
+#define SID_TBXCTL_INSOBJ		(SID_NEW_SLOTS+57)
+
+#define SID_DEFINE_COLROWNAMERANGES (SID_NEW_SLOTS+58)
+
+#define FID_NOTE_VISIBLE		(SID_NEW_SLOTS+59)
+
+//	Items fuer Gueltigkeit
+#define FID_VALID_MODE			(SID_NEW_SLOTS+60)
+#define FID_VALID_CONDMODE		(SID_NEW_SLOTS+61)
+#define FID_VALID_VALUE1		(SID_NEW_SLOTS+62)
+#define FID_VALID_VALUE2		(SID_NEW_SLOTS+63)
+#define FID_VALID_BLANK			(SID_NEW_SLOTS+64)
+#define FID_VALID_SHOWHELP		(SID_NEW_SLOTS+65)
+#define FID_VALID_HELPTITLE		(SID_NEW_SLOTS+66)
+#define FID_VALID_HELPTEXT		(SID_NEW_SLOTS+67)
+#define FID_VALID_SHOWERR		(SID_NEW_SLOTS+68)
+#define FID_VALID_ERRSTYLE		(SID_NEW_SLOTS+69)
+#define FID_VALID_ERRTITLE		(SID_NEW_SLOTS+70)
+#define FID_VALID_ERRTEXT		(SID_NEW_SLOTS+71)
+
+#define SID_REFRESH_DBAREA		(SID_NEW_SLOTS+72)
+#define SID_RANGE_REGION		(SID_NEW_SLOTS+73)
+
+#define FID_FOCUS_POSWND		(SID_NEW_SLOTS+74)
+
+//	einzelne Slots fuer verschiedene Unterstreich-Arten (Popup-Menu)
+#define SID_ULINE_VAL_NONE		(SID_NEW_SLOTS+75)
+#define SID_ULINE_VAL_SINGLE	(SID_NEW_SLOTS+76)
+#define SID_ULINE_VAL_DOUBLE	(SID_NEW_SLOTS+77)
+#define SID_ULINE_VAL_DOTTED	(SID_NEW_SLOTS+78)
+
+#define FID_DEL_MANUALBREAKS	(SID_NEW_SLOTS+79)
+#define SID_ADD_PRINTAREA		(SID_NEW_SLOTS+80)
+#define FID_ADJUST_PRINTZOOM	(SID_NEW_SLOTS+81)
+#define FID_RESET_PRINTZOOM		(SID_NEW_SLOTS+82)
+
+#define SID_TABLES_COUNT		(SID_NEW_SLOTS+83)
+#define SID_ACTIVE_OBJ_NAME		(SID_NEW_SLOTS+84)
+#define SID_OBJECT_LEFT			(SID_NEW_SLOTS+85)
+#define SID_OBJECT_TOP			(SID_NEW_SLOTS+86)
+#define SID_OBJECT_WIDTH		(SID_NEW_SLOTS+87)
+#define SID_OBJECT_HEIGHT		(SID_NEW_SLOTS+88)
+
+#define SID_PIVOT_CREATE		(SID_NEW_SLOTS+89)
+#define SID_PIVOT_FIELDS		(SID_NEW_SLOTS+90)
+#define SID_PFIELD_NAME			(SID_NEW_SLOTS+91)
+#define SID_PFIELD_ORIENTATION	(SID_NEW_SLOTS+92)
+#define SID_PFIELD_FUNCTION		(SID_NEW_SLOTS+93)
+#define SID_PIVOT_GET			(SID_NEW_SLOTS+94)
+
+#define SID_DELETE_SCENARIO		(SID_NEW_SLOTS+95)
+#define SID_EDIT_SCENARIO		(SID_NEW_SLOTS+96)
+
+#define SID_GET_CLPBRD_FORMAT_COUNT		(SID_NEW_SLOTS+97)
+#define SID_GET_CLPBRD_FORMAT_BY_IDX	(SID_NEW_SLOTS+98)
+#define SID_GET_CLPBRD_FORMAT_NAME		(SID_NEW_SLOTS+99)
+
+// idl Parameter ---------------------------------------------------------
+
+//aus sfx: #define FN_PARAM_1				(SC_PARAM_START)
+//aus sfx: #define FN_PARAM_2				(SC_PARAM_START+1)
+//aus sfx: #define FN_PARAM_3				(SC_PARAM_START+2)
+//aus sfx: #define FN_PARAM_4				(SC_PARAM_START+3)
+//aus sfx: #define FN_PARAM_5				(SC_PARAM_START+4)
+//aus sfx: #define FN_PARAM_6				(SC_PARAM_START+5)
+//aus sfx: #define FN_PARAM_7				(SC_PARAM_START+6)
+//aus sfx: #define FN_PARAM_8				(SC_PARAM_START+7)
+#define FN_PARAM_9				(FN_PARAM_8+1)
+
+#define SID_SORT_BYROW			(SC_PARAM_START)
+#define SID_SORT_HASHEADER		(SC_PARAM_START+1)
+#define SID_SORT_CASESENS		(SC_PARAM_START+2)
+#define SID_SORT_ATTRIBS		(SC_PARAM_START+3)
+#define SID_SORT_USERDEF		(SC_PARAM_START+4)
+
+// Resourcen -------------------------------------------------------------
+
+#define RID_OBJECTBAR_APP		(SC_RESOURCE_START)
+#define RID_OBJECTBAR_FORMAT	(SC_RESOURCE_START+1)
+#define RID_OBJECTBAR_INPUT		(SC_RESOURCE_START+2)
+#define RID_POPUP_CELLS			(SC_RESOURCE_START+3)
+#define RID_POPUP_DRAW			(SC_RESOURCE_START+4)
+#define RID_TEXT_TOOLBOX		(SC_RESOURCE_START+5)
+#define RID_OBJECTBAR_PREVIEW	(SC_RESOURCE_START+6)
+#define RID_POPUP_PREVIEW		(SC_RESOURCE_START+7)
+#define RID_POPUP_OLE			(SC_RESOURCE_START+8)
+#define RID_POPUP_CHART			(SC_RESOURCE_START+9)
+//#define RID_ANCHORBITMAP		(SC_RESOURCE_START+10)
+//#define RID_GRAYANCHORBITMAP	(SC_RESOURCE_START+11)
+#define RID_OUTLINEBITMAPS		(SC_RESOURCE_START+12)
+#define RID_DRAW_WIN			(SC_RESOURCE_START+13)
+#define RID_CNTRLR_WIN			(SC_RESOURCE_START+14)
+#define RID_GLOBSTR             (SC_RESOURCE_START+15)
+#define RID_ALIGNMENT_WIN		(SC_RESOURCE_START+19)
+#define RID_SCFUNCTIONS			(SC_RESOURCE_START+20)
+#define RID_POPUP_PIVOT			(SC_RESOURCE_START+21)
+#define RID_IMGLIST_INPUTWIN    (SC_RESOURCE_START+22)
+#define RID_ERRHDLSC			(SC_RESOURCE_START+23)
+#define RID_POPUP_GRAPHIC		(SC_RESOURCE_START+24)
+#define RID_SCTEAMDLGBMP1		(SC_RESOURCE_START+25)
+#define RID_SCTEAMDLGBMP2		(SC_RESOURCE_START+26)
+#define RID_SCTEAMDLGBMP3		(SC_RESOURCE_START+27)
+#define RID_POPUP_DRAWTEXT		(SC_RESOURCE_START+29)
+#define RID_MN_FORMAT_ALGN	 	(SC_RESOURCE_START+30)
+#define RID_MN_FORMAT_STYLE		(SC_RESOURCE_START+31)
+#define RID_MN_FORMAT_LINESPACE	(SC_RESOURCE_START+32)
+#define RID_POPUP_EDIT			(SC_RESOURCE_START+33)
+#define RID_POPUP_AUDIT			(SC_RESOURCE_START+34)
+#define RID_OBJECTBAR_TOOLS		(SC_RESOURCE_START+35)
+// free
+// free
+#define RID_TBXCTL_INSERT		(SC_RESOURCE_START+38)
+#define RID_TBXCTL_INSCELLS		(SC_RESOURCE_START+39)
+#define RID_TBXCTL_INSOBJ		(SC_RESOURCE_START+40)
+// free
+// free
+#define RID_SC_FUNCTION_DESCRIPTIONS1	(SC_RESOURCE_START+43)
+#define RID_SC_FUNCTION_DESCRIPTIONS2	(SC_RESOURCE_START+44)
+#define RID_POPUP_CONTROL		(SC_RESOURCE_START+45)
+#define RID_POPUP_PAGEBREAK		(SC_RESOURCE_START+46)
+// free
+#define RID_POPUP_DRAWFORM		(SC_RESOURCE_START+48)
+#define RID_SC_ADDIN_ROT13		(SC_RESOURCE_START+50)
+#define RID_SC_ADDIN_DFA		(SC_RESOURCE_START+51)
+#define RID_IMAGELIST_NAVCONT	(SC_RESOURCE_START+52)
+#define RID_DRAW_OBJECTBAR		(SC_RESOURCE_START+53)
+#define RID_GRAPHIC_OBJECTBAR	(SC_RESOURCE_START+54)
+// free
+// free
+#define RID_IMAGELIST_H_NAVCONT	(SC_RESOURCE_START+57)
+#define RID_OUTLINEBITMAPS_H    (SC_RESOURCE_START+58)
+#define RID_MEDIA_OBJECTBAR		(SC_RESOURCE_START+60)
+#define RID_POPUP_MEDIA			(SC_RESOURCE_START+61)
+#define RID_FUNCTION_CATEGORIES	(SC_RESOURCE_START+62)
+
+#define STR_START               (SC_RESOURCE_START+100)
+#define STR_ROWHEIGHT			(STR_START)
+#define STR_ROWHEIGHT_TITLE		(STR_START + 1)
+#define STR_OPT_ROWHEIGHT		(STR_START + 2)
+#define STR_OPT_ROWHEIGHT_TITLE	(STR_START + 3)
+#define STR_COLWIDTH			(STR_START + 4)
+#define STR_COLWIDTH_TITLE		(STR_START + 5)
+#define STR_OPT_COLWIDTH		(STR_START + 6)
+#define STR_OPT_COLWIDTH_TITLE	(STR_START + 7)
+#define	SCSTR_UNDEFINED			(STR_START + 8)
+#define	SCSTR_NONAME			(STR_START + 9)
+#define	SCSTR_NONE				(STR_START + 10)
+#define	SCSTR_EMPTY				(STR_START + 11)
+#define	SCSTR_NOTEMPTY			(STR_START + 12)
+#define SCSTR_COLUMN            (STR_START + 13)
+#define SCSTR_ROW               (STR_START + 14)
+#define SCSTR_NEW               (STR_START + 15)
+#define SCSTR_ADD               (STR_START + 16)
+#define SCSTR_REMOVE            (STR_START + 17)
+#define SCSTR_CANCEL            (STR_START + 18)
+#define SCSTR_MODIFY            (STR_START + 19)
+#define SCSTR_SHOWTABLE			(STR_START + 20)
+#define SCSTR_HIDDENTABLES		(STR_START + 21)
+#define SCSTR_SELECTDB			(STR_START + 22)
+#define SCSTR_AREAS				(STR_START + 23)
+#define SCSTR_TABLE				(STR_START + 24)
+#define SCSTR_NAME				(STR_START + 25)
+#define SCSTR_INSTABLE			(STR_START + 26)
+#define SCSTR_APDTABLE			(STR_START + 27)
+#define SCSTR_RENAMETAB			(STR_START + 28)
+#define STR_INSERTGRAPHIC		(STR_START + 29)
+//#define STR_BASIC_IDE           (STR_START + 30)
+#define SCSTR_APPLICATION		(STR_START + 31)
+#define SCSTR_DOCSHELL			(STR_START + 32)
+#define SCSTR_TABVIEWSHELL		(STR_START + 33)
+#define SCSTR_EDITSHELL			(STR_START + 34)
+#define SCSTR_DRAWSHELL			(STR_START + 35)
+#define SCSTR_DRAWTEXTSHELL		(STR_START + 36)
+#define SCSTR_NEWTABLE          (STR_START + 37)
+#define SCSTR_PREVIEWSHELL		(STR_START + 38)
+
+#define SCSTR_PROTECTDOC		(STR_START + 39)
+#define SCSTR_UNPROTECTDOC		(STR_START + 40)
+#define SCSTR_PROTECTTAB		(STR_START + 41)
+#define SCSTR_UNPROTECTTAB		(STR_START + 42)
+#define SCSTR_PASSWORD			(STR_START + 43)
+#define SCSTR_PASSWORDOPT		(STR_START + 44)
+#define SCSTR_WRONGPASSWORD		(STR_START + 45)
+
+#define SCSTR_PIVOTSHELL		(STR_START + 46)
+#define SCSTR_END				(STR_START + 47)
+#define SCSTR_STAT_PRINT		(STR_START + 48)
+
+#define SCSTR_UNKNOWN           (STR_START + 49)
+#define SCSTR_CHAR_ATTRS        (STR_START + 50)
+#define	SCSTR_ALL				(STR_START + 51)
+#define	SCSTR_STDFILTER			(STR_START + 52)
+
+// Cfg-Item-Namen
+#define SCSTR_CFG_APP           (STR_START + 53)
+#define SCSTR_CFG_DOC           (STR_START + 54)
+#define SCSTR_CFG_VIEW          (STR_START + 55)
+#define SCSTR_CFG_SPELLCHECK    (STR_START + 56)
+#define SCSTR_CFG_PRINT		    (STR_START + 57)
+
+#define SCSTR_AUDITSHELL		(STR_START + 58)
+
+#define SCSTR_CHARSET_USER		(STR_START + 59)
+#define SCSTR_COLUMN_USER		(STR_START + 60)
+#define SCSTR_FIELDSEP			(STR_START + 61)
+#define SCSTR_TEXTSEP			(STR_START + 62)
+
+#define SCSTR_30_APPLICATION	(STR_START + 63)
+#define SCSTR_30_LONG_DOCNAME	(STR_START + 64)
+
+#define SCSTR_CFG_INPUT		    (STR_START + 65)
+
+#define	SCSTR_TOP10FILTER		(STR_START + 66)
+
+#define SCSTR_CFG_NAVIPI        (STR_START + 67)
+
+#define SCSTR_40_APPLICATION	(STR_START + 68)
+#define SCSTR_40_LONG_DOCNAME	(STR_START + 69)
+
+#define SCSTR_DRAWFORMSHELL		(STR_START + 70)
+#define SCSTR_CELLSHELL			(STR_START + 71)
+#define SCSTR_FORMATSHELL		(STR_START + 72)
+#define SCSTR_OLEOBJECTSHELL	(STR_START + 73)
+#define SCSTR_CHARTSHELL		(STR_START + 74)
+#define SCSTR_GRAPHICSHELL		(STR_START + 75)
+#define SCSTR_PAGEBREAKSHELL	(STR_START + 76)
+
+#define SCSTR_GRFILTER_OPENERROR     (STR_START + 77)
+#define SCSTR_GRFILTER_IOERROR       (STR_START + 78)
+#define SCSTR_GRFILTER_FORMATERROR   (STR_START + 79)
+#define SCSTR_GRFILTER_VERSIONERROR  (STR_START + 80)
+#define SCSTR_GRFILTER_FILTERERROR   (STR_START + 81)
+#define SCSTR_GRFILTER_TOOBIG        (STR_START + 82)
+#define SCSTR_UNDO_GRAFFILTER        (STR_START + 83)
+
+#define SCSTR_50_APPLICATION	(STR_START + 84)
+#define SCSTR_50_LONG_DOCNAME	(STR_START + 85)
+#define SCSTR_CHG_PROTECT       (STR_START + 86)
+#define SCSTR_CHG_UNPROTECT     (STR_START + 87)
+
+// #98185#
+#define STR_CAPTION_DEFAULT_TEXT	(STR_START + 88)
+
+// dialog: Select Sheets
+#define STR_DLG_SELECTTABLES_TITLE  (STR_START + 89)
+#define STR_DLG_SELECTTABLES_LBNAME (STR_START + 90)
+
+// #101160# Replace cell contents warning
+#define STR_REPLCELLSWARN           (STR_START + 91)
+
+#define SCSTR_DPFUNCLISTBOX         (STR_START + 92)
+#define STR_PRINT_NOTHING           (STR_START + 93)
+#define SCSTR_ALLFILTER             (STR_START + 94)
+#define SCSTR_MOREBTN_MOREOPTIONS   (STR_START + 95)
+#define SCSTR_MOREBTN_FEWEROPTIONS   (STR_START + 96)
+
+// Items
+
+#define SCSTR_HOR_JUSTIFY_LEFT		(STR_START + 100)
+#define SCSTR_HOR_JUSTIFY_CENTER	(STR_START + 101)
+#define SCSTR_HOR_JUSTIFY_RIGHT		(STR_START + 102)
+#define SCSTR_HOR_JUSTIFY_BLOCK		(STR_START + 103)
+#define SCSTR_HOR_JUSTIFY_REPEAT	(STR_START + 104)
+#define SCSTR_HOR_JUSTIFY_STANDARD	(STR_START + 105)
+#define SCSTR_VER_JUSTIFY_TOP		(STR_START + 106)
+#define SCSTR_VER_JUSTIFY_CENTER	(STR_START + 107)
+#define SCSTR_VER_JUSTIFY_BOTTOM	(STR_START + 108)
+#define SCSTR_VER_JUSTIFY_STANDARD	(STR_START + 109)
+#define SCSTR_ORIENTATION_TOPBOTTOM	(STR_START + 110)
+#define SCSTR_ORIENTATION_BOTTOMTOP	(STR_START + 111)
+#define SCSTR_ORIENTATION_STANDARD	(STR_START + 112)
+
+// Accessibility ------------------------------------
+
+// CSV import
+#define STR_ACC_CSVRULER_NAME       (STR_START + 150)
+#define STR_ACC_CSVRULER_DESCR      (STR_START + 151)
+#define STR_ACC_CSVGRID_NAME        (STR_START + 152)
+#define STR_ACC_CSVGRID_DESCR       (STR_START + 153)
+
+// Document
+#define STR_ACC_DOC_NAME            (STR_START + 154)
+#define STR_ACC_DOC_DESCR           (STR_START + 155)
+#define STR_ACC_TABLE_NAME          (STR_START + 156)
+#define STR_ACC_TABLE_DESCR         (STR_START + 157)
+#define STR_ACC_CELL_NAME           (STR_START + 158)
+#define STR_ACC_CELL_DESCR          (STR_START + 159)
+// Preview
+#define STR_ACC_PREVIEWDOC_NAME     (STR_START + 160)
+#define STR_ACC_PREVIEWDOC_DESCR    (STR_START + 161)
+#define STR_ACC_HEADERCELL_NAME     (STR_START + 162)
+#define STR_ACC_HEADERCELL_DESCR    (STR_START + 163)
+#define STR_ACC_LEFTAREA_NAME       (STR_START + 164)
+#define STR_ACC_LEFTAREA_DESCR      (STR_START + 165)
+#define STR_ACC_CENTERAREA_NAME     (STR_START + 166)
+#define STR_ACC_CENTERAREA_DESCR    (STR_START + 167)
+#define STR_ACC_RIGHTAREA_NAME      (STR_START + 168)
+#define STR_ACC_RIGHTAREA_DESCR     (STR_START + 169)
+#define STR_ACC_HEADER_NAME         (STR_START + 170)
+#define STR_ACC_HEADER_DESCR        (STR_START + 171)
+#define STR_ACC_FOOTER_NAME         (STR_START + 172)
+#define STR_ACC_FOOTER_DESCR        (STR_START + 173)
+
+// Editline
+#define STR_ACC_EDITLINE_NAME       (STR_START + 174)
+#define STR_ACC_EDITLINE_DESCR      (STR_START + 175)
+
+// EditCell
+#define STR_ACC_EDITCELL_NAME       (STR_START + 176)
+#define STR_ACC_EDITCELL_DESCR      (STR_START + 177)
+
+// DataPilot
+#define STR_ACC_DATAPILOT_ROW_DESCR (STR_START + 178)
+#define STR_ACC_DATAPILOT_COL_DESCR (STR_START + 179)
+#define STR_ACC_DATAPILOT_DATA_DESCR (STR_START + 180)
+#define STR_ACC_DATAPILOT_SEL_DESCR (STR_START + 181)
+
+// --------------------------------------------------
+
+#define SCSTR_HUMAN_SCDOC_NAME      (STR_START + 210)
+#define SCSTR_SHORT_SCDOC_NAME      (STR_START + 211)
+#define SCSTR_LONG_SCDOC_NAME       (STR_START + 212)
+
+#define SCSTR_CLPBRD_CLEAR			(STR_START + 213)
+
+#define SCSTR_FORMULA_AUTOCORRECTION	(STR_START + 214)
+
+#define SCSTR_RENAMEOBJECT			(STR_START + 215)
+
+// Navigator - in der Reihenfolge wie SC_CONTENT_...
+#define SCSTR_CONTENT_ROOT		(STR_START + 250)
+#define SCSTR_CONTENT_TABLE		(STR_START + 251)
+#define SCSTR_CONTENT_RANGENAME	(STR_START + 252)
+#define SCSTR_CONTENT_DBAREA	(STR_START + 253)
+#define SCSTR_CONTENT_GRAPHIC	(STR_START + 254)
+#define SCSTR_CONTENT_OLEOBJECT	(STR_START + 255)
+#define SCSTR_CONTENT_NOTE		(STR_START + 256)
+#define SCSTR_CONTENT_AREALINK	(STR_START + 257)
+#define SCSTR_CONTENT_DRAWING	(STR_START + 258)
+//	hier ein wenig Platz fuer Erweiterungen
+
+// Eingabezeile, Quickhelp-Strings (HelpText jetzt per HelpId aus Hilfe)
+#define SCSTR_QHELP_INPUTWND	(STR_START + 307)
+#define SCSTR_QHELP_POSWND		(STR_START + 308)
+#define SCSTR_QHELP_BTNCALC		(STR_START + 309)
+#define SCSTR_QHELP_BTNOK		(STR_START + 310)
+#define SCSTR_QHELP_BTNCANCEL	(STR_START + 311)
+#define SCSTR_QHELP_BTNSUM		(STR_START + 312)
+#define SCSTR_QHELP_BTNEQUAL	(STR_START + 313)
+
+// Validator
+#define SCSTR_VALID_MINIMUM     (STR_START + 314)
+#define SCSTR_VALID_MAXIMUM     (STR_START + 315)
+#define SCSTR_VALID_VALUE       (STR_START + 316)
+#define SCSTR_VALID_RANGE       (STR_START + 317)
+#define SCSTR_VALID_LIST        (STR_START + 318)
+
+// Formulator
+#define SCSTR_FUDB				(STR_START + 389)
+#define SCSTR_FUDATE			(STR_START + 390)
+#define SCSTR_FUFIN				(STR_START + 391)
+#define SCSTR_FUINFO			(STR_START + 392)
+#define SCSTR_FULOG				(STR_START + 393)
+#define SCSTR_FUMATHS			(STR_START + 394)
+#define SCSTR_FUSTAT			(STR_START + 395)
+#define SCSTR_FUTAB				(STR_START + 396)
+#define SCSTR_FUTEXT			(STR_START + 397)
+//
+#define SCSTR_COMPILER_STRINGS  (STR_START + 398)
+#define SCSTR_FILTER_STRINGS    (STR_START + 399)
+#define SCSTR_COMPILER_INTL_STR (STR_START + 400)
+
+// Media shell
+#define SCSTR_MEDIASHELL		(STR_START + 401)
+
+#define RID_SCSTR_ONCLICK       (STR_START + 402)
+
+#define STR_END                 RID_SCSTR_ONCLICK
+
+#define BMP_START				(STR_END)
+
+// Navigator
+// not used anymore: RID_BMP_EXPAND, RID_BMP_COLLAPSE
+//#define    RID_BMP_EXPAND          (BMP_START)
+//#define    RID_BMP_COLLAPSE        (BMP_START + 1)
+#define RID_IMG_DROP_URL		(BMP_START + 2)
+#define RID_IMG_DROP_LINK		(BMP_START + 3)
+#define RID_IMG_DROP_COPY		(BMP_START + 4)
+#define RID_IMG_H_DROP_URL		(BMP_START + 5)
+#define RID_IMG_H_DROP_LINK		(BMP_START + 6)
+#define RID_IMG_H_DROP_COPY		(BMP_START + 7)
+
+#define RID_SCPTR_PIVOTCOL      (BMP_START + 81)
+#define RID_SCPTR_PIVOTROW      (BMP_START + 82)
+#define RID_SCPTR_DETECTIVE     (BMP_START + 83)
+#define RID_SCPTR_CHART			(BMP_START + 84)
+
+#define RID_SCICN_DOCUMENT      (BMP_START + 95)
+#define RID_SCICN_TEMPLATE      (BMP_START + 96)
+#define RID_SCICN_SC10DOC       (BMP_START + 97)
+
+#define BMP_END                 (BMP_START + 100)
+
+#define SC_DIALOGS_START		(BMP_END)
+#define RID_SCDLG_ATTR			(SC_DIALOGS_START)
+#define RID_SCPAGE_NUMBER		(SC_DIALOGS_START + 1)
+#define RID_SCPAGE_ALIGNMENT	(SC_DIALOGS_START + 2)
+#define RID_SCPAGE_PROTECTION  	(SC_DIALOGS_START + 3)
+#define RID_SCDLG_SORT			(SC_DIALOGS_START + 5)
+#define RID_SCPAGE_SORT_FIELDS	(SC_DIALOGS_START + 6)
+#define RID_SCPAGE_SORT_OPTIONS	(SC_DIALOGS_START + 7)
+#define RID_SCDLG_FILTER		(SC_DIALOGS_START + 8)
+#define RID_SCDLG_SPEC_FILTER	(SC_DIALOGS_START + 9)
+#define RID_SCMISCDLGS			(SC_DIALOGS_START + 10)
+#define RID_SCDLG_DELCELL		(SC_DIALOGS_START + 11)
+#define RID_SCDLG_INSCELL		(SC_DIALOGS_START + 12)
+#define RID_SCDLG_DELCONT		(SC_DIALOGS_START + 13)
+#define RID_SCDLG_INSCONT		(SC_DIALOGS_START + 14)
+#define RID_SCDLG_MOVETAB		(SC_DIALOGS_START + 15)
+#define RID_SCDLG_STRINPUT		(SC_DIALOGS_START + 16)
+#define RID_SCDLG_MTRINPUT		(SC_DIALOGS_START + 17)
+#define RID_SCDLG_SELENTRY		(SC_DIALOGS_START + 18)
+#define RID_SCDLG_FILLSERIES	(SC_DIALOGS_START + 19)
+#define RID_SCDLG_AUTOFORMAT    (SC_DIALOGS_START + 20)
+#define RID_SCDLG_GROUP         (SC_DIALOGS_START + 21)
+#define RID_SCDLG_NAMES         (SC_DIALOGS_START + 22)
+#define RID_SCDLG_DBNAMES       (SC_DIALOGS_START + 23)
+#define RID_SCDLG_PRINTOPTIONS  (SC_DIALOGS_START + 24)
+#define RID_SCPAGE_PRINTOPTIONS (SC_DIALOGS_START + 25)
+#define RID_SCDLG_SOLVER        (SC_DIALOGS_START + 26)
+#define RID_SCDLG_SUBTOTALS		(SC_DIALOGS_START + 27)
+#define RID_SUBTBASE			(SC_DIALOGS_START + 28)
+#define RID_SCPAGE_SUBT_OPTIONS	(SC_DIALOGS_START + 29)
+#define RID_SCDLG_OPTIONS       (SC_DIALOGS_START + 30)
+#define RID_SCPAGE_USERLISTS    (SC_DIALOGS_START + 31)
+#define RID_SCDLG_PIVOTFILTER   (SC_DIALOGS_START + 33)
+#define RID_SCDLG_PIVOT_LAYOUT  (SC_DIALOGS_START + 34)
+#define RID_SCDLG_CONSOLIDATE   (SC_DIALOGS_START + 35)
+#define RID_SCTBXWND_SCENARIO   (SC_DIALOGS_START + 36)
+#define RID_SCDLG_FORMULATOR	(SC_DIALOGS_START + 37)
+#define RID_SCDLG_PIVOTSUBT     (SC_DIALOGS_START + 38)
+#define RID_SCDLG_NEWSCENARIO   (SC_DIALOGS_START + 39)
+#define RID_SCDLG_FORMULA		(SC_DIALOGS_START + 40)
+#define RID_SCDLG_ARGUMENTS     (SC_DIALOGS_START + 41)
+#define RID_SCDLG_INSERT_TABLE  (SC_DIALOGS_START + 42)
+#define RID_SCPAGE_TABLE        (SC_DIALOGS_START + 43)
+#define RID_SCPAGE_AREAS        (SC_DIALOGS_START + 44)
+#define RID_SCDLG_STYLES_START	(SC_DIALOGS_START + 45)
+#define RID_SCDLG_STYLES_CHAR	(SC_DIALOGS_START + 45)
+#define RID_SCDLG_STYLES_PAR	(SC_DIALOGS_START + 46)
+#define RID_SCDLG_STYLES_FRAME	(SC_DIALOGS_START + 47)
+#define RID_SCDLG_STYLES_PAGE	(SC_DIALOGS_START + 48)
+#define RID_SCDLG_STYLES_END	(SC_DIALOGS_START + 48)
+#define RID_HFBASE			    (SC_DIALOGS_START + 49)
+#define RID_SCDLG_HFEDIT	    (SC_DIALOGS_START + 50)
+#define RID_SCDLG_HFEDIT_ALL    (SC_DIALOGS_START + 51)
+#define RID_SCDLG_HFED_HEADER   (SC_DIALOGS_START + 52)
+#define RID_SCDLG_HFED_FOOTER	(SC_DIALOGS_START + 53)
+#define RID_SCBTN_HFEDIT        (SC_DIALOGS_START + 54)
+#define RID_SCPAGE_VIEW		    (SC_DIALOGS_START + 55)
+#define RID_SCPAGE_CALC		    (SC_DIALOGS_START + 56)
+#define RID_SCDLG_NAVIGATOR	    (SC_DIALOGS_START + 57)
+#define RID_SCDLG_TABOP		    (SC_DIALOGS_START + 58)
+#define RID_SCDLG_IMPORTOPT		(SC_DIALOGS_START + 59)
+#define RID_POPUP_ROWHEADER     (SC_DIALOGS_START + 60)
+#define RID_POPUP_COLHEADER     (SC_DIALOGS_START + 61)
+#define RID_SCDLG_HFEDIT_SHDR   (SC_DIALOGS_START + 62)
+#define RID_SCDLG_HFEDIT_SFTR   (SC_DIALOGS_START + 63)
+#define RID_SCDLG_HFEDIT_LEFTHEADER	    (SC_DIALOGS_START + 64)
+#define RID_SCDLG_HFEDIT_RIGHTHEADER    (SC_DIALOGS_START + 65)
+#define RID_SCDLG_HFEDIT_LEFTFOOTER	    (SC_DIALOGS_START + 66)
+#define RID_SCDLG_HFEDIT_RIGHTFOOTER	(SC_DIALOGS_START + 67)
+#define RID_SCDLG_HFEDIT_HEADER		    (SC_DIALOGS_START + 68)
+#define RID_SCDLG_HFEDIT_FOOTER			(SC_DIALOGS_START + 69)
+#define RID_SCPAGE_PRINT				(SC_DIALOGS_START + 70)
+#define RID_SCDLG_COLORROW              (SC_DIALOGS_START + 71)
+#define RID_SCDLG_NAMES_PASTE           (SC_DIALOGS_START + 72)
+#define RID_SCDLG_NAMES_CREATE          (SC_DIALOGS_START + 73)
+#define RID_SCDLG_NAMES_APPLY           (SC_DIALOGS_START + 74) //NYI
+#define RID_SCDLG_TEAM		            (SC_DIALOGS_START + 75)
+
+#define RID_SCDLG_CHAR			        (SC_DIALOGS_START + 76)
+#define RID_SCDLG_PARAGRAPH		        (SC_DIALOGS_START + 77)
+//#define RID_SCDLG_CHARTRANGE	        (SC_DIALOGS_START + 78)
+
+#define RID_SCPAGE_STAT		    		(SC_DIALOGS_START + 79)
+#define RID_SCDLG_CHARTCOLROW	        (SC_DIALOGS_START + 80)
+#define RID_SCDLG_AREAS					(SC_DIALOGS_START + 81)
+
+#define RID_SCDLG_EDITCHAR		        (SC_DIALOGS_START + 82)
+
+	//	Popup fuer Statusbar-Controller
+#define RID_POPUP_SUMCTL				(SC_DIALOGS_START + 83)
+#define RID_SUMCTL_SUM					(SC_DIALOGS_START + 84)
+#define RID_SUMCTL_MIN					(SC_DIALOGS_START + 85)
+#define RID_SUMCTL_MAX					(SC_DIALOGS_START + 86)
+#define RID_SUMCTL_COUNT				(SC_DIALOGS_START + 87)
+#define RID_SUMCTL_COUNT2				(SC_DIALOGS_START + 88)
+#define RID_SUMCTL_AVG					(SC_DIALOGS_START + 89)
+#define RID_SUMCTL_NONE					(SC_DIALOGS_START + 90)
+
+#define RID_SCDLG_ASCII			        (SC_DIALOGS_START + 91)
+
+	//	Popup fuer Drop-Modus im Navigator
+#define RID_POPUP_DROPMODE				(SC_DIALOGS_START + 92)
+#define RID_DROPMODE_URL				(SC_DIALOGS_START + 93)
+#define RID_DROPMODE_LINK				(SC_DIALOGS_START + 94)
+#define RID_DROPMODE_COPY				(SC_DIALOGS_START + 95)
+#define RID_SCDLG_CONDFORMAT			(SC_DIALOGS_START + 96)
+
+#define RID_SCPAGE_SUBT_GROUP1			(SC_DIALOGS_START + 97)
+#define RID_SCPAGE_SUBT_GROUP2			(SC_DIALOGS_START + 98)
+#define RID_SCPAGE_SUBT_GROUP3			(SC_DIALOGS_START + 99)
+
+#define RID_SCPAGE_HFED_HL				(SC_DIALOGS_START + 100)
+#define RID_SCPAGE_HFED_HR				(SC_DIALOGS_START + 101)
+#define RID_SCPAGE_HFED_FL				(SC_DIALOGS_START + 102)
+#define RID_SCPAGE_HFED_FR				(SC_DIALOGS_START + 103)
+
+// Ableitungen von RID_SCDLG_MTRINPUT
+#define RID_SCDLG_COL_MAN				(SC_DIALOGS_START + 104)
+#define RID_SCDLG_COL_OPT				(SC_DIALOGS_START + 105)
+#define RID_SCDLG_ROW_MAN				(SC_DIALOGS_START + 106)
+#define RID_SCDLG_ROW_OPT				(SC_DIALOGS_START + 107)
+
+// Ableitungen von RID_SCDLG_SELENTRY
+#define RID_SCDLG_SELECTDB				(SC_DIALOGS_START + 108)
+#define RID_SCDLG_SHOW_TAB				(SC_DIALOGS_START + 109)
+
+// Ableitungen von RID_SCDLG_GROUP
+#define RID_SCDLG_GRP_MAKE				(SC_DIALOGS_START + 110)
+#define RID_SCDLG_GRP_KILL				(SC_DIALOGS_START + 111)
+
+#define RID_SCDLG_COLROWNAMERANGES		(SC_DIALOGS_START + 112)
+
+#define RID_SCPAGE_CONTENT				(SC_DIALOGS_START + 113)
+#define RID_SCPAGE_LAYOUT               (SC_DIALOGS_START + 114)
+#define RID_SCPAGE_INPUT				(SC_DIALOGS_START + 115)
+
+#define RID_SCTAB_PARAMETER				(SC_DIALOGS_START + 116)
+#define RID_SCTAB_FUNCTION				(SC_DIALOGS_START + 117)
+#define RID_SCTAB_STRUCT				(SC_DIALOGS_START + 118)
+
+#define RID_SCDLG_CHANGES				(SC_DIALOGS_START + 119)
+
+#define RID_POPUP_NAVIPI_SCENARIO		(SC_DIALOGS_START + 120)
+#define RID_NAVIPI_SCENARIO_DELETE		(SC_DIALOGS_START + 121)
+#define RID_NAVIPI_SCENARIO_EDIT		(SC_DIALOGS_START + 122)
+
+#define RID_SCDLG_HIGHLIGHT_CHANGES		(SC_DIALOGS_START + 123)
+#define RID_SCPAGE_OPREDLINE			(SC_DIALOGS_START + 124)
+
+#define RID_SCDLG_SIMPLEREF				(SC_DIALOGS_START + 125)
+#define WID_SIMPLE_REF					(SC_DIALOGS_START + 126)
+#define RID_POPUP_CHANGES				(SC_DIALOGS_START + 127)
+#define RID_SCPAGE_OPTLOAD				(SC_DIALOGS_START + 128)
+
+#define RID_SCDLG_DAPITYPE				(SC_DIALOGS_START + 129)
+#define RID_SCDLG_DAPISERVICE			(SC_DIALOGS_START + 130)
+#define RID_SCDLG_DAPIDATA				(SC_DIALOGS_START + 131)
+
+#define RID_SCDLG_LINKAREA				(SC_DIALOGS_START + 132)
+#define RID_SCDLG_DPDATAFIELD           (SC_DIALOGS_START + 133)
+#define RID_SCDLG_DPSUBTOTAL_OPT        (SC_DIALOGS_START + 134)
+#define RID_SCDLG_DPNUMGROUP            (SC_DIALOGS_START + 135)
+#define RID_SCDLG_DPDATEGROUP           (SC_DIALOGS_START + 136)
+#define RID_SCDLG_DPSHOWDETAIL          (SC_DIALOGS_START + 137)
+#define RID_SCDLG_OPTSOLVER             (SC_DIALOGS_START + 138)
+#define RID_SCDLG_SOLVEROPTIONS         (SC_DIALOGS_START + 139)
+#define RID_SCDLG_SOLVER_INTEGER        (SC_DIALOGS_START + 140)
+#define RID_SCDLG_SOLVER_DOUBLE         (SC_DIALOGS_START + 141)
+#define RID_SCDLG_SOLVER_PROGRESS       (SC_DIALOGS_START + 142)
+#define RID_SCDLG_SOLVER_NOSOLUTION     (SC_DIALOGS_START + 143)
+#define RID_SCDLG_SOLVER_SUCCESS        (SC_DIALOGS_START + 144)
+
+#define RID_SCDLG_CONFLICTS             (SC_DIALOGS_START + 145)
+#define RID_SCDLG_SHAREDOCUMENT         (SC_DIALOGS_START + 146)
+#define RID_SCDLG_SORT_WARNING          (SC_DIALOGS_START + 147)
+#define RID_SCDLG_TABPROTECTION         (SC_DIALOGS_START + 148)
+#define RID_SCDLG_DOCPROTECTION         (SC_DIALOGS_START + 149)
+#define RID_SCDLG_RETYPEPASS            (SC_DIALOGS_START + 150)
+#define RID_SCDLG_RETYPEPASS_INPUT      (SC_DIALOGS_START + 151)
+
+#define SC_DIALOGS_END          (SC_DIALOGS_START + 152)
+
+#ifndef STD_MASKCOLOR
+#define STD_MASKCOLOR Color { Red = 0xFF00; Green = 0x0000; Blue = 0xFF00; }
+#endif
+
+// mask color for high contrast
+#define SC_HC_MASKCOLOR STD_MASKCOLOR
+
+#define MID_1   1
+#define MID_2   2
+#define MID_3   3
+#define MID_4   4
+
+#define SC_OOO_BUILD_START          (SC_DIALOGS_END)
+
+// Data Form
+#define SID_DATAFORM_NEW            (SC_OOO_BUILD_START + 1) // message
+#define SID_DATA_FORM               (SC_OOO_BUILD_START + 2) // menu (in Data menu)
+#define RID_SCDLG_DATAFORM          (SC_OOO_BUILD_START + 3) // dialog
+
+#endif
+
+
Index: sc/inc/shapeuno.hxx
===================================================================
--- sc/inc/shapeuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/inc/shapeuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -55,6 +55,7 @@
 class SdrObject;
 struct SvEventDescription;
 class ShapeUnoEventAccessImpl;
+class  ScMacroInfo;
 
 //------------------------------------------------------------------------
 
@@ -73,6 +74,7 @@
                     ,public ScShapeObj_TextBase
 {
 private:
+friend  ScMacroInfo* lcl_getShapeHyperMacroInfo( ScShapeObj* pShape, BOOL bCreate );
 	::com::sun::star::uno::Reference< ::com::sun::star::uno::XAggregation > mxShapeAgg;
     // cached pointers to avoid repeated queryAggregation calls:
     ::com::sun::star::beans::XPropertySet*                                  pShapePropertySet;
Index: sc/inc/macromgr.hxx
===================================================================
--- sc/inc/macromgr.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sc/inc/macromgr.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.115.36.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_MACROMGR_HXX
+#define SC_MACROMGR_HXX
+
+#include <com/sun/star/container/XContainerListener.hpp>
+
+#include "rtl/ustring.hxx"
+#include "scdllapi.h"
+
+#include <hash_map>
+#include <memory>
+
+class ScDocument;
+class ScFormulaCell;
+class ScUserMacroDepTracker;
+
+class ScMacroManager
+{
+public:
+    explicit ScMacroManager(ScDocument* pDoc);
+    ~ScMacroManager();
+
+    SC_DLLPUBLIC void InitUserFuncData();
+    SC_DLLPUBLIC void SetUserFuncVolatile( const rtl::OUString& sName, bool isVolatile );
+    SC_DLLPUBLIC bool GetUserFuncVolatile( const rtl::OUString& sName );
+
+    void AddDependentCell(const ::rtl::OUString& aModuleName, ScFormulaCell* pCell);
+    void RemoveDependentCell(ScFormulaCell* pCell);
+    void BroadcastModuleUpdate(const ::rtl::OUString& aModuleName);
+
+private:
+    typedef std::hash_map< ::rtl::OUString, bool, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > NameBoolMap;
+    NameBoolMap mhFuncToVolatile;
+    com::sun::star::uno::Reference< com::sun::star::container::XContainerListener > mxContainerListener;
+
+    ::std::auto_ptr<ScUserMacroDepTracker> mpDepTracker;
+    ScDocument* mpDoc;
+};
+
+#endif
+
Index: sc/prj/build.lst
===================================================================
--- sc/prj/build.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,4 +1,4 @@
-sc	sc	:	l10n oovbaapi svx stoc uui BOOST:boost formula oox NULL
+sc     sc      :       l10n vbahelper oovbaapi svx stoc uui BOOST:boost formula oox NULL
 sc	sc							usr1	-	all	sc_mkout NULL
 sc	sc\inc							nmake	-	all	sc_inc NULL
 sc	sc\prj							get	-	all	sc_prj NULL
@@ -33,7 +33,7 @@
 sc	sc\source\ui\unoobj					nmake	-	all	sc_unobj sc_sdi sc_inc NULL
 sc	sc\source\ui\vba					nmake	-	all	sc_vba sc_sdi sc_inc NULL
 sc	sc\source\ui\view					nmake	-	all	sc_view sc_sdi sc_inc NULL
-sc	sc\source\filter\excel					nmake	-	all	sc_excel sc_sdi sc_inc NULL
+sc	sc\source\filter\excel					nmake	-	all	sc_excel sc_vba sc_sdi sc_inc NULL
 sc	sc\source\filter\ftools					nmake	-	all	sc_ftools sc_sdi sc_inc NULL
 sc	sc\source\filter\lotus					nmake	-	all	sc_lotus sc_sdi sc_inc NULL
 sc	sc\source\filter\qpro					nmake	-	all	sc_qpro sc_sdi sc_inc NULL
Index: sc/util/makefile.mk
===================================================================
--- sc/util/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sc/util/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -78,6 +78,7 @@
 
 # dynamic libraries
 SHL1STDLIBS=       \
+		$(VBAHELPERLIB) \
 	$(BASICLIB)	\
 	$(SFXLIB)		\
 	$(SVTOOLLIB)	\
@@ -276,6 +277,7 @@
 		$(SLO)$/filldlg.obj			\
 		$(SLO)$/delcodlg.obj		\
 		$(SLO)$/delcldlg.obj		\
+		$(SLO)$/datafdlg.obj		\
 		$(SLO)$/dapitype.obj	\
 		$(SLO)$/dapidata.obj	\
 		$(SLO)$/crdlg.obj			\
@@ -300,6 +302,7 @@
 .ENDIF
 
 SHL9STDLIBS= \
+		$(VBAHELPERLIB) \
 		$(CPPUHELPERLIB) \
 		$(VCLLIB) \
 		$(CPPULIB) \
@@ -315,6 +318,7 @@
 		$(ISCLIB) \
         $(VCLLIB) \
         $(TKLIB) \
+	    $(SVXMSFILTERLIB)		\
         $(FORLIB)
 
 SHL9DEPN=$(SHL1TARGETN) $(SHL8TARGETN)
@@ -333,6 +337,7 @@
 
 .INCLUDE :  target.mk
 
+COMP=
 .IF "$(VBA_EXTENSION)"=="YES"
     COMP=build_extn
 .ENDIF
Index: basic/source/uno/namecont.cxx
===================================================================
--- basic/source/uno/namecont.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/uno/namecont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -76,6 +76,9 @@
 #include <cppuhelper/exc_hlp.hxx>
 #include <basic/sbmod.hxx>
 
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
 
 namespace basic
 {
@@ -155,7 +158,7 @@
 	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -197,7 +200,7 @@
 	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
 	Type aAnyType = aElement.getValueType();
-	if( mType != aAnyType )
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
 		throw IllegalArgumentException();
 
 	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
@@ -2719,6 +2722,39 @@
     }
 }
 
+::sal_Bool SAL_CALL SfxLibraryContainer::getVBACompatModeOn() throw (RuntimeException)
+{
+	sal_Bool bVBACompat = sal_False;
+	BasicManager* pBasMgr = getBasicManager();
+	if( pBasMgr )
+	{
+		// get the standard library
+		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
+                if ( pBasMgr->GetName().Len() )
+                    aLibName = pBasMgr->GetName();
+
+		StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
+		if( pBasic )
+			bVBACompat = pBasic->isVBAEnabled();
+	}
+
+	return bVBACompat;
+}
+
+void SAL_CALL SfxLibraryContainer::setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (RuntimeException)
+{
+	BasicManager* pBasMgr = getBasicManager();
+	if( pBasMgr )
+	{
+		// get the standard library
+		String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+		StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
+		if( pBasic )
+			pBasic->SetVBAEnabled( _vbacompatmodeon );
+	}
+}
+
 // Methods XServiceInfo
 ::sal_Bool SAL_CALL SfxLibraryContainer::supportsService( const ::rtl::OUString& _rServiceName )
     throw (RuntimeException)
Index: basic/source/uno/scriptcont.cxx
===================================================================
--- basic/source/uno/scriptcont.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/uno/scriptcont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -67,7 +67,8 @@
 #include <xmlscript/xmlmod_imexp.hxx>
 #include <cppuhelper/factory.hxx>
 #include <com/sun/star/util/VetoException.hpp>
-
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
+#include <cppuhelper/implbase1.hxx>
 namespace basic
 {
 
@@ -138,7 +139,6 @@
     return pImplLib->mbPasswordProtected;
 }
 
-
 // Ctor for service
 SfxScriptLibraryContainer::SfxScriptLibraryContainer( void )
     :maScriptLanguage( RTL_CONSTASCII_USTRINGPARAM( "StarBasic" ) )
@@ -214,7 +214,12 @@
 	xmlscript::ModuleDescriptor aMod;
 	aMod.aName = aElementName;
 	aMod.aLanguage = maScriptLanguage;
-	aElement >>= aMod.aCode;
+	// make sure we export source
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		aMod.aCode = mInfo.ModuleSource;
+	else
+		aElement >>= aMod.aCode;
 	xmlscript::exportScriptModule( xHandler, aMod );
 }
 
@@ -1050,6 +1055,17 @@
 {
 }
 
+sal_Bool SAL_CALL
+SfxScriptLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	BasicManager* pBasicMgr = getBasicManager();
+    	OSL_ENSURE( pBasicMgr, "we need a basicmanager, really we do" );
+	if ( pBasicMgr )
+		return pBasicMgr->HasExeCode( Library ); // need to change this to take name
+	// default to it has code if we can't decide
+	return sal_True;
+}
+
 //============================================================================
 // Service
 void createRegistryInfo_SfxScriptLibraryContainer()
@@ -1160,7 +1176,11 @@
 bool SfxScriptLibrary::containsValidModule( const Any& aElement )
 {
 	OUString sModuleText;
-	aElement >>= sModuleText;
+	::com::sun::star::script::ModuleInfo mInfo;
+	if ( aElement >>= mInfo )
+		sModuleText = mInfo.ModuleSource;
+	else
+		aElement >>= sModuleText;
 	return ( sModuleText.getLength() > 0 );
 }
 
Index: basic/source/uno/dlgcont.cxx
===================================================================
--- basic/source/uno/dlgcont.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/uno/dlgcont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -322,7 +322,7 @@
 	
 	try {
 		// start parsing 
-		xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext ) );
+		xParser->setDocumentHandler( ::xmlscript::importDialogModel( xDialogModel, xContext, mxOwnerDocument ) );
 		xParser->parseStream( source );
 	}
 	catch( Exception& )
@@ -336,7 +336,7 @@
 
 	// Create InputStream, TODO: Implement own InputStreamProvider
 	// to avoid creating the DialogModel here!
-	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, mxOwnerDocument );
 	aRetAny <<= xISP;
 	return aRetAny;
 }
@@ -484,7 +484,11 @@
 	}
 }
 
-
+sal_Bool SAL_CALL
+SfxDialogLibraryContainer:: HasExecutableCode( const ::rtl::OUString& Library ) throw (uno::RuntimeException)
+{
+	return sal_False; // dialog library has no executable code
+}
 //============================================================================
 // Service
 
Index: basic/source/runtime/runtime.cxx
===================================================================
--- basic/source/runtime/runtime.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/runtime.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -46,13 +46,17 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include "sbunoobj.hxx"
+#include "errobject.hxx"
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 bool SbiRuntime::isVBAEnabled()
 {
 	bool result = false;
 	SbiInstance* pInst = pINST;
 	if ( pInst && pINST->pRun )
-		result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		//result = pInst->pRun->GetImageFlag( SBIMG_VBASUPPORT );
+		result = pInst->pRun->bVBAEnabled;
 	return result; 
 }
 
@@ -63,8 +67,26 @@
 {
     bStaticGlobalEnableReschedule = bReschedule;
 }
+void StarBASIC::SetVBAEnabled( BOOL bEnabled )
+{
+    if ( bDocBasic )
+    {
+        bVBAEnabled = bEnabled;
+    }
+}
 
+BOOL StarBASIC::isVBAEnabled()
+{
+    if ( bDocBasic )
+    { 
+        if( SbiRuntime::isVBAEnabled() )
+            return TRUE;
+        return bVBAEnabled;
+    }
+    return FALSE;
+}
 
+
 struct SbiArgvStack {					// Argv stack:
 	SbiArgvStack*  pNext;	   			// Stack Chain
 	SbxArrayRef    refArgv;	 			// Argv
@@ -495,7 +517,7 @@
 
 SbiRuntime::SbiRuntime( SbModule* pm, SbMethod* pe, UINT32 nStart )
 		 : rBasic( *(StarBASIC*)pm->pParent ), pInst( pINST ), 
-		   pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), m_nLastTime(0)
+		   pMod( pm ), pMeth( pe ), pImg( pMod->pImage ), mpExtCaller(0), m_nLastTime(0)
 {
 	nFlags	  = pe ? pe->GetDebugFlags() : 0;
 	pIosys	  = pInst->pIosys;
@@ -523,6 +545,7 @@
 	nForLvl   = 0;
 	nOps	  = 0;
 	refExprStk = new SbxArray;
+	SetVBAEnabled( pMod->IsVBACompat() );
 #if defined GCC
 	SetParameters( pe ? pe->GetParameters() : (class SbxArray *)NULL );
 #else
@@ -530,7 +553,6 @@
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
-	bVBAEnabled = isVBAEnabled();
 }
 
 SbiRuntime::~SbiRuntime()
@@ -549,6 +571,18 @@
 	}
 }
 
+void SbiRuntime::SetVBAEnabled(bool bEnabled )
+{
+	bVBAEnabled = bEnabled; 
+	if ( bVBAEnabled )
+	{
+		if ( pMeth )
+			mpExtCaller = pMeth->mCaller;
+	}
+	else
+		mpExtCaller = 0;
+}
+
 // Aufbau der Parameterliste. Alle ByRef-Parameter werden direkt
 // uebernommen; von ByVal-Parametern werden Kopien angelegt. Falls
 // ein bestimmter Datentyp verlangt wird, wird konvertiert.
@@ -797,7 +831,38 @@
 void SbiRuntime::Error( SbError n )
 {
 	if( n )
+	{
 		nError = n;
+		if ( isVBAEnabled() )
+		{
+			String aMsg = pInst->GetErrorMsg();
+			// If a message is defined use that ( in preference to
+			// the defined one for the error ) NB #TODO
+			// if there is an error defined it more than likely
+			// is not the one you want ( some are the same though )
+			// we really need a new vba compatible error list
+			if ( !aMsg.Len() )
+			{
+				StarBASIC::MakeErrorText( n, aMsg );	
+				aMsg =  StarBASIC::GetErrorText();
+				if ( !aMsg.Len() ) // no message for err no.
+					// need localized resource here
+					aMsg = String( RTL_CONSTASCII_USTRINGPARAM("Internal Object Error:") );
+			}
+			// no num? most likely then it *is* really a vba err
+			SbxErrObject::getUnoErrObject()->setNumber( ( StarBASIC::GetVBErrorCode( n ) == 0 ) ? n : StarBASIC::GetVBErrorCode( n ) );
+			SbxErrObject::getUnoErrObject()->setDescription( aMsg );
+
+			// prepend an error number to the message.
+			String aTmp = '\'';
+                        aTmp += String::CreateFromInt32( SbxErrObject::getUnoErrObject()->getNumber() );
+                        aTmp += String( RTL_CONSTASCII_USTRINGPARAM("\'\n") );
+                        aTmp += aMsg;
+
+			pInst->aErrorMsg = aTmp;
+			nError = SbERR_BASIC_COMPAT;
+		}
+	}
 }
 
 void SbiRuntime::Error( SbError _errCode, const String& _details )
@@ -917,8 +982,26 @@
 void SbiRuntime::TOSMakeTemp()
 {
 	SbxVariable* p = refExprStk->Get( nExprLvl - 1 );
-	if( p->GetRefCount() != 1 )
+	if ( p->GetType() == SbxEMPTY )
+		p->Broadcast( SBX_HINT_DATAWANTED );
+
+	SbxVariable* pDflt = NULL;
+	if ( bVBAEnabled &&  ( p->GetType() == SbxOBJECT || p->GetType() == SbxVARIANT  ) && ( pDflt = getDefaultProp( p ) ) )
 	{
+		pDflt->Broadcast( SBX_HINT_DATAWANTED );
+		// replacing new p on stack causes object pointed by 
+		// pDft->pParent to be deleted, when p2->Compute() is
+		// called below pParent is accessed ( but its deleted )
+		// so set it to NULL now
+		pDflt->SetParent( NULL );  
+		p = new SbxVariable( *pDflt );
+		p->SetFlag( SBX_READWRITE );
+		refExprStk->Put( p, nExprLvl - 1 );
+//		return;
+	}
+
+	else if( p->GetRefCount() != 1 )
+	{
 		SbxVariable* pNew = new SbxVariable( *p );
 		pNew->SetFlag( SBX_READWRITE );
 		refExprStk->Put( pNew, nExprLvl - 1 );
@@ -926,7 +1009,6 @@
 }
 
 // Der GOSUB-Stack nimmt Returnadressen fuer GOSUBs auf
-
 void SbiRuntime::PushGosub( const BYTE* pc )
 {
 	if( ++nGosubLvl > MAXRECURSION )
Index: basic/source/runtime/methods1.cxx
===================================================================
--- basic/source/runtime/methods1.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/methods1.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,6 +44,7 @@
 #ifndef _SBX_HXX
 #include <basic/sbx.hxx>
 #endif
+#include <basic/sbstar.hxx>
 #include <svtools/zforlist.hxx>
 #include <tools/fsys.hxx>
 #include <tools/urlobj.hxx>
@@ -64,6 +65,7 @@
 #endif
 
 #include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include "sbintern.hxx"
 #include "runtime.hxx"
@@ -80,11 +82,15 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/i18n/XCalendar.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
 
 using namespace comphelper;
+using namespace com::sun::star::sheet;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::i18n;
 
+void unoToSbxValue( SbxVariable* pVar, const Any& aValue );
+Any sbxToUnoValue( SbxVariable* pVar, const Type& rType, com::sun::star::beans::Property* pUnoProperty = NULL );
 
 static Reference< XCalendar > getLocaleCalendar( void )
 {
@@ -2506,6 +2512,546 @@
 	rPar.Get(0)->PutDouble( dRes );
 }
 
+void CallFunctionAccessFunction( const Sequence< Any >& aArgs, const rtl::OUString& sFuncName, SbxVariable* pRet )
+{
+    static Reference< XFunctionAccess > xFunc;
+    Any aRes;
+    try
+    {
+        if ( !xFunc.is() )
+        {
+            Reference< XMultiServiceFactory > xFactory( getProcessServiceFactory() );
+            if( xFactory.is() )
+            {
+                xFunc.set( xFactory->createInstance(::rtl::OUString::createFromAscii( "com.sun.star.sheet.FunctionAccess")), UNO_QUERY_THROW); 
+            }
+        }
+        Any aRet = xFunc->callFunction( sFuncName, aArgs );
+     
+        unoToSbxValue( pRet, aRet );
+
+    }
+    catch( Exception& )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+    }
+}
+
+RTLFUNC(SYD)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 4 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    aParams[ 3 ] <<= makeAny( rPar.Get(4)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SYD") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(SLN)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SLN") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Pmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Pmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetDouble();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(PV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= makeAny( rPar.Get(1)->GetDouble() );
+    Any aValues = sbxToUnoValue( rPar.Get(2),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 1 ] <<= aValues;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(NPer)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double pmt = rPar.Get(2)->GetDouble();
+    double pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NPer") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(MIRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+
+    // retrieve non-optional params
+
+    Sequence< Any > aParams( 3 );
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= makeAny( rPar.Get(2)->GetDouble() );
+    aParams[ 2 ] <<= makeAny( rPar.Get(3)->GetDouble() );
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("MIRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IRR)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 1 || nArgCount > 2 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+    Any aValues = sbxToUnoValue( rPar.Get(1),
+                getCppuType( (Sequence<double>*)0 ) );
+
+    // convert for calc functions
+    Sequence< Sequence< double > > sValues(1);
+    aValues >>= sValues[ 0 ];
+    aValues <<= sValues;
+
+    // set default values for Optional args
+    double guess = 0.1;    
+    // guess
+    if ( nArgCount >= 2 )
+    {
+        if( rPar.Get(2)->GetType() != SbxEMPTY )
+            guess = rPar.Get(2)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 2 );
+    aParams[ 0 ] <<= aValues;
+    aParams[ 1 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IRR") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(IPmt)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double per = rPar.Get(2)->GetInteger();
+    double nper = rPar.Get(3)->GetDouble();
+    double pv = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    
+    // fv
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            fv = rPar.Get(5)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= per;
+    aParams[ 2 ] <<= nper;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= fv;
+    aParams[ 5 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IPmt") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(FV)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double rate = rPar.Get(1)->GetDouble();
+    double nper = rPar.Get(2)->GetDouble();
+    double pmt = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double pv = 0;    
+    double type = 0;    
+    
+    // pv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            pv = rPar.Get(4)->GetDouble();
+    }
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= rate;
+    aParams[ 1 ] <<= nper;
+    aParams[ 2 ] <<= pmt;
+    aParams[ 3 ] <<= pv;
+    aParams[ 4 ] <<= type;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FV") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(DDB)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 4 || nArgCount > 5 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double cost = rPar.Get(1)->GetDouble();
+    double salvage = rPar.Get(2)->GetDouble();
+    double life = rPar.Get(3)->GetDouble();
+    double period = rPar.Get(4)->GetDouble();
+
+    // set default values for Optional args
+    double factor = 2;    
+    
+    // factor
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            factor = rPar.Get(5)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 5 );
+    aParams[ 0 ] <<= cost;
+    aParams[ 1 ] <<= salvage;
+    aParams[ 2 ] <<= life;
+    aParams[ 3 ] <<= period;
+    aParams[ 4 ] <<= factor;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DDB") ), rPar.Get( 0 ) );
+}
+
+RTLFUNC(Rate)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+    ULONG nArgCount = rPar.Count()-1;
+
+    if ( nArgCount < 3 || nArgCount > 6 )
+    {
+        StarBASIC::Error( SbERR_BAD_ARGUMENT );
+        return;
+    }
+    // retrieve non-optional params
+
+    double nper = 0;    
+    double pmt = 0;    
+    double pv = 0;
+
+    nper = rPar.Get(1)->GetDouble();
+    pmt = rPar.Get(2)->GetDouble();
+    pv = rPar.Get(3)->GetDouble();
+
+    // set default values for Optional args
+    double fv = 0;    
+    double type = 0;    
+    double guess = 0.1;    
+    
+    // fv
+    if ( nArgCount >= 4 )
+    {
+        if( rPar.Get(4)->GetType() != SbxEMPTY )
+            fv = rPar.Get(4)->GetDouble();
+    }
+
+    // type
+    if ( nArgCount >= 5 )
+    {
+        if( rPar.Get(5)->GetType() != SbxEMPTY )
+            type = rPar.Get(5)->GetDouble();
+    }
+
+    // guess
+    if ( nArgCount >= 6 )
+    {
+        if( rPar.Get(6)->GetType() != SbxEMPTY )
+            type = rPar.Get(6)->GetDouble();
+    }
+
+    Sequence< Any > aParams( 6 );
+    aParams[ 0 ] <<= nper;
+    aParams[ 1 ] <<= pmt;
+    aParams[ 2 ] <<= pv;
+    aParams[ 3 ] <<= fv;
+    aParams[ 4 ] <<= type;
+    aParams[ 5 ] <<= guess;
+    
+    CallFunctionAccessFunction( aParams, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Rate") ), rPar.Get( 0 ) );
+}
+
 RTLFUNC(StrReverse)
 {
     (void)pBasic;
@@ -2594,14 +3140,14 @@
 
 	SbModule* pActiveModule = pINST->GetActiveModule();
 	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
+    SbxVariableRef refVar = rPar.Get(0);
 	if( pClassModuleObject == NULL )
 	{
-		StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod )
+            refVar->PutObject( pMod );
 	}
 	else
-	{
-		SbxVariableRef refVar = rPar.Get(0);
 		refVar->PutObject( pClassModuleObject );
-	}
 }
 
Index: basic/source/runtime/stdobj.cxx
===================================================================
--- basic/source/runtime/stdobj.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/stdobj.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -36,6 +36,7 @@
 #include <basic/sbstdobj.hxx>
 #include "rtlproto.hxx"
 #include "sbintern.hxx"
+#include "errobject.hxx"
 
 // Das nArgs-Feld eines Tabelleneintrags ist wie folgt verschluesselt:
 // Zur Zeit wird davon ausgegangen, dass Properties keine Parameter
@@ -174,7 +175,12 @@
   { "expression",   SbxVARIANT, 0,NULL,0 },
 { "CVErr",          SbxVARIANT,   1 | _FUNCTION, RTLNAME(CVErr),0           },
   { "expression",   SbxVARIANT, 0,NULL,0 },
-
+{ "DDB",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(DDB),0       },
+  { "Cost",       SbxDOUBLE,  0, NULL,0 },
+  { "Salvage",       SbxDOUBLE,  0, NULL,0 },
+  { "Life",       SbxDOUBLE,  0, NULL,0 },
+  { "Period",       SbxDOUBLE,  0, NULL,0 },
+  { "Factor",     SbxVARIANT,  _OPT, NULL,0 },
 { "Date",           SbxDATE,          _LFUNCTION,RTLNAME(Date),0            },
 { "DateAdd",        SbxDATE,	  3 | _FUNCTION, RTLNAME(DateAdd),0         },
   { "Interval",     SbxSTRING, 0,NULL,0 },
@@ -272,6 +278,12 @@
 { "FreeLibrary",    SbxNULL,      1 | _FUNCTION, RTLNAME(FreeLibrary),0     },
   { "Modulename",   SbxSTRING, 0,NULL,0 },
 
+{ "FV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(FV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
 { "Get",            SbxNULL,   3 | _FUNCTION, RTLNAME(Get),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
@@ -332,6 +344,16 @@
   { "Compare",      SbxINTEGER,       _OPT, NULL,0 },
 { "Int",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Int),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "IPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(IPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "IRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(IRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "Guess",       SbxVARIANT,  _OPT, NULL,0 },
 { "IsArray",        SbxBOOL,      1 | _FUNCTION, RTLNAME(IsArray),0         },
   { "Variant",      SbxVARIANT, 0,NULL,0 },
 { "IsDate",         SbxBOOL,      1 | _FUNCTION, RTLNAME(IsDate),0          },
@@ -400,6 +422,10 @@
   { "Length",       SbxLONG,          _OPT, NULL,0 },
 { "Minute",         SbxINTEGER,   1 | _FUNCTION, RTLNAME(Minute),0          },
   { "Date",         SbxDATE, 0,NULL,0 },
+{ "MIRR",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(MIRR),0       },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
+  { "FinanceRate",       SbxDOUBLE,  0, NULL,0 },
+  { "ReinvestRate",       SbxDOUBLE,  0, NULL,0 },
 { "MkDir",          SbxNULL,      1 | _FUNCTION, RTLNAME(MkDir),0           },
   { "pathname",     SbxSTRING, 0,NULL,0 },
 { "Month",          SbxINTEGER,   1 | _FUNCTION, RTLNAME(Month),0           },
@@ -416,6 +442,15 @@
 
 { "Nothing",        SbxOBJECT,        _CPROP,    RTLNAME(Nothing),0         },
 { "Now",            SbxDATE,          _FUNCTION, RTLNAME(Now),0             },
+{ "NPer",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(NPer),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+{ "NPV",      SbxDOUBLE,      2 | _FUNCTION | _COMPTMASK, RTLNAME(NPV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "ValueArray",       SbxARRAY,  0, NULL,0 },
 { "Null",			SbxNULL,          _CPROP,    RTLNAME(Null),0			},
 
 { "Oct",            SbxSTRING,    1 | _FUNCTION, RTLNAME(Oct),0             },
@@ -427,16 +462,46 @@
   { "stop",  	    SbxLONG, 	0,NULL,0 },
   { "interval",     SbxLONG, 	0,NULL,0 },
 { "Pi",				SbxDOUBLE,		  _CPROP,    RTLNAME(PI),0		      	},
+
+{ "Pmt",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(Pmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
+{ "PPmt",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(PPmt),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "Per",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "Put",            SbxNULL,   3 | _FUNCTION, RTLNAME(Put),0                },
   { "filenumber",   SbxINTEGER, 0,NULL,0 },
   { "recordnumber", SbxLONG, 0,NULL,0 },
   { "variablename",	SbxVARIANT, 0,NULL,0 },
 
+{ "PV",      SbxDOUBLE,      5 | _FUNCTION | _COMPTMASK, RTLNAME(PV),0       },
+  { "Rate",       SbxDOUBLE,  0, NULL,0 },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",     SbxDOUBLE,  0, NULL,0 },
+  { "FV",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+
 { "QBColor",		SbxLONG,	  1 | _FUNCTION, RTLNAME(QBColor),0			},
   { "number",		SbxINTEGER, 0,NULL,0 },
 
 { "Randomize",      SbxNULL,      1 | _FUNCTION, RTLNAME(Randomize),0       },
   { "Number",       SbxDOUBLE,        _OPT, NULL,0 },
+{ "Rate",      SbxDOUBLE,      6 | _FUNCTION | _COMPTMASK, RTLNAME(Rate),0       },
+  { "NPer",       SbxDOUBLE,  0, NULL,0 },
+  { "Pmt",       SbxDOUBLE,  0, NULL,0 },
+  { "PV",       SbxDOUBLE,  0, NULL,0 },
+  { "FV",       SbxVARIANT,  _OPT, NULL,0 },
+  { "Due",     SbxVARIANT,  _OPT, NULL,0 },
+  { "Guess",    SbxVARIANT,  _OPT, NULL,0 },
 { "Red",        SbxINTEGER,   1 | _FUNCTION, RTLNAME(Red),0                 },
   { "RGB-Value",     SbxLONG, 0,NULL,0 },
 { "Reset",          SbxNULL,      0 | _FUNCTION, RTLNAME(Reset),0           },
@@ -477,6 +542,7 @@
 { "SendKeys",       SbxNULL,      2 | _FUNCTION, RTLNAME(SendKeys),0        },
   { "String",       SbxSTRING, 0,NULL,0 },
   { "Wait",         SbxBOOL,          _OPT, NULL,0 },
+{ "DoEvents",       SbxINTEGER,      0 | _FUNCTION, RTLNAME(DoEvents),0        },
 { "SetAttr",        SbxNULL,      2 | _FUNCTION, RTLNAME(SetAttr),0         },
   { "File"  ,       SbxSTRING, 0,NULL,0 },
   { "Attributes",   SbxINTEGER, 0,NULL,0 },
@@ -490,6 +556,15 @@
   { "WindowStyle",  SbxINTEGER,       _OPT, NULL,0 },
 { "Sin",            SbxDOUBLE,    1 | _FUNCTION, RTLNAME(Sin),0             },
   { "number",       SbxDOUBLE, 0,NULL,0 },
+{ "SLN",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SLN),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Double",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+{ "SYD",            SbxDOUBLE,    2 |  _FUNCTION | _COMPTMASK, RTLNAME(SYD),0             },
+  { "Cost",       SbxDOUBLE, 0,NULL,0 },
+  { "Salvage",       SbxDOUBLE, 0,NULL,0 },
+  { "Life",       SbxDOUBLE, 0,NULL,0 },
+  { "Period",       SbxDOUBLE, 0,NULL,0 },
 { "Space",          SbxSTRING,      1 | _FUNCTION, RTLNAME(Space),0         },
   { "string",       SbxLONG, 0,NULL,0 },
 { "Spc",          	SbxSTRING,      1 | _FUNCTION, RTLNAME(Spc),0           },
@@ -604,6 +679,7 @@
 
 { "Wait",        	SbxNULL,      1 | _FUNCTION, RTLNAME(Wait),0            },
   { "Milliseconds", SbxLONG, 0,NULL,0 },
+{ "FuncCaller",          SbxVARIANT,      _FUNCTION, RTLNAME(FuncCaller),0      },
 //#i64882#
 { "WaitUntil",          SbxNULL,      1 | _FUNCTION, RTLNAME(WaitUntil),0      },
   { "Date", SbxDOUBLE, 0,NULL,0 },
@@ -655,6 +731,11 @@
 
 SbxVariable* SbiStdObject::Find( const String& rName, SbxClassType t )
 {
+	// #TODO #FIXME hack for substituting ooo-basic Err with vba-ish
+	// ErrObject object
+	static String sErr( RTL_CONSTASCII_USTRINGPARAM("Err") );
+	if (  rName.EqualsIgnoreCaseAscii( sErr ) ) 
+		return SbxErrObject::getErrObject();
 	// Bereits eingetragen?
 	SbxVariable* pVar = SbxObject::Find( rName, t );
 	if( !pVar )
Index: basic/source/runtime/rtlproto.hxx
===================================================================
--- basic/source/runtime/rtlproto.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/rtlproto.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -167,28 +167,41 @@
 extern RTLFUNC(MkDir); // JSM
 extern RTLFUNC(RmDir); // JSM
 extern RTLFUNC(SendKeys); // JSM
+extern RTLFUNC(DDB);
+extern RTLFUNC(DoEvents);
 extern RTLFUNC(DimArray);
 extern RTLFUNC(Dir);
 extern RTLFUNC(Exp);
 extern RTLFUNC(FileLen);
 extern RTLFUNC(Fix);
+extern RTLFUNC(FV);
 extern RTLFUNC(Hex);
 extern RTLFUNC(Input);
 extern RTLFUNC(InStr);
 extern RTLFUNC(InStrRev);
 extern RTLFUNC(Int);
+extern RTLFUNC(IPmt);
+extern RTLFUNC(IRR);
 extern RTLFUNC(Join);
 extern RTLFUNC(LCase);
 extern RTLFUNC(Left);
 extern RTLFUNC(Log);
 extern RTLFUNC(LTrim);
 extern RTLFUNC(Mid);
+extern RTLFUNC(MIRR);
+extern RTLFUNC(NPer);
+extern RTLFUNC(NPV);
 extern RTLFUNC(Oct);
+extern RTLFUNC(Pmt);
+extern RTLFUNC(PPmt);
+extern RTLFUNC(PV);
+extern RTLFUNC(Rate);
 extern RTLFUNC(Replace);
 extern RTLFUNC(Right);
 extern RTLFUNC(RTrim);
 extern RTLFUNC(RTL);
 extern RTLFUNC(Sgn);
+extern RTLFUNC(SLN);
 extern RTLFUNC(Space);
 extern RTLFUNC(Split);
 extern RTLFUNC(Sqr);
@@ -196,6 +209,7 @@
 extern RTLFUNC(StrComp);
 extern RTLFUNC(String);
 extern RTLFUNC(StrReverse);
+extern RTLFUNC(SYD);
 extern RTLFUNC(Tan);
 extern RTLFUNC(UCase);
 extern RTLFUNC(Val);
@@ -298,6 +312,7 @@
 extern RTLFUNC(Wait);
 //i#64882# add new WaitUntil
 extern RTLFUNC(WaitUntil);
+extern RTLFUNC(FuncCaller);
 
 extern RTLFUNC(GetGUIVersion);
 extern RTLFUNC(Choose);
Index: basic/source/runtime/step0.cxx
===================================================================
--- basic/source/runtime/step0.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/step0.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -33,6 +33,7 @@
 #include <vcl/msgbox.hxx>
 #include <tools/fsys.hxx>
 
+#include "errobject.hxx"
 #include "runtime.hxx"
 #include "sbintern.hxx"
 #include "iosys.hxx"
@@ -47,6 +48,11 @@
 
 #include <algorithm>
 
+// for a patch forward declaring these methods below makes sense
+// but, #FIXME lets really just move the methods to the top
+void lcl_clearImpl( SbxVariableRef& refVar, SbxDataType& eType );
+void lcl_eraseImpl( SbxVariableRef& refVar, bool bVBAEnabled );
+
 SbxVariable* getDefaultProp( SbxVariable* pRef );
 
 void SbiRuntime::StepNOP()
@@ -58,34 +64,6 @@
 	TOSMakeTemp();
 	SbxVariable* p2 = GetTOS();
 
-
-	// This could & should be moved to the MakeTempTOS() method in runtime.cxx
-	// In the code which this is cut'npaste from there is a check for a ref
-	// count != 1 based on which the copy of the SbxVariable is done.
-	// see orig code in MakeTempTOS ( and I'm not sure what the significance,
-	// of that is )
-	// here we alway seem to have a refcount of 1. Also it seems that
-	// MakeTempTOS is called for other operation, so I hold off for now
-	// until I have a better idea
-	if ( bVBAEnabled
-		&& ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
-	)
-	{
-		SbxVariable* pDflt = getDefaultProp( p2 );
-		if ( pDflt )
-		{
-			pDflt->Broadcast( SBX_HINT_DATAWANTED );
-			// replacing new p2 on stack causes object pointed by 
-			// pDft->pParent to be deleted, when p2->Compute() is
-			// called below pParent is accessed ( but its deleted )
-			// so set it to NULL now
-			pDflt->SetParent( NULL );  
-			p2 = new SbxVariable( *pDflt );
-			p2->SetFlag( SBX_READWRITE );
-			refExprStk->Put( p2, nExprLvl - 1 );
-		}
-	}
-
 	p2->ResetFlag( SBX_FIXED );
 	p2->Compute( eOp, *p1 );
 
@@ -108,19 +86,24 @@
 	// values ( and type ) set as appropriate
 	SbxDataType p1Type = p1->GetType(); 
 	SbxDataType p2Type = p2->GetType(); 
+	if ( p1Type == SbxEMPTY )
+	{
+		p1->Broadcast( SBX_HINT_DATAWANTED );
+		p1Type = p1->GetType(); 
+	}
+	if ( p2Type == SbxEMPTY )
+	{
+		p2->Broadcast( SBX_HINT_DATAWANTED );
+		p2Type = p2->GetType(); 
+	}
 	if ( p1Type == p2Type )
 	{
-		if ( p1Type == SbxEMPTY )
-		{
-			p1->Broadcast( SBX_HINT_DATAWANTED );
-			p2->Broadcast( SBX_HINT_DATAWANTED );
-		}
 		// if both sides are an object and have default props
 		// then we need to use the default props
 		// we don't need to worry if only one side ( lhs, rhs ) is an 
 		// object ( object side will get coerced to correct type in 
 		// Compare )
-		else if ( p1Type ==  SbxOBJECT )
+		if ( p1Type ==  SbxOBJECT )
 		{
 			SbxVariable* pDflt = getDefaultProp( p1 );
 			if ( pDflt )
@@ -140,9 +123,22 @@
 #ifndef WIN
 	static SbxVariable* pTRUE = NULL;
 	static SbxVariable* pFALSE = NULL;
-
-	if( p2->Compare( eOp, *p1 ) )
+	static SbxVariable* pNULL = NULL;
+	// why do this on non-windows ?
+	// why do this at all ?
+	// I dumbly follow the pattern :-/
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
 	{
+		if( !pNULL )
+		{
+			pNULL = new SbxVariable;
+			pNULL->PutNull();
+			pNULL->AddRef();
+		}
+		PushVar( pNULL );
+	}
+	else if( p2->Compare( eOp, *p1 ) )
+	{
 		if( !pTRUE )
 		{
 			pTRUE = new SbxVariable;
@@ -162,9 +158,14 @@
 		PushVar( pFALSE );
 	}
 #else
-	BOOL bRes = p2->Compare( eOp, *p1 );
 	SbxVariable* pRes = new SbxVariable;
-	pRes->PutBool( bRes );
+	if ( bVBAEnabled && ( p1->IsNull() || p2->IsNull() ) )	
+		pRes->PutNull();
+	else
+	{
+		BOOL bRes = p2->Compare( eOp, *p1 );
+		pRes->PutBool( bRes );
+	}
 	PushVar( pRes );
 #endif
 }
@@ -641,6 +642,17 @@
 // #56204 DIM-Funktionalitaet in Hilfsmethode auslagern (step0.cxx)
 void SbiRuntime::DimImpl( SbxVariableRef refVar )
 {
+	// If refDim then this DIM statement is terminating a ReDIM and
+	// previous StepERASE_CLEAR for an array, the following actions have 
+	// been delayed from ( StepERASE_CLEAR ) 'till here
+	if ( refRedim ) 
+	{
+		if ( !refRedimpArray ) // only erase the array not ReDim Preserve
+			lcl_eraseImpl( refVar, bVBAEnabled );
+		SbxDataType eType = refVar->GetType();
+		lcl_clearImpl( refVar, eType );
+		refRedim = NULL;
+	}
 	SbxArray* pDims = refVar->GetParameters();
 	// Muss eine gerade Anzahl Argumente haben
 	// Man denke daran, dass Arg[0] nicht zaehlt!
@@ -806,6 +818,7 @@
 void SbiRuntime::StepREDIMP_ERASE()
 {
 	SbxVariableRef refVar = PopVar();
+	refRedim = refVar;
 	SbxDataType eType = refVar->GetType();
 	if( eType & SbxARRAY )
 	{
@@ -816,12 +829,6 @@
 			refRedimpArray = pDimArray;
 		}
 
-		// As in ERASE
-		USHORT nSavFlags = refVar->GetFlags();
-		refVar->ResetFlag( SBX_FIXED );
-		refVar->SetType( SbxDataType(eType & 0x0FFF) );
-		refVar->SetFlags( nSavFlags );
-		refVar->Clear();
 	}
 	else
 	if( refVar->IsFixed() )
@@ -894,10 +901,7 @@
 
 void SbiRuntime::StepERASE_CLEAR()
 {
-	SbxVariableRef refVar = PopVar();
-	lcl_eraseImpl( refVar, bVBAEnabled );
-	SbxDataType eType = refVar->GetType();
-	lcl_clearImpl( refVar, eType );
+	refRedim = PopVar();
 }
 
 void SbiRuntime::StepARRAYACCESS()
@@ -1119,6 +1123,7 @@
 	pInst->nErr = 0L;
 	pInst->nErl = 0;
 	nError = 0L;
+	SbxErrObject::getUnoErrObject()->Clear();
 }
 
 void SbiRuntime::StepNOERROR()
@@ -1127,6 +1132,7 @@
 	pInst->nErr = 0L;
 	pInst->nErl = 0;
 	nError = 0L;
+	SbxErrObject::getUnoErrObject()->Clear();
 	bError = FALSE;
 }
 
@@ -1135,6 +1141,9 @@
 void SbiRuntime::StepLEAVE()
 {
 	bRun = FALSE;
+        // If VBA and we are leaving an ErrorHandler then clear the error ( it's been processed )
+	if ( bInError && pError )
+	    SbxErrObject::getUnoErrObject()->Clear();
 }
 
 void SbiRuntime::StepCHANNEL()	  	// TOS = Kanalnummer
@@ -1268,6 +1277,6 @@
 	SbxVariableRef refCode = PopVar();
 	USHORT n = refCode->GetUShort();
 	SbError error = StarBASIC::GetSfxFromVBError( n );
-	Error( error );
+	pInst->Error( error );
 }
 
Index: basic/source/runtime/step1.cxx
===================================================================
--- basic/source/runtime/step1.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/step1.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,6 +38,7 @@
 #include "iosys.hxx"
 #include "image.hxx"
 #include "sbunoobj.hxx"
+#include "errobject.hxx"
 
 bool checkUnoObjectType( SbUnoObject* refVal, 
 	const String& aClass );
@@ -94,6 +95,15 @@
 	{
 		String aAlias( pImg->GetString( static_cast<short>( nOp1 ) ) );
 		SbxVariableRef pVal = PopVar();
+		if( bVBAEnabled && ( pVal->ISA(SbxMethod) || pVal->ISA(SbUnoProperty) || pVal->ISA(SbProcedureProperty) ) )
+		{
+			// named variables ( that are Any especially properties ) can be empty at this point and need a broadcast
+			if ( pVal->GetType() == SbxEMPTY )
+				pVal->Broadcast( SBX_HINT_DATAWANTED );
+			// Methoden und Properties evaluieren!
+			SbxVariable* pRes = new SbxVariable( *pVal );
+			pVal = pRes;
+		}
 		refArgv->Put( pVal, nArgc );
 		refArgv->PutAlias( aAlias, nArgc++ );
 	}
@@ -183,7 +193,9 @@
 void SbiRuntime::StepJUMPF( UINT32 nOp1 )
 {
 	SbxVariableRef p = PopVar();
-	if( !p->GetBool() )
+	// In a test e.g. If Null then 	
+        // will evaluate Null will act as if False
+	if( ( bVBAEnabled && p->IsNull() ) || !p->GetBool() )
 		StepJUMP( nOp1 );
 }
 
@@ -363,6 +375,7 @@
 	pInst->nErr = 0;
 	pInst->nErl = 0;
 	nError = 0;
+	SbxErrObject::getUnoErrObject()->Clear();
 }
 
 // Resume nach Fehlern (+0=statement, 1=next or Label)
@@ -383,6 +396,8 @@
 	}
 	else
 		pCode = pErrStmnt;
+	if ( pError ) // current in error handler ( and got a Resume Next statment )
+		SbxErrObject::getUnoErrObject()->Clear();
 
 	if( nOp1 > 1 )
 		StepJUMP( nOp1 );
Index: basic/source/runtime/step2.cxx
===================================================================
--- basic/source/runtime/step2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/step2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,59 +54,6 @@
 
 using com::sun::star::uno::Reference;
 
-SbxVariable* getVBAConstant( const String& rName );
-
-const static String aThisComponent( RTL_CONSTASCII_USTRINGPARAM("ThisComponent") );
-const static String aVBAHook( RTL_CONSTASCII_USTRINGPARAM( "VBAGlobals" ) );
-//  i#i68894#
-SbxArray* getVBAGlobals( )
-{
-	static SbxArrayRef pArray;
-	static bool isInitialised = false;
-	if ( isInitialised )
-		return pArray;
-	Reference < XComponentContext > xCtx;
-	Reference < XPropertySet > xProps(
-	::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
-	xCtx.set( xProps->getPropertyValue( rtl::OUString(
-		RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))),
-			UNO_QUERY_THROW );
-	SbUnoObject dGlobs( String( RTL_CONSTASCII_USTRINGPARAM("ExcelGlobals") ), xCtx->getValueByName( ::rtl::OUString::createFromAscii( "/singletons/ooo.vba.theGlobals") ) );
-
-	SbxVariable *vba = dGlobs.Find( String( RTL_CONSTASCII_USTRINGPARAM("getGlobals") ) , SbxCLASS_DONTCARE );
-
-	if ( vba )
-	{
-		pArray = static_cast<SbxArray *>(vba->GetObject());
-		isInitialised = true;
-		return pArray;
-	}
-	return NULL;
-}
-
-//  i#i68894#
-SbxVariable* VBAFind( const String& rName, SbxClassType t )
-{
-	if( rName == aThisComponent )
-		return NULL;
-
-	SbxArray *pVBAGlobals = getVBAGlobals( );
-	for (USHORT i = 0; pVBAGlobals && i < pVBAGlobals->Count(); i++)
-	{
-		SbxVariable *pElem = pVBAGlobals->Get( i );
-		if (!pElem || !pElem->IsObject())
-			continue;
-		SbxObject *pVba = static_cast<SbxObject *>(pElem->GetObject());
-		SbxVariable *pVbaVar = pVba ? pVba->Find( rName, t ) : NULL;
-		if( pVbaVar )
-		{
-			return pVbaVar;
-		}
-	}
-	return NULL;
-
-}
-
 // Suchen eines Elements
 // Die Bits im String-ID:
 // 0x8000 - Argv ist belegt
@@ -191,11 +138,11 @@
 				if ( bVBAEnabled )
 				{
 					// Try Find in VBA symbols space
-					pElem = VBAFind( aName, SbxCLASS_DONTCARE );
+					pElem = rBasic.VBAFind( aName, SbxCLASS_DONTCARE );
 					if ( pElem )
 						bSetName = false; // don't overwrite uno name
 					else
-						pElem = getVBAConstant( aName );
+                        pElem = VBAConstantHelper::instance().getVBAConstant( aName );
 				}
 				// #72382 VORSICHT! Liefert jetzt wegen unbekannten
 				// Modulen IMMER ein Ergebnis!
@@ -315,10 +262,12 @@
 			if( bSet )
 				pElem->SetType( t2 );
 			pElem = pNew;
-		}
+		} 
 		// Index-Access bei UnoObjekten beruecksichtigen
-		/*
-		else if( pElem->ISA(SbUnoProperty) )
+		// definitely we want this for VBA where properties are often 
+		// collections ( which need index access ), but lets only do 
+		// this if we actually have params following
+		else if( bVBAEnabled && pElem->ISA(SbUnoProperty) && pElem->GetParameters() )
 		{
 			// pElem auf eine Ref zuweisen, um ggf. eine Temp-Var zu loeschen
 			SbxVariableRef refTemp = pElem;
@@ -328,7 +277,6 @@
 			pElem->SetParameters( NULL ); // sonst bleibt Ref auf sich selbst
 			pElem = pNew;
 		}
-		*/
 	}
 	return CheckArray( pElem );
 }
@@ -431,7 +379,8 @@
 				bool bError_ = true;
 
 				SbUnoMethod* pUnoMethod = PTR_CAST(SbUnoMethod,p);
-				if( pUnoMethod )
+				SbUnoProperty* pUnoProperty = PTR_CAST(SbUnoProperty,p);
+				if( pUnoMethod || pUnoProperty )
 				{
 					SbUnoObject* pParentUnoObj = PTR_CAST( SbUnoObject,p->GetParent() );
 					if( pParentUnoObj )
@@ -509,7 +458,7 @@
 {
 	// Falls wir ein Array haben, wollen wir bitte das Array-Element!
 	SbxArray* pPar;
-	if( pElem->GetType() & SbxARRAY )
+	if( ( pElem->GetType() & SbxARRAY ) && (SbxVariable*)refRedim != pElem )
 	{
 		SbxBase* pElemObj = pElem->GetObject();
 		SbxDimArray* pDimArray = PTR_CAST(SbxDimArray,pElemObj);
@@ -774,6 +723,8 @@
 		SaveRef( q );
 		*q = *p;
 		p = q;
+		if ( i ) 
+                	refParams->Put( p, i );
 	}
 	SetupArgs( p, nOp1 );
 	PushVar( CheckArray( p ) );
@@ -1186,16 +1137,26 @@
 	if( pImg->GetFlag( SBIMG_CLASSMODULE ) )
 		StepPUBLIC_Impl( nOp1, nOp2, true );
 
+        SbxObject* pStorage = &rBasic;
 	String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+	// Store module scope variables at module scope 
+	// in non vba mode these are stored at the library level :/
+	// not sure if this really should not be enabled for ALL basic
+	if ( SbiRuntime::isVBAEnabled() ) 
+        {
+            pStorage = pMod;
+            pMod->AddVarName( aName );
+        }
+
 	SbxDataType t = (SbxDataType) nOp2;
-	BOOL bFlag = rBasic.IsSet( SBX_NO_MODIFY );
+	BOOL bFlag = pStorage->IsSet( SBX_NO_MODIFY );
 	rBasic.SetFlag( SBX_NO_MODIFY );
-	SbxVariableRef p = rBasic.Find( aName, SbxCLASS_PROPERTY );
+	SbxVariableRef p = pStorage->Find( aName, SbxCLASS_PROPERTY );
 	if( p.Is() )
-		rBasic.Remove (p);
-	p = rBasic.Make( aName, SbxCLASS_PROPERTY, t );
+		pStorage->Remove (p);
+	p = pStorage->Make( aName, SbxCLASS_PROPERTY, t );
 	if( !bFlag )
-		rBasic.ResetFlag( SBX_NO_MODIFY );
+		pStorage->ResetFlag( SBX_NO_MODIFY );
 	if( p )
 	{
 		p->SetFlag( SBX_DONTSTORE );
Index: basic/source/runtime/methods.cxx
===================================================================
--- basic/source/runtime/methods.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/runtime/methods.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,7 @@
 #include <unotools/ucbstreamhelper.hxx>
 #include <tools/wldcrd.hxx>
 #include <i18npool/lang.h>
+#include <rtl/string.hxx>
 
 #include "runtime.hxx"
 #include "sbunoobj.hxx"
@@ -77,13 +78,16 @@
 #include <com/sun/star/io/XOutputStream.hpp>
 #include <com/sun/star/io/XStream.hpp>
 #include <com/sun/star/io/XSeekable.hpp>
-
+#include <com/sun/star/script/XErrorQuery.hpp>
+#include <ooo/vba/XHelperInterface.hpp>
+#include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 using namespace comphelper;
 using namespace osl;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::ucb;
 using namespace com::sun::star::io;
+using namespace com::sun::star::script;
 
 #endif /* _USE_UNO */
 
@@ -105,6 +109,8 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 #if defined (WIN) || defined (WNT) || defined (OS2)
 #include <direct.h>   // _getdcwd get current work directory, _chdrive
 #endif
@@ -123,6 +129,10 @@
 #include <io.h>
 #endif
 
+using namespace rtl;
+
+#include <basic/sbobjmod.hxx>
+
 static void FilterWhiteSpace( String& rStr )
 {
 	rStr.EraseAllChars( ' ' );
@@ -837,6 +847,15 @@
 	StarBASIC::Error(SbERR_NOT_IMPLEMENTED);
 }
 
+// Stub, basic already yields by default
+RTLFUNC(DoEvents)
+{
+    (void)pBasic;
+    (void)bWrite;
+
+	rPar.Get(0)->PutInteger( 0 );
+}
+
 RTLFUNC(Exp)
 {
     (void)pBasic;
@@ -919,6 +938,26 @@
 	}
 }
 
+RTLFUNC(FuncCaller)
+{
+    (void)pBasic;
+    (void)bWrite;
+    if ( SbiRuntime::isVBAEnabled() &&  pINST && pINST->pRun )
+    {
+        if ( pINST->pRun->GetExternalCaller() )
+            *rPar.Get(0) =  *pINST->pRun->GetExternalCaller();
+        else
+        {
+            SbxVariableRef pVar = new SbxVariable(SbxVARIANT);
+            *rPar.Get(0) = *pVar;
+        }
+    }
+    else
+    {
+        StarBASIC::Error( SbERR_NOT_IMPLEMENTED );
+    }
+
+}
 // InStr( [start],string,string,[compare] )
 
 RTLFUNC(InStr)
@@ -2390,7 +2429,18 @@
 	if ( rPar.Count() < 2 )
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
 	else
-		rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	{
+		SbxVariable* pVar = NULL;
+		if( SbiRuntime::isVBAEnabled() )
+			pVar = getDefaultProp( rPar.Get(1) );
+		if ( pVar )
+		{
+			pVar->Broadcast( SBX_HINT_DATAWANTED );
+			rPar.Get( 0 )->PutBool( pVar->IsEmpty() );
+		}
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsEmpty() );
+	}
 }
 
 RTLFUNC(IsError)
@@ -2401,7 +2451,22 @@
 	if ( rPar.Count() < 2 )
 		StarBASIC::Error( SbERR_BAD_ARGUMENT );
 	else
-		rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	{
+		SbxVariable* pVar =rPar.Get( 1 );
+		SbUnoObject* pObj = PTR_CAST(SbUnoObject,pVar );
+                if ( !pObj )
+                { 
+                    if ( SbxBase* pBaseObj = pVar->GetObject() )
+                        pObj = PTR_CAST(SbUnoObject, pBaseObj );
+                }
+		Reference< XErrorQuery > xError;
+		if ( pObj )
+			xError.set( pObj->getUnoAny(), UNO_QUERY );
+		if ( xError.is() )
+			rPar.Get( 0 )->PutBool( xError->hasError() );
+		else
+			rPar.Get( 0 )->PutBool( rPar.Get(1)->IsErr() );
+	}
 }
 
 RTLFUNC(IsNull)
@@ -3606,6 +3671,65 @@
 	return aRetStr;
 }
 
+String getObjectTypeName( SbxVariable* pVar )
+{
+    rtl::OUString sRet( RTL_CONSTASCII_USTRINGPARAM("Object") );
+    if ( pVar )
+    {
+        SbxBase* pObj = pVar->GetObject();
+        if( !pObj )
+           sRet = String( RTL_CONSTASCII_USTRINGPARAM("Nothing") );
+        else
+        {
+            SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,pVar );
+            if ( !pUnoObj )
+            { 
+                if ( SbxBase* pBaseObj = pVar->GetObject() )
+                    pUnoObj = PTR_CAST(SbUnoObject, pBaseObj );
+            }
+            if ( pUnoObj )
+            { 
+                Any aObj = pUnoObj->getUnoAny();
+                // For upstreaming unless we start to build oovbaapi by default
+                // we need to get detect the vba-ness of the object in some
+                // other way        
+                // note: Automation objects do not support XServiceInfo
+                Reference< XServiceInfo > xServInfo( aObj, UNO_QUERY );
+                if ( xServInfo.is() )
+                {
+                    // is this a VBA object ?
+                    Reference< ooo::vba::XHelperInterface > xVBA( aObj, UNO_QUERY );
+                    Sequence< rtl::OUString > sServices = xServInfo->getSupportedServiceNames();
+                    if ( sServices.getLength() )
+                        sRet = sServices[ 0 ];
+                }
+                else
+                {
+                    Reference< com::sun::star::bridge::oleautomation::XAutomationObject > xAutoMation( aObj, UNO_QUERY );
+                    if ( xAutoMation.is() )
+                    {
+                        Reference< XInvocation > xInv( aObj, UNO_QUERY );
+                        if ( xInv.is() )
+                        {
+                            try
+                            {
+                                xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sRet;
+                            }
+                            catch( Exception& )
+                            {
+                            }
+                        }
+                    }
+                }
+                sal_Int32 nDot = sRet.lastIndexOf( '.' );
+                if ( nDot != -1 && nDot < sRet.getLength() )
+                       sRet = sRet.copy( nDot + 1 );
+            }
+        }
+    }         
+    return sRet;
+}
+
 RTLFUNC(TypeName)
 {
     (void)pBasic;
@@ -3617,7 +3741,12 @@
 	{
 		SbxDataType eType = rPar.Get(1)->GetType();
 		BOOL bIsArray = ( ( eType & SbxARRAY ) != 0 );
-		String aRetStr = getBasicTypeName( eType );
+
+        String aRetStr;
+        if ( SbiRuntime::isVBAEnabled() && eType == SbxOBJECT )
+            aRetStr = getObjectTypeName( rPar.Get(1) );
+        else
+            aRetStr = getBasicTypeName( eType );
 		if( bIsArray )
 			aRetStr.AppendAscii( "()" );
 		rPar.Get(0)->PutString( aRetStr );
@@ -4109,8 +4238,13 @@
 
 	// Diesen Call einfach an das Object weiterreichen
 	SbxBase* pObj = (SbxObject*)rPar.Get(1)->GetObject();
-	if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	if( pObj && pObj->IsA( TYPE( SbUserFormModule ) ) )
 	{
+		SbUserFormModule* pFormModule = ( SbUserFormModule* )pObj;
+		pFormModule->load();
+	}
+	else if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	{
 		SbxVariable* pVar = ((SbxObject*)pObj)->
 			Find( String( RTL_CONSTASCII_USTRINGPARAM("Load") ), SbxCLASS_METHOD );
 		if( pVar )
@@ -4132,8 +4266,13 @@
 
 	// Diesen Call einfach an das Object weitereichen
 	SbxBase* pObj = (SbxObject*)rPar.Get(1)->GetObject();
-	if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	if( pObj && pObj->IsA( TYPE( SbUserFormModule ) ) )
 	{
+		SbUserFormModule* pFormModule = ( SbUserFormModule* )pObj;
+		pFormModule->Unload();
+	}
+	else if( pObj && pObj->IsA( TYPE( SbxObject ) ) )
+	{
 		SbxVariable* pVar = ((SbxObject*)pObj)->
 			Find( String( RTL_CONSTASCII_USTRINGPARAM("Unload") ), SbxCLASS_METHOD );
 		if( pVar )
Index: basic/source/inc/errobject.hxx
===================================================================
--- basic/source/inc/errobject.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ basic/source/inc/errobject.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,16 @@
+#ifndef ERROBJECT_HXX
+#define ERROBJECT_HXX
+#include "sbunoobj.hxx"
+#include <ooo/vba/XErrObject.hpp>
+
+
+class SbxErrObject : public SbUnoObject
+{
+	com::sun::star::uno::Reference< ooo::vba::XErrObject > m_xErr;
+	SbxErrObject( const String& aName_, const com::sun::star::uno::Any& aUnoObj_ );
+	~SbxErrObject();
+public:
+	static SbxVariableRef getErrObject();
+	static com::sun::star::uno::Reference< ooo::vba::XErrObject > getUnoErrObject();
+};
+#endif
Index: basic/source/inc/token.hxx
===================================================================
--- basic/source/inc/token.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/token.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -75,7 +75,7 @@
 	IF, _IN_, INPUT,
 	LET, LINE, LINEINPUT, LOCAL, LOOP, LPRINT, LSET,
 	NAME, NEW, NEXT,
-	ON, OPEN, OPTION, IMPLEMENTS,
+	ON, OPEN, OPTION, ATTRIBUTE, IMPLEMENTS,
 	PRINT, PRIVATE, PROPERTY, PUBLIC,
 	REDIM, REM, RESUME, RETURN, RSET,
 	SELECT, SET, SHARED, STATIC, STEP, STOP, SUB,
@@ -162,6 +162,10 @@
 		{ return BOOL( t >= FIRSTKWD && t <= LASTKWD ); }
 	static BOOL IsExtra( SbiToken t )
 		{ return BOOL( t >= FIRSTEXTRA ); }
+
+    // process somthing like dim Name as String
+	virtual BOOL IsSymbol( SbiToken )
+        { return FALSE; }
 };
 
 
Index: basic/source/inc/sbunoobj.hxx
===================================================================
--- basic/source/inc/sbunoobj.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/sbunoobj.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,7 @@
 #include <com/sun/star/reflection/XIdlClass.hpp>
 #include <com/sun/star/reflection/XServiceTypeDescription2.hpp> 
 #include <rtl/ustring.hxx>
+#include <hash_map>
 
 class SbUnoObject: public SbxObject
 {
@@ -305,6 +306,26 @@
 	virtual void Clear();
 };
 
+typedef std::hash_map< ::rtl::OUString, ::com::sun::star::uno::Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
+
+typedef std::vector< rtl::OUString > VBAConstantsVector;
+
+class VBAConstantHelper
+{
+private:
+
+    VBAConstantsVector aConstCache;
+    VBAConstantsHash aConstHash;
+    bool isInited;
+    VBAConstantHelper():isInited( false ) {}
+    VBAConstantHelper(const VBAConstantHelper&);
+    void init();
+public:    
+    static VBAConstantHelper& instance(); 
+    SbxVariable* getVBAConstant( const String& rName );
+    bool isVBAConstantType( const String& rName );
+};
+
 #endif
 
 
Index: basic/source/inc/image.hxx
===================================================================
--- basic/source/inc/image.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/image.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -109,6 +109,5 @@
 #define	SBIMG_COMPARETEXT	0x0002	// OPTION COMPARE TEXT ist aktiv
 #define	SBIMG_INITCODE		0x0004	// Init-Code vorhanden
 #define	SBIMG_CLASSMODULE	0x0008	// OPTION ClassModule is active
-#define	SBIMG_VBASUPPORT	0x0020	// OPTION VBASupport is 1
 
 #endif
Index: basic/source/inc/runtime.hxx
===================================================================
--- basic/source/inc/runtime.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/runtime.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -206,7 +206,6 @@
 	BOOL			bCompatibility; // Flag: TRUE = VBA runtime compatibility mode
 
     ComponentVector_t ComponentVector;
-
 public:
 	SbiRuntime*  pRun;        		// Call-Stack
 	SbiInstance* pNext;             // Instanzen-Chain
@@ -293,7 +292,9 @@
 	SbxArrayRef   refExprStk;       // expression stack
 	SbxArrayRef   refCaseStk;       // CASE expression stack
 	SbxArrayRef   refRedimpArray;   // Array saved to use for REDIM PRESERVE
+	SbxVariableRef   refRedim;   // Array saved to use for REDIM
 	SbxVariableRef xDummyVar;		// Ersatz fuer nicht gefundene Variablen
+	SbxVariable* mpExtCaller;		// Caller ( external - e.g. button name, shape, range object etc. - only in vba mode )
 	SbiArgvStack*  pArgvStk;		// ARGV-Stack
 	SbiGosubStack* pGosubStk;		// GOSUB stack
 	SbiForStack*   pForStk;			// FOR/NEXT-Stack
@@ -436,7 +437,7 @@
 	void StepFIND_CM( UINT32, UINT32 );
 	void StepFIND_STATIC( UINT32, UINT32 );
 public:
-	void          SetVBAEnabled( bool bEnabled ) { bVBAEnabled = bEnabled; };
+	void          SetVBAEnabled( bool bEnabled );           
 	USHORT		GetImageFlag( USHORT n ) const;
 	USHORT		GetBase();
 	xub_StrLen  nLine,nCol1,nCol2;	// aktuelle Zeile, Spaltenbereich
@@ -461,6 +462,7 @@
 	SbMethod* GetCaller();
 	SbxArray* GetLocals();
 	SbxArray* GetParams();
+	SbxVariable* GetExternalCaller(){ return mpExtCaller; }
 
 	SbxBase* FindElementExtern( const String& rName );
 	static bool isVBAEnabled();
Index: basic/source/inc/scriptcont.hxx
===================================================================
--- basic/source/inc/scriptcont.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/scriptcont.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -120,7 +120,9 @@
         throw (::com::sun::star::lang::IllegalArgumentException, 
                ::com::sun::star::container::NoSuchElementException, 
                ::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Methods XServiceInfo
     virtual ::rtl::OUString SAL_CALL getImplementationName( )
         throw (::com::sun::star::uno::RuntimeException);
Index: basic/source/inc/dlgcont.hxx
===================================================================
--- basic/source/inc/dlgcont.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/dlgcont.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,7 +96,9 @@
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException);
-
+    // XLibraryQueryExecutable
+    virtual sal_Bool SAL_CALL HasExecutableCode(const rtl::OUString&)
+        throw (::com::sun::star::uno::RuntimeException);
     // Service
 	static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static();
 	static ::rtl::OUString getImplementationName_static();
Index: basic/source/inc/parser.hxx
===================================================================
--- basic/source/inc/parser.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/parser.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,7 @@
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
+struct SbiStatement;
 
 class SbiParser : public SbiTokenizer
 {
@@ -53,6 +54,7 @@
 	BOOL		bGblDefs; 			// TRUE globale Definitionen allgemein
 	BOOL		bNewGblDefs; 		// TRUE globale Definitionen vor Sub
 	BOOL		bSingleLineIf; 		// TRUE einzeiliges if-Statement
+	SbiStatement* pCurStat;
 
 	SbiSymDef*  VarDecl( SbiDimList**,BOOL,BOOL );// Variablen-Deklaration
 	SbiProcDef* ProcDecl(BOOL bDecl);// Prozedur-Deklaration
@@ -100,6 +103,7 @@
 	BOOL TestSymbol( BOOL=FALSE );	// Symbol?
 	BOOL TestComma();				// Komma oder EOLN?
 	void TestEoln();				// EOLN?
+	virtual BOOL IsSymbol( SbiToken t ); // Process something like DIM Name as String
 
 	void Symbol();					// Let oder Call
 	void ErrorStmnt(); 				// ERROR n
@@ -108,6 +112,7 @@
 	void BadSyntax();				// Falsches SbiToken
 	void NoIf();					// ELSE/ELSE IF ohne IF
 	void Assign();					// LET
+	void Attribute();				// Attribute
 	void Call();					// CALL
 	void Close();					// CLOSE
 	void Declare();					// DECLARE
Index: basic/source/inc/namecont.hxx
===================================================================
--- basic/source/inc/namecont.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/namecont.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -38,6 +38,7 @@
 #include <com/sun/star/script/XStorageBasedLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/script/XLibraryContainerExport.hpp>
+#include <com/sun/star/script/XLibraryQueryExecutable.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/container/XContainer.hpp>
 #include <com/sun/star/ucb/XSimpleFileAccess.hpp>
@@ -61,19 +62,24 @@
 
 #include <cppuhelper/implbase2.hxx>
 #include <cppuhelper/compbase6.hxx>
+#include <cppuhelper/compbase7.hxx>
+#include <cppuhelper/compbase8.hxx>
 #include <cppuhelper/interfacecontainer.hxx>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 class BasicManager;
 
 namespace basic
 {
 
-typedef ::cppu::WeakComponentImplHelper6< 
+typedef ::cppu::WeakComponentImplHelper8< 
     ::com::sun::star::lang::XInitialization,
     ::com::sun::star::script::XStorageBasedLibraryContainer,
     ::com::sun::star::script::XLibraryContainerPassword,
     ::com::sun::star::script::XLibraryContainerExport,
     ::com::sun::star::container::XContainer,
+    ::com::sun::star::script::XLibraryQueryExecutable,
+	::com::sun::star::script::XVBACompat,
     ::com::sun::star::lang::XServiceInfo > LibraryContainerHelper;
 
 typedef ::cppu::WeakImplHelper2< ::com::sun::star::container::XNameContainer,
@@ -496,6 +502,10 @@
         throw (::com::sun::star::uno::RuntimeException);
     virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
         throw (::com::sun::star::uno::RuntimeException) = 0;
+
+	// Methods XVBACompat
+	virtual ::sal_Bool SAL_CALL getVBACompatModeOn() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setVBACompatModeOn( ::sal_Bool _vbacompatmodeon ) throw (::com::sun::star::uno::RuntimeException);
 };
 
 class LibraryContainerMethodGuard
Index: basic/source/inc/codegen.hxx
===================================================================
--- basic/source/inc/codegen.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/inc/codegen.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -56,6 +56,7 @@
 	void GenStmnt();			// evtl. Statement-Opcode erzeugen
 	UINT32 GetPC();
 	UINT32 GetOffset()				{ return GetPC() + 1; }
+    SbModule& GetModule() { return rMod; } 
 	void Save();
 
 	// #29955 for-Schleifen-Ebene pflegen
Index: basic/source/basmgr/basmgr.cxx
===================================================================
--- basic/source/basmgr/basmgr.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/basmgr/basmgr.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,9 +44,11 @@
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
 #include <basic/sbmod.hxx>
+#include <basic/sbobjmod.hxx>
 
 #include <basic/sbuno.hxx>
 #include <basic/basmgr.hxx>
+#include <sbunoobj.hxx>
 #include "basrid.hxx"
 #include "sbintern.hxx"
 #include <sb.hrc>
@@ -67,6 +69,8 @@
 #include <com/sun/star/script/XStarBasicDialogInfo.hpp>
 #include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 #include <cppuhelper/implbase1.hxx>
 
@@ -243,9 +247,18 @@
 		{
 			::rtl::OUString aModuleName = pNames[ j ];
 			Any aElement = xLibNameAccess->getByName( aModuleName );
-			::rtl::OUString aMod;
-			aElement >>= aMod;
-			pLib->MakeModule32( aModuleName, aMod );
+            ModuleInfo mInfo;
+            if ( aElement >>= mInfo )
+            {
+                OSL_TRACE("#addLibraryModulesImpl - aMod");
+                pLib->MakeModule32( mInfo );
+            }
+            else
+            {
+			    ::rtl::OUString aMod;
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
 		}
 	}
 
@@ -282,8 +295,6 @@
 	}
 	else
 	{
-		::rtl::OUString aMod;
-		Event.Element >>= aMod;
 
 		StarBASIC* pLib = mpMgr->GetLib( maLibName );
 		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
@@ -292,7 +303,17 @@
     		SbModule* pMod = pLib->FindModule( aName );
             if( !pMod )
             {
-			    pLib->MakeModule32( aName, aMod );
+                ModuleInfo mInfo;
+                if( Event.Element >>= mInfo )
+                {
+                    pLib->MakeModule32( mInfo );
+                }
+                else
+                {
+        		    ::rtl::OUString aMod;
+        		    Event.Element >>= aMod;
+			        pLib->MakeModule32( aName, aMod );
+                }
 			    pLib->SetModified( FALSE );
             }
 		}
@@ -316,15 +337,35 @@
     DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
 
 	StarBASIC* pLib = mpMgr->GetLib( maLibName );
+    
 	if( pLib )
 	{
-		SbModule* pMod = pLib->FindModule( aName );
+	    SbModule* pMod = pLib->FindModule( aName );
 		::rtl::OUString aMod;
-		Event.Element >>= aMod;
+        ModuleInfo mInfo;
+        if( Event.Element >>= mInfo )
+			aMod = mInfo.ModuleSource;
+        else 
+            Event.Element >>= aMod;
 		if( pMod )
+		{
 			pMod->SetSource32( aMod );
-		else
-			pLib->MakeModule32( aName, aMod );
+			if ( mInfo.ModuleType == ModuleType::Document )
+			{
+				SbObjModule* pObjModule = dynamic_cast< SbObjModule* >( pMod );
+				if ( pObjModule )	
+					pObjModule->SetUnoObject( makeAny( mInfo.ModuleObject ) );
+			}
+		}
+        else
+			// Probably we should have an assert for
+			// unknow module type, e.g. either we are using
+			// the ModuleInfo structure ( vba ) for *all* modules
+			// or not ( normal )
+			if ( mInfo.ModuleType == ModuleType::Unknown )
+				pLib->MakeModule32( aName, aMod );
+			else
+				pLib->MakeModule32( mInfo );
 
 		pLib->SetModified( FALSE );
 	}
@@ -1121,6 +1162,25 @@
     _rpManager = NULL;
 }
 
+
+bool BasicManager::HasExeCode( const String& sLib )
+{
+	StarBASIC* pLib = GetLib(sLib);	
+	if ( pLib )
+	{
+		SbxArray* pMods = pLib->GetModules();
+		USHORT nMods = pMods ? pMods->Count() : 0;
+		for( USHORT i = 0; i < nMods; i++ )
+		{
+			SbModule* p = (SbModule*) pMods->Get( i );
+			if ( p )
+				if ( p->HasExeCode() )
+					return true;
+		}
+	}
+	return false;
+}
+
 void BasicManager::Init()
 {
 	DBG_CHKTHIS( BasicManager, 0 );
@@ -1767,6 +1827,15 @@
 	DBG_CHKTHIS( BasicManager, 0 );
 	return pErrorMgr->GetNextError();
 }
+bool BasicManager::GetGlobalUNOConstant( const sal_Char* _pAsciiName, ::com::sun::star::uno::Any& aOut )
+{
+    bool bRes = false;
+    StarBASIC* pStandardLib = GetStdLib();
+    OSL_PRECOND( pStandardLib, "BasicManager::SetGlobalUNOConstant: no lib to insert into!" );
+    if ( pStandardLib )
+        bRes = pStandardLib->GetUNOConstant( _pAsciiName, aOut );
+    return bRes;
+}
 
 Any BasicManager::SetGlobalUNOConstant( const sal_Char* _pAsciiName, const Any& _rValue )
 {
Index: basic/source/sbx/sbxvalue.cxx
===================================================================
--- basic/source/sbx/sbxvalue.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/sbx/sbxvalue.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1147,8 +1147,8 @@
 	{
 		SbxValues aL, aR;
 		bool bDecimal = false;
-		if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING ) || 
-			 ( eThisType != SbxSTRING && eOpType == SbxSTRING ) ) &&
+		if( bVBAInterop && ( ( eThisType == SbxSTRING && eOpType != SbxSTRING && eOpType != SbxEMPTY ) || 
+			 ( eThisType != SbxSTRING && eThisType != SbxEMPTY && eOpType == SbxSTRING ) ) &&
 			 ( eOp == SbxMUL || eOp == SbxDIV || eOp == SbxPLUS || eOp == SbxMINUS ) )
 		{
 			goto Lbl_OpIsDouble;
@@ -1195,6 +1195,8 @@
 					aL.eType = aR.eType = GetType();
 //				else if( GetType() == SbxDouble || GetType() == SbxSingle )
 //					aL.eType = aR.eType = SbxLONG64;
+				else if ( bVBAInterop && eOpType == SbxBOOL )
+					aL.eType = aR.eType = SbxBOOL;
 				else
 					aL.eType = aR.eType = SbxLONG;
 			}
@@ -1281,7 +1283,12 @@
 						break;
 					case SbxNOT:
 						if( aL.eType != SbxLONG && aL.eType != SbxULONG )
-							aL.nLong64 = ~aL.nLong64;
+						{
+							if ( aL.eType != SbxBOOL )
+								aL.nLong64 = ~aL.nLong64;
+							else
+								aL.nLong = ~aL.nLong;
+						}
 						else
 							aL.nLong = ~aL.nLong;
 						break;
Index: basic/source/classes/errobject.cxx
===================================================================
--- basic/source/classes/errobject.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ basic/source/classes/errobject.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,181 @@
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+#include "errobject.hxx"
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include "sbintern.hxx"
+#include "runtime.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo;
+
+typedef ::cppu::WeakImplHelper2< vba::XErrObject, script::XDefaultProperty > ErrObjectImpl_BASE;
+
+class ErrObject : public ErrObjectImpl_BASE
+{	
+	rtl::OUString m_sHelpFile;
+	rtl::OUString m_sSource;
+        rtl::OUString m_sDescription; 
+	sal_Int32 m_nNumber;
+	sal_Int32 m_nHelpContext;
+	
+public:
+	ErrObject();
+	~ErrObject();
+	// Attributes
+	virtual ::sal_Int32 SAL_CALL getNumber() throw (uno::RuntimeException);
+	virtual void SAL_CALL setNumber( ::sal_Int32 _number ) throw (uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getHelpContext() throw (uno::RuntimeException);
+	virtual void SAL_CALL setHelpContext( ::sal_Int32 _helpcontext ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getHelpFile() throw (uno::RuntimeException);
+	virtual void SAL_CALL setHelpFile( const ::rtl::OUString& _helpfile ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getDescription() throw (uno::RuntimeException);
+	virtual void SAL_CALL setDescription( const ::rtl::OUString& _description ) throw (uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getSource() throw (uno::RuntimeException);
+	virtual void SAL_CALL setSource( const ::rtl::OUString& _source ) throw (uno::RuntimeException);
+	
+	// Methods
+	virtual void SAL_CALL Clear(  ) throw (uno::RuntimeException);
+	virtual void SAL_CALL Raise( const uno::Any& Number, const uno::Any& Source, const uno::Any& Description, const uno::Any& HelpFile, const uno::Any& HelpContext ) throw (uno::RuntimeException);
+	// XDefaultProperty	
+	virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (uno::RuntimeException);
+};
+
+
+ErrObject::~ErrObject()
+{
+}
+
+ErrObject::ErrObject() : m_nNumber(0), m_nHelpContext(0)
+{
+}
+
+sal_Int32 SAL_CALL
+ErrObject::getNumber() throw (uno::RuntimeException)
+{
+	return m_nNumber;
+}
+
+void SAL_CALL 
+ErrObject::setNumber( ::sal_Int32 _number ) throw (uno::RuntimeException)
+{
+	m_nNumber = _number;
+
+	
+}
+
+::sal_Int32 SAL_CALL 
+ErrObject::getHelpContext() throw (uno::RuntimeException)
+{
+	return m_nHelpContext;
+}
+void SAL_CALL 
+ErrObject::setHelpContext( ::sal_Int32 _helpcontext ) throw (uno::RuntimeException)
+{
+	m_nHelpContext = _helpcontext;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getHelpFile() throw (uno::RuntimeException)
+{
+	return m_sHelpFile;
+}
+
+void SAL_CALL 
+ErrObject::setHelpFile( const ::rtl::OUString& _helpfile ) throw (uno::RuntimeException)
+{
+	m_sHelpFile = _helpfile;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getDescription() throw (uno::RuntimeException)
+{
+	return m_sDescription;
+}
+
+void SAL_CALL 
+ErrObject::setDescription( const ::rtl::OUString& _description ) throw (uno::RuntimeException)
+{
+	m_sDescription = _description;
+}
+
+::rtl::OUString SAL_CALL 
+ErrObject::getSource() throw (uno::RuntimeException)
+{
+	return m_sSource;
+}
+
+void SAL_CALL 
+ErrObject::setSource( const ::rtl::OUString& _source ) throw (uno::RuntimeException)
+{
+	m_sSource = _source;
+}
+	
+// Methods
+void SAL_CALL 
+ErrObject::Clear(  ) throw (uno::RuntimeException)
+{
+	m_sHelpFile = rtl::OUString();
+	m_sSource = m_sHelpFile;
+	m_sDescription = m_sSource;
+	m_nNumber = 0;	
+	m_nHelpContext = 0;	
+}
+
+void SAL_CALL 
+ErrObject::Raise( const uno::Any& Number, const uno::Any& Source, const uno::Any& Description, const uno::Any& HelpFile, const uno::Any& HelpContext ) throw (uno::RuntimeException)
+{
+	if ( !Number.hasValue() )
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("Missing Required Paramater"), uno::Reference< uno::XInterface >() );
+	Description >>= m_sDescription;
+	Source >>= m_sSource;
+	HelpFile >>= m_sHelpFile;
+	HelpContext >>= m_nHelpContext;
+	Number >>= m_nNumber;
+	if ( m_nNumber )
+	{
+		SbError n = StarBASIC::GetSfxFromVBError( m_nNumber );
+		if ( !n )
+			n = m_nNumber; // force orig number, probably should have a specific table of vb ( localized ) errors
+		pINST->Error( n, m_sDescription );
+	}
+}
+
+// XDefaultProperty	
+::rtl::OUString SAL_CALL 
+ErrObject::getDefaultPropertyName(  ) throw (uno::RuntimeException)
+{
+	static rtl::OUString sDfltPropName( RTL_CONSTASCII_USTRINGPARAM("Number") );
+	return sDfltPropName;
+}
+
+// SbxErrObject
+SbxErrObject::SbxErrObject( const String& rName, const Any& rUnoObj ): SbUnoObject( rName, rUnoObj )
+{
+	OSL_TRACE("SbxErrObject::SbxErrObject ctor");
+	rUnoObj >>= m_xErr;
+	if ( m_xErr.is() )
+		SetDfltProperty( uno::Reference< script::XDefaultProperty >( m_xErr, uno::UNO_QUERY_THROW )->getDefaultPropertyName() ) ;
+}
+
+SbxErrObject::~SbxErrObject()
+{
+	OSL_TRACE("SbxErrObject::~SbxErrObject dtor");
+}
+
+uno::Reference< vba::XErrObject > 
+SbxErrObject::getUnoErrObject()
+{
+	SbxVariable* pVar = getErrObject();
+	SbxErrObject* pGlobErr = static_cast< SbxErrObject* >(  pVar );
+	return pGlobErr->m_xErr;	
+}
+
+SbxVariableRef
+SbxErrObject::getErrObject()
+{
+	static SbxVariableRef pGlobErr = new SbxErrObject( String(  RTL_CONSTASCII_USTRINGPARAM("Err")), uno::makeAny( uno::Reference< vba::XErrObject >( new ErrObject() ) ) );
+	return pGlobErr;
+}
+
Index: basic/source/classes/sbunoobj.cxx
===================================================================
--- basic/source/classes/sbunoobj.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/sbunoobj.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -63,6 +63,7 @@
 #include <com/sun/star/script/XInvocationAdapterFactory.hpp>
 #include <com/sun/star/script/XTypeConverter.hpp>
 #include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XIdlArray.hpp>
@@ -73,8 +74,8 @@
 #include <com/sun/star/bridge/oleautomation/Date.hpp>
 #include <com/sun/star/bridge/oleautomation/Decimal.hpp>
 #include <com/sun/star/bridge/oleautomation/Currency.hpp>
+#include <com/sun/star/script/XAutomationInvocation.hpp>
 
-
 using com::sun::star::uno::Reference;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::lang;
@@ -141,18 +142,36 @@
 SbxVariable* getDefaultProp( SbxVariable* pRef )
 {
 	SbxVariable* pDefaultProp = NULL;
-	SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
-	if ( !pObj )
+	if ( pRef->GetType() == SbxOBJECT )
 	{
-		SbxBase* pObjVarObj = pRef->GetObject();
-		pObj = PTR_CAST(SbxObject,pObjVarObj);
+  		SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
+		if ( !pObj )
+		{
+			SbxBase* pObjVarObj = pRef->GetObject();
+			pObj = PTR_CAST(SbxObject,pObjVarObj);
+		}
+		if ( pObj && pObj->ISA(SbUnoObject) )
+		{
+			SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
+			pDefaultProp = pUnoObj->GetDfltProperty();
+		}
 	}
-	if ( pObj && pObj->ISA(SbUnoObject) )
+	return pDefaultProp;
+}
+
+void SetSbUnoObjectDfltPropName( SbxObject* pObj )
+{
+	SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*) pObj);
+	if ( pUnoObj )
 	{
-		SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
-		pDefaultProp = pUnoObj->GetDfltProperty();
+		String sDfltPropName;
+		
+		if ( SbUnoObject::getDefaultPropName( pUnoObj, sDfltPropName ) )
+		{
+			OSL_TRACE("SetSbUnoObjectDfltPropName setting dflt prop for %s", rtl::OUStringToOString( pObj->GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+			pUnoObj->SetDfltProperty( sDfltPropName );
+		}
 	}
-	return pDefaultProp;
 }
 
 Reference< XComponentContext > getComponentContext_Impl( void )
@@ -1485,6 +1508,103 @@
 	return aRetVal;
 }
 
+void processAutomationParams( SbxArray* pParams, Sequence< Any >& args, bool bOLEAutomation, UINT32 nParamCount )
+{
+	AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
+	if( bOLEAutomation )
+		pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
+
+	args.realloc( nParamCount );
+	Any* pAnyArgs = args.getArray();
+	bool bBlockConversionToSmallestType = pINST->IsCompatibility();
+	UINT32 i = 0;	
+	if( pArgNamesArray )
+	{
+		Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
+		::rtl::OUString* pNames = rNameSeq.getArray();
+		Any aValAny;
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			USHORT iSbx = (USHORT)(i+1);
+	
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
+			bBlockConversionToSmallestType );
+	
+			::rtl::OUString aParamName = pNames[iSbx];
+			if( aParamName.getLength() )
+			{
+				oleautomation::NamedArgument aNamedArgument;
+				aNamedArgument.Name = aParamName;
+				aNamedArgument.Value = aValAny;
+				pAnyArgs[i] <<= aNamedArgument;
+			}
+			else
+			{
+				pAnyArgs[i] = aValAny;
+			}
+		}
+	}
+	else
+	{
+		for( i = 0 ; i < nParamCount ; i++ )
+		{
+			// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
+			pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
+			bBlockConversionToSmallestType );
+		}
+	}
+
+}
+enum INVOKETYPE
+{
+   GetProp = 0, 
+   SetProp, 
+   Func
+};
+Any invokeAutomationMethod( const String& Name, Sequence< Any >& args, SbxArray* pParams, UINT32 nParamCount, Reference< XInvocation >& rxInvocation, INVOKETYPE invokeType = Func )
+{
+	Sequence< INT16 > OutParamIndex;
+	Sequence< Any > OutParam;
+    
+	Any aRetAny;
+	switch( invokeType )
+	{
+		case Func:
+			aRetAny = rxInvocation->invoke( Name, args, OutParamIndex, OutParam );
+			break;
+		case GetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY_THROW );
+				aRetAny = xAutoInv->invokeGetProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		case SetProp:
+			{
+				Reference< XAutomationInvocation > xAutoInv( rxInvocation, UNO_QUERY_THROW );
+				aRetAny = xAutoInv->invokePutProperty( Name, args, OutParamIndex, OutParam );
+				break;
+			}
+		default:
+			break; // should introduce an error here
+	
+	}
+	const INT16* pIndices = OutParamIndex.getConstArray();
+	UINT32 nLen = OutParamIndex.getLength();
+	if( nLen )
+	{
+		const Any* pNewValues = OutParam.getConstArray();
+		for( UINT32 j = 0 ; j < nLen ; j++ )
+		{
+			INT16 iTarget = pIndices[ j ];
+			if( iTarget >= (INT16)nParamCount )
+				break;
+			unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
+		}
+	}
+    return aRetAny;
+}
+
 // Dbg-Hilfsmethode zum Auslesen der in einem Object implementierten Interfaces
 String Impl_GetInterfaceInfo( const Reference< XInterface >& x, const Reference< XIdlClass >& xClass, USHORT nRekLevel )
 {
@@ -1599,6 +1719,23 @@
 				break;
 			}
 			::rtl::OUString sClassName = xClass->getName();
+			if ( sClassName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.bridge.oleautomation.XAutomationObject" ) ) ) )
+			{
+				// there is a hack in the extensions/source/ole/oleobj.cxx  to return the typename of the automation object, lets check if it
+				// matches
+				Reference< XInvocation > xInv( aToInspectObj, UNO_QUERY );
+				if ( xInv.is() )
+				{
+					rtl::OUString sTypeName;
+					xInv->getValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$GetTypeName") ) ) >>= sTypeName;
+					if ( sTypeName.getLength() == 0 || sTypeName.equals(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") ) ) )
+						// can't check type, leave it pass
+						result = true;	
+					else
+						result = sTypeName.equals( aClass );
+				}
+				break; // finished checking automation object
+			}
 			OSL_TRACE("Checking if object implements %s",
 				OUStringToOString( defaultNameSpace + aClass,
 					RTL_TEXTENCODING_UTF8 ).getStr() );
@@ -1968,11 +2105,26 @@
 				{
 					try
 					{
-						// Wert holen
-						Any aRetAny = mxInvocation->getValue( pProp->GetName() );
+						UINT32 nParamCount = pParams ? ((UINT32)pParams->Count() - 1) : 0;
+						sal_Bool bCanBeConsideredAMethod = mxInvocation->hasMethod( pProp->GetName() );
+						Any aRetAny;
+					   	if ( bCanBeConsideredAMethod && nParamCount )
+						{
+							// Automation properties have methods, so.. we need to invoke this through
+							// XInvocation
+							Sequence<Any> args;
+							processAutomationParams( pParams, args, true, nParamCount );
+							aRetAny = invokeAutomationMethod( pProp->GetName(), args, pParams, nParamCount, mxInvocation, GetProp );
+						}	
+						else
+							// Wert holen
+							aRetAny = mxInvocation->getValue( pProp->GetName() );
 
 						// Wert von Uno nach Sbx uebernehmen
 						unoToSbxValue( pVar, aRetAny );
+						if( pParams && bCanBeConsideredAMethod )
+							pVar->SetParameters( NULL );
+
 					}
 					catch( const Exception& )
 					{
@@ -2097,52 +2249,7 @@
 				else if( bInvocation && pParams && mxInvocation.is() )
 				{
 					bool bOLEAutomation = true;
-					// TODO: bOLEAutomation = xOLEAutomation.is()
-
-					AutomationNamedArgsSbxArray* pArgNamesArray = NULL;
-					if( bOLEAutomation )
-						pArgNamesArray = PTR_CAST(AutomationNamedArgsSbxArray,pParams);
-
-					args.realloc( nParamCount );
-					Any* pAnyArgs = args.getArray();
-					bool bBlockConversionToSmallestType = pINST->IsCompatibility();
-					if( pArgNamesArray )
-					{
-						Sequence< ::rtl::OUString >& rNameSeq = pArgNamesArray->getNames();
-						::rtl::OUString* pNames = rNameSeq.getArray();
-
-						Any aValAny;
-						for( i = 0 ; i < nParamCount ; i++ )
-						{
-							USHORT iSbx = (USHORT)(i+1);
-
-							// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-							aValAny = sbxToUnoValueImpl( pParams->Get( iSbx ),
-														bBlockConversionToSmallestType );
-
-							::rtl::OUString aParamName = pNames[iSbx];
-							if( aParamName.getLength() )
-							{
-								oleautomation::NamedArgument aNamedArgument;
-								aNamedArgument.Name = aParamName;
-								aNamedArgument.Value = aValAny;
-								pAnyArgs[i] <<= aNamedArgument;
-							}
-							else
-							{
-								pAnyArgs[i] = aValAny;
-							}
-						}
-					}
-					else
-					{
-						for( i = 0 ; i < nParamCount ; i++ )
-						{
-							// ACHTUNG: Bei den Sbx-Parametern den Offset nicht vergessen!
-							pAnyArgs[i] = sbxToUnoValueImpl( pParams->Get( (USHORT)(i+1) ),
-															bBlockConversionToSmallestType );
-						}
-					}
+					processAutomationParams( pParams, args, bOLEAutomation, nParamCount );
 				}
 
 				// Methode callen
@@ -2177,26 +2284,8 @@
 					}
 					else if( bInvocation && mxInvocation.is() )
 					{
-						Sequence< INT16 > OutParamIndex;
-						Sequence< Any > OutParam;
-						Any aRetAny = mxInvocation->invoke( pMeth->GetName(), args, OutParamIndex, OutParam );
-
-						// Wert von Uno nach Sbx uebernehmen
+						Any aRetAny = invokeAutomationMethod( pMeth->GetName(), args, pParams, nParamCount, mxInvocation );
 						unoToSbxValue( pVar, aRetAny );
-
-						const INT16* pIndices = OutParamIndex.getConstArray();
-						UINT32 nLen = OutParamIndex.getLength();
-						if( nLen )
-						{
-							const Any* pNewValues = OutParam.getConstArray();
-							for( UINT32 j = 0 ; j < nLen ; j++ )
-							{
-								INT16 iTarget = pIndices[ j ];
-								if( iTarget >= (INT16)nParamCount )
-									break;
-								unoToSbxValue( (SbxVariable*)pParams->Get( (USHORT)(j+1) ), pNewValues[ j ] );
-							}
-						}
 					}
 
 					// #55460, Parameter hier weghauen, da das in unoToSbxValue()
@@ -3125,11 +3214,16 @@
 
 typedef std::hash_map< ::rtl::OUString, Any, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > VBAConstantsHash;
 
-SbxVariable* getVBAConstant( const String& rName )
+VBAConstantHelper&
+VBAConstantHelper::instance()
 {
-	SbxVariable* pConst = NULL;
-	static VBAConstantsHash aConstCache;
-	static bool isInited = false;
+    static VBAConstantHelper aHelper;
+    return aHelper;
+}
+
+void
+VBAConstantHelper::init()
+{
 	if ( !isInited )
 	{
 		Sequence< TypeClass > types(1);
@@ -3137,39 +3231,77 @@
 		Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( defaultNameSpace, types, TypeDescriptionSearchDepth_INFINITE  );
 
 		if ( !xEnum.is() )
-			return NULL;
+            return; //NULL;
 
 		while ( xEnum->hasMoreElements() )
 		{
 			Reference< XConstantsTypeDescription > xConstants( xEnum->nextElement(), UNO_QUERY );
 			if ( xConstants.is() )
 			{
+                // store constant group name 
+                ::rtl::OUString sFullName = xConstants->getName();
+                sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
+                ::rtl::OUString sLeafName( sFullName );
+                if ( indexLastDot > -1 )
+                    sLeafName = sFullName.copy( indexLastDot + 1);
+                aConstCache.push_back( sLeafName ); // assume constant group names are unique
 				Sequence< Reference< XConstantTypeDescription > > aConsts = xConstants->getConstants();
 				Reference< XConstantTypeDescription >* pSrc = aConsts.getArray();
 				sal_Int32 nLen = aConsts.getLength();
 				for ( sal_Int32 index =0;  index<nLen; ++pSrc, ++index )
 				{
+                    // store constant member name
 					Reference< XConstantTypeDescription >& rXConst =
 						*pSrc;
-					::rtl::OUString sFullName = rXConst->getName();
-					sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
-					::rtl::OUString sLeafName;
+                    sFullName = rXConst->getName();
+                    indexLastDot = sFullName.lastIndexOf('.');
+                    sLeafName = sFullName;
 					if ( indexLastDot > -1 )
 						sLeafName = sFullName.copy( indexLastDot + 1);
-					aConstCache[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
+                    aConstHash[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();
 				}
 			}
 		}
 		isInited = true;
 	}
+}
+
+bool
+VBAConstantHelper::isVBAConstantType( const String& rName )
+{
+    init();
+    bool bConstant = false;
+    ::rtl::OUString sKey( rName );
+    VBAConstantsVector::const_iterator it = aConstCache.begin();
+
+    for( ; it != aConstCache.end(); it++ )
+    {
+        if( sKey.equalsIgnoreAsciiCase( *it ) )
+        {
+            bConstant = true;
+            break;
+        }
+    }
+    return bConstant; 
+}
+
+SbxVariable* 
+VBAConstantHelper::getVBAConstant( const String& rName )
+{
+    SbxVariable* pConst = NULL;
+    init();
+
 	::rtl::OUString sKey( rName );
-	VBAConstantsHash::const_iterator it = aConstCache.find( sKey.toAsciiLowerCase() );
-	if ( it != aConstCache.end() )
+
+    VBAConstantsHash::const_iterator it = aConstHash.find( sKey.toAsciiLowerCase() );
+
+    if ( it != aConstHash.end() )
 	{
 		pConst = new SbxVariable( SbxVARIANT );
 		pConst->SetName( rName );
 		unoToSbxValue( pConst, it->second );
 	}
+
 	return pConst;
 }
 
Index: basic/source/classes/makefile.mk
===================================================================
--- basic/source/classes/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -41,18 +41,28 @@
 
 .INCLUDE :  settings.mk
 
+ALLTAR .SEQUENTIAL : \
+        $(MISC)$/$(TARGET).don \
+        $(MISC)$/$(TARGET).slo
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
+$(MISC)$/$(TARGET).slo : $(SLOTARGET)
+        echo $@
+
 # --- Allgemein -----------------------------------------------------------
 
-COMMON_SLOFILES=	\
+SLOFILES=	\
 	$(SLO)$/sb.obj       \
 	$(SLO)$/sbxmod.obj	\
 	$(SLO)$/image.obj	\
 	$(SLO)$/sbintern.obj	\
 	$(SLO)$/sbunoobj.obj	\
 	$(SLO)$/propacc.obj	\
-	$(SLO)$/disas.obj
-
-SLOFILES=	$(COMMON_SLOFILES)	\
+	$(SLO)$/disas.obj \
+	$(SLO)$/errobject.obj \
 	$(SLO)$/eventatt.obj
 
 OBJFILES=	\
Index: basic/source/classes/sb.cxx
===================================================================
--- basic/source/classes/sb.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/sb.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -52,12 +52,17 @@
 #include "disas.hxx"
 #include "runtime.hxx"
 #include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
 #include "stdobj.hxx"
 #include "filefmt.hxx"
 #include "sb.hrc"
 #include <basrid.hxx>
 #include <vos/mutex.hxx>
 
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+using namespace ::com::sun::star::script;
+
 // #pragma SW_SEGMENT_CLASS( SBASIC, SBASIC_CODE )
 
 SV_IMPL_VARARR(SbTextPortions,SbTextPortion)
@@ -65,7 +70,29 @@
 TYPEINIT1(StarBASIC,SbxObject)
 
 #define RTLNAME "@SBRTL"
+//  i#i68894#
 
+const static String aThisComponent( RTL_CONSTASCII_USTRINGPARAM("ThisComponent") );
+const static String aVBAHook( RTL_CONSTASCII_USTRINGPARAM( "VBAGlobals" ) );
+
+SbxObject* StarBASIC::getVBAGlobals( )
+{
+	if ( !pVBAGlobals )
+		pVBAGlobals = (SbUnoObject*)Find( aVBAHook , SbxCLASS_DONTCARE );
+	return pVBAGlobals;
+}
+
+//  i#i68894#
+SbxVariable* StarBASIC::VBAFind( const String& rName, SbxClassType t )
+{
+	if( rName == aThisComponent )
+		return NULL;
+	// rename to init globals
+	if ( getVBAGlobals( ) )
+		return pVBAGlobals->Find( rName, t );
+	return NULL;
+
+}
 // Create array for conversion SFX <-> VB error code
 struct SFX_VB_ErrorItem
 {
@@ -196,6 +223,7 @@
 	{ 1004, SbERR_METHOD_FAILED },
 	{ 1005, SbERR_SETPROP_FAILED },
 	{ 1006, SbERR_GETPROP_FAILED },
+	{ 1007, SbERR_BASIC_COMPAT },
 	{ 0xFFFF, 0xFFFFFFFFL }		// End mark
 };
 
@@ -241,6 +269,8 @@
 	else
 	if( rClass.EqualsIgnoreCaseAscii( "Collection" ) )
 	{
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
 		String aCollectionName( RTL_CONSTASCII_USTRINGPARAM("Collection") );
 		return new BasicCollection( aCollectionName );
 	}
@@ -439,6 +495,7 @@
 			}
 		}
 	}
+	SetModuleType( com::sun::star::script::ModuleType::Class );
 }
 
 SbClassModuleObject::~SbClassModuleObject()
@@ -454,72 +511,7 @@
 void SbClassModuleObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
 						   const SfxHint& rHint, const TypeId& rHintType )
 {
-	bool bDone = false;
-
-	const SbxHint* pHint = PTR_CAST(SbxHint,&rHint);
-	if( pHint )
-	{
-		SbxVariable* pVar = pHint->GetVar();
-		SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
-		if( pProcProperty )
-		{
-			bDone = true;
-
-			if( pHint->GetId() == SBX_HINT_DATAWANTED )
-			{
-				String aProcName;
-				aProcName.AppendAscii( "Property Get " );
-				aProcName += pProcProperty->GetName();
-
-				SbxVariable* pMeth = Find( aProcName, SbxCLASS_METHOD );
-				if( pMeth )
-				{
-					SbxValues aVals;
-					aVals.eType = SbxVARIANT;
-					pMeth->Get( aVals );
-					pVar->Put( aVals );
-				}
-			}
-			else if( pHint->GetId() == SBX_HINT_DATACHANGED )
-			{
-				SbxVariable* pMeth = NULL;
-
-				bool bSet = pProcProperty->isSet();
-				if( bSet )
-				{
-					pProcProperty->setSet( false );
-
-					String aProcName;
-					aProcName.AppendAscii( "Property Set " );
-					aProcName += pProcProperty->GetName();
-					pMeth = Find( aProcName, SbxCLASS_METHOD );
-				}
-				if( !pMeth )	// Let
-				{
-					String aProcName;
-					aProcName.AppendAscii( "Property Let " );
-					aProcName += pProcProperty->GetName();
-					pMeth = Find( aProcName, SbxCLASS_METHOD );
-				}
-
-				if( pMeth )
-				{
-					// Setup parameters
-					SbxArrayRef xArray = new SbxArray;
-					xArray->Put( pMeth, 0 );	// Method as parameter 0
-					xArray->Put( pVar, 1 );
-					pMeth->SetParameters( xArray );
-
-					SbxValues aVals;
-					pMeth->Get( aVals );
-					pMeth->SetParameters( NULL );
-				}
-			}
-		}
-	}
-
-	if( !bDone )
-		SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
+	SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
 }
 
 SbxVariable* SbClassModuleObject::Find( const XubString& rName, SbxClassType t )
@@ -636,6 +628,7 @@
 	SetParent( p );
 	pLibInfo = NULL;
 	bNoRtl = bBreak = FALSE;
+    bVBAEnabled = FALSE;
 	pModules = new SbxArray;
 
 	if( !GetSbData()->nInst++ )
@@ -654,6 +647,8 @@
 	pRtl = new SbiStdObject( String( RTL_CONSTASCII_USTRINGPARAM(RTLNAME) ), this );
     // Search via StarBasic is always global
 	SetFlag( SBX_GBLSEARCH );
+	pVBAGlobals = NULL;
+	bQuit = FALSE;
 }
 
 // #51727 Override SetModified so that the modified state
@@ -734,12 +729,41 @@
 
 SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
 {
-	SbModule* p = new SbModule( rName );
-	p->SetSource32( rSrc );
+    ModuleInfo mInfo;
+    mInfo.ModuleSource = rSrc;
+    mInfo.ModuleType = ModuleType::Normal;
+    mInfo.ModuleName = rName;
+    return MakeModule32(  mInfo );
+}
+SbModule* StarBASIC::MakeModule32( const ModuleInfo& mInfo )
+{
+    
+    OSL_TRACE("create module %s type mInfo %d", rtl::OUStringToOString( mInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr(), mInfo.ModuleType );
+    SbModule* p = NULL;
+    switch ( mInfo.ModuleType )
+    {
+        case ModuleType::Document:
+            // In theory we should be able to create Object modules
+            // in ordinary basic ( in vba mode thought these are create
+            // by the application/basic and not by the user )
+            p = new SbObjModule( mInfo, isVBAEnabled() );
+            break;
+        case ModuleType::Class:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+			p->SetModuleType( com::sun::star::script::ModuleType::Class );	
+	    break;
+        case ModuleType::Form:
+            p = new SbUserFormModule( mInfo, isVBAEnabled() );
+	    break;
+        default:
+            p = new SbModule( mInfo.ModuleName, isVBAEnabled() );
+            
+    }
+	p->SetSource32( mInfo.ModuleSource );
 	p->SetParent( this );
 	pModules->Insert( p, pModules->Count() );
 	SetModified( TRUE );
-	return p;
+    return p;
 }
 
 void StarBASIC::Insert( SbxVariable* pVar )
@@ -910,6 +934,11 @@
 				}
 				pNamed = p;
 			}
+			// Only variables qualified by the Module Name e.g. Sheet1.foo
+			// should work for Documant && Class type Modules
+			INT32 nType = p->GetModuleType();
+			if ( nType == com::sun::star::script::ModuleType::Document || nType == com::sun::star::script::ModuleType::Form )
+				continue;
 			// otherwise check if the element is available
 			// unset GBLSEARCH-Flag (due to Rekursion)
 			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
@@ -968,6 +997,12 @@
 	return pVar;
 }
 
+void StarBASIC::QuitAndExitApplication()
+{
+    Stop();
+    bQuit = TRUE;
+}
+
 void StarBASIC::Stop()
 {
 	SbiInstance* p = pINST;
@@ -1506,6 +1541,18 @@
 	return FALSE;
 }
 
+bool StarBASIC::GetUNOConstant( const sal_Char* _pAsciiName, ::com::sun::star::uno::Any& aOut )
+{
+    bool bRes = false;
+    ::rtl::OUString sVarName( ::rtl::OUString::createFromAscii( _pAsciiName ) );
+    SbUnoObject* pGlobs = dynamic_cast<SbUnoObject*>( Find( sVarName, SbxCLASS_DONTCARE ) );
+    if ( pGlobs )
+    {
+        aOut = pGlobs->getUnoAny();
+        bRes = true;
+    }
+    return bRes;
+}
 
 //========================================================================
 // #118116 Implementation Collection object
Index: basic/source/classes/sb.src
===================================================================
--- basic/source/classes/sb.src	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/sb.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -591,6 +591,12 @@
 	{
 		Text [ en-US ] = "For loop not initialized." ;
 	};
+	String ERRCODE_BASIC_COMPAT & ERRCODE_RES_MASK
+	{
+		Text [ de ] = "$(ARG1)." ;
+		Text [ en-US ] = "$(ARG1)." ;
+		Text [ x-comment ] = " ";
+	};
 };
  // Hinweis: IDS_SBERR_TERMINATED = IDS_SBERR_START+2000.
 String IDS_SBERR_TERMINATED
Index: basic/source/classes/eventatt.cxx
===================================================================
--- basic/source/classes/eventatt.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/eventatt.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -58,7 +58,10 @@
 #include <com/sun/star/awt/XDialogProvider.hpp>
 
 #include <com/sun/star/frame/XModel.hpp>
-
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <basic/basicmanagerrepository.hxx>
+#include <basic/basmgr.hxx>
 //==================================================================================================
 
 #include <xmlscript/xmldlg_imexp.hxx>
@@ -458,6 +461,43 @@
 	return aRetDlgLibAny;
 }
 
+Any implFindDialogLibForDialogBasic( const Any& aAnyISP, SbxObject* pBasic, StarBASIC*& pFoundBasic )
+{
+	Any aDlgLibAny;
+	// Find dialog library for dialog, direct access is not possible here
+    StarBASIC* pStartedBasic = (StarBASIC*)pBasic;
+	SbxObject* pParentBasic = pStartedBasic ? pStartedBasic->GetParent() : NULL;
+	SbxObject* pParentParentBasic = pParentBasic ? pParentBasic->GetParent() : NULL;
+
+	SbxObject* pSearchBasic1 = NULL;
+	SbxObject* pSearchBasic2 = NULL;
+	if( pParentParentBasic )
+	{
+		pSearchBasic1 = pParentBasic;
+		pSearchBasic2 = pParentParentBasic;
+	}
+	else
+	{
+		pSearchBasic1 = pStartedBasic;
+		pSearchBasic2 = pParentBasic;
+	}
+	if( pSearchBasic1 )
+	{
+		aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic1 );
+
+		if ( aDlgLibAny.hasValue() )
+			pFoundBasic = (StarBASIC*)pSearchBasic1;
+
+		else if( pSearchBasic2 )
+		{
+			aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic2 );
+			if ( aDlgLibAny.hasValue() )
+				pFoundBasic = (StarBASIC*)pSearchBasic2;
+		}
+	}
+	return aDlgLibAny;
+}
+
 static ::rtl::OUString aDecorationPropName =
 	::rtl::OUString::createFromAscii( "Decoration" );
 static ::rtl::OUString aTitlePropName =
@@ -537,39 +577,51 @@
 		{}
 	}
 
-	// Find dialog library for dialog, direct access is not possible here
-    StarBASIC* pStartedBasic = pINST->GetBasic();
-	SbxObject* pParentBasic = pStartedBasic ? pStartedBasic->GetParent() : NULL;
-	SbxObject* pParentParentBasic = pParentBasic ? pParentBasic->GetParent() : NULL;
-
-	SbxObject* pSearchBasic1 = NULL;
-	SbxObject* pSearchBasic2 = NULL;
-	if( pParentParentBasic )
-	{
-		pSearchBasic1 = pParentBasic;
-		pSearchBasic2 = pParentParentBasic;
-	}
-	else
-	{
-		pSearchBasic1 = pStartedBasic;
-		pSearchBasic2 = pParentBasic;
-	}
-
 	Any aDlgLibAny;
-	if( pSearchBasic1 )
-	{
-		aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic1 );
-		if( pSearchBasic2 && aDlgLibAny.getValueType().getTypeClass() == TypeClass_VOID )
-			aDlgLibAny = implFindDialogLibForDialog( aAnyISP, pSearchBasic2 );
-	}
-
-
+	bool bDocDialog = false;
+	StarBASIC* pFoundBasic = NULL;
     OSL_TRACE("About to try get a hold of ThisComponent");
-    Reference< frame::XModel > xModel = getModelFromBasic( pStartedBasic ) ;
-	Reference< XScriptListener > xScriptListener = new BasicScriptListener_Impl( pStartedBasic, xModel );
+    Reference< frame::XModel > xModel = getModelFromBasic( pINST->GetBasic() ) ;
+		aDlgLibAny = implFindDialogLibForDialogBasic( aAnyISP, pINST->GetBasic(), pFoundBasic );
+		// If we found the dialog then it belongs to the Search basic
+		if ( !pFoundBasic )
+		{
+			Reference< frame::XDesktop > xDesktop( xMSF->createInstance
+		( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.frame.Desktop" ) ) ),
+			UNO_QUERY );
+			Reference< container::XEnumeration > xModels;
+			if ( xDesktop.is() )
+			{
+				Reference< container::XEnumerationAccess > xComponents( xDesktop->getComponents(), UNO_QUERY );
+				if ( xComponents.is() )
+					xModels.set( xComponents->createEnumeration(), UNO_QUERY );
+				if ( xModels.is() )
+				{
+					while ( xModels->hasMoreElements() )
+					{
+						Reference< frame::XModel > xNextModel( xModels->nextElement(), UNO_QUERY );
+						if ( xNextModel.is() )
+						{
+							BasicManager* pMgr = basic::BasicManagerRepository::getDocumentBasicManager( xNextModel );	
+							if ( pMgr )
+								aDlgLibAny = implFindDialogLibForDialogBasic( aAnyISP, pMgr->GetLib(0), pFoundBasic );
+							if ( aDlgLibAny.hasValue() )
+							{
+								bDocDialog = true;
+								xModel = xNextModel;
+								break;
+							} 
+						}
+					}
+				}
+			}
+		}
+	if ( pFoundBasic )
+		bDocDialog = pFoundBasic->IsDocBasic();
+       Reference< XScriptListener > xScriptListener = new BasicScriptListener_Impl( pINST->GetBasic(), xModel );
 
 	Sequence< Any > aArgs( 4 );
-	aArgs[ 0 ] <<= xModel;
+	aArgs[ 0 ] <<= bDocDialog ? xModel : uno::Reference< uno::XInterface >();
 	aArgs[ 1 ] <<= xInput;
 	aArgs[ 2 ] = aDlgLibAny;
 	aArgs[ 3 ] <<= xScriptListener;
Index: basic/source/classes/sbxmod.cxx
===================================================================
--- basic/source/classes/sbxmod.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/classes/sbxmod.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -55,6 +55,8 @@
 
 #include <basic/basrdll.hxx>
 #include <vos/mutex.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 
 // for the bsearch
@@ -70,13 +72,30 @@
 
 #include <stdio.h>
 
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/awt/XDialogProvider.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <comphelper/anytostring.hxx>
+#include <com/sun/star/document/XVbaMethodParameter.hpp> //liuchen 2009-7-21
+extern void unoToSbxValue( SbxVariable* pVar, const ::com::sun::star::uno::Any& aValue ); //liuchen 2009-7-21
+extern ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );  //liuchen 2009-7-21
 
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <vcl/svapp.hxx>
+using namespace ::com::sun::star; 
+
 TYPEINIT1(SbModule,SbxObject)
 TYPEINIT1(SbMethod,SbxMethod)
 TYPEINIT1(SbProperty,SbxProperty)
 TYPEINIT1(SbProcedureProperty,SbxProperty)
 TYPEINIT1(SbJScriptModule,SbModule)
 TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
+TYPEINIT1(SbUserFormModule,SbObjModule)
 
 SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
 SV_IMPL_VARARR(SbiBreakpoints,USHORT)
@@ -84,18 +103,73 @@
 
 SV_IMPL_VARARR(HighlightPortions, HighlightPortion)
 
+class AsyncQuitHandler
+{
+    AsyncQuitHandler() {}
+    AsyncQuitHandler( const AsyncQuitHandler&);
+public:
+    static AsyncQuitHandler& instance() 
+    {
+        static AsyncQuitHandler dInst;
+        return dInst;
+    }
 
+    void QuitApplication()
+    {
+        uno::Reference< lang::XMultiServiceFactory > xFactory = comphelper::getProcessServiceFactory();
+        if ( xFactory.is() )
+	{
+            uno::Reference< frame::XDesktop > xDeskTop( xFactory->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.frame.Desktop") ) ), uno::UNO_QUERY );
+           if ( xDeskTop.is() )
+               xDeskTop->terminate(); 
+        }
+    }
+    DECL_LINK( OnAsyncQuit, void* );
+};
+
+IMPL_LINK( AsyncQuitHandler, OnAsyncQuit, void*, /*pNull*/ )
+{
+    QuitApplication();
+    return 0L;
+}
+
+bool UnlockControllerHack( StarBASIC* pBasic )
+{
+    bool bRes = false;
+    if ( pBasic && pBasic->IsDocBasic() )
+    {
+        uno::Any aUnoVar;
+        ::rtl::OUString sVarName( ::rtl::OUString::createFromAscii( "ThisComponent" ) );
+        SbUnoObject* pGlobs = dynamic_cast<SbUnoObject*>( pBasic->Find( sVarName, SbxCLASS_DONTCARE ) );
+        if ( pGlobs )
+            aUnoVar = pGlobs->getUnoAny(); 
+        uno::Reference< frame::XModel > xModel( aUnoVar, uno::UNO_QUERY);
+        if ( xModel.is() )
+        {
+            try
+            {
+                xModel->unlockControllers();
+                bRes = true;
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+    }
+    return bRes;
+}
 /////////////////////////////////////////////////////////////////////////////
 
 // Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
 // Elemente von anderen Modulen aus gefunden werden koennen.
 
-SbModule::SbModule( const String& rName )
+SbModule::SbModule( const String& rName, bool bVBACompat )
 		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), mbVBACompat( bVBACompat ),  pDocObject( NULL ), bIsProxyModule( false )
 {
 	SetName( rName );
 	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	SetModuleType( com::sun::star::script::ModuleType::Normal );
 }
 
 SbModule::~SbModule()
@@ -270,7 +344,10 @@
 
 SbxVariable* SbModule::Find( const XubString& rName, SbxClassType t )
 {
+	// make sure a search in an uninstatiated class module will fail
 	SbxVariable* pRes = SbxObject::Find( rName, t );
+	if ( bIsProxyModule )
+		return NULL;
 	if( !pRes && pImage )
 	{
 		SbiInstance* pInst = pINST;
@@ -332,6 +409,64 @@
 		SbxVariable* pVar = pHint->GetVar();
 		SbProperty* pProp = PTR_CAST(SbProperty,pVar);
 		SbMethod* pMeth = PTR_CAST(SbMethod,pVar);
+		SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
+		if( pProcProperty )
+		{
+			if( pHint->GetId() == SBX_HINT_DATAWANTED )
+			{
+				String aProcName;
+				aProcName.AppendAscii( "Property Get " );
+				aProcName += pProcProperty->GetName();
+
+				SbxVariable* pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				if( pPropMeth )
+				{
+					// Setup parameters
+					pPropMeth->SetParameters( pVar->GetParameters() );
+
+					SbxValues aVals;
+					aVals.eType = SbxVARIANT;
+					pPropMeth->Get( aVals );
+					pVar->Put( aVals );
+				}
+			}
+			else if( pHint->GetId() == SBX_HINT_DATACHANGED )
+			{
+				SbxVariable* pPropMeth = NULL;
+
+				bool bSet = pProcProperty->isSet();
+				if( bSet )
+				{
+					pProcProperty->setSet( false );
+
+					String aProcName;
+					aProcName.AppendAscii( "Property Set " );
+					aProcName += pProcProperty->GetName();
+					pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+				if( !pPropMeth )	// Let
+				{
+					String aProcName;
+					aProcName.AppendAscii( "Property Let " );
+					aProcName += pProcProperty->GetName();
+					pPropMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+
+				if( pPropMeth )
+				{
+					// Setup parameters
+					SbxArrayRef xArray = new SbxArray;
+					xArray->Put( pPropMeth, 0 );	// Method as parameter 0
+					xArray->Put( pVar, 1 );
+					pPropMeth->SetParameters( xArray );
+
+					SbxValues aVals;
+					pPropMeth->Get( aVals );
+					pPropMeth->SetParameters( NULL );
+				}
+			}
+		}
+
 		if( pProp )
 		{
 			if( pProp->GetModule() != this )
@@ -372,6 +507,7 @@
 	aOUSource = r;
 	StartDefinitions();
 	SbiTokenizer aTok( r );
+        aTok.SetCompatible( IsVBACompat() );
 	while( !aTok.IsEof() )
 	{
 		SbiToken eEndTok = NIL;
@@ -396,13 +532,6 @@
 				{
 					eEndTok = ENDPROPERTY; break;
 				}
-				if( eCurTok == OPTION )
-				{
-					eCurTok = aTok.Next();
-					if( eCurTok == COMPATIBLE
-					|| ( ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 ) ) )
-						aTok.SetCompatible( true );
-				}
 			}
 			eLastTok = eCurTok;
 		}
@@ -542,16 +671,27 @@
     if( ((StarBASIC*)p) != pBasic )
 	    ClearUnoObjectsInRTL_Impl_Rek( (StarBASIC*)p );
 }
+bool SbModule::IsVBACompat()
+{
+	return mbVBACompat;
+}
 
+void SbModule::SetVBACompat( bool bCompat )
+{
+	mbVBACompat = bCompat;
+}
 // Ausfuehren eines BASIC-Unterprogramms
 USHORT SbModule::Run( SbMethod* pMeth )
 {
+	OSL_TRACE("About to run %s, vba compatmode is %d", rtl::OUStringToOString( pMeth->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), mbVBACompat );
 	static USHORT nMaxCallLevel = 0;
 	static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
 	static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
 
 	USHORT nRes = 0;
 	BOOL bDelInst = BOOL( pINST == NULL );
+        bool bQuit = false;
+{
 	StarBASICRef xBasic;
 	if( bDelInst )
 	{
@@ -637,10 +777,10 @@
 			if( pRt->pNext )
 				pRt->pNext->block();
 			pINST->pRun = pRt;
-			if ( SbiRuntime ::isVBAEnabled() )
+			if ( mbVBACompat )
                         {
 				pINST->EnableCompatibility( TRUE );
-				pRt->SetVBAEnabled( true );
+				//pRt->SetVBAEnabled( true ); // can we get rid of this
                         }
 			while( pRt->Step() ) {}
 			if( pRt->pNext )
@@ -672,6 +812,15 @@
 
 			delete pRt;
 			pMOD = pOldMod;
+			if ( pINST->nCallLvl == 0 && IsVBACompat() )
+			{
+				// VBA always ensure screenupdating is enabled after completing
+				StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
+				if ( pBasic && pBasic->IsDocBasic() )
+				{
+					UnlockControllerHack( pBasic );
+				}
+			}
 			if( bDelInst )
 			{
 				// #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -696,6 +845,11 @@
 		pINST->nCallLvl--;			// Call-Level wieder runter
 		StarBASIC::FatalError( SbERR_STACK_OVERFLOW );
     }
+		
+	// VBA always ensure screenupdating is enabled after completing
+	StarBASIC* pBasic = PTR_CAST(StarBASIC,GetParent());
+	if ( pBasic && pBasic->IsDocBasic() && !pINST )
+		UnlockControllerHack( pBasic );
 	if( bDelInst )
 	{
 		// #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
@@ -705,6 +859,15 @@
 		delete pINST;
 		pINST = NULL;
 	}
+	if ( pBasic && pBasic->IsDocBasic() && pBasic->IsQuitApplication() && !pINST )
+            bQuit = true;
+}
+        if ( bQuit )
+        {
+            //QuitApplicationHack();
+            Application::PostUserEvent( LINK( &AsyncQuitHandler::instance(), AsyncQuitHandler, OnAsyncQuit ), NULL );
+
+        }
 	return nRes;
 }
 
@@ -744,6 +907,33 @@
 }
 
 // Mit private/dim deklarierte Variablen loeschen
+
+void SbModule::AddVarName( const String& aName ) 
+{ 
+	// see if the name is added allready
+	std::vector< String >::iterator it_end = mModuleVariableNames.end();
+	for ( std::vector< String >::iterator it = mModuleVariableNames.begin(); it != it_end; ++it )
+	{
+		if ( aName == *it )
+			return;	
+	}
+	mModuleVariableNames.push_back( aName ); 
+}
+
+void SbModule::RemoveVars()
+{
+    std::vector< String >::iterator it_end = mModuleVariableNames.end();
+    for ( std::vector< String >::iterator it = mModuleVariableNames.begin(); it != it_end; ++it )
+    {
+	// We don't want a Find being called in a derived class ( e.g. 
+	// SbUserform because it could trigger say an initialise event  
+	// which would cause basic to be re-run in the middle of the init ( and remember RemoveVars is called from compile and we don't want code to run as part of the compile )
+	SbxVariableRef p = SbModule::Find( *it, SbxCLASS_PROPERTY );
+	if( p.Is() )
+		Remove (p);
+    }
+}
+
 void SbModule::ClearPrivateVars()
 {
 	for( USHORT i = 0 ; i < pProps->Count() ; i++ )
@@ -1124,7 +1314,49 @@
 	return false;
 }
 
+class ErrorHdlResetter
+{
+    Link    mErrHandler;
+    bool mbError;
+    public:
+    ErrorHdlResetter() : mbError( false )
+    {
+        // save error handler 
+        mErrHandler = StarBASIC::GetGlobalErrorHdl();
+        // set new error handler
+        StarBASIC::SetGlobalErrorHdl( LINK( this, ErrorHdlResetter, BasicErrorHdl ) );
+    }
+    ~ErrorHdlResetter()
+    {
+        // restore error handler 
+        StarBASIC::SetGlobalErrorHdl(mErrHandler);
+    }
+    DECL_LINK( BasicErrorHdl, StarBASIC * );
+    bool HasError() { return mbError; }
+};
+IMPL_LINK( ErrorHdlResetter, BasicErrorHdl, StarBASIC *, /*pBasic*/)
+{
+    mbError = true;
+    return 0;        
+}
 
+bool SbModule::HasExeCode()
+{
+
+        ErrorHdlResetter aGblErrHdl;
+	// And empty Image always has the Global Chain set up
+        static const unsigned char pEmptyImage[] = { 0x45, 0x0 , 0x0, 0x0, 0x0 };
+        // lets be stricter for the moment than VBA
+
+	bool bRes = false;
+	if ( !IsCompiled() )
+		Compile();
+	if ( pImage && !( pImage->GetCodeSize() == 5 && ( memcmp( pImage->GetCode(), pEmptyImage, pImage->GetCodeSize() ) == 0 ) )
+        || aGblErrHdl.HasError() )
+		bRes = true;
+	return bRes;
+}
+
 // Store only image, no source
 BOOL SbModule::StoreBinaryData( SvStream& rStrm )
 {
@@ -1173,7 +1405,6 @@
     return bRet;
 }
 
-
 BOOL SbModule::LoadCompleted()
 {
 	SbxArray* p = GetMethods();
@@ -1241,6 +1472,7 @@
 	nLine1		 =
 	nLine2		 = 0;
 	refStatics = new SbxArray;
+    mCaller          = 0;
 	// AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
 	SetFlag( SBX_NO_MODIFY );
 }
@@ -1255,6 +1487,7 @@
 	nLine1		 = r.nLine1;
 	nLine2		 = r.nLine2;
         refStatics = r.refStatics; 
+ 	mCaller          = r.mCaller; 
 	SetFlag( SBX_NO_MODIFY );
 }
 
@@ -1323,8 +1556,13 @@
 // Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
 // #34191# Mit speziellem RefCounting, damit das Basic nicht durch CloseDocument()
 // abgeschossen werden kann. Rueckgabewert wird als String geliefert.
-ErrCode SbMethod::Call( SbxValue* pRet )
+ErrCode SbMethod::Call( SbxValue* pRet, SbxVariable* pCaller )
 {
+	if ( pCaller )
+	{
+ 		OSL_TRACE("SbMethod::Call Have been passed a caller 0x%x", pCaller );
+		mCaller = pCaller;
+	}
 	// RefCount vom Modul hochzaehlen
 	SbModule* pMod_ = (SbModule*)GetParent();
 	pMod_->AddRef();
@@ -1352,7 +1590,7 @@
 	// Objekte freigeben
 	pMod_->ReleaseRef();
 	pBasic->ReleaseRef();
-
+	mCaller = 0;
 	return nErr;
 }
 
@@ -1413,7 +1651,386 @@
 
 
 /////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible )
+    : SbModule( mInfo.ModuleName, bIsVbaCompatible )
+{
+    SetModuleType( mInfo.ModuleType );
+    if ( mInfo.ModuleType == script::ModuleType::Form )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Form" ) );
+    }
+    else if ( mInfo.ModuleObject.is() )
+        SetUnoObject( uno::makeAny( mInfo.ModuleObject ) );
+}
+void
+SbObjModule::SetUnoObject( const uno::Any& aObj ) throw ( uno::RuntimeException )
+{
+    SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxVariable*)pDocObject);
+    if ( pUnoObj && pUnoObj->getUnoAny() == aObj ) // object is equal, nothing to do
+        return;
+    pDocObject = new SbUnoObject( GetName(), uno::makeAny( aObj ) );
+            
+    com::sun::star::uno::Reference< com::sun::star::lang::XServiceInfo > xServiceInfo( aObj, com::sun::star::uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Worksheet" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Worksheet" ) );
+    }
+    else if( xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Workbook" ) ) )
+    {
+        SetClassName( rtl::OUString::createFromAscii( "Workbook" ) );
+    }
+}
 
+SbxVariable*
+SbObjModule::GetObject() 
+{
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    //OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+        pVar = pDocObject->Find( rName, t );
+    if ( !pVar )
+        pVar = SbModule::Find( rName, t );
+    return pVar;
+}
+
+typedef ::cppu::WeakImplHelper1< awt::XTopWindowListener > EventListener_BASE;
+
+class FormObjEventListenerImpl : public EventListener_BASE
+{
+    SbUserFormModule* mpUserForm;
+    uno::Reference< lang::XComponent > mxComponent;
+    bool mbDisposed;
+    sal_Bool mbOpened;
+    sal_Bool mbActivated;
+    sal_Bool mbShowing;
+    FormObjEventListenerImpl(); // not defined
+    FormObjEventListenerImpl(const FormObjEventListenerImpl&); // not defined
+public:
+    FormObjEventListenerImpl( SbUserFormModule* pUserForm, const uno::Reference< lang::XComponent >& xComponent ) : mpUserForm( pUserForm ), mxComponent( xComponent) , mbDisposed( false ), mbOpened( sal_False ), mbActivated( sal_False ), mbShowing( sal_False )
+    {
+        if ( mxComponent.is() );
+        {
+	    uno::Reference< awt::XTopWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+            //uno::Reference< awt::XWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+            OSL_TRACE("*********** Registering the listener");
+            xList->addTopWindowListener( this );
+        }
+    }
+
+    ~FormObjEventListenerImpl()
+    {
+        removeListener();
+    }
+    sal_Bool isShowing() { return mbShowing; }
+    void removeListener()
+    {
+        try
+        {
+            if ( mxComponent.is() && !mbDisposed )
+            {
+                uno::Reference< awt::XTopWindow > xList( mxComponent, uno::UNO_QUERY_THROW );;
+                OSL_TRACE("*********** Removing the listener");
+            	xList->removeTopWindowListener( this );
+                mxComponent = NULL;
+            }
+        }
+        catch( uno::Exception& ) {}
+    } 
+    virtual void SAL_CALL windowOpened( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+        {
+            mbOpened = sal_True;
+            mbShowing = sal_True;
+            if ( mbActivated )
+            {
+                mbOpened = mbActivated = sal_False;
+                mpUserForm->triggerActivateEvent();
+            }
+        }
+    }
+	
+    //liuchen 2009-7-21, support Excel VBA Form_QueryClose event
+    virtual void SAL_CALL windowClosing( const lang::EventObject& e ) throw (uno::RuntimeException)
+    {    
+		uno::Reference< awt::XDialog > xDialog( e.Source, uno::UNO_QUERY );
+		if ( xDialog.is() )
+		{
+			uno::Reference< awt::XControl > xControl( xDialog, uno::UNO_QUERY );
+			if ( xControl->getPeer().is() )
+			{
+				uno::Reference< document::XVbaMethodParameter > xVbaMethodParameter( xControl->getPeer(), uno::UNO_QUERY );
+				if ( xVbaMethodParameter.is() )
+				{	
+					sal_Int8 nCancel = 0;
+					sal_Int8 nCloseMode = 0;
+
+					Sequence< Any > aParams;
+					aParams.realloc(2);
+					aParams[0] <<= nCancel;
+					aParams[1] <<= nCloseMode;
+
+					mpUserForm->triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ),
+												aParams);
+					xVbaMethodParameter->setVbaMethodParameter( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Cancel")), aParams[0]);
+					return;
+	
+				}			
+			}		
+		}
+    	
+    	mpUserForm->triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ) );
+    }
+	//liuchen 2009-7-21
+	
+    virtual void SAL_CALL windowClosed( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException) { mbOpened = sal_False; mbShowing = sal_False; }
+    virtual void SAL_CALL windowMinimized( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException) {}
+    virtual void SAL_CALL windowNormalized( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException){}
+    virtual void SAL_CALL windowActivated( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+        {
+            mbActivated = sal_True;
+            if ( mbOpened )
+            {
+                mbOpened = mbActivated = sal_False;
+                mpUserForm->triggerActivateEvent();
+            }
+        }
+    }
+   
+    virtual void SAL_CALL windowDeactivated( const lang::EventObject& /*e*/ ) throw (uno::RuntimeException)
+    {
+        if ( mpUserForm  )
+            mpUserForm->triggerDeActivateEvent();
+    }
+
+
+    virtual void SAL_CALL disposing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+    {
+        OSL_TRACE("** Userform/Dialog disposing");
+        mbDisposed = true;
+        uno::Any aSource;
+        aSource <<= Source;   
+        mxComponent = NULL;
+        if ( mpUserForm )
+            mpUserForm->ResetApiObj();
+    }
+};
+
+SbUserFormModule::SbUserFormModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsCompat )
+    :SbObjModule( mInfo, bIsCompat ), mbInit( false )
+{
+        m_xModel.set( mInfo.ModuleObject, uno::UNO_QUERY_THROW );
+}
+
+void SbUserFormModule::ResetApiObj()
+{
+        if (  m_xDialog.is() ) // probably someone close the dialog window
+	{
+            triggerTerminateEvent();
+        }
+        pDocObject = NULL;
+	m_xDialog = NULL;
+}
+
+void SbUserFormModule::triggerMethod( const String& aMethodToRun )
+{
+	Sequence< Any > aArguments;
+	triggerMethod( aMethodToRun, aArguments );
+}
+void SbUserFormModule::triggerMethod( const String& aMethodToRun, Sequence< Any >& aArguments)
+{
+	OSL_TRACE("*** trigger %s ***", rtl::OUStringToOString( aMethodToRun, RTL_TEXTENCODING_UTF8 ).getStr() );
+	// Search method
+	SbxVariable* pMeth = SbObjModule::Find( aMethodToRun, SbxCLASS_METHOD );
+	if( pMeth )
+	{		
+                 //liuchen 2009-7-21, support Excel VBA UserForm_QueryClose event with parameters
+		if ( aArguments.getLength() > 0 )   // Setup parameters
+		{
+			SbxArrayRef xArray = new SbxArray;
+			xArray->Put( pMeth, 0 );	// Method as parameter 0
+
+			for ( sal_Int32 i = 0; i < aArguments.getLength(); ++i )
+			{
+				SbxVariableRef xSbxVar = new SbxVariable( SbxVARIANT );
+                unoToSbxValue( static_cast< SbxVariable* >( xSbxVar ), aArguments[i] );
+                xArray->Put( xSbxVar, static_cast< USHORT >( i ) + 1 );
+
+				// Enable passing by ref
+				if ( xSbxVar->GetType() != SbxVARIANT )
+					xSbxVar->SetFlag( SBX_FIXED );
+			}
+			pMeth->SetParameters( xArray );
+
+			SbxValues aVals;
+			pMeth->Get( aVals );
+			
+			for ( sal_Int32 i = 0; i < aArguments.getLength(); ++i )
+			{
+				aArguments[i] = sbxToUnoValue( xArray->Get( static_cast< USHORT >(i) + 1) );
+			}		
+			pMeth->SetParameters( NULL );
+		}
+		else
+//liuchen 2009-7-21
+		{
+			SbxValues aVals;
+			pMeth->Get( aVals );
+		}
+	}
+}
+
+void SbUserFormModule::triggerActivateEvent( void )
+{
+        OSL_TRACE("**** entering SbUserFormModule::triggerActivate");
+	triggerMethod( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserForm_activate") ) );
+        OSL_TRACE("**** leaving SbUserFormModule::triggerActivate");
+}
+
+void SbUserFormModule::triggerDeActivateEvent( void )
+{
+        OSL_TRACE("**** SbUserFormModule::triggerDeActivate");
+	triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_DeActivate") ) );
+}
+
+void SbUserFormModule::triggerInitializeEvent( void )
+
+{
+	if ( mbInit )
+		return;
+        OSL_TRACE("**** SbUserFormModule::triggerInitializeEvent");
+	static String aInitMethodName( RTL_CONSTASCII_USTRINGPARAM("Userform_Initialize") );
+	triggerMethod( aInitMethodName );
+	mbInit = true;
+}
+
+void SbUserFormModule::triggerTerminateEvent( void )
+{
+        OSL_TRACE("**** SbUserFormModule::triggerTerminateEvent");
+	static String aTermMethodName( RTL_CONSTASCII_USTRINGPARAM("Userform_Terminate") );
+	triggerMethod( aTermMethodName );
+	mbInit=false;
+}
+
+void SbUserFormModule::load()
+{
+    OSL_TRACE("** load() ");
+    // forces a load
+    if ( !pDocObject )
+        InitObject();
+}
+
+//liuchen 2009-7-21 change to accmordate VBA's beheavior
+void SbUserFormModule::Unload()
+{
+    OSL_TRACE("** Unload() ");
+
+	sal_Int8 nCancel = 0;
+	sal_Int8 nCloseMode = 1;
+
+	Sequence< Any > aParams;
+	aParams.realloc(2);
+	aParams[0] <<= nCancel;
+	aParams[1] <<= nCloseMode;
+
+	triggerMethod( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Userform_QueryClose") ), aParams);
+
+	aParams[0] >>= nCancel;
+	if (nCancel == 1)
+	{
+		return;
+	}
+	
+    if ( m_xDialog.is() )
+    {
+		triggerTerminateEvent();
+    }
+	// Search method
+	SbxVariable* pMeth = SbObjModule::Find( String( RTL_CONSTASCII_USTRINGPARAM( "UnloadObject" ) ), SbxCLASS_METHOD );
+	if( pMeth )
+	{
+		OSL_TRACE("Attempting too run the UnloadObjectMethod");
+                m_xDialog = NULL; //release ref to the uno object
+		SbxValues aVals;
+               FormObjEventListenerImpl* pFormListener = dynamic_cast< FormObjEventListenerImpl* >( m_DialogListener.get() );
+		bool bWaitForDispose = true; // assume dialog is showing
+                if ( pFormListener ) 
+		{
+			bWaitForDispose = pFormListener->isShowing();
+			OSL_TRACE("Showing %d", bWaitForDispose );
+		}
+		pMeth->Get( aVals);
+                if ( !bWaitForDispose )
+                {
+                    // we've either already got a dispose or we'er never going to get one 
+		    ResetApiObj();
+                } // else wait for dispose
+		OSL_TRACE("UnloadObject completed ( we hope )");
+	}
+}
+//liuchen
+
+void SbUserFormModule::InitObject()
+{
+    try
+    {
+
+        String aHook( RTL_CONSTASCII_USTRINGPARAM( "VBAGlobals" ) );
+        SbUnoObject* pGlobs = (SbUnoObject*)GetParent()->Find( aHook, SbxCLASS_DONTCARE ); 
+        if ( m_xModel.is() && pGlobs )
+        {
+            
+            uno::Reference< lang::XMultiServiceFactory > xVBAFactory( pGlobs->getUnoAny(), uno::UNO_QUERY_THROW );
+            uno::Reference< lang::XMultiServiceFactory > xFactory = comphelper::getProcessServiceFactory();
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[ 0 ] <<= m_xModel;
+            rtl::OUString sDialogUrl( RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.script:" ) );
+            rtl::OUString sProjectName( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+            if ( this->GetParent()->GetName().Len() )
+                sProjectName = this->GetParent()->GetName(); 
+            sDialogUrl = sDialogUrl.concat( sProjectName ).concat( rtl::OUString( '.') ).concat( GetName() ).concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("?location=document") ) ); 
+
+            uno::Reference< awt::XDialogProvider > xProvider( xFactory->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.DialogProvider")), aArgs  ), uno::UNO_QUERY_THROW );
+            m_xDialog = xProvider->createDialog( sDialogUrl );
+
+            // create vba api object
+            aArgs.realloc( 3 );
+            aArgs[ 0 ] = uno::Any();
+            aArgs[ 1 ] <<= m_xDialog;
+            aArgs[ 2 ] <<= m_xModel;
+            pDocObject = new SbUnoObject( GetName(), uno::makeAny( xVBAFactory->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.UserForm")), aArgs  ) ) );
+            uno::Reference< lang::XComponent > xComponent( aArgs[ 1 ], uno::UNO_QUERY_THROW );
+            // remove old listener if it exists
+            FormObjEventListenerImpl* pFormListener = dynamic_cast< FormObjEventListenerImpl* >( m_DialogListener.get() );
+            if ( pFormListener )
+                pFormListener->removeListener();
+            m_DialogListener = new FormObjEventListenerImpl( this, xComponent );
+
+            triggerInitializeEvent();
+        } 
+    }
+    catch( uno::Exception& e )
+    {
+    }
+
+}
+
+SbxVariable*
+SbUserFormModule::Find( const XubString& rName, SbxClassType t )
+{
+    if ( !pDocObject && !GetSbData()->bRunInit && pINST )
+        InitObject();
+    return SbObjModule::Find( rName, t );
+}
+/////////////////////////////////////////////////////////////////////////
+
 SbProperty::SbProperty( const String& r, SbxDataType t, SbModule* p )
 		: SbxProperty( r, t ), pMod( p )
 {
Index: basic/source/comp/exprtree.cxx
===================================================================
--- basic/source/comp/exprtree.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/exprtree.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -378,8 +378,12 @@
 		// Typ SbxOBJECT sein
 		if( pDef->GetType() != SbxOBJECT && pDef->GetType() != SbxVARIANT )
 		{
-			pParser->Error( SbERR_BAD_DECLARATION, aSym );
-			bError = TRUE;
+			// defer error until runtime if in vba mode
+			if ( !pParser->IsVBASupportOn() )
+                        {
+				pParser->Error( SbERR_BAD_DECLARATION, aSym );
+				bError = TRUE;
+			}
 		}
 		if( !bError )
 			pNd->aVar.pNext = ObjTerm( *pDef );
@@ -716,7 +720,7 @@
 			pNd = new SbiExprNode( pParser, pNd, eTok, Comp() ), nCount++;
 		}
 		// Mehrere Operatoren hintereinander gehen nicht
-		if( nCount > 1 )
+		if( nCount > 1 && !pParser->IsVBASupportOn() )
 		{
 			pParser->Error( SbERR_SYNTAX );
 			bError = TRUE;
Index: basic/source/comp/token.cxx
===================================================================
--- basic/source/comp/token.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/token.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -61,6 +61,7 @@
 	{ ANY,		"Any" },
 	{ APPEND,	"Append" },
 	{ AS,		"As" },
+	{ ATTRIBUTE,"Attribute" },
 	{ BASE,		"Base" },
 	{ BINARY,	"Binary" },
 	{ TBOOLEAN,	"Boolean" },
@@ -593,6 +594,13 @@
 		}
 		return eCurTok;
 	}
+
+	// check whether the keyword has been dim as a variable
+	if( IsSymbol( tp->t ) )
+	{
+		return eCurTok = SYMBOL;
+	}
+	
 	// Sind Datentypen Keywords?
 	// Nur nach AS, sonst sind es Symbole!
 	// Es gibt ja ERROR(), DATA(), STRING() etc.
Index: basic/source/comp/sbcomp.cxx
===================================================================
--- basic/source/comp/sbcomp.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/sbcomp.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -134,6 +134,7 @@
 	if( bRet )
 	{
 		pBasic->ClearAllModuleVars();
+		RemoveVars(); // remove 'this' Modules variables
 		// clear all method statics
 		for( USHORT i = 0; i < pMethods->Count(); i++ )
 		{
Index: basic/source/comp/codegen.cxx
===================================================================
--- basic/source/comp/codegen.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/codegen.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -130,12 +130,12 @@
 	// OPTION EXPLICIT-Flag uebernehmen
 	if( pParser->bExplicit )
 		p->SetFlag( SBIMG_EXPLICIT );
-	if( pParser->IsVBASupportOn() )
-		p->SetFlag( SBIMG_VBASUPPORT );
 	
 	int nIfaceCount = 0;
-	if( pParser->bClassModule )
+	if( rMod.mnType == com::sun::star::script::ModuleType::Class )
 	{
+                OSL_TRACE("COdeGen::save() classmodule processing");
+		rMod.bIsProxyModule = true;
 		p->SetFlag( SBIMG_CLASSMODULE );
 		pCLASSFAC->AddClassModule( &rMod );
 
@@ -158,6 +158,10 @@
 	else
 	{
 		pCLASSFAC->RemoveClassModule( &rMod );
+		// Only a ClassModule can revert to Normal
+                if ( rMod.mnType == com::sun::star::script::ModuleType::Class )
+			rMod.mnType = com::sun::star::script::ModuleType::Normal;
+		rMod.bIsProxyModule = false;
 	}
 	if( pParser->bText )
 		p->SetFlag( SBIMG_COMPARETEXT );
@@ -240,6 +244,8 @@
 					if( nPass == 1 )
 						aPropName = aPropName.Copy( aIfaceName.Len() + 1 );
 					SbProcedureProperty* pProcedureProperty = NULL;
+                                        OSL_TRACE("*** getProcedureProperty for thing %s",
+						rtl::OUStringToOString( aPropName,RTL_TEXTENCODING_UTF8 ).getStr() );
 					pProcedureProperty = rMod.GetProcedureProperty( aPropName, ePropType );
 				}
 				if( nPass == 1 )
Index: basic/source/comp/dim.cxx
===================================================================
--- basic/source/comp/dim.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/dim.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,7 +32,9 @@
 #include "precompiled_basic.hxx"
 #include <basic/sbx.hxx>
 #include "sbcomp.hxx"
+#include "sbunoobj.hxx"
 
+
 // Deklaration einer Variablen
 // Bei Fehlern wird bis zum Komma oder Newline geparst.
 // Returnwert: eine neue Instanz, die eingefuegt und dann geloescht wird.
@@ -40,7 +42,10 @@
 
 SbiSymDef* SbiParser::VarDecl( SbiDimList** ppDim, BOOL bStatic, BOOL bConst )
 {
-	if( !TestSymbol() ) return NULL;
+	// Some keywords can be dim as varibles like " Sub Test( Name as String )"
+	eCurTok = Peek();
+	BOOL bKwdOk = IsVBASupportOn() ? BOOL( (eCurTok == NAME) || (eCurTok == LINE) || (eCurTok == TEXT) ): FALSE;
+	if( !TestSymbol( bKwdOk ) ) return NULL;
 	SbxDataType t = eScanType;
 	SbiSymDef* pDef = bConst ? new SbiConstDef( aSym ) : new SbiSymDef( aSym );
 	SbiDimList* pDim = NULL;
@@ -144,7 +149,7 @@
 							}
 						}
 					}
-					else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) )
+					else if( rEnumArray->Find( aCompleteName, SbxCLASS_OBJECT ) || ( IsVBASupportOn() && VBAConstantHelper::instance().isVBAConstantType( aCompleteName ) ) )
 					{
 						eType = SbxLONG;
 						break;
@@ -211,7 +216,7 @@
 		Next(), bConst = TRUE;
 
 	// #110004 It can also be a sub/function
-	if( !bConst && (eCurTok == SUB || eCurTok == FUNCTION || eCurTok == PROPERTY ||
+	if( !bConst && (eCurTok == DECLARE || eCurTok == SUB || eCurTok == FUNCTION || eCurTok == PROPERTY ||
 					eCurTok == STATIC || eCurTok == ENUM || eCurTok == DECLARE) )
 	{
 		// Next token is read here, because !bConst
@@ -395,7 +406,10 @@
 				aExpr.Gen();
 				SbiOpcode eOp_ = pDef->IsNew() ? _CREATE : _TCREATE;
 				aGen.Gen( eOp_, pDef->GetId(), pDef->GetTypeId() );
-				aGen.Gen( _SET );
+				if ( bVBASupportOn )
+					aGen.Gen( _VBASET );
+				else	
+					aGen.Gen( _SET );
 			}
 		}
 		else
@@ -947,6 +947,24 @@ void SbiParser::DefDeclare( BOOL bPrivate )
     }
 }
 
+void SbiParser::Attribute()
+{
+	// TODO: Need to implement the method as an attributed object.
+	while( Next() != EQ )
+	{
+		String aSym( GetSym() );
+		if( Next() != DOT) 
+			break;
+	}
+	
+	if( eCurTok != EQ )
+		Error( SbERR_SYNTAX );
+	else
+		SbiExpression aValue( this );
+
+	// Don't generate any code - just discard it.
+}
+
 // Aufruf einer SUB oder FUNCTION
 
 void SbiParser::Call()
Index: basic/source/comp/parser.cxx
===================================================================
--- basic/source/comp/parser.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/source/comp/parser.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,7 @@
 #define	N	FALSE
 
 static SbiStatement StmntTable [] = {
+{ ATTRIBUTE, &SbiParser::Attribute, Y, Y, }, // ATTRIBUTE
 { CALL,		&SbiParser::Call,   	N, Y, }, // CALL
 { CLOSE,	&SbiParser::Close,		N, Y, }, // CLOSE
 { _CONST_,	&SbiParser::Dim, 		Y, Y, }, // CONST
@@ -137,13 +138,15 @@
 	pProc    = NULL;
 	pStack   = NULL;
 	pWithVar = NULL;
+	pCurStat = NULL;
 	nBase	 = 0;
 	bText	 =
 	bGblDefs =
 	bNewGblDefs =
 	bSingleLineIf =
 	bExplicit = FALSE;
-	bClassModule = FALSE;
+	bClassModule = ( pm->GetModuleType() == com::sun::star::script::ModuleType::Class );
+	OSL_TRACE("Parser - %s, bClassModule %d", rtl::OUStringToOString( pm->GetName(), RTL_TEXTENCODING_UTF8 ).getStr(), bClassModule );
 	pPool	 = &aPublics;
 	for( short i = 0; i < 26; i++ )
 		eDefTypes[ i ] = SbxVARIANT;    // Kein expliziter Defaulttyp
@@ -156,6 +159,10 @@
 
 	rTypeArray = new SbxArray; // Array fuer Benutzerdefinierte Typen
 	rEnumArray = new SbxArray; // Array for Enum types
+	bVBASupportOn = pm->IsVBACompat();
+	if ( bVBASupportOn )
+		EnableCompatibility();
+
 }
 
 
@@ -302,6 +309,26 @@
 	}
 }
 
+// If some keywords e.g. Name have been dim as a variable, 
+// they should be treated as symbol
+BOOL SbiParser::IsSymbol( SbiToken t )
+{
+	// FIXME: if "name" is a argument in a subroutine like "Sub Test( name as String )".
+	if( IsVBASupportOn() && ( t == NAME || t == LINE || t == TEXT ))
+	{
+		if( pCurStat && ( pCurStat->eTok == DIM || pCurStat->eTok == PUBLIC ||
+		  pCurStat->eTok == PRIVATE || pCurStat->eTok == GLOBAL	))
+		{
+			return TRUE;
+		}
+    	if( pPool->Find(aSym) )
+    	{
+        	return TRUE;
+    	}
+	}	
+    return FALSE;
+}
+
 // Parsing eines Statement-Blocks
 // Das Parsing laeuft bis zum Ende-Token.
 
@@ -378,6 +405,18 @@
 		Next(); return TRUE;
 	}
 
+        // In vba it's possible to do Error.foobar ( even if it results in
+	// a runtime error
+        if ( eCurTok == _ERROR_ && IsVBASupportOn() ) // we probably need to define a subset of keywords where this madness applies e.g. if ( IsVBASupportOn() && SymbolCanBeRedined( eCurTok ) )
+        {
+            SbiTokenizer tokens( *(SbiTokenizer*)this );
+            tokens.Next();
+            if ( tokens.Peek()  == DOT )
+            {
+                eCurTok = SYMBOL;
+		ePush = eCurTok;
+            }
+	}
 	// Kommt ein Symbol, ist es entweder eine Variable( LET )
 	// oder eine SUB-Prozedur( CALL ohne Klammern )
 	// DOT fuer Zuweisungen im WITH-Block: .A=5
@@ -425,7 +464,9 @@
 				if( ( p->bSubr && (eCurTok != STATIC || Peek() == SUB || Peek() == FUNCTION ) ) ||
 						eCurTok == SUB || eCurTok == FUNCTION )
 					aGen.Statement();
+				pCurStat = p;	
 				(this->*( p->Func ) )();
+				pCurStat = NULL;
 				SbxError nSbxErr = SbxBase::GetError();
 				if( nSbxErr )
 					SbxBase::ResetError(), Error( (SbError)nSbxErr );
@@ -754,8 +795,9 @@
 
 		case CLASSMODULE:
 			bClassModule = TRUE; 
+			aGen.GetModule().SetModuleType( com::sun::star::script::ModuleType::Class );
 			break;
-		case VBASUPPORT:
+		case VBASUPPORT: // Option VBASupport used to override the module mode ( in fact this must reset the mode
 			if( Next() == NUMBER )
 			{
 				if ( nVal == 1 || nVal == 0 )
@@ -763,6 +805,10 @@
 					bVBASupportOn = ( nVal == 1 );
 					if ( bVBASupportOn )
 						EnableCompatibility();
+					// if the module setting is different
+					// reset it to what the Option tells us
+					if ( bVBASupportOn != aGen.GetModule().IsVBACompat() )
+						aGen.GetModule().SetVBACompat( bVBASupportOn );
 					break;
 				}
 			}
Index: basic/inc/basic/basmgr.hxx
===================================================================
--- basic/inc/basic/basmgr.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/basmgr.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -231,13 +231,15 @@
     ::com::sun::star::uno::Any
                     SetGlobalUNOConstant( const sal_Char* _pAsciiName, const ::com::sun::star::uno::Any& _rValue );
 
+    /** retrieves a global constant in the basic library, referring to some UNO object, returns true if a value is found ( value is in aOut ) false otherwise. */
+                    bool GetGlobalUNOConstant( const sal_Char* _pAsciiName, ::com::sun::star::uno::Any& aOut );
     /** determines whether there are password-protected modules whose size exceedes the
         legacy module size
         @param _out_rModuleNames
             takes the names of modules whose size exceeds the legacy limit
     */
     bool            LegacyPsswdBinaryLimitExceeded( ::com::sun::star::uno::Sequence< rtl::OUString >& _out_rModuleNames );
-
+    bool HasExeCode( const String& ); 
 private:
 	BOOL		    IsReference( USHORT nLib );
 
Index: basic/inc/basic/sbmeth.hxx
===================================================================
--- basic/inc/basic/sbmeth.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/sbmeth.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -49,6 +49,7 @@
 	friend class SbIfaceMapperMethod;
 
 	SbMethodImpl* mpSbMethodImpl;			// Impl data
+	SbxVariable* mCaller;                   // caller
 	SbModule* pMod;
 	USHORT    nDebugFlags;
 	USHORT	  nLine1, nLine2;
@@ -75,7 +76,7 @@
 	void 	  GetLineRange( USHORT&, USHORT& );
 
 	// Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
-	virtual ErrCode Call( SbxValue* pRet = NULL );
+	virtual ErrCode Call( SbxValue* pRet = NULL,  SbxVariable* pCaller = NULL );
 	virtual void Broadcast( ULONG nHintId );
 };
 
Index: basic/inc/basic/sbuno.hxx
===================================================================
--- basic/inc/basic/sbuno.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/sbuno.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -41,6 +41,7 @@
 
 // Force creation of all properties for debugging
 void createAllObjectProperties( SbxObject* pObj );
+void SetSbUnoObjectDfltPropName( SbxObject* pObj );
 
 ::com::sun::star::uno::Any sbxToUnoValue( SbxVariable* pVar );
 
Index: basic/inc/basic/sbstar.hxx
===================================================================
--- basic/inc/basic/sbstar.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/sbstar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,7 @@
 
 #include <basic/sbdef.hxx>
 #include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
 
 class SbModule;                     // completed module
 class SbiInstance;                  // runtime instance
@@ -72,8 +73,14 @@
 	BOOL			bNoRtl;                 // if TRUE: do not search RTL
 	BOOL			bBreak;                 // if TRUE: Break, otherwise Step
 	BOOL			bDocBasic;
+    BOOL            bVBAEnabled;
 	BasicLibInfo*	pLibInfo;			// Info block for basic manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode of the basic object
+	BOOL			bQuit;
+
+	SbxObjectRef pVBAGlobals; 
+	SbxObject* getVBAGlobals( );
+
 protected:
 	BOOL 			CError( SbError, const String&, xub_StrLen, xub_StrLen, xub_StrLen );
 private:
@@ -114,7 +121,8 @@
 
 	// Compiler-Interface
 	SbModule*   	MakeModule( const String& rName, const String& rSrc );
-    SbModule*   	MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeModule32( const com::sun::star::script::ModuleInfo& mInfo );
 	BOOL			Compile( SbModule* );
 	BOOL 			Disassemble( SbModule*, String& rText );
 	static void 	Stop();
@@ -187,6 +195,8 @@
 					( const String& rName, USHORT& rStatus );
 	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
 	static SbModule* GetActiveModule();
+    void SetVBAEnabled( BOOL bEnabled );
+    BOOL isVBAEnabled();
 
 	// #60175 TRUE: SFX-Resource is not displayed on basic errors
 	static void StaticSuppressSfxResource( BOOL bSuppress );
@@ -196,6 +206,10 @@
 
 	SbxObjectRef getRTL( void ) { return pRtl; }
 	BOOL IsDocBasic() { return bDocBasic; }
+	SbxVariable* VBAFind( const String& rName, SbxClassType t );
+	bool GetUNOConstant( const sal_Char* _pAsciiName, ::com::sun::star::uno::Any& aOut );
+	void QuitAndExitApplication();
+	BOOL IsQuitApplication() { return bQuit; };
 };
 
 #ifndef __SB_SBSTARBASICREF_HXX
Index: basic/inc/basic/sbobjmod.hxx
===================================================================
--- basic/inc/basic/sbobjmod.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ basic/inc/basic/sbobjmod.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,96 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+
+namespace css = ::com::sun::star;
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+    SbObjModule( const SbObjModule& );
+    SbObjModule();
+public:
+    TYPEINFO();
+    SbObjModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVbaCompatible );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    SbxVariable* GetObject();
+    void SetUnoObject( const com::sun::star::uno::Any& aObj )throw ( com::sun::star::uno::RuntimeException ) ;
+};
+
+class SbUserFormModule : public SbObjModule
+{
+    css::uno::Reference<css::lang::XEventListener> m_DialogListener;
+    css::uno::Reference<css::awt::XDialog> m_xDialog;
+    css::uno::Reference<css::frame::XModel> m_xModel;
+    String sFormName;
+    bool mbInit;
+    SbUserFormModule( const SbUserFormModule& );
+    SbUserFormModule();
+
+protected:
+    virtual void InitObject();
+public:
+    TYPEINFO();
+    SbUserFormModule( const com::sun::star::script::ModuleInfo& mInfo, bool bIsVBACompat );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    void ResetApiObj();
+    void Unload();
+    void load();
+    void triggerMethod( const String& );
+    void triggerMethod( const String&, css::uno::Sequence< css::uno::Any >&  );
+    void triggerActivateEvent();
+    void triggerDeActivateEvent();
+    void triggerInitializeEvent();
+    void triggerTerminateEvent();
+};
+
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
Index: basic/inc/basic/sberrors.hxx
===================================================================
--- basic/inc/basic/sberrors.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/sberrors.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -290,6 +290,8 @@
 #define	ERRCODE_BASIC_LOOP_NOT_INIT			((LAST_SBX_ERROR_ID+109UL) | ERRCODE_AREA_SBX | \
 											ERRCODE_CLASS_COMPILER)				// For loop not initialized
 
+#define	ERRCODE_BASIC_COMPAT				((LAST_SBX_ERROR_ID+103UL)| ERRCODE_AREA_SBX | ERRCODE_CLASS_RUNTIME)
+
 // Map old codes to new codes
 #define	SbERR_SYNTAX						ERRCODE_BASIC_SYNTAX
 #define	SbERR_NO_GOSUB						ERRCODE_BASIC_NO_GOSUB
@@ -413,6 +415,7 @@
 #define	SbERR_PROG_TOO_LARGE                ERRCODE_BASIC_PROG_TOO_LARGE
 #define	SbERR_NO_STRINGS_ARRAYS             ERRCODE_BASIC_NO_STRINGS_ARRAYS
 #define	SbERR_BASIC_EXCEPTION               ERRCODE_BASIC_EXCEPTION
+#define	SbERR_BASIC_COMPAT                  ERRCODE_BASIC_COMPAT
 #define	SbERR_BASIC_ARRAY_FIX				ERRCODE_BASIC_ARRAY_FIX
 #define	SbERR_BASIC_STRING_OVERFLOW			ERRCODE_BASIC_STRING_OVERFLOW
 #define	SbERR_BASIC_EXPR_TOO_COMPLEX		ERRCODE_BASIC_EXPR_TOO_COMPLEX
Index: basic/inc/basic/sbmod.hxx
===================================================================
--- basic/inc/basic/sbmod.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/inc/basic/sbmod.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -37,7 +37,8 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
-
+#include <com/sun/star/script/ModuleType.hpp>
+#include <vector>
 class SbMethod;
 class SbProperty;
 class SbiRuntime;
@@ -59,6 +60,9 @@
 	friend class	SbClassModuleObject;
 
 	SbModuleImpl*	mpSbModuleImpl;		// Impl data
+	std::vector< String > mModuleVariableNames;
+	SbModule();
+	SbModule(const SbModule&);
 
 protected:
     ::rtl::OUString     aOUSource;
@@ -66,6 +70,10 @@
     SbiImage*           pImage;        // the Image
     SbiBreakpoints*     pBreaks;       // Breakpoints
     SbClassData*        pClassData;
+	bool mbVBACompat;
+	INT32 mnType; 
+	SbxObjectRef pDocObject; // an impl object ( used by Document Modules )
+	bool 	bIsProxyModule;
 
 	void			StartDefinitions();
 	SbMethod*		GetMethod( const String&, SbxDataType );
@@ -90,7 +98,7 @@
 public:
 	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASICMOD,2);
 	TYPEINFO();
-					SbModule( const String& );
+					SbModule( const String&, bool bCompat = false );
 	virtual void	SetParent( SbxObject* );
 	virtual void 	Clear();
 
@@ -126,6 +134,14 @@
 	BOOL LoadBinaryData( SvStream& );
 	BOOL ExceedsLegacyModuleSize();
 	void fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg = NULL ) const;
+        bool HasExeCode();
+        bool IsVBACompat();
+        void SetVBACompat( bool bCompat );
+        INT32 GetModuleType() { return mnType; }
+        void SetModuleType( INT32 nType ) { mnType = nType; }
+	bool GetIsProxyModule() { return bIsProxyModule; }
+        void AddVarName( const String& aName );
+        void RemoveVars();
 };
 
 #ifndef __SB_SBMODULEREF_HXX
Index: basic/prj/build.lst
===================================================================
--- basic/prj/build.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,4 +1,4 @@
-sb	basic	:    l10n offuh svtools xmlscript framework NULL
+sb	basic	:    l10n offuh svtools xmlscript framework oovbaapi NULL
 sb	basic									usr1	-	all	sb_mkout NULL
 sb	basic\inc								nmake	-	all	sb_inc NULL
 sb	basic\source\app						nmake	-	all	sb_app sb_class sb_inc NULL
Index: basic/prj/d.lst
===================================================================
--- basic/prj/d.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ basic/prj/d.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -7,6 +7,8 @@
 ..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
 ..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
 ..\%__SRC%\slb\sb.lib %_DEST%\lib%_EXT%\xsb.lib
+..\%__SRC%\lib\vbahelp*.* %_DEST%\lib%_EXT%\vba*.*
+
 ..\%__SRC%\srs\classes.srs %_DEST%\res%_EXT%\basic.srs
 ..\%COMMON_OUTDIR%\srs\classes_srs.hid %COMMON_DEST%\res%_EXT%\basic_srs.hid
 ..\%__SRC%\bin\sb?????.dll %_DEST%\bin%_EXT%\sb?????.dll
@@ -56,4 +58,8 @@
 ..\inc\basic\sbxmstrm.hxx %_DEST%\inc%_EXT%\basic\sbxmstrm.hxx
 
 ..\inc\basic\basicmanagerrepository.hxx %_DEST%\inc%_EXT%\basic\basicmanagerrepository.hxx
+..\inc\basic\vbacollectionimpl.hxx %_DEST%\inc%_EXT%\basic\vbacollectionimpl.hxx
+..\inc\basic\vbahelper.hxx %_DEST%\inc%_EXT%\basic\vbahelper.hxx
+..\inc\basic\helperdecl.hxx %_DEST%\inc%_EXT%\basic\helperdecl.hxx
+..\inc\basic\vbahelperinterface.hxx %_DEST%\inc%_EXT%\basic\vbahelperinterface.hxx
 ..\inc\modsizeexceeded.hxx %_DEST%\inc%_EXT%\basic\modsizeexceeded.hxx
Index: toolkit/source/helper/property.cxx
===================================================================
--- toolkit/source/helper/property.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/helper/property.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -183,6 +183,7 @@
             DECL_PROP_3     ( "FormatsSupplier",        FORMATSSUPPLIER,    Reference< ::com::sun::star::util::XNumberFormatsSupplier >, BOUND, MAYBEVOID, TRANSIENT ),
 
             DECL_PROP_2     ( "Graphic",                GRAPHIC,            Reference< ::com::sun::star::graphic::XGraphic >, BOUND, TRANSIENT ),
+            DECL_PROP_2     ( "GroupName",              GROUPNAME,          ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpText",               HELPTEXT,           ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HelpURL",                HELPURL,            ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "HideInactiveSelection",  HIDEINACTIVESELECTION, bool,            BOUND, MAYBEDEFAULT ),
@@ -280,7 +281,8 @@
             DECL_PROP_3     ( "GridDataModel",		GRID_DATAMODEL,   Reference< ::com::sun::star::awt::grid::XGridDataModel >,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "ColumnModel",		GRID_COLUMNMODEL,   Reference< ::com::sun::star::awt::grid::XGridColumnModel >,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
             DECL_PROP_3     ( "SelectionModel",		GRID_SELECTIONMODE,   ::com::sun::star::view::SelectionType,          BOUND, MAYBEDEFAULT, MAYBEVOID ),
-            DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,           BOUND, MAYBEDEFAULT )
+            DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,           BOUND, MAYBEDEFAULT ),
+            DECL_PROP_2     ( "VBAForm",                VBAFORM,                sal_Bool,           BOUND, MAYBEDEFAULT )
             };
 			pPropertyInfos = aImplPropertyInfos;
 			nElements = sizeof( aImplPropertyInfos ) / sizeof( ImplPropertyInfo );
Index: toolkit/source/helper/servicenames.cxx
===================================================================
--- toolkit/source/helper/servicenames.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/helper/servicenames.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,8 @@
 const sal_Char __FAR_DATA szServiceName_MenuBar[] = "stardiv.vcl.MenuBar", szServiceName2_MenuBar[] = "com.sun.star.awt.MenuBar";
 const sal_Char __FAR_DATA szServiceName_Pointer[] = "stardiv.vcl.Pointer", szServiceName2_Pointer[] = "com.sun.star.awt.Pointer";
 const sal_Char __FAR_DATA szServiceName_UnoControlContainer[] = "stardiv.vcl.control.ControlContainer", szServiceName2_UnoControlContainer[] = "com.sun.star.awt.UnoControlContainer";
+
+
 const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[] = "stardiv.vcl.controlmodel.ControlContainer", szServiceName2_UnoControlContainerModel[] = "com.sun.star.awt.UnoControlContainerModel";
 const sal_Char __FAR_DATA szServiceName_TabController[] = "stardiv.vcl.control.TabController", szServiceName2_TabController[] = "com.sun.star.awt.TabController";
 const sal_Char __FAR_DATA szServiceName_TabControllerModel[] = "stardiv.vcl.controlmodel.TabController", szServiceName2_TabControllerModel[] = "com.sun.star.awt.TabControllerModel";
@@ -92,6 +94,8 @@
 const sal_Char __FAR_DATA szServiceName_UnoControlRoadmapModel[] = "stardiv.vcl.controlmodel.Roadmap", szServiceName2_UnoControlRoadmapModel[] = "com.sun.star.awt.UnoControlRoadmapModel";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonControl[] = "com.sun.star.awt.UnoControlSpinButton";
 const sal_Char __FAR_DATA szServiceName_UnoSpinButtonModel[] = "com.sun.star.awt.UnoControlSpinButtonModel";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[] = "com.sun.star.awt.UnoControlMultiPage";
+const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[] = "com.sun.star.awt.UnoMultiPageModel";
 const sal_Char __FAR_DATA szServiceName_TreeControl[] = "com.sun.star.awt.tree.TreeControl";
 const sal_Char __FAR_DATA szServiceName_TreeControlModel[] = "com.sun.star.awt.tree.TreeControlModel";
 const sal_Char __FAR_DATA szServiceName_MutableTreeDataModel[] = "com.sun.star.awt.tree.MutableTreeDataModel";
Index: toolkit/source/helper/registerservices.cxx
===================================================================
--- toolkit/source/helper/registerservices.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/helper/registerservices.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -168,6 +168,7 @@
 IMPL_CREATEINSTANCE( UnoControlProgressBarModel )
 IMPL_CREATEINSTANCE( UnoControlScrollBarModel )
 IMPL_CREATEINSTANCE( UnoSpinButtonModel )
+IMPL_CREATEINSTANCE( UnoMultiPageModel )
 IMPL_CREATEINSTANCE( UnoControlFixedLineModel )
 IMPL_CREATEINSTANCE( UnoCurrencyFieldControl )
 IMPL_CREATEINSTANCE( UnoDateFieldControl )
@@ -187,6 +188,7 @@
 IMPL_CREATEINSTANCE( UnoProgressBarControl )
 IMPL_CREATEINSTANCE( UnoScrollBarControl )
 IMPL_CREATEINSTANCE( UnoSpinButtonControl )
+IMPL_CREATEINSTANCE( UnoMultiPageControl )
 IMPL_CREATEINSTANCE( UnoFixedLineControl )
 IMPL_CREATEINSTANCE( VCLXMenuBar )
 IMPL_CREATEINSTANCE( VCLXPointer )
@@ -279,6 +281,8 @@
 		registerServices( xRegistryKey, "UnoControlScrollBarModel", szServiceName_UnoControlScrollBarModel, szServiceName2_UnoControlScrollBarModel );
         registerServices( xRegistryKey, "UnoSpinButtonModel", szServiceName_UnoSpinButtonModel );
         registerServices( xRegistryKey, "UnoSpinButtonControl", szServiceName_UnoSpinButtonControl );
+        registerServices( xRegistryKey, "UnoMultiPageModel", szServiceName_UnoMultiPageModel );
+        registerServices( xRegistryKey, "UnoMultiPageControl", szServiceName_UnoMultiPageControl );
         registerServices( xRegistryKey, "UnoFixedLineControl", szServiceName_UnoControlFixedLine, szServiceName2_UnoControlFixedLine );
 		registerServices( xRegistryKey, "UnoControlFixedLineModel", szServiceName_UnoControlFixedLineModel, szServiceName2_UnoControlFixedLineModel );
 		registerServices( xRegistryKey, "VCLXPrinterServer", szServiceName_PrinterServer, szServiceName2_PrinterServer );
@@ -369,6 +373,8 @@
 		CHECKANDCREATEFACTORY( VCLXPrinterServer, szServiceName_PrinterServer, szServiceName2_PrinterServer )
 		CHECKANDCREATEFACTORY( UnoRoadmapControl, szServiceName_UnoControlRoadmap, szServiceName2_UnoControlRoadmap )
 		CHECKANDCREATEFACTORY( UnoControlRoadmapModel, szServiceName_UnoControlRoadmapModel, szServiceName2_UnoControlRoadmapModel )
+        CHECKANDCREATEFACTORY( UnoMultiPageModel, szServiceName_UnoMultiPageModel, NULL )
+        CHECKANDCREATEFACTORY( UnoMultiPageControl, szServiceName_UnoMultiPageControl, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonModel, szServiceName_UnoSpinButtonModel, NULL )
         CHECKANDCREATEFACTORY( UnoSpinButtonControl, szServiceName_UnoSpinButtonControl, NULL )
 		CHECKANDCREATEFACTORY( TreeControl, szServiceName_TreeControl, NULL )
Index: toolkit/source/controls/unocontrolmodel.cxx
===================================================================
--- toolkit/source/controls/unocontrolmodel.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/controls/unocontrolmodel.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -349,6 +349,7 @@
             case BASEPROPERTY_ENABLEVISIBLE:
             case BASEPROPERTY_DECORATION:           aDefault <<= (sal_Bool) sal_True; break;
 
+            case BASEPROPERTY_GROUPNAME:
             case BASEPROPERTY_HELPTEXT:
             case BASEPROPERTY_HELPURL:
 	        case BASEPROPERTY_IMAGEURL:
Index: toolkit/source/controls/unocontrols.cxx
===================================================================
--- toolkit/source/controls/unocontrols.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/controls/unocontrols.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -571,7 +571,7 @@
 
     return UnoControlModel::ImplGetDefaultValue( nPropId );
 }
-    uno::Reference< graphic::XGraphic > ImageProducerControlModel::getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
+    uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
 
@@ -581,10 +581,10 @@
             rtl::OUString sID = _rURL.copy( sizeof( UNO_NAME_GRAPHOBJ_URLPREFIX ) - 1 );
             // get the DefaultContext
             ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
-            mxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
+            rxGrfObj = graphic::GraphicObject::createWithId( aContext.getUNOContext(), sID );
         }
         else // linked
-            mxGrfObj = NULL; // release the GraphicObject
+            rxGrfObj = NULL; // release the GraphicObject
 
         if ( !_rURL.getLength() )
             return xGraphic;
@@ -625,7 +625,7 @@
                 mbAdjustingGraphic = true;
                 ::rtl::OUString sImageURL;
                 OSL_VERIFY( rValue >>= sImageURL );
-                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( sImageURL ) ) );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
                 mbAdjustingGraphic = false;
             }
             break;
@@ -1842,7 +1842,78 @@
 	return sal_True;
 }
 
+// MultiPage
+
+UnoMultiPageModel::UnoMultiPageModel()
+{
+	ImplRegisterProperty( BASEPROPERTY_DEFAULTCONTROL );
+	ImplRegisterProperty( BASEPROPERTY_ENABLED );
+	ImplRegisterProperty( BASEPROPERTY_FONTDESCRIPTOR );
+	ImplRegisterProperty( BASEPROPERTY_HELPTEXT );
+	ImplRegisterProperty( BASEPROPERTY_HELPURL );
+	ImplRegisterProperty( BASEPROPERTY_LABEL );
+	ImplRegisterProperty( BASEPROPERTY_PRINTABLE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE );
+	ImplRegisterProperty( BASEPROPERTY_PROGRESSVALUE_MAX );
+}
+
+::rtl::OUString UnoMultiPageModel::getServiceName() throw(::com::sun::star::uno::RuntimeException)
+{
+	return ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageModel );
+}
+
+uno::Any UnoMultiPageModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
+{
+	if ( nPropId == BASEPROPERTY_DEFAULTCONTROL )
+	{
+		uno::Any aAny;
+		aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoControlGroupBox );
+		//aAny <<= ::rtl::OUString::createFromAscii( szServiceName_UnoMultiPageControl );
+		return aAny;
+	}
+	return UnoControlModel::ImplGetDefaultValue( nPropId );
+}
+
+::cppu::IPropertyArrayHelper& UnoMultiPageModel::getInfoHelper()
+{
+	static UnoPropertyArrayHelper* pHelper = NULL;
+	if ( !pHelper )
+	{
+		uno::Sequence<sal_Int32>	aIDs = ImplGetPropertyIds();
+		pHelper = new UnoPropertyArrayHelper( aIDs );
+	}
+	return *pHelper;
+}
+
+// beans::XMultiPropertySet
+uno::Reference< beans::XPropertySetInfo > UnoMultiPageModel::getPropertySetInfo(  ) throw(uno::RuntimeException)
+{
+	static uno::Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+	return xInfo;
+}
+
 //	----------------------------------------------------
+//	class MultiPageControl
+//	----------------------------------------------------
+UnoMultiPageControl::UnoMultiPageControl()
+{
+	maComponentInfos.nWidth = 100;
+	maComponentInfos.nHeight = 100;
+}
+
+::rtl::OUString UnoMultiPageControl::GetComponentServiceName()
+{
+	return ::rtl::OUString::createFromAscii( "multipage" );
+}
+
+sal_Bool UnoMultiPageControl::isTransparent() throw(uno::RuntimeException)
+{
+	return sal_True;
+}
+
+
+
+//	----------------------------------------------------
 //	class UnoControlListBoxModel
 //	----------------------------------------------------
 UnoControlListBoxModel::UnoControlListBoxModel()
Index: toolkit/source/controls/dialogcontrol.cxx
===================================================================
--- toolkit/source/controls/dialogcontrol.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/controls/dialogcontrol.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -81,6 +81,7 @@
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::script;
 using namespace toolkit;
 
 #define PROPERTY_RESOURCERESOLVER ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ResourceResolver" ))
@@ -91,6 +92,8 @@
 //HELPER
 ::rtl::OUString getPhysicalLocation( const ::com::sun::star::uno::Any& rbase, const ::com::sun::star::uno::Any& rUrl );
 
+uno::Reference< graphic::XGraphic > getGraphicFromURL_nothrow( uno::Reference< graphic::XGraphicObject >& rxGrfObj, const ::rtl::OUString& _rURL );
+
 struct LanguageDependentProp
 {
     const char* pPropName;
@@ -116,7 +119,7 @@
         }
         return s_aLanguageDependentProperties;
     }
-
+ 
     static uno::Reference< graphic::XGraphic > lcl_getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL )
     {
         uno::Reference< graphic::XGraphic > xGraphic;
@@ -143,6 +146,18 @@
         return xGraphic;
     }
 
+    static ::rtl::OUString lcl_GetStringProperty( const ::rtl::OUString& sProperty, const Reference< XPropertySet >& xSet )
+    {
+        ::rtl::OUString sValue;
+        Reference< XPropertySetInfo > xPSI;
+        if (xSet.is() && (xPSI = xSet->getPropertySetInfo()).is() && 
+                xPSI->hasPropertyByName( sProperty ) )
+        {
+            xSet->getPropertyValue( sProperty ) >>= sValue;
+        }
+        return sValue;
+    }
+
 }
 
 // ----------------------------------------------------------------------------
@@ -254,7 +269,7 @@
 UnoControlDialogModel::UnoControlDialogModel()
 	:maContainerListeners( *this )
 	,maChangeListeners ( GetMutex() )
-	,mbGroupsUpToDate( sal_False )
+	,mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
 	ImplRegisterProperty( BASEPROPERTY_BACKGROUNDCOLOR );
 //	ImplRegisterProperty( BASEPROPERTY_BORDER );
@@ -276,6 +291,8 @@
 	aBool <<= (sal_Bool) sal_True;
 	ImplRegisterProperty( BASEPROPERTY_MOVEABLE, aBool );
 	ImplRegisterProperty( BASEPROPERTY_CLOSEABLE, aBool );
+	aBool <<= (sal_Bool) sal_False;
+	ImplRegisterProperty( BASEPROPERTY_VBAFORM, aBool );
 }
 
 UnoControlDialogModel::UnoControlDialogModel( const UnoControlDialogModel& rModel )
@@ -283,7 +300,7 @@
     , UnoControlDialogModel_Base( rModel )
 	, maContainerListeners( *this )
 	, maChangeListeners ( GetMutex() )
-	, mbGroupsUpToDate( sal_False )
+	, mbGroupsUpToDate( sal_False ), mbAdjustingGraphic( false )
 {
 }
 
@@ -314,6 +331,40 @@
 	return ::rtl::OUString::createFromAscii( szServiceName_UnoControlDialogModel );
 }
 
+void SAL_CALL UnoControlDialogModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception)
+{
+    UnoControlModel::setFastPropertyValue_NoBroadcast( nHandle, rValue );
+    try
+    {
+        switch ( nHandle )
+        {
+        case BASEPROPERTY_IMAGEURL:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_GRAPHIC ) )
+            {
+                mbAdjustingGraphic = true;
+                ::rtl::OUString sImageURL;
+                OSL_VERIFY( rValue >>= sImageURL );
+                setPropertyValue( GetPropertyName( BASEPROPERTY_GRAPHIC ), uno::makeAny( getGraphicFromURL_nothrow( mxGrfObj, sImageURL ) ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+
+        case BASEPROPERTY_GRAPHIC:
+            if ( !mbAdjustingGraphic && ImplHasProperty( BASEPROPERTY_IMAGEURL ) )
+            {
+                mbAdjustingGraphic = true;
+                setPropertyValue( GetPropertyName( BASEPROPERTY_IMAGEURL ), uno::makeAny( ::rtl::OUString() ) );
+                mbAdjustingGraphic = false;
+            }
+            break;
+	}
+    }
+    catch( const ::com::sun::star::uno::Exception& )
+    {
+        OSL_ENSURE( sal_False, "UnoControlDialogModel::setFastPropertyValue_NoBroadcast: caught an exception while setting Graphic/ImageURL properties!" );
+    }
+}
+
 Any UnoControlDialogModel::ImplGetDefaultValue( sal_uInt16 nPropId ) const
 {
     Any aAny;
@@ -901,7 +952,64 @@
 	}
 }
 
+// ----------------------------------------------------------------------------
+void UnoControlDialogModel::AddRadioButtonGroup ( 
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups )
+{
+    if ( rNamedGroups.size() == 0 )
+        return;
 
+    size_t nGroups = maGroups.size();
+    maGroups.reserve( nGroups + rNamedGroups.size() );
+    ::std::map< ::rtl::OUString, ModelGroup >::const_iterator i = rNamedGroups.begin(), e = rNamedGroups.end();
+    for( ; i != e; ++i)
+    {
+            maGroups.push_back( i->second );
+    }
+
+    rNamedGroups.clear();
+}
+
+void UnoControlDialogModel::AddRadioButtonToGroup ( 
+        const Reference< XControlModel >& rControlModel,
+        const ::rtl::OUString& rPropertyName,
+        ::std::map< ::rtl::OUString, ModelGroup >& rNamedGroups,
+        ModelGroup*& rpCurrentGroup )
+{
+    Reference< XPropertySet > xCurProps( rControlModel, UNO_QUERY );
+    ::rtl::OUString sGroup = lcl_GetStringProperty( rPropertyName, xCurProps );
+    const sal_Int32 nControlModelStep = lcl_getDialogStep( rControlModel );
+
+    if ( sGroup.getLength() == 0 )
+    {
+        // Create a new group if:
+        if ( maGroups.size() == 0 ||                // no groups
+                rpCurrentGroup == NULL ||           // previous group was closed
+                (nControlModelStep != 0 &&          // control step matches current group
+                 maGroups.back().size() > 0 &&      //  (group 0 == display everywhere)
+                 nControlModelStep != lcl_getDialogStep( maGroups.back().back() ) ) )
+        {
+            size_t nGroups = maGroups.size();
+            maGroups.resize( nGroups + 1 );
+        }
+        rpCurrentGroup = &maGroups.back();
+    }
+    else
+    {
+        // Different steps get different sets of named groups
+        if ( rNamedGroups.size() > 0 &&
+                rNamedGroups.begin()->second.size() > 0 )
+        {
+            const sal_Int32 nPrevStep = lcl_getDialogStep( rNamedGroups.begin()->second.front() );
+            if ( nControlModelStep != nPrevStep )
+                AddRadioButtonGroup( rNamedGroups );
+        }
+
+        rpCurrentGroup = &rNamedGroups[ sGroup ];
+    }
+    rpCurrentGroup->push_back( rControlModel );
+}
+
 // ----------------------------------------------------------------------------
 void UnoControlDialogModel::implUpdateGroupStructure()
 {
@@ -925,10 +1033,13 @@
 
 	GroupingMachineState eState = eLookingForGroup;		// the current state of our machine
 	Reference< XServiceInfo > xModelSI;					// for checking for a radion button
-	AllGroups::iterator aCurrentGroup = maGroups.end();	// the group which we're currently building
-	sal_Int32	nCurrentGroupStep = -1;					// the step which all controls of the current group belong to
+	ModelGroup* aCurrentGroup = NULL;                   // the group which we're currently building
 	sal_Bool	bIsRadioButton;							// is it a radio button?
 
+    const ::rtl::OUString GROUP_NAME( RTL_CONSTASCII_USTRINGPARAM( "GroupName" ) );
+
+    ::std::map< ::rtl::OUString, ModelGroup > aNamedGroups;
+
 #if OSL_DEBUG_LEVEL > 1
 	::std::vector< ::rtl::OUString > aCurrentGroupLabels;
 #endif
@@ -949,14 +1060,8 @@
 				// the current model is a radio button
 				// -> we found the beginning of a new group
 				// create the place for this group
-				size_t nGroups = maGroups.size();
-				maGroups.resize( nGroups + 1 );
-				aCurrentGroup = maGroups.begin() + nGroups;
-				// and add the (only, til now) member
-				aCurrentGroup->push_back( *pControlModels );
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
 
-				// get the step which all controls of this group now have to belong to
-				nCurrentGroupStep = lcl_getDialogStep( *pControlModels );
 				// new state: looking for further members
 				eState = eExpandingGroup;
 
@@ -974,7 +1079,7 @@
 			{
 				if ( !bIsRadioButton )
 				{	// no radio button -> the group is done
-					aCurrentGroup = maGroups.end();
+					aCurrentGroup = NULL;
 					eState = eLookingForGroup;
 #if OSL_DEBUG_LEVEL > 1
 					aCurrentGroupLabels.clear();
@@ -982,48 +1087,9 @@
 					continue;
 				}
 
-				// it is a radio button - is it on the proper page?
-				const sal_Int32 nThisModelStep = lcl_getDialogStep( *pControlModels );
-				if	(	( nThisModelStep == nCurrentGroupStep )	// the current button is on the same dialog page
-					||	( 0 == nThisModelStep )					// the current button appears on all pages
-					)
-				{
-					// -> it belongs to the same group
-					aCurrentGroup->push_back( *pControlModels );
-					// state still is eExpandingGroup - we're looking for further elements
-					eState = eExpandingGroup;
+                AddRadioButtonToGroup( *pControlModels, GROUP_NAME, aNamedGroups, aCurrentGroup );
 
 #if OSL_DEBUG_LEVEL > 1
-					Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
-					::rtl::OUString sLabel;
-					if ( xModelProps.is() && xModelProps->getPropertySetInfo().is() && xModelProps->getPropertySetInfo()->hasPropertyByName( ::rtl::OUString::createFromAscii( "Label" ) ) )
-						xModelProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Label" ) ) >>= sLabel;
-					aCurrentGroupLabels.push_back( sLabel );
-#endif
-					continue;
-				}
-
-				// it's a radio button, but on a different page
-				// -> we open a new group for it
-
-				// close the old group
-				aCurrentGroup = maGroups.end();
-#if OSL_DEBUG_LEVEL > 1
-				aCurrentGroupLabels.clear();
-#endif
-
-				// open a new group
-				size_t nGroups = maGroups.size();
-				maGroups.resize( nGroups + 1 );
-				aCurrentGroup = maGroups.begin() + nGroups;
-				// and add the (only, til now) member
-				aCurrentGroup->push_back( *pControlModels );
-
-				nCurrentGroupStep = nThisModelStep;
-
-				// state is the same: we still are looking for further elements of the current group
-				eState = eExpandingGroup;
-#if OSL_DEBUG_LEVEL > 1
 				Reference< XPropertySet > xModelProps( *pControlModels, UNO_QUERY );
 				::rtl::OUString sLabel;
 				if ( xModelProps.is() && xModelProps->getPropertySetInfo().is() && xModelProps->getPropertySetInfo()->hasPropertyByName( ::rtl::OUString::createFromAscii( "Label" ) ) )
@@ -1035,6 +1101,7 @@
 		}
 	}
 
+    AddRadioButtonGroup( aNamedGroups );
 	mbGroupsUpToDate = sal_True;
 }
 
@@ -1415,17 +1482,32 @@
 	xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Width" ) ) ) >>= nWidth;
 	xP->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) >>= nHeight;
 
-	// Currentley we are simply using MAP_APPFONT
+	// Currentley we are simply using MAP_APPFONT ( for normal Dialogs )
+	// and MAP_100TH_MM for imported Userforms
+	MapMode aMode( MAP_APPFONT );
+	sal_Bool bVBAForm = sal_False;
+	Reference< XPropertySet > xDlgModelProps( getModel(), UNO_QUERY );
+	if ( xDlgModelProps.is() )
+	{
+		try
+		{
+			xDlgModelProps->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAForm" ) ) ) >>= bVBAForm;
+		}
+		catch( Exception& )
+		{
+		}
+	} 
+	if ( bVBAForm )
+		aMode = MapMode( MAP_100TH_MM );
 	OutputDevice*pOutDev = Application::GetDefaultDevice();
-	DBG_ASSERT( pOutDev, "Missing Default Device!" );
 	if ( pOutDev )
 	{
 		::Size aTmp( nX, nY );
-		aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
 		nX = aTmp.Width();
 		nY = aTmp.Height();
 		aTmp = ::Size( nWidth, nHeight );
-		aTmp = pOutDev->LogicToPixel( aTmp, MAP_APPFONT );
+		aTmp = pOutDev->LogicToPixel( aTmp, aMode );
 		nWidth = aTmp.Width();
 		nHeight = aTmp.Height();
 	}
@@ -1644,17 +1726,16 @@
     // can lead to overwrites we have to set the graphic property
     // before the propertiesChangeEvents are sent!
     ::rtl::OUString aImageURL;
-    Reference< graphic::XGraphic > xGraphic;
     if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
         ( aImageURL.getLength() > 0 ))
     {
-        ::rtl::OUString absoluteUrl =
+        aImageURL = 
             getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                  ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-        xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
-        ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
     }
+    if ( aImageURL.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+        ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
 }
 
 void UnoDialogControl::elementInserted( const ContainerEvent& Event ) throw(RuntimeException)
@@ -1886,18 +1967,16 @@
         if ( bOwnModel && rEvt.PropertyName.equalsAsciiL( "ImageURL", 8 ))
         {
             ::rtl::OUString aImageURL;
-            Reference< graphic::XGraphic > xGraphic;
             if (( ImplGetPropertyValue( PROPERTY_IMAGEURL ) >>= aImageURL ) &&
                 ( aImageURL.getLength() > 0 ))
             {
-                ::rtl::OUString absoluteUrl =
+                aImageURL =
                     getPhysicalLocation( ImplGetPropertyValue( PROPERTY_DIALOGSOURCEURL ),
                                          ImplGetPropertyValue( PROPERTY_IMAGEURL ));
 
-                xGraphic = lcl_getGraphicFromURL_nothrow( absoluteUrl );
             }
 
-            ImplSetPropertyValue( PROPERTY_GRAPHIC, uno::makeAny( xGraphic ), sal_True );
+            ImplSetPropertyValue( PROPERTY_IMAGEURL, uno::makeAny( aImageURL ), sal_True );
             break;
         }
     }
@@ -2096,10 +2175,17 @@
 
 	if ( url.getLength() > 0 )
 	{
-		INetURLObject urlObj(baseLocation);
-		urlObj.removeSegment();
-		baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
-		::osl::FileBase::getAbsoluteFileURL( baseLocation, url, ret );
+		// Don't adjust GraphicObject url(s)
+		if ( url.compareToAscii( UNO_NAME_GRAPHOBJ_URLPREFIX, RTL_CONSTASCII_LENGTH( UNO_NAME_GRAPHOBJ_URLPREFIX ) ) != 0 )
+		{
+			INetURLObject urlObj(baseLocation);
+			urlObj.removeSegment();
+			baseLocation = urlObj.GetMainURL( INetURLObject::NO_DECODE );
+			::osl::FileBase::getAbsoluteFileURL( baseLocation, url, ret );
+		}
+		else
+			ret = url;
+
 	}
 
 	return ret;
Index: toolkit/source/awt/vclxmenu.cxx
===================================================================
--- toolkit/source/awt/vclxmenu.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/awt/vclxmenu.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -529,6 +529,14 @@
 				break;
 			}
 		}
+        // it seems the popup menu is not insert into maPopupMenueRefs
+        // if the popup men is not created by stardiv.Toolkit.VCLXPopupMenu
+        if( !aRef.is() )
+        {
+		    ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > * pNewRef = new ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu > ;
+            *pNewRef = new VCLXPopupMenu( (PopupMenu*)pMenu );
+            aRef = *pNewRef;
+        }
 	}
 	return aRef;
 }
@@ -1060,3 +1068,8 @@
     DBG_CTOR( VCLXPopupMenu, 0 );
     ImplCreateMenu( TRUE );
 }
+
+VCLXPopupMenu::VCLXPopupMenu( PopupMenu* pPopMenu ) : VCLXMenu( (Menu *)pPopMenu )
+{
+    DBG_CTOR( VCLXPopupMenu, 0 );
+}
Index: toolkit/source/awt/vclxwindows.cxx
===================================================================
--- toolkit/source/awt/vclxwindows.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/source/awt/vclxwindows.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1116,6 +1116,7 @@
                      BASEPROPERTY_VERTICALALIGN,
                      BASEPROPERTY_WRITING_MODE,
                      BASEPROPERTY_CONTEXT_WRITING_MODE,
+                     BASEPROPERTY_GROUPNAME,
                      0);
     VCLXImageConsumer::ImplGetPropertyIds( rIds );
 }
@@ -1180,6 +1181,16 @@
 						pButton->Check( b );
 					else
 						pButton->SetState( b );
+					// If VBA - need to be able to test
+					// simulate click event
+					if ( maActionListeners.getLength() )
+					{
+						::com::sun::star::awt::ActionEvent aEvent;
+						aEvent.Source = (::cppu::OWeakObject*)this;
+						aEvent.ActionCommand = maActionCommand;
+						maActionListeners.actionPerformed( aEvent );
+					}
+					
 				}
 			}
 			break;
@@ -1942,8 +1953,11 @@
 				::com::sun::star::uno::Sequence< ::rtl::OUString> aItems;
 				if ( Value >>= aItems )
 				{
+					sal_Int16 nElem  = pListBox->GetEntryCount();
 					pListBox->Clear();
 					addItems( aItems, 0 );
+					if ( aItems.getLength() == 0 && nElem && maItemListeners.getLength() )
+						ImplCallItemListeners();
 				}
 			}
 			break;
@@ -1956,7 +1970,11 @@
 						pListBox->SelectEntryPos( --n, sal_False );
 
                     if ( aItems.getLength() )
+                    {			
 					    selectItemsPos( aItems, sal_True );
+                       if ( maItemListeners.getLength() )
+                           ImplCallItemListeners();
+                    }
                     else
                         pListBox->SetNoSelection();
 
@@ -2207,12 +2225,14 @@
 ::com::sun::star::uno::Any VCLXDialog::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
 {
 	::com::sun::star::uno::Any aRet = ::cppu::queryInterface( rType,
+										SAL_STATIC_CAST( ::com::sun::star::document::XVbaMethodParameter*, this ), //liuchen 2009-6-23
 										SAL_STATIC_CAST( ::com::sun::star::awt::XDialog*, this ) );
 	return (aRet.hasValue() ? aRet : VCLXTopWindow::queryInterface( rType ));
 }
 
 // ::com::sun::star::lang::XTypeProvider
 IMPL_XTYPEPROVIDER_START( VCLXDialog )
+	getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::document::XVbaMethodParameter>* ) NULL ), //liuchen 2009-6-23
 	getCppuType( ( ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDialog>* ) NULL ),
 	VCLXTopWindow::getTypes()
 IMPL_XTYPEPROVIDER_END
@@ -2300,7 +2320,41 @@
 	return aInfo;
 }
 
+//liuchen 2009-7-22
+// ::com::sun::star::document::XVbaMethodParameter
+void SAL_CALL VCLXDialog::setVbaMethodParameter(
+	const ::rtl::OUString& PropertyName,
+	const ::com::sun::star::uno::Any& Value )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	if (rtl::OUString::createFromAscii( "Cancel" ) == PropertyName)
+	{
+		::vos::OGuard aGuard( GetMutex() ); 
+		if ( GetWindow() )
+		{
+			sal_Int8 nCancel;
+			Value >>= nCancel;
+		
+			Dialog* pDlg = (Dialog*) GetWindow();
+			pDlg->SetCloseFlag(nCancel);
+		}
+	}
+}
 
+::com::sun::star::uno::Any SAL_CALL VCLXDialog::getVbaMethodParameter(
+	const ::rtl::OUString& PropertyName )
+throw(::com::sun::star::uno::RuntimeException)
+{
+	::vos::OGuard aGuard( GetMutex() );
+
+	::com::sun::star::uno::Any aRet;	
+	return aRet;
+}
+//liuchen 2009-7-22
+
+
+
+
 void SAL_CALL VCLXDialog::setProperty(
     const ::rtl::OUString& PropertyName,
     const ::com::sun::star::uno::Any& Value )
Index: toolkit/inc/toolkit/helper/property.hxx
===================================================================
--- toolkit/inc/toolkit/helper/property.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/helper/property.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -197,6 +197,8 @@
 #define BASEPROPERTY_GRID_COLUMNMODEL               143
 #define BASEPROPERTY_GRID_SELECTIONMODE             144
 #define BASEPROPERTY_ENABLEVISIBLE                  145  // sal_Bool
+#define BASEPROPERTY_GROUPNAME                      146  // ::rtl::OUString
+#define BASEPROPERTY_VBAFORM                        147  // sal_Bool
 
 
 // Keine gebundenen Properties, werden immer aus der Property BASEPROPERTY_FONTDESCRIPTOR entnommen.
Index: toolkit/inc/toolkit/helper/servicenames.hxx
===================================================================
--- toolkit/inc/toolkit/helper/servicenames.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/helper/servicenames.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,6 +40,8 @@
 extern const sal_Char __FAR_DATA szServiceName_MenuBar[], szServiceName2_MenuBar[];
 extern const sal_Char __FAR_DATA szServiceName_Pointer[], szServiceName2_Pointer[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainer[], szServiceName2_UnoControlContainer[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageControl[], szServiceName2_UnoMultiPageControl[];
+extern const sal_Char __FAR_DATA szServiceName_UnoMultiPageModel[], szServiceName2_UnoMultiPageModel[];
 extern const sal_Char __FAR_DATA szServiceName_UnoControlContainerModel[], szServiceName2_UnoControlContainerModel[];
 extern const sal_Char __FAR_DATA szServiceName_TabController[], szServiceName2_TabController[];
 extern const sal_Char __FAR_DATA szServiceName_TabControllerModel[], szServiceName2_TabControllerModel[];
Index: toolkit/inc/toolkit/controls/unocontrols.hxx
===================================================================
--- toolkit/inc/toolkit/controls/unocontrols.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/controls/unocontrols.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -225,7 +225,6 @@
     bool                                                                                    mbAdjustingGraphic;
     
     ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
-    ::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphic > getGraphicFromURL_nothrow( const ::rtl::OUString& _rURL );
 protected:
     ImageProducerControlModel() : mbAdjustingImagePosition( false ), mbAdjustingGraphic( false ) { }
     ImageProducerControlModel( const ImageProducerControlModel& _rSource ) : com::sun::star::awt::XImageProducer(), UnoControlModel( _rSource ), mbAdjustingImagePosition( false ), mbAdjustingGraphic( false ) { }
@@ -670,6 +669,44 @@
 
 };
 
+class UnoMultiPageModel : public UnoControlModel
+{
+protected:
+	::com::sun::star::uno::Any 		ImplGetDefaultValue( sal_uInt16 nPropId ) const;
+	::cppu::IPropertyArrayHelper& 	SAL_CALL getInfoHelper();
+
+public:
+						UnoMultiPageModel();
+						UnoMultiPageModel( const UnoMultiPageModel& rModel ) : UnoControlModel( rModel ) {;}
+
+	UnoControlModel*	Clone() const { return new UnoMultiPageModel( *this ); }
+
+	// ::com::sun::star::io::XPersistObject
+    ::rtl::OUString SAL_CALL getServiceName() throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::beans::XMultiPropertySet
+    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageModel, UnoControlModel, szServiceName_UnoMultiPageModel )
+
+};
+//	----------------------------------------------------
+//	class UnoGroupBoxControl
+//	----------------------------------------------------
+class UnoMultiPageControl :	public UnoControlBase
+{
+public:
+						UnoMultiPageControl();
+	::rtl::OUString		GetComponentServiceName();
+
+    sal_Bool SAL_CALL isTransparent(  ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XServiceInfo
+	DECLIMPL_SERVICEINFO_DERIVED( UnoMultiPageControl, UnoControlBase, szServiceName_UnoMultiPageControl )
+
+};
+
 //  ----------------------------------------------------
 //  class UnoFixedTextControl
 //  ----------------------------------------------------
Index: toolkit/inc/toolkit/controls/dialogcontrol.hxx
===================================================================
--- toolkit/inc/toolkit/controls/dialogcontrol.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/controls/dialogcontrol.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,8 @@
 #include <cppuhelper/propshlp.hxx>
 #include <cppuhelper/basemutex.hxx>
 #include <list>
+#include <map>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //	----------------------------------------------------
 //	class UnoControlDialogModel
@@ -91,7 +93,9 @@
 
 	AllGroups							maGroups;
 	sal_Bool							mbGroupsUpToDate;
-
+        
+	::com::sun::star::uno::Reference< ::com::sun::star::graphic::XGraphicObject > mxGrfObj;
+	bool mbAdjustingGraphic;
 protected:	
 	::com::sun::star::uno::Any			ImplGetDefaultValue( sal_uInt16 nPropId ) const;
 	::cppu::IPropertyArrayHelper&		SAL_CALL getInfoHelper();
@@ -178,10 +182,20 @@
 protected:
 	void startControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
 	void stopControlListening( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >& _rxChildModel );
+    // ::cppu::OPropertySetHelper
+	void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue ) throw (::com::sun::star::uno::Exception);
 
 	void implNotifyTabModelChange( const ::rtl::OUString& _rAccessor );
 
 	void implUpdateGroupStructure();
+private:
+    void AddRadioButtonToGroup (
+            const ::com::sun::star::uno::Reference< XControlModel >& rControlModel,
+            const ::rtl::OUString& rPropertyName,
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups,
+            ModelGroup*& rpCurrentGroup );
+    void AddRadioButtonGroup (
+            ::std::map< ::rtl::OUString, ModelGroup >& pNamedGroups );
 };
 
 //	----------------------------------------------------
Index: toolkit/inc/toolkit/awt/vclxwindows.hxx
===================================================================
--- toolkit/inc/toolkit/awt/vclxwindows.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/awt/vclxwindows.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -96,6 +96,7 @@
 #include <vcl/imgcons.hxx>
 #include <vcl/image.hxx>
 
+#include <com/sun/star/document/XVbaMethodParameter.hpp>  //liuchen 2009-6-22, add the support of input/output parameters to VBA Dialog_QueryClose event
 class Button;
 class CheckBox;
 class RadioButton;
@@ -391,6 +392,7 @@
 //	class VCLXDialog
 //	----------------------------------------------------
 class VCLXDialog :	public ::com::sun::star::awt::XDialog,
+						public ::com::sun::star::document::XVbaMethodParameter, //liuchen 2009-6-22, add the support of input/output parameters to VBA UserForm_QueryClose event
 					public VCLXTopWindow
 {
 public:
@@ -424,6 +426,10 @@
 	// ::com::sun::star::awt::XVclWindowPeer
     void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
 
+	//liuchen 2009-6-23, support Excel VBA UserForm_QueryClose event
+	// ::com::sun::star::document::XVBAMethodParameter
+	void SAL_CALL setVbaMethodParameter( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+	::com::sun::star::uno::Any SAL_CALL getVbaMethodParameter( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException); 
 };
 
 //	----------------------------------------------------
Index: toolkit/inc/toolkit/awt/vclxmenu.hxx
===================================================================
--- toolkit/inc/toolkit/awt/vclxmenu.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ toolkit/inc/toolkit/awt/vclxmenu.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -48,6 +48,7 @@
 class Menu;
 class MenuBar;
 class VclSimpleEvent;
+class PopupMenu;
 
 DECLARE_LIST( PopupMenuRefList, ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPopupMenu >* )
 
@@ -184,6 +185,7 @@
 {
 public:
 		VCLXPopupMenu();
+		VCLXPopupMenu( PopupMenu* pPopMenu );
 };
 
 #endif // _TOOLKIT_AWT_VCLXMENU_HXX_
Index: sw/source/filter/ww8/makefile.mk
===================================================================
--- sw/source/filter/ww8/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/filter/ww8/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -69,7 +69,8 @@
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/ww8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
-        $(SLO)$/WW8FibData.obj
+        $(SLO)$/WW8FibData.obj \
+        $(SLO)$/ww8toolbar.obj \
 
 
 SLOFILES =	\
@@ -96,9 +97,11 @@
         $(SLO)$/WW8TableInfo.obj \
         $(SLO)$/ww8FFData.obj \
         $(SLO)$/WW8Sttbf.obj \
-        $(SLO)$/WW8FibData.obj
+        $(SLO)$/WW8FibData.obj \
+        $(SLO)$/ww8toolbar.obj \
 
 
+
 # --- Tagets -------------------------------------------------------
 
 .INCLUDE :	target.mk
Index: sw/source/filter/ww8/ww8par.cxx
===================================================================
--- sw/source/filter/ww8/ww8par.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/filter/ww8/ww8par.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -133,11 +133,19 @@
 #include <svtools/itemiter.hxx>  //SfxItemIter
 
 #include <stdio.h>
+#include <comphelper/processfactory.hxx>
+#include <basic/basmgr.hxx>
 
+#include "ww8toolbar.hxx"
+#include <osl/file.hxx>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
 #endif
+#include <unotools/localfilehelper.hxx>
+#include <comphelper/configurationhelper.hxx>
 
 #define MM_250 1417             // WW-Default fuer Hor. Seitenraender: 2.5 cm
 #define MM_200 1134             // WW-Default fuer u.Seitenrand: 2.0 cm
@@ -147,7 +155,150 @@
 using namespace sw::types;
 using namespace nsHdFtFlags;
 
+#include <com/sun/star/document/XEventsSupplier.hpp>
+#include <com/sun/star/container/XNameReplace.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <svx/msvbahelper.hxx>
+#include <svtools/pathoptions.hxx>
+#include <com/sun/star/ucb/XSimpleFileAccess.hpp>
 
+const static String sThisDocument( RTL_CONSTASCII_USTRINGPARAM("ThisDocument"));
+
+struct DocEventNameTable
+{
+    const sal_Char* sEventName;
+    const sal_Char* sMacroName;
+};
+
+const DocEventNameTable aEventNameTable[] = 
+{
+    {"OnNew", "Document_New"},
+    {"OnLoad", "Document_Open"},
+    {"OnPrepareUnload", "Document_Close"},
+    {NULL, NULL}
+};
+
+bool registerDocEvent( SfxObjectShell* pShell )
+{
+	bool result = false;
+	const static rtl::OUString sEvtType( RTL_CONSTASCII_USTRINGPARAM("EventType") );
+	const static rtl::OUString sScript( RTL_CONSTASCII_USTRINGPARAM("Script") );
+    uno::Reference< document::XEventsSupplier > xEvtSupplier( pShell->GetModel(), uno::UNO_QUERY );
+    if( !xEvtSupplier.is() )
+        return result;
+    uno::Reference< container::XNameReplace > xEvts( xEvtSupplier->getEvents(), uno::UNO_QUERY );     
+	if ( xEvts.is() )
+	{
+        for( const DocEventNameTable* pTable = aEventNameTable; pTable->sEventName != NULL; pTable++ )
+        {
+            rtl::OUString sEvt = rtl::OUString::createFromAscii( pTable->sEventName );
+            String sMacroName = String::CreateFromAscii( pTable->sMacroName ).Insert( '.', 0 ).Insert( sThisDocument, 0);
+            // fail to search the macro if the module is not specified.
+            ooo::vba::VBAMacroResolvedInfo aMacroInfo = ooo::vba::resolveVBAMacro( pShell, sMacroName );
+            if( !aMacroInfo.IsResolved() )
+                continue;
+
+		    uno::Sequence< beans::PropertyValue > aEvents;
+		    xEvts->getByName( sEvt ) >>= aEvents;
+		    uno::Sequence< beans::PropertyValue > aOpenEvt( 2 );
+		    aOpenEvt[ 0 ].Name = sEvtType;
+		    aOpenEvt[ 0 ].Value = uno::makeAny(sScript);
+		    aOpenEvt[ 1 ].Name = sScript;
+            rtl::OUString sUrl = ooo::vba::makeMacroURL( aMacroInfo.ResolvedMacro() );
+    		aOpenEvt[ 1 ].Value = uno::makeAny(sUrl);
+	    	sal_Int32 nPos = aEvents.getLength();
+
+		    sal_Int32 nNewSize = aEvents.getLength() + aOpenEvt.getLength();
+		    if ( nNewSize > aEvents.getLength() )
+			    aEvents.realloc( nNewSize );
+
+	    	for ( sal_Int32 nIndex = nPos, nCpyIndex = 0; nIndex<nNewSize; nIndex++, nCpyIndex++ )
+		    	aEvents[ nIndex ] = aOpenEvt[ nCpyIndex ];	
+			
+		    uno::Any aParam = uno::makeAny( aEvents );
+
+		    xEvts->replaceByName( sEvt, aParam ); 
+		    result = true;
+        }    
+	}
+	return result;
+}
+
+class Sttb : TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    SBBItem() : cchData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+
+    std::vector< SBBItem > dataItems;
+
+    Sttb(const Sttb&);
+    Sttb& operator = ( const Sttb&);
+public:
+    Sttb();
+    ~Sttb();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    rtl::OUString getStringAtIndex( sal_uInt32 );
+};
+
+Sttb::Sttb() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+{
+}
+
+Sttb::~Sttb()
+{
+}
+
+bool Sttb::Read( SvStream* pS )
+{
+    OSL_TRACE("Sttb::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            SBBItem aItem;
+            *pS >> aItem.cchData;
+            aItem.data = readUnicodeString( pS, aItem.cchData );
+            dataItems.push_back( aItem );
+        }
+    }
+    return true;
+}
+
+void Sttb::Print( FILE* fp )
+{
+    fprintf( fp, "[ 0x%x ] Sttb - dump\n", nOffSet);
+    fprintf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    fprintf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            fprintf(fp,"   string dataItem[ %d(0x%x) ] has name %s\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+
+}
+
+rtl::OUString 
+Sttb::getStringAtIndex( sal_uInt32 index )
+{
+    rtl::OUString aRet;
+    if ( index < dataItems.size() )
+        aRet = dataItems[ index ].data;
+    return aRet;
+}
+
 SwMSDffManager::SwMSDffManager( SwWW8ImplReader& rRdr )
     : SvxMSDffManager(*rRdr.pTableStream, rRdr.GetBaseURL(), rRdr.pWwFib->fcDggInfo,
         rRdr.pDataStream, 0, 0, COL_WHITE, 12, rRdr.pStrm,
@@ -3661,11 +3812,164 @@
         DBG_ASSERT(xDocProps.is(), "DocumentProperties is null");
 
         if (xDocProps.is()) {
+            if ( pWwFib->fDot )
+            {
+                rtl::OUString sTemplateURL;
+                SfxMedium* pMedium = mpDocShell->GetMedium();
+                if ( pMedium )
+                {
+                    rtl::OUString aName = pMedium->GetName();
+                    INetURLObject aURL( aName );
+                    sTemplateURL = aURL.GetMainURL(INetURLObject::DECODE_TO_IURI);
+                    if ( sTemplateURL.getLength() > 0 )
+                        xDocProps->setTemplateURL( sTemplateURL );
+                }
+            }
+            else // not a template
+            {
+                long nCur = pTableStream->Tell();
+                Sttb aSttb;
+                pTableStream->Seek( pWwFib->fcSttbfAssoc ); // point at tgc record
+                if (!aSttb.Read( pTableStream ) )
+                    OSL_TRACE("** Read of SttbAssoc data failed!!!! ");
+                pTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+                aSttb.Print( stderr );
+#endif
+                String sPath = aSttb.getStringAtIndex( 0x1 );
+                String aURL;
+                // attempt to convert to url ( won't work for obvious reasons on  linux 
+                if ( sPath.Len() )
+	        	::utl::LocalFileHelper::ConvertPhysicalNameToURL( sPath, aURL );
+                if ( aURL.Len() )
+                    xDocProps->setTemplateURL( aURL );
+                else
+                    xDocProps->setTemplateURL( sPath );
+                
+            }
             sfx2::LoadOlePropertySet(xDocProps, pStg);
         }
     }
 }
 
+void lcl_createTemplateToProjectEntry( const uno::Reference< container::XNameContainer >& xPrjNameCache, const rtl::OUString& sTemplatePathOrURL, const rtl::OUString& sVBAProjName )
+{
+    if ( xPrjNameCache.is() )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sTemplatePathOrURL );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+            aURL = sTemplatePathOrURL;
+        else
+        {
+            osl::FileBase::getFileURLFromSystemPath( sTemplatePathOrURL, aURL );
+            aObj.SetURL( aURL );
+        }
+        try
+        {
+            rtl::OUString templateNameWithExt = aObj.GetLastName();
+            rtl::OUString templateName;
+            sal_Int32 nIndex =  templateNameWithExt.lastIndexOf( '.' );
+            //xPrjNameCache->insertByName( templateNameWithExt, uno::makeAny( sVBAProjName ) );    
+            if ( nIndex != -1 )
+            {
+                templateName = templateNameWithExt.copy( 0, nIndex );
+                xPrjNameCache->insertByName( templateName, uno::makeAny( sVBAProjName ) );    
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+}
+
+class WW8Customizations
+{
+    SvStream* mpTableStream;
+    WW8Fib mWw8Fib;
+public:
+    WW8Customizations( SvStream*, WW8Fib& );
+    bool  Import( SwDocShell* pShell );
+};
+
+WW8Customizations::WW8Customizations( SvStream* pTableStream, WW8Fib& rFib ) : mpTableStream(pTableStream), mWw8Fib( rFib )
+{
+}
+
+bool WW8Customizations::Import( SwDocShell* pShell ) 
+{
+    if ( mWw8Fib.lcbCmds == 0 )
+        return false;
+    Tcg aTCG;
+    long nCur = mpTableStream->Tell();
+    mpTableStream->Seek( mWw8Fib.fcCmds ); // point at tgc record
+    if (!aTCG.Read( mpTableStream ) )
+        OSL_TRACE("** Read of Customization data failed!!!! ");
+    mpTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+    aTCG.Print( stderr );
+#endif
+    return aTCG.ImportCustomToolBar( *pShell );
+}
+
+bool SwWW8ImplReader::ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const uno::Reference< container::XNameContainer >& xPrjNameCache )
+{
+    SvtPathOptions aPathOpt;
+    String aAddinPath = aPathOpt.GetAddinPath();
+    uno::Sequence< rtl::OUString > sGlobalTemplates;
+
+    // first get the autoload addins in the directory STARTUP
+    uno::Reference< ucb::XSimpleFileAccess > xSFA( ::comphelper::getProcessServiceFactory()->createInstance( rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), uno::UNO_QUERY_THROW );
+
+    if( xSFA->isFolder( aAddinPath ) )
+        sGlobalTemplates = xSFA->getFolderContents( aAddinPath, sal_False );
+
+    sal_Int32 nEntries = sGlobalTemplates.getLength();
+    bool bRes = true;
+    const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+    for ( sal_Int32 i=0; i<nEntries; ++i )
+    {
+        INetURLObject aObj;
+        aObj.SetURL( sGlobalTemplates[ i ] );
+        bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+        rtl::OUString aURL;
+        if ( bIsURL )
+                aURL = sGlobalTemplates[ i ];
+        else
+                osl::FileBase::getFileURLFromSystemPath( sGlobalTemplates[ i ], aURL );        
+        if ( !aURL.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) || ( sCreatedFrom.getLength() && sCreatedFrom.equals( aURL ) ) )
+            continue; // don't try and read the same document as ourselves
+
+        SotStorageRef rRoot = new SotStorage( aURL, STREAM_STD_READWRITE, STORAGE_TRANSACTED ); 
+
+        // Read Macro Projects
+        SvxImportMSVBasic aVBasic(*mpDocShell, *rRoot,
+            pVBAFlags->IsLoadWordBasicCode(),
+            pVBAFlags->IsLoadWordBasicStorage() );
+
+
+        String s1(CREATE_CONST_ASC("Macros"));
+        String s2(CREATE_CONST_ASC("VBA"));
+        int nRet = aVBasic.Import( s1, s2, ! pVBAFlags->IsLoadWordBasicCode() );
+        lcl_createTemplateToProjectEntry( xPrjNameCache, aURL, aVBasic.GetVBAProjectName() );
+        // Read toolbars & menus
+        SvStorageStreamRef refMainStream = rRoot->OpenSotStream( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("WordDocument") ) );
+        refMainStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+        WW8Fib aWwFib( *refMainStream, 8 );       
+        SvStorageStreamRef xTableStream = rRoot->OpenSotStream(String::CreateFromAscii( aWwFib.fWhichTblStm ? SL::a1Table : SL::a0Table), STREAM_STD_READ);
+
+        if (xTableStream.Is() && SVSTREAM_OK == xTableStream->GetError())
+        {
+            xTableStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+            WW8Customizations aGblCustomisations( xTableStream, aWwFib ); 
+            aGblCustomisations.Import( mpDocShell );
+        }
+    }
+    return bRes;
+}
+
 ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
 {
     ULONG nErrRet = 0;
@@ -3921,7 +4225,63 @@
     }
     else //ordinary case
     {
+        if (mbNewDoc && pStg && !pGloss) /*meaningless for a glossary, cmc*/
+        {
+            mpDocShell->SetIsTemplate( pWwFib->fDot ); // point at tgc record
+            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
+            maTracer.EnterEnvironment(sw::log::eMacros);
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+            uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    
+            rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
+            uno::Reference< container::XNameContainer > xPrjNameCache;
+            uno::Reference< lang::XMultiServiceFactory> xSF(mpDocShell->GetModel(), uno::UNO_QUERY);
+            if ( xSF.is() )
+                xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
+
+            // Read Global templates 
+            ReadGlobalTemplateSettings( sCreatedFrom, xPrjNameCache );
+#endif 
+            // Create and insert Word vba Globals
+            uno::Any aGlobs;
+            uno::Sequence< uno::Any > aArgs(1);
+            aArgs[ 0 ] <<= mpDocShell->GetModel();
+            aGlobs <<= ::comphelper::getProcessServiceFactory()->createInstanceWithArguments( ::rtl::OUString::createFromAscii( "ooo.vba.word.Globals"), aArgs );
+            mpDocShell->GetBasicManager()->SetGlobalUNOConstant( "VBAGlobals", aGlobs );
+            
+            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
+                            pVBAFlags->IsLoadWordBasicCode(),
+                            pVBAFlags->IsLoadWordBasicStorage() );
+            String s1(CREATE_CONST_ASC("Macros"));
+            String s2(CREATE_CONST_ASC("VBA"));
+            int nRet = aVBasic.Import( s1, s2, ! pVBAFlags->IsLoadWordBasicCode() );
+// dissable below for 3.1 at the moment, 'cause it's kinda immature
+// similarly the project reference in svx/source/msvba
+#if 1
+            lcl_createTemplateToProjectEntry( xPrjNameCache, sCreatedFrom, aVBasic.GetVBAProjectName() );
+            WW8Customizations aCustomisations( pTableStream, *pWwFib ); 
+            aCustomisations.Import( mpDocShell );
+#endif 
+            if( 2 & nRet )
+            {
+                maTracer.Log(sw::log::eContainsVisualBasic);
+                rDoc.SetContainsMSVBasic(true);
+            }
+
+            StoreMacroCmds();
+
+            // Hackly to register the document event.
+            // should be find a better solution to share the codes with Excel Workbook event. 
+            registerDocEvent( mpDocShell );
+
+            maTracer.LeaveEnvironment(sw::log::eMacros);
+        }
         ReadText(0, pWwFib->ccpText, MAN_MAINTEXT);
+
     }
 
     ::SetProgressState(nProgress, mpDocShell);    // Update
@@ -3995,26 +4355,6 @@
             eMode |= nsRedlineMode_t::REDLINE_ON;
         if( pWDop->fRMView )
             eMode |= nsRedlineMode_t::REDLINE_SHOW_DELETE;
-        if (pStg && !pGloss) /*meaningless for a glossary, cmc*/
-        {
-            const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
-            maTracer.EnterEnvironment(sw::log::eMacros);
-            SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
-                            pVBAFlags->IsLoadWordBasicCode(),
-                            pVBAFlags->IsLoadWordBasicStorage() );
-            String s1(CREATE_CONST_ASC("Macros"));
-            String s2(CREATE_CONST_ASC("VBA"));
-            int nRet = aVBasic.Import( s1, s2 );
-            if( 2 & nRet )
-            {
-                maTracer.Log(sw::log::eContainsVisualBasic);
-                rDoc.SetContainsMSVBasic(true);
-            }
-
-            StoreMacroCmds();
-
-            maTracer.LeaveEnvironment(sw::log::eMacros);
-        }
     }
 
     maInsertedTables.DelAndMakeTblFrms();
Index: sw/source/filter/ww8/ww8par.hxx
===================================================================
--- sw/source/filter/ww8/ww8par.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/filter/ww8/ww8par.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1423,7 +1423,7 @@
     // determine object attribute "Layout in Table Cell"
     bool IsObjectLayoutInTableCell( const UINT32 nLayoutInTableCell ) const;
     // <--
-
+    bool ReadGlobalTemplateSettings( const rtl::OUString& sCreatedFrom, const com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xPrjNameMap );
     //No copying
     SwWW8ImplReader(const SwWW8ImplReader &);
     SwWW8ImplReader& operator=(const SwWW8ImplReader&);
Index: sw/source/filter/ww8/ww8toolbar.cxx
===================================================================
--- sw/source/filter/ww8/ww8toolbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/filter/ww8/ww8toolbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,1288 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleComponentFactory.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+// no. of visual data elements in a CTB ( fixed ) 
+const short nVisualData = 5;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOWordCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOWordCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOWordCommandConvertor::MSOWordCommandConvertor()
+{
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+Customization* CTBWrapper::GetCustomizaton( sal_Int16 index )
+{
+    if ( index < 0 || index >= rCustomizations.size() )
+        return NULL;
+    return &rCustomizations[ index ]; 
+}
+
+CTB* CTBWrapper::GetCustomizationData( const rtl::OUString& sTBName )
+{
+    CTB* pCTB = NULL;
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        if ( it->GetCustomizationData() && it->GetCustomizationData()->GetName().equals( sTBName ) )
+        {
+            pCTB = it->GetCustomizationData();
+            break;
+        }
+    }
+    return pCTB;
+}
+
+bool CTBWrapper::Read( SvStream* pS )
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        int nStart = pS->Tell();
+
+        int bytesRead = 0;
+        int bytesToRead = cbDTBC - bytesRead; 
+        // cbDTBC specifies the size ( in bytes ) taken by an array ( of unspecified size )
+        // of TBC records ( TBC records have dynamic length, so we need to check our position
+        // after each read )
+        do
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rtbdc.push_back( aTBC );
+            bytesToRead = cbDTBC - ( pS->Tell() - nStart ); 
+        } while ( bytesToRead > 0 );
+    }
+    if ( cCust )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            Customization aCust( this );
+            if ( !aCust.Read( pS ) )
+                return false;
+            rCustomizations.push_back( aCust );
+        } 
+    } 
+    std::vector< sal_Int16 >::iterator it_end = dropDownMenuIndices.end();
+    for ( std::vector< sal_Int16 >::iterator it = dropDownMenuIndices.begin(); it != it_end; ++it )
+    {
+        rCustomizations[ *it ].bIsDroppedMenuTB = true;
+    }
+    return true;
+}
+
+TBC* CTBWrapper::GetTBCAtOffset( sal_uInt32 nStreamOffset )
+{
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it )
+    {
+        if ( (*it).GetOffset() == nStreamOffset )
+            return &(*it);
+    }
+    return NULL;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] CTBWrapper - dump\n", nOffSet );
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        indent_printf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        indent_printf(fp,"    reserved1(0x%x)\n",ch);
+        indent_printf(fp,"    reserved2(0x%x)\n",reserved2);
+        indent_printf(fp,"    reserved3(0x%x)\n",reserved3);
+        indent_printf(fp,"    reserved4(0x%x)\n",reserved4);
+        indent_printf(fp,"    reserved5(0x%x)\n",reserved5);
+        indent_printf(fp,"Quiting dump");
+        return;
+    }
+    indent_printf(fp,"  size of TBDelta structures 0x%x\n", cbTBD );
+    indent_printf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    indent_printf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+
+    sal_Int32 index = 0;
+
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping rtbdc[%d]\n", static_cast< int >( index ));
+        Indent b;
+        it->Print( fp );
+    }
+
+    index = 0;
+
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+        Indent c;
+        it->Print(fp);
+    }
+}
+
+bool CTBWrapper::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rDocSh, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) );
+        helper.setMSOCommandMap( new MSOWordCommandConvertor() );
+
+        if ( !(*it).ImportCustomToolBar( *this, helper ) )
+            return false;
+    }
+    return false;
+}
+
+Customization::Customization( CTBWrapper* wrapper ) : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+, pWrapper( wrapper )
+, bIsDroppedMenuTB( false )
+{
+}
+
+Customization::~Customization()
+{
+}
+
+bool Customization::Read( SvStream *pS)
+{
+    OSL_TRACE("Custimization::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD )
+    {
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+        {
+            TBDelta aTBDelta;
+            if (!aTBDelta.Read( pS ) )
+                return false;
+            customizationDataTBDelta.push_back( aTBDelta );
+            // Only set the drop down for menu's associated with standard toolbar
+            if ( aTBDelta.ControlDropsToolBar() && tbidForTBD == 0x25 )
+                pWrapper->InsertDropIndex( aTBDelta.CustomizationIndex() );
+        }
+    }
+    else
+    {
+        customizationDataCTB.reset( new CTB() );
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] Customization -- dump \n", nOffSet );
+    indent_printf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    indent_printf( fp,"  reserved1 0x%x \n", reserved1);
+    indent_printf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+    {
+        const char* pToolBar = NULL;
+        switch ( tbidForTBD )
+        {
+            case 0x9:
+                pToolBar = "Standard";
+                break;
+            case 0x25:
+                pToolBar = "Builtin-Menu";
+                break;
+            default:
+                pToolBar = "Unknown toolbar";
+                break;
+        }
+        
+        indent_printf( fp,"  TBDelta(s) are associated with %s toolbar.\n", pToolBar);
+        std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin();
+        for ( sal_Int32 index = 0; index < ctbds; ++it,++index )
+            it->Print( fp );
+    }
+    
+}
+
+bool Customization::ImportMenu( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( tbidForTBD == 0x25 )  // we can handle in a limited way additions the built-in menu bar
+    {
+        for ( std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin(); it != customizationDataTBDelta.end(); ++it )
+        {
+            // for each new menu ( control that drops a toolbar )
+            // import a toolbar
+            if ( it->ControlIsInserted() && it->ControlDropsToolBar() )
+            {
+                Customization* pCust = pWrapper->GetCustomizaton( it->CustomizationIndex() );
+                if ( pCust )
+                {
+                    // currently only support built-in menu
+                    rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+
+                    sMenuBar = sMenuBar.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("menubar") ) );
+                    // Get menu name
+                    TBC* pTBC = pWrapper->GetTBCAtOffset( it->TBCStreamOffset() );
+                    if ( !pTBC )
+                        return false;
+                    rtl::OUString sMenuName = pTBC->GetCustomText();
+                    sMenuName = sMenuName.replace('&','~');
+
+                    // see if the document has already setting for the menubar
+                
+                    uno::Reference< container::XIndexContainer > xIndexContainer;
+                    bool bHasSettings = false;
+                    if ( helper.getCfgManager()->hasSettings( sMenuBar ) )
+                    {
+                        xIndexContainer.set( helper.getCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        bHasSettings = true;
+                    }
+                    else
+                    {
+                        if ( helper.getAppCfgManager()->hasSettings( sMenuBar ) )
+                            xIndexContainer.set( helper.getAppCfgManager()->getSettings( sMenuBar, sal_True ), uno::UNO_QUERY_THROW );
+                        else 
+                            xIndexContainer.set( helper.getAppCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+                    }
+               
+                    uno::Reference< lang::XSingleComponentFactory > xSCF( xIndexContainer, uno::UNO_QUERY_THROW );
+                    uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                    uno::Reference< uno::XComponentContext > xContext(  xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+                    // create the popup menu
+                    uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+                    aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                    aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + sMenuName );
+                    aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+                    aPopupMenu[1].Value <<= sMenuName;
+                    aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+                    aPopupMenu[2].Value <<= sal_Int32( 0 );
+                    aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    uno::Reference< container::XIndexContainer > xMenuContainer( xSCF->createInstanceWithContext( xContext ), uno::UNO_QUERY_THROW );
+                    aPopupMenu[3].Value <<= xMenuContainer;
+                    if ( pCust->customizationDataCTB.get() && !pCust->customizationDataCTB->ImportMenuTB( rWrapper, xMenuContainer, helper ) )
+                        return false;
+                    OSL_TRACE("** there are %d menu items on the bar, inserting after that", xIndexContainer->getCount() );
+                    xIndexContainer->insertByIndex( xIndexContainer->getCount(), uno::makeAny( aPopupMenu ) );
+
+                    if ( bHasSettings )
+                        helper.getCfgManager()->replaceSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+                    else
+                        helper.getCfgManager()->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xIndexContainer, uno::UNO_QUERY_THROW ) );
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+                }
+            }
+        }
+        return true;
+    }
+    return true;
+}
+
+bool Customization::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    if ( GetTBIDForTB() == 0x25 )
+        return ImportMenu( rWrapper, helper );
+    if ( !customizationDataCTB.get() )
+        return false;
+    if ( !customizationDataCTB->IsMenuToolbar() )
+    {
+        if ( !customizationDataCTB->ImportCustomToolBar( rWrapper, helper ) )
+            return false;
+    }
+    return true;
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::ControlIsModified()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x2 );
+}
+
+bool TBDelta::ControlIsInserted()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlIsChanged()
+{
+    return ( ( doprfatendFlags & 0x3 ) == 0x1 );
+}
+
+bool TBDelta::ControlDropsToolBar()
+{
+    return !( CiTBDE & 0x8000 );
+}
+
+sal_Int32 TBDelta::TBCStreamOffset()
+{
+    return fc;
+}
+
+sal_Int16 TBDelta::CustomizationIndex()
+{
+    sal_Int16 nIndex = CiTBDE;
+    nIndex = nIndex >> 1;
+    nIndex &= 0x1ff; // only 13 bits are relevant
+    return nIndex;
+}
+
+bool TBDelta::Read(SvStream *pS)
+{
+    OSL_TRACE("TBDelta::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    *pS >> CiTBDE >> cbTBC;
+    return true;
+}
+
+void TBDelta::Print( FILE* fp )
+{
+    // Like most of the debug output, it's raw and little ( no )
+    // interpretation of the data is output ( e.g. flag values etc. )
+    indent_printf( fp, "[ 0x%x ] TBDelta -- dump\n", nOffSet );
+    indent_printf( fp, " doprfatendFlags 0x%x\n",doprfatendFlags );
+    
+    indent_printf( fp, " ibts 0x%x\n",ibts );
+    indent_printf( fp, " cidNext 0x%x\n", static_cast< unsigned int >( cidNext ) );
+    indent_printf( fp, " cid 0x%x\n", static_cast< unsigned int >( cid ) );
+    indent_printf( fp, " fc 0x%x\n", static_cast< unsigned int >( fc ) );
+    indent_printf( fp, " CiTBDE 0x%x\n",CiTBDE );
+    indent_printf( fp, " cbTBC 0x%x\n", cbTBC );
+    if ( ControlDropsToolBar() )
+    {
+        indent_printf( fp, " this delta is associated with a control that drops a menu toolbar\n", cbTBC );
+        indent_printf( fp, " the menu toolbar drops the toolbar defined at index[%d] in the rCustomizations array of the CTBWRAPPER that contains this TBDelta\n", CustomizationIndex() );
+    }
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+{
+}
+
+CTB::~CTB()
+{
+}
+
+bool CTB::IsMenuToolbar()
+{
+    return tb.IsMenuToolbar();
+}
+
+
+bool CTB::Read( SvStream *pS)
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    if ( !tb.Read( pS ) )
+        return false;
+    for ( short index = 0; index < nVisualData; ++index )
+    {
+        TBVisualData aVisData;
+        aVisData.Read( pS );
+        rVisualData.push_back( aVisData );
+    }
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rTBC.push_back( aTBC );
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] CTB - dump\n", nOffSet );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    for ( short counter = 0; counter < nVisualData; ++counter )
+    {
+        indent_printf( fp, "  TBVisualData [%d]\n", counter);
+        Indent b;
+        rVisualData[ counter ].Print( fp );
+    } 
+    indent_printf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            indent_printf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+bool CTB::ImportCustomToolBar( CTBWrapper& rWrapper, CustomToolBarImportHelper& helper )
+{
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    bool bRes = false;
+    try
+    {
+        if ( !tb.IsEnabled() )
+            return true;  // didn't fail, just ignoring
+        // Create default setting
+        uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+        
+        // set UI name for toolbar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+    
+        rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+        for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+        {
+            // createToolBar item for control
+            if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, helper, IsMenuToolbar() ) )
+                return false;
+        }
+    
+        OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+        helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+        helper.applyIcons();
+#if 1 // don't think this is necessary
+        uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+
+        xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+        xPersistence->store();
+#endif
+        bRes = true;
+    }
+    catch( uno::Exception& e )
+    {
+        OSL_TRACE("***** For some reason we have an exception %s", rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+        bRes = false;
+    }
+    return bRes;
+}
+
+bool CTB::ImportMenuTB( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& xIndexContainer, CustomToolBarImportHelper& rHelper )
+{
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+    {
+        // createToolBar item for control
+        if ( !it->ImportToolBarControl( rWrapper, xIndexContainer, rHelper, true ) )
+            return false;
+    }
+    return true;
+}
+
+TBC::TBC()
+{
+}
+
+TBC::~TBC()
+{
+}
+
+bool TBC::Read( SvStream *pS )
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.getTcID() != 0x1 && tbch.getTcID() != 0x1051 )
+    {
+        cid.reset( new sal_uInt32 );
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.getTct() != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBC -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid.get() )
+        indent_printf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        indent_printf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+bool
+TBC::ImportToolBarControl( CTBWrapper& rWrapper, const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper, bool bIsMenuBar )
+{
+    // cmtFci       0x1 Command based on a built-in command. See CidFci.
+    // cmtMacro     0x2 Macro command. See CidMacro.
+    // cmtAllocated 0x3 Allocated command. See CidAllocated.
+    // cmtNil       0x7 No command. See Cid.
+    bool bBuiltin = false;
+    sal_uInt16 cmdId = 0;
+    if  ( cid.get() )
+    {
+        sal_uInt16 arg2 = ( *( cid.get() ) & 0xFFFF );
+
+        sal_uInt8 cmt = ( arg2 & 0x7 );
+        arg2 = ( arg2 >> 3 );
+
+        switch ( cmt )
+        {
+            case 1:
+                OSL_TRACE("cmt is cmtFci builtin command 0x%x", arg2);
+                bBuiltin = true;
+                cmdId = arg2;
+                break;
+            case 2:
+                OSL_TRACE("cmt is cmtMacro macro 0x%x", arg2);
+                break;
+            case 3:
+                OSL_TRACE("cmt is cmtAllocated [???] 0x%x", arg2);
+                break;
+            case 7:
+                OSL_TRACE("cmt is cmNill no-phing 0x%x", arg2);
+                break;
+            default:
+                OSL_TRACE("illegal 0x%x", cmt);
+                break;
+        }
+    }
+
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+        }
+        bool bBeginGroup = false;
+        if ( ! tbcd->ImportToolBarControl( helper, props, bBeginGroup, bIsMenuBar ) )
+            return false;
+
+        TBCMenuSpecific* pMenu = tbcd->getMenuSpecific();
+        if ( pMenu )
+        {
+            OSL_TRACE("** control has a menu, name of toolbar with menu items is %s", rtl::OUStringToOString( pMenu->Name(), RTL_TEXTENCODING_UTF8 ).getStr() );
+            // search for CTB with the appropriate name ( it contains the
+            // menu items, although we cannot import ( or create ) a menu on
+            // a custom toolbar we can import the menu items in a separate 
+            // toolbar ( better than nothing )
+            CTB* pCustTB = rWrapper.GetCustomizationData( pMenu->Name() );
+            if ( pCustTB )
+            {
+                 uno::Reference< container::XIndexContainer > xMenuDesc;
+                 uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+                 xMenuDesc.set( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.IndexedPropertyValues" ) ) ), uno::UNO_QUERY_THROW );
+                if ( !pCustTB->ImportMenuTB( rWrapper,xMenuDesc, helper ) )
+                    return false;     
+                if ( !bIsMenuBar )
+                {
+                    if ( !helper.createMenu( pMenu->Name(), uno::Reference< container::XIndexAccess >( xMenuDesc, uno::UNO_QUERY ), true ) )
+                        return false;
+                }
+                else
+                {
+                    beans::PropertyValue aProp;
+                    aProp.Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+                    aProp.Value <<= xMenuDesc;
+                    props.push_back( aProp );
+                }
+            } 
+        }
+
+        if ( bBeginGroup )
+        {
+            // insert spacer
+            uno::Sequence< beans::PropertyValue > sProps( 1 );
+            sProps[ 0 ].Name =  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+            sProps[ 0 ].Value = uno::makeAny( ui::ItemType::SEPARATOR_LINE ); 
+            toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );       
+        }
+ 
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+rtl::OUString 
+TBC::GetCustomText()
+{
+    rtl::OUString sCustomText;
+    if ( tbcd.get() )
+        sCustomText = tbcd->getGeneralInfo().CustomText();
+    return sCustomText;
+   
+    
+}
+
+bool 
+Xst::Read( SvStream* pS )
+{
+    OSL_TRACE("Xst::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] Xst -- dump\n", nOffSet );
+    indent_printf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    Indent a(true);
+    indent_printf(fp, "[ 0x%x ] Tcg - dump %d\n", nOffSet, nTcgVer);
+    indent_printf(fp,"  nTcgVer %d\n", nTcgVer);
+    tcg->Print( fp );
+}
+
+bool Tcg::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    return tcg->ImportCustomToolBar( rDocSh );
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SvStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::ImportCustomToolBar( SfxObjectShell& rDocSh )
+{
+    // Find the CTBWrapper
+    for ( std::vector< Tcg255SubStruct* >::const_iterator it = rgtcgData.begin(); it != rgtcgData.end(); ++it )
+    {
+        if ( (*it)->id() == 0x12 )
+        {
+            // not so great, shouldn't really have to do a horror casting    
+            CTBWrapper* pCTBWrapper =  dynamic_cast< CTBWrapper* > ( *it );
+            if ( pCTBWrapper )
+            {
+                if ( !pCTBWrapper->ImportCustomToolBar( rDocSh ) )
+                    return false;
+            }
+        }
+    }
+    return true;
+}
+
+
+bool Tcg255::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] Tcg255 - dump\n", nOffSet );
+    indent_printf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        Indent b;
+        indent_printf(fp, "  [%d] Tcg255SubStruct \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255SubStruct::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SvStream *pS)
+{
+    OSL_TRACE("PffMcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfMcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SvStream *pS)
+{
+    OSL_TRACE("PffAcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfAcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SvStream *pS)
+{
+    OSL_TRACE("PlfKme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfKme ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SvStream *pS) 
+{
+    OSL_TRACE("TcgSttbf::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TcgSttbf - dump\n", nOffSet );
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SvStream* pS )
+{
+    OSL_TRACE("TcgSttbfCore::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TcgSttbfCore - dump\n");
+    indent_printf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    indent_printf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    indent_printf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            indent_printf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SvStream *pS)
+{
+    OSL_TRACE("MacroNames::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] MacroNames ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SvStream *pS)
+{
+    OSL_TRACE("MacroName::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MacroName - dump");
+    indent_printf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SvStream *pS)
+{
+    OSL_TRACE("Xstz::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] Xstz -- dump\n", nOffSet );
+    indent_printf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    indent_printf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SvStream *pS)
+{
+    OSL_TRACE("Kme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> kt >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    Indent a;
+    
+   indent_printf( fp, "[ 0x%x ] Kme - dump\n", nOffSet );
+   indent_printf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   indent_printf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   indent_printf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   indent_printf( fp, " kt 0x%x \n", kt );
+   indent_printf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SvStream *pS)
+{
+    OSL_TRACE("Acd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] ACD - dump\n", nOffSet );
+    // #TODO flesh out interpretation of these values
+    indent_printf( fp,"  ibst 0x%x\n", ibst);
+    indent_printf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SvStream *pS)
+{
+    OSL_TRACE("MCD::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MCD - dump\n", nOffSet );
+    indent_printf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+    indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+    indent_printf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+    indent_printf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+    indent_printf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+    indent_printf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+    indent_printf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+    indent_printf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+    indent_printf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
Index: sw/source/filter/ww8/ww8toolbar.hxx
===================================================================
--- sw/source/filter/ww8/ww8toolbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/filter/ww8/ww8toolbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,347 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <svx/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SvStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class CTBWrapper;
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr< sal_uInt32 > cid; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper&, bool );
+    rtl::OUString GetCustomText();
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb;
+    std::vector<TBVisualData> rVisualData;
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    std::vector< TBC > rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    bool IsMenuToolbar();
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenuTB( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+    rtl::OUString GetName() { return tb.getName().getString(); }
+};
+
+class TBDelta : public TBBase
+{
+    sal_uInt8 doprfatendFlags;
+
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt16 CiTBDE; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ControlIsModified();
+    bool ControlIsInserted();
+    bool ControlIsChanged();
+    bool ControlDropsToolBar();
+    sal_Int32 TBCStreamOffset();
+    sal_Int16 CustomizationIndex();
+    
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() const { return ch; }
+    bool Read(SvStream *pS);
+};
+
+class CTBWrapper;
+class Customization : public TBBase
+{
+friend class CTBWrapper;
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+    CTBWrapper* pWrapper;
+    boost::shared_ptr< CTB > customizationDataCTB;
+    std::vector< TBDelta > customizationDataTBDelta; 
+    bool bIsDroppedMenuTB; 
+    bool ImportMenu( CTBWrapper&, const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+public:    
+    Customization( CTBWrapper* rapper );
+    ~Customization();
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( CTBWrapper&, CustomToolBarImportHelper& );
+    bool ImportMenu( CTBWrapper&, CustomToolBarImportHelper& );
+    void Print( FILE* );
+    sal_Int32 GetTBIDForTB(){ return tbidForTBD; }
+    CTB*  GetCustomizationData() { return customizationDataCTB.get(); };
+};
+
+class SfxObjectShell; 
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    std::vector< TBC > rtbdc; // 
+    std::vector< Customization > rCustomizations; // array of Customizations
+    std::vector< sal_Int16 > dropDownMenuIndices; // array of indexes of Customization toolbars that are dropped by a menu
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    void InsertDropIndex( sal_Int32 aIndex ) { dropDownMenuIndices.push_back( aIndex ); }
+    TBC* GetTBCAtOffset( sal_uInt32 nStreamOffset );
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+
+    Customization* GetCustomizaton( sal_Int16 index );
+    CTB* GetCustomizationData( const rtl::OUString& name );
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macros name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SvStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SvStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( SfxObjectShell& rDocSh );
+    void Print( FILE* );
+};
+
+#endif
Index: sw/source/core/unocore/unocoll.cxx
===================================================================
--- sw/source/core/unocore/unocoll.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/core/unocore/unocoll.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -77,9 +77,17 @@
 #include <iterator>
 
 #include "unometa.hxx"
 #include "docsh.hxx"
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#include <vbahelper/vbahelper.hxx>
+#include <basic/basmgr.hxx>
 
 
 using ::rtl::OUString;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::document;
@@ -86,6 +93,184 @@
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::lang;
 
+class SwVbaCodeNameProvider : public ::cppu::WeakImplHelper1< document::XCodeNameQuery >
+{
+    SwDocShell* mpDocShell;
+    rtl::OUString msThisDocumentCodeName;
+public:
+    SwVbaCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+        // XCodeNameQuery
+    rtl::OUString SAL_CALL getCodeNameForObject( const uno::Reference< uno::XInterface >& xIf ) throw( uno::RuntimeException )
+    {
+        // Initialise the code name
+        if ( msThisDocumentCodeName.getLength() == 0 )
+        {
+            try
+            {
+                uno::Reference< beans::XPropertySet > xProps( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< container::XNameAccess > xLibContainer( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BasicLibraries") ) ), uno::UNO_QUERY_THROW );
+		rtl::OUString sProjectName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) );
+                if ( mpDocShell->GetBasicManager()->GetName().Len() )
+                    sProjectName =  mpDocShell->GetBasicManager()->GetName();
+    
+                uno::Reference< container::XNameAccess > xStandard( xLibContainer->getByName( sProjectName ), uno::UNO_QUERY_THROW );
+                uno::Sequence< rtl::OUString > sModuleNames = xStandard->getElementNames();
+                for ( sal_Int32 i=0; i < sModuleNames.getLength(); ++i )
+                {
+                    script::ModuleInfo mInfo;
+                    if ( xStandard->getByName( sModuleNames[ i ] ) >>= mInfo )
+                    {
+                        if ( mInfo.ModuleType == script::ModuleType::Document )
+                        {
+                            msThisDocumentCodeName = sModuleNames[ i ];
+                            break;
+                        }
+                    } 
+                }
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+        rtl::OUString sCodeName;
+        if ( mpDocShell )
+        {
+            OSL_TRACE( "*** In ScVbaCodeNameProvider::getCodeNameForObject");
+            // need to find the page ( and index )  for this control
+            uno::Reference< drawing::XDrawPageSupplier > xSupplier( mpDocShell->GetModel(), uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xIndex( xSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+            sal_Int32 nLen = xIndex->getCount();
+            bool bMatched = false;
+            uno::Sequence< script::ScriptEventDescriptor > aFakeEvents;
+                try
+                {
+                    uno::Reference< form::XFormsSupplier >  xFormSupplier( xIndex, uno::UNO_QUERY_THROW );
+                    uno::Reference< container::XIndexAccess > xFormIndex( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+                    // get the www-standard container
+                    uno::Reference< container::XIndexAccess > xFormControls( xFormIndex->getByIndex(0), uno::UNO_QUERY_THROW );
+                    sal_Int32 nCntrls = xFormControls->getCount();
+                    for( sal_Int32 cIndex = 0; cIndex < nCntrls; ++cIndex )
+                    {
+                        uno::Reference< uno::XInterface > xControl( xFormControls->getByIndex( cIndex ), uno::UNO_QUERY_THROW );	
+                        bMatched = ( xControl == xIf );
+                        if ( bMatched )
+                        {
+                            sCodeName = msThisDocumentCodeName;
+                            break;
+                        }
+                    }
+                }
+                catch( uno::Exception& ) {}
+        }
+        // Probably should throw here ( if !bMatched )
+        return sCodeName;
+    }
+};
+
+typedef std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash > StringHashMap;
+class SwVbaProjectNameProvider : public ::cppu::WeakImplHelper1< container::XNameContainer >
+{
+    SwDocShell* mpDocShell;
+    StringHashMap mTemplateToProject; 
+public:
+    SwVbaProjectNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        return ( mTemplateToProject.find( aName ) != mTemplateToProject.end() );
+    }
+    virtual ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        return uno::makeAny( mTemplateToProject.find( aName )->second );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aElements( mTemplateToProject.size() );
+        StringHashMap::iterator it_end = mTemplateToProject.end();
+        sal_Int32 index = 0;
+        for ( StringHashMap::iterator it = mTemplateToProject.begin(); it != it_end; ++it, ++index )
+            aElements[ index ] = it->first;
+        return aElements;
+    }
+
+    virtual void SAL_CALL insertByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::ElementExistException, com::sun::star::lang::WrappedTargetException )
+    {
+        
+        rtl::OUString sProjectName;
+        aElement >>= sProjectName;
+        OSL_TRACE("** Template cache inserting template name %s with project %s"
+            , rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr()
+            , rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        mTemplateToProject[ aName ] = sProjectName;
+    }
+
+    virtual void SAL_CALL removeByName( const rtl::OUString& Name ) throw ( com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( Name ) )
+            throw container::NoSuchElementException();
+        mTemplateToProject.erase( Name );
+    }
+    virtual void SAL_CALL replaceByName( const rtl::OUString& aName, const uno::Any& aElement ) throw ( com::sun::star::lang::IllegalArgumentException, com::sun::star::container::NoSuchElementException, com::sun::star::lang::WrappedTargetException )
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        insertByName( aName, aElement ); // insert will overwrite
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException)
+    { 
+        return ::getCppuType((const rtl::OUString*)0); 
+    }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) 
+    { 
+        
+        return ( mTemplateToProject.size() > 0 );
+    }
+
+};
+
+class SwVbaObjectForCodeNameProvider : public ::cppu::WeakImplHelper1< container::XNameAccess >
+{
+    SwDocShell* mpDocShell;
+public:
+    SwVbaObjectForCodeNameProvider( SwDocShell* pDocShell ) : mpDocShell( pDocShell )
+    {
+        // #FIXME #TODO is the code name for ThisDocument read anywhere?
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException )
+    {
+        // #FIXME #TODO we really need to be checking against the codename for 
+        // ThisDocument 
+        if ( aName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisDocument" ) ) ) )
+            return sal_True;
+        return sal_False;
+    }
+    ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+             throw container::NoSuchElementException();
+	uno::Sequence< uno::Any > aArgs( 2 );
+        aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+        aArgs[1] = uno::Any( mpDocShell->GetModel() );
+        uno::Reference< uno::XInterface > xDocObj = ov::createVBAUnoAPIServiceWithArgs( mpDocShell, "ooo.vba.word.Document" , aArgs );
+        OSL_TRACE("Creating Object ( ooo.vba.word.Document ) 0x%x", xDocObj.get() );
+        return  uno::makeAny( xDocObj );
+    }
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (::com::sun::star::uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aNames;
+        return aNames;
+    }
+    // XElemenAccess
+    virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException){ return uno::Type(); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException ) { return sal_True; }
+
+};
+
 /******************************************************************************
  *
  ******************************************************************************/
@@ -207,7 +392,10 @@
     { "com.sun.star.chart2.data.DataProvider",                SW_SERVICE_CHART2_DATA_PROVIDER },
     { "com.sun.star.text.Fieldmark",                          SW_SERVICE_TYPE_FIELDMARK },
     { "com.sun.star.text.FormFieldmark",                      SW_SERVICE_TYPE_FORMFIELDMARK },
     { "com.sun.star.text.InContentMetadata",                  SW_SERVICE_TYPE_META },
+    { "ooo.vba.VBAObjectModuleObjectProvider",                SW_SERVICE_VBAOBJECTPROVIDER },
+    { "ooo.vba.VBACodeNameProvider",                          SW_SERVICE_VBACODENAMEPROVIDER },
+    { "ooo.vba.VBAProjectNameProvider",                       SW_SERVICE_VBAPROJECTNAMEPROVIDER },
 
     // case-correct versions of the service names (see #i67811)
     { CSS_TEXT_TEXTFIELD_DATE_TIME,                   SW_SERVICE_FIELDTYPE_DATETIME },
@@ -387,6 +575,30 @@
             xRet =  (cppu::OWeakObject*)pFieldmark;
         }
         break;
+		case  SW_SERVICE_VBAOBJECTPROVIDER :
+		{
+			SwVbaObjectForCodeNameProvider* pObjProv = new SwVbaObjectForCodeNameProvider( pDoc->GetDocShell() );
+			xRet =  (cppu::OWeakObject*)pObjProv;
+		}
+		break;
+		case  SW_SERVICE_VBACODENAMEPROVIDER :
+		{
+			SwVbaCodeNameProvider* pObjProv = new SwVbaCodeNameProvider( pDoc->GetDocShell() );
+			xRet =  (cppu::OWeakObject*)pObjProv;
+		}
+		break;
+		case  SW_SERVICE_VBAPROJECTNAMEPROVIDER :
+		{
+                        uno::Reference< container::XNameContainer > xProjProv = pDoc->GetVBATemplateToProjectCache();
+                        if ( !xProjProv.is() )
+                        {
+			    xProjProv = new SwVbaProjectNameProvider( pDoc->GetDocShell() );
+                            pDoc->SetVBATemplateToProjectCache( xProjProv );
+                        }
+			//xRet =  (cppu::OWeakObject*)xProjProv;
+			xRet = xProjProv;
+		}
+		break;
         case  SW_SERVICE_TYPE_FOOTNOTE :
             xRet =  (cppu::OWeakObject*)new SwXFootnote(sal_False);
         break;
Index: sw/source/core/unocore/unoprnms.cxx
===================================================================
--- sw/source/core/unocore/unoprnms.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/core/unocore/unoprnms.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -779,8 +779,10 @@
 /* 0734 CHAR_OVERLINE_COLOR */         {MAP_CHAR_LEN("CharOverlineColor")},
 /* 0735 CHAR_OVERLINE_HAS_COLOR */     {MAP_CHAR_LEN("CharOverlineHasColor")},
 /* 0736 UNO_NAME_OUTLINE_LEVEL */       {MAP_CHAR_LEN("OutlineLevel")},//#outline level,add<-zhaojianwei Outlinelevel
 /* 0737 UNO_NAME_DESCRIPTION */         {MAP_CHAR_LEN("Description")},
 /* 0738 UNO_NAME_META */        {MAP_CHAR_LEN("InContentMetadata")},
+/* 0739 UNO_NAME_IS_TEMPLATE */       {MAP_CHAR_LEN("IsTemplate")},
+/* 0740 UNO_NAME_VBA_DOCOBJ */       {MAP_CHAR_LEN("ThisVBADocObj")},
 };
 
 const SwPropNameLen& SwGetPropName( USHORT nId )
Index: sw/source/core/unocore/unomap.cxx
===================================================================
--- sw/source/core/unocore/unomap.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/core/unocore/unomap.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1591,11 +1591,13 @@
 					{ SW_PROP_NMID(UNO_NAME_CHAR_LOCALE), RES_CHRATR_LANGUAGE ,   CPPU_E2T(CPPUTYPE_LOCALE), PropertyAttribute::MAYBEVOID,  MID_LANG_LOCALE },
 					{ SW_PROP_NMID(UNO_NAME_CHARACTER_COUNT), WID_DOC_CHAR_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
                     { SW_PROP_NMID(UNO_NAME_DIALOG_LIBRARIES), WID_DOC_DIALOG_LIBRARIES,  CPPU_E2T(CPPUTYPE_REFLIBCONTAINER), PropertyAttribute::READONLY, 0},
+                    { SW_PROP_NMID(UNO_NAME_VBA_DOCOBJ), WID_DOC_VBA_DOCOBJ,  CPPU_E2T(CPPUTYPE_PROPERTYVALUE), PropertyAttribute::READONLY, 0},
 					{ SW_PROP_NMID(UNO_NAME_INDEX_AUTO_MARK_FILE_U_R_L), WID_DOC_AUTO_MARK_URL, CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
 					{ SW_PROP_NMID(UNO_NAME_PARAGRAPH_COUNT), WID_DOC_PARA_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
 					{ SW_PROP_NMID(UNO_NAME_RECORD_CHANGES), WID_DOC_CHANGES_RECORD,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
 					{ SW_PROP_NMID(UNO_NAME_SHOW_CHANGES), WID_DOC_CHANGES_SHOW,		CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
 					{ SW_PROP_NMID(UNO_NAME_WORD_COUNT), WID_DOC_WORD_COUNT,			CPPU_E2T(CPPUTYPE_INT32),	PropertyAttribute::READONLY,   0},
+					{ SW_PROP_NMID(UNO_NAME_IS_TEMPLATE), WID_DOC_ISTEMPLATEID,			CPPU_E2T(CPPUTYPE_BOOLEAN),	PropertyAttribute::READONLY,   0},
 					{ SW_PROP_NMID(UNO_NAME_WORD_SEPARATOR), WID_DOC_WORD_SEPARATOR,		CPPU_E2T(CPPUTYPE_OUSTRING),	PROPERTY_NONE,   0},
 					{ SW_PROP_NMID(UNO_NAME_HIDE_FIELD_TIPS), WID_DOC_HIDE_TIPS, 			CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE,   0},
 					{ SW_PROP_NMID(UNO_NAME_REDLINE_DISPLAY_TYPE), WID_DOC_REDLINE_DISPLAY, 	CPPU_E2T(CPPUTYPE_INT16),	PROPERTY_NONE,   0},
Index: sw/source/ui/app/docsh.cxx
===================================================================
--- sw/source/ui/app/docsh.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/ui/app/docsh.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -495,16 +495,6 @@
             xDocSh->DoClose();
 		}
 
-        if( pDoc->ContainsMSVBasic() )
-        {
-            //TODO/MBA: it looks as that this code can be removed!
-            //SvxImportMSVBasic aTmp( *this, pIo->GetStorage() );
-            //aTmp.SaveOrDelMSVBAStorage( FALSE, aEmptyStr );
-            if( SvtFilterOptions::Get()->IsLoadWordBasicStorage() )
-                nVBWarning = SvxImportMSVBasic::
-                                GetSaveWarningOfMSVBAStorage( *this );
-            pDoc->SetContainsMSVBasic( FALSE );
-        }
 
 		// TabellenBox Edit beenden!
 		if( pWrtShell )
Index: sw/source/ui/uno/unotxdoc.cxx
===================================================================
--- sw/source/ui/uno/unotxdoc.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/source/ui/uno/unotxdoc.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -166,6 +166,7 @@
 #define SW_CREATE_MARKER_TABLE          0x06
 #define SW_CREATE_DRAW_DEFAULTS         0x07
 
+#include <comphelper/processfactory.hxx> 
 
 /******************************************************************************
  *
@@ -220,6 +221,12 @@
     {
             return sal::static_int_cast< sal_Int64 >( reinterpret_cast< sal_IntPtr >( this ));
     }
+    if( rId.getLength() == 16
+        && 0 == rtl_compareMemory( SfxObjectShell::getUnoTunnelId().getConstArray(),
+										rId.getConstArray(), 16 ) )
+    {
+        return sal::static_int_cast<sal_Int64>(reinterpret_cast<sal_IntPtr>(pDocShell ));
+    }
 
 	sal_Int64 nRet = SfxBaseModel::getSomething( rId );
 	if ( nRet )
@@ -366,6 +373,9 @@
     pxXRedlines(0),
     m_pHiddenViewFrame(0)
 {
+    uno::Reference< document::XDocumentProperties > xWriterProps( ::comphelper::getProcessServiceFactory()->createInstance( DEFINE_CONST_UNICODE("com.sun.star.writer.DocumentProperties") ), uno::UNO_QUERY_THROW);
+
+    SfxBaseModel::setDocumentProperties( xWriterProps );
 }
 /*-- 18.12.98 11:53:00---------------------------------------------------
 
@@ -2145,6 +2155,9 @@
 	Any aAny;
     switch(pEntry->nWID)
 	{
+		case WID_DOC_ISTEMPLATEID    :
+			aAny <<= pDocShell->IsTemplate();
+			break;
 		case  WID_DOC_CHAR_COUNT     :
 		case  WID_DOC_PARA_COUNT     :
 		case  WID_DOC_WORD_COUNT     :
@@ -2253,6 +2266,14 @@
         case WID_DOC_DIALOG_LIBRARIES:
             aAny <<= pDocShell->GetDialogContainer();
         break;
+        case WID_DOC_VBA_DOCOBJ:
+        {
+            beans::PropertyValue aProp;
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ThisWordDoc") );
+            aProp.Value <<= pDocShell->GetModel();
+            aAny <<= aProp;
+        }
+        break;
         case WID_DOC_RUNTIME_UID:
             aAny <<= getRuntimeUID();
         break;
@@ -2902,6 +2923,7 @@
 {
 	::vos::OGuard aGuard(Application::GetSolarMutex());
 
+
     // possible canonical values for nScriptTypes
     // any bit wise combination is allowed
     const sal_Int16 nLatin   = 0x001;
Index: sw/source/ui/vba/vbaselection.cxx
===================================================================
--- sw/source/ui/vba/vbaselection.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaselection.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,682 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaselection.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbarange.hxx"
+#include "vbafind.hxx"
+#include "wordvbahelper.hxx"
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/XTextTableCursor.hpp>
+#include <com/sun/star/text/ControlCharacter.hpp>
+#include <com/sun/star/table/XCell.hpp>
+#include <ooo/vba/word/WdUnits.hpp>
+#include <ooo/vba/word/WdMovementType.hpp>
+#include <ooo/vba/word/WdGoToItem.hpp>
+#include <ooo/vba/word/WdGoToDirection.hpp>
+#include <ooo/vba/word/XBookmark.hpp>
+#include <ooo/vba/word/XApplication.hpp>
+#include <com/sun/star/text/XPageCursor.hpp>
+#include "unotbl.hxx"
+#include "unocoll.hxx"
+#include "vbatable.hxx"
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/view/XViewCursor.hpp>
+#include <ooo/vba/word/WdInformation.hpp>
+#include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+#include "vbainformationhelper.hxx"
+#include "vbafield.hxx"
+#include "vbaheaderfooter.hxx"
+#include "vbaheaderfooterhelper.hxx"
+#include <vbahelper/vbashaperange.hxx>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaSelection::SwVbaSelection( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& rModel ) throw ( uno::RuntimeException ) : SwVbaSelection_BASE( rParent, rContext ), mxModel( rModel )
+{
+    mxTextViewCursor = word::getXTextViewCursor( mxModel );
+}
+
+SwVbaSelection::~SwVbaSelection()
+{
+}
+
+uno::Reference< text::XTextRange > SwVbaSelection::GetSelectedRange() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< lang::XServiceInfo > xServiceInfo( mxModel->getCurrentSelection(), uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextRanges") ) ) ) 
+    {
+        uno::Reference< container::XIndexAccess > xTextRanges( xServiceInfo, uno::UNO_QUERY_THROW );
+        if( xTextRanges->getCount() > 0 )
+        {
+            // if there are multipul selection, just return the last selected Range.
+            xTextRange.set( xTextRanges->getByIndex( xTextRanges->getCount()-1 ), uno::UNO_QUERY_THROW );
+        }
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+    return xTextRange;
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaSelection::getRange() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xTextRange = GetSelectedRange();
+    uno::Reference< text::XTextDocument > xDocument( mxModel, uno::UNO_QUERY_THROW );
+    return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, xDocument, xTextRange->getStart(), xTextRange->getEnd(), mxTextViewCursor->getText() ) );
+}
+
+rtl::OUString SAL_CALL
+SwVbaSelection::getText() throw ( uno::RuntimeException )
+{
+    return getRange()->getText();
+}
+
+void SAL_CALL
+SwVbaSelection::setText( const rtl::OUString& rText ) throw ( uno::RuntimeException )
+{
+    getRange()->setText( rText );
+}
+
+void SAL_CALL
+SwVbaSelection::TypeText( const rtl::OUString& rText ) throw ( uno::RuntimeException )
+{
+    // FIXME: handle the property Options.ReplaceSelection, the default value is TRUE
+    setText( rText );
+}
+
+void SAL_CALL
+SwVbaSelection::HomeKey( const uno::Any& _unit, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdLine;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+    _unit >>= nUnit;
+    _extend >>= nExtend;
+
+    switch( nUnit )
+    {
+        case word::WdUnits::wdStory:
+        {
+            // go to the begin of the document
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfDoc"));
+            dispatchRequests( mxModel,url );
+            // If something is selected, it needs to go twice
+            dispatchRequests( mxModel,url );
+            break;
+        }
+        case word::WdUnits::wdLine:
+        {
+            // go to the begin of the Line
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToStartOfLine"));
+            dispatchRequests( mxModel,url );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
+
+void SAL_CALL
+SwVbaSelection::EndKey( const uno::Any& _unit, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdLine;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+    _unit >>= nUnit;
+    _extend >>= nExtend;
+
+    switch( nUnit )
+    {
+        case word::WdUnits::wdStory:
+        {
+            // go to the end of the document
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfDoc"));
+            dispatchRequests( mxModel,url );
+            // If something is selected, it needs to go twice
+            dispatchRequests( mxModel,url );
+            break;
+        }
+        case word::WdUnits::wdLine:
+        {
+            // go to the end of the Line
+            rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:GoToEndOfLine"));
+            dispatchRequests( mxModel,url );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+}
+
+void SAL_CALL
+SwVbaSelection::Delete( const uno::Any& /*_unit*/, const uno::Any& /*_count*/ ) throw ( uno::RuntimeException )
+{
+    // FIXME: handle the arguments: _unit and _count 
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Delete"));
+    dispatchRequests( mxModel,url );
+}
+
+void SwVbaSelection::NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( mxTextViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextTable > xTextTable;
+    uno::Reference< table::XCell > xCell;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextTable;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Cell") ) ) >>= xCell;
+    if( !xTextTable.is() || !xCell.is() )
+    {
+        DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+        return;
+    }
+    uno::Reference< beans::XPropertySet > xCellProps( xCell, uno::UNO_QUERY_THROW );
+    rtl::OUString aCellName;
+    xCellProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CellName") ) ) >>= aCellName;
+    uno::Reference< text::XTextTableCursor > xTextTableCursor = xTextTable->createCursorByCellName( aCellName );
+    // move the table cursor 
+    switch( eDirection )
+    {
+        case MOVE_LEFT:
+        {
+            xTextTableCursor->goLeft( nCount, sal_False );
+            break;
+        }
+        case MOVE_RIGHT:
+        {
+            xTextTableCursor->goRight( nCount, sal_False );
+            break;
+        }
+        case MOVE_UP:
+        {
+            xTextTableCursor->goUp( nCount, sal_False );
+            break;
+        }
+        case MOVE_DOWN:
+        {
+            xTextTableCursor->goDown( nCount, sal_False );
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+            return;
+        }
+    }
+    // move the view cursor
+    xCell = xTextTable->getCellByName( xTextTableCursor->getRangeName() );
+    mxTextViewCursor->gotoRange( uno::Reference< text::XTextRange >( xCell, uno::UNO_QUERY_THROW ), sal_False );
+}
+
+void SAL_CALL
+SwVbaSelection::MoveRight( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+    
+    if( nCount < 0 )
+    {
+        // TODO: call MoveLeft;
+        MoveLeft( _unit, uno::makeAny( -nCount ), _extend );
+        return;
+    }
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdCell:
+        {
+            if(  nExtend == word::WdMovementType::wdExtend )
+            {
+                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+                return;
+            }
+            NextCell( nCount, MOVE_RIGHT );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+
+}
+
+void SAL_CALL
+SwVbaSelection::MoveLeft( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+    
+    if( nCount < 0 )
+    {
+        MoveRight( _unit, uno::makeAny( -nCount ), _extend );
+        return;
+    }
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdCell:
+        {
+            if(  nExtend == word::WdMovementType::wdExtend )
+            {
+                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+                return;
+            }
+            NextCell( nCount, MOVE_LEFT );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+
+}
+
+void SAL_CALL
+SwVbaSelection::MoveDown( const uno::Any& _unit, const uno::Any& _count, const uno::Any& _extend ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nUnit = word::WdUnits::wdCharacter;
+    sal_Int32 nCount = 1;
+    sal_Int32 nExtend = word::WdMovementType::wdMove;
+
+    if( _unit.hasValue() )
+        _unit >>= nUnit;
+    if( _count.hasValue() )
+        _count >>= nCount;
+    if( _extend.hasValue() )
+        _extend >>= nExtend;
+    
+    if( nCount == 0 )
+        return;
+    
+    if( nCount < 0 )
+    {
+        // TODO: call MoveLeft;
+        //MoveUp( _unit, uno::makeAny( -nCount ), _extend );
+        return;
+    }
+    
+    switch( nUnit )
+    {
+        case word::WdUnits::wdLine:
+        {
+            uno::Reference< view::XViewCursor > xViewCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            sal_Bool bExpand = ( nExtend == word::WdMovementType::wdMove ) ? sal_False : sal_True;
+            xViewCursor->goDown( nCount, bExpand );
+            break;
+        }
+        default:
+        {
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+            break;
+        }
+    }
+
+}
+
+void SAL_CALL
+SwVbaSelection::TypeParagraph() throw ( uno::RuntimeException )
+{
+    // #FIXME: if the selection is an entire paragraph, it's replaced 
+    // by the new paragraph
+    sal_Bool isCollapsed = mxTextViewCursor->isCollapsed();
+    InsertParagraph();
+    if( isCollapsed )
+        mxTextViewCursor->collapseToStart();
+}
+
+void SAL_CALL
+SwVbaSelection::InsertParagraph() throw ( uno::RuntimeException )
+{
+    // #FIME: the selection should include the new paragraph.
+    getRange()->InsertParagraph();
+}
+
+void SAL_CALL
+SwVbaSelection::InsertParagraphBefore() throw ( uno::RuntimeException )
+{
+    getRange()->InsertParagraphBefore();
+}
+
+void SAL_CALL
+SwVbaSelection::InsertParagraphAfter() throw ( uno::RuntimeException )
+{
+    getRange()->InsertParagraphAfter();
+}
+
+uno::Reference< word::XParagraphFormat > SAL_CALL
+SwVbaSelection::getParagraphFormat() throw ( uno::RuntimeException )
+{
+    return getRange()->getParagraphFormat();
+}
+
+void SAL_CALL
+SwVbaSelection::setParagraphFormat( const uno::Reference< word::XParagraphFormat >& rParagraphFormat ) throw ( uno::RuntimeException )
+{
+    return getRange()->setParagraphFormat( rParagraphFormat );
+}
+
+uno::Reference< word::XFind > SAL_CALL 
+SwVbaSelection::getFind() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xTextRange = GetSelectedRange();
+    return uno::Reference< word::XFind >( new SwVbaFind( this, mxContext, mxModel, xTextRange ) );
+}
+
+uno::Reference< word::XStyle > SAL_CALL
+SwVbaSelection::getStyle() throw ( uno::RuntimeException )
+{
+    return getRange()->getStyle();
+}
+
+void SAL_CALL
+SwVbaSelection::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+{
+    return getRange()->setStyle( rStyle );
+}
+
+uno::Reference< word::XFont > SAL_CALL
+SwVbaSelection::getFont() throw ( uno::RuntimeException )
+{
+    return getRange()->getFont();
+}
+
+void SAL_CALL
+SwVbaSelection::TypeBackspace() throw ( uno::RuntimeException )
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:SwBackspace"));
+    dispatchRequests( mxModel,url );
+}
+
+uno::Reference< word::XRange > SAL_CALL SwVbaSelection::GoTo( const uno::Any& _what, const uno::Any& _which, const uno::Any& _count, const uno::Any& _name ) throw (uno::RuntimeException)
+{
+    sal_Int32 nWhat;
+    if( ( _what >>= nWhat ) != sal_True )
+         DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+    switch( nWhat )
+    {
+        case word::WdGoToItem::wdGoToBookmark:
+        {
+            rtl::OUString sName;
+            uno::Reference< word::XApplication > xApplication( Application(), uno::UNO_QUERY_THROW );
+            uno::Reference< word::XBookmark > xBookmark( xApplication->getActiveDocument()->Bookmarks(_name), uno::UNO_QUERY_THROW );
+            xBookmark->Select();
+            //return uno::Reference< word::XRange >( xBookmark->Range(), uno::UNO_QUERY_THROW );
+            break;
+        }
+        case word::WdGoToItem::wdGoToPage:
+        {
+            uno::Reference< text::XPageCursor > xPageCursor( mxTextViewCursor, uno::UNO_QUERY_THROW );
+            sal_Int32 nCurrPage = xPageCursor->getPage();
+            sal_Int32 nLastPage = word::getPageCount( mxModel );
+            sal_Int32 nCount = 0;
+            if( _count.hasValue() )
+                _count >>= nCount;
+            sal_Int32 nWhich = 0;
+            if( _which.hasValue() )
+                _which >>= nWhich;
+             sal_Int32 nPage = 0;
+             switch( nWhich )
+             {
+                case word::WdGoToDirection::wdGoToLast:
+                {
+                    nPage = nLastPage;
+                    break;
+                }
+                case word::WdGoToDirection::wdGoToNext:
+                {
+                    nPage = nCurrPage + 1;
+                    break;
+                }
+                case word::WdGoToDirection::wdGoToPrevious:
+                {
+                    nPage = nCurrPage - 1;
+                    break;
+                }
+                default:
+                {
+                    nPage = nCount;
+                }
+             }
+             if( nPage <= 0 )
+                nPage = 1;
+             if( nPage > nLastPage )
+                nPage = nLastPage;
+             xPageCursor->jumpToPage( ( sal_Int16 )( nPage ) );
+             break;
+        }
+        case word::WdGoToItem::wdGoToSection:
+        {
+            // TODO: implement Section object
+        }
+        default:
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+    return getRange();
+}
+
+::sal_Int32 SAL_CALL SwVbaSelection::getLanguageID() throw (uno::RuntimeException)
+{
+    return getRange()->getLanguageID();
+}
+
+void SAL_CALL SwVbaSelection::setLanguageID( ::sal_Int32 _languageid ) throw (uno::RuntimeException)
+{
+    getRange()->setLanguageID( _languageid );
+}
+
+uno::Any SAL_CALL SwVbaSelection::Information( sal_Int32 _type ) throw (uno::RuntimeException)
+{
+    uno::Any result;
+    //uno::Reference< view::XSelectionSupplier > xSel( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    //uno::Any aSelectedObject = xSel->getSelection();
+    switch( _type )
+    {
+        case word::WdInformation::wdActiveEndPageNumber:
+        {
+            result = uno::makeAny( SwVbaInformationHelper::handleWdActiveEndPageNumber( mxTextViewCursor ) );
+            break;
+        }
+        case word::WdInformation::wdNumberOfPagesInDocument:
+        {
+            result = uno::makeAny( SwVbaInformationHelper::handleWdNumberOfPagesInDocument( mxModel ) );
+            break;
+        }
+        case word::WdInformation::wdVerticalPositionRelativeToPage:
+        {
+            result = uno::makeAny( SwVbaInformationHelper::handleWdVerticalPositionRelativeToPage( mxModel, mxTextViewCursor ) );
+            break;
+        }
+        default:
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+    // This method fails to restore the previouse selection
+    //xSel->select( aSelectedObject );
+    return result;
+}
+
+void SAL_CALL SwVbaSelection::InsertBreak( const uno::Any& _breakType ) throw (uno::RuntimeException)
+{
+    getRange()->InsertBreak( _breakType );
+}
+
+uno::Any SAL_CALL
+SwVbaSelection::Tables( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    // Hacky implementation due to missing api ( and lack of knowledge )
+    // we can only support a selection that is a single table
+    if ( !aIndex.hasValue() ) // currently we can't support multiple tables in a selection
+       throw uno::RuntimeException(); 
+    // if the current selection is a XTextTableCursor and the index is 1 then we can service this request, otherwise we just have to throw
+    uno::Reference< text::XTextTableCursor > xTextTableCursor( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+
+    if ( !xTextTableCursor.is() )
+       throw uno::RuntimeException(); 
+
+    sal_Int32 nIndex = 0;
+    aIndex >>= nIndex;
+
+    uno::Any aRet;
+
+    if ( nIndex != 1 )
+       throw uno::RuntimeException(); 
+    SwXTextTableCursor* pTTCursor = dynamic_cast< SwXTextTableCursor* >( xTextTableCursor.get() );
+    if ( pTTCursor )
+    {
+        SwFrmFmt* pFmt = pTTCursor->GetFrmFmt();
+        rtl::OUString sTableName;
+        if ( pFmt )
+        {
+            uno::Reference< text::XTextTable > xTbl = SwXTextTables::GetObject(*pFmt);
+            uno::Reference< css::text::XTextDocument > xTextDoc( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< word::XTable > xVBATbl = new SwVbaTable( mxParent, mxContext, xTextDoc, xTbl ); 
+            aRet <<= xVBATbl;
+        }
+    }
+    return aRet;
+    
+}
+
+uno::Any SAL_CALL
+SwVbaSelection::Fields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaFields( mxParent, mxContext, mxModel ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Reference< word::XHeaderFooter > SAL_CALL
+SwVbaSelection::getHeaderFooter() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XText > xCurrentText = word::getXTextViewCursor( mxModel )->getText();
+    if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFooter( mxModel, xCurrentText ) )
+    {
+        uno::Reference< beans::XPropertySet > xPageStyleProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
+        sal_Int32 nIndex = word::WdHeaderFooterIndex::wdHeaderFooterPrimary;
+        sal_Bool isHeader = HeaderFooterHelper::isHeader( mxModel, xCurrentText );
+        if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+            nIndex = word::WdHeaderFooterIndex::wdHeaderFooterEvenPages;
+        else if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) || HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+            nIndex = word::WdHeaderFooterIndex::wdHeaderFooterFirstPage;
+        
+        return uno::Reference< word::XHeaderFooter >( new SwVbaHeaderFooter( this, mxContext, mxModel, xPageStyleProps, isHeader, nIndex ) );
+
+    }
+    return uno::Reference< word::XHeaderFooter >();
+}
+
+uno::Any SAL_CALL
+SwVbaSelection::ShapeRange( ) throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XShapes > xShapes( mxModel->getCurrentSelection(), uno::UNO_QUERY );
+
+    if ( !xShapes.is() )
+       throw uno::RuntimeException(); 
+
+    uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< drawing::XDrawPage > xDrawPage = xDrawPageSupplier->getDrawPage();
+    uno::Reference< container::XIndexAccess > xShapesAccess( xShapes, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< msforms::XShapeRange >( new ScVbaShapeRange( this, mxContext, xShapesAccess, xDrawPage, mxModel ) ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaSelection::getStart() throw (uno::RuntimeException)
+{
+    return getRange()->getStart();
+}
+
+void SAL_CALL SwVbaSelection::setStart( ::sal_Int32 _start ) throw (uno::RuntimeException)
+{
+    getRange()->setStart( _start );
+}
+::sal_Int32 SAL_CALL SwVbaSelection::getEnd() throw (uno::RuntimeException)
+{
+    return getRange()->getEnd();
+}
+
+void SAL_CALL SwVbaSelection::setEnd( ::sal_Int32 _end ) throw (uno::RuntimeException)
+{
+    getRange()->setEnd( _end );
+}
+
+rtl::OUString& 
+SwVbaSelection::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaSelection") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaSelection::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Selection" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbatable.cxx
===================================================================
--- sw/source/ui/vba/vbatable.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatable.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,97 @@
+#include "vbatable.hxx"
+#include "vbarange.hxx"
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/XTextTablesSupplier.hpp>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include "vbaborders.hxx"
+#include "vbapalette.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTable::SwVbaTable(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const  uno::Reference< css::text::XTextTable >& xTextTable) throw ( uno::RuntimeException ) : SwVbaTable_BASE( rParent, rContext ), mxTextDocument( rDocument )
+{
+    mxTextTable.set( xTextTable, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaTable::Range(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    return new SwVbaRange( mxParent, mxContext, mxTextDocument, mxTextTable->getAnchor() );
+}
+
+void SAL_CALL 
+SwVbaTable::Select(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );    
+    uno::Reference< frame::XController > xController = xModel->getCurrentController();
+
+    uno::Reference< text::XTextViewCursorSupplier > xViewCursorSupplier( xController, uno::UNO_QUERY_THROW );
+    uno::Reference< view::XSelectionSupplier > xSelectionSupplier( xController, uno::UNO_QUERY_THROW );
+
+    // set the view cursor to the start of the table.
+    xSelectionSupplier->select( uno::makeAny( mxTextTable ) );
+
+    // go to the end of the table and span the view
+    uno::Reference< text::XTextViewCursor > xCursor = xViewCursorSupplier->getViewCursor();
+    xCursor->gotoEnd(sal_True);
+    
+}
+
+void SAL_CALL 
+SwVbaTable::Delete(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< table::XTableRows > xRows( mxTextTable->getRows() );
+    xRows->removeByIndex( 0, xRows->getCount() );
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaTable::ConvertToText( const uno::Any& /*Separator*/, const uno::Any& /*NestedTables*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // #FIXME the helper api uses the dreaded dispatch mechanism, holding off 
+    // implementation while I look for alternative solution
+    throw uno::RuntimeException();
+}
+
+rtl::OUString SAL_CALL
+SwVbaTable::getName() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XNamed > xNamed( mxTextTable, uno::UNO_QUERY_THROW );
+    return xNamed->getName();
+}
+
+uno::Any SAL_CALL
+SwVbaTable::Borders( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< table::XCellRange > aCellRange( mxTextTable, uno::UNO_QUERY_THROW );
+    VbaPalette aPalette;
+    uno::Reference< XCollection > xCol( new SwVbaBorders( this, mxContext, aCellRange, aPalette ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaTable::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTable") );
+    return sImplName;    
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaTable::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Table" ) );
+    }
+    return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbasections.cxx
===================================================================
--- sw/source/ui/vba/vbasections.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasections.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbasections.hxx"
+#include "vbasection.hxx"
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+#include <docsh.hxx>
+#include <doc.hxx>
+#include "wordvbahelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > SectionEnumeration_BASE;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > SectionCollectionHelper_Base;
+typedef std::vector< uno::Reference< beans::XPropertySet > > XSectionVec;
+
+class SectionEnumeration : public SectionEnumeration_BASE
+{
+    XSectionVec mxSections;
+    XSectionVec::iterator mIt;
+
+public:
+	SectionEnumeration( const XSectionVec& rVec ) : mxSections( rVec ), mIt( mxSections.begin() ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( mIt != mxSections.end() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( hasMoreElements() )
+			return uno::makeAny( *mIt++ );
+		throw container::NoSuchElementException();
+	}
+};
+
+// here I regard pagestyle as section
+class SectionCollectionHelper : public SectionCollectionHelper_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    XSectionVec mxSections;
+
+public:
+    SectionCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( mxModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
+        uno::Reference< container::XIndexAccess > xPageStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles") ) ), uno::UNO_QUERY_THROW );
+        sal_Int32 nCount = xPageStyles->getCount();
+        for( sal_Int32 index = 0; index < nCount; ++index )
+        {
+            uno::Reference< style::XStyle > xStyle( xPageStyles->getByIndex( index ), uno::UNO_QUERY_THROW );
+            // only the pagestyles in using are considered
+            if( xStyle->isInUse( ) )
+            {
+                uno::Reference< beans::XPropertySet > xPageProps( xStyle, uno::UNO_QUERY_THROW );
+                mxSections.push_back( xPageProps );
+            }
+        }
+    }
+
+    ~SectionCollectionHelper(){}
+
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxSections.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( Index < 0 || Index >= getCount() )    
+            throw css::lang::IndexOutOfBoundsException();
+
+        uno::Reference< beans::XPropertySet > xPageProps( mxSections[ Index ], uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< word::XSection >( new SwVbaSection( mxParent,  mxContext, mxModel, xPageProps ) ) );    
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XSection::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+    // XEnumerationAccess
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new SectionEnumeration( mxSections );
+    }
+};
+
+class SectionsEnumWrapper : public EnumerationHelperImpl
+{
+	uno::Reference< frame::XModel > mxModel;
+	uno::WeakReference< XHelperInterface > mxParent;
+public:
+	SectionsEnumWrapper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), mxModel( xModel ), mxParent( xParent ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< beans::XPropertySet > xPageProps( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< word::XSection > ( new SwVbaSection( mxParent, m_xContext, mxModel, xPageProps ) ) );
+	}
+};
+
+SwVbaSections::SwVbaSections( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ): SwVbaSections_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new SectionCollectionHelper( xParent, xContext, xModel ) ) ),  mxModel( xModel )
+{
+}
+
+uno::Any SAL_CALL
+SwVbaSections::PageSetup( ) throw (uno::RuntimeException)
+{
+    if( m_xIndexAccess->getCount() )
+    {
+        // check if the first section is our want
+        uno::Reference< word::XSection > xSection( m_xIndexAccess->getByIndex( 0 ), uno::UNO_QUERY_THROW );
+        return xSection->PageSetup();
+    }
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("There is no section") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL
+SwVbaSections::getElementType() throw (uno::RuntimeException)
+{
+	return word::XSection::static_type(0);
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL
+SwVbaSections::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return new SectionsEnumWrapper( this, mxContext, xEnumAccess->createEnumeration(), mxModel );
+}
+
+uno::Any
+SwVbaSections::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaSections::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaSections") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaSections::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Sections") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbastyles.hxx
===================================================================
--- sw/source/ui/vba/vbastyles.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbastyles.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbastyles.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_STYLES_HXX
+#define SW_VBA_STYLES_HXX
+
+#include <ooo/vba/word/XStyles.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XStyles > SwVbaStyles_BASE;
+class SwVbaStyles: public SwVbaStyles_BASE
+{
+	css::uno::Reference< css::frame::XModel > mxModel;
+	css::uno::Reference< css::lang::XMultiServiceFactory > mxMSF;
+public:
+	SwVbaStyles( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel ) throw ( css::script::BasicErrorException );
+
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& Index2 ) throw (css::uno::RuntimeException);
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);	
+	virtual css::uno::Any createCollectionObject(const css::uno::Any&);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif 
Index: sw/source/ui/vba/vbafield.hxx
===================================================================
--- sw/source/ui/vba/vbafield.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafield.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile:  $
+ * $Revision:  $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FIELD_HXX
+#define SW_VBA_FIELD_HXX
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextField.hpp>
+#include <ooo/vba/word/XField.hpp>
+#include <ooo/vba/word/XFields.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XField > SwVbaField_BASE;
+
+class SwVbaField : public SwVbaField_BASE
+{
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XTextField > mxTextField;
+public:
+    SwVbaField( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const css::uno::Reference< css::text::XTextField >& xTextField) throw ( css::uno::RuntimeException);
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
+};
+
+// *** SwVbaFields ***********************************************
+
+typedef CollTestImplHelper< ov::word::XFields > SwVbaFields_BASE;
+
+class SwVbaFields : public SwVbaFields_BASE
+{
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::lang::XMultiServiceFactory > mxMSF;
+private:
+    css::uno::Reference< css::text::XTextField > Create_Field_FileName( const rtl::OUString _text ) throw (css::uno::RuntimeException);
+
+public:
+    SwVbaFields( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+    // XFields
+    virtual css::uno::Reference< ::ooo::vba::word::XField > SAL_CALL Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range, const css::uno::Any& Type, const css::uno::Any& Text, const css::uno::Any& PreserveFormatting ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL Update() throw (css::uno::RuntimeException);
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    // ScVbaCollectionBaseImpl      
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();    
+};
+
+#endif
Index: sw/source/ui/vba/vbainformationhelper.hxx
===================================================================
--- sw/source/ui/vba/vbainformationhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbainformationhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,46 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_INFORMATIONHELPER_HXX
+#define SW_VBA_INFORMATIONHELPER_HXX
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+class SwVbaInformationHelper
+{
+public:
+    static sal_Int32 handleWdActiveEndPageNumber( const css::uno::Reference< css::text::XTextViewCursor >& xTVCursor ) throw( css::uno::RuntimeException );
+    static sal_Int32 handleWdNumberOfPagesInDocument( const css::uno::Reference< css::frame::XModel >& xModel ) throw( css::uno::RuntimeException );
+    static double handleWdVerticalPositionRelativeToPage( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextViewCursor >& xTVCursor ) throw( css::uno::RuntimeException );
+    //static double verticalPositionRelativeToPageBoundary( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextViewCursor >& xTVCursor, const css::uno::Reference< css::beans::XPropertySet >& xStyleProps ) throw( css::uno::RuntimeException );
+
+};
+#endif /* SW_VBA_INFORMATIONHELPER_HXX */
Index: sw/source/ui/vba/vbaoptions.cxx
===================================================================
--- sw/source/ui/vba/vbaoptions.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaoptions.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,287 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microoptionss, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaoptions.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <ooo/vba/word/WdDefaultFilePath.hpp>
+#include <ooo/vba/word/WdLineStyle.hpp>
+#include <ooo/vba/word/WdLineWidth.hpp>
+#include <ooo/vba/word/WdColorIndex.hpp>
+#include <com/sun/star/util/XStringSubstitution.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <osl/file.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaOptions::SwVbaOptions( uno::Reference<uno::XComponentContext >& xContext ) throw ( uno::RuntimeException ) : SwVbaOptions_BASE( uno::Reference< XHelperInterface >(), xContext )
+{
+    mxFactory.set( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+}
+
+SwVbaOptions::~SwVbaOptions()
+{
+}
+
+uno::Any SAL_CALL 
+SwVbaOptions::DefaultFilePath( sal_Int32 _path ) throw ( uno::RuntimeException )
+{
+    switch( _path )
+    {
+        case word::WdDefaultFilePath::wdDocumentsPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Work") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdPicturesPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Gallery") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdUserTemplatesPath:
+        case word::WdDefaultFilePath::wdWorkgroupTemplatesPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Template") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdStartupPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Addin") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdUserOptionsPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UserConfig") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdToolsPath:
+        case word::WdDefaultFilePath::wdProgramPath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Module") );
+            break;
+        }
+        case word::WdDefaultFilePath::wdTempFilePath:
+        {
+            msDefaultFilePath = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Temp") );
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception( SbERR_NOT_IMPLEMENTED, rtl::OUString() ); 
+            break;
+        }
+    }
+    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( this ) ) );
+}
+
+void SwVbaOptions::setValueEvent( const uno::Any& value )
+{
+    rtl::OUString sNewPath;
+    value >>= sNewPath;
+    rtl::OUString sNewPathUrl;
+    ::osl::File::getFileURLFromSystemPath( sNewPath, sNewPathUrl );
+    uno::Reference< beans::XPropertySet > xPathSettings( mxFactory->createInstance( rtl::OUString::createFromAscii("com.sun.star.util.PathSettings") ), uno::UNO_QUERY_THROW );
+    rtl::OUString sOldPathUrl;
+    xPathSettings->getPropertyValue( msDefaultFilePath ) >>= sOldPathUrl;
+    // path could be a multipath, Microsoft doesn't support this feature in Word currently
+    // only the last path is from interest.
+    sal_Int32 nIndex = sOldPathUrl.lastIndexOf( sal_Unicode(';') );
+    if( nIndex != -1 )
+    {
+        sNewPathUrl = sOldPathUrl.copy( 0, nIndex + 1 ).concat( sNewPathUrl );
+    }
+    xPathSettings->setPropertyValue( msDefaultFilePath, uno::makeAny( sNewPathUrl ) );
+}
+
+uno::Any SwVbaOptions::getValueEvent()
+{
+    uno::Reference< beans::XPropertySet > xPathSettings( mxFactory->createInstance( rtl::OUString::createFromAscii("com.sun.star.util.PathSettings") ), uno::UNO_QUERY_THROW );
+    rtl::OUString sPathUrl;
+    xPathSettings->getPropertyValue( msDefaultFilePath ) >>= sPathUrl;
+    // path could be a multipath, Microsoft doesn't support this feature in Word currently
+    // only the last path is from interest.
+    sal_Int32 nIndex = sPathUrl.lastIndexOf( sal_Unicode(';') );
+    if( nIndex != -1 )
+    {
+        sPathUrl = sPathUrl.copy( nIndex + 1 );
+    }
+    rtl::OUString sPath;
+    ::osl::File::getSystemPathFromFileURL( sPathUrl, sPath );
+    return uno::makeAny( sPath );
+}
+
+sal_Int32 SAL_CALL SwVbaOptions::getDefaultBorderLineStyle() throw (uno::RuntimeException)
+{
+    return word::WdLineStyle::wdLineStyleSingle;
+}
+
+void SAL_CALL SwVbaOptions::setDefaultBorderLineStyle( ::sal_Int32 /*_defaultborderlinestyle*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+sal_Int32 SAL_CALL SwVbaOptions::getDefaultBorderLineWidth() throw (uno::RuntimeException)
+{
+    return word::WdLineWidth::wdLineWidth050pt;
+}
+
+void SAL_CALL SwVbaOptions::setDefaultBorderLineWidth( ::sal_Int32 /*_defaultborderlinewidth*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+sal_Int32 SAL_CALL SwVbaOptions::getDefaultBorderColorIndex() throw (uno::RuntimeException)
+{
+    return word::WdColorIndex::wdAuto;
+}
+
+void SAL_CALL SwVbaOptions::setDefaultBorderColorIndex( ::sal_Int32 /*_defaultbordercolorindex*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getReplaceSelection() throw (uno::RuntimeException)
+{
+    return sal_True;
+}
+
+void SAL_CALL SwVbaOptions::setReplaceSelection( ::sal_Bool /*_replaceselection*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getMapPaperSize() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setMapPaperSize( ::sal_Bool /*_mappapersize*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatAsYouTypeApplyHeadings() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatAsYouTypeApplyHeadings( ::sal_Bool /*_autoformatasyoutypeapplyheadings*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatAsYouTypeApplyBulletedLists() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatAsYouTypeApplyBulletedLists( ::sal_Bool /*_autoformatasyoutypeapplybulletedlists*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatAsYouTypeApplyNumberedLists() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatAsYouTypeApplyNumberedLists( ::sal_Bool /*_autoformatasyoutypeapplynumberedlists*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatAsYouTypeFormatListItemBeginning() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatAsYouTypeFormatListItemBeginning( ::sal_Bool /*_autoformatasyoutypeformatlistitembeginning*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatAsYouTypeDefineStyles() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatAsYouTypeDefineStyles( ::sal_Bool /*_autoformatasyoutypedefinestyles*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatApplyHeadings() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatApplyHeadings( ::sal_Bool /*_autoformatapplyheadings*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatApplyLists() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatApplyLists( ::sal_Bool /*_autoformatapplylists*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL SwVbaOptions::getAutoFormatApplyBulletedLists() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaOptions::setAutoFormatApplyBulletedLists( ::sal_Bool /*_autoformatapplybulletedlists*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+
+rtl::OUString& 
+SwVbaOptions::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaOptions") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaOptions::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Options" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbarangehelper.cxx
===================================================================
--- sw/source/ui/vba/vbarangehelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbarangehelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,174 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarangehelper.hxx"
+#include <com/sun/star/text/ControlCharacter.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+/**
+ * get a range in a xText by creating
+ * a cursor that iterates over the text. If the iterating cursor is 
+ * equal to the desired position, the range equivalent is returned.
+ * Some special cases are tables that are inside of the text, because the
+ * position has to be adjusted.
+ * @param xText a text where a range position is searched
+ * @param position a position inside o the text
+ * @return a range for the postion; null is returned if no range can be
+ * constructed.
+ */
+uno::Reference< text::XTextRange > SwVbaRangeHelper::getRangeByPosition( const uno::Reference< text::XText >& rText, sal_Int32 _position ) throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xRange;
+    if( rText.is() )
+    {
+        sal_Int32 nPos = 0;
+        uno::Reference< text::XTextCursor > xCursor = rText->createTextCursor();
+        xCursor->collapseToStart();
+        sal_Bool bCanGo = sal_True;
+        while( !xRange.is() && bCanGo )
+        {
+            if( _position == nPos )
+            {
+                xRange = xCursor->getStart();
+            }    
+            else
+            {
+                bCanGo = xCursor->goRight( 1, sal_False );
+                nPos++;
+            }
+        }
+    }
+    return xRange;
+}
+
+
+void SwVbaRangeHelper::insertString( uno::Reference< text::XTextRange >& rTextRange, uno::Reference< text::XText >& rText, const rtl::OUString& rStr, sal_Bool _bAbsorb ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nlastIndex = 0;
+    sal_Int32 nIndex = 0;
+    uno::Reference< text::XTextRange > xRange = rTextRange;
+    
+    while(( nIndex = rStr.indexOf('\n', nlastIndex)) >= 0  )
+    {
+        xRange = xRange->getEnd();
+        if( nlastIndex < ( nIndex - 1 ) )
+        {
+            rText->insertString( xRange, rStr.copy( nlastIndex, ( nIndex - 1 - nlastIndex ) ), _bAbsorb );
+            xRange = xRange->getEnd();
+        }
+
+        rText->insertControlCharacter( xRange, text::ControlCharacter::PARAGRAPH_BREAK, _bAbsorb );
+        nlastIndex = nIndex + 1;
+    }
+
+    if( nlastIndex < rStr.getLength() )
+    {
+        xRange = xRange->getEnd();
+
+        rtl::OUString aWatt = rStr.copy( nlastIndex );
+        rText->insertString( xRange, aWatt, _bAbsorb );
+    }
+}
+
+uno::Reference< text::XTextCursor > SwVbaRangeHelper::initCursor( const uno::Reference< text::XTextRange >& rTextRange, const uno::Reference< text::XText >& rText ) throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextCursor > xTextCursor;
+    sal_Bool bGotTextCursor = sal_False;
+
+    try
+    {
+        xTextCursor = rText->createTextCursorByRange( rTextRange );
+        bGotTextCursor = sal_True;
+    }
+    catch (uno::Exception& e)
+    {
+        DebugHelper::exception(e);
+    }
+
+    if( !bGotTextCursor )
+    {
+        try
+        {
+            uno::Reference< text::XText > xText = rTextRange->getText();
+            xTextCursor = xText->createTextCursor();
+            bGotTextCursor = sal_True;
+        }
+        catch( uno::Exception& e )
+        {
+            DebugHelper::exception(e);
+        }
+    }
+
+    if( !bGotTextCursor )
+    {
+        try
+        {
+            xTextCursor = rText->createTextCursor();
+            bGotTextCursor = sal_True;
+        }
+        catch( uno::Exception& e )
+        {
+            DebugHelper::exception(e);
+        }
+    }
+    return xTextCursor;
+}
+
+sal_Int32 SwVbaRangeHelper::getPosition( const uno::Reference< text::XText >& rText, const uno::Reference< text::XTextRange >& rTextRange ) throw ( uno::RuntimeException )
+{
+    sal_Int32 nPosition = -1;
+    if( rText.is() && rTextRange.is() )
+    {
+        nPosition = 0;
+        uno::Reference< text::XTextCursor > xCursor = rText->createTextCursor();
+        xCursor->collapseToStart();
+        uno::Reference< text::XTextRangeCompare > xCompare( rText, uno::UNO_QUERY_THROW );
+        // compareValue is 0 if the ranges are equal
+        sal_Int32 nCompareValue = xCompare->compareRegionStarts( xCursor->getStart(), rTextRange );
+        sal_Bool canGo = sal_True;
+
+        while( nCompareValue !=0 && canGo )
+        {
+            canGo = xCursor->goRight( 1, sal_False );
+            nCompareValue = xCompare->compareRegionStarts( xCursor->getStart(), rTextRange );
+            nPosition++;
+        }
+
+        // check fails: no correct position found
+        if( !canGo && nCompareValue != 0 )
+        {
+            nPosition = -1;
+        }
+    }
+
+    return nPosition;
+}
Index: sw/source/ui/vba/vbareplacement.cxx
===================================================================
--- sw/source/ui/vba/vbareplacement.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbareplacement.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbareplacement.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaReplacement::SwVbaReplacement( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< util::XPropertyReplace >& xPropertyReplace ) throw ( uno::RuntimeException ) :
+    SwVbaReplacement_BASE( rParent, rContext ), mxPropertyReplace( xPropertyReplace )
+{
+}
+
+SwVbaReplacement::~SwVbaReplacement()
+{
+}
+
+::rtl::OUString SAL_CALL SwVbaReplacement::getText() throw (uno::RuntimeException)
+{
+    return mxPropertyReplace->getReplaceString();
+}
+
+void SAL_CALL SwVbaReplacement::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setReplaceString( _text );
+}
+
+rtl::OUString& 
+SwVbaReplacement::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaReplacement") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaReplacement::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Replacement" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbastyle.cxx
===================================================================
--- sw/source/ui/vba/vbastyle.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbastyle.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,152 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile:
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbastyle.hxx"
+#include <ooo/vba/word/WdStyleType.hpp>
+#include <com/sun/star/lang/Locale.hpp>
+#include <i18npool/mslangid.hxx>
+#include "vbafont.hxx"
+#include "vbapalette.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+
+SwVbaStyle::SwVbaStyle( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertySet >& _xPropertySet ) throw ( script::BasicErrorException, uno::RuntimeException ) : SwVbaStyle_BASE( xParent, xContext ) , mxStyleProps( _xPropertySet )
+{
+    mxStyle.set( _xPropertySet, uno::UNO_QUERY_THROW );
+}
+
+void SAL_CALL 
+SwVbaStyle::setName( const ::rtl::OUString& Name ) throw (uno::RuntimeException)
+{
+	mxStyle->setName(Name);
+}
+
+::rtl::OUString SAL_CALL 
+SwVbaStyle::getName() throw (uno::RuntimeException)
+{
+	return mxStyle->getName();
+}
+
+sal_Int32 SwVbaStyle::getLanguageID( const uno::Reference< beans::XPropertySet >& xTCProps ) throw (uno::RuntimeException)
+{
+    lang::Locale aLocale;
+    xTCProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharLocale") ) ) >>= aLocale;
+    return MsLangId::convertLocaleToLanguage( aLocale );
+}
+
+void SwVbaStyle::setLanguageID( const uno::Reference< beans::XPropertySet >& xTCProps, sal_Int32 _languageid ) throw (uno::RuntimeException)
+{
+    lang::Locale aLocale = MsLangId::convertLanguageToLocale( static_cast<LanguageType>(_languageid) );
+    xTCProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharLocale") ), uno::makeAny( aLocale ) ) ;
+}
+
+::sal_Int32 SAL_CALL SwVbaStyle::getLanguageID() throw (uno::RuntimeException)
+{
+    return getLanguageID( mxStyleProps );
+}
+
+void SAL_CALL SwVbaStyle::setLanguageID( ::sal_Int32 _languageid ) throw (uno::RuntimeException)
+{
+    setLanguageID( mxStyleProps, _languageid );
+}
+
+::sal_Int32 SAL_CALL SwVbaStyle::getType() throw (uno::RuntimeException)
+{
+    sal_Int32 nType = word::WdStyleType::wdStyleTypeParagraph;
+    uno::Reference< lang::XServiceInfo > xServiceInfo( mxStyle, uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.ParagraphStyle") ) ) )
+        nType = word::WdStyleType::wdStyleTypeParagraph;
+    else if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.style.CharacterStyle") ) ) )    
+        nType = word::WdStyleType::wdStyleTypeCharacter;
+    else // if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.NumberingStyle") ) ) )    
+        nType = word::WdStyleType::wdStyleTypeList;
+    return nType;
+}
+
+uno::Reference< word::XFont > SAL_CALL
+SwVbaStyle::getFont() throw ( uno::RuntimeException )
+{
+    VbaPalette aColors;
+    return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), mxStyleProps );
+}
+
+void SwVbaStyle::setStyle( const uno::Reference< beans::XPropertySet >& xTCProps, const uno::Reference< ooo::vba::word::XStyle >& xStyle )throw (uno::RuntimeException)
+{
+    rtl::OUString aStyleType = getOOoStyleTypeFromMSWord( xStyle->getType() );
+    xTCProps->setPropertyValue( aStyleType, uno::makeAny( xStyle->getName() ) );
+}
+
+rtl::OUString SwVbaStyle::getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType )
+{
+    rtl::OUString aStyleType;
+    switch( _wdStyleType )
+    {
+        case word::WdStyleType::wdStyleTypeParagraph:
+        case word::WdStyleType::wdStyleTypeTable:
+        {
+            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaStyleName") );
+            break;
+        }
+        case word::WdStyleType::wdStyleTypeCharacter:
+        {
+            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharStyleName") );
+            break;
+        }
+        case word::WdStyleType::wdStyleTypeList:
+        {
+            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyleName") );
+            break;
+        }
+        default:
+            DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
+    }
+    return aStyleType;
+}
+
+rtl::OUString&
+SwVbaStyle::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaStyle") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaStyle::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.XStyle" ) );
+    }
+    return aServiceNames;
+}
Index: sw/source/ui/vba/vbadocumentproperties.hxx
===================================================================
--- sw/source/ui/vba/vbadocumentproperties.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocumentproperties.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadocument.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_DOCUMENTPROPERTIES_HXX
+#define SW_VBA_DOCUMENTPROPERTIES_HXX
+
+#include <ooo/vba/XDocumentProperties.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <hash_map>
+
+typedef CollTestImplHelper< ov::XDocumentProperties > SwVbaDocumentproperties_BASE;
+
+class SwVbaBuiltinDocumentProperties : public SwVbaDocumentproperties_BASE
+{
+protected:
+    css::uno::Reference< css::frame::XModel > m_xModel;
+public:
+    SwVbaBuiltinDocumentProperties( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xDocument );
+
+    // XDocumentProperties
+    virtual css::uno::Reference< ::ooo::vba::XDocumentProperty > SAL_CALL Add( const ::rtl::OUString& Name, ::sal_Bool LinkToContent, ::sal_Int8 Type, const css::uno::Any& Value, const css::uno::Any& LinkSource ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    // ScVbaCollectionBaseImpl      
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+class SwVbaCustomDocumentProperties : public SwVbaBuiltinDocumentProperties
+{
+public:
+    SwVbaCustomDocumentProperties( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xDocument );
+// XDocumentProperties
+    virtual css::uno::Reference< ::ooo::vba::XDocumentProperty > SAL_CALL Add( const ::rtl::OUString& Name, ::sal_Bool LinkToContent, ::sal_Int8 Type, const css::uno::Any& Value, const css::uno::Any& LinkSource ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+};
+
+#endif /* SW_VBA_DOCUMENTPROPERTY_HXX */
Index: sw/source/ui/vba/vbapalette.hxx
===================================================================
--- sw/source/ui/vba/vbapalette.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapalette.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,15 @@
+#ifndef VBAPALETTE_HXX
+#define VBAPALETTE_HXX
+#include <vbahelper/vbahelper.hxx>
+
+class VbaPalette
+{
+        css::uno::Reference< css::container::XIndexAccess > mxPalette;
+public:
+        VbaPalette();
+        // if no palette available e.g. because the document doesn't have a 
+        // palette defined then a default palette will be returned.
+        css::uno::Reference< css::container::XIndexAccess > getPalette() const;
+};
+
+#endif
Index: sw/source/ui/vba/vbabookmark.cxx
===================================================================
--- sw/source/ui/vba/vbabookmark.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbabookmark.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbabookmark.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include "vbarange.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaBookmark::SwVbaBookmark( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,
+    const css::uno::Reference< frame::XModel >& rModel, const rtl::OUString& rName ) throw ( css::uno::RuntimeException ) :
+    SwVbaBookmark_BASE( rParent, rContext ), mxModel( rModel ), maName( rName ), mbValid( sal_True )
+{
+    uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( mxModel, uno::UNO_QUERY_THROW );
+    mxBookmark.set( xBookmarksSupplier->getBookmarks()->getByName( maName ), uno::UNO_QUERY_THROW );
+}
+
+SwVbaBookmark::~SwVbaBookmark()
+{
+}
+
+void SwVbaBookmark::checkVality() throw ( uno::RuntimeException )
+{
+    if( !mbValid )
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("The bookmark is not valid" ) ), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL SwVbaBookmark::Delete() throw ( uno::RuntimeException )
+{
+    checkVality();
+    uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
+    xTextDocument->getText()->removeTextContent( mxBookmark );
+    mbValid = sal_False;
+}
+
+void SAL_CALL SwVbaBookmark::Select() throw ( uno::RuntimeException )
+{
+    checkVality();
+    uno::Reference< text::XTextViewCursorSupplier > xViewCursorSupplier( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xViewCursorSupplier->getViewCursor()->gotoRange( mxBookmark->getAnchor(),sal_False );
+}
+
+rtl::OUString SAL_CALL SwVbaBookmark::getName() throw ( uno::RuntimeException )
+{
+    return maName;
+}
+
+void SAL_CALL SwVbaBookmark::setName( const rtl::OUString& _name ) throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XNamed > xNamed( mxBookmark, uno::UNO_QUERY_THROW );
+    xNamed->setName( _name );
+}
+
+uno::Any SAL_CALL SwVbaBookmark::Range() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextContent > xTextContent( mxBookmark, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTextRange( xTextContent->getAnchor(), uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XRange>(  new SwVbaRange( this, mxContext, xTextDocument, xTextRange->getStart(), xTextRange->getEnd(), xTextRange->getText() ) ) );
+}
+
+rtl::OUString& 
+SwVbaBookmark::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBookmark") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaBookmark::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Bookmark" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbadocuments.hxx
===================================================================
--- sw/source/ui/vba/vbadocuments.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocuments.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_DOCUMENTS_HXX
+#define SW_VBA_DOCUMENTS_HXX
+
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XDocuments.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <vbahelper/vbadocumentsbase.hxx>
+#include "wordvbahelper.hxx"
+
+
+typedef cppu::ImplInheritanceHelper1< VbaDocumentsBase, ov::word::XDocuments > SwVbaDocuments_BASE;
+
+class SwVbaDocuments : public SwVbaDocuments_BASE
+{
+public:
+	SwVbaDocuments( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext );
+	virtual ~SwVbaDocuments() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaDocuments_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	// Methods
+    virtual css::uno::Any SAL_CALL Add( const css::uno::Any& Template, const css::uno::Any& NewTemplate, const css::uno::Any& DocumentType, const css::uno::Any& Visible ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& ConfirmConversions, const css::uno::Any& ReadOnly, const css::uno::Any& AddToRecentFiles, const css::uno::Any& PasswordDocument, const css::uno::Any& PasswordTemplate, const css::uno::Any& Revert, const css::uno::Any& WritePasswordDocument, const css::uno::Any& WritePasswordTemplate, const css::uno::Any& Format, const css::uno::Any& Encoding, const css::uno::Any& Visible, const css::uno::Any& OpenAndRepair, const css::uno::Any& DocumentDirection, const css::uno::Any& NoEncodingDialog, const css::uno::Any& XMLTransform ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Close( const css::uno::Any& SaveChanges, const css::uno::Any& OriginalFormat, const css::uno::Any& RouteDocument ) throw (css::uno::RuntimeException);
+
+	// VbaDocumentsBase / XDocumentsBase (to avoid warning C4266 for hiding function on wntmsci)
+	virtual css::uno::Any SAL_CALL Add() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& ReadOnly, const css::uno::Sequence< css::beans::PropertyValue >& rProps ) throw (css::uno::RuntimeException);
+};
+
+#endif /* SW_VBA_DOCUMENTS_HXX */
Index: sw/source/ui/vba/vbaaddins.hxx
===================================================================
--- sw/source/ui/vba/vbaaddins.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaaddins.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ADDINS_HXX
+#define SW_VBA_ADDINS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XAddins.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XAddins > SwVbaAddins_BASE;
+
+class SwVbaAddins : public SwVbaAddins_BASE
+{
+public:
+	SwVbaAddins( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaAddins() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaAddins_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_ADDINS_HXX */
Index: sw/source/ui/vba/vbaheaderfooterhelper.cxx
===================================================================
--- sw/source/ui/vba/vbaheaderfooterhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaheaderfooterhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,178 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaheaderfooterhelper.hxx"
+#include "wordvbahelper.hxx"
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+#define FIRST_PAGE 1;
+
+// Class HeaderFooterHelper 
+
+sal_Bool HeaderFooterHelper::isHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
+    
+    sal_Bool isOn = sal_False;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isOn;
+    if( !isOn )
+        return sal_False;
+
+    sal_Bool isShared = sal_False;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared"))) >>= isShared;
+
+    rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderText") );
+    if( !isShared )
+    {
+        if( 0 == xPageCursor->getPage() % 2 )
+        {
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextLeft") );
+        }
+        else
+        {
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderTextRight") );
+        }
+    }
+    
+    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    //FIXME: can not compare in this way?
+    return ( xText == xCurrentText );
+}
+
+sal_Bool HeaderFooterHelper::isFirstPageHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isHeader( xModel, xCurrentText ) )
+    {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+        // FIXME: getPage allways returns 1
+        sal_Int32 nPage = xPageCursor->getPage();
+        return nPage == FIRST_PAGE;
+    }
+    return sal_False;
+}
+
+sal_Bool HeaderFooterHelper::isEvenPagesHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isHeader( xModel, xCurrentText ) )
+    {
+        uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
+        sal_Bool isShared = sal_False;
+        xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared"))) >>= isShared;
+        if( !isShared )
+        {
+            uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+            return ( 0 == xPageCursor->getPage() % 2 );
+        }    
+    }
+    return sal_False;
+}
+
+sal_Bool HeaderFooterHelper::isFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
+    
+    sal_Bool isOn = sal_False;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn"))) >>= isOn;
+    if( !isOn )
+        return sal_False;
+
+    sal_Bool isShared = sal_False;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared"))) >>= isShared;
+
+    rtl::OUString aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterText") );
+    if( !isShared )
+    {
+        if( 0 == xPageCursor->getPage() % 2 )
+        {
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextLeft") );
+        }
+        else
+        {
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterTextRight") );
+        }
+    }
+    
+    uno::Reference< text::XText > xText( xStyleProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+
+    return ( xText == xCurrentText );
+}
+
+sal_Bool HeaderFooterHelper::isFirstPageFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isFooter( xModel, xCurrentText ) )
+    {
+        uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+        sal_Int32 nPage = xPageCursor->getPage();
+        return nPage == FIRST_PAGE;
+    }
+    return sal_False;
+}
+
+sal_Bool HeaderFooterHelper::isEvenPagesFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isFooter( xModel, xCurrentText ) )
+    {
+        uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
+        sal_Bool isShared = sal_False;
+        xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared"))) >>= isShared;
+        if( !isShared )
+        {
+            uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+            return ( 0 == xPageCursor->getPage() % 2 );
+        }    
+    }
+    return sal_False;
+}
+
+sal_Bool HeaderFooterHelper::isPrimaryHeader( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isHeader( xModel, xCurrentText ) )
+    {
+        return( !( isFirstPageHeader( xModel, xCurrentText ) && isEvenPagesHeader( xModel, xCurrentText ) ) );
+    }
+    return sal_False;
+}
+
+sal_Bool HeaderFooterHelper::isPrimaryFooter( const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XText >& xCurrentText ) throw (uno::RuntimeException)
+{
+    if( isHeader( xModel, xCurrentText ) )
+    {
+        return( !( isFirstPageFooter( xModel, xCurrentText ) && isEvenPagesFooter( xModel, xCurrentText ) ) );
+    }
+    return sal_False;
+}
Index: sw/source/ui/vba/vbasection.hxx
===================================================================
--- sw/source/ui/vba/vbasection.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasection.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_SECTION_HXX
+#define SW_VBA_SECTION_HXX
+
+#include <ooo/vba/word/XSection.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XSection > SwVbaSection_BASE;
+
+class SwVbaSection : public SwVbaSection_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxPageProps;
+
+public:
+	SwVbaSection( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaSection();
+
+    // Attributes
+    virtual ::sal_Bool SAL_CALL getProtectedForForms() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setProtectedForForms( ::sal_Bool _protectedforforms ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual css::uno::Any SAL_CALL Headers(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Footers(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL PageSetup(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_SECTION_HXX */
Index: sw/source/ui/vba/vbaparagraph.hxx
===================================================================
--- sw/source/ui/vba/vbaparagraph.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaparagraph.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PARAGRAPH_HXX
+#define SW_VBA_PARAGRAPH_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XParagraphs.hpp>
+#include <ooo/vba/word/XParagraph.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XParagraph > SwVbaParagraph_BASE;
+
+class SwVbaParagraph : public SwVbaParagraph_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XTextRange > mxTextRange;
+
+public:
+	SwVbaParagraph( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& xDocument, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaParagraph();
+
+    // XParagraph
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL getRange() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+
+/* class SwVbaParagraphs */
+typedef CollTestImplHelper< ooo::vba::word::XParagraphs > SwVbaParagraphs_BASE;
+
+class SwVbaParagraphs : public SwVbaParagraphs_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+public:
+	SwVbaParagraphs( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::text::XTextDocument >& xDocument ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaParagraphs() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaParagraphs_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_PARAGRAPH_HXX */
Index: sw/source/ui/vba/vbatables.cxx
===================================================================
--- sw/source/ui/vba/vbatables.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatables.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,131 @@
+#include "vbatables.hxx"
+#include "vbatable.hxx"
+#include "vbarange.hxx"
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/text/XTextTablesSupplier.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <comphelper/componentcontext.hxx>
+
+using namespace ::ooo::vba;
+using namespace css;
+
+uno::Reference< container::XIndexAccess > lcl_getTables( const uno::Reference< frame::XModel >& xDoc )
+{
+    uno::Reference< container::XIndexAccess > xTables;
+    uno::Reference< text::XTextTablesSupplier > xSupp( xDoc, uno::UNO_QUERY );
+    if ( xSupp.is() )
+        xTables.set( xSupp->getTextTables(), uno::UNO_QUERY_THROW );
+    return xTables;
+}
+
+uno::Any lcl_createTable( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xDocument, const uno::Any& aSource )
+{
+    uno::Reference< text::XTextTable > xTextTable( aSource, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextDocument > xTextDocument( xDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XTable > xTable( new SwVbaTable( xParent, xContext, xTextDocument, xTextTable ) );
+    return uno::makeAny( xTable );
+}
+
+typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumBase;
+
+class TableEnumerationImpl : public EnumBase
+{
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxDocument;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    sal_Int32 mnCurIndex;
+public:
+    TableEnumerationImpl(  const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : mxParent( xParent ), mxContext( xContext ), mxDocument( xDocument ), mxIndexAccess( xIndexAccess ), mnCurIndex(0)
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+    { 
+        return ( mnCurIndex < mxIndexAccess->getCount() );
+    }
+    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+        return lcl_createTable( mxParent, mxContext, mxDocument, mxIndexAccess->getByIndex( mnCurIndex++ ) );
+    }
+    
+};
+ 
+SwVbaTables::SwVbaTables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xDocument ) : SwVbaTables_BASE( xParent, xContext , lcl_getTables( xDocument ) ), mxDocument( xDocument )
+{
+}
+
+
+uno::Reference< word::XTable > SAL_CALL 
+SwVbaTables::Add( const uno::Reference< word::XRange >& Range, const uno::Any& NumRows, const uno::Any& NumColumns, const uno::Any& /*DefaultTableBehavior*/, const uno::Any& /*AutoFitBehavior*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    sal_Int32 nCols = 0;
+    sal_Int32 nRows = 0;
+    SwVbaRange* pVbaRange = dynamic_cast< SwVbaRange* >( Range.get() );
+    // Preconditions
+    if ( !( pVbaRange && ( NumRows >>= nRows ) && ( NumColumns >>= nCols ) ) )
+        throw uno::RuntimeException(); // #FIXME better exception??
+    if ( nCols <= 0 || nRows <= 0 ) 
+        throw uno::RuntimeException(); // #FIXME better exception??
+
+    uno::Reference< frame::XModel > xModel( pVbaRange->getDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< lang::XMultiServiceFactory > xMsf( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextRange > xTextRange = pVbaRange->getXTextRange();
+
+    uno::Reference< text::XTextTable > xTable;
+    xTable.set( xMsf->createInstance( rtl::OUString::createFromAscii("com.sun.star.text.TextTable") ), uno::UNO_QUERY_THROW );
+/*
+    comphelper::ComponentContext aCtx( xMsf );
+    if ( !aCtx.createComponent( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ), xTable ) );
+        throw uno::RuntimeException(); // #FIXME better exception??
+*/
+    xTable->initialize( nRows, nCols );
+    uno::Reference< text::XText > xText = xTextRange->getText();
+    uno::Reference< text::XTextContent > xContext( xTable, uno::UNO_QUERY_THROW );     
+    
+    xText->insertTextContent( xTextRange, xContext, true );
+    uno::Reference< word::XTable > xVBATable( new SwVbaTable( mxParent, mxContext,  pVbaRange->getDocument(), xTable ) );
+    return xVBATable;
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+SwVbaTables::createEnumeration() throw (uno::RuntimeException)
+{
+    return new TableEnumerationImpl( mxParent, mxContext, mxDocument, m_xIndexAccess );
+}
+
+// ScVbaCollectionBaseImpl      
+uno::Any 
+SwVbaTables::createCollectionObject( const uno::Any& aSource )
+{
+    return lcl_createTable( mxParent, mxContext, mxDocument, aSource );
+} 
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaTables::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTables") );
+    return sImplName;    
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+SwVbaTables::getElementType() throw (uno::RuntimeException)
+{
+    return  word::XTable::static_type(0); 
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaTables::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Tables" ) );
+    }
+    return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbawindow.hxx
===================================================================
--- sw/source/ui/vba/vbawindow.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbawindow.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbawindow.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_WINDOW_HXX
+#define SW_VBA_WINDOW_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/word/XWindow.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbawindowbase.hxx>
+
+typedef cppu::ImplInheritanceHelper1< VbaWindowBase, ov::word::XWindow > WindowImpl_BASE;
+
+class SwVbaWindow : public WindowImpl_BASE
+{		
+public:	
+	SwVbaWindow( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+    SwVbaWindow( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+
+
+    // Attributes
+    virtual css::uno::Any SAL_CALL getView() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setView( const css::uno::Any& _view ) throw (css::uno::RuntimeException);
+	// Methods
+	virtual void SAL_CALL Activate(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close( const css::uno::Any& SaveChanges, const css::uno::Any& RouteDocument ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Panes( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL ActivePane() throw (css::uno::RuntimeException);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //SW_VBA_WINDOW_HXX
Index: sw/source/ui/vba/vbaview.hxx
===================================================================
--- sw/source/ui/vba/vbaview.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaview.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_VIEW_HXX
+#define SW_VBA_VIEW_HXX
+
+#include <ooo/vba/word/XView.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XView > SwVbaView_BASE;
+
+class SwVbaView : public SwVbaView_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextViewCursor > mxViewCursor;
+    css::uno::Reference< css::beans::XPropertySet > mxViewSettings;
+
+    css::uno::Reference< css::text::XTextRange > getHFTextRange( sal_Int32 nType ) throw (css::uno::RuntimeException);
+    css::uno::Reference< css::text::XTextRange > getFirstObjectPosition( const css::uno::Reference< css::text::XText >& xText ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaView( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
+        const css::uno::Reference< css::frame::XModel >& rModel ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaView();
+
+   // XView
+    virtual ::sal_Int32 SAL_CALL getSeekView() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSeekView( ::sal_Int32 _seekview ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getSplitSpecial() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSplitSpecial( ::sal_Int32 _splitspecial ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getTableGridLines() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTableGridLines( ::sal_Bool _tablegridlines ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setType( ::sal_Int32 _type ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_VIEW_HXX */
Index: sw/source/ui/vba/vbawrapformat.cxx
===================================================================
--- sw/source/ui/vba/vbawrapformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbawrapformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,260 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbawrapformat.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbawrapformat.hxx"
+#include <ooo/vba/word/WdWrapSideType.hpp>
+#include <ooo/vba/word/WdWrapType.hpp>
+#include <com/sun/star/text/WrapTextMode.hpp>
+#include <vbahelper/vbahelper.hxx>
+#include <vbahelper/helperdecl.hxx>
+
+using namespace ooo::vba;
+using namespace com::sun::star;
+
+SwVbaWrapFormat::SwVbaWrapFormat( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape > xShape ) : SwVbaWrapFormat_BASE( xParent, xContext ), m_xShape( xShape ), mnWrapFormatType( 0 ), mnSide( word::WdWrapSideType::wdWrapBoth ) 
+{
+    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
+}
+
+SwVbaWrapFormat::SwVbaWrapFormat( uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& xContext ) : SwVbaWrapFormat_BASE( getXSomethingFromArgs< XHelperInterface >( aArgs, 0 ), xContext ), m_xShape( getXSomethingFromArgs< drawing::XShape >( aArgs, 1, false ) ), mnWrapFormatType( 0 ), mnSide( word::WdWrapSideType::wdWrapBoth )
+{
+    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
+}
+
+void SwVbaWrapFormat::makeWrap() throw (uno::RuntimeException)
+{
+    text::WrapTextMode eTextMode = text::WrapTextMode_NONE;
+    if( mnSide == word::WdWrapSideType::wdWrapLeft )
+    {
+        eTextMode = text::WrapTextMode_LEFT;
+    }
+    else if(  mnSide == word::WdWrapSideType::wdWrapRight )
+    {
+        eTextMode = text::WrapTextMode_RIGHT;
+    }
+    else if( mnSide == word::WdWrapSideType::wdWrapBoth ||
+            mnSide == word::WdWrapSideType::wdWrapLargest )
+    {
+        switch( mnWrapFormatType )
+        {
+            case word::WdWrapType::wdWrapNone:
+            case word::WdWrapType::wdWrapThrough:
+            {
+                eTextMode = text::WrapTextMode_THROUGHT;
+                break;
+            }
+            case word::WdWrapType::wdWrapInline:
+            case word::WdWrapType::wdWrapTopBottom:
+            {
+                eTextMode = text::WrapTextMode_NONE;
+                break;
+            }
+            case word::WdWrapType::wdWrapSquare:
+            {
+                eTextMode = text::WrapTextMode_PARALLEL;
+                m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SurroundContour") ), uno::makeAny( sal_False ) );
+                break;
+            }
+            case word::WdWrapType::wdWrapTight:
+            {
+                eTextMode = text::WrapTextMode_PARALLEL;
+                m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SurroundContour") ), uno::makeAny( sal_True ) );
+                break;
+            }
+            default:
+            {
+                DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+            }
+        }
+    }
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextWrap") ), uno::makeAny( eTextMode ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaWrapFormat::getType() throw (uno::RuntimeException)
+{
+    sal_Int32 nType = word::WdWrapType::wdWrapSquare;
+    text::WrapTextMode eTextMode;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextWrap") )) >>= eTextMode;
+    switch( eTextMode )
+    {
+        case text::WrapTextMode_NONE:
+        {
+            nType = word::WdWrapType::wdWrapTopBottom;
+            break;
+        }
+        case text::WrapTextMode_THROUGHT:
+        {
+            nType = word::WdWrapType::wdWrapNone;
+            break;
+        }
+        case text::WrapTextMode_PARALLEL:
+        {
+            sal_Bool bContour = sal_False;
+            m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SurroundContour") )) >>= bContour;
+            if( bContour )
+                nType = word::WdWrapType::wdWrapTight;
+            else    
+                nType = word::WdWrapType::wdWrapSquare;
+            break;
+        }
+        case text::WrapTextMode_DYNAMIC:
+        case text::WrapTextMode_LEFT:
+        case text::WrapTextMode_RIGHT:
+        {
+            nType = word::WdWrapType::wdWrapThrough;
+            break;
+        }
+        default:
+        {
+            nType = word::WdWrapType::wdWrapSquare;
+        }
+    }
+    return nType;
+}
+
+void SAL_CALL SwVbaWrapFormat::setType( ::sal_Int32 _type ) throw (uno::RuntimeException)
+{
+    mnWrapFormatType = _type;
+    makeWrap();
+}
+
+::sal_Int32 SAL_CALL SwVbaWrapFormat::getSide() throw (uno::RuntimeException)
+{
+    sal_Int32 nSide = word::WdWrapSideType::wdWrapBoth;
+    text::WrapTextMode eTextMode;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextWrap") )) >>= eTextMode;
+    switch( eTextMode )
+    {
+        case text::WrapTextMode_LEFT:
+        {
+            nSide = word::WdWrapSideType::wdWrapLeft;
+            break;
+        }
+        case text::WrapTextMode_RIGHT:
+        {
+            nSide = word::WdWrapSideType::wdWrapRight;
+            break;
+        }
+        default:
+        {
+            nSide = word::WdWrapSideType::wdWrapBoth;
+        }
+    }
+    return nSide;
+}
+
+void SAL_CALL SwVbaWrapFormat::setSide( ::sal_Int32 _side ) throw (uno::RuntimeException)
+{
+    mnSide = _side;
+    makeWrap();
+}
+
+float SwVbaWrapFormat::getDistance( const rtl::OUString& sName ) throw (uno::RuntimeException)
+{
+    sal_Int32 nDistance = 0;
+    m_xPropertySet->getPropertyValue( sName ) >>= nDistance;
+    return static_cast< float >( Millimeter::getInPoints( nDistance ) );
+}
+
+void SwVbaWrapFormat::setDistance( const rtl::OUString& sName, float _distance ) throw (uno::RuntimeException)
+{
+    sal_Int32 nDistance = Millimeter::getInHundredthsOfOneMillimeter( _distance );
+    m_xPropertySet->setPropertyValue( sName, uno::makeAny( nDistance ) );
+}
+
+float SAL_CALL SwVbaWrapFormat::getDistanceTop() throw (uno::RuntimeException)
+{
+    return getDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin") ) );
+}
+
+void SAL_CALL SwVbaWrapFormat::setDistanceTop( float _distancetop ) throw (uno::RuntimeException)
+{
+    setDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin") ), _distancetop );
+}
+
+float SAL_CALL SwVbaWrapFormat::getDistanceBottom() throw (uno::RuntimeException)
+{
+    return getDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin") ) );
+}
+
+void SAL_CALL SwVbaWrapFormat::setDistanceBottom( float _distancebottom ) throw (uno::RuntimeException)
+{
+    setDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin") ), _distancebottom );
+}
+
+float SAL_CALL SwVbaWrapFormat::getDistanceLeft() throw (uno::RuntimeException)
+{
+    return getDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ) );
+}
+
+void SAL_CALL SwVbaWrapFormat::setDistanceLeft( float _distanceleft ) throw (uno::RuntimeException)
+{
+    setDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ), _distanceleft );
+}
+
+float SAL_CALL SwVbaWrapFormat::getDistanceRight() throw (uno::RuntimeException)
+{
+    return getDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin") ) );
+}
+
+void SAL_CALL SwVbaWrapFormat::setDistanceRight( float _distanceright ) throw (uno::RuntimeException)
+{
+    setDistance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin") ), _distanceright );
+}
+
+rtl::OUString& 
+SwVbaWrapFormat::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaWrapFormat") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaWrapFormat::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.WrapFormat" ) );
+	}
+	return aServiceNames;
+}
+
+namespace wrapformat
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<SwVbaWrapFormat, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SwVbaWrapFormat",
+    "ooo.vba.word.WrapFormat" );
+}
+
+
Index: sw/source/ui/vba/vbapane.cxx
===================================================================
--- sw/source/ui/vba/vbapane.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapane.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbapane.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbaview.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaPane::SwVbaPane( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,
+    const uno::Reference< frame::XModel >& xModel ) throw ( uno::RuntimeException ) :
+    SwVbaPane_BASE( rParent, rContext ), mxModel( xModel )
+{
+}
+
+SwVbaPane::~SwVbaPane()
+{
+}
+
+uno::Any SAL_CALL
+SwVbaPane::View() throw ( css::uno::RuntimeException )
+{
+    return uno::makeAny( uno::Reference< word::XView >( new SwVbaView( this,  mxContext, mxModel ) ) );    
+}
+
+void SAL_CALL
+SwVbaPane::Close( ) throw ( css::uno::RuntimeException )
+{
+    rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CloseWin"));
+    dispatchRequests( mxModel,url );
+}
+
+rtl::OUString& 
+SwVbaPane::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaPane") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaPane::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Pane" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbadocument.hxx
===================================================================
--- sw/source/ui/vba/vbadocument.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocument.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadocument.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_DOCUMENT_HXX
+#define SW_VBA_DOCUMENT_HXX
+
+#include <ooo/vba/word/XDocument.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadocumentbase.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+
+typedef cppu::ImplInheritanceHelper1< VbaDocumentBase, ooo::vba::word::XDocument > SwVbaDocument_BASE;
+
+class SwVbaDocument : public SwVbaDocument_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+
+    void Initialize();
+    css::uno::Any getControlShape( const rtl::OUString& sName );
+    css::uno::Reference< css::container::XNameAccess > getFormControls();
+
+public:
+	SwVbaDocument( const css::uno::Reference< ooo::vba::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& m_xContext, css::uno::Reference< css::frame::XModel > xModel );
+	SwVbaDocument(  css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext );
+	virtual ~SwVbaDocument();
+
+    // XDocument
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL getContent() throw ( css::uno::RuntimeException );
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL Range( const css::uno::Any& rStart, const css::uno::Any& rEnd ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL BuiltInDocumentProperties( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL CustomDocumentProperties( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Bookmarks( const css::uno::Any& rIndex ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL Variables( const css::uno::Any& rIndex ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL getAttachedTemplate() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAttachedTemplate( const css::uno::Any& _attachedtemplate ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Paragraphs( const css::uno::Any& rIndex ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL Styles( const css::uno::Any& rIndex ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL Tables( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Fields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Shapes( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Sections( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL PageSetup() throw (css::uno::RuntimeException);
+	// XInvocation
+	virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual void SAL_CALL setValue( const ::rtl::OUString& aPropertyName, const css::uno::Any& aValue ) throw (css::beans::UnknownPropertyException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getValue( const ::rtl::OUString& aPropertyName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL hasMethod( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL hasProperty( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_DOCUMENT_HXX */
Index: sw/source/ui/vba/vbafind.hxx
===================================================================
--- sw/source/ui/vba/vbafind.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafind.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_FIND_HXX
+#define SW_VBA_FIND_HXX
+
+#include <ooo/vba/word/XFind.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/util/XReplaceable.hpp>
+#include <com/sun/star/util/XPropertyReplace.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextCursor.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XFind > SwVbaFind_BASE;
+
+class SwVbaFind : public SwVbaFind_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextRange > mxTextRange;
+    css::uno::Reference< css::util::XReplaceable > mxReplaceable;
+    css::uno::Reference< css::util::XPropertyReplace> mxPropertyReplace;
+    css::uno::Reference< css::text::XTextViewCursor> mxTVC;
+    css::uno::Reference< css::view::XSelectionSupplier> mxSelSupp;
+    sal_Bool mbReplace;
+    sal_Int32 mnReplaceType;
+    sal_Int32 mnWrap;
+
+private:
+    sal_Bool InRange( const css::uno::Reference< css::text::XTextRange >& xCurrentRange ) throw ( css::uno::RuntimeException );
+    sal_Bool InEqualRange( const css::uno::Reference< css::text::XTextRange >& xCurrentRange ) throw ( css::uno::RuntimeException );
+    void SetReplace( sal_Int32 type );
+    void SetReplaceWith( const rtl::OUString& rText ) throw ( css::uno::RuntimeException );
+    rtl::OUString GetReplaceWith() throw ( css::uno::RuntimeException );
+    rtl::OUString ReplaceWildcards( const rtl::OUString& rText ) throw ( css::uno::RuntimeException );
+    css::uno::Reference< css::text::XTextRange > FindOneElement() throw ( css::uno::RuntimeException );
+    sal_Bool SearchReplace() throw ( css::uno::RuntimeException );
+
+public:
+	SwVbaFind( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextRange >& xTextRange ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFind();
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getReplacement() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setReplacement( const css::uno::Any& _replacement ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getForward() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setForward( ::sal_Bool _forward ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getWrap() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWrap( ::sal_Int32 _wrap ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getFormat() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFormat( ::sal_Bool _format ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMatchCase() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchCase( ::sal_Bool _matchcase ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMatchWholeWord() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchWholeWord( ::sal_Bool _matchwholeword ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMatchWildcards() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchWildcards( ::sal_Bool _matchwildcards ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMatchSoundsLike() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchSoundsLike( ::sal_Bool _matchsoundslike ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMatchAllWordForms() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMatchAllWordForms( ::sal_Bool _matchallwordforms ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Any& _style ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual ::sal_Bool SAL_CALL Execute( const css::uno::Any& FindText, const css::uno::Any& MatchCase, const css::uno::Any& MatchWholeWord, const css::uno::Any& MatchWildcards, const css::uno::Any& MatchSoundsLike, const css::uno::Any& MatchAllWordForms, const css::uno::Any& Forward, const css::uno::Any& Wrap, const css::uno::Any& Format, const css::uno::Any& ReplaceWith, const css::uno::Any& Replace, const css::uno::Any& MatchKashida, const css::uno::Any& MatchDiacritics, const css::uno::Any& MatchAlefHamza, const css::uno::Any& MatchControl, const css::uno::Any& MatchPrefix, const css::uno::Any& MatchSuffix, const css::uno::Any& MatchPhrase, const css::uno::Any& IgnoreSpace, const css::uno::Any& IgnorePunct ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ClearFormatting(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_FIND_HXX */
Index: sw/source/ui/vba/makefile.mk
===================================================================
--- sw/source/ui/vba/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,111 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.6 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=sw
+TARGET=vbaswobj
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vba..."
+.ENDIF
+ 
+INCPRE=$(INCCOM)$/$(TARGET)
+CDEFS+=-DVBA_OOBUILD_HACK
+# ------------------------------------------------------------------
+
+SLOFILES= \
+		$(SLO)$/vbaglobals.obj \
+		$(SLO)$/vbaapplication.obj \
+		$(SLO)$/vbadocument.obj \
+		$(SLO)$/vbawindow.obj \
+		$(SLO)$/vbasystem.obj \
+		$(SLO)$/vbarangehelper.obj \
+		$(SLO)$/vbarange.obj \
+		$(SLO)$/vbabookmark.obj \
+		$(SLO)$/vbabookmarks.obj \
+		$(SLO)$/vbavariable.obj \
+		$(SLO)$/vbavariables.obj \
+		$(SLO)$/vbaview.obj \
+		$(SLO)$/wordvbahelper.obj \
+				$(SLO)$/service.obj \
+				$(SLO)$/vbadocumentproperties.obj \
+				$(SLO)$/vbapane.obj \
+				$(SLO)$/vbapanes.obj \
+				$(SLO)$/vbaoptions.obj \
+				$(SLO)$/vbaselection.obj \
+ 				$(SLO)$/vbatemplate.obj \
+				$(SLO)$/vbaparagraphformat.obj \
+				$(SLO)$/vbaautotextentry.obj \
+				$(SLO)$/vbaparagraph.obj \
+				$(SLO)$/vbafind.obj \
+				$(SLO)$/vbareplacement.obj \
+				$(SLO)$/vbastyle.obj \
+				$(SLO)$/vbastyles.obj \
+				$(SLO)$/vbafont.obj \
+				$(SLO)$/vbapalette.obj \
+				$(SLO)$/vbainformationhelper.obj \
+				$(SLO)$/vbatable.obj \
+				$(SLO)$/vbatables.obj \
+				$(SLO)$/vbafield.obj \
+				$(SLO)$/vbaborders.obj \
+				$(SLO)$/vbadocuments.obj \
+				$(SLO)$/vbaheaderfooter.obj \
+				$(SLO)$/vbaheaderfooterhelper.obj \
+				$(SLO)$/vbaaddin.obj \
+				$(SLO)$/vbaaddins.obj \
+				$(SLO)$/vbadialogs.obj \
+				$(SLO)$/vbadialog.obj \
+				$(SLO)$/vbawrapformat.obj \
+				$(SLO)$/vbapagesetup.obj \
+				$(SLO)$/vbasection.obj \
+				$(SLO)$/vbasections.obj \
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
Index: sw/source/ui/vba/vbavariable.hxx
===================================================================
--- sw/source/ui/vba/vbavariable.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbavariable.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_VARIABLE_HXX
+#define SW_VBA_VARIABLE_HXX
+
+#include <ooo/vba/word/XVariable.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/beans/XPropertyAccess.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XVariable > SwVbaVariable_BASE;
+
+class SwVbaVariable : public SwVbaVariable_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertyAccess > mxUserDefined;
+    rtl::OUString maName;
+
+public:
+	SwVbaVariable( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
+        const css::uno::Reference< css::beans::XPropertyAccess >& rUserDefined, const rtl::OUString& rName ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaVariable();
+
+   // XVariable
+    virtual rtl::OUString SAL_CALL getName() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setName( const rtl::OUString& ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL getValue() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setValue( const css::uno::Any& rValue ) throw ( css::uno::RuntimeException );
+    virtual sal_Int32 SAL_CALL getIndex() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_VARIABLE_HXX */
Index: sw/source/ui/vba/vbapagesetup.cxx
===================================================================
--- sw/source/ui/vba/vbapagesetup.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapagesetup.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,275 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbapagesetup.hxx"
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XPageCursor.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <ooo/vba/word/WdSectionStart.hpp>
+#include <ooo/vba/word/WdOrientation.hpp>
+#include "wordvbahelper.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+SwVbaPageSetup::SwVbaPageSetup(const uno::Reference< XHelperInterface >& xParent, 
+				const uno::Reference< uno::XComponentContext >& xContext,
+				const uno::Reference< frame::XModel >& xModel,
+                const uno::Reference< beans::XPropertySet >& xProps ) throw (uno::RuntimeException):
+	   	SwVbaPageSetup_BASE( xParent, xContext )
+{
+    mxModel.set( xModel, uno::UNO_QUERY_THROW );
+    mxPageProps.set( xProps, uno::UNO_QUERY_THROW );
+    mnOrientPortrait = word::WdOrientation::wdOrientPortrait;
+    mnOrientLandscape = word::WdOrientation::wdOrientLandscape;
+}		
+
+double SAL_CALL SwVbaPageSetup::getGutter() throw (uno::RuntimeException)
+{
+    // not support in Writer
+    return 0;
+}
+
+void SAL_CALL SwVbaPageSetup::setGutter( double _gutter ) throw (uno::RuntimeException)
+{
+    // default add gutter into left margin
+    if( _gutter != 0 )
+    {
+        double margin = VbaPageSetupBase::getLeftMargin() + _gutter;
+        VbaPageSetupBase::setLeftMargin( margin );
+    }
+}
+
+double SAL_CALL SwVbaPageSetup::getHeaderDistance() throw (uno::RuntimeException)
+{
+    sal_Bool isHeaderOn = sal_False;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isHeaderOn;
+    if( !isHeaderOn )
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")), uno::makeAny( sal_True ) );
+    return VbaPageSetupBase::getHeaderMargin();
+}
+
+    /**
+     * changes the value of TopMargin to the value of new MS-Word-HeaderDistance. Subtracts the difference
+     * between old TopMargin and the new headerDistance from the value of HeaderSpacing (which defines the
+     * space between the header and the body of the text). calculates the new HeaderHeight (= height of the
+     * header + headerBodyDistance).
+     *
+     * @param: headerDistance is the value that is set in MS Word for the distance from the top of the page
+     *          to the header
+     */
+void SAL_CALL SwVbaPageSetup::setHeaderDistance( double _headerdistance ) throw (uno::RuntimeException)
+{
+    sal_Int32 newHeaderDistance = Millimeter::getInHundredthsOfOneMillimeter( _headerdistance );
+    sal_Bool isHeaderOn = sal_False;
+    sal_Int32 aktTopMargin = 0;
+    sal_Int32 aktSpacing = 0;
+    sal_Int32 aktHeaderHeight = 0;
+
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isHeaderOn;
+    if( !isHeaderOn )
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")), uno::makeAny( sal_True ) );
+        
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin"))) >>= aktTopMargin;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderBodyDistance"))) >>= aktSpacing;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight"))) >>= aktHeaderHeight;
+
+    sal_Int32 newSpacing = aktSpacing - ( newHeaderDistance - aktTopMargin );
+    sal_Int32 height = aktHeaderHeight - aktSpacing;
+    sal_Int32 newHeaderHeight = newSpacing + height;
+
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")), uno::makeAny( newHeaderDistance ) );
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderBodyDistance")), uno::makeAny( newSpacing ) );
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight")), uno::makeAny( newHeaderHeight ) );
+}
+
+double SAL_CALL SwVbaPageSetup::getFooterDistance() throw (uno::RuntimeException)
+{
+    sal_Bool isFooterOn = sal_False;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn"))) >>= isFooterOn;
+    if( !isFooterOn )
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")), uno::makeAny( sal_True ) );
+    return VbaPageSetupBase::getFooterMargin();
+}
+
+void SAL_CALL SwVbaPageSetup::setFooterDistance( double _footerdistance ) throw (uno::RuntimeException)
+{
+    sal_Int32 newFooterDistance = Millimeter::getInHundredthsOfOneMillimeter( _footerdistance );
+    sal_Bool isFooterOn = sal_False;
+    sal_Int32 aktBottomMargin = 0;
+    sal_Int32 aktSpacing = 0;
+    sal_Int32 aktFooterHeight = 0;
+
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn"))) >>= isFooterOn;
+    if( !isFooterOn )
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")), uno::makeAny( sal_True ) );
+        
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin"))) >>= aktBottomMargin;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterBodyDistance"))) >>= aktSpacing;
+    mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight"))) >>= aktFooterHeight;
+
+    sal_Int32 newSpacing = aktSpacing - ( newFooterDistance - aktBottomMargin );
+    sal_Int32 height = aktFooterHeight - aktSpacing;
+    sal_Int32 newFooterHeight = newSpacing + height;
+
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")), uno::makeAny( newFooterDistance ) );
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterBodyDistance")), uno::makeAny( newSpacing ) );
+    mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight")), uno::makeAny( newFooterHeight ) );
+}
+
+sal_Bool SAL_CALL SwVbaPageSetup::getDifferentFirstPageHeaderFooter() throw (uno::RuntimeException)
+{
+    rtl::OUString pageStyle = getStyleOfFirstPage();
+    if( pageStyle.equalsAscii( "First Page" ) )
+        return sal_True;
+
+    return sal_False;
+}
+
+void SAL_CALL SwVbaPageSetup::setDifferentFirstPageHeaderFooter( sal_Bool status ) throw (uno::RuntimeException)
+{
+    if( status == getDifferentFirstPageHeaderFooter() )
+        return;
+
+    rtl::OUString newStyle;
+    if( status )
+        newStyle = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("First Page") );
+    else
+        newStyle = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+
+    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
+    sal_Int32 nTopMargin = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin"))) >>= nTopMargin;
+    sal_Int32 nBottomMargin = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin"))) >>= nBottomMargin;
+    sal_Int32 nLeftMargin = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin"))) >>= nLeftMargin;
+    sal_Int32 nRightMargin = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin"))) >>= nRightMargin;
+    sal_Int32 nHeaderHeight = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight"))) >>= nHeaderHeight;
+    sal_Int32 nFooterHeight = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight"))) >>= nFooterHeight;
+
+    sal_Bool isHeaderOn = sal_False;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn"))) >>= isHeaderOn;
+    if( isHeaderOn )
+    {
+        nTopMargin += nHeaderHeight;
+        nBottomMargin += nFooterHeight;
+        xStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")), uno::makeAny( sal_False ) );
+        xStyleProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")), uno::makeAny( sal_False ) );
+    }
+    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( mxModel ), uno::UNO_QUERY_THROW );
+    if( xPageCursor->getPage() != 1 )
+    {
+        xPageCursor->jumpToFirstPage();
+    }
+
+    uno::Reference< beans::XPropertySet > xCursorProps( xPageCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xTableProps( xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ), uno::UNO_QUERY );
+    if( xTableProps.is() )
+    {
+        xTableProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageDescName") ), uno::makeAny( newStyle ) );
+    }
+    else
+    {
+        xCursorProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageDescName") ), uno::makeAny( newStyle ) );
+    }
+
+    uno::Reference< beans::XPropertySet > xFirstPageProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
+    xFirstPageProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin") ), uno::makeAny( nTopMargin ) );
+    xFirstPageProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin") ), uno::makeAny( nBottomMargin ) );
+    xFirstPageProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin") ), uno::makeAny( nLeftMargin ) );
+    xFirstPageProps->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin") ), uno::makeAny( nRightMargin ) );
+}
+
+rtl::OUString SwVbaPageSetup::getStyleOfFirstPage() throw (uno::RuntimeException)
+{
+    rtl::OUString styleFirstPage;
+    uno::Reference< text::XPageCursor > xPageCursor( word::getXTextViewCursor( mxModel ), uno::UNO_QUERY_THROW );
+    if( xPageCursor->getPage() != 1 )
+    {
+        xPageCursor->jumpToFirstPage();
+    }
+
+    uno::Reference< beans::XPropertySet > xCursorProps( xPageCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xTableProps( xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ), uno::UNO_QUERY );
+    if( xTableProps.is() )
+    {
+        xTableProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageDescName") ) ) >>= styleFirstPage;
+    }
+    else
+    {
+        xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageDescName") ) ) >>= styleFirstPage;
+    }
+    return styleFirstPage;
+}
+
+::sal_Int32 SAL_CALL SwVbaPageSetup::getSectionStart() throw (uno::RuntimeException)
+{
+    // FIXME:
+    sal_Int32 wdSectionStart = word::WdSectionStart::wdSectionNewPage;
+    uno::Reference< container::XNamed > xNamed( mxPageProps, uno::UNO_QUERY_THROW );
+    rtl::OUString sStyleName = xNamed->getName();
+    //mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) ) >>= sStyleName;
+    if( sStyleName.equalsAscii("Left Page") )
+        wdSectionStart = word::WdSectionStart::wdSectionEvenPage;
+    else if( sStyleName.equalsAscii("Right Page") )
+        wdSectionStart = word::WdSectionStart::wdSectionOddPage;
+    else
+        wdSectionStart = word::WdSectionStart::wdSectionNewPage;
+    return wdSectionStart;    
+}
+
+void SAL_CALL SwVbaPageSetup::setSectionStart( ::sal_Int32 /*_sectionstart*/ ) throw (uno::RuntimeException)
+{
+    // fail to find corresponding feature in Writer
+    // #FIXME:
+}
+
+rtl::OUString& 
+SwVbaPageSetup::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaPageSetup") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaPageSetup::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.PageSetup" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbabookmarks.hxx
===================================================================
--- sw/source/ui/vba/vbabookmarks.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbabookmarks.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_BOOKMARKS_HXX
+#define SW_VBA_BOOKMARKS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XBookmarks.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XText.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XBookmarks > SwVbaBookmarks_BASE;
+
+class SwVbaBookmarks : public SwVbaBookmarks_BASE
+{
+private:
+	css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XBookmarksSupplier > mxBookmarksSupplier;
+    css::uno::Reference< css::text::XText > mxText;
+
+private:
+    void removeBookmarkByName( const rtl::OUString& rName ) throw (css::uno::RuntimeException);
+    void addBookmarkByName( const rtl::OUString& rName, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw (css::uno::RuntimeException);
+
+public:
+	SwVbaBookmarks( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xBookmarks, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaBookmarks() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaBookmarks_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	// XBookmarks
+    virtual sal_Int32 SAL_CALL getDefaultSorting() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDefaultSorting( sal_Int32 _type ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getShowHidden() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setShowHidden( sal_Bool _hidden ) throw (css::uno::RuntimeException);
+
+	virtual css::uno::Any SAL_CALL Add( const rtl::OUString& rName, const css::uno::Any& rRange ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL Exists( const rtl::OUString& rName ) throw (css::uno::RuntimeException);
+};    
+
+#endif /* SW_VBA_BOOKMARKS_HXX */
Index: sw/source/ui/vba/vbaborders.cxx
===================================================================
--- sw/source/ui/vba/vbaborders.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaborders.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,381 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaborders.cxx,v $
+ * $Revision: 1.6 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaborders.hxx"
+#include <ooo/vba/word/XBorder.hpp>
+#include <ooo/vba/word/WdBorderType.hpp>
+#include <ooo/vba/word/WdLineStyle.hpp>
+#include <cppuhelper/implbase3.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/table/TableBorder.hpp>
+#include <com/sun/star/table/ShadowFormat.hpp>
+#include <com/sun/star/table/ShadowLocation.hpp>
+#include "vbapalette.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1<container::XIndexAccess > RangeBorders_Base;
+typedef InheritedHelperInterfaceImpl1<word::XBorder > SwVbaBorder_Base;
+
+// #TODO sort these indexes to match the order in which Word iterates over the
+// borders, the enumeration will match the order in this list
+static const sal_Int16 supportedIndexTable[] = { word::WdBorderType::wdBorderBottom, word::WdBorderType::wdBorderDiagonalDown, word::WdBorderType::wdBorderDiagonalUp, word::WdBorderType::wdBorderHorizontal, word::WdBorderType::wdBorderLeft, word::WdBorderType::wdBorderRight, word::WdBorderType::wdBorderTop, word::WdBorderType::wdBorderVertical };
+
+const static rtl::OUString sTableBorder( RTL_CONSTASCII_USTRINGPARAM("TableBorder") );
+
+//  Equiv widths in in 1/100 mm
+const static sal_Int32 OOLineThin = 35;
+const static sal_Int32 OOLineMedium = 88;
+const static sal_Int32 OOLineThick = 141;
+const static sal_Int32 OOLineHairline = 2;
+
+class SwVbaBorder : public SwVbaBorder_Base
+{
+private:
+	uno::Reference< beans::XPropertySet > m_xProps;
+	sal_Int32 m_LineType;	
+	VbaPalette m_Palette;
+	bool setBorderLine( table::BorderLine& rBorderLine )
+	{
+		table::TableBorder aTableBorder;
+		m_xProps->getPropertyValue( sTableBorder ) >>= aTableBorder;
+
+		switch ( m_LineType )
+		{
+			case word::WdBorderType::wdBorderLeft:
+				aTableBorder.IsLeftLineValid = sal_True;
+				aTableBorder.LeftLine= rBorderLine;
+				break;
+			case word::WdBorderType::wdBorderTop:
+				aTableBorder.IsTopLineValid = sal_True;
+				aTableBorder.TopLine = rBorderLine;
+				break;
+			
+			case word::WdBorderType::wdBorderBottom:
+				aTableBorder.IsBottomLineValid = sal_True;
+				aTableBorder.BottomLine = rBorderLine;
+				break;
+			case word::WdBorderType::wdBorderRight:
+				aTableBorder.IsRightLineValid = sal_True;
+				aTableBorder.RightLine = rBorderLine;
+				break;
+			case word::WdBorderType::wdBorderVertical:
+				aTableBorder.IsVerticalLineValid = sal_True;
+				aTableBorder.VerticalLine = rBorderLine;
+				break;
+			case word::WdBorderType::wdBorderHorizontal:
+				aTableBorder.IsHorizontalLineValid = sal_True;
+				aTableBorder.HorizontalLine = rBorderLine;
+				break;
+			case word::WdBorderType::wdBorderDiagonalDown:
+			case word::WdBorderType::wdBorderDiagonalUp:
+				// #TODO have to ignore at the momement, would be
+				// nice to investigate what we can do here
+				break; 
+			default:
+					return false;
+		}
+		m_xProps->setPropertyValue( sTableBorder, uno::makeAny(aTableBorder) );
+		return true;
+	}	
+
+	bool getBorderLine( table::BorderLine& rBorderLine )
+	{
+		table::TableBorder aTableBorder;
+		m_xProps->getPropertyValue( sTableBorder ) >>= aTableBorder;
+		switch ( m_LineType )
+		{
+			case word::WdBorderType::wdBorderLeft:
+				if ( aTableBorder.IsLeftLineValid )
+					rBorderLine = aTableBorder.LeftLine;
+				break;
+			case word::WdBorderType::wdBorderTop:
+				if ( aTableBorder.IsTopLineValid )
+					rBorderLine = aTableBorder.TopLine;
+				break;
+			case word::WdBorderType::wdBorderBottom:
+				if ( aTableBorder.IsBottomLineValid )
+					rBorderLine = aTableBorder.BottomLine;
+				break;
+			case word::WdBorderType::wdBorderRight:
+				if ( aTableBorder.IsRightLineValid )
+					rBorderLine = aTableBorder.RightLine;
+				break;
+			case word::WdBorderType::wdBorderVertical:
+                if ( aTableBorder.IsVerticalLineValid )
+                    rBorderLine = aTableBorder.VerticalLine;
+				break;
+			case word::WdBorderType::wdBorderHorizontal:
+                if ( aTableBorder.IsHorizontalLineValid )
+                    rBorderLine = aTableBorder.HorizontalLine;
+				break;
+
+			case word::WdBorderType::wdBorderDiagonalDown:
+			case word::WdBorderType::wdBorderDiagonalUp:
+				// #TODO have to ignore at the momement, would be
+				// nice to investigate what we can do here
+				break; 
+			default:
+					return false;
+		}
+		return true;
+	}	
+	SwVbaBorder(); // no impl
+protected: 
+	virtual rtl::OUString& getServiceImplName()
+	{
+		static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBorder") );
+	return sImplName;		
+	}
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames()
+	{
+		static uno::Sequence< rtl::OUString > aServiceNames;
+		if ( aServiceNames.getLength() == 0 )
+		{
+			aServiceNames.realloc( 1 );
+			aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Border" ) );
+		}
+		return aServiceNames;		
+	}
+public:
+	SwVbaBorder( const uno::Reference< beans::XPropertySet > & xProps, const uno::Reference< uno::XComponentContext >& xContext, sal_Int32 lineType, VbaPalette& rPalette) : SwVbaBorder_Base( uno::Reference< XHelperInterface >( xProps, uno::UNO_QUERY ), xContext ), m_xProps( xProps ), m_LineType( lineType ), m_Palette( rPalette ) {}  	
+
+	uno::Any SAL_CALL getLineStyle() throw (uno::RuntimeException)
+	{
+        sal_Int32 nLineStyle = word::WdLineStyle::wdLineStyleNone;
+        table::BorderLine aBorderLine;
+        if ( getBorderLine( aBorderLine ) )
+        {
+            if( aBorderLine.InnerLineWidth !=0 && aBorderLine.OuterLineWidth !=0 )
+            {
+                nLineStyle = word::WdLineStyle::wdLineStyleDouble;
+            }
+            else if( aBorderLine.InnerLineWidth !=0 || aBorderLine.OuterLineWidth !=0 )
+            {
+                nLineStyle = word::WdLineStyle::wdLineStyleSingle;
+            }
+            else
+            {
+                nLineStyle = word::WdLineStyle::wdLineStyleNone;
+            }
+        }
+		return uno::makeAny( nLineStyle );
+	}
+	void SAL_CALL setLineStyle( const uno::Any& _linestyle ) throw (uno::RuntimeException) 
+	{
+		// Urk no choice but to silently ignore we don't support this attribute
+		// #TODO would be nice to support the word line styles
+        sal_Int32 nLineStyle = 0;
+        _linestyle >>= nLineStyle;
+        table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+		{
+			switch ( nLineStyle )
+			{
+                case word::WdLineStyle::wdLineStyleNone:
+                {
+                    aBorderLine.InnerLineWidth = 0;
+                    aBorderLine.OuterLineWidth = 0;
+                    break;
+                }
+                case word::WdLineStyle::wdLineStyleDashDot:
+                case word::WdLineStyle::wdLineStyleDashDotDot:
+                case word::WdLineStyle::wdLineStyleDashDotStroked:
+                case word::WdLineStyle::wdLineStyleDashLargeGap:
+                case word::WdLineStyle::wdLineStyleDashSmallGap:
+                case word::WdLineStyle::wdLineStyleDot:
+                case word::WdLineStyle::wdLineStyleDouble:
+                case word::WdLineStyle::wdLineStyleDoubleWavy:
+                case word::WdLineStyle::wdLineStyleEmboss3D:
+                case word::WdLineStyle::wdLineStyleEngrave3D:
+                case word::WdLineStyle::wdLineStyleInset:
+                case word::WdLineStyle::wdLineStyleOutset:
+                case word::WdLineStyle::wdLineStyleSingle:
+                case word::WdLineStyle::wdLineStyleSingleWavy:
+                case word::WdLineStyle::wdLineStyleThickThinLargeGap:
+                case word::WdLineStyle::wdLineStyleThickThinMedGap:
+                case word::WdLineStyle::wdLineStyleThickThinSmallGap:
+                case word::WdLineStyle::wdLineStyleThinThickLargeGap:
+                case word::WdLineStyle::wdLineStyleThinThickMedGap:
+                case word::WdLineStyle::wdLineStyleThinThickSmallGap:
+                case word::WdLineStyle::wdLineStyleThinThickThinLargeGap:
+                case word::WdLineStyle::wdLineStyleThinThickThinMedGap:
+                case word::WdLineStyle::wdLineStyleThinThickThinSmallGap:
+                case word::WdLineStyle::wdLineStyleTriple:
+                {
+                    aBorderLine.InnerLineWidth = 0;
+                    aBorderLine.OuterLineWidth = OOLineHairline;
+                    break;
+                }
+                default:
+                    throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Bad param" ) ), uno::Reference< uno::XInterface >() );
+            }
+			setBorderLine( aBorderLine );
+        }
+		else
+            throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Method failed" ) ), uno::Reference< uno::XInterface >() );
+	}
+};
+
+class RangeBorders : public RangeBorders_Base
+{
+private:
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > m_xContext;
+	VbaPalette m_Palette;
+	sal_Int32 getTableIndex( sal_Int32 nConst )
+	{
+		// hokay return position of the index in the table
+		sal_Int32 nIndexes = getCount();
+		sal_Int32 realIndex = 0;
+		const sal_Int16* pTableEntry = supportedIndexTable;
+		for ( ; realIndex < nIndexes; ++realIndex, ++pTableEntry )
+		{
+			if ( *pTableEntry == nConst )
+				return realIndex;
+		}
+		return getCount(); // error condition
+	}
+public:
+	RangeBorders(  const uno::Reference< table::XCellRange >& xRange,  const uno::Reference< uno::XComponentContext > & xContext, VbaPalette& rPalette ) : m_xRange( xRange ), m_xContext( xContext ), m_Palette( rPalette )
+	{
+	}
+	// XIndexAccess 
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+	{
+		return sizeof( supportedIndexTable ) / sizeof( supportedIndexTable[0] );
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{
+			
+		sal_Int32 nIndex = getTableIndex( Index );
+		if ( nIndex >= 0 && nIndex < getCount() )
+		{
+			uno::Reference< beans::XPropertySet > xProps( m_xRange, uno::UNO_QUERY_THROW );
+			return uno::makeAny( uno::Reference< word::XBorder >( new SwVbaBorder( xProps, m_xContext, supportedIndexTable[ nIndex ], m_Palette )) );
+		}
+		throw lang::IndexOutOfBoundsException();
+	}
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{
+		return  word::XBorder::static_type(0);
+	}
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+	{
+		return sal_True;
+	}
+};
+
+uno::Reference< container::XIndexAccess > 
+rangeToBorderIndexAccess( const uno::Reference< table::XCellRange >& xRange,  const uno::Reference< uno::XComponentContext > & xContext, VbaPalette& rPalette )
+{
+	return new RangeBorders( xRange, xContext, rPalette );
+}
+
+class RangeBorderEnumWrapper : public EnumerationHelper_BASE
+{
+	uno::Reference<container::XIndexAccess > m_xIndexAccess;
+	sal_Int32 nIndex;
+public:
+	RangeBorderEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < m_xIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex < m_xIndexAccess->getCount() )
+			return m_xIndexAccess->getByIndex( nIndex++ );
+		throw container::NoSuchElementException();
+	}
+};
+
+// for Table borders
+SwVbaBorders::SwVbaBorders( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< table::XCellRange >& xRange, VbaPalette& rPalette  ):  SwVbaBorders_BASE( xParent, xContext, rangeToBorderIndexAccess( xRange ,xContext, rPalette ) )
+{
+	m_xProps.set( xRange, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< container::XEnumeration >
+SwVbaBorders::createEnumeration() throw (uno::RuntimeException)
+{
+	return new RangeBorderEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaBorders::createCollectionObject( const css::uno::Any& aSource )
+{
+	return aSource; // its already a Border object
+}
+
+uno::Type 
+SwVbaBorders::getElementType() throw (uno::RuntimeException)
+{
+	return word::XBorders::static_type(0);
+}
+
+uno::Any
+SwVbaBorders::getItemByIntIndex( const sal_Int32 nIndex )  throw (uno::RuntimeException)
+{
+	return createCollectionObject( m_xIndexAccess->getByIndex( nIndex ) );
+}
+
+sal_Bool SAL_CALL SwVbaBorders::getShadow() throw (uno::RuntimeException)
+{
+    table::ShadowFormat aShadowFormat;
+    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShadowFormat") ) ) >>= aShadowFormat;
+    return ( aShadowFormat.Location != table::ShadowLocation_NONE );
+}
+
+void SAL_CALL SwVbaBorders::setShadow( sal_Bool /*_shadow*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+rtl::OUString& 
+SwVbaBorders::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBorders") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaBorders::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Borders" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbarange.hxx
===================================================================
--- sw/source/ui/vba/vbarange.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbarange.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_RANGE_HXX
+#define SW_VBA_RANGE_HXX
+
+#include <ooo/vba/word/XRange.hpp>
+#include <ooo/vba/word/XParagraphFormat.hpp>
+#include <ooo/vba/word/XFont.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <ooo/vba/word/XStyle.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XRange > SwVbaRange_BASE;
+
+class SwVbaRange : public SwVbaRange_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XTextCursor > mxTextCursor;
+    css::uno::Reference< css::text::XText > mxText;
+    sal_Bool mbMaySpanEndOfDocument;
+
+private:
+    void initialize( const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd ) throw (css::uno::RuntimeException);
+public:
+	SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
+	SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
+	SwVbaRange( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::text::XTextRange >& rStart, const css::uno::Reference< css::text::XTextRange >& rEnd, const css::uno::Reference< css::text::XText >& rText, sal_Bool _bMaySpanEndOfDocument = sal_False ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaRange();
+   css::uno::Reference< css::text::XTextDocument > getDocument() { return mxTextDocument; }
+    
+    virtual css::uno::Reference< css::text::XTextRange > SAL_CALL getXTextRange() throw (css::uno::RuntimeException);
+    void setXTextRange( const css::uno::Reference< css::text::XTextRange >& xRange ) throw (css::uno::RuntimeException);
+    css::uno::Reference< css::text::XText > getXText() { return mxText; }
+    void setXTextCursor( const css::uno::Reference< css::text::XTextCursor >& xTextCursor ) { mxTextCursor = xTextCursor; }
+
+	// Attribute
+    virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setText( const rtl::OUString& rText ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    // Methods
+    virtual void SAL_CALL InsertBreak( const css::uno::Any& _breakType ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraph() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraphBefore() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraphAfter() throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getLanguageID() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLanguageID( ::sal_Int32 _languageid ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL PageSetup() throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getStart() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_RANGE_HXX */
Index: sw/source/ui/vba/vbadialog.hxx
===================================================================
--- sw/source/ui/vba/vbadialog.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadialog.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialog.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_DIALOG_HXX
+#define SW_VBA_DIALOG_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/word/XDialog.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadialogbase.hxx>
+
+typedef cppu::ImplInheritanceHelper1< VbaDialogBase, ov::word::XDialog > SwVbaDialog_BASE;
+
+class SwVbaDialog : public SwVbaDialog_BASE
+{
+public:
+	SwVbaDialog( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, const css::uno::Reference< css::frame::XModel >& xModel, sal_Int32 nIndex ):SwVbaDialog_BASE( xParent, xContext, xModel, nIndex ) {}
+	virtual ~SwVbaDialog() {}
+
+	// Methods
+	virtual rtl::OUString mapIndexToName( sal_Int32 nIndex );
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif /* SW_VBA_DIALOG_HXX */
Index: sw/source/ui/vba/vbaautotextentry.hxx
===================================================================
--- sw/source/ui/vba/vbaautotextentry.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaautotextentry.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_AUTOTEXTENTRY_HXX
+#define SW_VBA_AUTOTEXTENTRY_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XAutoTextEntries.hpp>
+#include <ooo/vba/word/XAutoTextEntry.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/word/XRange.hpp>
+#include <com/sun/star/text/XAutoTextEntry.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XAutoTextEntry > SwVbaAutoTextEntry_BASE;
+
+class SwVbaAutoTextEntry : public SwVbaAutoTextEntry_BASE
+{
+private:
+    css::uno::Reference< css::text::XAutoTextEntry > mxEntry;
+
+public:
+	SwVbaAutoTextEntry( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XAutoTextEntry >& xEntry ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaAutoTextEntry();
+
+    // XAutoTextEntry
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL Insert( const css::uno::Reference< ooo::vba::word::XRange >& _where, const css::uno::Any& _richtext ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+
+/* class SwVbaAutoTextEntries */
+typedef CollTestImplHelper< ooo::vba::word::XAutoTextEntries > SwVbaAutoTextEntries_BASE;
+
+class SwVbaAutoTextEntries : public SwVbaAutoTextEntries_BASE
+{
+private:
+    css::uno::Reference< css::container::XIndexAccess > mxAutoTextEntryAccess;
+
+public:
+	SwVbaAutoTextEntries( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw (css::uno::RuntimeException);
+	virtual ~SwVbaAutoTextEntries() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaAutoTextEntries_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_AUTOTEXTENTRY_HXX */
Index: sw/source/ui/vba/vbapanes.cxx
===================================================================
--- sw/source/ui/vba/vbapanes.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapanes.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbapanes.hxx"
+#include "vbapane.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// I assume there is only one pane in Writer
+typedef ::cppu::WeakImplHelper1<container::XIndexAccess > PanesIndexAccess_Base;
+class PanesIndexAccess : public PanesIndexAccess_Base
+{
+private:
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+
+public:
+    PanesIndexAccess( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ) {}
+    ~PanesIndexAccess(){}
+
+    // XIndexAccess
+    virtual sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return 1;
+    }
+    virtual uno::Any SAL_CALL getByIndex( sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if( Index != 1 )
+            throw container::NoSuchElementException();
+        return uno::makeAny( uno::Reference< word::XPane >( new SwVbaPane( mxParent,  mxContext, mxModel ) ) );    
+    }
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return word::XPane::static_type(0);
+    }
+    virtual sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+};
+
+class PanesEnumWrapper : public EnumerationHelper_BASE
+{
+	uno::Reference<container::XIndexAccess > m_xIndexAccess;
+	sal_Int32 nIndex;
+public:
+	PanesEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < m_xIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex < m_xIndexAccess->getCount() )
+			return m_xIndexAccess->getByIndex( nIndex++ );
+		throw container::NoSuchElementException();
+	}
+};
+
+SwVbaPanes::SwVbaPanes( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ): SwVbaPanes_BASE( xParent, xContext, new PanesIndexAccess( xParent, xContext, xModel ) ),  mxModel( xModel )
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaPanes::getElementType() throw (uno::RuntimeException)
+{
+	return word::XPane::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaPanes::createEnumeration() throw (uno::RuntimeException)
+{
+    return new PanesEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+SwVbaPanes::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaPanes::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaPanes") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaPanes::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Panes") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/service.cxx
===================================================================
--- sw/source/ui/vba/service.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/service.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: service.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+#include "comphelper/servicedecl.hxx"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace sdecl = comphelper::service_decl;
+
+namespace globals
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
+namespace document
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
+namespace wrapformat
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+    {
+		OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_writeInfo");
+
+	// Component registration
+        return component_writeInfoHelper( pServiceManager, pRegistryKey, 
+		globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl  ); 
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_getFactory for %s", pImplName );
+	void* pRet =  component_getFactoryHelper(
+        	pImplName, pServiceManager, pRegistryKey, globals::serviceDecl, document::serviceDecl, wrapformat::serviceDecl );
+	OSL_TRACE("Ret is 0x%x", pRet);
+	return pRet;
+    }
+}
Index: sw/source/ui/vba/vbaheaderfooter.cxx
===================================================================
--- sw/source/ui/vba/vbaheaderfooter.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaheaderfooter.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,114 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaheaderfooter.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <ooo/vba/word/WdHeaderFooterIndex.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include "vbarange.hxx"
+#include <vbahelper/vbashapes.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaHeaderFooter::SwVbaHeaderFooter( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& rProps, sal_Bool isHeader, sal_Int32 index ) throw ( uno::RuntimeException ) : SwVbaHeaderFooter_BASE( rParent, rContext ), mxModel( xModel ), mxPageStyleProps( rProps ), mbHeader( isHeader ), mnIndex( index )
+{
+}
+
+sal_Bool SAL_CALL SwVbaHeaderFooter::getIsHeader() throw (uno::RuntimeException)
+{
+    return mbHeader;
+}
+
+sal_Bool SAL_CALL SwVbaHeaderFooter::getLinkToPrevious() throw (uno::RuntimeException)
+{
+    // seems always false
+    return sal_False;
+}
+
+void SAL_CALL SwVbaHeaderFooter::setLinkToPrevious( ::sal_Bool /*_linktoprevious*/ ) throw (uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+uno::Reference< word::XRange > SAL_CALL SwVbaHeaderFooter::getRange() throw (uno::RuntimeException)
+{
+    rtl::OUString sPropsNameText;
+    if( mbHeader )
+    {
+        sPropsNameText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderText") );
+    }
+    else
+    {
+        sPropsNameText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterText") );
+    }
+    if( mnIndex == word::WdHeaderFooterIndex::wdHeaderFooterEvenPages )
+    {
+        sPropsNameText.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Left") ) );
+    }
+
+    uno::Reference< text::XText > xText( mxPageStyleProps->getPropertyValue( sPropsNameText ), uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextDocument > xDocument( mxModel, uno::UNO_QUERY_THROW );
+    return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, xDocument, xText->getStart(), xText->getEnd(), xText ) );
+}
+
+uno::Any SAL_CALL
+SwVbaHeaderFooter::Shapes( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxModel, uno::UNO_QUERY_THROW );
+    //uno::Reference< drawing::XShapes > xShapes( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new ScVbaShapes( this, mxContext, xIndexAccess, mxModel ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+rtl::OUString& 
+SwVbaHeaderFooter::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaHeaderFooter") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaHeaderFooter::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Pane" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbavariables.cxx
===================================================================
--- sw/source/ui/vba/vbavariables.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbavariables.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbavariables.hxx"
+#include "vbavariable.hxx"
+#include <com/sun/star/beans/XPropertyContainer.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+uno::Reference< container::XIndexAccess > createVariablesAccess( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< beans::XPropertyAccess >& xUserDefined ) throw ( uno::RuntimeException )
+{
+    // FIXME: the performance is poor?
+    XNamedObjectCollectionHelper< word::XVariable >::XNamedVec mVariables;
+    const uno::Sequence< beans::PropertyValue > props = xUserDefined->getPropertyValues();
+    sal_Int32 nCount = props.getLength();
+    mVariables.reserve( nCount );
+    for( sal_Int32 i=0; i < nCount; i++ )
+        mVariables.push_back( uno::Reference< word::XVariable > ( new SwVbaVariable( xParent, xContext, xUserDefined, props[i].Name ) ) );
+
+    uno::Reference< container::XIndexAccess > xVariables( new XNamedObjectCollectionHelper< word::XVariable >( mVariables ) );
+    return xVariables;
+}
+
+SwVbaVariables::SwVbaVariables( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< beans::XPropertyAccess >& rUserDefined ): SwVbaVariables_BASE( xParent, xContext, createVariablesAccess( xParent, xContext, rUserDefined ) ),  mxUserDefined( rUserDefined )
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaVariables::getElementType() throw (uno::RuntimeException)
+{
+	return word::XVariable::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaVariables::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumerationAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaVariables::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+uno::Any SAL_CALL
+SwVbaVariables::Add( const rtl::OUString& rName, const uno::Any& rValue ) throw (uno::RuntimeException)
+{
+    uno::Any aValue;
+    if( rValue.hasValue() )
+        aValue = rValue;
+    else
+        aValue <<= rtl::OUString();
+    uno::Reference< beans::XPropertyContainer > xPropertyContainer( mxUserDefined, uno::UNO_QUERY_THROW );
+    xPropertyContainer->addProperty( rName, beans::PropertyAttribute::MAYBEVOID | beans::PropertyAttribute::REMOVEABLE, aValue );
+
+    return uno::makeAny( uno::Reference< word::XVariable >( new SwVbaVariable( getParent(), mxContext, mxUserDefined, rName ) ) );
+}
+
+rtl::OUString& 
+SwVbaVariables::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaVariables") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaVariables::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Variables") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbaapplication.hxx
===================================================================
--- sw/source/ui/vba/vbaapplication.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaapplication.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaapplication.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_APPLICATION_HXX
+#define SW_VBA_APPLICATION_HXX
+
+#include <ooo/vba/word/XApplication.hpp>
+#include <ooo/vba/word/XDocument.hpp>
+#include <ooo/vba/word/XWindow.hpp>
+#include <ooo/vba/word/XSystem.hpp>
+#include <ooo/vba/word/XOptions.hpp>
+#include <ooo/vba/word/XSelection.hpp>
+#include <ooo/vba/word/XAddins.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbaapplicationbase.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+//typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XApplication > SwVbaApplication_BASE;
+typedef cppu::ImplInheritanceHelper1< VbaApplicationBase, ooo::vba::word::XApplication > SwVbaApplication_BASE;
+
+class SwVbaApplication : public SwVbaApplication_BASE
+{
+public:
+	SwVbaApplication( css::uno::Reference< css::uno::XComponentContext >& m_xContext );
+	virtual ~SwVbaApplication();
+
+    virtual SfxObjectShell* GetDocShell( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+
+	// XApplication
+    virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XSystem > SAL_CALL getSystem() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::word::XDocument > SAL_CALL getActiveDocument() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::word::XWindow > SAL_CALL getActiveWindow() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XOptions > SAL_CALL getOptions() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XSelection > SAL_CALL getSelection() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL CommandBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual sal_Bool SAL_CALL getDisplayAutoCompleteTips() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDisplayAutoCompleteTips( sal_Bool _displayAutoCompleteTips ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getEnableCancelKey() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnableCancelKey( sal_Int32 _enableCancelKey ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+protected:
+    virtual css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException);
+};
+#endif /* SW_VBA_APPLICATION_HXX */
Index: sw/source/ui/vba/wordvbahelper.cxx
===================================================================
--- sw/source/ui/vba/wordvbahelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/wordvbahelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,95 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.cxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <docsh.hxx>
+#include "wordvbahelper.hxx"
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/lang/XUnoTunnel.hpp>
+#include <unotxdoc.hxx>
+#include <doc.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+#define FIRST_PAGE 1;
+
+namespace ooo
+{
+namespace vba
+{
+namespace word
+{
+
+SwDocShell* getDocShell( const uno::Reference< frame::XModel>& xModel ) 
+{
+	uno::Reference< lang::XUnoTunnel > xTunnel( xModel, uno::UNO_QUERY_THROW );
+    SwXTextDocument* pXDoc = reinterpret_cast< SwXTextDocument * >( sal::static_int_cast< sal_IntPtr >(xTunnel->getSomething(SwXTextDocument::getUnoTunnelId())));
+	return pXDoc ? pXDoc->GetDocShell() : 0;
+}
+
+SwView* getView( const uno::Reference< frame::XModel>& xModel )
+{
+    SwDocShell* pDocShell = getDocShell( xModel );
+    return pDocShell? pDocShell->GetView() : 0;
+}
+
+uno::Reference< text::XTextViewCursor > getXTextViewCursor( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< frame::XController > xController = xModel->getCurrentController();
+    uno::Reference< text::XTextViewCursorSupplier > xTextViewCursorSupp( xController, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextViewCursor > xTextViewCursor = xTextViewCursorSupp->getViewCursor();
+    return xTextViewCursor;
+}
+
+uno::Reference< style::XStyle > getCurrentPageStyle( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xCursorProps( getXTextViewCursor( xModel ), uno::UNO_QUERY_THROW );
+    rtl::OUString aPageStyleName;
+    xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+    uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xPageStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles") ) ), uno::UNO_QUERY_THROW );
+    uno::Reference< style::XStyle > xStyle( xPageStyles->getByName( aPageStyleName ), uno::UNO_QUERY_THROW );
+
+    return xStyle;
+}
+
+sal_Int32 getPageCount( const uno::Reference< frame::XModel>& xModel ) throw (uno::RuntimeException)
+{
+    SwDocShell* pDocShell = getDocShell( xModel );
+    return pDocShell ? pDocShell->GetDoc()->GetPageCount() : 0;
+}
+
+} // word
+} // 
+} //
Index: sw/source/ui/vba/vbafont.hxx
===================================================================
--- sw/source/ui/vba/vbafont.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafont.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,31 @@
+#ifndef VBA_FONT_HXX
+#define VBA_FONT_HXX
+
+#include <vbahelper/vbafontbase.hxx>
+#include <ooo/vba/word/XFont.hpp>
+
+typedef cppu::ImplInheritanceHelper1< VbaFontBase, ov::word::XFont > SwVbaFont_BASE;
+
+class SwVbaFont : public SwVbaFont_BASE
+{
+public:
+	SwVbaFont( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xPalette, css::uno::Reference< css::beans::XPropertySet > xPropertySet ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaFont(){}
+
+    // Attributes
+    virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getColorIndex() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getUnderline() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUnderline( const css::uno::Any& _underline ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getSubscript() throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL getSuperscript() throw ( css::uno::RuntimeException );
+
+    virtual css::uno::Any SAL_CALL getBold() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getItalic() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStrikethrough() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getShadow() throw (css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();   
+};
+#endif
Index: sw/source/ui/vba/vbaaddin.cxx
===================================================================
--- sw/source/ui/vba/vbaaddin.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaaddin.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaaddin.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaAddin::SwVbaAddin( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const rtl::OUString& rFileURL, sal_Bool bAutoload ) throw ( uno::RuntimeException ) :
+    SwVbaAddin_BASE( rParent, rContext ), msFileURL( rFileURL ), mbAutoload( bAutoload ), mbInstalled( bAutoload )
+{
+}
+
+SwVbaAddin::~SwVbaAddin()
+{
+}
+
+::rtl::OUString SAL_CALL SwVbaAddin::getName() throw (uno::RuntimeException)
+{
+    rtl::OUString sName;
+    INetURLObject aURL( msFileURL );
+    ::osl::File::getSystemPathFromFileURL( aURL.GetLastName(), sName );
+    return sName;
+}
+
+void SAL_CALL
+SwVbaAddin::setName( const rtl::OUString& ) throw ( css::uno::RuntimeException )
+{
+    throw uno::RuntimeException( rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM(" Fail to set name")), uno::Reference< uno::XInterface >() );
+}
+
+::rtl::OUString SAL_CALL SwVbaAddin::getPath() throw (uno::RuntimeException)
+{
+    INetURLObject aURL( msFileURL );
+    aURL.CutLastName();
+    return aURL.GetURLPath();
+}
+
+::sal_Bool SAL_CALL SwVbaAddin::getAutoload() throw (uno::RuntimeException)
+{
+    return mbAutoload;
+}
+
+::sal_Bool SAL_CALL SwVbaAddin::getInstalled() throw (uno::RuntimeException)
+{
+    return mbInstalled;
+}
+
+void SAL_CALL SwVbaAddin::setInstalled( ::sal_Bool _installed ) throw (uno::RuntimeException)
+{
+    if( _installed != mbInstalled )
+    {
+        mbInstalled = _installed;
+        // TODO: should call AutoExec and AutoExit etc.
+    }
+}
+
+rtl::OUString& 
+SwVbaAddin::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaAddin") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaAddin::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Addin" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbatemplate.hxx
===================================================================
--- sw/source/ui/vba/vbatemplate.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatemplate.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_TEMPLATE_HXX
+#define SW_VBA_TEMPLATE_HXX
+
+#include <ooo/vba/word/XTemplate.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTemplate > SwVbaTemplate_BASE;
+
+class SwVbaTemplate : public SwVbaTemplate_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    rtl::OUString msName;
+public:
+	SwVbaTemplate( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
+        const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& );
+	virtual ~SwVbaTemplate();
+
+   // XTemplate
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL AutoTextEntries( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_TEMPLATE_HXX */
Index: sw/source/ui/vba/vbastyles.cxx
===================================================================
--- sw/source/ui/vba/vbastyles.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbastyles.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,380 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbastyles.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbastyles.hxx"
+#include "vbastyle.hxx"
+#include <cppuhelper/implbase3.hxx>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/lang/IndexOutOfBoundsException.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+#include <ooo/vba/word/WdBuiltinStyle.hpp>
+#include <ooo/vba/word/WdStyleType.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+struct BuiltinStyleTable
+{
+    sal_Int32 wdBuiltinStyle;
+    const sal_Char* pOOoStyleName;
+    sal_Int32 wdStyleType;
+};
+
+const BuiltinStyleTable aBuiltinStyleTable[] =
+{
+    { word::WdBuiltinStyle::wdStyleBlockQuotation, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyText, "Text body", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyText2, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyText3, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyTextFirstIndent, "First line indent", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyTextFirstIndent2, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyTextIndent, "Text body indent", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyTextIndent2, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleBodyTextIndent3, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleCaption, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleClosing, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleCommentReference, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleCommentText, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleDate, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleDefaultParagraphFont, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleEmphasis, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleEndnoteReference, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleEndnoteText, "Endnote", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleEnvelopeAddress, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleEnvelopeReturn, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleFooter, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleFootnoteReference, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleFootnoteText, "Footnote", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeader, "Header", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading1, "Heading 1", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading2, "Heading 2", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading3, "Heading 3", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading4, "Heading 4", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading5, "Heading 5", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading6, "Heading 6", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading7, "Heading 7", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading8, "Heading 8", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHeading9, "Heading 9", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlAcronym, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlAddress, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlCite, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlCode, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlDfn, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlKbd, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlNormal, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlPre, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlSamp, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlTt, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHtmlVar, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHyperlink, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleHyperlinkFollowed, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex1, "Index 1", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex2, "Index 2", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex3, "Index 3", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex4, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex5, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex6, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex7, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex8, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndex9, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleIndexHeading, "Index Heading", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleLineNumber, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleList, "List", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleList2, "List 2", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleList3, "List 3", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleList4, "List 4", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleList5, "List 5", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListBullet, "List 1", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListBullet2, "List 2", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListBullet3, "List 3", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListBullet4, "List 4", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListBullet5, "List 5", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListContinue, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListContinue2, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListContinue3, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListContinue4, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListContinue5, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleListNumber, "Numbering 1", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListNumber2, "Numbering 2", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListNumber3, "Numbering 3", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListNumber4, "Numbering 4", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleListNumber5, "Numbering 5", word::WdStyleType::wdStyleTypeList },
+    { word::WdBuiltinStyle::wdStyleMacroText, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleMessageHeader, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleNavPane, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleNormal, "Default", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleNormalIndent, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleNormalTable, "Table", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleNoteHeading, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStylePageNumber, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStylePlainText, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleSalutation, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleSignature, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleStrong, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleSubtitle, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTableOfAuthorities, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTableOfFigures, "", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTitle, "Title", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOAHeading, "Contents Heading", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC1, "Contents 1", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC2, "Contents 2", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC3, "Contents 3", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC4, "Contents 4", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC5, "Contents 5", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC6, "Contents 6", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC7, "Contents 7", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC8, "Contents 8", word::WdStyleType::wdStyleTypeParagraph },
+    { word::WdBuiltinStyle::wdStyleTOC9, "Contents 9", word::WdStyleType::wdStyleTypeParagraph },
+    { 0, 0, 0 }
+};
+
+
+static uno::Sequence< rtl::OUString > getStyleTypes()
+{
+    uno::Sequence< rtl::OUString > aRet(3);
+    rtl::OUString* pArray = aRet.getArray();
+    pArray[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") );
+    pArray[1] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharacterStyles") );
+    pArray[2] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") );
+    return aRet;
+}
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > StyleEnumeration_BASE;
+typedef ::cppu::WeakImplHelper3< container::XNameAccess, container::XIndexAccess, container::XEnumerationAccess > StyleCollectionHelper_BASE;
+/*
+class StylesEnumeration : public StyleEnumeration_BASE
+{
+public:
+	StylesEnumeration( const SheetMap& sMap ) : mSheetMap( sMap ), mIt( mSheetMap.begin() ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( mIt != mSheetMap.end() );
+	}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		uno::Reference< sheet::XSpreadsheet > xSheet( *mIt++ );
+		return uno::makeAny( xSheet ) ;
+	}
+};
+*/
+class StyleCollectionHelper : public StyleCollectionHelper_BASE
+{
+private:
+    uno::Reference< frame::XModel > mxModel;
+    uno::Reference< container::XNameAccess > mxStyleFamilies;
+    uno::Reference< container::XNameContainer > mxCurrentStyleFamily;
+    uno::Any cachePos;
+public:
+	StyleCollectionHelper( const uno::Reference< frame::XModel >& _xModel ) : mxModel( _xModel )
+    {
+        uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( _xModel, uno::UNO_QUERY_THROW);
+        mxStyleFamilies = xStyleSupplier->getStyleFamilies();
+    }
+    uno::Reference< container::XNameContainer > getCurrentStyleFamily(){ return mxCurrentStyleFamily; }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  style::XStyle::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return getCount() > 0; }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+		return cachePos;
+	}
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+		uno::Sequence< rtl::OUString > sNames( getCount() );
+		rtl::OUString* pString = sNames.getArray();
+        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
+        sal_Int32 nCount = 0;
+        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        {
+            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
+            uno::Sequence< rtl::OUString > sElementNames = xNameAccess->getElementNames();
+            for( sal_Int32 j = 0; j < sElementNames.getLength(); j++ )
+            {
+                pString[nCount++] = sElementNames[j];
+            }
+        }
+		return sNames;
+	}
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
+        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        {
+            uno::Reference< container::XNameAccess > xNameAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
+            if( xNameAccess->hasByName( aName ) )
+            {
+                cachePos = xNameAccess->getByName( aName );
+                mxCurrentStyleFamily.set( xNameAccess, uno::UNO_QUERY_THROW );
+                return sal_True;
+            }
+        }
+        return sal_False;
+	}
+
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    { 
+        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
+        sal_Int32 nCount = 0;
+        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        {
+            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
+            nCount += xIndexAccess->getCount();
+        }
+        return nCount;
+    }	
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+		if ( Index < 0 || Index >= getCount() )
+			throw lang::IndexOutOfBoundsException();
+	
+        // FIXME: need to make a alphabetically sorted list of style names
+        uno::Sequence< rtl::OUString > aStyleTypes = getStyleTypes();
+        for( sal_Int32 i = 0; i < aStyleTypes.getLength(); i++ )
+        {
+            uno::Reference< container::XIndexAccess > xIndexAccess( mxStyleFamilies->getByName( aStyleTypes[i] ), uno::UNO_QUERY_THROW );
+            sal_Int32 nCount = xIndexAccess->getCount();
+            if( Index >= nCount )
+                Index -= nCount;
+            else
+            {
+                mxCurrentStyleFamily.set( xIndexAccess, uno::UNO_QUERY_THROW );
+                return xIndexAccess->getByIndex( Index );
+            }
+        }
+		throw lang::IndexOutOfBoundsException();
+	}
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+        // FIXME:
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+	}
+};
+
+SwVbaStyles::SwVbaStyles( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< css::uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ) throw ( script::BasicErrorException ) : SwVbaStyles_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new StyleCollectionHelper( xModel )  ) ), mxModel( xModel )
+{
+    mxMSF.set( mxModel, uno::UNO_QUERY_THROW );
+}
+
+uno::Any 
+SwVbaStyles::createCollectionObject(const uno::Any& aObject)
+{
+    uno::Reference< beans::XPropertySet > xStyleProp( aObject, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProp ) ) );
+}
+
+uno::Type SAL_CALL 
+SwVbaStyles::getElementType() throw (uno::RuntimeException)
+{
+	return word::XStyle::static_type(0);
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+SwVbaStyles::createEnumeration() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+uno::Any SAL_CALL
+SwVbaStyles::Item( const uno::Any& Index1, const uno::Any& Index2 ) throw (uno::RuntimeException)
+{
+    //handle WdBuiltinStyle
+    sal_Int32 nIndex = 0;
+    if( ( Index1 >>= nIndex ) && ( nIndex < 0 ) )
+    {
+        for( const BuiltinStyleTable* pTable = aBuiltinStyleTable; pTable != NULL; pTable++ )
+        {
+            if( nIndex == pTable->wdBuiltinStyle )
+            {
+                rtl::OUString aStyleName = rtl::OUString::createFromAscii( pTable->pOOoStyleName );
+                if( aStyleName.getLength() > 0 )
+                {
+                    rtl::OUString aStyleType = SwVbaStyle::getOOoStyleTypeFromMSWord( pTable->wdStyleType );
+                    switch( pTable->wdStyleType )
+                    {
+                        case word::WdStyleType::wdStyleTypeParagraph:
+                        case word::WdStyleType::wdStyleTypeTable:
+                        {
+                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") );
+                            break;
+                        }
+                        case word::WdStyleType::wdStyleTypeCharacter:
+                        {
+                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharacterStyles") );
+                            break;
+                        }
+                        case word::WdStyleType::wdStyleTypeList:
+                        {
+                            aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberingStyles") );
+                            break;
+                        }
+                        default:
+                            DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
+                    }
+                    uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxModel, uno::UNO_QUERY_THROW);
+                    uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
+                    uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
+                    return uno::makeAny( uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ) );
+                }
+                else
+                {
+                    OSL_TRACE("SwVbaStyles::Item: the builtin style type is not implemented");
+                    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+                }
+            }
+        }
+    }
+    return SwVbaStyles_BASE::Item( Index1, Index2 );
+}
+
+rtl::OUString&
+SwVbaStyles::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaStyles") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaStyles::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.XStyles" ) );
+    }
+    return aServiceNames;
+}
Index: sw/source/ui/vba/vbafield.cxx
===================================================================
--- sw/source/ui/vba/vbafield.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafield.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,481 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile:  $
+ * $Revision:  $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbafield.hxx"
+#include "vbarange.hxx"
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/text/XTextFieldsSupplier.hpp>
+#include <ooo/vba/word/WdFieldType.hpp>
+#include <com/sun/star/text/FilenameDisplayFormat.hpp>
+#include <com/sun/star/util/XRefreshable.hpp>
+#include <swtypes.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// *** SwVbaField ***********************************************
+
+SwVbaField::SwVbaField(  const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const  uno::Reference< css::text::XTextField >& xTextField) throw ( uno::RuntimeException ) : SwVbaField_BASE( rParent, rContext ), mxTextDocument( rDocument )
+{
+    mxTextField.set( xTextField, uno::UNO_QUERY_THROW );
+}
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaField::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaField") );
+    return sImplName;    
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaField::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Field" ) );
+    }
+    return aServiceNames;
+}
+
+// *** _ReadFieldParams ***********************************************
+// the codes are copied from ww8par5.cxx
+class _ReadFieldParams
+{
+private:
+    String aData;
+    xub_StrLen nLen, nFnd, nNext, nSavPtr;
+    String aFieldName;
+public:
+    _ReadFieldParams( const String& rData );
+    ~_ReadFieldParams();
+
+    xub_StrLen GoToTokenParam();
+    long SkipToNextToken();
+    xub_StrLen GetTokenSttPtr() const   { return nFnd;  }
+
+    xub_StrLen FindNextStringPiece( xub_StrLen _nStart = STRING_NOTFOUND );
+    bool GetTokenSttFromTo(xub_StrLen* _pFrom, xub_StrLen* _pTo,
+        xub_StrLen _nMax);
+
+    String GetResult() const;
+    String GetFieldName()const { return aFieldName; }
+};
+
+
+_ReadFieldParams::_ReadFieldParams( const String& _rData )
+    : aData( _rData ), nLen( _rData.Len() ), nNext( 0 )
+{
+    /*
+        erstmal nach einer oeffnenden Klammer oder einer Leerstelle oder einem
+        Anfuehrungszeichen oder einem Backslash suchen, damit der Feldbefehl
+        (also INCLUDEPICTURE bzw EINFUeGENGRAFIK bzw ...) ueberlesen wird
+    */
+    while( (nLen > nNext) && (aData.GetChar( nNext ) == ' ') )
+        ++nNext;
+
+    sal_Unicode c;
+    while(     nLen > nNext
+            && (c = aData.GetChar( nNext )) != ' '
+            && c != '"'
+            && c != '\\'
+            && c != 132
+            && c != 0x201c )
+        ++nNext;
+
+    nFnd      = nNext;
+    nSavPtr   = nNext;
+    aFieldName = aData.Copy( 0, nFnd );
+//  cLastChar = aData.GetChar( nSavPtr );
+}
+
+
+_ReadFieldParams::~_ReadFieldParams()
+{
+//  aData.SetChar( nSavPtr, cLastChar );
+}
+
+
+String _ReadFieldParams::GetResult() const
+{
+    return    (STRING_NOTFOUND == nFnd)
+            ? aEmptyStr
+            : aData.Copy( nFnd, (nSavPtr - nFnd) );
+}
+
+
+xub_StrLen _ReadFieldParams::GoToTokenParam()
+{
+    xub_StrLen nOld = nNext;
+    if( -2 == SkipToNextToken() )
+        return GetTokenSttPtr();
+    nNext = nOld;
+    return STRING_NOTFOUND;
+}
+
+// ret: -2: NOT a '\' parameter but normal Text
+long _ReadFieldParams::SkipToNextToken()
+{
+    long nRet = -1;     // Ende
+    if (
+         (STRING_NOTFOUND != nNext) && (nLen > nNext) &&
+         STRING_NOTFOUND != (nFnd = FindNextStringPiece(nNext))
+       )
+    {
+        nSavPtr = nNext;
+
+        if ('\\' == aData.GetChar(nFnd) && '\\' != aData.GetChar(nFnd + 1))
+        {
+            nRet = aData.GetChar(++nFnd);
+            nNext = ++nFnd;             // und dahinter setzen
+        }
+        else
+        {
+            nRet = -2;
+            if (
+                 (STRING_NOTFOUND != nSavPtr ) &&
+                 (
+                   ('"' == aData.GetChar(nSavPtr - 1)) ||
+                   (0x201d == aData.GetChar(nSavPtr - 1))
+                 )
+               )
+            {
+                --nSavPtr;
+            }
+        }
+    }
+    return nRet;
+}
+
+// FindNextPara sucht naechsten Backslash-Parameter oder naechste Zeichenkette
+// bis zum Blank oder naechsten "\" oder zum schliessenden Anfuehrungszeichen
+// oder zum String-Ende von pStr.
+//
+// Ausgabe ppNext (falls ppNext != 0) Suchbeginn fuer naechsten Parameter bzw. 0
+//
+// Returnwert: 0 falls String-Ende erreicht,
+//             ansonsten Anfang des Paramters bzw. der Zeichenkette
+//
+xub_StrLen _ReadFieldParams::FindNextStringPiece(const xub_StrLen nStart)
+{
+    xub_StrLen  n = ( STRING_NOTFOUND == nStart ) ? nFnd : nStart;  // Anfang
+    xub_StrLen n2;          // Ende
+
+    nNext = STRING_NOTFOUND;        // Default fuer nicht gefunden
+
+    while( (nLen > n) && (aData.GetChar( n ) == ' ') )
+        ++n;
+
+    if( nLen == n )
+        return STRING_NOTFOUND;     // String End reached!
+
+    if(     (aData.GetChar( n ) == '"')     // Anfuehrungszeichen vor Para?
+        ||  (aData.GetChar( n ) == 0x201c)
+        ||  (aData.GetChar( n ) == 132) )
+    {
+        n++;                        // Anfuehrungszeichen ueberlesen
+        n2 = n;                     // ab hier nach Ende suchen
+        while(     (nLen > n2)
+                && (aData.GetChar( n2 ) != '"')
+                && (aData.GetChar( n2 ) != 0x201d)
+                && (aData.GetChar( n2 ) != 147) )
+            n2++;                   // Ende d. Paras suchen
+    }
+    else                        // keine Anfuehrungszeichen
+    {
+        n2 = n;                     // ab hier nach Ende suchen
+        while( (nLen > n2) && (aData.GetChar( n2 ) != ' ') ) // Ende d. Paras suchen
+        {
+            if( aData.GetChar( n2 ) == '\\' )
+            {
+                if( aData.GetChar( n2+1 ) == '\\' )
+                    n2 += 2;        // Doppel-Backslash -> OK
+                else
+                {
+                    if( n2 > n )
+                        n2--;
+                    break;          // einfach-Backslash -> Ende
+                }
+            }
+            else
+                n2++;               // kein Backslash -> OK
+        }
+    }
+    if( nLen > n2 )
+    {
+        if(aData.GetChar( n2 ) != ' ') n2++;
+        nNext = n2;
+    }
+    return n;
+}
+
+
+
+// read parameters "1-3" or 1-3 with both values between 1 and nMax
+bool _ReadFieldParams::GetTokenSttFromTo(USHORT* pFrom, USHORT* pTo, USHORT nMax)
+{
+    USHORT nStart = 0;
+    USHORT nEnd   = 0;
+    xub_StrLen n = GoToTokenParam();
+    if( STRING_NOTFOUND != n )
+    {
+
+        String sParams( GetResult() );
+
+        xub_StrLen nIndex = 0;
+        String sStart( sParams.GetToken(0, '-', nIndex) );
+        if( STRING_NOTFOUND != nIndex )
+        {
+            nStart = static_cast<USHORT>(sStart.ToInt32());
+            nEnd   = static_cast<USHORT>(sParams.Copy(nIndex).ToInt32());
+        }
+    }
+    if( pFrom ) *pFrom = nStart;
+    if( pTo )   *pTo   = nEnd;
+
+    return nStart && nEnd && (nMax >= nStart) && (nMax >= nEnd);
+}
+
+// *** SwVbaFields ***********************************************
+
+uno::Any lcl_createField( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel, const uno::Any& aSource )
+{
+    uno::Reference< text::XTextField > xTextField( aSource, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextDocument > xTextDocument( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< word::XField > xField( new SwVbaField( xParent, xContext, xTextDocument, xTextField ) );
+    return uno::makeAny( xField );
+}
+
+typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > FieldEnumeration_BASE;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > FieldCollectionHelper_BASE;
+
+class FieldEnumeration : public FieldEnumeration_BASE 
+{
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    uno::Reference< container::XEnumeration > mxEnumeration;
+public:
+    FieldEnumeration(  const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< container::XEnumeration >& xEnumeration ) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel ), mxEnumeration( xEnumeration )
+    {
+    }
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+    { 
+        return mxEnumeration->hasMoreElements();
+    }
+    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+        return lcl_createField( mxParent, mxContext, mxModel, mxEnumeration->nextElement() );
+    }
+};
+
+class FieldCollectionHelper : public FieldCollectionHelper_BASE
+{
+    uno::Reference< XHelperInterface > mxParent;
+    uno::Reference< uno::XComponentContext > mxContext;
+    uno::Reference< frame::XModel > mxModel;
+    uno::Reference< container::XEnumerationAccess > mxEnumerationAccess;
+public:
+    FieldCollectionHelper( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) throw (css::uno::RuntimeException) : mxParent( xParent ), mxContext( xContext ), mxModel( xModel )
+    {
+        uno::Reference< text::XTextFieldsSupplier > xSupp( xModel, uno::UNO_QUERY_THROW );
+        mxEnumerationAccess.set( xSupp->getTextFields(), uno::UNO_QUERY_THROW );
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  mxEnumerationAccess->getElementType(); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return mxEnumerationAccess->hasElements(); }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    { 
+        uno::Reference< container::XEnumeration > xEnumeration =  mxEnumerationAccess->createEnumeration();
+        sal_Int32 nCount = 0;
+        while( xEnumeration->hasMoreElements() )
+        {
+            ++nCount;
+            xEnumeration->nextElement();
+        }    
+        return nCount;    
+    }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+        if( Index < 0 || Index >= getCount() )
+            throw lang::IndexOutOfBoundsException();
+
+        uno::Reference< container::XEnumeration > xEnumeration =  mxEnumerationAccess->createEnumeration();
+        sal_Int32 nCount = 0;
+        while( xEnumeration->hasMoreElements() )
+        {
+            if( nCount == Index )
+            {
+                return xEnumeration->nextElement();
+            }
+            ++nCount;
+        }
+        throw lang::IndexOutOfBoundsException();
+    }
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        uno::Reference< container::XEnumeration > xEnumeration =  mxEnumerationAccess->createEnumeration();
+        return uno::Reference< container::XEnumeration >( new FieldEnumeration( mxParent, mxContext, mxModel, xEnumeration ) );
+    }
+};
+ 
+SwVbaFields::SwVbaFields( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< frame::XModel >& xModel ) : SwVbaFields_BASE( xParent, xContext , uno::Reference< container::XIndexAccess >( new FieldCollectionHelper( xParent, xContext, xModel ) ) ), mxModel( xModel )
+{
+    mxMSF.set( mxModel, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< word::XField > SAL_CALL 
+SwVbaFields::Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range, const css::uno::Any& Type, const css::uno::Any& Text, const css::uno::Any& /*PreserveFormatting*/ ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nType = word::WdFieldType::wdFieldEmpty;
+    Type >>= nType;
+    rtl::OUString sText;
+    Text >>= sText;
+
+    String sFieldName;
+    if( ( nType == word::WdFieldType::wdFieldEmpty ) && ( sText.getLength() > 0 ) )
+    {
+        _ReadFieldParams aReadParam(sText);
+        sFieldName = aReadParam.GetFieldName();
+    }
+
+    uno::Reference< text::XTextContent > xTextField;
+    if( nType == word::WdFieldType::wdFieldFileName || sFieldName.EqualsIgnoreCaseAscii("FILENAME") )
+    {
+        xTextField.set( Create_Field_FileName( sText ), uno::UNO_QUERY_THROW );
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+
+    SwVbaRange* pVbaRange = dynamic_cast< SwVbaRange* >( Range.get() );
+    uno::Reference< text::XTextRange > xTextRange = pVbaRange->getXTextRange();
+    uno::Reference< text::XText > xText = xTextRange->getText();
+    xText->insertTextContent( xTextRange, xTextField, true );
+    return uno::Reference< word::XField >( new SwVbaField( mxParent, mxContext, uno::Reference< text::XTextDocument >( mxModel, uno::UNO_QUERY_THROW ), uno::Reference< text::XTextField >( xTextField, uno::UNO_QUERY_THROW ) ) );
+}
+
+uno::Reference< text::XTextField > SwVbaFields::Create_Field_FileName( const rtl::OUString _text ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextField > xTextField( mxMSF->createInstance( rtl::OUString::createFromAscii("com.sun.star.text.TextField.FileName") ), uno::UNO_QUERY_THROW );
+    sal_Int16 nFileFormat = text::FilenameDisplayFormat::NAME_AND_EXT;
+    if( _text.getLength() > 0 )
+    {
+        long nRet;
+        _ReadFieldParams aReadParam( _text );
+        while (-1 != (nRet = aReadParam.SkipToNextToken()))
+        {
+            switch (nRet)
+            {
+                case 'p':
+                    nFileFormat = text::FilenameDisplayFormat::FULL;
+                    break;
+                case '*':
+                    //Skip over MERGEFORMAT
+                    aReadParam.SkipToNextToken();
+                    break;
+                default:
+                    DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+                    break;
+            }
+        }
+    }
+
+    uno::Reference< beans::XPropertySet > xProps( xTextField, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FileFormat") ), uno::makeAny( nFileFormat ) );
+
+    return xTextField;
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+SwVbaFields::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumerationAccess->createEnumeration();
+}
+
+// ScVbaCollectionBaseImpl      
+uno::Any 
+SwVbaFields::createCollectionObject( const uno::Any& aSource )
+{
+    return lcl_createField( mxParent, mxContext, mxModel, aSource );
+} 
+
+sal_Int32 SAL_CALL SwVbaFields::Update() throw (uno::RuntimeException)
+{
+    sal_Int32 nUpdate = 1;
+    try
+    {
+        uno::Reference< text::XTextFieldsSupplier > xSupp( mxModel, uno::UNO_QUERY_THROW );
+        uno::Reference< util::XRefreshable > xRef( xSupp->getTextFields(), uno::UNO_QUERY_THROW );
+        xRef->refresh();
+        nUpdate = 0;
+    }catch( uno::Exception )
+    {
+        nUpdate = 1;
+    }
+    return nUpdate;
+}
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaFields::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFields") );
+    return sImplName;    
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+SwVbaFields::getElementType() throw (uno::RuntimeException)
+{
+    return  word::XField::static_type(0); 
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaFields::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Fields" ) );
+    }
+    return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbaparagraphformat.hxx
===================================================================
--- sw/source/ui/vba/vbaparagraphformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaparagraphformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PARAGRAPHFORMAT_HXX
+#define SW_VBA_PARAGRAPHFORMAT_HXX
+
+#include <ooo/vba/word/XParagraphFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/style/LineSpacing.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XParagraphFormat > SwVbaParagraphFormat_BASE;
+
+class SwVbaParagraphFormat : public SwVbaParagraphFormat_BASE
+{
+private:
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::beans::XPropertySet > mxParaProps;
+
+private:
+    css::style::LineSpacing getOOoLineSpacing( float _lineSpace, sal_Int16 mode );
+    css::style::LineSpacing getOOoLineSpacingFromRule( sal_Int32 _linespacingrule );
+    float getMSWordLineSpacing( css::style::LineSpacing& rLineSpacing );
+    sal_Int32 getMSWordLineSpacingRule( css::style::LineSpacing& rLineSpacing );
+    sal_Int16 getCharHeight() throw (css::uno::RuntimeException);
+    sal_Int32 getOOoAlignment( sal_Int32 _alignment );
+    sal_Int32 getMSWordAlignment( sal_Int32 _alignment );
+
+public:
+	SwVbaParagraphFormat( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rTextDocument, const css::uno::Reference< css::beans::XPropertySet >& rParaProps );
+	virtual ~SwVbaParagraphFormat();
+    
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getAlignment() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAlignment( ::sal_Int32 _alignment ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getFirstLineIndent() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFirstLineIndent( float _firstlineindent ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getKeepTogether() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setKeepTogether( const css::uno::Any& _keeptogether ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getKeepWithNext() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setKeepWithNext( const css::uno::Any& _keepwithnext ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getHyphenation() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHyphenation( const css::uno::Any& _hyphenation ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getLineSpacing() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLineSpacing( float _linespacing ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getLineSpacingRule() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLineSpacingRule( ::sal_Int32 _linespacingrule ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getNoLineNumber() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setNoLineNumber( const css::uno::Any& _nolinenumber ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getOutlineLevel() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setOutlineLevel( ::sal_Int32 _outlinelevel ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getPageBreakBefore() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setPageBreakBefore( const css::uno::Any& _pagebreakbefore ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getSpaceBefore() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSpaceBefore( float _spacebefore ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getSpaceAfter() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSpaceAfter( float _spaceafter ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getLeftIndent() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLeftIndent( float _leftindent ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getRightIndent() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRightIndent( float _rightindent ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getTabStops() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTabStops( const css::uno::Any& _tabstops ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getWidowControl() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidowControl( const css::uno::Any& _widowcontrol ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_PARAGRAPHFORMAT_HXX */
Index: sw/source/ui/vba/vbainformationhelper.cxx
===================================================================
--- sw/source/ui/vba/vbainformationhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbainformationhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbainformationhelper.hxx"
+#include <com/sun/star/text/XPageCursor.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include "wordvbahelper.hxx"
+#include <docsh.hxx>
+#include <doc.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include <swtypes.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const sal_Int32 DEFAULT_PAGE_DISTANCE = 500;
+
+sal_Int32 SwVbaInformationHelper::handleWdActiveEndPageNumber( const css::uno::Reference< css::text::XTextViewCursor >& xTVCursor ) throw( css::uno::RuntimeException )
+{
+    uno::Reference< text::XPageCursor > xPageCursor( xTVCursor, uno::UNO_QUERY_THROW );
+    return xPageCursor->getPage();
+}
+
+sal_Int32 SwVbaInformationHelper::handleWdNumberOfPagesInDocument( const css::uno::Reference< css::frame::XModel >& xModel ) throw( css::uno::RuntimeException )
+{
+    return word::getPageCount( xModel );
+}
+
+double SwVbaInformationHelper::handleWdVerticalPositionRelativeToPage( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XTextViewCursor >& xTVCursor ) throw( css::uno::RuntimeException )
+{
+    xTVCursor->collapseToStart();
+    uno::Reference< beans::XPropertySet > xStyleProps( word::getCurrentPageStyle( xModel ), uno::UNO_QUERY_THROW );
+    sal_Int32 nTopMargin = 0;
+    xStyleProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin") ) ) >>= nTopMargin;
+    sal_Int32 nCurrentPos = xTVCursor->getPosition().Y;
+
+    sal_Int32 nCurrentPage = handleWdActiveEndPageNumber( xTVCursor );
+    sal_Int32 nPageHeight = word::getDocShell( xModel )->GetDoc()->GetPageSize( nCurrentPage, sal_False ).Height();
+    // FIXME: handle multipul page style
+    // it is very strange that the curros position is incorrect when open Word file.
+    // e.g. if current cursor in the top left of the text body of the first page without header,
+    // the top value of current position should be 0, but is 201 when open a Word file. 
+    nCurrentPos = nCurrentPos + nTopMargin - ( DEFAULT_PAGE_DISTANCE + TWIP_TO_MM100( nPageHeight ) ) * (  nCurrentPage - 1  );
+    return Millimeter::getInPoints( nCurrentPos );
+}
Index: sw/source/ui/vba/vbadialogs.hxx
===================================================================
--- sw/source/ui/vba/vbadialogs.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadialogs.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialogs.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_DIALOGS_HXX
+#define SW_VBA_DIALOGS_HXX
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <ooo/vba/word/XDialogs.hpp>
+#include <ooo/vba/XCollection.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbadialogsbase.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef cppu::ImplInheritanceHelper1< VbaDialogsBase, ov::word::XDialogs > SwVbaDialogs_BASE;
+
+class SwVbaDialogs : public SwVbaDialogs_BASE
+{
+public:
+	SwVbaDialogs( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel ): SwVbaDialogs_BASE( xParent, xContext, xModel ) {} 
+	virtual ~SwVbaDialogs() {}
+
+	// XCollection
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif /* SW_VBA_DIALOGS_HXX */
Index: sw/source/ui/vba/vbaglobals.hxx
===================================================================
--- sw/source/ui/vba/vbaglobals.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaglobals.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaglobals.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_GLOBALS_HXX
+#define SW_VBA_GLOBALS_HXX
+
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <ooo/vba/word/XGlobals.hpp>
+#include <ooo/vba/word/XApplication.hpp>
+#include <ooo/vba/word/XSystem.hpp>
+#include <ooo/vba/word/XOptions.hpp>
+#include <ooo/vba/word/XSelection.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include <vbahelper/vbaglobalbase.hxx>
+
+// =============================================================================
+// class SwVbaGlobals
+// =============================================================================
+
+
+typedef ::cppu::ImplInheritanceHelper1< VbaGlobalsBase, ov::word::XGlobals > SwVbaGlobals_BASE;
+
+class SwVbaGlobals : public SwVbaGlobals_BASE 
+{
+private:
+    css::uno::Reference< ooo::vba::word::XApplication > mxApplication;
+
+    virtual css::uno::Reference< ooo::vba::word::XApplication > getApplication() throw (css::uno::RuntimeException);
+
+public:
+	
+    SwVbaGlobals( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& rxContext );
+    virtual ~SwVbaGlobals();
+
+    // XGlobals
+    virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XSystem > SAL_CALL getSystem() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::word::XDocument > SAL_CALL getActiveDocument() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::word::XWindow > SAL_CALL getActiveWindow() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XOptions > SAL_CALL getOptions() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XSelection > SAL_CALL getSelection() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL CommandBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Documents( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Addins( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+    virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
+    // XMultiServiceFactory
+    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getAvailableServiceNames(  ) throw (css::uno::RuntimeException);
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_GLOBALS_HXX */ 
Index: sw/source/ui/vba/vbasystem.hxx
===================================================================
--- sw/source/ui/vba/vbasystem.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasystem.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbasystem.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_SYSTEM_HXX
+#define SW_VBA_SYSTEM_HXX
+
+#include <ooo/vba/word/XSystem.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbapropvalue.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XSystem > SwVbaSystem_BASE;
+
+class PrivateProfileStringListener : public PropListener
+{
+private:
+    rtl::OUString maFileName;
+    ByteString maGroupName;
+    ByteString  maKey;
+public:    
+    PrivateProfileStringListener(){};
+    PrivateProfileStringListener( const rtl::OUString& rFileName, const ByteString& rGroupName, const ByteString& rKey );
+    virtual ~PrivateProfileStringListener();
+    void Initialize( const rtl::OUString& rFileName, const ByteString& rGroupName, const ByteString& rKey );
+
+    //PropListener
+    virtual void setValueEvent( const css::uno::Any& value );
+    virtual css::uno::Any getValueEvent();
+};
+
+class SwVbaSystem : public SwVbaSystem_BASE
+{
+private:
+    PrivateProfileStringListener maPrivateProfileStringListener;
+
+public:
+	SwVbaSystem( css::uno::Reference< css::uno::XComponentContext >& m_xContext );
+	virtual ~SwVbaSystem();
+
+	// XSystem
+	virtual sal_Int32 SAL_CALL getCursor() throw ( css::uno::RuntimeException );
+	virtual void SAL_CALL setCursor( sal_Int32 _cursor ) throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL PrivateProfileString( const rtl::OUString& rFilename, const rtl::OUString& rSection, const rtl::OUString& rKey ) throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_SYSTEM_HXX */
Index: sw/source/ui/vba/vbaselection.hxx
===================================================================
--- sw/source/ui/vba/vbaselection.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaselection.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_SELECTION_HXX
+#define SW_VBA_SELECTION_HXX
+
+#include <ooo/vba/word/XSelection.hpp>
+#include <ooo/vba/word/XRange.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <ooo/vba/word/XParagraphFormat.hpp>
+#include <ooo/vba/word/XFind.hpp>
+#include <ooo/vba/word/XStyle.hpp>
+#include <ooo/vba/word/XFont.hpp>
+#include <ooo/vba/word/XHeaderFooter.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XSelection > SwVbaSelection_BASE;
+
+class SwVbaSelection : public SwVbaSelection_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextViewCursor > mxTextViewCursor;
+    css::uno::Reference< ooo::vba::word::XRange > mxRange;
+
+    enum E_DIRECTION
+    {
+        MOVE_LEFT = 1,
+        MOVE_RIGHT,
+        MOVE_UP,
+        MOVE_DOWN
+    };
+
+private:
+    void NextCell( sal_Int32 nCount, E_DIRECTION eDirection ) throw ( css::uno::RuntimeException );
+    css::uno::Reference< css::text::XTextRange > GetSelectedRange() throw ( css::uno::RuntimeException );
+
+public:
+	SwVbaSelection( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaSelection();
+    
+	// Attribute
+    virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setText( const rtl::OUString& rText ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL getRange() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL HomeKey( const css::uno::Any& _unit, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL EndKey( const css::uno::Any& _unit, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL TypeText( const rtl::OUString& rText ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Delete( const css::uno::Any& _unit, const css::uno::Any& _count ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL MoveRight( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL MoveLeft( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL MoveDown( const css::uno::Any& _unit, const css::uno::Any& _count, const css::uno::Any& _extend ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL TypeParagraph() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraph() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraphBefore() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertParagraphAfter() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XParagraphFormat > SAL_CALL getParagraphFormat() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setParagraphFormat( const css::uno::Reference< ooo::vba::word::XParagraphFormat >& rParagraphFormat ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XFind > SAL_CALL getFind() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XStyle > SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( const css::uno::Reference< ooo::vba::word::XStyle >& _xStyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL TypeBackspace() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XRange > SAL_CALL GoTo( const css::uno::Any& _what, const css::uno::Any& _which, const css::uno::Any& _count, const css::uno::Any& _name ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getLanguageID( ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLanguageID( ::sal_Int32 _languageid ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Information( sal_Int32 _type ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL InsertBreak( const css::uno::Any& _breakType ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Tables( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Fields( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XHeaderFooter > SAL_CALL getHeaderFooter() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL ShapeRange( ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getStart() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStart( ::sal_Int32 _start ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getEnd() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnd( ::sal_Int32 _end ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_SELECTION_HXX */
Index: sw/source/ui/vba/vbadocumentproperties.cxx
===================================================================
--- sw/source/ui/vba/vbadocumentproperties.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocumentproperties.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,767 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadocument.cxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbadocumentproperties.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase3.hxx>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/beans/XPropertyContainer.hpp>
+#include <ooo/vba/word/WdBuiltInProperty.hpp>
+#include <ooo/vba/office/MsoDocProperties.hpp>
+#include <memory>
+#include <boost/shared_ptr.hpp>
+#include "wordvbahelper.hxx"
+#include "fesh.hxx"
+#include "docsh.hxx"
+using namespace ::ooo::vba;
+using namespace css;
+
+sal_Int8 lcl_toMSOPropType( const uno::Type& aType ) throw ( lang::IllegalArgumentException )
+{
+    sal_Int16 msoType = office::MsoDocProperties::msoPropertyTypeString;
+
+    switch ( aType.getTypeClass() )
+    {
+        case uno::TypeClass_BOOLEAN:       
+            msoType =  office::MsoDocProperties::msoPropertyTypeBoolean;
+            break;
+        case uno::TypeClass_FLOAT:
+            msoType =  office::MsoDocProperties::msoPropertyTypeFloat;
+            break;
+        case uno::TypeClass_STRUCT: // Assume date
+            msoType =  office::MsoDocProperties::msoPropertyTypeDate;
+            break;
+        case  uno::TypeClass_BYTE:
+        case  uno::TypeClass_SHORT:
+        case  uno::TypeClass_LONG:
+        case  uno::TypeClass_HYPER:
+            msoType =  office::MsoDocProperties::msoPropertyTypeNumber;
+            break;
+        default:
+            throw lang::IllegalArgumentException();
+    }
+    return msoType;
+}
+
+class PropertGetSetHelper
+{
+protected:
+    uno::Reference< frame::XModel > m_xModel;
+    uno::Reference< beans::XPropertySet > mxProps;
+public:
+    PropertGetSetHelper( const uno::Reference< frame::XModel >& xModel ):m_xModel( xModel ) 
+    {
+        uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( m_xModel, uno::UNO_QUERY_THROW );
+        mxProps.set( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+    }
+    virtual ~PropertGetSetHelper() {}
+    virtual uno::Any getPropertyValue( const rtl::OUString& rPropName ) = 0;
+    virtual void setPropertyValue( const rtl::OUString& rPropName, const uno::Any& aValue ) = 0;
+    virtual uno::Reference< beans::XPropertySet > getUnoProperties() { return mxProps; }
+
+};
+
+class BuiltinPropertyGetSetHelper : public PropertGetSetHelper
+{
+public:
+    BuiltinPropertyGetSetHelper( const uno::Reference< frame::XModel >& xModel ) :PropertGetSetHelper( xModel ) 
+    {
+    }
+    virtual uno::Any getPropertyValue( const rtl::OUString& rPropName )
+    {
+        if ( rPropName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("EditingDuration" ) ) ) )
+        {
+            sal_Int32 nSecs = 0;
+            mxProps->getPropertyValue( rPropName ) >>= nSecs;
+            return uno::makeAny( nSecs/60 ); // minutes
+        }
+        return mxProps->getPropertyValue( rPropName );
+    }
+    virtual void setPropertyValue( const rtl::OUString& rPropName, const uno::Any& aValue )
+    {
+        mxProps->setPropertyValue( rPropName, aValue );
+    }
+};
+
+class CustomPropertyGetSetHelper : public BuiltinPropertyGetSetHelper
+{
+public:
+    CustomPropertyGetSetHelper( const uno::Reference< frame::XModel >& xModel ) :BuiltinPropertyGetSetHelper( xModel )
+    {
+        uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( mxProps, uno::UNO_QUERY_THROW );
+        uno::Reference< document::XDocumentProperties > xDocProp( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );  
+        mxProps.set( xDocProp->getUserDefinedProperties(), uno::UNO_QUERY_THROW );
+    }
+};
+class StatisticPropertyGetSetHelper : public PropertGetSetHelper
+{
+    SwDocShell* mpDocShell;
+    uno::Reference< beans::XPropertySet > mxModelProps;
+public:
+    StatisticPropertyGetSetHelper( const uno::Reference< frame::XModel >& xModel ) :PropertGetSetHelper( xModel ) , mpDocShell( NULL )
+    {
+            mxModelProps.set( m_xModel, uno::UNO_QUERY_THROW );
+            mpDocShell = word::getDocShell( xModel );
+    }
+    virtual uno::Any getPropertyValue( const rtl::OUString& rPropName )
+    {
+        uno::Sequence< beans::NamedValue > stats;
+        try 
+        {
+            // Characters, ParagraphCount & WordCount are available from
+            // the model ( and addtionally these also update the statics object )
+            //return mxProps->getPropertyValue( rPropName );
+            return mxModelProps->getPropertyValue( rPropName );
+        }
+        catch( uno::Exception& )
+        {
+            OSL_TRACE("Got exception");
+        }
+        uno::Any aReturn;
+        if ( rPropName.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LineCount")) ) ) // special processing needed
+        {
+            if ( mpDocShell )
+            {
+                SwFEShell* pFEShell = mpDocShell->GetFEShell();
+                if(pFEShell)
+                {
+                    aReturn <<= pFEShell->GetLineCount(FALSE);
+                }
+            }
+        }
+        else
+        {
+            mxModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphCount") ) ) >>= stats;
+            mxProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DocumentStatistic") ) ) >>= stats;
+  
+            sal_Int32 nLen = stats.getLength();
+            bool bFound = false;
+            for ( sal_Int32 index = 0; index < nLen && !bFound ; ++index )
+            {
+                if ( rPropName.equals( stats[ index ].Name ) )
+                {
+                    aReturn = stats[ index ].Value;
+                    bFound = true;
+                }  
+            }     
+            if ( !bFound )
+                throw uno::RuntimeException(); // bad Property
+        }
+        return aReturn;
+    }
+
+    virtual void setPropertyValue( const rtl::OUString& rPropName, const uno::Any& aValue )
+    {
+
+        uno::Sequence< beans::NamedValue > stats;
+        mxProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DocumentStatistic") ) ) >>= stats;
+  
+        sal_Int32 nLen = stats.getLength();
+        for ( sal_Int32 index = 0; index < nLen; ++index )
+        {
+            if ( rPropName.equals( stats[ index ].Name ) )
+            {
+                stats[ index ].Value = aValue;
+                mxProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DocumentStatistic") ), uno::makeAny( stats ) );
+                break;
+            }  
+        }     
+    }
+};
+
+class DocPropInfo
+{
+public:
+    rtl::OUString msMSODesc;
+    rtl::OUString msOOOPropName;
+    boost::shared_ptr< PropertGetSetHelper > mpPropGetSetHelper;
+    
+    static DocPropInfo createDocPropInfo( const rtl::OUString& sDesc, const rtl::OUString& sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
+    {
+        return createDocPropInfo( rtl::OUStringToOString( sDesc, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( sPropName, RTL_TEXTENCODING_UTF8 ).getStr(), rHelper );
+    }
+
+    static DocPropInfo createDocPropInfo( const sal_Char* sDesc, const sal_Char* sPropName, boost::shared_ptr< PropertGetSetHelper >& rHelper )
+    {
+        DocPropInfo aItem;
+        aItem.msMSODesc = rtl::OUString::createFromAscii( sDesc );
+        aItem.msOOOPropName = rtl::OUString::createFromAscii( sPropName );
+        aItem.mpPropGetSetHelper = rHelper;
+        return aItem;
+    }
+    uno::Any getValue() 
+    {
+        if ( mpPropGetSetHelper.get() )
+            return mpPropGetSetHelper->getPropertyValue( msOOOPropName ); 
+        return uno::Any();
+    }
+    void setValue( const uno::Any& rValue ) 
+    {
+        if ( mpPropGetSetHelper.get() )
+            mpPropGetSetHelper->setPropertyValue( msOOOPropName, rValue ); 
+    }
+    uno::Reference< beans::XPropertySet > getUnoProperties() 
+    { 
+        
+        uno::Reference< beans::XPropertySet > xProps;
+        if ( mpPropGetSetHelper.get() )
+            return mpPropGetSetHelper->getUnoProperties(); 
+        return xProps; 
+    }
+};
+
+
+typedef std::hash_map< sal_Int32, DocPropInfo > MSOIndexToOODocPropInfo;
+
+class BuiltInIndexHelper
+{
+    MSOIndexToOODocPropInfo m_docPropInfoMap;
+    BuiltInIndexHelper();
+public:
+    BuiltInIndexHelper( const uno::Reference< frame::XModel >& xModel )
+    {
+        boost::shared_ptr< PropertGetSetHelper > aStandardHelper( new BuiltinPropertyGetSetHelper( xModel ) );
+        boost::shared_ptr< PropertGetSetHelper > aUsingStatsHelper( new StatisticPropertyGetSetHelper( xModel ) );
+
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyTitle ] = DocPropInfo::createDocPropInfo( "Title", "Title", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertySubject ] = DocPropInfo::createDocPropInfo( "Subject", "Subject", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyAuthor ] = DocPropInfo::createDocPropInfo( "Author", "Author", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyKeywords ] = DocPropInfo::createDocPropInfo( "Keywords", "Keywords", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyComments ] = DocPropInfo::createDocPropInfo( "Comments", "Description", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyTemplate ] = DocPropInfo::createDocPropInfo( "Template", "Template", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyLastAuthor ] = DocPropInfo::createDocPropInfo( "Last author", "ModifiedBy", aStandardHelper ); // doesn't seem to exist - throw or return nothing ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyRevision ] = DocPropInfo::createDocPropInfo( "Revision number", "EditingCycles", aStandardHelper ); // doesn't seem to exist - throw or return nothing ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyAppName ] = DocPropInfo::createDocPropInfo( "Application name", "Generator", aStandardHelper ); // doesn't seem to exist - throw or return nothing ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyTimeLastPrinted ] = DocPropInfo::createDocPropInfo( "Last print date", "PrintDate", aStandardHelper ); // doesn't seem to exist - throw or return nothing ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyTimeCreated ] = DocPropInfo::createDocPropInfo( "Creation date", "CreationDate", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyTimeLastSaved ] = DocPropInfo::createDocPropInfo( "Last save time", "ModifyDate", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyVBATotalEdit ] = DocPropInfo::createDocPropInfo( "Total editing time", "EditingDuration", aStandardHelper ); // Not sure if this is correct 
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyPages ] = DocPropInfo::createDocPropInfo( "Number of pages", "PageCount", aUsingStatsHelper ); // special handling required ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyWords ] = DocPropInfo::createDocPropInfo( "Number of words", "WordCount", aUsingStatsHelper ); // special handling require ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyCharacters ] = DocPropInfo::createDocPropInfo( "Number of characters", "CharacterCount", aUsingStatsHelper ); // special handling required ?
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertySecurity ] = DocPropInfo::createDocPropInfo( "Security", "", aStandardHelper ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyCategory ] = DocPropInfo::createDocPropInfo( "Category", "Category", aStandardHelper ); // hacked in
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyFormat ] = DocPropInfo::createDocPropInfo( "Format", "", aStandardHelper ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyManager ] = DocPropInfo::createDocPropInfo( "Manager", "Manager", aStandardHelper ); // hacked in
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyCompany ] = DocPropInfo::createDocPropInfo( "Company", "Company", aStandardHelper ); // hacked in
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyBytes ] = DocPropInfo::createDocPropInfo( "Number of bytes", "", aStandardHelper ); // doesn't seem to exist - size on disk exists ( for an already saved document ) perhaps it will do ( or we need something else )
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyLines ] = DocPropInfo::createDocPropInfo( "Number of lines", "LineCount", aUsingStatsHelper ); // special handling
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyParas ] = DocPropInfo::createDocPropInfo( "Number of paragraphs", "ParagraphCount", aUsingStatsHelper ); // special handling
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertySlides ] = DocPropInfo::createDocPropInfo( "Number of slides", "" , aStandardHelper ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyNotes ] = DocPropInfo::createDocPropInfo( "Number of notes", "", aStandardHelper ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyHiddenSlides ] = DocPropInfo::createDocPropInfo("Number of hidden Slides", "", aStandardHelper  ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyMMClips ] = DocPropInfo::createDocPropInfo( "Number of multimedia clips", "", aStandardHelper ); // doesn't seem to exist
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyHyperlinkBase ] = DocPropInfo::createDocPropInfo( "Hyperlink base", "AutoloadURL", aStandardHelper );
+        m_docPropInfoMap[ word::WdBuiltInProperty::wdPropertyCharsWSpaces ] = DocPropInfo::createDocPropInfo( "Number of characters (with spaces)", "", aStandardHelper ); // doesn't seem to be supported
+    }
+
+    MSOIndexToOODocPropInfo& getDocPropInfoMap() { return m_docPropInfoMap; }
+};
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::XDocumentProperty > SwVbaDocumentProperty_BASE;
+
+class SwVbaBuiltInDocumentProperty : public SwVbaDocumentProperty_BASE
+{
+protected:
+    DocPropInfo mPropInfo;
+public:
+    SwVbaBuiltInDocumentProperty(  const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const DocPropInfo& rInfo );
+    // XDocumentProperty
+    virtual void SAL_CALL Delete(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getName(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setName( const ::rtl::OUString& Name ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual ::sal_Int8 SAL_CALL getType(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setType( ::sal_Int8 Type ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLinkToContent(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setLinkToContent( ::sal_Bool LinkToContent ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual uno::Any SAL_CALL getValue(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setValue( const uno::Any& Value ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getLinkSource(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setLinkSource( const rtl::OUString& LinkSource ) throw (script::BasicErrorException, uno::RuntimeException);
+    //XDefaultProperty
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (uno::RuntimeException) { return rtl::OUString::createFromAscii("Value"); }
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+class SwVbaCustomDocumentProperty : public SwVbaBuiltInDocumentProperty
+{
+public:
+
+    SwVbaCustomDocumentProperty(  const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const DocPropInfo& rInfo );
+
+    virtual ::sal_Bool SAL_CALL getLinkToContent(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setLinkToContent( ::sal_Bool LinkToContent ) throw (script::BasicErrorException, uno::RuntimeException);
+
+    virtual rtl::OUString SAL_CALL getLinkSource(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setLinkSource( const rtl::OUString& LinkSource ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL Delete(  ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setName( const ::rtl::OUString& Name ) throw (script::BasicErrorException, uno::RuntimeException);
+    virtual void SAL_CALL setType( ::sal_Int8 Type ) throw (script::BasicErrorException, uno::RuntimeException);
+
+};
+
+
+SwVbaCustomDocumentProperty::SwVbaCustomDocumentProperty(  const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const DocPropInfo& rInfo ) : SwVbaBuiltInDocumentProperty( xParent, xContext, rInfo )
+{
+}
+
+sal_Bool
+SwVbaCustomDocumentProperty::getLinkToContent(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // #FIXME we need to store the link content somewhere
+    return sal_False;
+}
+
+void
+SwVbaCustomDocumentProperty::setLinkToContent( sal_Bool /*bLinkContent*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+}
+
+rtl::OUString
+SwVbaCustomDocumentProperty::getLinkSource(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // #FIXME we need to store the link content somewhere
+    return rtl::OUString();;
+}
+
+void
+SwVbaCustomDocumentProperty::setLinkSource( const rtl::OUString& /*rsLinkContent*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // #FIXME we need to store the link source somewhere
+}
+
+void SAL_CALL 
+SwVbaCustomDocumentProperty::setName( const ::rtl::OUString& /*Name*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // setName on existing property ? 
+    // #FIXME 
+    // do we need to delete existing property and create a new one?
+}
+
+void SAL_CALL 
+SwVbaCustomDocumentProperty::setType( ::sal_Int8 /*Type*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // setType, do we need to do a conversion?
+    // #FIXME the underlying value needs to be changed to the new type
+}
+
+void SAL_CALL 
+SwVbaCustomDocumentProperty::Delete(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertyContainer > xContainer( mPropInfo.getUnoProperties(), uno::UNO_QUERY_THROW );
+    xContainer->removeProperty( getName() );
+}
+
+SwVbaBuiltInDocumentProperty::SwVbaBuiltInDocumentProperty( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const DocPropInfo& rInfo ) : SwVbaDocumentProperty_BASE( xParent, xContext ), mPropInfo( rInfo )
+{
+} 
+
+void SAL_CALL 
+SwVbaBuiltInDocumentProperty::Delete(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+ 
+::rtl::OUString SAL_CALL 
+SwVbaBuiltInDocumentProperty::getName(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    return mPropInfo.msMSODesc;
+}
+
+void SAL_CALL
+SwVbaBuiltInDocumentProperty::setName( const rtl::OUString& ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+
+::sal_Int8 SAL_CALL 
+SwVbaBuiltInDocumentProperty::getType(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    return lcl_toMSOPropType( getValue().getValueType() );
+}
+
+void SAL_CALL 
+SwVbaBuiltInDocumentProperty::setType( ::sal_Int8 /*Type*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+
+::sal_Bool SAL_CALL 
+SwVbaBuiltInDocumentProperty::getLinkToContent(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    return sal_False; // built-in always false
+}
+
+void SAL_CALL 
+SwVbaBuiltInDocumentProperty::setLinkToContent( ::sal_Bool /*LinkToContent*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+
+uno::Any SAL_CALL 
+SwVbaBuiltInDocumentProperty::getValue(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Any aRet = mPropInfo.getValue();
+    if ( !aRet.hasValue() )
+        throw uno::RuntimeException();
+    return aRet;
+}
+
+void SAL_CALL 
+SwVbaBuiltInDocumentProperty::setValue( const uno::Any& Value ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    mPropInfo.setValue( Value );
+}
+
+rtl::OUString SAL_CALL 
+SwVbaBuiltInDocumentProperty::getLinkSource(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL 
+SwVbaBuiltInDocumentProperty::setLinkSource( const rtl::OUString& /*LinkSource*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // not valid for Builtin
+    throw uno::RuntimeException();
+}
+
+rtl::OUString& 
+SwVbaBuiltInDocumentProperty::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBuiltinDocumentProperty") );
+    return sImplName;    
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaBuiltInDocumentProperty::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.DocumentProperty" ) );
+    }
+    return aServiceNames;
+}
+typedef ::cppu::WeakImplHelper3< com::sun::star::container::XIndexAccess
+        ,com::sun::star::container::XNameAccess
+        ,com::sun::star::container::XEnumerationAccess
+        > PropertiesImpl_BASE;
+
+typedef std::hash_map< sal_Int32, uno::Reference< XDocumentProperty > > DocProps;
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::container::XEnumeration > DocPropEnumeration_BASE;
+class DocPropEnumeration : public DocPropEnumeration_BASE
+{
+    DocProps mDocProps;
+    DocProps::iterator mIt;
+public:
+    
+    DocPropEnumeration( const DocProps& rProps ) : mDocProps( rProps ), mIt( mDocProps.begin() ) {}
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return mIt != mDocProps.end();
+    }
+    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasMoreElements() )
+            throw container::NoSuchElementException();
+        return uno::makeAny( mIt++->second );
+    }
+};
+
+typedef std::hash_map< rtl::OUString, uno::Reference< XDocumentProperty >, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > DocPropsByName;
+
+class BuiltInPropertiesImpl : public PropertiesImpl_BASE
+{
+protected:
+
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< frame::XModel > m_xModel;
+    uno::Reference< document::XDocumentInfo > m_xOOOBuiltIns;
+ 
+    DocProps mDocProps;
+    DocPropsByName mNamedDocProps;
+      
+    public:
+    BuiltInPropertiesImpl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : m_xParent( xParent ), m_xContext( xContext ), m_xModel( xModel )
+    {
+    	BuiltInIndexHelper builtIns( m_xModel );
+        for ( sal_Int32 index = word::WdBuiltInProperty::wdPropertyTitle; index <= word::WdBuiltInProperty::wdPropertyCharsWSpaces; ++index )
+        {
+            mDocProps[ index ] = new SwVbaBuiltInDocumentProperty( xParent, xContext, builtIns.getDocPropInfoMap()[ index ] );
+            mNamedDocProps[ mDocProps[ index ]->getName() ] = mDocProps[ index ];
+        } 
+    }
+// XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mDocProps.size();
+    }
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException )
+    {
+        // correct the correct by the base class for 1 based indices
+        DocProps::iterator it = mDocProps.find( ++Index );
+        if ( it == mDocProps.end() )
+            throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( it->second  );
+    }
+    virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+		throw container::NoSuchElementException();
+        DocPropsByName::iterator it = mNamedDocProps.find( aName );
+        return uno::Any( it->second );
+        
+    }
+    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+    {
+        uno::Sequence< rtl::OUString > aNames( getCount() );
+        rtl::OUString* pName = aNames.getArray();
+        DocPropsByName::iterator it_end = mNamedDocProps.end();
+        for(  DocPropsByName::iterator it = mNamedDocProps.begin(); it != it_end; ++it, ++pName )
+           *pName = it->first;
+        return aNames; 
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+    {
+        DocPropsByName::iterator it = mNamedDocProps.find( aName );
+        if ( it == mNamedDocProps.end() )
+            return sal_False;
+        return sal_True;
+    }
+// XElementAccess
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) 
+    {
+        return  XDocumentProperty::static_type(0); 
+    }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return mDocProps.size() > 0;
+    }
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        return new DocPropEnumeration( mDocProps );
+    }
+};
+
+SwVbaBuiltinDocumentProperties::SwVbaBuiltinDocumentProperties( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : SwVbaDocumentproperties_BASE( xParent, xContext,  uno::Reference< container::XIndexAccess >( new BuiltInPropertiesImpl( xParent, xContext, xModel ) ) ), m_xModel( xModel )
+{
+} 
+
+uno::Reference< XDocumentProperty > SAL_CALL 
+SwVbaBuiltinDocumentProperties::Add( const ::rtl::OUString& /*Name*/, ::sal_Bool /*LinkToContent*/, ::sal_Int8 /*Type*/, const uno::Any& /*value*/, const uno::Any& /*LinkSource*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    throw uno::RuntimeException(
+        rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("not supported for Builtin properties") ), uno::Reference< uno::XInterface >() );
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+SwVbaBuiltinDocumentProperties::getElementType() throw (uno::RuntimeException)
+{
+    return  XDocumentProperty::static_type(0); 
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+SwVbaBuiltinDocumentProperties::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumAccess->createEnumeration();
+}
+
+// ScVbaCollectionBaseImpl      
+uno::Any 
+SwVbaBuiltinDocumentProperties::createCollectionObject( const uno::Any& aSource )
+{
+    // pass through
+    return aSource;
+}
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaBuiltinDocumentProperties::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBuiltinDocumentProperties") );
+    return sImplName;    
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaBuiltinDocumentProperties::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.DocumentProperties" ) );
+    }
+    return aServiceNames;
+}
+
+class CustomPropertiesImpl : public PropertiesImpl_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    uno::Reference< frame::XModel > m_xModel;
+    uno::Reference< beans::XPropertySet > mxUserDefinedProp;
+    boost::shared_ptr< PropertGetSetHelper > mpPropGetSetHelper;
+public:
+    CustomPropertiesImpl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : m_xParent( xParent ), m_xContext( xContext ), m_xModel( xModel )
+    {
+        // suck in the document( custom ) properties
+        uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( m_xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );     
+        uno::Reference< document::XDocumentProperties > xDocProp( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );     
+        mxUserDefinedProp.set( xDocProp->getUserDefinedProperties(), uno::UNO_QUERY_THROW );     
+        mpPropGetSetHelper.reset( new CustomPropertyGetSetHelper( m_xModel ) );
+    }; 
+    // XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxUserDefinedProp->getPropertySetInfo()->getProperties().getLength();
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException )
+    {
+        uno::Sequence< beans::Property > aProps = mxUserDefinedProp->getPropertySetInfo()->getProperties();
+        if ( Index >= aProps.getLength() )
+            throw lang::IndexOutOfBoundsException();
+        // How to determine type e.g Date? ( com.sun.star.util.DateTime )
+        DocPropInfo aPropInfo = DocPropInfo::createDocPropInfo( aProps[ Index ].Name, aProps[ Index ].Name, mpPropGetSetHelper );
+        return uno::makeAny( uno::Reference< XDocumentProperty >( new SwVbaCustomDocumentProperty( m_xParent, m_xContext, aPropInfo ) ) );
+    }
+
+    virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+
+        DocPropInfo aPropInfo = DocPropInfo::createDocPropInfo( aName, aName, mpPropGetSetHelper );
+        return uno::makeAny( uno::Reference< XDocumentProperty >( new SwVbaCustomDocumentProperty( m_xParent, m_xContext, aPropInfo ) ) );
+    }
+
+    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+    {
+        uno::Sequence< beans::Property > aProps = mxUserDefinedProp->getPropertySetInfo()->getProperties();
+        uno::Sequence< rtl::OUString > aNames( aProps.getLength() );
+        rtl::OUString* pString = aNames.getArray();
+        rtl::OUString* pEnd = ( pString + aNames.getLength() );
+        beans::Property* pProp = aProps.getArray();
+        for ( ; pString != pEnd; ++pString, ++pProp )
+            *pString = pProp->Name;
+        return aNames;
+    }
+
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+    {
+        OSL_TRACE("hasByName(%s) returns %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), mxUserDefinedProp->getPropertySetInfo()->hasPropertyByName( aName ) );
+        return mxUserDefinedProp->getPropertySetInfo()->hasPropertyByName( aName );
+    }
+
+    // XElementAccess
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) 
+    {
+        return  XDocumentProperty::static_type(0); 
+    }
+
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+    {
+        return getCount() > 0;
+    }
+
+    virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+    {
+        // create a map of properties ( the key doesn't matter )
+        OSL_TRACE("Creating an enumeration");
+        sal_Int32 key = 0;
+        sal_Int32 nElem =  getCount();
+        DocProps simpleDocPropSnapShot;
+        for ( ; key < nElem; ++key )
+             simpleDocPropSnapShot[ key ].set( getByIndex( key ), uno::UNO_QUERY_THROW );
+        OSL_TRACE("After creating the enumeration");
+        return  new DocPropEnumeration( simpleDocPropSnapShot );
+    }
+
+    void addProp( const ::rtl::OUString& Name, ::sal_Int8 /*Type*/, const uno::Any& Value )
+    {
+        sal_Int16 attributes = 128;
+        uno::Reference< beans::XPropertyContainer > xContainer( mxUserDefinedProp, uno::UNO_QUERY_THROW );
+        // TODO fixme, perform the necessary Type Value conversions
+        xContainer->addProperty( Name, attributes, Value );
+    }
+
+};
+
+
+SwVbaCustomDocumentProperties::SwVbaCustomDocumentProperties( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : SwVbaBuiltinDocumentProperties( xParent, xContext, xModel )
+{
+    // replace the m_xIndexAccess implementation ( we need a virtual init )
+    m_xIndexAccess.set( new CustomPropertiesImpl( xParent, xContext, xModel ) );
+    m_xNameAccess.set( m_xIndexAccess, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< XDocumentProperty > SAL_CALL 
+SwVbaCustomDocumentProperties::Add( const ::rtl::OUString& Name, ::sal_Bool LinkToContent, ::sal_Int8 Type, const uno::Any& Value, const uno::Any& LinkSource ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    CustomPropertiesImpl* pCustomProps = dynamic_cast< CustomPropertiesImpl* > ( m_xIndexAccess.get() );
+    uno::Reference< XDocumentProperty > xDocProp;
+    if ( pCustomProps )
+    {
+        rtl::OUString sLinkSource;
+        pCustomProps->addProp( Name, Type, Value );
+
+        xDocProp.set( m_xNameAccess->getByName( Name ), uno::UNO_QUERY_THROW );
+        xDocProp->setLinkToContent( LinkToContent );
+
+        if ( LinkSource >>= sLinkSource )
+           xDocProp->setLinkSource( sLinkSource );
+    }
+    return xDocProp;
+}
+
+// XHelperInterface
+rtl::OUString& 
+SwVbaCustomDocumentProperties::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaCustomDocumentProperties") );
+    return sImplName;    
+}
Index: sw/source/ui/vba/vbatable.hxx
===================================================================
--- sw/source/ui/vba/vbatable.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatable.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,28 @@
+#ifndef SW_VBA_TABLE_HXX
+#define SW_VBA_TABLE_HXX
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <ooo/vba/word/XRange.hpp>
+#include <ooo/vba/word/XTable.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XTable > SwVbaTable_BASE;
+
+class SwVbaTable : public SwVbaTable_BASE
+{
+    css::uno::Reference< css::text::XTextDocument > mxTextDocument;
+    css::uno::Reference< css::text::XTextTable > mxTextTable;
+public:
+    SwVbaTable( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::text::XTextDocument >& rDocument, const css::uno::Reference< css::text::XTextTable >& xTextTable) throw ( css::uno::RuntimeException);
+    css::uno::Reference< css::text::XTextDocument > getDocument() { return mxTextDocument; };
+    virtual css::uno::Reference< ::ooo::vba::word::XRange > SAL_CALL Range(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual void SAL_CALL Select(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XRange > SAL_CALL ConvertToText( const css::uno::Any& Separator, const css::uno::Any& NestedTables ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getName( ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Borders( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();  
+};
+#endif
Index: sw/source/ui/vba/vbasections.hxx
===================================================================
--- sw/source/ui/vba/vbasections.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasections.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_SECTIONS_HXX
+#define SW_VBA_SECTIONS_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XSections.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XSections > SwVbaSections_BASE;
+
+class SwVbaSections : public SwVbaSections_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaSections( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaSections() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+    virtual css::uno::Any SAL_CALL PageSetup(  ) throw (css::uno::RuntimeException);
+
+	// SwVbaSections_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_SECTIONS_HXX */
Index: sw/source/ui/vba/vbapalette.cxx
===================================================================
--- sw/source/ui/vba/vbapalette.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapalette.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,75 @@
+#include "vbapalette.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/word/WdColor.hpp>
+#include <ooo/vba/word/WdColorIndex.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::ooo::vba::word;
+using namespace ::com::sun::star;
+
+static const sal_Int32 ColorTable[] =
+{
+WdColor::wdColorAutomatic, // 0
+WdColor::wdColorBlack,             // 1
+WdColor::wdColorBlue,               // 2 
+WdColor::wdColorTurquoise,     // 3
+WdColor::wdColorBrightGreen, // 4
+WdColor::wdColorPink,               // 5
+WdColor::wdColorRed,                 // 6
+WdColor::wdColorYellow,           // 7
+WdColor::wdColorWhite,             // 8
+WdColor::wdColorDarkBlue,       // 9
+WdColor::wdColorTeal,               // 10
+WdColor::wdColorGreen,             // 11
+WdColor::wdColorViolet,           // 12
+WdColor::wdColorDarkRed,         // 13
+WdColor::wdColorDarkYellow,   // 14
+WdColor::wdColorGray50,           // 15
+WdColor::wdColorGray25,           // 16
+};
+
+typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
+
+class DefaultPalette : public XIndexAccess_BASE
+{
+public:
+   DefaultPalette(){}
+
+    // Methods XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
+    {
+        return sizeof(ColorTable) / sizeof(ColorTable[0]);
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+	if ( Index < 0 || Index >= getCount() )
+		throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( sal_Int32( ColorTable[ Index ] ) );
+    }
+
+    // Methods XElementAcess
+    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (sal_Int32*)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+
+};
+
+VbaPalette::VbaPalette()
+{
+    mxPalette = new DefaultPalette();
+}
+
+uno::Reference< container::XIndexAccess >
+VbaPalette::getPalette() const
+{
+
+	return mxPalette;	
+}
+
Index: sw/source/ui/vba/vbaoptions.hxx
===================================================================
--- sw/source/ui/vba/vbaoptions.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaoptions.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbasystem.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_OPTIONS_HXX
+#define SW_VBA_OPTIONS_HXX
+
+#include <ooo/vba/word/XOptions.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbapropvalue.hxx>
+#include <comphelper/processfactory.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XOptions > SwVbaOptions_BASE;
+
+class SwVbaOptions : public SwVbaOptions_BASE, 
+                    public PropListener
+{
+private:
+    rtl::OUString msDefaultFilePath;
+    css::uno::Reference< css::lang::XMultiServiceFactory > mxFactory;
+public:
+	SwVbaOptions( css::uno::Reference< css::uno::XComponentContext >& m_xContext ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaOptions();
+
+    // Attributes
+    virtual ::sal_Int32 SAL_CALL getDefaultBorderLineStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDefaultBorderLineStyle( ::sal_Int32 _defaultborderlinestyle ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getDefaultBorderLineWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDefaultBorderLineWidth( ::sal_Int32 _defaultborderlinewidth ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getDefaultBorderColorIndex() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDefaultBorderColorIndex( ::sal_Int32 _defaultbordercolorindex ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getReplaceSelection() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setReplaceSelection( ::sal_Bool _replaceselection ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getMapPaperSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMapPaperSize( ::sal_Bool _mappapersize ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatAsYouTypeApplyHeadings() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatAsYouTypeApplyHeadings( ::sal_Bool _autoformatasyoutypeapplyheadings ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatAsYouTypeApplyBulletedLists() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatAsYouTypeApplyBulletedLists( ::sal_Bool _autoformatasyoutypeapplybulletedlists ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatAsYouTypeApplyNumberedLists() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatAsYouTypeApplyNumberedLists( ::sal_Bool _autoformatasyoutypeapplynumberedlists ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatAsYouTypeFormatListItemBeginning() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatAsYouTypeFormatListItemBeginning( ::sal_Bool _autoformatasyoutypeformatlistitembeginning ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatAsYouTypeDefineStyles() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatAsYouTypeDefineStyles( ::sal_Bool _autoformatasyoutypedefinestyles ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatApplyHeadings() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatApplyHeadings( ::sal_Bool _autoformatapplyheadings ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatApplyLists() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatApplyLists( ::sal_Bool _autoformatapplylists ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoFormatApplyBulletedLists() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoFormatApplyBulletedLists( ::sal_Bool _autoformatapplybulletedlists ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual css::uno::Any SAL_CALL DefaultFilePath( sal_Int32 _path ) throw ( css::uno::RuntimeException );
+
+    //PropListener
+    virtual void setValueEvent( const css::uno::Any& value );
+    virtual css::uno::Any getValueEvent();
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_OPTIONS_HXX */
Index: sw/source/ui/vba/vbadocuments.cxx
===================================================================
--- sw/source/ui/vba/vbadocuments.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocuments.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,200 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadocuments.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <comphelper/processfactory.hxx>
+
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase3.hxx>
+
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/frame/XComponentLoader.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/FrameSearchFlag.hpp>
+#include <com/sun/star/util/XModifiable.hpp>
+#include <com/sun/star/frame/XStorable.hpp>
+#include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/beans/PropertyVetoException.hpp>
+#include <com/sun/star/util/XCloseable.hpp>
+#include <com/sun/star/lang/IndexOutOfBoundsException.hpp>
+#include <com/sun/star/document/XTypeDetection.hpp>
+#include <com/sun/star/uri/XUriReference.hpp>
+#include <com/sun/star/uri/XUriReferenceFactory.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <tools/urlobj.hxx>
+
+#include "vbaglobals.hxx"
+#include "vbadocument.hxx"
+#include "vbadocuments.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+#include <hash_map>
+#include <osl/file.hxx>
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static uno::Any
+getDocument( uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< text::XTextDocument > &xDoc, const uno::Any& aApplication )
+{
+	// FIXME: fine as long as SwVbaDocument is stateless ...
+	uno::Reference< frame::XModel > xModel( xDoc, uno::UNO_QUERY );
+	if( !xModel.is() )
+		return uno::Any();
+	
+	SwVbaDocument *pWb = new SwVbaDocument(  uno::Reference< XHelperInterface >( aApplication, uno::UNO_QUERY_THROW ), xContext, xModel );
+	return uno::Any( uno::Reference< word::XDocument > (pWb) );
+}
+
+class DocumentEnumImpl : public EnumerationHelperImpl
+{
+	uno::Any m_aApplication;
+public:
+	DocumentEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration, const uno::Any& aApplication ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), m_aApplication( aApplication ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< text::XTextDocument > xDoc( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return getDocument( m_xContext, xDoc, m_aApplication );
+	}
+};
+
+SwVbaDocuments::SwVbaDocuments( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext ) : SwVbaDocuments_BASE( xParent, xContext, VbaDocumentsBase::WORD_DOCUMENT )
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaDocuments::getElementType() throw (uno::RuntimeException)
+{
+	return word::XDocument::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaDocuments::createEnumeration() throw (uno::RuntimeException)
+{
+	// #FIXME its possible the DocumentEnumImpl here doens't reflect
+	// the state of this object ( although it should ) would be 
+	// safer to create an enumeration based on this objects state
+	// rather than one effectively based of the desktop component
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new DocumentEnumImpl( mxContext, xEnumerationAccess->createEnumeration(), Application() );
+}
+
+uno::Any
+SwVbaDocuments::createCollectionObject( const uno::Any& aSource )
+{
+	uno::Reference< text::XTextDocument > xDoc( aSource, uno::UNO_QUERY_THROW );
+	return getDocument( mxContext, xDoc, Application() );
+}
+
+uno::Any SAL_CALL
+SwVbaDocuments::Add( const uno::Any& Template, const uno::Any& /*NewTemplate*/, const uno::Any& /*DocumentType*/, const uno::Any& /*Visible*/ ) throw (uno::RuntimeException)
+{
+    rtl::OUString sFileName;
+    if( Template.hasValue() && ( Template >>= sFileName ) )
+    {
+        return  Open( sFileName, uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any(), uno::Any());
+    }
+    uno::Reference <text::XTextDocument> xTextDoc( VbaDocumentsBase::Add() , uno::UNO_QUERY_THROW );
+
+    if( xTextDoc.is() )
+        return getDocument( mxContext, xTextDoc, Application() );
+    return uno::Any();
+}
+
+// #TODO# #FIXME# can any of the unused params below be used?
+void SAL_CALL
+SwVbaDocuments::Close( const uno::Any& /*SaveChanges*/, const uno::Any& /*OriginalFormat*/, const uno::Any& /*RouteDocument*/ ) throw (uno::RuntimeException)
+{
+    VbaDocumentsBase::Close();
+}
+
+// #TODO# #FIXME# can any of the unused params below be used?
+uno::Any SAL_CALL
+SwVbaDocuments::Open( const ::rtl::OUString& Filename, const uno::Any& /*ConfirmConversions*/, const uno::Any& ReadOnly, const uno::Any& /*AddToRecentFiles*/, const uno::Any& /*PasswordDocument*/, const uno::Any& /*PasswordTemplate*/, const uno::Any& /*Revert*/, const uno::Any& /*WritePasswordDocument*/, const uno::Any& /*WritePasswordTemplate*/, const uno::Any& /*Format*/, const uno::Any& /*Encoding*/, const uno::Any& /*Visible*/, const uno::Any& /*OpenAndRepair*/, const uno::Any& /*DocumentDirection*/, const uno::Any& /*NoEncodingDialog*/, const uno::Any& /*XMLTransform*/ ) throw (uno::RuntimeException)
+{
+	// we need to detect if this is a URL, if not then assume its a file path
+    rtl::OUString aURL;
+    INetURLObject aObj;
+	aObj.SetURL( Filename );
+	bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+	if ( bIsURL )
+		aURL = Filename;
+	else
+		osl::FileBase::getFileURLFromSystemPath( Filename, aURL );
+
+	uno::Sequence< beans::PropertyValue > sProps(0);
+
+	uno::Reference <text::XTextDocument> xSpreadDoc( VbaDocumentsBase::Open( Filename, ReadOnly, sProps ), uno::UNO_QUERY_THROW );
+	uno::Any aRet = getDocument( mxContext, xSpreadDoc, Application() );
+	uno::Reference< word::XDocument > xDocument( aRet, uno::UNO_QUERY );
+	if ( xDocument.is() )
+		xDocument->Activate();
+	return aRet;
+}
+
+	// VbaDocumentsBase / XDocumentsBase (to avoid warning C4266 for hiding function on wntmsci)
+uno::Any SAL_CALL
+SwVbaDocuments::Add() throw (uno::RuntimeException)
+{
+	return VbaDocumentsBase::Add();
+}
+
+void SAL_CALL
+SwVbaDocuments::Close(  ) throw (uno::RuntimeException)
+{
+	VbaDocumentsBase::Close();
+}
+
+uno::Any SAL_CALL
+SwVbaDocuments::Open( const ::rtl::OUString& Filename, const uno::Any& ReadOnly, const uno::Sequence< beans::PropertyValue >& rProps ) throw (uno::RuntimeException)
+{
+	return VbaDocumentsBase::Open( Filename, ReadOnly, rProps );
+}
+
+rtl::OUString& 
+SwVbaDocuments::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaDocuments") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+SwVbaDocuments::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Documents") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbarangehelper.hxx
===================================================================
--- sw/source/ui/vba/vbarangehelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbarangehelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,46 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_RANGEHELPER_HXX
+#define SW_VBA_RANGEHELPER_HXX
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XText.hpp>
+
+class SwVbaRangeHelper
+{
+public:
+    static css::uno::Reference< css::text::XTextRange > getRangeByPosition( const css::uno::Reference< css::text::XText >& rText, sal_Int32 _position )throw ( css::uno::RuntimeException );
+    static void insertString( css::uno::Reference< css::text::XTextRange >& rTextRange, css::uno::Reference< css::text::XText >& rText, const rtl::OUString& rStr, sal_Bool _bAbsorb ) throw ( css::uno::RuntimeException );
+    static css::uno::Reference< css::text::XTextCursor > initCursor( const css::uno::Reference< css::text::XTextRange >& rTextRange, const css::uno::Reference< css::text::XText >& rText ) throw ( css::uno::RuntimeException );
+    static sal_Int32 getPosition( const css::uno::Reference< css::text::XText >& rText, const css::uno::Reference< css::text::XTextRange >& rTextRange ) throw ( css::uno::RuntimeException );
+
+};
+#endif /* SW_VBA_RANGEHELPER_HXX */
Index: sw/source/ui/vba/vbaaddins.cxx
===================================================================
--- sw/source/ui/vba/vbaaddins.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaaddins.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaaddins.hxx"
+#include "vbaaddin.hxx"
+#include <cppuhelper/implbase3.hxx>
+#include <svtools/pathoptions.hxx>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/ucb/XSimpleFileAccess.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+uno::Reference< container::XIndexAccess > lcl_getAddinCollection( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext )
+{
+    XNamedObjectCollectionHelper< word::XAddin >::XNamedVec maAddins;
+
+    // first get the autoload addins in the directory STARTUP
+    uno::Reference< lang::XMultiComponentFactory > xMCF( xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< ucb::XSimpleFileAccess > xSFA( xMCF->createInstanceWithContext( rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ), xContext), uno::UNO_QUERY_THROW );
+    SvtPathOptions aPathOpt;
+    // FIXME: temporary the STARTUP path is located in $OO/basic3.1/program/addin
+    String aAddinPath = aPathOpt.GetAddinPath();
+    OSL_TRACE("lcl_getAddinCollection: %s", rtl::OUStringToOString( aAddinPath, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if( xSFA->isFolder( aAddinPath ) )
+    {
+        uno::Sequence< rtl::OUString > sEntries = xSFA->getFolderContents( aAddinPath, sal_False );
+        sal_Int32 nEntry = sEntries.getLength();
+        for( sal_Int32 index = 0; index < nEntry; ++index )
+        {
+            rtl::OUString sUrl = sEntries[ index ];
+            if( !xSFA->isFolder( sUrl ) && sUrl.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) )
+            {
+                maAddins.push_back( uno::Reference< word::XAddin >( new SwVbaAddin( xParent, xContext, sUrl, sal_True ) ) );
+            }
+        }
+    }
+
+    // TODO: second get the customize addins in the org.openoffice.Office.Writer/GlobalTemplateList
+
+    uno::Reference< container::XIndexAccess > xAddinsAccess( new XNamedObjectCollectionHelper< word::XAddin >( maAddins ) );
+    return xAddinsAccess;
+}
+
+SwVbaAddins::SwVbaAddins( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext > & xContext ) throw (uno::RuntimeException): SwVbaAddins_BASE( xParent, xContext, lcl_getAddinCollection( xParent,xContext ) )
+{
+}
+// XEnumerationAccess
+uno::Type
+SwVbaAddins::getElementType() throw (uno::RuntimeException)
+{
+	return word::XAddin::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaAddins::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumerationAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaAddins::createCollectionObject( const css::uno::Any& aSource )
+{
+    return aSource;
+}
+
+rtl::OUString& 
+SwVbaAddins::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaAddins") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaAddins::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Addins") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbareplacement.hxx
===================================================================
--- sw/source/ui/vba/vbareplacement.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbareplacement.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_REPLACEMENT_HXX
+#define SW_VBA_REPLACEMENT_HXX
+
+#include <ooo/vba/word/XReplacement.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/util/XPropertyReplace.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XReplacement > SwVbaReplacement_BASE;
+
+class SwVbaReplacement : public SwVbaReplacement_BASE
+{
+private:
+    css::uno::Reference< css::util::XPropertyReplace> mxPropertyReplace;
+
+public:
+	SwVbaReplacement( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::util::XPropertyReplace >& xPropertyReplace ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaReplacement();
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_REPLACEMENT_HXX */
Index: sw/source/ui/vba/vbasection.cxx
===================================================================
--- sw/source/ui/vba/vbasection.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasection.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbasection.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbapagesetup.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaSection::SwVbaSection( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& xProps ) throw ( uno::RuntimeException ) :
+    SwVbaSection_BASE( rParent, rContext ), mxModel( xModel ), mxPageProps( xProps )
+{
+}
+
+SwVbaSection::~SwVbaSection()
+{
+}
+
+::sal_Bool SAL_CALL SwVbaSection::getProtectedForForms() throw (uno::RuntimeException)
+{
+    return sal_False;
+}
+
+void SAL_CALL SwVbaSection::setProtectedForForms( ::sal_Bool /*_protectedforforms*/ ) throw (uno::RuntimeException)
+{
+}
+
+uno::Any SAL_CALL SwVbaSection::Headers(  ) throw (uno::RuntimeException)
+{
+    return uno::Any();
+}
+
+uno::Any SAL_CALL SwVbaSection::Footers(  ) throw (uno::RuntimeException)
+{
+    return uno::Any();
+}
+
+uno::Any SAL_CALL
+SwVbaSection::PageSetup( ) throw (uno::RuntimeException)
+{
+    return uno::makeAny( uno::Reference< word::XPageSetup >( new SwVbaPageSetup( this, mxContext, mxModel, mxPageProps ) ) );
+}
+
+rtl::OUString& 
+SwVbaSection::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaSection") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaSection::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Section" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbastyle.hxx
===================================================================
--- sw/source/ui/vba/vbastyle.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbastyle.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile:  $
+ * $Revision:  $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_STYLE_HXX
+#define SW_VBA_STYLE_HXX
+#include <ooo/vba/word/XStyle.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+#include <ooo/vba/word/XFont.hpp>
+
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XStyle > SwVbaStyle_BASE;
+
+class SwVbaStyle : public SwVbaStyle_BASE
+{
+private:
+	css::uno::Reference< css::beans::XPropertySet > mxStyleProps;
+	css::uno::Reference< css::style::XStyle > mxStyle;
+public:
+	SwVbaStyle( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertySet >& _xPropertySet ) throw ( css::script::BasicErrorException, css::uno::RuntimeException );
+	virtual ~SwVbaStyle(){}
+
+    static void setStyle( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, const css::uno::Reference< ooo::vba::word::XStyle >& xStyle ) throw (css::uno::RuntimeException);
+    static rtl::OUString getOOoStyleTypeFromMSWord( sal_Int32 _wdStyleType );
+    static sal_Int32 getLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps ) throw (css::uno::RuntimeException);
+    static void setLanguageID( const css::uno::Reference< css::beans::XPropertySet >& xTCProps, sal_Int32 _languageid ) throw (css::uno::RuntimeException);
+
+    // Attributes
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& Name ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getLanguageID( ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLanguageID( ::sal_Int32 _languageid ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ooo::vba::word::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //SW_VBA_AXIS_HXX
Index: sw/source/ui/vba/vbaparagraph.cxx
===================================================================
--- sw/source/ui/vba/vbaparagraph.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaparagraph.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,177 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaparagraph.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbarange.hxx"
+#include <com/sun/star/lang/XServiceInfo.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaParagraph::SwVbaParagraph( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& xDocument, const uno::Reference< text::XTextRange >& xTextRange ) throw ( uno::RuntimeException ) :
+    SwVbaParagraph_BASE( rParent, rContext ), mxTextDocument( xDocument ), mxTextRange( xTextRange )
+{
+}
+
+SwVbaParagraph::~SwVbaParagraph()
+{
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaParagraph::getRange( ) throw ( uno::RuntimeException )
+{
+    return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, mxTextDocument, mxTextRange->getStart(), mxTextRange->getEnd(), mxTextRange->getText(), sal_True ) );
+}
+
+rtl::OUString& 
+SwVbaParagraph::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaParagraph") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaParagraph::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Paragraph" ) );
+	}
+	return aServiceNames;
+}
+
+
+//typedef ::cppu::WeakImplHelper1< container::XEnumeration > ParagraphEnumeration_BASE;
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > ParagraphCollectionHelper_BASE;
+
+class ParagraphCollectionHelper : public ParagraphCollectionHelper_BASE
+{
+private:
+    uno::Reference< text::XTextDocument > mxTextDocument;
+    
+    uno::Reference< container::XEnumeration > getEnumeration() throw (uno::RuntimeException)
+    {
+        uno::Reference< container::XEnumerationAccess > xParEnumAccess( mxTextDocument->getText(), uno::UNO_QUERY_THROW );
+        return xParEnumAccess->createEnumeration();
+    }
+
+public:
+    ParagraphCollectionHelper( const uno::Reference< text::XTextDocument >& xDocument ) throw (uno::RuntimeException): mxTextDocument( xDocument )
+    {
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  text::XTextRange::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return sal_True; }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        sal_Int32 nCount = 0;
+        uno::Reference< container::XEnumeration > xParEnum = getEnumeration();
+        while( xParEnum->hasMoreElements() )
+        {
+            uno::Reference< lang::XServiceInfo > xServiceInfo( xParEnum->nextElement(), uno::UNO_QUERY_THROW );
+            if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Paragraph") ) ) )
+            {
+                nCount++;
+            }
+        }
+        return nCount;
+    }	
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+        if( Index < getCount() )
+        {
+            sal_Int32 nCount = 0;
+            uno::Reference< container::XEnumeration > xParEnum = getEnumeration();
+            while( xParEnum->hasMoreElements() )
+            {
+                uno::Reference< lang::XServiceInfo > xServiceInfo( xParEnum->nextElement(), uno::UNO_QUERY_THROW );
+                if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Paragraph") ) ) )
+                {
+                    if( Index == nCount )
+                        return uno::makeAny( xServiceInfo );
+                    nCount++;
+                }        
+            }
+        }
+        throw lang::IndexOutOfBoundsException();
+    }
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return getEnumeration();
+    }    
+};
+
+SwVbaParagraphs::SwVbaParagraphs( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< text::XTextDocument >& xDocument ) throw (uno::RuntimeException) : SwVbaParagraphs_BASE( xParent, xContext, new ParagraphCollectionHelper( xDocument ) ), mxTextDocument( xDocument )
+{
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaParagraphs::getElementType() throw (uno::RuntimeException)
+{
+	return word::XParagraph::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaParagraphs::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumerationAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaParagraphs::createCollectionObject( const css::uno::Any& aSource )
+{
+    uno::Reference< text::XTextRange > xTextRange( aSource, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XParagraph >( new SwVbaParagraph( this, mxContext, mxTextDocument, xTextRange ) ) );
+}
+
+rtl::OUString& 
+SwVbaParagraphs::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaParagraphs") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaParagraphs::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Paragraphs") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbawindow.cxx
===================================================================
--- sw/source/ui/vba/vbawindow.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbawindow.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,116 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbawindow.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+#include "vbawindow.hxx"
+#include "vbaglobals.hxx"
+#include "vbadocument.hxx"
+#include "vbaview.hxx"
+#include "vbapanes.hxx"
+#include "vbapane.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+SwVbaWindow::SwVbaWindow( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : WindowImpl_BASE( xParent, xContext, xModel )
+{
+}
+
+SwVbaWindow::SwVbaWindow( uno::Sequence< uno::Any > const & args, uno::Reference< uno::XComponentContext > const & xContext )  
+        : WindowImpl_BASE( args, xContext )
+{
+}
+
+void
+SwVbaWindow::Activate() throw (css::uno::RuntimeException)
+{
+	SwVbaDocument document( uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
+
+	document.Activate();
+}
+
+void
+SwVbaWindow::Close( const uno::Any& SaveChanges, const uno::Any& RouteDocument ) throw (uno::RuntimeException)
+{
+    // FIXME: it is incorrect when there are more than 1 windows
+	SwVbaDocument document( uno::Reference< XHelperInterface >( Application(), uno::UNO_QUERY_THROW ), mxContext, m_xModel );
+    uno::Any FileName;
+	document.Close(SaveChanges, FileName, RouteDocument );
+}
+
+uno::Any SAL_CALL 
+SwVbaWindow::getView() throw (uno::RuntimeException)
+{
+    return uno::makeAny( uno::Reference< word::XView >( new SwVbaView( this,  mxContext, m_xModel ) ) );    
+}
+
+void SAL_CALL SwVbaWindow::setView( const uno::Any& _view ) throw (uno::RuntimeException)
+{
+    sal_Int32 nType = 0;
+    if( _view >>= nType )
+    {
+        SwVbaView view( this,  mxContext, m_xModel );
+        view.setType( nType );
+    }    
+}
+
+uno::Any SAL_CALL 
+SwVbaWindow::Panes( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xPanes( new SwVbaPanes( this,  mxContext, m_xModel ) );
+    if(  aIndex.getValueTypeClass() == uno::TypeClass_VOID )
+        return uno::makeAny( xPanes );
+
+    return uno::Any( xPanes->Item( aIndex, uno::Any() ) );    
+}
+
+uno::Any SAL_CALL 
+SwVbaWindow::ActivePane() throw (uno::RuntimeException)
+{
+    return uno::makeAny( uno::Reference< word::XPane >( new SwVbaPane( this,  mxContext, m_xModel ) ) );    
+}
+
+rtl::OUString& 
+SwVbaWindow::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaWindow") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaWindow::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Window" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbabookmark.hxx
===================================================================
--- sw/source/ui/vba/vbabookmark.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbabookmark.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_BOOKMARK_HXX
+#define SW_VBA_BOOKMARK_HXX
+
+#include <ooo/vba/word/XBookmark.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XBookmark > SwVbaBookmark_BASE;
+
+class SwVbaBookmark : public SwVbaBookmark_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::text::XTextContent > mxBookmark;
+    rtl::OUString maName;
+    sal_Bool mbValid;
+
+private:
+    void checkVality() throw ( css::uno::RuntimeException );
+
+public:
+	SwVbaBookmark( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
+        const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rName ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaBookmark();
+
+   // Methods
+    virtual rtl::OUString SAL_CALL getName() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL setName( const rtl::OUString& ) throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL Delete() throw ( css::uno::RuntimeException );
+    virtual void SAL_CALL Select() throw ( css::uno::RuntimeException );
+    virtual css::uno::Any SAL_CALL Range() throw ( css::uno::RuntimeException );
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_BOOKMARK_HXX */
Index: sw/source/ui/vba/vbaview.cxx
===================================================================
--- sw/source/ui/vba/vbaview.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaview.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,425 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaview.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/view/XViewSettingsSupplier.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextTable.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XFootnotesSupplier.hpp>
+#include <com/sun/star/text/XEndnotesSupplier.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XEnumeration.hpp>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <ooo/vba/word/WdSpecialPane.hpp>
+#include <ooo/vba/word/WdViewType.hpp>
+#include <ooo/vba/word/WdSeekView.hpp>
+
+#include "wordvbahelper.hxx"
+#include "vbaheaderfooterhelper.hxx"
+#include <view.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const sal_Int32 DEFAULT_BODY_DISTANCE = 500;
+
+SwVbaView::SwVbaView( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,
+    const uno::Reference< frame::XModel >& rModel ) throw ( uno::RuntimeException ) :
+    SwVbaView_BASE( rParent, rContext ), mxModel( rModel )
+{
+    uno::Reference< frame::XController > xController = mxModel->getCurrentController();
+
+    uno::Reference< text::XTextViewCursorSupplier > xTextViewCursorSupp( xController, uno::UNO_QUERY_THROW );
+    mxViewCursor = xTextViewCursorSupp->getViewCursor();
+
+    uno::Reference< view::XViewSettingsSupplier > xViewSettingSupp( xController, uno::UNO_QUERY_THROW );
+    mxViewSettings.set( xViewSettingSupp->getViewSettings(), uno::UNO_QUERY_THROW );
+}
+
+SwVbaView::~SwVbaView()
+{
+}
+
+::sal_Int32 SAL_CALL 
+SwVbaView::getSeekView() throw (css::uno::RuntimeException)
+{
+    // FIXME: if the view cursor is in table, field, section and frame
+    // handle if the cursor is in table
+    uno::Reference< text::XText > xCurrentText = mxViewCursor->getText();
+    uno::Reference< beans::XPropertySet > xCursorProps( mxViewCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextContent > xTextContent;
+    while( xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TextTable") ) ) >>= xTextContent )
+    {
+        xCurrentText = xTextContent->getAnchor()->getText();
+        xCursorProps.set( xCurrentText->createTextCursor(), uno::UNO_QUERY_THROW );
+    }
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xCurrentText, uno::UNO_QUERY_THROW );
+    rtl::OUString aImplName = xServiceInfo->getImplementationName();
+    if( aImplName.equalsAscii("SwXBodyText") )
+    {
+        return word::WdSeekView::wdSeekMainDocument;
+    }
+    else if( aImplName.equalsAscii("SwXHeadFootText") )
+    {
+        if( HeaderFooterHelper::isHeader( mxModel, xCurrentText ) )
+        {
+            if( HeaderFooterHelper::isFirstPageHeader( mxModel, xCurrentText ) )
+                return word::WdSeekView::wdSeekFirstPageHeader;
+            else if( HeaderFooterHelper::isEvenPagesHeader( mxModel, xCurrentText ) )
+                return word::WdSeekView::wdSeekEvenPagesHeader;
+            else
+                return word::WdSeekView::wdSeekPrimaryHeader;
+        }
+        else
+        {
+            if( HeaderFooterHelper::isFirstPageFooter( mxModel, xCurrentText ) )
+                return word::WdSeekView::wdSeekFirstPageFooter;
+            else if( HeaderFooterHelper::isEvenPagesFooter( mxModel, xCurrentText ) )
+                return word::WdSeekView::wdSeekEvenPagesFooter;
+            else
+                return word::WdSeekView::wdSeekPrimaryFooter;
+        }
+    }
+    else if( aImplName.equalsAscii("SwXFootnote") )
+    {
+        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Endnote") ) ) )
+            return word::WdSeekView::wdSeekEndnotes;
+        else
+            return word::WdSeekView::wdSeekFootnotes;
+    }
+
+    return word::WdSeekView::wdSeekMainDocument;
+}
+
+void SAL_CALL 
+SwVbaView::setSeekView( ::sal_Int32 _seekview ) throw (css::uno::RuntimeException)
+{
+    // FIXME: save the current cursor position, if the cursor is in the main
+    // document, so we can jump back to this position, if the macro sets
+    // the ViewMode back to wdSeekMainDocument
+
+    // if( _seekview == getSeekView() )
+    //    return;
+
+    switch( _seekview )
+    {
+        case word::WdSeekView::wdSeekFirstPageFooter:
+        case word::WdSeekView::wdSeekFirstPageHeader:
+        case word::WdSeekView::wdSeekCurrentPageFooter:
+        case word::WdSeekView::wdSeekCurrentPageHeader:
+        case word::WdSeekView::wdSeekPrimaryFooter:
+        case word::WdSeekView::wdSeekPrimaryHeader:
+        case word::WdSeekView::wdSeekEvenPagesFooter:
+        case word::WdSeekView::wdSeekEvenPagesHeader:
+        {
+            // need to test
+            mxViewCursor->gotoRange( getHFTextRange( _seekview ), sal_False );
+            break;
+        }
+        case word::WdSeekView::wdSeekFootnotes:
+        {
+            uno::Reference< text::XFootnotesSupplier > xFootnotesSupp( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xFootnotes( xFootnotesSupp->getFootnotes(), uno::UNO_QUERY_THROW );
+            if( xFootnotes->getCount() > 0 )
+            {
+                uno::Reference< text::XText > xText( xFootnotes->getByIndex(0), uno::UNO_QUERY_THROW );
+                mxViewCursor->gotoRange( xText->getStart(), sal_False );
+            }
+            else
+            {
+                DebugHelper::exception( SbERR_NO_ACTIVE_OBJECT, rtl::OUString() );
+            }
+            break;
+        }
+        case word::WdSeekView::wdSeekEndnotes:
+        {
+            uno::Reference< text::XEndnotesSupplier > xEndnotesSupp( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< container::XIndexAccess > xEndnotes( xEndnotesSupp->getEndnotes(), uno::UNO_QUERY_THROW );
+            if( xEndnotes->getCount() > 0 )
+            {
+                uno::Reference< text::XText > xText( xEndnotes->getByIndex(0), uno::UNO_QUERY_THROW );
+                mxViewCursor->gotoRange( xText->getStart(), sal_False );
+            }
+            else
+            {
+                DebugHelper::exception( SbERR_NO_ACTIVE_OBJECT, rtl::OUString() );
+            }
+            break;
+        }
+        case word::WdSeekView::wdSeekMainDocument:
+        {
+            uno::Reference< text::XTextDocument > xTextDocument( mxModel, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XText > xText = xTextDocument->getText();
+            mxViewCursor->gotoRange( getFirstObjectPosition( xText ), sal_False );
+            break;
+        }
+    }
+}
+
+::sal_Int32 SAL_CALL 
+SwVbaView::getSplitSpecial() throw (css::uno::RuntimeException)
+{
+    return word::WdSpecialPane::wdPaneNone;
+}
+
+void SAL_CALL 
+SwVbaView::setSplitSpecial( ::sal_Int32/* _splitspecial */) throw (css::uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+::sal_Bool SAL_CALL 
+SwVbaView::getTableGridLines() throw (css::uno::RuntimeException)
+{
+    sal_Bool bShowTableGridLine = sal_False;
+    mxViewSettings->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShowTableBoundaries"))) >>= bShowTableGridLine;
+    return bShowTableGridLine;
+}
+
+void SAL_CALL 
+SwVbaView::setTableGridLines( ::sal_Bool _tablegridlines ) throw (css::uno::RuntimeException)
+{
+    mxViewSettings->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShowTableBoundaries")), uno::makeAny( _tablegridlines ) );
+}
+
+::sal_Int32 SAL_CALL 
+SwVbaView::getType() throw (css::uno::RuntimeException)
+{
+    // FIXME: handle wdPrintPreview type
+    sal_Bool bOnlineLayout = sal_False;
+    mxViewSettings->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShowOnlineLayout"))) >>= bOnlineLayout;
+    return bOnlineLayout ? word::WdViewType::wdWebView : word::WdViewType::wdPrintView;
+}
+
+void SAL_CALL 
+SwVbaView::setType( ::sal_Int32 _type ) throw (css::uno::RuntimeException)
+{
+    // FIXME: handle wdPrintPreview type
+    switch( _type )
+    {
+        case word::WdViewType::wdPrintView:
+        case word::WdViewType::wdNormalView:
+        {
+            mxViewSettings->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShowOnlineLayout")), uno::makeAny( sal_False ) );
+            break;
+        }
+        case word::WdViewType::wdWebView:
+        {
+            mxViewSettings->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ShowOnlineLayout")), uno::makeAny( sal_True ) );
+            break;
+        }
+        case word::WdViewType::wdPrintPreview:
+        {
+            PrintPreviewHelper( uno::Any(),word::getView( mxModel ) ); 
+            break;
+        }
+        default:
+            DebugHelper::exception( SbERR_NOT_IMPLEMENTED, rtl::OUString() );
+            
+    }
+}
+
+uno::Reference< text::XTextRange > SwVbaView::getHFTextRange( sal_Int32 nType ) throw (uno::RuntimeException)
+{
+    mxModel->lockControllers();
+
+    rtl::OUString aPropIsOn;
+    rtl::OUString aPropIsShared;
+    rtl::OUString aPropBodyDistance;
+    rtl::OUString aPropText;
+    
+    switch( nType )
+    {
+        case word::WdSeekView::wdSeekCurrentPageFooter:
+        case word::WdSeekView::wdSeekFirstPageFooter:
+        case word::WdSeekView::wdSeekPrimaryFooter:
+        case word::WdSeekView::wdSeekEvenPagesFooter:
+        {
+            aPropIsOn = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn") );
+            aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsShared") );
+            aPropBodyDistance = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterBodyDistance") );
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterText") );
+            break;
+        }
+        case word::WdSeekView::wdSeekCurrentPageHeader:
+        case word::WdSeekView::wdSeekFirstPageHeader:
+        case word::WdSeekView::wdSeekPrimaryHeader:
+        case word::WdSeekView::wdSeekEvenPagesHeader:
+        {
+            aPropIsOn = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn") );
+            aPropIsShared = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsShared") );
+            aPropBodyDistance = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderBodyDistance") );
+            aPropText = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderText") );
+            break;
+        }
+    }
+
+    uno::Reference< text::XPageCursor > xPageCursor( mxViewCursor, uno::UNO_QUERY_THROW );
+    
+    if( nType == word::WdSeekView::wdSeekFirstPageFooter
+        || nType == word::WdSeekView::wdSeekFirstPageHeader )
+    {
+        xPageCursor->jumpToFirstPage();
+    }
+
+    uno::Reference< style::XStyle > xStyle;
+    uno::Reference< text::XText > xText;
+    switch( nType )
+    {
+        case word::WdSeekView::wdSeekPrimaryFooter:
+        case word::WdSeekView::wdSeekPrimaryHeader:
+        case word::WdSeekView::wdSeekEvenPagesFooter:
+        case word::WdSeekView::wdSeekEvenPagesHeader:
+        {
+            // The primary header is the first header of the section.
+            // If the header is not shared between odd and even pages
+            // the odd page's header is the primary header. If the
+            // first page's header is different from the rest of the
+            // document, it is NOT the primary header ( the next primary
+            // header would be on page 3 )
+            // The even pages' header is only available if the header is
+            // not shared and the current style is applied to a page with
+            // an even page number
+            uno::Reference< beans::XPropertySet > xCursorProps( mxViewCursor, uno::UNO_QUERY_THROW );
+            rtl::OUString aPageStyleName;
+            xCursorProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+            if( aPageStyleName.equalsAscii("First Page") )
+            {
+                // go to the beginning of where the next style is used
+                sal_Bool hasNextPage = sal_False;
+                xStyle = word::getCurrentPageStyle( mxModel );
+                do
+                {
+                    hasNextPage = xPageCursor->jumpToNextPage();
+                }
+                while( hasNextPage && ( xStyle == word::getCurrentPageStyle( mxModel ) ) );
+
+                if( !hasNextPage )
+                    DebugHelper::exception( SbERR_BAD_ACTION, rtl::OUString() );
+            }
+            break;
+        }    
+        default:
+        {
+            break;
+        }
+    }    
+
+    xStyle = word::getCurrentPageStyle( mxModel );
+    uno::Reference< beans::XPropertySet > xPageProps( xStyle, uno::UNO_QUERY_THROW );
+    sal_Bool isOn = sal_False;
+    xPageProps->getPropertyValue( aPropIsOn ) >>= isOn;
+    sal_Bool isShared =  sal_False;
+    xPageProps->getPropertyValue( aPropIsShared ) >>= isShared;
+    if( !isOn )
+    {
+        xPageProps->setPropertyValue( aPropIsOn, uno::makeAny( sal_True ) );
+        xPageProps->setPropertyValue( aPropBodyDistance, uno::makeAny( DEFAULT_BODY_DISTANCE ) );
+    }
+    if( !isShared )
+    {
+        rtl::OUString aTempPropText = aPropText;
+        if( nType == word::WdSeekView::wdSeekEvenPagesFooter
+            || nType == word::WdSeekView::wdSeekEvenPagesHeader )
+        {
+            aTempPropText += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Left") );
+        }
+        else
+        {
+            aTempPropText += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Right") );
+        }
+        xText.set( xPageProps->getPropertyValue( aTempPropText), uno::UNO_QUERY_THROW );
+    }
+    else
+    {
+        if( nType == word::WdSeekView::wdSeekEvenPagesFooter
+            || nType == word::WdSeekView::wdSeekEvenPagesHeader )
+        {
+            DebugHelper::exception( SbERR_BAD_ACTION, rtl::OUString() );
+        }
+        xText.set( xPageProps->getPropertyValue( aPropText ), uno::UNO_QUERY_THROW );
+    }
+
+    mxModel->unlockControllers();
+    if( !xText.is() )
+    {
+        DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
+    }
+    uno::Reference< text::XTextRange > xTextRange = getFirstObjectPosition( xText );
+    return xTextRange;
+}
+
+uno::Reference< text::XTextRange > SwVbaView::getFirstObjectPosition( const uno::Reference< text::XText >& xText ) throw (uno::RuntimeException)
+{
+    // if the first object is table, get the position of first cell 
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< container::XEnumerationAccess > xParaAccess( xText, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XEnumeration> xParaEnum = xParaAccess->createEnumeration();
+    if( xParaEnum->hasMoreElements() )
+    {
+        uno::Reference< lang::XServiceInfo > xServiceInfo( xParaEnum->nextElement(), uno::UNO_QUERY_THROW );
+        if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextTable") ) ) )
+        {
+            uno::Reference< table::XCellRange > xCellRange( xServiceInfo, uno::UNO_QUERY_THROW );
+            uno::Reference< text::XText> xFirstCellText( xCellRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+            xTextRange = xFirstCellText->getStart();
+        }
+    }
+    if( !xTextRange.is() )
+        xTextRange = xText->getStart();
+    return xTextRange;
+}
+
+rtl::OUString& 
+SwVbaView::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaView") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaView::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.View" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbaheaderfooterhelper.hxx
===================================================================
--- sw/source/ui/vba/vbaheaderfooterhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaheaderfooterhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_WORD_VBA_HEADERFOOTERHELPER_HXX
+#define SW_WORD_VBA_HEADERFOOTERHELPER_HXX
+
+#include <vbahelper/vbahelper.hxx>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XPageCursor.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+
+class HeaderFooterHelper
+{
+public:
+    static sal_Bool isHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isFirstPageFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isEvenPagesFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryHeader( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+    static sal_Bool isPrimaryFooter( const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::text::XText >& xCurrentText ) throw (css::uno::RuntimeException);
+};
+
+#endif
Index: sw/source/ui/vba/vbadocument.cxx
===================================================================
--- sw/source/ui/vba/vbadocument.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadocument.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,384 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadocument.cxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbadocument.hxx"
+#include "vbarange.hxx"
+#include "vbarangehelper.hxx"
+#include "vbadocumentproperties.hxx"
+#include "vbabookmarks.hxx"
+#include "vbavariables.hxx"
+#include <com/sun/star/text/XBookmarksSupplier.hpp>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+#include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <com/sun/star/form/XFormsSupplier.hpp>
+#include <ooo/vba/XControlProvider.hpp>
+
+#include <vbahelper/helperdecl.hxx>
+#include <wordvbahelper.hxx>
+#include <docsh.hxx>
+#include "vbatemplate.hxx"
+#include "vbaparagraph.hxx"
+#include "vbastyles.hxx"
+#include "vbatables.hxx"
+#include "vbafield.hxx"
+#include "vbapagesetup.hxx"
+#include "vbasections.hxx"
+#include <vbahelper/vbashapes.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaDocument::SwVbaDocument( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, uno::Reference< frame::XModel > xModel ): SwVbaDocument_BASE( xParent, xContext, xModel )
+{
+    Initialize();
+}
+SwVbaDocument::SwVbaDocument( uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& xContext ) : SwVbaDocument_BASE( aArgs, xContext )
+{
+    Initialize();
+} 
+
+SwVbaDocument::~SwVbaDocument()
+{
+}
+
+void SwVbaDocument::Initialize()
+{
+    mxTextDocument.set( getModel(), uno::UNO_QUERY_THROW );    
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaDocument::getContent() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xStart = mxTextDocument->getText()->getStart();
+    uno::Reference< text::XTextRange > xEnd;
+    return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, mxTextDocument, xStart, xEnd, sal_True ) );
+}
+
+uno::Reference< word::XRange > SAL_CALL 
+SwVbaDocument::Range( const uno::Any& rStart, const uno::Any& rEnd ) throw ( uno::RuntimeException )
+{
+    if( !rStart.hasValue() && !rEnd.hasValue() )
+        return getContent();
+    
+    sal_Int32 nStart = 0;
+    sal_Int32 nEnd = 0;
+    rStart >>= nStart;
+    rEnd >>= nEnd;
+    nStart--;
+    nEnd--;
+
+    uno::Reference< text::XTextRange > xStart;
+    uno::Reference< text::XTextRange > xEnd;
+    if( nStart != -1 || nEnd != -1 )
+    {
+        if( nStart == -1 )
+            xStart = mxTextDocument->getText()->getStart();
+        else
+            xStart = SwVbaRangeHelper::getRangeByPosition( mxTextDocument->getText(), nStart );
+
+        if( nEnd == -1 )
+            xEnd = mxTextDocument->getText()->getEnd();
+        else
+            xEnd = SwVbaRangeHelper::getRangeByPosition( mxTextDocument->getText(), nEnd );
+    }
+
+    if( !xStart.is() && !xEnd.is() )
+    {
+        try
+        {
+            // FIXME
+            xStart = mxTextDocument->getText()->getStart();
+            xEnd = mxTextDocument->getText()->getEnd();
+        }
+        catch( uno::Exception )
+        {
+            DebugHelper::exception(SbERR_METHOD_FAILED, rtl::OUString());
+        }    
+    }
+    return uno::Reference< word::XRange >( new SwVbaRange( this, mxContext, mxTextDocument, xStart, xEnd ) );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::BuiltInDocumentProperties( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaBuiltinDocumentProperties( mxParent, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::CustomDocumentProperties( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaCustomDocumentProperties( mxParent, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL 
+SwVbaDocument::Bookmarks( const uno::Any& rIndex ) throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XBookmarksSupplier > xBookmarksSupplier( getModel(),uno::UNO_QUERY_THROW );
+    uno::Reference<container::XIndexAccess > xBookmarks( xBookmarksSupplier->getBookmarks(), uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xBookmarksVba( new SwVbaBookmarks( this, mxContext, xBookmarks, getModel() ) );
+    if (  rIndex.getValueTypeClass() == uno::TypeClass_VOID )
+        return uno::makeAny( xBookmarksVba );
+    
+    return uno::Any( xBookmarksVba->Item( rIndex, uno::Any() ) );
+}
+
+uno::Any SAL_CALL 
+SwVbaDocument::Variables( const uno::Any& rIndex ) throw ( uno::RuntimeException )
+{
+    uno::Reference< document::XDocumentPropertiesSupplier > xDocumentPropertiesSupplier( getModel(),uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentProperties > xDocumentProperties =  xDocumentPropertiesSupplier->getDocumentProperties();
+    uno::Reference< beans::XPropertyAccess > xUserDefined( xDocumentProperties->getUserDefinedProperties(), uno::UNO_QUERY_THROW );
+
+    uno::Reference< XCollection > xVariables( new SwVbaVariables( this, mxContext, xUserDefined ) );
+    if (  rIndex.getValueTypeClass() == uno::TypeClass_VOID )
+        return uno::makeAny( xVariables );
+    
+    return uno::Any( xVariables->Item( rIndex, uno::Any() ) );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Paragraphs( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaParagraphs( mxParent, mxContext, mxTextDocument ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Styles( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaStyles( mxParent, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Fields( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaFields( mxParent, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Shapes( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( getModel(), uno::UNO_QUERY_THROW );
+    //uno::Reference< drawing::XShapes > xShapes( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xCol( new ScVbaShapes( this, mxContext, xIndexAccess, xModel ) );
+
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::Sections( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaSections( mxParent, mxContext, getModel() ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaDocument::PageSetup( ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xPageProps( word::getCurrentPageStyle( mxModel ), uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XPageSetup >( new SwVbaPageSetup( this, mxContext, mxModel, xPageProps ) ) );
+}
+
+rtl::OUString& 
+SwVbaDocument::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaDocument") );
+	return sImplName;
+}
+uno::Any SAL_CALL 
+SwVbaDocument::getAttachedTemplate() throw (uno::RuntimeException)
+{
+    uno::Reference< word::XTemplate > xTemplate;
+    uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( getModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+    rtl::OUString sTemplateName = xDocProps->getTemplateName();
+
+    xTemplate = new SwVbaTemplate( this, mxContext, getModel(), sTemplateName );
+    return uno::makeAny( xTemplate );
+}
+
+void SAL_CALL 
+SwVbaDocument::setAttachedTemplate( const css::uno::Any& /*_attachedtemplate*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException();
+}
+
+uno::Any SAL_CALL 
+SwVbaDocument::Tables( const css::uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< XCollection > xColl( new SwVbaTables( mxParent, mxContext, xModel ) );
+    
+    if ( aIndex.hasValue() )
+        return xColl->Item( aIndex, uno::Any() );
+    return uno::makeAny( xColl );
+}
+
+void SAL_CALL SwVbaDocument::Activate() throw (uno::RuntimeException)
+{
+    VbaDocumentBase::Activate();
+}
+
+uno::Any
+SwVbaDocument::getControlShape( const ::rtl::OUString& sName )
+{
+    uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+
+    sal_Int32 nCount = xIndexAccess->getCount();
+    for( int index = 0; index < nCount; index++ )
+    {
+        uno::Any aUnoObj =  xIndexAccess->getByIndex( index );
+        // It seems there are some drawing objects that can not query into Control shapes?
+        uno::Reference< drawing::XControlShape > xControlShape( aUnoObj, uno::UNO_QUERY );
+        if( xControlShape.is() )
+        {
+     	    uno::Reference< container::XNamed > xNamed( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+            if( sName.equals( xNamed->getName() ))
+            {
+                return aUnoObj;
+            }
+        }
+    }
+    return uno::Any();
+}
+
+uno::Reference< beans::XIntrospectionAccess > SAL_CALL 
+SwVbaDocument::getIntrospection(  ) throw (uno::RuntimeException)
+{
+	return uno::Reference< beans::XIntrospectionAccess >();
+}
+
+uno::Any SAL_CALL 
+SwVbaDocument::invoke( const ::rtl::OUString& aFunctionName, const uno::Sequence< uno::Any >& /*aParams*/, uno::Sequence< ::sal_Int16 >& /*aOutParamIndex*/, uno::Sequence< uno::Any >& /*aOutParam*/ ) throw (lang::IllegalArgumentException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	OSL_TRACE("** SwVbaDocument::invoke( %s ), will barf",
+		rtl::OUStringToOString( aFunctionName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	
+	throw uno::RuntimeException(); // unsupported operation
+}
+
+void SAL_CALL 
+SwVbaDocument::setValue( const ::rtl::OUString& /*aPropertyName*/, const uno::Any& /*aValue*/ ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	throw uno::RuntimeException(); // unsupported operation
+}
+uno::Any SAL_CALL 
+SwVbaDocument::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::UnknownPropertyException, uno::RuntimeException)
+{
+    uno::Reference< drawing::XControlShape > xControlShape( getControlShape( aPropertyName ), uno::UNO_QUERY_THROW );
+    
+    uno::Reference<lang::XMultiComponentFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< XControlProvider > xControlProvider( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.ControlProvider" ) ), mxContext ), uno::UNO_QUERY_THROW );
+    uno::Reference< msforms::XControl > xControl( xControlProvider->createControl(  xControlShape, getModel() ) );
+    return uno::makeAny( xControl );
+}
+
+::sal_Bool SAL_CALL 
+SwVbaDocument::hasMethod( const ::rtl::OUString& /*aName*/ ) throw (uno::RuntimeException)
+{
+	return sal_False;
+}
+
+::sal_Bool SAL_CALL 
+SwVbaDocument::hasProperty( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+{
+	uno::Reference< container::XNameAccess > xFormControls( getFormControls() );
+	if ( xFormControls.is() )
+		return xFormControls->hasByName( aName );
+	return sal_False;
+}
+
+uno::Reference< container::XNameAccess > 
+SwVbaDocument::getFormControls()
+{
+	uno::Reference< container::XNameAccess > xFormControls;
+	try
+	{
+		uno::Reference< drawing::XDrawPageSupplier > xDrawPageSupplier( mxTextDocument, uno::UNO_QUERY_THROW );
+		uno::Reference< form::XFormsSupplier >  xFormSupplier( xDrawPageSupplier->getDrawPage(), uno::UNO_QUERY_THROW );
+    		uno::Reference< container::XIndexAccess > xIndexAccess( xFormSupplier->getForms(), uno::UNO_QUERY_THROW );
+		// get the www-standard container ( maybe we should access the 
+		// 'www-standard' by name rather than index, this seems an
+		// implementation detail
+		xFormControls.set( xIndexAccess->getByIndex(0), uno::UNO_QUERY_THROW );
+	}
+	catch( uno::Exception& )
+	{
+	}
+	return xFormControls;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaDocument::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Document" ) );
+	}
+	return aServiceNames;
+}
+
+namespace document
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<SwVbaDocument, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SwVbaDocument",
+    "ooo.vba.word.Document" );
+}
+
Index: sw/source/ui/vba/vbatables.hxx
===================================================================
--- sw/source/ui/vba/vbatables.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatables.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,28 @@
+#ifndef SW_VBA_TABLES_HXX
+#define SW_VBA_TABLES_HXX
+
+#include <ooo/vba/word/XTables.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+
+typedef CollTestImplHelper< ov::word::XTables > SwVbaTables_BASE;
+
+class SwVbaTables : public SwVbaTables_BASE
+{
+    css::uno::Reference< css::frame::XModel > mxDocument;
+public:
+    SwVbaTables( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xDocument );
+    // XTables
+    virtual css::uno::Reference< ov::word::XTable > SAL_CALL Add( const css::uno::Reference< ::ooo::vba::word::XRange >& Range, const css::uno::Any& NumRows, const css::uno::Any& NumColumns, const css::uno::Any& DefaultTableBehavior, const css::uno::Any& AutoFitBehavior ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    // ScVbaCollectionBaseImpl      
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();    
+};
+
+#endif
Index: sw/source/ui/vba/vbafind.cxx
===================================================================
--- sw/source/ui/vba/vbafind.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafind.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,431 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbafind.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbareplacement.hxx"
+#include <ooo/vba/word/WdFindWrap.hpp>
+#include <ooo/vba/word/WdReplace.hpp>
+#include <com/sun/star/text/XTextRangeCompare.hpp>
+#include "wordvbahelper.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaFind::SwVbaFind( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< frame::XModel >& xModel, const uno::Reference< text::XTextRange >& xTextRange ) throw ( uno::RuntimeException ) :
+    SwVbaFind_BASE( rParent, rContext ), mxModel( xModel ), mxTextRange( xTextRange ), mbReplace( sal_False ), mnReplaceType( word::WdReplace::wdReplaceOne ), mnWrap( word::WdFindWrap::wdFindStop )
+{
+    mxReplaceable.set( mxModel, uno::UNO_QUERY_THROW );
+    mxPropertyReplace.set( mxReplaceable->createReplaceDescriptor(), uno::UNO_QUERY_THROW );
+    mxTVC = word::getXTextViewCursor( mxModel );
+    mxSelSupp.set( mxModel->getCurrentController(), uno::UNO_QUERY_THROW );
+}
+
+SwVbaFind::~SwVbaFind()
+{
+}
+
+sal_Bool SwVbaFind::InRange( const uno::Reference< text::XTextRange >& xCurrentRange ) throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextRange->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( mxTextRange, xCurrentRange ) >= 0 && xTRC->compareRegionEnds( mxTextRange, xCurrentRange ) <= 0 )
+        return sal_True;
+    return sal_False;
+}
+
+sal_Bool SwVbaFind::InEqualRange( const uno::Reference< text::XTextRange >& xCurrentRange ) throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRangeCompare > xTRC( mxTextRange->getText(), uno::UNO_QUERY_THROW );
+    if( xTRC->compareRegionStarts( mxTextRange, xCurrentRange ) == 0 && xTRC->compareRegionEnds( mxTextRange, xCurrentRange ) == 0 )
+        return sal_True;
+    return sal_False;
+}
+
+void SwVbaFind::SetReplaceWith( const rtl::OUString& rText ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setReplaceString( rText );
+    mbReplace = sal_True;
+}
+
+rtl::OUString SwVbaFind::GetReplaceWith() throw (uno::RuntimeException)
+{
+    return mxPropertyReplace->getReplaceString();
+}
+void SwVbaFind::SetReplace( sal_Int32 type )
+{
+    mnReplaceType = type;
+    mbReplace = sal_True;
+}
+
+rtl::OUString SwVbaFind::ReplaceWildcards( const rtl::OUString& /*rText*/ ) throw ( uno::RuntimeException )
+{
+    // TODO:
+    return rtl::OUString();
+}
+
+uno::Reference< text::XTextRange > SwVbaFind::FindOneElement() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xFoundOne;
+    if( mxTVC->getString().getLength() > 0 )
+    {
+        if( getForward() )
+        {
+            xFoundOne.set( mxReplaceable->findNext( mxTextRange->getStart(), uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+        }
+        else
+        {
+            xFoundOne.set( mxReplaceable->findNext( mxTextRange->getEnd(), uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+        }
+
+        if( xFoundOne.is() && InEqualRange( xFoundOne ) )
+        {
+            xFoundOne.set( mxReplaceable->findNext( xFoundOne, uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+        }
+        else if( xFoundOne.is() && !InRange( xFoundOne ) )
+        {
+            xFoundOne = uno::Reference< text::XTextRange >();
+        }
+    }
+    else
+    {
+        xFoundOne.set( mxReplaceable->findNext( mxTextRange, uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+    }
+
+    if( !xFoundOne.is() && ( getWrap() == word::WdFindWrap::wdFindContinue || getWrap() == word::WdFindWrap::wdFindAsk ) )
+    {
+        if( getForward() )
+        {
+            mxTVC->gotoStart(sal_False);
+            xFoundOne.set( mxReplaceable->findNext( mxTextRange->getStart(), uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+        }    
+        else
+        {
+            mxTVC->gotoEnd( sal_False );
+            xFoundOne.set( mxReplaceable->findNext( mxTextRange->getEnd(), uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) ), uno::UNO_QUERY );
+
+        }
+    }
+    return xFoundOne;
+}
+
+sal_Bool SwVbaFind::SearchReplace() throw (uno::RuntimeException)
+{
+    sal_Bool result = sal_False;
+
+    // TODO: map wildcards in area to OOo wildcards
+
+    if( mbReplace )
+    {
+        switch( mnReplaceType )
+        {
+            case word::WdReplace::wdReplaceNone:
+            {
+                result = sal_True;
+                break;
+            }
+            case word::WdReplace::wdReplaceOne:
+            {
+                uno::Reference< text::XTextRange > xFindOne = FindOneElement();
+                if( xFindOne.is() )
+                {
+                    xFindOne->setString( GetReplaceWith() );
+                    result = mxSelSupp->select( uno::makeAny( xFindOne ) );
+                }
+                break;
+            }
+            case word::WdReplace::wdReplaceAll:
+            {
+                uno::Reference< container::XIndexAccess > xIndexAccess = mxReplaceable->findAll( uno::Reference< util::XSearchDescriptor >( mxPropertyReplace, uno::UNO_QUERY_THROW ) );
+                if( xIndexAccess->getCount() > 0 )
+                {
+                    for( sal_Int32 i = 0; i < xIndexAccess->getCount(); i++ )
+                    {
+                        uno::Reference< text::XTextRange > xTextRange( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                        if( mnWrap == word::WdFindWrap::wdFindContinue || mnWrap == word::WdFindWrap::wdFindAsk || InRange( xTextRange ) )
+                        {
+                            xTextRange->setString( GetReplaceWith() );
+                            result = sal_True;
+                        }
+                    }
+                }
+                break;
+            }
+            default:
+            {
+                result = sal_False;
+            }
+        }
+    }
+    else
+    {
+        uno::Reference< text::XTextRange > xFindOne = FindOneElement();
+        if( xFindOne.is() )
+            result = mxSelSupp->select( uno::makeAny( xFindOne ) );
+    }
+
+    return result;
+}
+
+::rtl::OUString SAL_CALL SwVbaFind::getText() throw (uno::RuntimeException)
+{
+    return mxPropertyReplace->getSearchString();
+}
+
+void SAL_CALL SwVbaFind::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setSearchString( _text );
+}
+
+uno::Any SAL_CALL SwVbaFind::getReplacement() throw (uno::RuntimeException)
+{
+    return uno::makeAny( uno::Reference< word::XReplacement >( new SwVbaReplacement( this, mxContext, mxPropertyReplace ) ) );
+}
+
+void SAL_CALL SwVbaFind::setReplacement( const uno::Any& /*_replacement */ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getForward() throw (uno::RuntimeException)
+{
+    sal_Bool bBackward = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchBackwards") ) ) >>= bBackward;
+    return !bBackward;
+}
+
+void SAL_CALL SwVbaFind::setForward( ::sal_Bool _forward ) throw (uno::RuntimeException)
+{
+    sal_Bool bBackward = !_forward;
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchBackwards") ), uno::makeAny( bBackward ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaFind::getWrap() throw (uno::RuntimeException)
+{
+    // seems not supported in Writer
+    return mnWrap;
+}
+
+void SAL_CALL SwVbaFind::setWrap( ::sal_Int32 _wrap ) throw (uno::RuntimeException)
+{
+    // seems not supported in Writer
+    mnWrap = _wrap;
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getFormat() throw (uno::RuntimeException)
+{
+    return mxPropertyReplace->getValueSearch();
+}
+
+void SAL_CALL SwVbaFind::setFormat( ::sal_Bool _format ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setValueSearch( _format );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getMatchCase() throw (uno::RuntimeException)
+{
+    sal_Bool value = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchCaseSensitive") ) ) >>= value;
+    return value;
+}
+
+void SAL_CALL SwVbaFind::setMatchCase( ::sal_Bool _matchcase ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchCaseSensitive") ), uno::makeAny( _matchcase ) );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getMatchWholeWord() throw (uno::RuntimeException)
+{
+    sal_Bool value = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchWords") ) ) >>= value;
+    return value;
+}
+
+void SAL_CALL SwVbaFind::setMatchWholeWord( ::sal_Bool _matchwholeword ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchWords") ), uno::makeAny( _matchwholeword ) );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getMatchWildcards() throw (uno::RuntimeException)
+{
+    sal_Bool value = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchRegularExpression") ) ) >>= value;
+    return value;
+}
+
+void SAL_CALL SwVbaFind::setMatchWildcards( ::sal_Bool _matchwildcards ) throw (uno::RuntimeException)
+{
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchRegularExpression") ), uno::makeAny( _matchwildcards ) );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getMatchSoundsLike() throw (uno::RuntimeException)
+{
+    sal_Bool value = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarity") ) ) >>= value;
+    return value;
+}
+
+void SAL_CALL SwVbaFind::setMatchSoundsLike( ::sal_Bool _matchsoundslike ) throw (uno::RuntimeException)
+{
+    // seems not accurate
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarity") ), uno::makeAny( _matchsoundslike ) );
+}
+
+::sal_Bool SAL_CALL SwVbaFind::getMatchAllWordForms() throw (uno::RuntimeException)
+{
+    sal_Bool value = sal_False;
+    mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarity") ) ) >>= value;
+    if( value )
+        mxPropertyReplace->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarityRelax") ) ) >>= value;
+    return value;
+}
+
+void SAL_CALL SwVbaFind::setMatchAllWordForms( ::sal_Bool _matchallwordforms ) throw (uno::RuntimeException)
+{
+    // seems not accurate
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarity") ), uno::makeAny( _matchallwordforms ) );
+    mxPropertyReplace->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SearchSimilarityRelax") ), uno::makeAny( _matchallwordforms ) );
+}
+
+uno::Any SAL_CALL SwVbaFind::getStyle() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL SwVbaFind::setStyle( const uno::Any& /*_style */ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+sal_Bool SAL_CALL 
+SwVbaFind::Execute( const uno::Any& FindText, const uno::Any& MatchCase, const uno::Any& MatchWholeWord, const uno::Any& MatchWildcards, const uno::Any& MatchSoundsLike, const uno::Any& MatchAllWordForms, const uno::Any& Forward, const uno::Any& Wrap, const uno::Any& Format, const uno::Any& ReplaceWith, const uno::Any& Replace, const uno::Any& /*MatchKashida*/, const uno::Any& /*MatchDiacritics*/, const uno::Any& /*MatchAlefHamza*/, const uno::Any& /*MatchControl*/, const uno::Any& /*MatchPrefix*/, const uno::Any& /*MatchSuffix*/, const uno::Any& /*MatchPhrase*/, const uno::Any& /*IgnoreSpace*/, const uno::Any& /*IgnorePunct*/ ) throw (uno::RuntimeException)
+{
+    sal_Bool result = sal_False;
+    if( FindText.hasValue() )
+    {
+        rtl::OUString sText;
+        FindText >>= sText;
+        setText( sText );
+    }
+
+    sal_Bool bValue = sal_False;
+    if( MatchCase.hasValue() )
+    {
+        MatchCase >>= bValue;
+        setMatchCase( bValue );
+    }
+
+    if( MatchWholeWord.hasValue() )
+    {
+        MatchWholeWord >>= bValue;
+        setMatchWholeWord( bValue );
+    }
+
+    if( MatchWildcards.hasValue() )
+    {
+        MatchWildcards >>= bValue;
+        setMatchWildcards( bValue );
+    }
+
+    if( MatchSoundsLike.hasValue() )
+    {
+        MatchSoundsLike >>= bValue;
+        setMatchSoundsLike( bValue );
+    }
+
+    if( MatchAllWordForms.hasValue() )
+    {
+        MatchAllWordForms >>= bValue;
+        setMatchAllWordForms( bValue );
+    }
+
+    if( Forward.hasValue() )
+    {
+        Forward >>= bValue;
+        setForward( bValue );
+    }
+
+    if( Wrap.hasValue() )
+    {
+        sal_Int32 nWrapType = 0;
+        Wrap >>= nWrapType;
+        setWrap( nWrapType );
+    }
+
+    if( Format.hasValue() )
+    {
+        Format >>= bValue;
+        setFormat( bValue );
+    }
+
+    if( ReplaceWith.hasValue() )
+    {
+        rtl::OUString sValue;
+        ReplaceWith >>= sValue;
+        SetReplaceWith( sValue );
+    }
+
+    if( Replace.hasValue() )
+    {
+        sal_Int32 nValue(0);
+        Replace >>= nValue;
+        SetReplace( nValue );
+    }
+
+    result = SearchReplace();
+
+    return result;
+}
+
+void SAL_CALL 
+SwVbaFind::ClearFormatting(  ) throw (uno::RuntimeException)
+{
+    uno::Sequence< beans::PropertyValue >  aSearchAttribs;
+    mxPropertyReplace->setSearchAttributes( aSearchAttribs );
+}
+
+rtl::OUString& 
+SwVbaFind::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFind") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaFind::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Find" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbavariable.cxx
===================================================================
--- sw/source/ui/vba/vbavariable.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbavariable.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbavariable.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/PropertyValue.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaVariable::SwVbaVariable( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext,
+    const uno::Reference< beans::XPropertyAccess >& rUserDefined, const rtl::OUString& rName ) throw ( uno::RuntimeException ) :
+    SwVbaVariable_BASE( rParent, rContext ), mxUserDefined( rUserDefined ), maName( rName )
+{
+}
+
+SwVbaVariable::~SwVbaVariable()
+{
+}
+
+rtl::OUString SAL_CALL
+SwVbaVariable::getName() throw ( css::uno::RuntimeException )
+{
+    return maName;
+}
+
+void SAL_CALL
+SwVbaVariable::setName( const rtl::OUString& ) throw ( css::uno::RuntimeException )
+{
+    throw uno::RuntimeException( rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM(" Fail to set name")), uno::Reference< uno::XInterface >() );
+}
+
+uno::Any SAL_CALL
+SwVbaVariable::getValue() throw ( css::uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xProp( mxUserDefined, uno::UNO_QUERY_THROW );
+    return xProp->getPropertyValue( maName );
+}
+
+void SAL_CALL
+SwVbaVariable::setValue( const uno::Any& rValue ) throw ( css::uno::RuntimeException )
+{
+    // FIXME: fail to set the value if the new type of vaue is differenct from the original one.
+    uno::Reference< beans::XPropertySet > xProp( mxUserDefined, uno::UNO_QUERY_THROW );
+    xProp->setPropertyValue( maName, rValue );
+}
+
+sal_Int32 SAL_CALL
+SwVbaVariable::getIndex() throw ( css::uno::RuntimeException )
+{
+    const uno::Sequence< beans::PropertyValue > props = mxUserDefined->getPropertyValues();
+    for (sal_Int32 i = 0; i < props.getLength(); ++i)
+    {
+        if( maName.equals( props[i].Name ) )
+            return i+1;
+    }
+
+    return 0;
+}
+
+rtl::OUString& 
+SwVbaVariable::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaVariable") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaVariable::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Variable" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbawrapformat.hxx
===================================================================
--- sw/source/ui/vba/vbawrapformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbawrapformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbafillformat.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_XWRAPFORMAT_HXX
+#define SW_VBA_XWRAPFORMAT_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <ooo/vba/word/XWrapFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XWrapFormat > SwVbaWrapFormat_BASE;
+
+class SwVbaWrapFormat : public SwVbaWrapFormat_BASE
+{
+private:
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+    sal_Int32 mnWrapFormatType;
+    sal_Int32 mnSide;
+
+private:
+    void makeWrap() throw (css::uno::RuntimeException);
+    float getDistance( const rtl::OUString& sName ) throw (css::uno::RuntimeException);
+    void setDistance( const rtl::OUString& sName, float _distance ) throw (css::uno::RuntimeException);
+
+public:
+    SwVbaWrapFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape > xShape );
+	SwVbaWrapFormat(  css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext );
+
+    virtual ::sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setType( ::sal_Int32 _type ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getSide() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSide( ::sal_Int32 _side ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getDistanceTop() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDistanceTop( float _distancetop ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getDistanceBottom() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDistanceBottom( float _distancebottom ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getDistanceLeft() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDistanceLeft( float _distanceleft ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getDistanceRight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDistanceRight( float _distanceright ) throw (css::uno::RuntimeException);
+
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SW_VBA_XWRAPFORMAT_HXX
Index: sw/source/ui/vba/vbapane.hxx
===================================================================
--- sw/source/ui/vba/vbapane.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapane.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PANE_HXX
+#define SW_VBA_PANE_HXX
+
+#include <ooo/vba/word/XPane.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XPane > SwVbaPane_BASE;
+
+class SwVbaPane : public SwVbaPane_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaPane( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, 
+        const css::uno::Reference< css::frame::XModel >& xModel ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaPane();
+
+    // Methods
+    virtual css::uno::Any SAL_CALL View(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Close(  ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_PANE_HXX */
Index: sw/source/ui/vba/vbabookmarks.cxx
===================================================================
--- sw/source/ui/vba/vbabookmarks.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbabookmarks.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,240 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbabookmarks.hxx"
+#include "vbabookmark.hxx"
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XTextViewCursorSupplier.hpp>
+#include <ooo/vba/word/WdBookmarkSortBy.hpp>
+#include "vbarange.hxx"
+#include "wordvbahelper.hxx"
+#include <cppuhelper/implbase2.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class BookmarksEnumeration : public EnumerationHelperImpl
+{
+	uno::Reference< frame::XModel > mxModel;
+	uno::WeakReference< XHelperInterface > mxParent;
+public:
+	BookmarksEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), mxModel( xModel ), mxParent( xParent ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< container::XNamed > xNamed( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+        rtl::OUString aName = xNamed->getName();
+		return uno::makeAny( uno::Reference< word::XBookmark > ( new SwVbaBookmark( mxParent, m_xContext, mxModel, aName ) ) );
+	}
+
+};
+
+// Bookmarks use case-insensitive name lookup in MS Word.
+typedef ::cppu::WeakImplHelper2< container::XNameAccess, container::XIndexAccess > BookmarkCollectionHelper_BASE;
+class BookmarkCollectionHelper : public BookmarkCollectionHelper_BASE
+{
+private:
+    uno::Reference< container::XNameAccess > mxNameAccess;
+    uno::Reference< container::XIndexAccess > mxIndexAccess;
+    uno::Any cachePos;
+public:
+    BookmarkCollectionHelper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) throw (uno::RuntimeException) : mxIndexAccess( xIndexAccess )
+    {
+        mxNameAccess.set( mxIndexAccess, uno::UNO_QUERY_THROW );
+    }
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException) { return  mxIndexAccess->getElementType(); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) { return mxIndexAccess->hasElements(); }
+	// XNameAcess 
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+		if ( !hasByName(aName) )
+			throw container::NoSuchElementException();
+		return cachePos;
+    }
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+	{
+        return mxNameAccess->getElementNames();
+    }
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+	{
+        if( mxNameAccess->hasByName( aName ) )
+        {
+            cachePos = mxNameAccess->getByName( aName );
+            return sal_True;
+        }
+        else
+        {
+            for( sal_Int32 nIndex = 0; nIndex < mxIndexAccess->getCount(); nIndex++ )
+            {
+                uno::Reference< container::XNamed > xNamed( mxIndexAccess->getByIndex( nIndex ), uno::UNO_QUERY_THROW );
+                rtl::OUString aBookmarkName = xNamed->getName();
+                if( aName.equalsIgnoreAsciiCase( aBookmarkName ) )
+                {
+                    cachePos <<= xNamed;
+                    return sal_True;
+                }
+            }
+        }
+        return sal_False;
+    }
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+    {
+        return mxIndexAccess->getCount();
+    }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+	{
+        return mxIndexAccess->getByIndex( Index );
+    }
+};
+
+SwVbaBookmarks::SwVbaBookmarks( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xBookmarks, const uno::Reference< frame::XModel >& xModel ): SwVbaBookmarks_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new BookmarkCollectionHelper( xBookmarks ) ) ), mxModel( xModel ) 
+{
+    mxBookmarksSupplier.set( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextDocument > xDocument( mxModel, uno::UNO_QUERY_THROW );
+    // use view cursor to insert bookmark, or it will fail if insert bookmark in table
+    // mxText = xDocument->getText();
+    mxText = word::getXTextViewCursor( mxModel )->getText();
+}
+// XEnumerationAccess
+uno::Type
+SwVbaBookmarks::getElementType() throw (uno::RuntimeException)
+{
+	return word::XBookmark::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaBookmarks::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new BookmarksEnumeration( getParent(), mxContext,xEnumAccess->createEnumeration(), mxModel );
+}
+
+uno::Any
+SwVbaBookmarks::createCollectionObject( const css::uno::Any& aSource )
+{
+	uno::Reference< container::XNamed > xNamed( aSource, uno::UNO_QUERY_THROW );
+    rtl::OUString aName = xNamed->getName();
+    return uno::makeAny( uno::Reference< word::XBookmark > ( new SwVbaBookmark( getParent(), mxContext, mxModel, aName ) ) );
+}
+
+void SwVbaBookmarks::removeBookmarkByName( const rtl::OUString& rName ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextContent > xBookmark( m_xNameAccess->getByName( rName ), uno::UNO_QUERY_THROW );
+    mxText->removeTextContent( xBookmark );
+}
+
+void SwVbaBookmarks::addBookmarkByName( const rtl::OUString& rName, const uno::Reference< text::XTextRange >& rTextRange ) throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XMultiServiceFactory > xDocMSF( mxModel, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextContent > xBookmark( xDocMSF->createInstance(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.Bookmark")) ), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNamed > xNamed( xBookmark, uno::UNO_QUERY_THROW );
+    xNamed->setName( rName );
+    mxText->insertTextContent( rTextRange, xBookmark, sal_False );
+}
+
+uno::Any SAL_CALL
+SwVbaBookmarks::Add( const rtl::OUString& rName, const uno::Any& rRange ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange;
+    uno::Reference< word::XRange > xRange;
+    if( rRange >>= xRange )
+    {
+        SwVbaRange* pRange = dynamic_cast< SwVbaRange* >( xRange.get() );
+        if( pRange )
+            xTextRange = pRange->getXTextRange();
+    }
+    else
+    {
+        // FIXME: insert the bookmark into current view cursor
+        xTextRange.set( word::getXTextViewCursor( mxModel ), uno::UNO_QUERY_THROW );
+    }
+
+    // remove the exist bookmark
+    // rtl::OUString aName = rName.toAsciiLowerCase();
+    rtl::OUString aName = rName;
+    if( m_xNameAccess->hasByName( aName ) )
+        removeBookmarkByName( aName );
+    
+    addBookmarkByName( aName, xTextRange );
+
+    return uno::makeAny( uno::Reference< word::XBookmark >( new SwVbaBookmark( getParent(), mxContext, mxModel, aName ) ) );
+}
+
+sal_Int32 SAL_CALL 
+SwVbaBookmarks::getDefaultSorting() throw (css::uno::RuntimeException)
+{
+    return word::WdBookmarkSortBy::wdSortByName;
+}
+
+void SAL_CALL 
+SwVbaBookmarks::setDefaultSorting( sal_Int32/* _type*/ ) throw (css::uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+sal_Bool SAL_CALL 
+SwVbaBookmarks::getShowHidden() throw (css::uno::RuntimeException)
+{
+    return sal_True;
+}
+
+void SAL_CALL 
+SwVbaBookmarks::setShowHidden( sal_Bool /*_hidden*/ ) throw (css::uno::RuntimeException)
+{
+    // not support in Writer
+}
+
+sal_Bool SAL_CALL 
+SwVbaBookmarks::Exists( const rtl::OUString& rName ) throw (css::uno::RuntimeException)
+{
+    sal_Bool bExist = m_xNameAccess->hasByName( rName );
+    return bExist;
+}
+
+rtl::OUString& 
+SwVbaBookmarks::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaBookmarks") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaBookmarks::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Bookmarks") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbarange.cxx
===================================================================
--- sw/source/ui/vba/vbarange.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbarange.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,348 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbarange.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbarangehelper.hxx"
+#include <ooo/vba/word/WdBreakType.hpp>
+#include <com/sun/star/style/BreakType.hpp>
+#include <com/sun/star/text/ControlCharacter.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include "wordvbahelper.hxx"
+#include "vbaparagraphformat.hxx"
+#include "vbastyle.hxx"
+#include "vbafont.hxx"
+#include "vbapalette.hxx"
+#include "vbapagesetup.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaRange::SwVbaRange( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rTextDocument, const uno::Reference< text::XTextRange >& rStart, sal_Bool _bMaySpanEndOfDocument ) throw (uno::RuntimeException) : SwVbaRange_BASE( rParent, rContext ), mxTextDocument( rTextDocument ), mbMaySpanEndOfDocument( _bMaySpanEndOfDocument )
+{
+    uno::Reference< text::XTextRange > xEnd;
+    initialize( rStart, xEnd );
+}
+
+SwVbaRange::SwVbaRange( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rTextDocument, const uno::Reference< text::XTextRange >& rStart, const uno::Reference< text::XTextRange >& rEnd, sal_Bool _bMaySpanEndOfDocument ) throw (uno::RuntimeException) : SwVbaRange_BASE( rParent, rContext ), mxTextDocument( rTextDocument ), mbMaySpanEndOfDocument( _bMaySpanEndOfDocument )
+{
+    initialize( rStart, rEnd );
+}
+
+SwVbaRange::SwVbaRange( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rTextDocument, const uno::Reference< text::XTextRange >& rStart, const uno::Reference< text::XTextRange >& rEnd, const uno::Reference< text::XText >& rText, sal_Bool _bMaySpanEndOfDocument ) throw (uno::RuntimeException) : SwVbaRange_BASE( rParent, rContext ),mxTextDocument( rTextDocument ), mxText( rText ), mbMaySpanEndOfDocument( _bMaySpanEndOfDocument )
+{
+    initialize( rStart, rEnd );
+}
+
+SwVbaRange::~SwVbaRange()
+{
+}
+
+void SwVbaRange::initialize( const uno::Reference< text::XTextRange >& rStart, const uno::Reference< text::XTextRange >& rEnd ) throw (uno::RuntimeException)
+{
+    if( !mxText.is() )
+    {
+        mxText = mxTextDocument->getText();
+    }    
+    
+    mxTextCursor = SwVbaRangeHelper::initCursor( rStart, mxText );
+    mxTextCursor->collapseToStart();
+
+    if( rEnd.is() )
+        mxTextCursor->gotoRange( rEnd, sal_True );
+    else
+        mxTextCursor->gotoEnd( sal_True );
+}
+
+uno::Reference< text::XTextRange > SAL_CALL
+SwVbaRange::getXTextRange() throw (uno::RuntimeException)
+{
+    uno::Reference< text::XTextRange > xTextRange( mxTextCursor, uno::UNO_QUERY_THROW );
+    return xTextRange;
+}
+
+void SwVbaRange::setXTextRange( const uno::Reference< text::XTextRange >& xRange ) throw (uno::RuntimeException)
+{
+    mxTextCursor->gotoRange( xRange->getStart(), sal_False );
+    mxTextCursor->gotoRange( xRange->getEnd(), sal_True );
+}
+
+/**
+* The complexity in this method is because we need to workaround
+* an issue that the last paragraph in a document does not have a trailing CRLF.
+* @return
+*/
+rtl::OUString SAL_CALL
+SwVbaRange::getText() throw ( uno::RuntimeException )
+{
+    rtl::OUString aText = mxTextCursor->getString();
+    sal_Int32 nLen = aText.getLength();
+
+    // FIXME: should add a line separator if the range includes the last paragraph
+    if( nLen == 0 )
+    {
+        if( mxTextCursor->isCollapsed() )
+        {
+            mxTextCursor->goRight( 1, sal_True );
+            aText = mxTextCursor->getString();
+            mxTextCursor->collapseToStart();
+        }
+        else
+        {
+            uno::Reference< text::XTextRange > xStart = mxTextCursor->getStart();
+            uno::Reference< text::XTextRange > xEnd = mxTextCursor->getEnd();
+            mxTextCursor->collapseToEnd();
+            mxTextCursor->goRight( 1, sal_True );
+            mxTextCursor->gotoRange( xStart, sal_False );
+            mxTextCursor->gotoRange( xEnd, sal_True );
+        }
+    }
+
+    return aText;
+}
+
+void SAL_CALL
+SwVbaRange::setText( const rtl::OUString& rText ) throw ( uno::RuntimeException )
+{
+    if( rText.indexOf( '\n' )  != -1 )
+    {
+        mxTextCursor->setString( rtl::OUString() );
+        // process CR in strings
+        uno::Reference< text::XTextRange > xRange( mxTextCursor, uno::UNO_QUERY_THROW );
+        SwVbaRangeHelper::insertString( xRange, mxText, rText, sal_True );
+    }
+    else
+    {
+        mxTextCursor->setString( rText );
+    }
+}
+
+// FIXME: test is not pass
+void SAL_CALL SwVbaRange::InsertBreak( const uno::Any& _breakType ) throw (uno::RuntimeException)
+{
+    // default type is wdPageBreak;
+    sal_Int32 nBreakType = word::WdBreakType::wdPageBreak;
+    if( _breakType.hasValue() )
+        _breakType >>= nBreakType;
+
+    style::BreakType eBreakType = style::BreakType_NONE;
+    switch( nBreakType )
+    {
+        case word::WdBreakType::wdPageBreak:
+            eBreakType = style::BreakType_PAGE_BEFORE;
+            break;
+        case word::WdBreakType::wdColumnBreak:
+            eBreakType = style::BreakType_COLUMN_AFTER;
+            break;
+        case word::WdBreakType::wdLineBreak:
+        case word::WdBreakType::wdLineBreakClearLeft:
+        case word::WdBreakType::wdLineBreakClearRight:
+        case word::WdBreakType::wdSectionBreakContinuous:
+        case word::WdBreakType::wdSectionBreakEvenPage:
+        case word::WdBreakType::wdSectionBreakNextPage:
+        case word::WdBreakType::wdSectionBreakOddPage:
+        case word::WdBreakType::wdTextWrappingBreak:
+            DebugHelper::exception( SbERR_NOT_IMPLEMENTED, rtl::OUString() );
+            break;
+        default:
+            DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+
+    if( eBreakType != style::BreakType_NONE )
+    {
+        if( !mxTextCursor->isCollapsed() )
+        {
+            mxTextCursor->setString( rtl::OUString() );
+            mxTextCursor->collapseToStart();
+        }
+
+        uno::Reference< beans::XPropertySet > xProp( mxTextCursor, uno::UNO_QUERY_THROW );
+        xProp->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BreakType") ), uno::makeAny( eBreakType ) );
+    }
+}
+
+void SAL_CALL
+SwVbaRange::Select() throw ( uno::RuntimeException )
+{
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    uno::Reference< text::XTextViewCursor > xTextViewCursor = word::getXTextViewCursor( xModel );
+    xTextViewCursor->gotoRange( mxTextCursor->getStart(), sal_False );
+    xTextViewCursor->gotoRange( mxTextCursor->getEnd(), sal_True );
+}
+
+void SAL_CALL
+SwVbaRange::InsertParagraph() throw ( uno::RuntimeException )
+{
+    mxTextCursor->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) );
+    InsertParagraphBefore();
+}
+
+void SAL_CALL
+SwVbaRange::InsertParagraphBefore() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xTextRange = mxTextCursor->getStart();
+    mxText->insertControlCharacter( xTextRange, text::ControlCharacter::PARAGRAPH_BREAK, sal_True );
+    mxTextCursor->gotoRange( xTextRange, sal_True );
+}
+
+void SAL_CALL
+SwVbaRange::InsertParagraphAfter() throw ( uno::RuntimeException )
+{
+    uno::Reference< text::XTextRange > xTextRange = mxTextCursor->getEnd();
+    mxText->insertControlCharacter( xTextRange, text::ControlCharacter::PARAGRAPH_BREAK, sal_True );
+}
+
+uno::Reference< word::XParagraphFormat > SAL_CALL
+SwVbaRange::getParagraphFormat() throw ( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
+    return uno::Reference< word::XParagraphFormat >( new SwVbaParagraphFormat( this, mxContext, mxTextDocument, xParaProps ) );
+}
+
+void SAL_CALL
+SwVbaRange::setParagraphFormat( const uno::Reference< word::XParagraphFormat >& /*rParagraphFormat*/ ) throw ( uno::RuntimeException )
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+uno::Reference< word::XStyle > SAL_CALL
+SwVbaRange::getStyle() throw ( uno::RuntimeException )
+{
+    rtl::OUString aStyleName;
+    rtl::OUString aStyleType;
+    uno::Reference< beans::XPropertySet > xProp( mxTextCursor, uno::UNO_QUERY_THROW );
+    if( ( xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharStyleName") ) ) >>= aStyleName ) && aStyleName.getLength() )
+    {
+        aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharacterStyles") );
+    }
+    else if( ( xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaStyleName") ) ) >>= aStyleName ) && aStyleName.getLength() )
+    {
+        aStyleType = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParagraphStyles") );
+    }
+    if( aStyleType.getLength() == 0 )
+    {
+        DebugHelper::exception( SbERR_INTERNAL_ERROR, rtl::OUString() );
+    }
+    uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( mxTextDocument, uno::UNO_QUERY_THROW);
+    uno::Reference< container::XNameAccess > xStylesAccess( xStyleSupplier->getStyleFamilies()->getByName( aStyleType ), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xStyleProps( xStylesAccess->getByName( aStyleName ), uno::UNO_QUERY_THROW );
+    return uno::Reference< word::XStyle >( new SwVbaStyle( this, mxContext, xStyleProps ) ); 
+}
+
+void SAL_CALL
+SwVbaRange::setStyle( const uno::Reference< word::XStyle >& rStyle ) throw ( uno::RuntimeException )
+{
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
+    SwVbaStyle::setStyle( xParaProps, rStyle );
+}
+
+uno::Reference< word::XFont > SAL_CALL
+SwVbaRange::getFont() throw ( uno::RuntimeException )
+{
+    VbaPalette aColors;
+    return new SwVbaFont( mxParent, mxContext, aColors.getPalette(), uno::Reference< beans::XPropertySet >( getXTextRange(), uno::UNO_QUERY_THROW ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaRange::getLanguageID() throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
+    return SwVbaStyle::getLanguageID( xParaProps );
+}
+
+void SAL_CALL SwVbaRange::setLanguageID( ::sal_Int32 _languageid ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
+    SwVbaStyle::setLanguageID( xParaProps, _languageid );
+}
+
+uno::Any SAL_CALL
+SwVbaRange::PageSetup( ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xParaProps( mxTextCursor, uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XModel > xModel( mxTextDocument, uno::UNO_QUERY_THROW );
+    rtl::OUString aPageStyleName;
+    xParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyleName"))) >>= aPageStyleName;
+    uno::Reference< style::XStyleFamiliesSupplier > xSytleFamSupp( xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xSytleFamNames( xSytleFamSupp->getStyleFamilies(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XNameAccess > xPageStyles( xSytleFamNames->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("PageStyles") ) ), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xPageProps( xPageStyles->getByName( aPageStyleName ), uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XPageSetup >( new SwVbaPageSetup( this, mxContext, xModel, xPageProps ) ) );
+}
+
+::sal_Int32 SAL_CALL SwVbaRange::getStart() throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = mxTextDocument->getText();
+    return SwVbaRangeHelper::getPosition( xText, mxTextCursor->getStart() );
+}
+
+void SAL_CALL SwVbaRange::setStart( ::sal_Int32 _start ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = mxTextDocument->getText();
+    uno::Reference< text::XTextRange > xStart = SwVbaRangeHelper::getRangeByPosition( xText, _start );
+    uno::Reference< text::XTextRange > xEnd = mxTextCursor->getEnd();
+
+    mxTextCursor->gotoRange( xStart, sal_False );
+    mxTextCursor->gotoRange( xEnd, sal_True );
+}
+
+::sal_Int32 SAL_CALL SwVbaRange::getEnd() throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = mxTextDocument->getText();
+    return SwVbaRangeHelper::getPosition( xText, mxTextCursor->getEnd() );
+}
+
+void SAL_CALL SwVbaRange::setEnd( ::sal_Int32 _end ) throw (uno::RuntimeException)
+{
+    uno::Reference< text::XText > xText = mxTextDocument->getText();
+    uno::Reference< text::XTextRange > xEnd = SwVbaRangeHelper::getRangeByPosition( xText, _end );
+
+    mxTextCursor->collapseToStart();
+    mxTextCursor->gotoRange( xEnd, sal_True );
+}
+
+rtl::OUString& 
+SwVbaRange::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaRange") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaRange::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Range" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbaautotextentry.cxx
===================================================================
--- sw/source/ui/vba/vbaautotextentry.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaautotextentry.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaautotextentry.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "vbarange.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaAutoTextEntry::SwVbaAutoTextEntry( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XAutoTextEntry >& xEntry ) throw ( uno::RuntimeException ) :
+    SwVbaAutoTextEntry_BASE( rParent, rContext ), mxEntry( xEntry )
+{
+}
+
+SwVbaAutoTextEntry::~SwVbaAutoTextEntry()
+{
+}
+
+uno::Reference< word::XRange > SAL_CALL SwVbaAutoTextEntry::Insert( const uno::Reference< word::XRange >& _where, const uno::Any& /*_richtext*/ ) throw ( uno::RuntimeException )
+{
+    SwVbaRange* pWhere = dynamic_cast<SwVbaRange*>( _where.get() );
+    if( pWhere )
+    {
+        uno::Reference< text::XTextRange > xTextRange = pWhere->getXTextRange();
+        xTextRange->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("x") ) ); // set marker
+        uno::Reference< text::XTextRange > xEndMarker = xTextRange->getEnd();
+        xEndMarker->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("x") ) ); // set marker
+        uno::Reference< text::XText > xText = pWhere->getXText();
+        mxEntry->applyTo( xEndMarker->getStart() );
+        uno::Reference< text::XTextCursor > xTC = xText->createTextCursorByRange( xTextRange->getStart() );
+        xTC->goRight( 1, sal_True );
+        xTC->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
+        xEndMarker->setString( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("") ) ); // remove marker
+        xTC->gotoRange( xEndMarker, sal_True );
+        pWhere->setXTextCursor( xTC );
+    }
+    return uno::Reference< word::XRange >( pWhere );
+}
+
+rtl::OUString& 
+SwVbaAutoTextEntry::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaAutoTextEntry") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaAutoTextEntry::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.AutoTextEntry" ) );
+	}
+	return aServiceNames;
+}
+
+
+SwVbaAutoTextEntries::SwVbaAutoTextEntries( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) throw (uno::RuntimeException) : SwVbaAutoTextEntries_BASE( xParent, xContext, xIndexAccess ), mxAutoTextEntryAccess( xIndexAccess )
+{
+}
+
+// XEnumerationAccess
+uno::Type
+SwVbaAutoTextEntries::getElementType() throw (uno::RuntimeException)
+{
+	return word::XAutoTextEntry::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+SwVbaAutoTextEntries::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumerationAccess > xEnumerationAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    return xEnumerationAccess->createEnumeration();
+}
+
+uno::Any
+SwVbaAutoTextEntries::createCollectionObject( const css::uno::Any& aSource )
+{
+    uno::Reference< text::XAutoTextEntry > xEntry( aSource, uno::UNO_QUERY_THROW );
+    return uno::makeAny( uno::Reference< word::XAutoTextEntry >( new SwVbaAutoTextEntry( this, mxContext, xEntry ) ) );
+}
+
+rtl::OUString& 
+SwVbaAutoTextEntries::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaAutoTextEntries") );
+	return sImplName;
+}
+
+css::uno::Sequence<rtl::OUString> 
+SwVbaAutoTextEntries::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > sNames;
+	if ( sNames.getLength() == 0 )
+	{
+		sNames.realloc( 1 );
+		sNames[0] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.AutoTextEntries") );
+	}
+	return sNames;
+}
Index: sw/source/ui/vba/vbadialog.cxx
===================================================================
--- sw/source/ui/vba/vbadialog.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadialog.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialog.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbadialog.hxx"
+#include <ooo/vba/word/WdWordDialog.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+struct WordDialogTable
+{
+    sal_Int32 wdDialog;
+    const sal_Char* ooDialog;
+};
+
+static const WordDialogTable aWordDialogTable[] =
+{
+    { word::WdWordDialog::wdDialogFileNew, ".uno:NewDoc" },
+    { word::WdWordDialog::wdDialogFileOpen, ".uno:Open" },
+    { word::WdWordDialog::wdDialogFilePrint, ".uno:Print" },
+    { word::WdWordDialog::wdDialogFileSaveAs, ".uno:SaveAs" },
+    { 0, 0 }
+};
+
+rtl::OUString 
+SwVbaDialog::mapIndexToName( sal_Int32 nIndex )
+{
+    for( const WordDialogTable* pTable = aWordDialogTable; pTable != NULL; pTable++ )
+    {
+        if( nIndex == pTable->wdDialog )
+        {
+            return rtl::OUString::createFromAscii( pTable->ooDialog );
+        }
+    }
+	return rtl::OUString();
+}
+
+rtl::OUString& 
+SwVbaDialog::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaDialog") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaDialog::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Dialog" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbapagesetup.hxx
===================================================================
--- sw/source/ui/vba/vbapagesetup.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapagesetup.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PAGESETUP_HXX
+#define SW_VBA_PAGESETUP_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/word/XPageSetup.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbapagesetupbase.hxx>
+
+typedef cppu::ImplInheritanceHelper1< VbaPageSetupBase, ooo::vba::word::XPageSetup > SwVbaPageSetup_BASE;
+
+class SwVbaPageSetup :  public SwVbaPageSetup_BASE 
+{
+private:
+    rtl::OUString getStyleOfFirstPage() throw (css::uno::RuntimeException);
+
+public:
+	SwVbaPageSetup( const css::uno::Reference< ooo::vba::XHelperInterface >& xParent, 
+                    const css::uno::Reference< css::uno::XComponentContext >& xContext,
+                    const css::uno::Reference< css::frame::XModel >& xModel, 
+                    const css::uno::Reference< css::beans::XPropertySet >& xProps ) throw (css::uno::RuntimeException); 
+	virtual ~SwVbaPageSetup(){}
+
+    // Attributes
+    virtual double SAL_CALL getGutter() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setGutter( double _gutter ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getHeaderDistance() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeaderDistance( double _headerdistance ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getFooterDistance() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFooterDistance( double _footerdistance ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getDifferentFirstPageHeaderFooter() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDifferentFirstPageHeaderFooter( sal_Bool status ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getSectionStart() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSectionStart( ::sal_Int32 _sectionstart ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif
Index: sw/source/ui/vba/vbaapplication.cxx
===================================================================
--- sw/source/ui/vba/vbaapplication.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaapplication.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,206 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaapplication.cxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <stdio.h>
+#include "vbaapplication.hxx"
+#include "vbadocument.hxx"
+#include <osl/file.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include "vbawindow.hxx"
+#include "vbasystem.hxx"
+#include "vbaoptions.hxx"
+#include "vbaselection.hxx"
+#include "vbadocuments.hxx"
+#include "vbaaddins.hxx"
+#include "vbadialogs.hxx"
+#include <ooo/vba/word/WdEnableCancelKey.hpp>
+#include <svx/acorrcfg.hxx>
+#include "wordvbahelper.hxx"
+#include <docsh.hxx>
+
+using namespace ::ooo;
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::rtl::OUString;
+
+// Enable our own join detection for Intersection and Union
+// should be more efficient than using ScRangeList::Join ( because
+// we already are testing the same things )
+
+#define OWN_JOIN 1
+
+// #TODO is this defined somewhere else?
+#if ( defined UNX ) || ( defined OS2 ) //unix
+#define FILE_PATH_SEPERATOR "/"
+#else // windows
+#define FILE_PATH_SEPERATOR "\\"
+#endif 
+
+#define EXCELVERSION "11.0"
+
+uno::Any sbxToUnoValue( SbxVariable* pVar );
+
+SwVbaApplication::SwVbaApplication( uno::Reference<uno::XComponentContext >& xContext ): SwVbaApplication_BASE( xContext )
+{
+}
+
+SwVbaApplication::~SwVbaApplication()
+{
+}
+
+SfxObjectShell* SwVbaApplication::GetDocShell( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+{
+    return static_cast< SfxObjectShell* >( word::getDocShell( xModel ) );
+}
+
+rtl::OUString SAL_CALL
+SwVbaApplication::getName() throw (uno::RuntimeException)
+{
+    static rtl::OUString appName( RTL_CONSTASCII_USTRINGPARAM("Microsoft Word" ) );
+    return appName;
+}
+
+uno::Reference< word::XDocument > SAL_CALL
+SwVbaApplication::getActiveDocument() throw (uno::RuntimeException)
+{
+    return new SwVbaDocument( this, mxContext, getCurrentDocument() );
+}
+
+uno::Reference< word::XWindow > SAL_CALL 
+SwVbaApplication::getActiveWindow() throw (uno::RuntimeException)
+{
+	// #FIXME sofar can't determine Parent
+	return new SwVbaWindow( uno::Reference< XHelperInterface >(), mxContext, getCurrentDocument() );
+}
+
+uno::Reference<word::XSystem > SAL_CALL
+SwVbaApplication::getSystem() throw (uno::RuntimeException)
+{
+    return uno::Reference< word::XSystem >( new SwVbaSystem( mxContext ) );
+}
+
+uno::Reference<word::XOptions > SAL_CALL
+SwVbaApplication::getOptions() throw (uno::RuntimeException)
+{
+    return uno::Reference< word::XOptions >( new SwVbaOptions( mxContext ) );
+}
+
+uno::Any SAL_CALL
+SwVbaApplication::CommandBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    return VbaApplicationBase::CommandBars( aIndex );
+}
+
+uno::Reference< word::XSelection > SAL_CALL
+SwVbaApplication::getSelection() throw (uno::RuntimeException)
+{
+    return new SwVbaSelection( this, mxContext, getCurrentDocument() );
+}
+
+uno::Any SAL_CALL
+SwVbaApplication::Documents( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCollection > xCol( new SwVbaDocuments( this, mxContext ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaApplication::Addins( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    static uno::Reference< XCollection > xCol( new SwVbaAddins( this, mxContext ) );
+    if ( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+uno::Any SAL_CALL
+SwVbaApplication::Dialogs( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< word::XDialogs > xCol( new SwVbaDialogs( this, mxContext, getCurrentDocument() ));
+    if ( index.hasValue() )
+        return xCol->Item( index );
+    return uno::makeAny( xCol );
+}
+
+sal_Bool SAL_CALL SwVbaApplication::getDisplayAutoCompleteTips() throw (css::uno::RuntimeException)
+{
+    return SvxAutoCorrCfg::Get()->IsAutoTextTip();
+}
+
+void SAL_CALL SwVbaApplication::setDisplayAutoCompleteTips( sal_Bool _displayAutoCompleteTips ) throw (css::uno::RuntimeException)
+{
+    SvxAutoCorrCfg::Get()->SetAutoTextTip( _displayAutoCompleteTips );
+}
+
+sal_Int32 SAL_CALL SwVbaApplication::getEnableCancelKey() throw (css::uno::RuntimeException)
+{
+    // the default value is wdCancelInterrupt in Word
+    return word::WdEnableCancelKey::wdCancelInterrupt;
+}
+
+void SAL_CALL SwVbaApplication::setEnableCancelKey( sal_Int32/* _enableCancelKey */) throw (css::uno::RuntimeException)
+{
+    // seems not supported in Writer
+}
+
+float SAL_CALL SwVbaApplication::CentimetersToPoints( float _Centimeters ) throw (uno::RuntimeException)
+{
+    return VbaApplicationBase::CentimetersToPoints( _Centimeters );
+}
+
+uno::Reference< frame::XModel > 
+SwVbaApplication::getCurrentDocument() throw (css::uno::RuntimeException)
+{
+    return getCurrentWordDoc( mxContext );
+}
+
+rtl::OUString& 
+SwVbaApplication::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaApplication") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaApplication::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Application" ) );
+	}
+	return aServiceNames;
+}
Index: sw/source/ui/vba/vbaborders.hxx
===================================================================
--- sw/source/ui/vba/vbaborders.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaborders.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaborders.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_BORDERS_HXX
+#define SW_VBA_BORDERS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/word/XBorders.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::word::XBorders > SwVbaBorders_BASE;
+class VbaPalette;
+class SwVbaBorders : public SwVbaBorders_BASE
+{
+	// XEnumerationAccess
+	virtual css::uno::Any getItemByIntIndex( const sal_Int32 nIndex ) throw (css::uno::RuntimeException);
+	css::uno::Reference< css::beans::XPropertySet > m_xProps;
+public:
+	SwVbaBorders( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::table::XCellRange >& xRange, VbaPalette& rPalette );
+	virtual ~SwVbaBorders() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	
+	virtual sal_Bool SAL_CALL getShadow() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setShadow( sal_Bool _shadow ) throw (css::uno::RuntimeException);
+
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //SW_VBA_BORDERS_HXX
+
Index: sw/source/ui/vba/vbafont.cxx
===================================================================
--- sw/source/ui/vba/vbafont.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbafont.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,216 @@
+#include "vbafont.hxx"
+#include <com/sun/star/awt/FontUnderline.hpp>
+#include <ooo/vba/word/WdUnderline.hpp>
+#include <hash_map>
+#include <ooo/vba/word/WdColorIndex.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+const uno::Any aLongAnyTrue( sal_Int16(-1) );
+const uno::Any aLongAnyFalse( sal_Int16( 0 ) );
+
+struct MapPair
+{
+    sal_Int32 nMSOConst;
+    sal_Int32 nOOOConst;
+};
+
+static MapPair UnderLineTable[] = {
+        { word::WdUnderline::wdUnderlineNone, com::sun::star::awt::FontUnderline::NONE },
+        { word::WdUnderline::wdUnderlineSingle, com::sun::star::awt::FontUnderline::SINGLE },
+        { word::WdUnderline::wdUnderlineWords, com::sun::star::awt::FontUnderline::SINGLE },
+        { word::WdUnderline::wdUnderlineDouble, com::sun::star::awt::FontUnderline::DOUBLE },
+        { word::WdUnderline::wdUnderlineDotted, com::sun::star::awt::FontUnderline::DOTTED },
+        { word::WdUnderline::wdUnderlineThick, com::sun::star::awt::FontUnderline::BOLDDASH },
+        { word::WdUnderline::wdUnderlineDash, com::sun::star::awt::FontUnderline::DASH }, 
+	{ word::WdUnderline::wdUnderlineDotDash, com::sun::star::awt::FontUnderline::DASHDOT }, 
+	{ word::WdUnderline::wdUnderlineDotDotDash, com::sun::star::awt::FontUnderline::DASHDOTDOT },
+        { word::WdUnderline::wdUnderlineWavy, com::sun::star::awt::FontUnderline::WAVE },
+        { word::WdUnderline::wdUnderlineDottedHeavy, com::sun::star::awt::FontUnderline::BOLDDOTTED },
+        { word::WdUnderline::wdUnderlineDashHeavy, com::sun::star::awt::FontUnderline::BOLDDASH },
+        { word::WdUnderline::wdUnderlineDotDashHeavy, com::sun::star::awt::FontUnderline::BOLDDASHDOT },
+        { word::WdUnderline::wdUnderlineDotDotDashHeavy, com::sun::star::awt::FontUnderline::BOLDDASHDOTDOT },
+        { word::WdUnderline::wdUnderlineWavyHeavy, com::sun::star::awt::FontUnderline::BOLDWAVE },
+        { word::WdUnderline::wdUnderlineDashLong, com::sun::star::awt::FontUnderline::LONGDASH },
+        { word::WdUnderline::wdUnderlineWavyDouble, com::sun::star::awt::FontUnderline::DOUBLEWAVE },
+        { word::WdUnderline::wdUnderlineDashLongHeavy, com::sun::star::awt::FontUnderline::BOLDLONGDASH },
+};
+
+typedef std::hash_map< sal_Int32, sal_Int32 > ConstToConst;
+class UnderLineMapper
+{
+    ConstToConst MSO2OOO;
+    ConstToConst OOO2MSO;
+private:
+    UnderLineMapper()
+    {
+        sal_Int32 nLen = sizeof( UnderLineTable )/ sizeof( UnderLineTable[0] );
+
+        for ( sal_Int32 index=0; index<nLen; ++index )
+        {
+            MSO2OOO[ UnderLineTable[ index ].nMSOConst ] = UnderLineTable[ index ].nOOOConst;
+            OOO2MSO[ UnderLineTable[ index ].nOOOConst ] = UnderLineTable[ index ].nMSOConst;
+        }
+    }
+public:
+    static rtl::OUString propName()
+    {
+        static rtl::OUString sPropName( RTL_CONSTASCII_USTRINGPARAM("CharUnderline") );
+        return sPropName;
+    }
+
+    static UnderLineMapper& instance()
+    {
+        static  UnderLineMapper theMapper;
+        return theMapper; 
+    }
+
+    sal_Int32 getOOOFromMSO( sal_Int32 nMSOConst ) throw( lang::IllegalArgumentException )
+    {
+        ConstToConst::iterator it = MSO2OOO.find( nMSOConst );
+        if ( it == MSO2OOO.end() )
+            throw lang::IllegalArgumentException();
+        return it->second;
+    }
+    sal_Int32 getMSOFromOOO( sal_Int32 nOOOConst ) throw( lang::IllegalArgumentException )
+    {
+        ConstToConst::iterator it = OOO2MSO.find( nOOOConst );
+        if ( it == OOO2MSO.end() )
+            throw lang::IllegalArgumentException();
+        return it->second;
+    }
+};
+
+SwVbaFont::SwVbaFont( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xPalette, uno::Reference< css::beans::XPropertySet > xPropertySet ) throw ( css::uno::RuntimeException ) : SwVbaFont_BASE( xParent, xContext, xPalette, xPropertySet )
+{
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getUnderline() throw (uno::RuntimeException)
+{
+    sal_Int32 nOOVal = 0;
+    mxFont->getPropertyValue(  UnderLineMapper::propName() ) >>= nOOVal;
+    return uno::makeAny( UnderLineMapper::instance().getMSOFromOOO( nOOVal ) );
+}
+
+void SAL_CALL 
+SwVbaFont::setUnderline( const uno::Any& _underline ) throw (uno::RuntimeException)
+{
+    sal_Int32 nMSOVal = 0;
+
+    if ( _underline >>= nMSOVal )
+    {
+        sal_Int32 nOOVal =  UnderLineMapper::instance().getOOOFromMSO( nMSOVal );
+        mxFont->setPropertyValue(  UnderLineMapper::propName(), uno::makeAny( nOOVal ) );
+    }
+}
+
+rtl::OUString&
+SwVbaFont::getServiceImplName()
+{
+        static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaFont") );
+        return sImplName;
+}
+
+void SAL_CALL
+SwVbaFont::setColorIndex( const uno::Any& _colorindex ) throw( uno::RuntimeException )
+{
+        sal_Int32 nIndex = 0;
+        _colorindex >>= nIndex;
+        return setColor( OORGBToXLRGB(mxPalette->getByIndex( nIndex )) );
+} 
+
+uno::Any SAL_CALL
+SwVbaFont::getColorIndex() throw ( uno::RuntimeException )
+{
+    	sal_Int32 nColor = 0;
+
+	XLRGBToOORGB( getColor() ) >>= nColor;
+	sal_Int32 nElems = mxPalette->getCount();
+	sal_Int32 nIndex = 0;
+	for ( sal_Int32 count=0; count<nElems; ++count )
+       	{
+		sal_Int32 nPaletteColor = 0;
+		mxPalette->getByIndex( count ) >>= nPaletteColor;
+		if ( nPaletteColor == nColor )
+		{
+			nIndex = count;
+			break;
+		}
+	}
+	return uno::makeAny( nIndex );
+}	
+uno::Any SAL_CALL 
+SwVbaFont::getSubscript() throw ( uno::RuntimeException )
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getSubscript() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getSuperscript() throw ( uno::RuntimeException )
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getSuperscript() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getBold() throw (uno::RuntimeException)
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getBold() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getItalic() throw (uno::RuntimeException)
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getItalic() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getStrikethrough() throw (css::uno::RuntimeException)
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getStrikethrough() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Any SAL_CALL 
+SwVbaFont::getShadow() throw (uno::RuntimeException)
+{
+    sal_Bool bRes = sal_False;
+    SwVbaFont_BASE::getShadow() >>= bRes;
+    if ( bRes )
+        return aLongAnyTrue;
+    return aLongAnyFalse;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaFont::getServiceNames()
+{
+        static uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+                aServiceNames.realloc( 1 );
+                aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Font" ) );
+        }
+        return aServiceNames;
+}
+
+
Index: sw/source/ui/vba/vbapanes.hxx
===================================================================
--- sw/source/ui/vba/vbapanes.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbapanes.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_PANES_HXX
+#define SW_VBA_PANES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XPanes.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef CollTestImplHelper< ooo::vba::word::XPanes > SwVbaPanes_BASE;
+
+class SwVbaPanes : public SwVbaPanes_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+
+public:
+	SwVbaPanes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~SwVbaPanes() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaPanes_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};    
+
+#endif /* SW_VBA_PANES_HXX */
Index: sw/source/ui/vba/vbatemplate.cxx
===================================================================
--- sw/source/ui/vba/vbatemplate.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbatemplate.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbatemplate.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include "wordvbahelper.hxx"
+#include "vbaautotextentry.hxx"
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/text/XAutoTextContainer.hpp>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+SwVbaTemplate::SwVbaTemplate( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& rModel, const rtl::OUString& rName )
+    : SwVbaTemplate_BASE( rParent, rContext ), mxModel( rModel ), msName( rName )
+{
+}
+
+
+SwVbaTemplate::~SwVbaTemplate()
+{
+}
+
+rtl::OUString
+SwVbaTemplate::getName() throw ( css::uno::RuntimeException )
+{
+    return msName;
+}
+
+uno::Any SAL_CALL
+SwVbaTemplate::AutoTextEntries( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XMultiServiceFactory > xMgr = comphelper::getProcessServiceFactory();
+    uno::Reference< text::XAutoTextContainer > xAutoTextContainer( xMgr->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.AutoTextContainer") ) ), uno::UNO_QUERY_THROW );
+
+    // the default template is "Normal.dot" in Word.
+    rtl::OUString sGroup( RTL_CONSTASCII_USTRINGPARAM("Normal") );
+    sal_Int32 nIndex = msName.lastIndexOf( sal_Unicode('.') );
+    if( nIndex > 0 )
+    {
+        sGroup = msName.copy( 0, msName.lastIndexOf( sal_Unicode('.') ) );
+       // OSL_TRACE("SwVbaTemplate::AutoTextEntries: %s", rtl::OUStringToOString( sGroup, RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    
+    uno::Reference< container::XIndexAccess > xGroup;
+    if( xAutoTextContainer->hasByName( sGroup ) )
+    {
+        xGroup.set( xAutoTextContainer->getByName( sGroup ), uno::UNO_QUERY_THROW );
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Auto Text Entry doesn't exist") ), uno::Reference< uno::XInterface >() );
+        //xGroup.set( xAutoTextContainer->insertNewByName( sGroup ), uno::UNO_QUERY_THROW );
+    }
+
+    uno::Reference< XCollection > xCol( new SwVbaAutoTextEntries( this, mxContext, xGroup ) );
+    if( index.hasValue() )
+        return xCol->Item( index, uno::Any() );
+    return uno::makeAny( xCol );
+}
+
+rtl::OUString&
+SwVbaTemplate::getServiceImplName()
+{
+        static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaTemplate") );
+        return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaTemplate::getServiceNames()
+{
+        static uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+                aServiceNames.realloc( 1 );
+                aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Template" ) );
+        }
+        return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbaheaderfooter.hxx
===================================================================
--- sw/source/ui/vba/vbaheaderfooter.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaheaderfooter.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_HEADERFOOTER_HXX
+#define SW_VBA_HEADERFOOTER_HXX
+
+#include <ooo/vba/word/XHeaderFooter.hpp>
+#include <ooo/vba/word/XRange.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XHeaderFooter > SwVbaHeaderFooter_BASE;
+
+class SwVbaHeaderFooter : public SwVbaHeaderFooter_BASE
+{
+private:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxPageStyleProps;
+    sal_Bool mbHeader;
+    sal_Int32 mnIndex;
+
+public:
+	SwVbaHeaderFooter( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const css::uno::Reference< css::frame::XModel >& xModel, const css::uno::Reference< css::beans::XPropertySet >& xProps, sal_Bool isHeader, sal_Int32 index ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaHeaderFooter(){}
+
+    // Attributes
+    virtual ::sal_Bool SAL_CALL getIsHeader() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLinkToPrevious() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLinkToPrevious( ::sal_Bool _linktoprevious ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::word::XRange > SAL_CALL getRange() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Shapes( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_HEADERFOOTER_HXX */
Index: sw/source/ui/vba/vbavariables.hxx
===================================================================
--- sw/source/ui/vba/vbavariables.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbavariables.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_VARIABLES_HXX
+#define SW_VBA_VARIABLES_HXX
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/word/XVariables.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/beans/XPropertyAccess.hpp>
+
+typedef CollTestImplHelper< ooo::vba::word::XVariables > SwVbaVariables_BASE;
+
+class SwVbaVariables : public SwVbaVariables_BASE
+{
+private:
+    css::uno::Reference< css::beans::XPropertyAccess > mxUserDefined;
+
+public:
+	SwVbaVariables( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::beans::XPropertyAccess >& rUserDefined );
+	virtual ~SwVbaVariables() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// SwVbaVariables_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+	// XVariables
+	virtual css::uno::Any SAL_CALL Add( const rtl::OUString& rName, const css::uno::Any& rValue ) throw (css::uno::RuntimeException);
+};    
+
+#endif /* SW_VBA_VARIABLES_HXX */
Index: sw/source/ui/vba/vbaparagraphformat.cxx
===================================================================
--- sw/source/ui/vba/vbaparagraphformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaparagraphformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,576 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaparagraphformat.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <tools/diagnose_ex.h>
+#include "wordvbahelper.hxx"
+#include <com/sun/star/style/LineSpacingMode.hpp>
+#include <ooo/vba/word/WdLineSpacing.hpp>
+#include <ooo/vba/word/WdParagraphAlignment.hpp>
+#include <ooo/vba/word/WdOutlineLevel.hpp>
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+#include <com/sun/star/style/BreakType.hpp>
+
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const sal_Int16 CHARACTER_INDENT_FACTOR = 12;
+static const sal_Int16 PERCENT100 = 100;
+static const sal_Int16 PERCENT150 = 150;
+static const sal_Int16 PERCENT200 = 200;
+
+SwVbaParagraphFormat::SwVbaParagraphFormat( const uno::Reference< ooo::vba::XHelperInterface >& rParent, const uno::Reference< uno::XComponentContext >& rContext, const uno::Reference< text::XTextDocument >& rTextDocument, const uno::Reference< beans::XPropertySet >& rParaProps ) : SwVbaParagraphFormat_BASE( rParent, rContext ), mxTextDocument( rTextDocument ), mxParaProps( rParaProps )
+{
+}
+
+SwVbaParagraphFormat::~SwVbaParagraphFormat()
+{
+}
+
+sal_Int32 SAL_CALL SwVbaParagraphFormat::getAlignment() throw (uno::RuntimeException)
+{
+    style::ParagraphAdjust aParaAdjust = style::ParagraphAdjust_LEFT;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaAdjust") ) ) >>= aParaAdjust;
+    return getMSWordAlignment( aParaAdjust );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setAlignment( sal_Int32 _alignment ) throw (uno::RuntimeException)
+{
+    style::ParagraphAdjust aParaAdjust = ( style::ParagraphAdjust ) getOOoAlignment( _alignment );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaAdjust") ), uno::makeAny( aParaAdjust ) );
+}
+
+float SAL_CALL SwVbaParagraphFormat::getFirstLineIndent() throw (uno::RuntimeException)
+{
+    sal_Int32 indent = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaFirstLineIndent") ) ) >>= indent;
+    return (float)( Millimeter::getInPoints( indent ) );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setFirstLineIndent( float _firstlineindent ) throw (uno::RuntimeException)
+{
+    sal_Int32 indent = Millimeter::getInHundredthsOfOneMillimeter( _firstlineindent );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaFirstLineIndent") ), uno::makeAny( indent ) );
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getKeepTogether() throw (uno::RuntimeException)
+{
+    sal_Bool bKeep = sal_False;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaKeepTogether") ) ) >>= bKeep;
+    return uno::makeAny ( bKeep );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setKeepTogether( const uno::Any& _keeptogether ) throw (uno::RuntimeException)
+{
+    sal_Bool bKeep = sal_False;
+    if( _keeptogether >>= bKeep )
+    {
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaKeepTogether") ), uno::makeAny( bKeep ) );
+    }    
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getKeepWithNext() throw (uno::RuntimeException)
+{
+    sal_Bool bKeep = sal_False;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaSplit") ) ) >>= bKeep;
+    return uno::makeAny ( bKeep );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setKeepWithNext( const uno::Any& _keepwithnext ) throw (uno::RuntimeException)
+{
+    sal_Bool bKeep = sal_False;
+    if( _keepwithnext >>= bKeep )
+    {
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaSplit") ), uno::makeAny( bKeep ) );
+    }    
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getHyphenation() throw (uno::RuntimeException)
+{
+    sal_Bool bHypn = sal_False;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation") ) ) >>= bHypn;
+    return uno::makeAny ( bHypn );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setHyphenation( const uno::Any& _hyphenation ) throw (uno::RuntimeException)
+{
+    sal_Bool bHypn = sal_False;
+    if( _hyphenation >>= bHypn )
+    {
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaIsHyphenation") ), uno::makeAny( bHypn ) );
+    }    
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+float SAL_CALL SwVbaParagraphFormat::getLineSpacing() throw (uno::RuntimeException)
+{
+    style::LineSpacing aLineSpacing;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineSpacing") ) ) >>= aLineSpacing;
+    return getMSWordLineSpacing( aLineSpacing );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setLineSpacing( float _linespacing ) throw (uno::RuntimeException)
+{
+    style::LineSpacing aLineSpacing;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineSpacing") ) ) >>= aLineSpacing;
+    aLineSpacing = getOOoLineSpacing( _linespacing, aLineSpacing.Mode );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineSpacing") ), uno::makeAny( aLineSpacing ) );
+}
+
+sal_Int32 SAL_CALL SwVbaParagraphFormat::getLineSpacingRule() throw (uno::RuntimeException)
+{
+    style::LineSpacing aLineSpacing;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineSpacing") ) ) >>= aLineSpacing;
+    return getMSWordLineSpacingRule( aLineSpacing );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setLineSpacingRule( sal_Int32 _linespacingrule ) throw (uno::RuntimeException)
+{
+    style::LineSpacing aLineSpacing = getOOoLineSpacingFromRule( _linespacingrule );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineSpacing") ), uno::makeAny( aLineSpacing ) );
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getNoLineNumber() throw (uno::RuntimeException)
+{
+    sal_Bool noLineNum = sal_False;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineNumberCount") ) ) >>= noLineNum;
+    return uno::makeAny ( noLineNum );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setNoLineNumber( const uno::Any& _nolinenumber ) throw (uno::RuntimeException)
+{
+    sal_Bool noLineNum = sal_False;
+    if( _nolinenumber >>= noLineNum )
+    {
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLineNumberCount") ), uno::makeAny( noLineNum ) );
+    }    
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+sal_Int32 SAL_CALL SwVbaParagraphFormat::getOutlineLevel() throw (uno::RuntimeException)
+{
+    sal_Int32 nLevel = word::WdOutlineLevel::wdOutlineLevelBodyText;
+    rtl::OUString aHeading;
+    const rtl::OUString HEADING = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Heading") );
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaStyleName") ) ) >>= aHeading;
+    if( aHeading.indexOf( HEADING ) == 0 )
+    {
+        // get the sub string after "Heading"
+        nLevel = aHeading.copy( HEADING.getLength() ).toInt32();
+    }
+    return nLevel;
+}
+
+void SAL_CALL SwVbaParagraphFormat::setOutlineLevel( sal_Int32 /*_outlinelevel*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getPageBreakBefore() throw (uno::RuntimeException)
+{
+    style::BreakType aBreakType;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BreakType") ) ) >>= aBreakType;
+    sal_Bool bBreakBefore = ( aBreakType == style::BreakType_PAGE_BEFORE || aBreakType == style::BreakType_PAGE_BOTH );
+    return uno::makeAny( bBreakBefore );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setPageBreakBefore( const uno::Any& _breakbefore ) throw (uno::RuntimeException)
+{
+    sal_Bool bBreakBefore = sal_False;
+    if( _breakbefore >>= bBreakBefore )
+    {
+        style::BreakType aBreakType;
+        mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BreakType") ) ) >>= aBreakType;
+        if( bBreakBefore )
+        {
+            if( aBreakType == style::BreakType_NONE )
+                aBreakType = style::BreakType_PAGE_BEFORE;
+            else if ( aBreakType == style::BreakType_PAGE_AFTER )
+                aBreakType = style::BreakType_PAGE_BOTH;
+        }
+        else
+        {
+            if( aBreakType == style::BreakType_PAGE_BOTH )
+                aBreakType = style::BreakType_PAGE_AFTER;
+            else if ( aBreakType == style::BreakType_PAGE_BEFORE )
+                aBreakType = style::BreakType_PAGE_AFTER;
+        }
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BreakType") ), uno::makeAny( aBreakType ) );
+    }    
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+float SAL_CALL SwVbaParagraphFormat::getSpaceBefore() throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTopMargin") ) ) >>= nSpace;
+    return (float)( Millimeter::getInPoints( nSpace ) );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setSpaceBefore( float _space ) throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = Millimeter::getInHundredthsOfOneMillimeter( _space );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaTopMargin") ), uno::makeAny( nSpace ) );
+}
+
+float SAL_CALL SwVbaParagraphFormat::getSpaceAfter() throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaBottomMargin") ) ) >>= nSpace;
+    return (float)( Millimeter::getInPoints( nSpace ) );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setSpaceAfter( float _space ) throw (uno::RuntimeException)
+{
+    sal_Int32 nSpace = Millimeter::getInHundredthsOfOneMillimeter( _space );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaBottomMargin") ), uno::makeAny( nSpace ) );
+}
+
+float SAL_CALL SwVbaParagraphFormat::getLeftIndent() throw (uno::RuntimeException)
+{
+    sal_Int32 nIndent = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLeftMargin") ) ) >>= nIndent;
+    return (float)( Millimeter::getInPoints( nIndent ) );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setLeftIndent( float _leftindent ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndent = Millimeter::getInHundredthsOfOneMillimeter( _leftindent );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaLeftMargin") ), uno::makeAny( nIndent ) );
+}
+
+float SAL_CALL SwVbaParagraphFormat::getRightIndent() throw (uno::RuntimeException)
+{
+    sal_Int32 nIndent = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaRightMargin") ) ) >>= nIndent;
+    return (float)( Millimeter::getInPoints( nIndent ) );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setRightIndent( float _rightindent ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndent = Millimeter::getInHundredthsOfOneMillimeter( _rightindent );
+    mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaRightMargin") ), uno::makeAny( nIndent ) );
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getTabStops() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setTabStops( const uno::Any& /*_tabstops*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+uno::Any SAL_CALL SwVbaParagraphFormat::getWidowControl() throw (uno::RuntimeException)
+{
+    sal_Bool bWidow = sal_False;
+    sal_Int8 nWidow = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaWidows") ) ) >>= nWidow;
+    sal_Int8 nOrphan = 0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaOrphans") ) ) >>= nOrphan;
+    // if the amount of single lines on one page > 1 and the same of start and end of the paragraph,
+    // true is retured.
+    bWidow = ( nWidow > 1 && nOrphan == nWidow );
+    return uno::makeAny( bWidow );
+}
+
+void SAL_CALL SwVbaParagraphFormat::setWidowControl( const uno::Any& _widowcontrol ) throw (uno::RuntimeException)
+{
+    // if we get true, the part of the paragraph on one page has to be
+    // at least two lines
+    sal_Bool bWidow = sal_False;
+    if( _widowcontrol >>= bWidow )
+    {
+        sal_Int8 nControl = bWidow? 2:1;
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaWidows") ), uno::makeAny( nControl ) );
+        mxParaProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ParaOrphans") ), uno::makeAny( nControl ) );
+    }
+    else
+    {
+        DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+}
+
+style::LineSpacing SwVbaParagraphFormat::getOOoLineSpacing( float _lineSpace, sal_Int16 mode )
+{
+    style::LineSpacing aLineSpacing;
+    if( mode != style::LineSpacingMode::MINIMUM && mode != style::LineSpacingMode::FIX )
+    {
+        // special behaviour of word: if the space is set to these values, the rule and 
+        // the height are changed accordingly
+        if( _lineSpace == CHARACTER_INDENT_FACTOR )
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = PERCENT100;
+        }
+        else if( _lineSpace == ( sal_Int16 )( CHARACTER_INDENT_FACTOR * 1.5 ) )
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = PERCENT150;
+        }
+        else if( _lineSpace == ( sal_Int16 )( ( CHARACTER_INDENT_FACTOR ) * 2 ) )
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = PERCENT200;
+        }
+        else
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::FIX;
+            aLineSpacing.Height = ( sal_Int16 )( Millimeter::getInHundredthsOfOneMillimeter( _lineSpace ) );
+        }
+    }
+    else
+    {
+        aLineSpacing.Mode = mode;
+        aLineSpacing.Height = ( sal_Int16 )( Millimeter::getInHundredthsOfOneMillimeter( _lineSpace ) );
+    }
+    return aLineSpacing;
+}
+
+style::LineSpacing SwVbaParagraphFormat::getOOoLineSpacingFromRule( sal_Int32 _linespacingrule )
+{
+    style::LineSpacing aLineSpacing;
+    switch( _linespacingrule )
+    {
+        case word::WdLineSpacing::wdLineSpace1pt5:
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = PERCENT150;
+            break;
+        }
+        case word::WdLineSpacing::wdLineSpaceAtLeast:
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::MINIMUM;
+            aLineSpacing.Height = getCharHeight();
+            break;
+        }
+        case word::WdLineSpacing::wdLineSpaceDouble:
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = getCharHeight();
+            break;
+        }
+        case word::WdLineSpacing::wdLineSpaceExactly:
+        case word::WdLineSpacing::wdLineSpaceMultiple:
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::FIX;
+            aLineSpacing.Height = getCharHeight();
+            break;
+        }
+        case word::WdLineSpacing::wdLineSpaceSingle:
+        {
+            aLineSpacing.Mode = style::LineSpacingMode::PROP;
+            aLineSpacing.Height = PERCENT100;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+            break;
+        }
+    }
+    return aLineSpacing;
+}
+
+float SwVbaParagraphFormat::getMSWordLineSpacing( style::LineSpacing& rLineSpacing )
+{
+    float wdLineSpacing = 0;
+    if( rLineSpacing.Mode != style::LineSpacingMode::PROP )
+    {
+        wdLineSpacing = (float)( Millimeter::getInPoints( rLineSpacing.Height ) );
+    }
+    else
+    {
+        wdLineSpacing = (float)( CHARACTER_INDENT_FACTOR * rLineSpacing.Height ) / PERCENT100;
+    }
+    return wdLineSpacing;
+}
+
+sal_Int32 SwVbaParagraphFormat::getMSWordLineSpacingRule( style::LineSpacing& rLineSpacing )
+{
+    sal_Int32 wdLineSpacing = word::WdLineSpacing::wdLineSpaceSingle;
+    switch( rLineSpacing.Mode )
+    {
+        case style::LineSpacingMode::PROP:
+        {
+            switch( rLineSpacing.Height )
+            {
+                case PERCENT100:
+                {
+                    wdLineSpacing = word::WdLineSpacing::wdLineSpaceSingle;
+                    break;
+                }
+                case PERCENT150:
+                {
+                    wdLineSpacing = word::WdLineSpacing::wdLineSpace1pt5;
+                    break;
+                }
+                case PERCENT200:
+                {
+                    wdLineSpacing = word::WdLineSpacing::wdLineSpaceDouble;
+                    break;
+                }
+                default:
+                {
+                    wdLineSpacing = word::WdLineSpacing::wdLineSpaceMultiple;
+                }
+            }
+            break;
+        }
+        case style::LineSpacingMode::MINIMUM:
+        {
+            wdLineSpacing = word::WdLineSpacing::wdLineSpaceAtLeast;
+            break;
+        }
+        case style::LineSpacingMode::FIX:
+        case style::LineSpacingMode::LEADING:
+        {
+            wdLineSpacing = word::WdLineSpacing::wdLineSpaceExactly;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+        }
+    }
+    return wdLineSpacing;
+}
+
+sal_Int16 SwVbaParagraphFormat::getCharHeight() throw (uno::RuntimeException)
+{
+    float fCharHeight = 0.0;
+    mxParaProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CharHeight") ) ) >>= fCharHeight;
+    return (sal_Int16)( Millimeter::getInHundredthsOfOneMillimeter( fCharHeight ) );
+}
+
+sal_Int32 SwVbaParagraphFormat::getOOoAlignment( sal_Int32 _alignment )
+{
+    sal_Int32 nParaAjust = style::ParagraphAdjust_LEFT;
+    switch( _alignment )
+    {
+        case word::WdParagraphAlignment::wdAlignParagraphCenter:
+        {
+            nParaAjust = style::ParagraphAdjust_CENTER;
+            break;
+        }
+        case word::WdParagraphAlignment::wdAlignParagraphJustify:
+        {
+            nParaAjust = style::ParagraphAdjust_BLOCK;
+            break;
+        }
+        case word::WdParagraphAlignment::wdAlignParagraphLeft:
+        {
+            nParaAjust = style::ParagraphAdjust_LEFT;
+            break;
+        }
+        case word::WdParagraphAlignment::wdAlignParagraphRight:
+        {
+            nParaAjust = style::ParagraphAdjust_RIGHT;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+        }
+    }
+    return nParaAjust;
+}
+
+sal_Int32 SwVbaParagraphFormat::getMSWordAlignment( sal_Int32 _alignment )
+{
+    sal_Int32 wdAlignment = word::WdParagraphAlignment::wdAlignParagraphLeft;
+    switch( _alignment )
+    {
+        case style::ParagraphAdjust_CENTER:
+        {
+            wdAlignment = word::WdParagraphAlignment::wdAlignParagraphCenter;
+            break;
+        }
+        case style::ParagraphAdjust_LEFT:
+        {
+            wdAlignment = word::WdParagraphAlignment::wdAlignParagraphLeft;
+            break;
+        }
+        case style::ParagraphAdjust_BLOCK:
+        {
+            wdAlignment = word::WdParagraphAlignment::wdAlignParagraphJustify;
+            break;
+        }
+        case style::ParagraphAdjust_RIGHT:
+        {
+            wdAlignment = word::WdParagraphAlignment::wdAlignParagraphRight;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception( SbERR_BAD_PARAMETER, rtl::OUString() );
+        }
+    }
+    return wdAlignment;
+}
+
+rtl::OUString& 
+SwVbaParagraphFormat::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaParagraphFormat") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaParagraphFormat::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.ParagraphFormat" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/wordvbahelper.hxx
===================================================================
--- sw/source/ui/vba/wordvbahelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/wordvbahelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_WORD_VBA_HELPER_HXX
+#define SW_WORD_VBA_HELPER_HXX
+
+#include <vbahelper/vbahelper.hxx>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextViewCursor.hpp>
+#include <com/sun/star/text/XPageCursor.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+
+class SwDocShell;
+class SwView;
+namespace ooo 
+{
+	namespace vba 
+	{
+    namespace word
+    {
+		//css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException);
+        SwDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel );
+        SwView* getView( const css::uno::Reference< css::frame::XModel>& xModel );
+        css::uno::Reference< css::text::XTextViewCursor > getXTextViewCursor( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::style::XStyle > getCurrentPageStyle( const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+        sal_Int32 getPageCount( const css::uno::Reference< css::frame::XModel>& xModel ) throw (css::uno::RuntimeException);
+
+} // word
+} // vba
+} // ooo
+#endif
Index: sw/source/ui/vba/vbadialogs.cxx
===================================================================
--- sw/source/ui/vba/vbadialogs.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbadialogs.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialogs.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <ooo/vba/word/XDialog.hpp>
+#include "vbadialogs.hxx"
+#include "vbadialog.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+uno::Any
+SwVbaDialogs::Item( const uno::Any &aItem ) throw (uno::RuntimeException)
+{
+	sal_Int32 nIndex = 0;
+	aItem >>= nIndex;
+	uno::Reference< word::XDialog > aDialog( new SwVbaDialog( uno::Reference< XHelperInterface >( Application(),uno::UNO_QUERY_THROW ), mxContext, m_xModel, nIndex ) );
+	return uno::Any( aDialog );
+}
+
+rtl::OUString& 
+SwVbaDialogs::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaDialogs") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaDialogs::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Dialogs" ) );
+	}
+	return aServiceNames;
+}
+
Index: sw/source/ui/vba/vbaglobals.cxx
===================================================================
--- sw/source/ui/vba/vbaglobals.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaglobals.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,196 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaglobals.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+#include "vbaglobals.hxx"
+
+#include <comphelper/unwrapargs.hxx>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <cppuhelper/bootstrap.hxx>
+#include "vbaapplication.hxx"
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::ooo::vba;
+
+
+rtl::OUString sDocCtxName( RTL_CONSTASCII_USTRINGPARAM("WordDocumentContext") );
+
+// =============================================================================
+// SwVbaGlobals
+// =============================================================================
+
+SwVbaGlobals::SwVbaGlobals(  uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& rxContext ) : SwVbaGlobals_BASE( uno::Reference< XHelperInterface >(), rxContext, sDocCtxName )
+{
+	OSL_TRACE("SwVbaGlobals::SwVbaGlobals()");
+        uno::Sequence< beans::PropertyValue > aInitArgs( 2 );
+        aInitArgs[ 0 ].Name = rtl::OUString::createFromAscii("Application");
+        aInitArgs[ 0 ].Value = uno::makeAny( getApplication() );
+        aInitArgs[ 1 ].Name = sDocCtxName;
+        aInitArgs[ 1 ].Value = uno::makeAny( getXSomethingFromArgs< frame::XModel >( aArgs, 0 ) );
+        
+        init( aInitArgs );
+}
+
+SwVbaGlobals::~SwVbaGlobals()
+{
+	OSL_TRACE("SwVbaGlobals::~SwVbaGlobals");
+}
+
+// =============================================================================
+// XGlobals
+// =============================================================================
+uno::Reference<word::XApplication >
+SwVbaGlobals::getApplication() throw (uno::RuntimeException)
+{
+	OSL_TRACE("In SwVbaGlobals::getApplication");	
+	if ( !mxApplication.is() )
+		 mxApplication.set( new SwVbaApplication( mxContext) );
+        
+   	return mxApplication; 
+}
+
+uno::Reference<word::XSystem > SAL_CALL
+SwVbaGlobals::getSystem() throw (uno::RuntimeException)
+{
+	return getApplication()->getSystem();	
+}
+
+uno::Reference< word::XDocument > SAL_CALL 
+SwVbaGlobals::getActiveDocument() throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveDocument();	
+}
+
+uno::Reference< word::XWindow > SAL_CALL 
+SwVbaGlobals::getActiveWindow() throw (uno::RuntimeException)
+{
+	return getApplication()->getActiveWindow();
+}
+
+rtl::OUString SAL_CALL 
+SwVbaGlobals::getName() throw (uno::RuntimeException)
+{
+	return getApplication()->getName();
+}
+
+uno::Reference<word::XOptions > SAL_CALL
+SwVbaGlobals::getOptions() throw (uno::RuntimeException)
+{
+	return getApplication()->getOptions();
+}
+
+uno::Any SAL_CALL
+SwVbaGlobals::CommandBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    return getApplication()->CommandBars( aIndex );
+}
+
+uno::Any SAL_CALL
+SwVbaGlobals::Documents( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    return getApplication()->Documents( index );
+}
+
+uno::Any SAL_CALL
+SwVbaGlobals::Addins( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    return getApplication()->Addins( index );
+}
+
+uno::Any SAL_CALL
+SwVbaGlobals::Dialogs( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    return getApplication()->Dialogs( index );
+}
+
+uno::Reference<word::XSelection > SAL_CALL
+SwVbaGlobals::getSelection() throw (uno::RuntimeException)
+{
+	return getApplication()->getSelection();
+}
+
+float SAL_CALL SwVbaGlobals::CentimetersToPoints( float _Centimeters ) throw (uno::RuntimeException)
+{
+    return getApplication()->CentimetersToPoints( _Centimeters );
+}
+
+rtl::OUString&
+SwVbaGlobals::getServiceImplName()
+{
+        static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaGlobals") );
+        return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaGlobals::getServiceNames()
+{
+        static uno::Sequence< rtl::OUString > aServiceNames;
+        if ( aServiceNames.getLength() == 0 )
+        {
+                aServiceNames.realloc( 1 );
+                aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.Globals" ) );
+        }
+        return aServiceNames;
+}
+
+uno::Sequence< rtl::OUString >
+SwVbaGlobals::getAvailableServiceNames(  ) throw (uno::RuntimeException)
+{
+    static bool bInit = false;
+    static uno::Sequence< rtl::OUString > serviceNames( SwVbaGlobals_BASE::getAvailableServiceNames() );
+    if ( !bInit )
+    {
+         rtl::OUString names[] = { 
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.word.Document" ) ),
+//            #FIXME #TODO make Application a proper service
+//            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.word.Application" ) ),
+        };
+        sal_Int32 nWordServices = ( sizeof( names )/ sizeof( names[0] ) );
+        sal_Int32 startIndex = serviceNames.getLength();
+        serviceNames.realloc( serviceNames.getLength() + nWordServices );
+        for ( sal_Int32 index = 0; index < nWordServices; ++index )
+             serviceNames[ startIndex + index ] = names[ index ];
+        bInit = true;
+    }
+    return serviceNames;
+}
+
+namespace globals
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<SwVbaGlobals, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SwVbaGlobals",
+    "ooo.vba.word.Globals" );
+}
+
Index: sw/source/ui/vba/vbaaddin.hxx
===================================================================
--- sw/source/ui/vba/vbaaddin.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbaaddin.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SW_VBA_ADDIN_HXX
+#define SW_VBA_ADDIN_HXX
+
+#include <ooo/vba/word/XAddin.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::word::XAddin > SwVbaAddin_BASE;
+
+class SwVbaAddin : public SwVbaAddin_BASE
+{
+private:
+    rtl::OUString msFileURL;
+    sal_Bool mbAutoload;
+    sal_Bool mbInstalled;
+
+public:
+	SwVbaAddin( const css::uno::Reference< ooo::vba::XHelperInterface >& rParent, const css::uno::Reference< css::uno::XComponentContext >& rContext, const rtl::OUString& rFileURL, sal_Bool bAutoload ) throw ( css::uno::RuntimeException );
+	virtual ~SwVbaAddin();
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getAutoload() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getInstalled() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setInstalled( ::sal_Bool _installed ) throw (css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif /* SW_VBA_ADDIN_HXX */
Index: sw/source/ui/vba/vbasystem.cxx
===================================================================
--- sw/source/ui/vba/vbasystem.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ sw/source/ui/vba/vbasystem.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,195 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbasystem.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <ooo/vba/word/WdCursorType.hpp>
+#include <tools/diagnose_ex.h>
+#include <tools/config.hxx>
+#include <tools/string.hxx>
+#include <osl/file.hxx>
+#include <tools/urlobj.hxx>
+#include <tools/string.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+PrivateProfileStringListener::PrivateProfileStringListener( const rtl::OUString& rFileName, const ByteString& rGroupName, const ByteString& rKey )
+    :maFileName( rFileName ), maGroupName( rGroupName ), maKey( rKey )
+{
+}
+
+PrivateProfileStringListener::~PrivateProfileStringListener()
+{
+}
+
+void PrivateProfileStringListener::Initialize( const rtl::OUString& rFileName, const ByteString& rGroupName, const ByteString& rKey )
+{
+    maFileName = rFileName;
+    maGroupName = rGroupName;
+    maKey = rKey;
+}
+
+uno::Any PrivateProfileStringListener::getValueEvent()
+{
+    // get the private profile string
+    Config aCfg( maFileName );
+    aCfg.SetGroup( maGroupName );
+    rtl::OUString sValue = String( aCfg.ReadKey( maKey ), RTL_TEXTENCODING_DONTKNOW );
+
+    return uno::makeAny( sValue );
+}
+
+void PrivateProfileStringListener::setValueEvent( const css::uno::Any& value )
+{
+    // set the private profile string
+    Config aCfg( maFileName );
+    aCfg.SetGroup( maGroupName );
+
+    rtl::OUString aValue;
+    value >>= aValue;
+    aCfg.WriteKey( maKey, ByteString( aValue.getStr(), RTL_TEXTENCODING_DONTKNOW ) );
+}
+
+SwVbaSystem::SwVbaSystem( uno::Reference<uno::XComponentContext >& xContext ): SwVbaSystem_BASE( uno::Reference< XHelperInterface >(), xContext )
+{
+}
+
+SwVbaSystem::~SwVbaSystem()
+{
+}
+
+sal_Int32 SAL_CALL
+SwVbaSystem::getCursor() throw (uno::RuntimeException)
+{
+    sal_Int32 nPointerStyle =  getPointerStyle( getCurrentWordDoc(mxContext) );
+
+    switch( nPointerStyle )
+    {
+        case POINTER_ARROW:
+            return word::WdCursorType::wdCursorNorthwestArrow;
+        case POINTER_NULL:
+            return word::WdCursorType::wdCursorNormal;
+        case POINTER_WAIT:
+            return word::WdCursorType::wdCursorWait;
+        case POINTER_TEXT:
+            return word::WdCursorType::wdCursorIBeam;
+        default:
+            return word::WdCursorType::wdCursorNormal;
+    }
+}
+
+void SAL_CALL 
+SwVbaSystem::setCursor( sal_Int32 _cursor ) throw (uno::RuntimeException)
+{
+    try
+    {
+        switch( _cursor )
+        {
+            case word::WdCursorType::wdCursorNorthwestArrow:
+            {
+                const Pointer& rPointer( POINTER_ARROW );
+                setCursorHelper( getCurrentWordDoc(mxContext), rPointer, sal_False );
+                break;
+            }
+            case word::WdCursorType::wdCursorWait:
+            {
+                const Pointer& rPointer( static_cast< PointerStyle >( POINTER_WAIT ) );
+                //It will set the edit window, toobar and statusbar's mouse pointer.
+                setCursorHelper( getCurrentWordDoc(mxContext), rPointer, sal_True );
+                break;
+            }
+            case word::WdCursorType::wdCursorIBeam:
+            {
+                const Pointer& rPointer( static_cast< PointerStyle >( POINTER_TEXT ) );
+                //It will set the edit window, toobar and statusbar's mouse pointer.
+                setCursorHelper( getCurrentWordDoc( mxContext ), rPointer, sal_True );
+                break;
+            }
+            case word::WdCursorType::wdCursorNormal:
+            {
+                const Pointer& rPointer( POINTER_NULL );
+                setCursorHelper( getCurrentWordDoc( mxContext ), rPointer, sal_False );
+                break;
+            }
+            default:
+                throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Unknown value for Cursor pointer")), uno::Reference< uno::XInterface >() );
+                // TODO: isn't this a flaw in the API? It should be allowed to throw an
+                // IllegalArgumentException, or so
+        }        
+    }
+    catch( const uno::Exception& )
+    {
+    	DBG_UNHANDLED_EXCEPTION();
+    }
+}
+
+uno::Any SAL_CALL 
+SwVbaSystem::PrivateProfileString( const rtl::OUString& rFilename, const rtl::OUString& rSection, const rtl::OUString& rKey ) throw ( uno::RuntimeException )
+{
+    if( rFilename.getLength() == 0 )
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+    // FIXME: need to detect whether it is a relative file path
+    // we need to detect if this is a URL, if not then assume its a file path
+    rtl::OUString sFileUrl;
+    INetURLObject aObj;
+	aObj.SetURL( rFilename );
+	bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+	if ( bIsURL )
+		sFileUrl = rFilename;
+	else
+		osl::FileBase::getFileURLFromSystemPath( rFilename, sFileUrl);
+
+    ByteString aGroupName = ByteString( rSection.getStr(), RTL_TEXTENCODING_DONTKNOW);
+    ByteString aKey = ByteString( rKey.getStr(), RTL_TEXTENCODING_DONTKNOW);
+    maPrivateProfileStringListener.Initialize( sFileUrl, aGroupName, aKey );
+
+    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( &maPrivateProfileStringListener ) ) );
+}
+
+rtl::OUString& 
+SwVbaSystem::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("SwVbaSystem") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+SwVbaSystem::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.System" ) );
+	}
+	return aServiceNames;
+}
Index: sw/inc/unoprnms.hxx
===================================================================
--- sw/inc/unoprnms.hxx	(revision 276159)
+++ sw/inc/unoprnms.hxx	(revision 276288)
@@ -807,8 +807,10 @@ enum SwPropNameIds
 // --> OD 2009-07-13 #i73249#
 /* 0737 */  UNO_NAME_DESCRIPTION,
 // <--
 /* 0738 */  UNO_NAME_META,       // #i91565#
-/* 0739 */  SW_PROPNAME_END
+/* 0739 */  UNO_NAME_IS_TEMPLATE,
+/* 0740 */  UNO_NAME_VBA_DOCOBJ,
+/* 0741 */  SW_PROPNAME_END
 };
 
 
Index: sw/inc/doc.hxx
===================================================================
--- sw/inc/doc.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/inc/doc.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -395,6 +395,7 @@
 
 	// table of forbidden characters of this document
 	vos::ORef<SvxForbiddenCharactersTable>	xForbiddenCharsTable;
+   com::sun::star::uno::Reference<com::sun::star::container::XNameContainer> m_xTemplateToProjectCache;
 
     // --> OD 2007-10-26 #i83479#
 public:
@@ -2092,6 +2093,8 @@
 	{
 		return n32DummyCompatabilityOptions2;
 	}
+        void SetVBATemplateToProjectCache( com::sun::star::uno::Reference< com::sun::star::container::XNameContainer >& xCache ) { m_xTemplateToProjectCache = xCache; };
+        com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > GetVBATemplateToProjectCache() { return m_xTemplateToProjectCache; };
 
     ::sfx2::IXmlIdRegistry& GetXmlIdRegistry();
     SwDoc* CreateCopy() const;
Index: sw/inc/docsh.hxx
===================================================================
--- sw/inc/docsh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/inc/docsh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -85,6 +85,7 @@
     comphelper::EmbeddedObjectContainer*    pOLEChildList;
     sal_Int16               nUpdateDocMode; // contains the com::sun::star::document::UpdateDocMode
     bool                    bInUpdateFontList; //prevent nested calls of UpdateFontList
+    bool                    bIsATemplate; //prevent nested calls of UpdateFontList
 	// Methoden fuer den Zugriff aufs Doc
 	SW_DLLPRIVATE void					AddLink();
 	SW_DLLPRIVATE void					RemoveLink();
@@ -299,6 +300,8 @@
                                 GetController();
 
     SfxInPlaceClient* GetIPClient( const ::svt::EmbeddedObjectRef& xObjRef );
+    SW_DLLPRIVATE sal_Bool IsTemplate() { return bIsATemplate; }
+    SW_DLLPRIVATE void SetIsTemplate( bool bValue ) { bIsATemplate = bValue; }
 
     virtual const ::sfx2::IXmlIdRegistry* GetXmlIdRegistry() const;
 };
Index: sw/inc/unocoll.hxx
===================================================================
--- sw/inc/unocoll.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/inc/unocoll.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -43,6 +43,7 @@
 #include <cppuhelper/implbase4.hxx>	// helper for implementations
 #include <IMark.hxx>
 #include <unobaseclass.hxx>
+#include "swdllapi.h"
 /***************************************************
  ***************************************************
  *
@@ -196,9 +197,12 @@
 #define SW_SERVICE_CHART2_DATA_PROVIDER                 106
 #define SW_SERVICE_TYPE_FIELDMARK                       107
 #define SW_SERVICE_TYPE_FORMFIELDMARK                   108
 #define SW_SERVICE_TYPE_META                            109
+#define SW_SERVICE_VBAOBJECTPROVIDER                    110
+#define SW_SERVICE_VBACODENAMEPROVIDER                  111
+#define SW_SERVICE_VBAPROJECTNAMEPROVIDER               112
 
-#define SW_SERVICE_LAST                 SW_SERVICE_TYPE_META
+#define SW_SERVICE_LAST                 SW_SERVICE_VBAPROJECTNAMEPROVIDER
 
 #define SW_SERVICE_INVALID			USHRT_MAX
 
@@ -283,7 +287,7 @@
 	::com::sun::star::lang::XServiceInfo
 >
 SwCollectionBaseClass;
-class SwXTextTables : public SwCollectionBaseClass,
+class SW_DLLPUBLIC SwXTextTables : public SwCollectionBaseClass,
 	public SwUnoCollection
 {
 protected:
Index: sw/inc/unotbl.hxx
===================================================================
--- sw/inc/unotbl.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/inc/unotbl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -214,14 +214,13 @@
 								::com::sun::star::lang::XServiceInfo,
 								::com::sun::star::beans::XPropertySet
 							> SwXTextTableCursor_Base;
-class SwXTextTableCursor : public SwXTextTableCursor_Base
+class SW_DLLPUBLIC SwXTextTableCursor : public SwXTextTableCursor_Base
 	,public SwClient
 	,public OTextCursorHelper
 {
 	SwDepend 				aCrsrDepend;
     const SfxItemPropertySet*   m_pPropSet;
 
-	SwFrmFmt* 		GetFrmFmt() const { return (SwFrmFmt*)GetRegisteredIn(); }
 	//	SwUnoCrsr* 		GetCrsr() const { return (SwUnoCrsr*)aCrsrDepend.GetRegisteredIn(); }
 
 protected:
@@ -271,6 +270,7 @@
 
 	const SwUnoCrsr*			GetCrsr() const;
 	SwUnoCrsr*					GetCrsr();
+	SwFrmFmt* 		GetFrmFmt() const { return (SwFrmFmt*)GetRegisteredIn(); }
 };
 
 /*-----------------11.12.97 09:38-------------------
Index: sw/inc/unomap.hxx
===================================================================
--- sw/inc/unomap.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/inc/unomap.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -250,6 +250,7 @@
 #define WID_DOC_LOCK_UPDATES                    1016
 #define WID_DOC_HAS_VALID_SIGNATURES            1017
 #define WID_DOC_BUILDID							1024
+#define WID_DOC_ISTEMPLATEID						1025
 // --> OD 2006-03-21 #b6375613#
 #define WID_APPLY_WORKAROUND_FOR_B6375613       1070
 // <--
@@ -294,6 +295,7 @@
 
 #define WID_LAYOUT_SIZE                         1104
 #define WID_DOC_DIALOG_LIBRARIES                1105
+#define WID_DOC_VBA_DOCOBJ                      1106
 
 
 //AutoText
Index: sw/prj/build.lst
===================================================================
--- sw/prj/build.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1,4 +1,4 @@
-sw	sw	:    l10n connectivity OOo:writerperfect OOo:lotuswordpro svx stoc uui writerfilter NULL
+sw	sw	:    l10n connectivity OOo:writerperfect OOo:lotuswordpro svx stoc uui writerfilter vbahelper NULL
 sw	sw										usr1	-	all	sw_mkout NULL
 sw	sw\inc									nmake		-	all	sw_inc NULL
 sw	sw\uiconfig\layout									nmake	-	all	sw_layout NULL
@@ -33,6 +33,7 @@
 sw      sw\source\ui\table                                              nmake   -       all     sw_table sw_inc NULL
 sw	sw\source\ui\uiview						nmake	-	all	sw_uivw sw_sdi sw_inc NULL
 sw	sw\source\ui\uno						nmake	-	all	sw_uiuno sw_sdi sw_inc NULL
+sw	sw\source\ui\vba						nmake	-	all	sw_vba sw_inc NULL
 sw	sw\source\ui\utlui						nmake	-	all	sw_utlui sw_inc NULL
 sw	sw\source\ui\web						nmake	-	all	sw_web sw_uinc sw_sdi sw_inc NULL
 sw	sw\source\ui\wrtsh						nmake	-	all	sw_wrtsh sw_inc NULL
@@ -69,7 +70,7 @@
 sw      sw\source\filter\ww1                nmake   -       all     sw_ww1 sw_inc NULL
 sw      sw\source\filter\ww8                nmake   -       all     sw_ww8 sw_inc NULL
 sw      sw\source\filter\xml                nmake   -       all     sw_xml sw_inc NULL
-sw      sw\source\ui                        nmake   -       all     sw_ui sw_app sw_cctrl sw_chrdl sw_conf sw_dbui sw_dchdl sw_dcvw sw_dlg sw_envlp sw_fldui sw_fmtui sw_frmdl sw_globd sw_index sw_ling sw_misc sw_rbbar sw_shell sw_table sw_uiuno sw_uivw sw_utlui sw_web sw_wrtsh sw_smartmenu NULL
+sw      sw\source\ui                        nmake   -       all     sw_ui sw_app sw_cctrl sw_chrdl sw_conf sw_dbui sw_dchdl sw_dcvw sw_dlg sw_envlp sw_fldui sw_fmtui sw_frmdl sw_globd sw_index sw_ling sw_misc sw_rbbar sw_shell sw_table sw_uiuno sw_uivw sw_utlui sw_web sw_wrtsh sw_smartmenu sw_vba NULL
 sw      sw\source\core                      nmake   -       all     sw_core sw_attr sw_bast sw_crsr sw_dcnd sw_doc sw_draw sw_edit sw_excpt sw_fld sw_frmed sw_grph sw_layo sw_ole sw_para sw_sw3io sw_swg sw_text sw_tox sw_txtnd sw_uco sw_undo sw_view sw_acc sw_objpos sw_NumberTree sw_tablecore NULL
 sw      sw\source\filter                    nmake   -       all     sw_flt sw_ascii sw_bsflt sw_html sw_rtf sw_wrtr sw_ww1 sw_ww8 sw_xml NULL
 sw      sw\util                             nmake   -       all     sw_util sw_core sw_flt sw_sdi sw_ui NULL
Index: sw/prj/d.lst
===================================================================
--- sw/prj/d.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/prj/d.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -63,6 +63,7 @@
 ..\%__SRC%\bin\swd?????.dll %_DEST%\bin%_EXT%\swd?????.dll
 ..\%__SRC%\bin\swui?????.dll %_DEST%\bin%_EXT%\swui?????.dll
 ..\%__SRC%\bin\msword?????.dll %_DEST%\bin%_EXT%\msword?????.dll
+..\%__SRC%\bin\vbaswobj*.dll %_DEST%\bin%_EXT%\vbaswobj*.dll
 ..\%__SRC%\bin\sw*.res %_DEST%\bin%_EXT%\sw*.res
 ..\%__SRC%\lib\lib*.* %_DEST%\lib%_EXT%\lib*.*
 
Index: sw/util/makefile.mk
===================================================================
--- sw/util/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ sw/util/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -127,6 +127,7 @@
 	$(SALHELPERLIB) \
     $(ICUUCLIB) \
 	$(I18NUTILLIB)	\
+		        $(VBAHELPERLIB) \
 	$(AVMEDIALIB)
 
 .IF "$(GUI)"=="WNT"
@@ -338,6 +339,40 @@
 	$(CPPUHELPERLIB) \
 	$(SALLIB) \
 	$(ICUUCLIB) \
+    $(BASICLIB)     \
 	$(I18NUTILLIB)
 
+#target vba
+TARGET_VBA=vbaswobj
+SHL5TARGET=$(TARGET_VBA)$(DLLPOSTFIX).uno
+SHL5IMPLIB=     i$(TARGET_VBA)
+
+SHL5VERSIONMAP=$(TARGET_VBA).map
+SHL5DEF=$(MISC)$/$(SHL5TARGET).def
+DEF5NAME=$(SHL5TARGET)
+SHL5STDLIBS= \
+                $(ISWLIB) \
+                $(CPPUHELPERLIB) \
+                $(VCLLIB) \
+                $(CPPULIB) \
+                $(COMPHELPERLIB) \
+                $(SVLIB) \
+	            $(UNOTOOLSLIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)\
+		        $(VBAHELPERLIB) \
+                $(BASICLIB)     \
+                $(SFXLIB)       \
+                $(SVXLIB)       \
+                $(SVTOOLLIB)    \
+                $(SVLLIB) \
+                $(VCLLIB) \
+                $(TKLIB) \
+                $(I18NISOLANGLIB) \
+	            $(SVXCORELIB) \
+                $(SVXMSFILTERLIB) \
+
+SHL5DEPN=$(SHL1TARGETN)
+SHL5LIBS=$(SLB)$/$(TARGET_VBA).lib
+
 .INCLUDE :  target.mk
Index: sw/util/vbaswobj.map
===================================================================
--- sw/util/vbaswobj.map	(.../tags/DEV300_m58)	(revision 0)
+++ sw/util/vbaswobj.map	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
Index: extensions/source/ole/oleobjw.cxx
===================================================================
--- extensions/source/ole/oleobjw.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/ole/oleobjw.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -72,6 +72,7 @@
 using namespace osl;
 using namespace rtl;
 using namespace cppu;
+using namespace com::sun::star::script;
 using namespace com::sun::star::lang;
 using namespace com::sun::star::bridge;
 using namespace com::sun::star::bridge::oleautomation;
@@ -111,7 +112,7 @@
 										   sal_uInt8 unoWrapperClass, sal_uInt8 comWrapperClass):
 	UnoConversionUtilities<IUnknownWrapper_Impl>( xFactory, unoWrapperClass, comWrapperClass),
 	m_pxIdlClass( NULL), m_eJScript( JScriptUndefined),
-    m_bComTlbIndexInit(false)
+    m_bComTlbIndexInit(false),  m_bHasDfltMethod(false), m_bHasDfltProperty(false)
 {
 }
 
@@ -150,17 +151,15 @@
 Any IUnknownWrapper_Impl::queryInterface(const Type& t)
     throw (RuntimeException)
 {
-    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)))
-    {
-        if (m_spDispatch)
-            return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-                XInitialization, XAutomationObject>::queryInterface(t);
-        else
-            return Any();
-    }
+    if (t == getCppuType(static_cast<Reference<XDefaultMethod>*>( 0)) && !m_bHasDfltMethod )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XDefaultProperty>*>( 0)) && !m_bHasDfltProperty )
+        return Any();
+    if (t == getCppuType(static_cast<Reference<XInvocation>*>( 0)) && !m_spDispatch)
+        return Any();
 
-    return WeakImplHelper4<XInvocation, XBridgeSupplier2,
-        XInitialization, XAutomationObject>::queryInterface(t);
+    return WeakImplHelper6<XInvocation, XBridgeSupplier2,
+        XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>::queryInterface(t);
 }
 
 Reference<XIntrospectionAccess> SAL_CALL IUnknownWrapper_Impl::getIntrospection(void)
@@ -425,6 +424,46 @@
     {
         o2u_attachCurrentThread();
         ITypeInfo * pInfo = getTypeInfo();
+        // I was going to implement an XServiceInfo interface to allow the type
+        // of the automation object to be exposed.. but it seems
+        // from looking at comments in the code that it is possible for a 
+        // this object to actually wrap an UNO object ( I guess if automation is
+        // used from MSO to create Openoffice objects ) Therefore, those objects
+        // will more than likely already have an XServiceInfo interface.
+        // Instead here I chose a name that should be illegal both in COM and
+        // UNO ( from an IDL point of view ) therefore I think this is a safe
+        // hack
+        if ( aPropertyName.equals( rtl::OUString::createFromAscii("$GetTypeName") )) 
+        {
+            if ( pInfo && m_sTypeName.getLength() == 0 )
+            {
+            	 m_sTypeName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IDispatch") );
+                CComBSTR sName;
+                
+                if ( SUCCEEDED( pInfo->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                {
+                    rtl::OUString sTmp( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                    if ( sTmp.indexOf('_')  == 0 )
+                       sTmp = sTmp.copy(1);
+                    // do we own the memory for pTypeLib, msdn doco is vague
+                    // I'll assume we do 
+                    CComPtr< ITypeLib > pTypeLib;
+                    unsigned int index;
+                    if ( SUCCEEDED(  pInfo->GetContainingTypeLib(  &pTypeLib.p, &index )) )
+                    {
+                        if ( SUCCEEDED( pTypeLib->GetDocumentation( -1, &sName, NULL, NULL, NULL  ) ) )
+                        {
+                            rtl::OUString sLibName( reinterpret_cast<const sal_Unicode*>(LPCOLESTR(sName)));
+                            m_sTypeName = sLibName.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) ).concat( sTmp );
+                            
+                        }
+                    }
+                }
+                
+            }
+            ret <<= m_sTypeName;
+            return ret;
+        }
         FuncDesc aDescGet(pInfo);
         FuncDesc aDescPut(pInfo);
         VarDesc aVarDesc(pInfo);
@@ -1157,6 +1196,47 @@
 
     aArguments[1] >>= m_bOriginalDispatch;    
 	aArguments[2] >>= m_seqTypes;
+    try
+    {
+        ITypeInfo* pType= getTypeInfo();
+        // Get Default member
+        CComBSTR defaultMemberName;
+        if ( SUCCEEDED( pType->GetDocumentation(0, &defaultMemberName, 0, 0, 0 ) ) )
+        {
+            OUString usName(reinterpret_cast<const sal_Unicode*>(LPCOLESTR(defaultMemberName)));
+            FuncDesc aDescGet(pType);
+            FuncDesc aDescPut(pType);
+            VarDesc aVarDesc(pType);
+            // see if this is a property first ( more likely to be a property then a method )
+            getPropDesc( usName, & aDescGet, & aDescPut, & aVarDesc);
+
+            if ( !aDescGet && !aDescPut )
+            {
+                getFuncDesc( usName, &aDescGet );
+                if ( !aDescGet )
+                    // we're knackered
+                    throw RuntimeException();
+                
+            }
+            // now for some funny heuristics to make basic understand what to do
+            // a single aDescGet ( that doesn't take any params ) would be 
+            // a read only ( defaultmember ) property e.g. this object
+            // should implement XDefaultProperty
+            // a single aDescGet ( that *does* ) take params is basically a
+            // default method e.g. implement XDefaultMethod
+            
+            // a DescPut ( I guess we only really support a default param with '1' param ) as a setValue ( but I guess we can leave it through, the object will fail if we don't get it right anyway )
+            if ( aDescPut || ( aDescGet && aDescGet->cParams == 0 ) )
+                m_bHasDfltProperty = true;
+            if ( aDescGet->cParams > 0 )
+                m_bHasDfltMethod = true;
+            if ( m_bHasDfltProperty || m_bHasDfltMethod )
+                m_sDefaultMember = usName;
+        }
+    }
+    catch( Exception& )
+    {
+    } 
 }
 
 // UnoConversionUtilities --------------------------------------------------------------------------------
@@ -1408,6 +1488,9 @@
         arDispidNamedArgs.reset(new DISPID[nSizeAr]);   
         HRESULT hr = getTypeInfo()->GetIDsOfNames(arNames, nSizeAr,
                                                   arDispidNamedArgs.get()); 
+        if ( hr == E_NOTIMPL )
+            hr = m_spDispatch->GetIDsOfNames(IID_NULL, arNames, nSizeAr, LOCALE_USER_DEFAULT, arDispidNamedArgs.get() );
+
         if (hr == S_OK)
         {
             // In a "property put" operation, the property value is a named param with the
Index: extensions/source/ole/oleobjw.hxx
===================================================================
--- extensions/source/ole/oleobjw.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/ole/oleobjw.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -53,11 +53,14 @@
 #endif
 #include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase4.hxx>
+#include <cppuhelper/implbase6.hxx>
 
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/bridge/oleautomation/XAutomationObject.hpp>
 #include <rtl/ustring.hxx>
 
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
 
 #include <typelib/typedescription.hxx>
 #include "unoconversionutilities.hxx"
@@ -81,7 +84,8 @@
 // This class wraps an IDispatch and maps XInvocation calls to IDispatch calls on the wrapped object.
 // If m_TypeDescription is set then this class represents an UNO interface implemented in a COM component.
 // The interface is not a real interface in terms of an abstract class but is realized through IDispatch.
-class IUnknownWrapper_Impl : public WeakImplHelper4<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject>,
+class IUnknownWrapper_Impl : public WeakImplHelper6<XInvocation, XBridgeSupplier2, XInitialization, XAutomationObject, XDefaultProperty, XDefaultMethod>,
+
 							 public UnoConversionUtilities<IUnknownWrapper_Impl>
 
 {
@@ -129,8 +133,10 @@
 	// XInitialization
     virtual void SAL_CALL initialize( const Sequence< Any >& aArguments )
         throw(Exception, RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
 protected:
-    
+    virtual ::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (::com::sun::star::uno::RuntimeException) { return m_sDefaultMember; }
+
 	// ----------------------------------------------------------------------------
     virtual Any invokeWithDispIdUnoTlb(const OUString& sFunctionName,
                                        const Sequence< Any >& Params,
@@ -237,6 +243,7 @@
 	Sequence<Type> m_seqTypes;
 	CComPtr<IUnknown> m_spUnknown;
 	CComPtr<IDispatch> m_spDispatch;
+        rtl::OUString m_sTypeName; // is "" ( not initialised ), "IDispatch" ( we have no idea ) or "SomeLibrary.SomeTypeName" if we managed to get a type
     /** This value is set dureing XInitialization::initialize. It indicates that the COM interface
     was transported as VT_DISPATCH in a VARIANT rather then a VT_UNKNOWN
     */
@@ -255,6 +262,9 @@
     bool m_bComTlbIndexInit;
 	// Keeps the ITypeInfo obtained from IDispatch::GetTypeInfo
 	CComPtr< ITypeInfo > m_spTypeInfo;
+    rtl::OUString m_sDefaultMember;
+    bool m_bHasDfltMethod;
+    bool m_bHasDfltProperty;
 };
 
 } // end namespace
Index: extensions/source/propctrlr/defaultforminspection.cxx
===================================================================
--- extensions/source/propctrlr/defaultforminspection.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/defaultforminspection.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -154,7 +154,7 @@
             { "com.sun.star.form.inspection.EventHandler", false },
 
             // a handler which introduces virtual properties for binding controls to spreadsheet cells
-            { "com.sun.star.form.inspection.CellBindingPropertyHandler", true },
+            { "com.sun.star.form.inspection.CellBindingPropertyHandler", false },
 
             // properties related to binding to an XForms DOM node
             { "com.sun.star.form.inspection.XMLFormsPropertyHandler", true },
Index: extensions/source/propctrlr/formres.src
===================================================================
--- extensions/source/propctrlr/formres.src	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/formres.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -234,6 +234,10 @@
 {
 	Text [ en-US ] = "Name" ;
 };
+String RID_STR_GROUP_NAME
+{
+	Text [ en-US ] = "Group name" ;
+};
 String RID_STR_TABINDEX
 {
 	Text [ en-US ] = "Tab order" ;
Index: extensions/source/propctrlr/formmetadata.cxx
===================================================================
--- extensions/source/propctrlr/formmetadata.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/formmetadata.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -143,6 +143,7 @@
         DEF_INFO_3( LABEL,             LABEL,              LABEL,             FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( CONTROLLABEL,      LABELCONTROL,       CONTROLLABEL,      FORM_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( WRITING_MODE,      WRITING_MODE,       WRITING_MODE,      FORM_VISIBLE, ENUM, COMPOSEABLE ),
+        DEF_INFO_3( GROUP_NAME,        GROUP_NAME,         GROUP_NAME,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_2( TEXT,              TEXT,               TEXT,              DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( MAXTEXTLEN,        MAXTEXTLEN,         MAXTEXTLEN,        FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
         DEF_INFO_3( EDITMASK,          EDITMASK,           EDITMASK,          FORM_VISIBLE, DIALOG_VISIBLE, COMPOSEABLE ),
Index: extensions/source/propctrlr/formresid.hrc
===================================================================
--- extensions/source/propctrlr/formresid.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/formresid.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -152,6 +152,7 @@
 #define RID_STR_CURSOR_TYPE					( RID_FORMBROWSER_START + 121 )
 #define RID_STR_ENABLE_VISIBLE              ( RID_FORMBROWSER_START + 122 )
 #define RID_STR_WHEEL_BEHAVIOR              ( RID_FORMBROWSER_START + 123 )
+#define RID_STR_GROUP_NAME                  ( RID_FORMBROWSER_START + 124 )
     // FREE
     // FREE
     // FREE
Index: extensions/source/propctrlr/eventhandler.cxx
===================================================================
--- extensions/source/propctrlr/eventhandler.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/eventhandler.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -65,6 +65,7 @@
 /** === end UNO includes === **/
 
 #include <comphelper/namedvaluecollection.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <comphelper/types.hxx>
 #include <cppuhelper/implbase1.hxx>
 #include <rtl/ref.hxx>
@@ -172,36 +173,6 @@
     namespace
     {
         //....................................................................
-        Sequence< ::rtl::OUString > lcl_getListenerMethodsForType( const Type& type )
-        {
-            typelib_InterfaceTypeDescription *pType=0;
-            type.getDescription( (typelib_TypeDescription**)&pType);
-
-            if ( !pType )
-                return Sequence< ::rtl::OUString>();
-
-            Sequence< ::rtl::OUString > aNames( pType->nMembers );
-            ::rtl::OUString* pNames = aNames.getArray();
-            for ( sal_Int32 i = 0; i < pType->nMembers; ++i, ++pNames)
-            {
-                // the decription reference
-                typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-                // the description for the reference
-                typelib_TypeDescription* pMemberDescription = NULL;
-                typelib_typedescriptionreference_getDescription( &pMemberDescription, pMemberDescriptionReference );
-                if ( pMemberDescription )
-                {
-                    typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-                        reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-                    *pNames = pRealMemberDescription->pMemberName;
-                }
-            }
-
-            typelib_typedescription_release( (typelib_TypeDescription*)pType );
-            return aNames;
-        }
-
-        //....................................................................
         #define DESCRIBE_EVENT( asciinamespace, asciilistener, asciimethod, id_postfix ) \
             s_aKnownEvents.insert( EventMap::value_type( \
                 ::rtl::OUString::createFromAscii( asciimethod ), \
@@ -822,7 +793,7 @@
                         continue;
 
                     // loop through all methods
-                    Sequence< ::rtl::OUString > aMethods( lcl_getListenerMethodsForType( *pListeners ) );
+                    Sequence< ::rtl::OUString > aMethods( comphelper::getEventMethodsForType( *pListeners ) );
 
                     const ::rtl::OUString* pMethods = aMethods.getConstArray();
                     sal_uInt32 methodCount = aMethods.getLength();
Index: extensions/source/propctrlr/formstrings.hxx
===================================================================
--- extensions/source/propctrlr/formstrings.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/formstrings.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,7 @@
     PCR_CONSTASCII_STRING( PROPERTY_WHEEL_BEHAVIOR,         "MouseWheelBehavior");
 	PCR_CONSTASCII_STRING( PROPERTY_TAG,					"Tag");
 	PCR_CONSTASCII_STRING( PROPERTY_NAME,					"Name");
+	PCR_CONSTASCII_STRING( PROPERTY_GROUP_NAME,             "GroupName");
 	PCR_CONSTASCII_STRING( PROPERTY_VALUE,					"Value");
 	PCR_CONSTASCII_STRING( PROPERTY_TEXT,					"Text");
 	PCR_CONSTASCII_STRING( PROPERTY_NAVIGATION,				"NavigationBarMode");
Index: extensions/source/propctrlr/formmetadata.hxx
===================================================================
--- extensions/source/propctrlr/formmetadata.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/source/propctrlr/formmetadata.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -166,6 +166,7 @@
 	#define PROPERTY_ID_ALLOWADDITIONS		 20
 	#define PROPERTY_ID_ALLOWEDITS			 21
 	#define PROPERTY_ID_ALLOWDELETIONS		 22
+	#define PROPERTY_ID_GROUP_NAME    		 23
 	#define PROPERTY_ID_NAVIGATION			 24
 	#define PROPERTY_ID_CYCLE				 25
 	#define PROPERTY_ID_HIDDEN_VALUE		 26
Index: extensions/inc/extensio.hrc
===================================================================
--- extensions/inc/extensio.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/inc/extensio.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -459,9 +459,10 @@
 #define HID_PROP_NOLABEL                        (HID_FORMS_START + 340)
 #define HID_PROP_WRITING_MODE                   (HID_FORMS_START + 341)
 #define HID_PROP_ANCHOR_TYPE                    (HID_FORMS_START + 343)
+#define HID_PROP_GROUP_NAME                     (HID_FORMS_START + 344)
     // please adjust HID_LAST_FORMS_ID if you add new ids here!
 
-#define HID_LAST_FORMS_ID   HID_PROP_ANCHOR_TYPE
+#define HID_LAST_FORMS_ID   HID_PROP_GROUP_NAME
 
 #if HID_LAST_FORMS_ID > HID_FORMS_END
     #error id overflow
Index: extensions/util/hidother.src
===================================================================
--- extensions/util/hidother.src	(.../tags/DEV300_m58)	(revision 277097)
+++ extensions/util/hidother.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -213,6 +213,7 @@
 hidspecial HID_PROP_FONT                        { HelpId = HID_PROP_FONT; }
 hidspecial HID_PROP_FORMATKEY                   { HelpId = HID_PROP_FORMATKEY; }
 hidspecial HID_PROP_GROUPBOX                    { HelpId = HID_PROP_GROUPBOX; }
+hidspecial HID_PROP_GROUP_NAME                  { HelpId = HID_PROP_GROUP_NAME; }
 hidspecial HID_PROP_HEIGHT                      { HelpId = HID_PROP_HEIGHT; }
 hidspecial HID_PROP_HELPTEXT                    { HelpId = HID_PROP_HELPTEXT; }
 hidspecial HID_PROP_HELPURL                     { HelpId = HID_PROP_HELPURL; }
Index: offapi/com/sun/star/drawing/Shape.idl
===================================================================
--- offapi/com/sun/star/drawing/Shape.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ offapi/com/sun/star/drawing/Shape.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -195,6 +195,10 @@
 		the z-order.
 	*/
 	[optional, property] long NavigationOrder;
+
+	/** this property lets you get and set a hyperlink for this shape.
+	 */
+	[optional, property] string Hyperlink;
 };
 
 //=============================================================================
Index: offapi/com/sun/star/document/XVbaMethodParameter.idl
===================================================================
--- offapi/com/sun/star/document/XVbaMethodParameter.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/XVbaMethodParameter.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright IBM Corporation 2009
+ * Copyright 2009 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaMethodParameter,v $
+ * $Revision: 1.13 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef __org_openoffice_vba_XVbaMethodParameter_idl__
+#define __org_openoffice_vba_XVbaMethodParameter_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//============================================================================= 
+
+module com {  module sun {  module star {  module document {
+
+//============================================================================= 
+//gives access to vba method input/output parameters
+//
+//some OO objects need to implement this interface to support the passing of input/output parameters
+//for certain VBA events
+
+interface XVbaMethodParameter : com::sun::star::uno::XInterface
+{
+	//------------------------------------------------------------------------- 
+	 
+	/** sets the value of the parameter with the specified name.
+	 */
+	void setVbaMethodParameter( [in] string PropertyName, 
+			 [in] any Value ); 
+ 
+	//------------------------------------------------------------------------- 
+
+	/** returns the value of the parameter with the specified name.
+     */
+	any getVbaMethodParameter( [in] string PropertyName ); 
+};
+
+//============================================================================= 
+
+}; }; }; };
+#endif
Index: offapi/com/sun/star/document/makefile.mk
===================================================================
--- offapi/com/sun/star/document/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ offapi/com/sun/star/document/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -116,8 +116,16 @@
     LinkUpdateModes.idl\
     XDocumentRevisionListPersistence.idl\
     DocumentRevisionListPersistence.idl \
-    XDocumentLanguages.idl
+    XDocumentLanguages.idl \
+    XCodeNameQuery.idl \
+    XDocumentEventCompatibleHelper.idl \
+    XCompatWriterDocProperties.idl \
+    XVbaMethodParameter.idl \
+    VbaEventId.idl \
+    XVbaEventsHelper.idl \
+    VbaEventsHelper.idl \
 
+
 # ------------------------------------------------------------------
 
 .INCLUDE :  target.mk
Index: offapi/com/sun/star/document/VbaEventId.idl
===================================================================
--- offapi/com/sun/star/document/VbaEventId.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/VbaEventId.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventId_idl__
+#define __org_openoffice_vba_VbaEventId_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+/* VBA compatibility event id */
+constants VbaEventId
+{
+    // Worksheet
+    const long VBAEVENT_WORKSHEET_ACTIVATE                  	= 1;
+    const long VBAEVENT_WORKSHEET_BEFOREDOUBLECLICK         	= 2;
+    const long VBAEVENT_WORKSHEET_BEFORERIGHTCLICK          	= 3;
+    const long VBAEVENT_WORKSHEET_CALCULATE                 	= 4;
+    const long VBAEVENT_WORKSHEET_CHANGE                    	= 5;
+    const long VBAEVENT_WORKSHEET_DEACTIVATE                	= 6;
+    const long VBAEVENT_WORKSHEET_FOLLOWHYPERLINK           	= 7;
+    const long VBAEVENT_WORKSHEET_PIVOTTABLEUPDATE          	= 8;
+    const long VBAEVENT_WORKSHEET_SELECTIONCHANGE           	= 9;
+    // Workbook
+    const long VBAEVENT_WORKBOOK_ACTIVATE            			= 20;
+    const long VBAEVENT_WORKBOOK_DEACTIVATE          			= 21;
+    const long VBAEVENT_WORKBOOK_OPEN                			= 22;
+    const long VBAEVENT_WORKBOOK_AUTOOPEN            			= 23;
+    const long VBAEVENT_WORKBOOK_BEFORECLOSE         			= 24;
+    const long VBAEVENT_WORKBOOK_BEFOREPRINT         			= 25;
+    const long VBAEVENT_WORKBOOK_BEFORESAVE          			= 26;
+    const long VBAEVENT_WORKBOOK_NEWSHEET            			= 27;
+    const long VBAEVENT_WORKBOOK_WINDOWACTIVATE      			= 28;
+    const long VBAEVENT_WORKBOOK_WINDOWDEACTIVATE    			= 29;
+    const long VBAEVENT_WORKBOOK_WINDOWRESIZE        			= 30;
+    // Workbook_sheet
+    const long VBAEVENT_WORKBOOK_SHEET_ACTIVATE               	= 51;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFOREDOUBLECLICK      	= 52;
+    const long VBAEVENT_WORKBOOK_SHEET_BEFORERIGHTCLICK       	= 53;
+    const long VBAEVENT_WORKBOOK_SHEET_CALCULATE              	= 54;
+    const long VBAEVENT_WORKBOOK_SHEET_CHANGE                 	= 55;
+    const long VBAEVENT_WORKBOOK_SHEET_DEACTIVATE             	= 56;
+    const long VBAEVENT_WORKBOOK_SHEET_FOLLOWHYPERLINK        	= 57;
+    const long VBAEVENT_WORKBOOK_SHEET_PIVOTTABLEUPDATE       	= 58;
+    const long VBAEVENT_WORKBOOK_SHEET_SELECTIONCHANGE        	= 59;
+};
+
+}; }; }; };
+
+#endif
Index: offapi/com/sun/star/document/XCodeNameQuery.idl
===================================================================
--- offapi/com/sun/star/document/XCodeNameQuery.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/XCodeNameQuery.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDocumentPropertiesSupplier.idl,v $
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCodeNameQuery_idl__
+#define __com_sun_star_document_XCodeNameQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+//=============================================================================
+interface XCodeNameQuery
+{
+	//-------------------------------------------------------------------------
+    string getCodeNameForObject( [in] com::sun::star::uno::XInterface aObj );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
Index: offapi/com/sun/star/document/XCompatWriterDocProperties.idl
===================================================================
--- offapi/com/sun/star/document/XCompatWriterDocProperties.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/XCompatWriterDocProperties.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XDocumentProperties.idl,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XCompatWriterDocProperties_idl__
+#define __com_sun_star_document_XCompatWriterDocProperties_idl__
+
+#ifndef __com_sun_star_document_XDocumentProperties_idl__
+#include <com/sun/star/document/XDocumentProperties.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+interface XCompatWriterDocProperties
+{
+//    interface ::com::sun::star::document::XDocumentProperties;
+    [attribute] string Manager;
+    [attribute] string Category;
+    [attribute] string Company;
+
+
+}; }; }; };
+};
+#endif
Index: offapi/com/sun/star/document/XVbaEventsHelper.idl
===================================================================
--- offapi/com/sun/star/document/XVbaEventsHelper.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/XVbaEventsHelper.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_XVbaEventsHelper_idl__
+#define __org_openoffice_vba_XVbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {  module sun {  module star {  module document {
+//=============================================================================
+
+interface XVbaEventsHelper
+{
+    /**
+        Execute VBA compatible event.
+        VbaEvent: Compatible VBA event id.
+        aArgs: the array of input arguments.
+        return: True if execute successfully, or False.
+    **/
+    boolean ProcessCompatibleVbaEvent( [in] long nEventId, [in] sequence< any > aArgs );
+    [attribute ] boolean IgnoreEvents;
+};
+
+}; }; }; };
+
+#endif
Index: offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl
===================================================================
--- offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/XDocumentEventCompatibleHelper.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XVbaEventHelper.idl,v $
+ * $Revision: 1.0 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+#define __com_sun_star_document_XDocumentEventCompatibleHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+//=============================================================================
+
+module com {   module sun {   module star {   module document {
+
+//=============================================================================
+interface XDocumentEventCompatibleHelper
+{
+    /* Execute some compatible VBA event related to document, such as document save, document print.
+       nEventId: event id.
+    */
+    boolean processCompatibleEvent( [in] short nEventId );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
Index: offapi/com/sun/star/document/VbaEventsHelper.idl
===================================================================
--- offapi/com/sun/star/document/VbaEventsHelper.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/document/VbaEventsHelper.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __org_openoffice_vba_VbaEventsHelper_idl__
+#define __org_openoffice_vba_VbaEventsHelper_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+#include <com/sun/star/frame/XModel.idl>
+#include <com/sun/star/document/XVbaEventsHelper.idl>
+//=============================================================================
+
+module com {  module sun {  module star { module document {
+//=============================================================================
+
+service VbaEventsHelper : XVbaEventsHelper
+{
+  	createVbaEventsHelper(  [in] ::com::sun::star::frame::XModel xModel );
+};
+
+}; }; }; };
+
+#endif
Index: offapi/com/sun/star/script/makefile.mk
===================================================================
--- offapi/com/sun/star/script/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ offapi/com/sun/star/script/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -51,6 +51,8 @@
 	XLibraryContainerExport.idl\
 	XPersistentLibraryContainer.idl\
 	XStorageBasedLibraryContainer.idl\
+	XLibraryQueryExecutable.idl \
+	XVBACompat.idl\
 	ModuleSizeExceededRequest.idl\
 
 # ------------------------------------------------------------------
Index: offapi/com/sun/star/script/XLibraryQueryExecutable.idl
===================================================================
--- offapi/com/sun/star/script/XLibraryQueryExecutable.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/script/XLibraryQueryExecutable.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+#define __com_sun_star_script_XLibraryQueryExecutable_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XLibraryQueryExecutable: com::sun::star::uno::XInterface
+{ 
+	boolean HasExecutableCode( [in] string name );
+};
+
+//============================================================================= 
+ 
+ 
+}; }; }; };  
+ 
+#endif 
Index: offapi/com/sun/star/script/XVBACompat.idl
===================================================================
--- offapi/com/sun/star/script/XVBACompat.idl	(.../tags/DEV300_m58)	(revision 0)
+++ offapi/com/sun/star/script/XVBACompat.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XLibraryContainer.idl,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XVBACompat_idl__ 
+#define __com_sun_star_script_XVBACompat_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+ 
+interface XVBACompat: com::sun::star::uno::XInterface
+{ 
+
+//============================================================================= 
+    [attribute ] boolean VBACompatModeOn;
+ 
+}; }; }; };  
+}; 
+#endif 
Index: offapi/com/sun/star/ui/ItemStyle.idl
===================================================================
--- offapi/com/sun/star/ui/ItemStyle.idl	(.../tags/DEV300_m58)	(revision 277097)
+++ offapi/com/sun/star/ui/ItemStyle.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -149,6 +149,7 @@
         <p>This style is only valid if the item describes a toolbar item.</p>
     */
     const short DROPDOWN_ONLY = 1024;
+    const short TEXT = 2048;
 };
 
 }; }; }; };
Index: scp2/source/ooo/file_library_ooo.scp
===================================================================
--- scp2/source/ooo/file_library_ooo.scp	(.../tags/DEV300_m58)	(revision 277097)
+++ scp2/source/ooo/file_library_ooo.scp	(.../cws/vbasupportdev300)	(revision 277097)
@@ -71,6 +71,20 @@
   #endif
 End
 
+#ifdef ENABLE_VBA
+File gid_File_Lib_Vbaevent
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT4(vbaevents,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT4(vbaevents,DLLPOSTFIX,.uno,.dll));
+  #endif
+End
+#endif // ENABLE_VBA
+
 STD_UNO_LIB_FILE( gid_File_Lib_Bib , bib)
 
 File gid_File_Lib_Cached1
@@ -400,7 +414,42 @@
   #endif
 End
 
+File gid_File_Lib_Vbaswobj
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT4(libvbaswobj,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT4(vbaswobj,DLLPOSTFIX,.uno,.dll));
+  #endif
+End
+
+File gid_File_Lib_Vbamsforms
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT4(libmsforms,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT4(msforms,DLLPOSTFIX,.uno,.dll));
+  #endif
+End
+
 #endif // VBA_EXTENSION
+File gid_File_Lib_Vbahelper
+    TXT_FILE_BODY;
+    Styles = (PACKED);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = SCP2_OOO_BIN_DIR;
+  #ifdef UNX
+    Name = STRING(CONCAT3(libvbahelper,DLLPOSTFIX,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT3(vbahelper,DLLPOSTFIX,.dll));
+  #endif
+End
 #endif // ENABLE_VBA
 
 
Index: formula/source/core/api/FormulaCompiler.cxx
===================================================================
--- formula/source/core/api/FormulaCompiler.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ formula/source/core/api/FormulaCompiler.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -723,6 +723,30 @@
     return bFound ? (*iLook).second : OpCode(ocNone);
 }
 
+bool FormulaCompiler::IsOpCodeVolatile( OpCode eOp )
+{
+    switch (eOp)
+    {
+        // no parameters:
+        case ocRandom:
+        case ocGetActDate:
+        case ocGetActTime:
+        // one parameter:
+        case ocFormula:
+        case ocInfo:
+        // more than one parameters:
+            // ocIndirect/ocIndirectXL otherwise would have to do
+            // StopListening and StartListening on a reference for every
+            // interpreted value.
+        case ocIndirect:
+        case ocIndirectXL:
+            // ocOffset results in indirect references.
+        case ocOffset:
+            return true;
+    }
+    return false;
+}
+
 // Remove quotes, escaped quotes are unescaped.
 BOOL FormulaCompiler::DeQuote( String& rStr )
 {
@@ -939,44 +963,32 @@
     {
         if( nNumFmt == NUMBERFORMAT_UNDEFINED )
             nNumFmt = lcl_GetRetFormat( eOp );
-        // Functions that have to be always recalculated
-        switch( eOp )
+
+        if ( IsOpCodeVolatile(eOp) )
+            pArr->SetRecalcModeAlways();
+        else
         {
-            // no parameters:
-            case ocRandom:
-            case ocGetActDate:
-            case ocGetActTime:
-            // one parameter:
-            case ocFormula:
-            case ocInfo:
-            // more than one parameters:
-                // ocIndirect/ocIndirectXL otherwise would have to do
-                // StopListening and StartListening on a reference for every
-                // interpreted value.
-            case ocIndirect:
-            case ocIndirectXL:
-                // ocOffset results in indirect references.
-            case ocOffset:
-                pArr->SetRecalcModeAlways();
-            break;
-                // Functions recalculated on every document load.
-                // Don't use SetRecalcModeOnLoad() which would override
-                // ModeAlways.
-            case ocConvert :
-                pArr->AddRecalcMode( RECALCMODE_ONLOAD );
-            break;
-                // If the referred cell is moved the value changes.
-            case ocColumn :
-            case ocRow :
-                // ocCell needs recalc on move for some possible type values.
-            case ocCell :
-                pArr->SetRecalcModeOnRefMove();
-            break;
-            case ocHyperLink :
-                pArr->SetHyperLink(TRUE);
-            break;
-            default:
-                ;   // nothing
+            switch( eOp )
+            {
+                    // Functions recalculated on every document load.
+                    // Don't use SetRecalcModeOnLoad() which would override
+                    // ModeAlways.
+                case ocConvert :
+                    pArr->AddRecalcMode( RECALCMODE_ONLOAD );
+                break;
+                    // If the referred cell is moved the value changes.
+                case ocColumn :
+                case ocRow :
+                    // ocCell needs recalc on move for some possible type values.
+                case ocCell :
+                    pArr->SetRecalcModeOnRefMove();
+                break;
+                case ocHyperLink :
+                    pArr->SetHyperLink(TRUE);
+                break;
+                default:
+                    ;   // nothing
+            }
         }
         if (SC_OPCODE_START_NO_PAR <= eOp && eOp < SC_OPCODE_STOP_NO_PAR)
         {
Index: formula/inc/formula/FormulaCompiler.hxx
===================================================================
--- formula/inc/formula/FormulaCompiler.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ formula/inc/formula/FormulaCompiler.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -222,6 +222,8 @@
     void            SetCompileForFAP( BOOL bVal )
                         { bCompileForFAP = bVal; bIgnoreErrors = bVal; }
 
+    static bool IsOpCodeVolatile( OpCode eOp );
+
     static BOOL DeQuote( String& rStr );
 
     static const String&    GetNativeSymbol( OpCode eOp );
Index: solenv/inc/libs.mk
===================================================================
--- solenv/inc/libs.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ solenv/inc/libs.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -188,6 +188,7 @@
 MAILLIB=-lmail
 DOCMGRLIB=-ldmg$(DLLPOSTFIX)
 BASICLIB=-lsb$(DLLPOSTFIX)
+VBAHELPERLIB=-lvbahelper$(DLLPOSTFIX)
 DBTOOLSLIB=-ldbtools$(DLLPOSTFIX)
 HM2LIBSH=-lhmwrpdll
 HM2LIBST=-lhmwrap
@@ -420,6 +421,7 @@
 MAILLIB=mail.lib
 DOCMGRLIB=docmgr.lib
 BASICLIB=basic.lib
+VBAHELPERLIB=vbahelper.lib
 TKTLIB=tkt.lib
 SJLIB=sj.lib
 SVXCORELIB=isvxcore.lib
Index: framework/source/uielement/menubarmanager.cxx
===================================================================
--- framework/source/uielement/menubarmanager.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/uielement/menubarmanager.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -74,6 +74,7 @@
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
 #include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
 #include <com/sun/star/frame/status/Visibility.hpp>
 
 //_________________________________________________________________________________________________________________
@@ -136,6 +137,7 @@
 static const char ITEM_DESCRIPTOR_TYPE[]              = "Type";
 static const char ITEM_DESCRIPTOR_MODULEIDENTIFIER[]  = "ModuleIdentifier";
 static const char ITEM_DESCRIPTOR_DISPATCHPROVIDER[]  = "DispatchProvider";
+static const char   ITEM_DESCRIPTOR_STYLE[]         = "Style";
 
 const sal_Int32   LEN_DESCRIPTOR_COMMANDURL           = 10;
 const sal_Int32   LEN_DESCRIPTOR_HELPURL              = 7;
@@ -144,6 +146,7 @@
 const sal_Int32   LEN_DESCRIPTOR_TYPE                 = 4;
 const sal_Int32   LEN_DESCRIPTOR_MODULEIDENTIFIER     = 16;
 const sal_Int32   LEN_DESCRIPTOR_DISPATCHPROVIDER     = 16;
+static const sal_Int32 ITEM_DESCRIPTOR_STYLE_LEN       = 5;
 
 const sal_uInt16 ADDONMENU_MERGE_ITEMID_START = 1500;
 
@@ -1327,6 +1330,11 @@
         Reference< XDispatch > xDispatch;
 		Reference< XStatusListener > xStatusListener;
 		PopupMenu* pPopup = pMenu->GetPopupMenu( nItemId );
+        bool bItemShowMenuImages = m_bShowMenuImages;
+        MenuItemBits nBits =  pMenu->GetItemBits( nItemId );
+        // overwrite the show icons on menu option?
+        if ( nBits )
+            bItemShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
 		if ( pPopup )
 		{
             // Retrieve module identifier from Help Command entry
@@ -1422,7 +1430,7 @@
                         pSubMenuManager->m_aMenuItemCommand = ::rtl::OUString();
 
 			            // Set image for the addon popup menu item
-			            if ( m_bShowMenuImages && !pPopup->GetItemImage( ITEMID_ADDONLIST ))
+			            if ( bItemShowMenuImages && !pPopup->GetItemImage( ITEMID_ADDONLIST ))
 			            {
                             Reference< XFrame > xTemp( rFrame );
                             Image aImage = GetImageFromURL( xTemp, aItemCommand, FALSE, m_bWasHiContrast );
@@ -1441,7 +1449,7 @@
 		}
         else if ( pMenu->GetItemType( i ) != MENUITEM_SEPARATOR )
 		{
-			if ( m_bShowMenuImages )
+            if ( bItemShowMenuImages )
 			{
 			    if ( AddonMenuManager::IsAddonMenuId( nItemId ))
 			    {
@@ -1752,7 +1760,7 @@
         sal_uInt16                      nType = 0;
         Reference< XIndexAccess >       xIndexContainer;
         Reference< XDispatchProvider >  xDispatchProvider( rDispatchProvider );
-
+        sal_Int16 nStyle = 0;
         try
         {
             if ( rItemContainer->getByIndex( n ) >>= aProp )
@@ -1781,6 +1789,8 @@
                     else if ( aPropName.equalsAsciiL( ITEM_DESCRIPTOR_DISPATCHPROVIDER,
                                                       LEN_DESCRIPTOR_DISPATCHPROVIDER ))
                         aProp[i].Value >>= xDispatchProvider;
+                   else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_STYLE, ITEM_DESCRIPTOR_STYLE_LEN ))
+                        aProp[i].Value >>= nStyle;
                 }
 
                 if ( nType == ::com::sun::star::ui::ItemType::DEFAULT )
@@ -1791,7 +1801,15 @@
                     sal_Int32 nHelpId = aHelpURL.toInt32();
                     if ( nHelpId > 0 )
                         pMenu->SetHelpId( nId, (USHORT)nHelpId );
-
+                    if ( nStyle )
+                    {
+                        MenuItemBits nBits = pMenu->GetItemBits( nId );
+                        if ( nStyle & ::com::sun::star::ui::ItemStyle::ICON )
+                           nBits |= MIB_ICON;
+                        if ( nStyle & ::com::sun::star::ui::ItemStyle::TEXT )
+                           nBits |= MIB_TEXT;
+                        pMenu->SetItemBits( nId, nBits );
+                    } 
                     if ( xIndexContainer.is() )
                     {
                         PopupMenu* pNewPopupMenu = new PopupMenu;
Index: framework/source/uielement/toolbarmanager.cxx
===================================================================
--- framework/source/uielement/toolbarmanager.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/uielement/toolbarmanager.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -71,7 +71,6 @@
 #include <com/sun/star/lang/XMultiComponentFactory.hpp>
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/ui/XUIElementSettings.hpp>
-#include <com/sun/star/container/XIndexContainer.hpp>
 #include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
 #include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
 #include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
@@ -122,6 +121,7 @@
 
 static const char   ITEM_DESCRIPTOR_COMMANDURL[]    = "CommandURL";
 static const char   ITEM_DESCRIPTOR_HELPURL[]       = "HelpURL";
+static const char   ITEM_DESCRIPTOR_TOOLTIP[]       = "Tooltip";
 static const char   ITEM_DESCRIPTOR_CONTAINER[]     = "ItemDescriptorContainer";
 static const char   ITEM_DESCRIPTOR_LABEL[]         = "Label";
 static const char   ITEM_DESCRIPTOR_TYPE[]          = "Type";
@@ -131,6 +131,7 @@
 
 static const sal_Int32 ITEM_DESCRIPTOR_COMMANDURL_LEN  = 10;
 static const sal_Int32 ITEM_DESCRIPTOR_HELPURL_LEN     = 7;
+static const sal_Int32 ITEM_DESCRIPTOR_TOOLTIP_LEN     = 7;
 static const sal_Int32 ITEM_DESCRIPTOR_CONTAINER_LEN   = 23;
 static const sal_Int32 ITEM_DESCRIPTOR_LABEL_LEN       = 5;
 static const sal_Int32 ITEM_DESCRIPTOR_TYPE_LEN        = 4;
@@ -143,6 +144,7 @@
 //static sal_Int32    HELPID_PREFIX_LENGTH            = 7;
 static const USHORT STARTID_CUSTOMIZE_POPUPMENU     = 1000;
 
+#define MENUPREFIX "private:resource/menubar/"
 
 class ImageOrientationListener : public svt::FrameStatusListener
 {
@@ -966,8 +968,13 @@
                 }
                 else
                 {
-                    xController = Reference< XStatusListener >(
-                        new GenericToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL ));
+                    MenuDescriptionMap::iterator it = m_aMenuMap.find( nId );
+                    if ( it == m_aMenuMap.end() )
+                        xController = Reference< XStatusListener >(
+                            new GenericToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL ));
+                    else
+                        xController = Reference< XStatusListener >(
+                            new MenuToolbarController( m_xServiceManager, m_xFrame, m_pToolBar, nId, aCommandURL, m_aModuleIdentifier, m_aMenuMap[ nId ] ));
                 }
             }
             else if ( pController )
@@ -1099,6 +1106,10 @@
         nItemBits |= TIB_REPEAT;
     if ( nStyle & ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY )
         nItemBits |= TIB_DROPDOWNONLY;
+    if ( nStyle & ::com::sun::star::ui::ItemStyle::TEXT )
+        nItemBits |= TIB_TEXT_ONLY;
+    if ( nStyle & ::com::sun::star::ui::ItemStyle::ICON )
+        nItemBits |= TIB_ICON_ONLY;
 
     return nItemBits;
 }
@@ -1128,8 +1139,8 @@
             Reference< XUIConfigurationManagerSupplier > xSupplier( xModel, UNO_QUERY );
             if ( xSupplier.is() )
             {
-                Reference< XUIConfigurationManager > xDocUICfgMgr( xSupplier->getUIConfigurationManager(), UNO_QUERY );
-                m_xDocImageManager = Reference< XImageManager >( xDocUICfgMgr->getImageManager(), UNO_QUERY );
+                m_xDocUICfgMgr.set( xSupplier->getUIConfigurationManager(), UNO_QUERY );
+                m_xDocImageManager = Reference< XImageManager >( m_xDocUICfgMgr->getImageManager(), UNO_QUERY );
                 m_xDocImageManager->addConfigurationListener(
                                         Reference< XUIConfigurationListener >(
                                             static_cast< OWeakObject* >( this ), UNO_QUERY ));
@@ -1151,8 +1162,8 @@
         Reference< XModuleUIConfigurationManagerSupplier > xModuleCfgMgrSupplier( m_xServiceManager->createInstance(
                                                                                     SERVICENAME_MODULEUICONFIGURATIONMANAGERSUPPLIER ),
                                                                                   UNO_QUERY );
-        Reference< XUIConfigurationManager > xUICfgMgr = xModuleCfgMgrSupplier->getUIConfigurationManager( m_aModuleIdentifier );
-        m_xModuleImageManager = Reference< XImageManager >( xUICfgMgr->getImageManager(), UNO_QUERY );
+        m_xUICfgMgr = xModuleCfgMgrSupplier->getUIConfigurationManager( m_aModuleIdentifier );
+        m_xModuleImageManager = Reference< XImageManager >( m_xUICfgMgr->getImageManager(), UNO_QUERY );
         m_xModuleImageManager->addConfigurationListener( Reference< XUIConfigurationListener >(
                                                             static_cast< OWeakObject* >( this ), UNO_QUERY ));
     }
@@ -1164,6 +1175,8 @@
     m_aControllerMap.clear();
     m_aCommandMap.clear();
 
+    m_aMenuMap.clear();
+
     CommandInfo aCmdInfo;
     for ( sal_Int32 n = 0; n < rItemContainer->getCount(); n++ )
     {
@@ -1171,11 +1184,13 @@
         rtl::OUString               aCommandURL;
         rtl::OUString               aLabel;
         rtl::OUString               aHelpURL;
+        rtl::OUString               aTooltip;
         sal_uInt16                  nType( ::com::sun::star::ui::ItemType::DEFAULT );
         sal_uInt16                  nWidth( 0 );
         sal_Bool                    bIsVisible( sal_True );
         sal_uInt32                  nStyle( 0 );
 
+        Reference< XIndexAccess >   aMenuDesc;
         try
         {
             if ( rItemContainer->getByIndex( n ) >>= aProp )
@@ -1183,9 +1198,44 @@
                 for ( int i = 0; i < aProp.getLength(); i++ )
                 {
                     if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_COMMANDURL, ITEM_DESCRIPTOR_COMMANDURL_LEN ))
+                    {
                         aProp[i].Value >>= aCommandURL;
+                        if ( aCommandURL.compareToAscii(MENUPREFIX, RTL_CONSTASCII_LENGTH(MENUPREFIX) ) == 0  )
+                        {
+                            try
+                            {
+                                Reference< XIndexAccess > xMenuContainer;
+                                if ( m_xDocUICfgMgr.is() )
+                                    xMenuContainer  = m_xDocUICfgMgr->getSettings( aCommandURL, sal_False );
+                                if ( !xMenuContainer.is() && m_xUICfgMgr.is() )
+                                    xMenuContainer = m_xUICfgMgr->getSettings( aCommandURL, sal_False );
+                                if ( xMenuContainer.is() && xMenuContainer->getCount() )
+                                {
+                                    Sequence< PropertyValue > aProps; 
+                                    // drop down menu info is currently
+                                    // the first ( and only ) menu
+                                    // in the menusettings container
+                                    xMenuContainer->getByIndex(0) >>= aProps;
+                                    for ( sal_Int32 index=0; index<aProps.getLength(); ++index )
+                                    {
+                                        if ( aProps[ index ].Name.equalsAsciiL( ITEM_DESCRIPTOR_CONTAINER, ITEM_DESCRIPTOR_CONTAINER_LEN ))
+ 
+                                        {
+                                            aProps[ index ].Value >>= aMenuDesc;
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                            catch( Exception& e )
+                            {
+                            }
+                        }
+                    }
                     else if (  aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_HELPURL, ITEM_DESCRIPTOR_HELPURL_LEN ))
                         aProp[i].Value >>= aHelpURL;
+                    else if (  aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_TOOLTIP, ITEM_DESCRIPTOR_TOOLTIP_LEN ))
+                        aProp[i].Value >>= aTooltip;
                     else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_LABEL, ITEM_DESCRIPTOR_LABEL_LEN ))
                         aProp[i].Value >>= aLabel;
                     else if ( aProp[i].Name.equalsAsciiL( ITEM_DESCRIPTOR_TYPE, ITEM_DESCRIPTOR_TYPE_LEN ))
@@ -1203,9 +1253,14 @@
                     ::rtl::OUString aString( RetrieveLabelFromCommand( aCommandURL ));
 
                     sal_uInt16 nItemBits = ConvertStyleToToolboxItemBits( nStyle );
+                    if ( aMenuDesc.is() )
+                        m_aMenuMap[ nId ] = aMenuDesc;
                     m_pToolBar->InsertItem( nId, aString, nItemBits );
                     m_pToolBar->SetItemCommand( nId, aCommandURL );
-                    m_pToolBar->SetQuickHelpText( nId, aString );
+                    if ( aTooltip.getLength() )
+                        m_pToolBar->SetQuickHelpText( nId, aTooltip );
+                    else
+                        m_pToolBar->SetQuickHelpText( nId, aString );
                     if ( aLabel.getLength() > 0 )
                         m_pToolBar->SetItemText( nId, aLabel );
                     else
Index: framework/source/uielement/generictoolbarcontroller.cxx
===================================================================
--- framework/source/uielement/generictoolbarcontroller.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/uielement/generictoolbarcontroller.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -68,6 +68,9 @@
 #include <classes/fwkresid.hxx>
 #include <dispatch/uieventloghelper.hxx>
 
+#include <xml/menuconfiguration.hxx>
+#include <uielement/menubarmanager.hxx>
+
 using namespace ::com::sun::star::awt;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
@@ -75,6 +78,7 @@
 using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::frame::status;
 using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::container;
 
 namespace framework
 {
@@ -326,5 +330,67 @@
    return 0;
 }
 
+MenuToolbarController::MenuToolbarController( const Reference< XMultiServiceFactory >& rServiceManager, const Reference< XFrame >& rFrame, ToolBox* pToolBar, USHORT   nID, const rtl::OUString& aCommand, const rtl::OUString& aModuleIdentifier, const Reference< XIndexAccess >& xMenuDesc ) : GenericToolbarController( rServiceManager, rFrame, pToolBar, nID, aCommand ), m_xMenuDesc( xMenuDesc ), pMenu( NULL ), m_aModuleIdentifier( aModuleIdentifier )
+{
+}
+
+MenuToolbarController::~MenuToolbarController()
+{
+    try
+    {
+        if ( m_xMenuManager.is() )
+            m_xMenuManager->dispose();
+    }
+    catch( Exception& ) {}
+    if ( pMenu )
+    {
+        delete pMenu;
+        pMenu = NULL;
+    }
+ 
+}
+
+class Toolbarmenu : public PopupMenu
+{
+    public:
+    Toolbarmenu();
+    ~Toolbarmenu();
+};
+
+Toolbarmenu::Toolbarmenu()
+{
+    OSL_TRACE("**** contstructing Toolbarmenu 0x%x", this );
+}
+
+Toolbarmenu::~Toolbarmenu()
+{
+    OSL_TRACE("**** destructing Toolbarmenu 0x%x", this );
+}
+
+void SAL_CALL MenuToolbarController::click() throw (RuntimeException)
+{
+    createPopupWindow();
+}
+
+Reference< XWindow > SAL_CALL 
+MenuToolbarController::createPopupWindow() throw (::com::sun::star::uno::RuntimeException)
+{
+    if ( !pMenu ) 
+    {
+        Reference< XDispatchProvider > xDispatch;
+        Reference< XURLTransformer > xURLTransformer( m_xServiceManager->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.util.URLTransformer" ))), UNO_QUERY );
+        pMenu = new Toolbarmenu();
+        m_xMenuManager.set( new MenuBarManager( m_xServiceManager, m_xFrame, xURLTransformer, xDispatch, m_aModuleIdentifier, pMenu, sal_True, sal_True ) );
+        if ( m_xMenuManager.is() )
+        {
+            MenuBarManager* pMgr = dynamic_cast< MenuBarManager* >( m_xMenuManager.get() );
+            pMgr->SetItemContainer( m_xMenuDesc );
+        }
+    }
+
+    ::Rectangle aRect( m_pToolbar->GetItemRect( m_nID ) );
+    pMenu->Execute( m_pToolbar, aRect, POPUPMENU_EXECUTE_DOWN );
+    return NULL; 
+}
 } // namespace
 
Index: framework/source/classes/menumanager.cxx
===================================================================
--- framework/source/classes/menumanager.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/classes/menumanager.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -171,7 +171,13 @@
 	for ( USHORT i = 0; i < nItemCount; i++ )
 	{
 		USHORT nItemId = FillItemCommand(aItemCommand,pMenu, i );
+        bool bShowMenuImages( m_bShowMenuImages );
+        MenuItemBits nBits =  pMenu->GetItemBits( nItemId );
+        // overwrite the default?
+        if ( nBits )
+            bShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
 
+
 		PopupMenu* pPopupMenu = pMenu->GetPopupMenu( nItemId );
 		if ( pPopupMenu )
 		{
@@ -217,7 +223,7 @@
 						    aQueryLabelItemIdVector.push_back( nItemId );
 #endif
 					    // Set image for the addon popup menu item
-					    if ( m_bShowMenuImages && !pPopupMenu->GetItemImage( ITEMID_ADDONLIST ))
+                        if ( bShowMenuImages && !pPopupMenu->GetItemImage( ITEMID_ADDONLIST ))
 					    {
 						    Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                 		    if ( !!aImage )
@@ -249,7 +255,7 @@
 					aQueryLabelItemIdVector.push_back( nItemId );
 #endif
 				
-				if ( m_bShowMenuImages && !pMenu->GetItemImage( nItemId ))
+                if ( bShowMenuImages && !pMenu->GetItemImage( nItemId ))
 				{
 					Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                 	if ( !!aImage )
@@ -274,7 +280,7 @@
 					aQueryLabelItemIdVector.push_back( nItemId );
 #endif
 				
-				if ( m_bShowMenuImages && !pMenu->GetItemImage( nItemId ))
+                if ( bShowMenuImages && !pMenu->GetItemImage( nItemId ))
 				{
 					Image aImage = GetImageFromURL( rFrame, aItemCommand, FALSE, m_bWasHiContrast );
                 	if ( !!aImage )
@@ -283,7 +289,7 @@
 			}
 			else if ( pMenu->GetItemType( i ) != MENUITEM_SEPARATOR )
 			{
-			    if ( m_bShowMenuImages )
+                if ( bShowMenuImages )
 			    {
 			        if ( AddonMenuManager::IsAddonMenuId( nItemId ))
 			        {
@@ -1131,7 +1137,13 @@
 		USHORT nId = _pMenu->GetItemId( nPos );
 		if ( _pMenu->GetItemType( nPos ) != MENUITEM_SEPARATOR )
 		{
-			if ( bShowMenuImages )
+            bool bTmpShowMenuImages( bShowMenuImages );
+            MenuItemBits nBits =  _pMenu->GetItemBits( nId );
+            // overwrite the default?
+            if ( nBits )
+                bTmpShowMenuImages = ( ( nBits & MIB_ICON ) == MIB_ICON );
+
+            if ( bTmpShowMenuImages )
 			{
 				sal_Bool		bImageSet = sal_False;
 				::rtl::OUString aImageId;
Index: framework/source/xml/toolboxdocumenthandler.cxx
===================================================================
--- framework/source/xml/toolboxdocumenthandler.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/xml/toolboxdocumenthandler.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -79,6 +79,7 @@
 // Property names of a menu/menu item ItemDescriptor
 static const char ITEM_DESCRIPTOR_COMMANDURL[]  = "CommandURL";
 static const char ITEM_DESCRIPTOR_HELPURL[]     = "HelpURL";
+static const char ITEM_DESCRIPTOR_TOOLTIP[]     = "Tooltip";
 static const char ITEM_DESCRIPTOR_LABEL[]       = "Label";
 static const char ITEM_DESCRIPTOR_TYPE[]        = "Type";
 static const char ITEM_DESCRIPTOR_STYLE[]       = "Style";
@@ -89,6 +90,8 @@
                                       ::rtl::OUString&                       rCommandURL,
                                       ::rtl::OUString&                       rLabel,
                                       ::rtl::OUString&                       rHelpURL,
+                                      ::rtl::OUString&                       rTooltip,
+                                      sal_Int16&                      rStyle,
                                       sal_Int16&                      rWidth,
                                       sal_Bool&                       rVisible,
                                       sal_Int16&                      rType )
@@ -102,6 +105,8 @@
         }
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_HELPURL ))
             rProp[i].Value >>= rHelpURL;
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_TOOLTIP ))
+            rProp[i].Value >>= rTooltip;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_LABEL ))
             rProp[i].Value >>= rLabel;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_TYPE ))
@@ -110,9 +115,30 @@
             rProp[i].Value >>= rVisible;
         else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_WIDTH ))
             rProp[i].Value >>= rWidth;
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_STYLE ))
+            rProp[i].Value >>= rStyle;
     }
 }
 
+struct ToolboxStyleItem
+{
+    sal_Int16 nBit;
+    const char* attrName;
+};
+
+ToolboxStyleItem Styles[ ] = {
+    { ::com::sun::star::ui::ItemStyle::RADIO_CHECK, ATTRIBUTE_ITEMSTYLE_RADIO },
+    { ::com::sun::star::ui::ItemStyle::ALIGN_LEFT, ATTRIBUTE_ITEMSTYLE_LEFT },
+    { ::com::sun::star::ui::ItemStyle::AUTO_SIZE, ATTRIBUTE_ITEMSTYLE_AUTO },
+    { ::com::sun::star::ui::ItemStyle::REPEAT, ATTRIBUTE_ITEMSTYLE_REPEAT },
+    { ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY, ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY },
+    { ::com::sun::star::ui::ItemStyle::DROP_DOWN, ATTRIBUTE_ITEMSTYLE_DROPDOWN },
+    { ::com::sun::star::ui::ItemStyle::ICON, ATTRIBUTE_ITEMSTYLE_IMAGE },
+    { ::com::sun::star::ui::ItemStyle::TEXT, ATTRIBUTE_ITEMSTYLE_TEXT },
+};
+
+sal_Int32 nStyleItemEntries = sizeof( Styles ) / sizeof( Styles[ 0 ] );
+
 struct ToolBarEntryProperty
 {
 	OReadToolBoxDocumentHandler::ToolBox_XML_Namespace	nNamespace;
@@ -135,7 +161,8 @@
 	{ OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_USER				},
 	{ OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_HELPID			},
 	{ OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_ITEMSTYLE			},
-    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,   ATTRIBUTE_UINAME            }
+    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,   ATTRIBUTE_UINAME            },
+    { OReadToolBoxDocumentHandler::TB_NS_TOOLBAR,	ATTRIBUTE_TOOLTIP			},
 };
 
 OReadToolBoxDocumentHandler::OReadToolBoxDocumentHandler( const Reference< XIndexContainer >& rItemContainer ) :
@@ -145,6 +172,7 @@
     m_aLabel( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_LABEL )),
     m_aStyle( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_STYLE )),
     m_aHelpURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_HELPURL )),
+    m_aTooltip( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_TOOLTIP )),
     m_aIsVisible( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_VISIBLE )),
     m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL ))
  {
@@ -179,6 +207,8 @@
 	m_nHashCode_Style_DropDown	    = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_DROPDOWN ).hashCode();
 	m_nHashCode_Style_Repeat	    = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_REPEAT ).hashCode();
     m_nHashCode_Style_DropDownOnly  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY ).hashCode();
+    m_nHashCode_Style_Text  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_TEXT ).hashCode();
+    m_nHashCode_Style_Image  = ::rtl::OUString::createFromAscii( ATTRIBUTE_ITEMSTYLE_IMAGE ).hashCode();
 
 	m_bToolBarStartFound			= sal_False;
 	m_bToolBarEndFound				= sal_False;
@@ -298,6 +328,7 @@
                 ::rtl::OUString        aLabel;
                 ::rtl::OUString        aCommandURL;
                 ::rtl::OUString        aHelpURL;
+                ::rtl::OUString        aTooltip;
                 ::rtl::OUString        aBitmapName;
                 sal_uInt16      nItemBits( 0 );
                 sal_uInt16      nWidth( 0 );
@@ -368,6 +399,13 @@
 								aHelpURL = xAttribs->getValueByIndex( n );
 							}
 							break;
+#ifdef IZ105626 
+                            case TB_ATTRIBUTE_TOOLTIP:
+                            {
+                                aTooltip = xAttribs->getValueByIndex( n );
+                            }
+                            break;
+#endif
 
 							case TB_ATTRIBUTE_STYLE:
 							{
@@ -393,6 +431,12 @@
                                             nItemBits |= ::com::sun::star::ui::ItemStyle::REPEAT;
                                         else if ( nHashCode == m_nHashCode_Style_DropDownOnly )
                                             nItemBits |= ::com::sun::star::ui::ItemStyle::DROPDOWN_ONLY;
+#ifdef IZ105626 
+                                        else if ( nHashCode == m_nHashCode_Style_Text )
+                                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                                        else if ( nHashCode == m_nHashCode_Style_Image )
+                                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+#endif
 									}
 								}
 								while ( nIndex >= 0 );
@@ -414,13 +458,20 @@
 
 		        if ( aCommandURL.getLength() > 0 )
 		        {
+#ifdef IZ105626
+                    Sequence< PropertyValue > aToolbarItemProp( 7 );
+#else
                     Sequence< PropertyValue > aToolbarItemProp( 6 );
+#endif
                     aToolbarItemProp[0].Name = m_aCommandURL;
                     aToolbarItemProp[1].Name = m_aHelpURL;
                     aToolbarItemProp[2].Name = m_aLabel;
                     aToolbarItemProp[3].Name = m_aType;
                     aToolbarItemProp[4].Name = m_aStyle;
                     aToolbarItemProp[5].Name = m_aIsVisible;
+#ifdef IZ105626 
+                    aToolbarItemProp[6].Name = m_aTooltip;
+#endif
 
                     aToolbarItemProp[0].Value <<= aCommandURL;
                     aToolbarItemProp[1].Value <<= aHelpURL;
@@ -428,6 +479,9 @@
                     aToolbarItemProp[3].Value = makeAny( ::com::sun::star::ui::ItemType::DEFAULT );
                     aToolbarItemProp[4].Value <<= nItemBits;
                     aToolbarItemProp[5].Value <<= bVisible;
+#ifdef IZ105626 
+                    aToolbarItemProp[6].Value <<= aTooltip;
+#endif
 
                     m_rItemContainer->insertByIndex( m_rItemContainer->getCount(), makeAny( aToolbarItemProp ) );
 		        }
@@ -718,13 +772,15 @@
             ::rtl::OUString    aCommandURL;
             ::rtl::OUString    aLabel;
             ::rtl::OUString    aHelpURL;
+            ::rtl::OUString    aTooltip;
             sal_Bool    bVisible( sal_True );
             sal_Int16   nType( ::com::sun::star::ui::ItemType::DEFAULT );
             sal_Int16   nWidth( 0 );
+            sal_Int16   nStyle( 0 );
 
-            ExtractToolbarParameters( aProps, aCommandURL, aLabel, aHelpURL, nWidth, bVisible, nType );
+            ExtractToolbarParameters( aProps, aCommandURL, aLabel, aHelpURL, aTooltip, nStyle, nWidth, bVisible, nType );
             if ( nType == ::com::sun::star::ui::ItemType::DEFAULT )
-                WriteToolBoxItem( aCommandURL, aLabel, aHelpURL, nWidth, bVisible );
+                WriteToolBoxItem( aCommandURL, aLabel, aHelpURL, aTooltip, nStyle, nWidth, bVisible );
             else if ( nType == ::com::sun::star::ui::ItemType::SEPARATOR_SPACE )
 				WriteToolBoxSpace();
             else if ( nType == ::com::sun::star::ui::ItemType::SEPARATOR_LINE )
@@ -748,6 +804,8 @@
     const ::rtl::OUString& rCommandURL,
     const ::rtl::OUString& rLabel,
     const ::rtl::OUString& rHelpURL,
+    const ::rtl::OUString& rTooltip,
+    sal_Int16       nStyle,
     sal_Int16       nWidth,
     sal_Bool        bVisible )
 throw ( SAXException, RuntimeException )
@@ -784,7 +842,34 @@
 							 m_aAttributeType,
 							 rHelpURL );
 	}
+#ifdef IZ105626
+    if ( rTooltip.getLength() > 0 )
+    {
+        pList->AddAttribute( m_aXMLToolbarNS + ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_TOOLTIP )),
+                             m_aAttributeType,
+                             rTooltip );
+    }
 
+    if ( nStyle > 0 )
+    {
+        rtl::OUString aValue;
+        ToolboxStyleItem* pStyle = Styles;
+
+        for ( sal_Int32 nIndex = 0; nIndex < nStyleItemEntries; ++nIndex, ++pStyle )
+        {
+            if ( nStyle & pStyle->nBit )
+            {
+                if ( aValue.getLength() )
+                    aValue = aValue.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(" ") ) );
+                aValue += rtl::OUString::createFromAscii( pStyle->attrName );
+            }
+        } 
+        pList->AddAttribute( m_aXMLToolbarNS + ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_ITEMSTYLE )),
+                             m_aAttributeType,
+                             aValue );
+    }
+#endif
+
     if ( nWidth > 0 )
     {
 		pList->AddAttribute( m_aXMLToolbarNS + ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_WIDTH )),
Index: framework/source/xml/menudocumenthandler.cxx
===================================================================
--- framework/source/xml/menudocumenthandler.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/source/xml/menudocumenthandler.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,6 +47,7 @@
 #include <com/sun/star/xml/sax/XExtendedDocumentHandler.hpp>
 #include <com/sun/star/lang/XSingleComponentFactory.hpp>
 #include <com/sun/star/ui/ItemType.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 
@@ -80,11 +81,13 @@
 #define ATTRIBUTE_LABEL			    "http://openoffice.org/2001/menu^label"
 #define ATTRIBUTE_HELPID		    "http://openoffice.org/2001/menu^helpid"
 #define ATTRIBUTE_LINEBREAK		    "http://openoffice.org/2001/menu^linebreak"
+#define ATTRIBUTE_STYLE		    "http://openoffice.org/2001/menu^style"
 
 #define ATTRIBUTE_NS_ID			    "menu:id"
 #define ATTRIBUTE_NS_LABEL		    "menu:label"
 #define ATTRIBUTE_NS_HELPID		    "menu:helpid"
 #define ATTRIBUTE_NS_LINEBREAK	    "menu:linebreak"
+#define ATTRIBUTE_NS_STYLE		    "menu:style"
 
 #define ATTRIBUTE_XMLNS_MENU	    "xmlns:menu"
 
@@ -92,12 +95,16 @@
 
 #define MENUBAR_DOCTYPE			    "<!DOCTYPE menu:menubar PUBLIC \"-//OpenOffice.org//DTD OfficeDocument 1.0//EN\" \"menubar.dtd\">"
 
+#define ATTRIBUTE_ITEMSTYLE_TEXT    "text"
+#define ATTRIBUTE_ITEMSTYLE_IMAGE    "image"
+
 // Property names of a menu/menu item ItemDescriptor
 static const char ITEM_DESCRIPTOR_COMMANDURL[]  = "CommandURL";
 static const char ITEM_DESCRIPTOR_HELPURL[]     = "HelpURL";
 static const char ITEM_DESCRIPTOR_CONTAINER[]   = "ItemDescriptorContainer";
 static const char ITEM_DESCRIPTOR_LABEL[]       = "Label";
 static const char ITEM_DESCRIPTOR_TYPE[]        = "Type";
+static const char ITEM_DESCRIPTOR_STYLE[]       = "Style";
 
 // special popup menus (filled during runtime) must be saved as an empty popup menu or menuitem!!!
 static const sal_Int32 CMD_PROTOCOL_SIZE        = 5;
@@ -121,12 +128,27 @@
 namespace framework
 {
 
+struct MenuStyleItem
+{
+    sal_Int16 nBit;
+    const char* attrName;
+};
+
+MenuStyleItem MenuItemStyles[ ] = {
+    { ::com::sun::star::ui::ItemStyle::ICON, ATTRIBUTE_ITEMSTYLE_IMAGE },
+    { ::com::sun::star::ui::ItemStyle::TEXT, ATTRIBUTE_ITEMSTYLE_TEXT },
+};
+
+
+sal_Int32 nMenuStyleItemEntries = sizeof( MenuItemStyles ) / sizeof( MenuItemStyles[ 0 ] );
+
 static void ExtractMenuParameters( const Sequence< PropertyValue > rProp,
                                    ::rtl::OUString&                       rCommandURL,
                                    ::rtl::OUString&                       rLabel,
                                    ::rtl::OUString&                       rHelpURL,
                                    Reference< XIndexAccess >&      rSubMenu,
-                                   sal_Int16&                      rType )
+                                   sal_Int16&                      rType,
+                                   sal_Int16&                      rStyle )
 {
     for ( sal_Int32 i = 0; i < rProp.getLength(); i++ )
     {
@@ -151,6 +173,12 @@
         {
             rProp[i].Value >>= rType;
         }
+#ifdef IZ105626
+        else if ( rProp[i].Name.equalsAscii( ITEM_DESCRIPTOR_STYLE ))
+        {
+            rProp[i].Value >>= rStyle;
+        }
+#endif
     }
 }
 
@@ -165,7 +193,8 @@
 	m_aLabel( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_LABEL )),
 	m_aContainer( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_CONTAINER )),
 	m_aHelpURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_HELPURL )),
-	m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL ))
+    m_aCommandURL( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_COMMANDURL )),
+    m_aStyle( RTL_CONSTASCII_USTRINGPARAM( ITEM_DESCRIPTOR_STYLE ))
 {
 }
 
@@ -207,20 +236,29 @@
 
 void ReadMenuDocumentHandlerBase::initPropertyCommon(
 	Sequence< PropertyValue > &rProps, const rtl::OUString &rCommandURL,
-	const rtl::OUString &rHelpId, const rtl::OUString &rLabel)
+    const rtl::OUString &rHelpId, const rtl::OUString &rLabel, sal_Int16 nItemStyleBits )
 {
 	rProps[0].Name = m_aCommandURL;
 	rProps[1].Name = m_aHelpURL;
 	rProps[2].Name = m_aContainer;
 	rProps[3].Name = m_aLabel;
+#ifdef IZ105626
+	rProps[4].Name = m_aStyle;
+	rProps[5].Name = m_aType;
+#else
 	rProps[4].Name = m_aType;
-
+#endif
 	// Common values
 	rProps[0].Value <<= rCommandURL.intern();
 	rProps[1].Value <<= rHelpId;
 	rProps[2].Value <<= Reference< XIndexContainer >();
 	rProps[3].Value <<= rLabel;
+#ifdef IZ105626
+	rProps[4].Value <<= nItemStyleBits;
+	rProps[5].Value <<= ::com::sun::star::ui::ItemType::DEFAULT;
+#else
 	rProps[4].Value <<= ::com::sun::star::ui::ItemType::DEFAULT;
+#endif
 }
 
 // -----------------------------------------------------------------------------
@@ -373,6 +411,7 @@
 		::rtl::OUString aHelpId;
 		::rtl::OUString aCommandId;
 		::rtl::OUString aLabel;
+        sal_Int16 nItemBits(0);
 
 		m_bMenuMode = sal_True;
 
@@ -399,12 +438,35 @@
 				    aLabel = aValue;
 			    else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
 				    aHelpId = aValue;
+#ifdef IZ105626
+                else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+                {
+                    ::rtl::OUString aTemp( aValue );
+                    sal_Int32 nIndex = 0;
+                    do
+                    {
+                        ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                        if ( aToken.getLength() > 0 )
+                        {
+                            if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                                nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                            if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                                nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                        }
+                    }
+                    while ( nIndex >= 0 );                    
+                }
+#endif
 		    }
 
 		    if ( aCommandId.getLength() > 0 )
 		    {
+#ifdef IZ105626 
+                Sequence< PropertyValue > aSubMenuProp( 6 );
+#else
                 Sequence< PropertyValue > aSubMenuProp( 5 );
-				initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel );
+#endif
+                initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel, nItemBits );
 				aSubMenuProp[2].Value <<= xSubItemContainer;
 
                 m_xMenuBarContainer->insertByIndex( m_xMenuBarContainer->getCount(), makeAny( aSubMenuProp ) );
@@ -589,6 +651,7 @@
 		::rtl::OUString aHelpId;
 		::rtl::OUString aCommandId;
 		::rtl::OUString aLabel;
+        sal_Int16 nItemBits(0);
 
 		m_bMenuMode = sal_True;
 
@@ -614,12 +677,36 @@
 				aLabel = aValue;
 			else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
 				aHelpId = aValue;
+#ifdef IZ105626
+            else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+            {
+                ::rtl::OUString aTemp( aValue );
+                sal_Int32 nIndex = 0;
+                do
+                {
+                    ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                    if ( aToken.getLength() > 0 )
+                    {
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                    }
+                }
+                while ( nIndex >= 0 );                    
+            }
+#endif
+
 		}
 
 		if ( aCommandId.getLength() > 0 )
 		{
+#ifdef IZ105626
+            Sequence< PropertyValue > aSubMenuProp( 6 );
+#else
             Sequence< PropertyValue > aSubMenuProp( 5 );
-			initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel );
+#endif 
+            initPropertyCommon( aSubMenuProp, aCommandId, aHelpId, aLabel, nItemBits );
 			aSubMenuProp[2].Value <<= xSubItemContainer;
 
             m_xMenuContainer->insertByIndex( m_xMenuContainer->getCount(), makeAny( aSubMenuProp ) );
@@ -639,7 +726,7 @@
 		::rtl::OUString aHelpId;
 		::rtl::OUString aCommandId;
 		::rtl::OUString aLabel;
-
+        sal_Int16 nItemBits(0);
 		// read attributes for menu item
 		for ( sal_Int16 i=0; i< xAttrList->getLength(); i++ )
 		{
@@ -651,12 +738,34 @@
 				aLabel = aValue;
 			else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_HELPID )))
 				aHelpId = aValue;
+            else if ( aName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_STYLE )))
+            {
+                ::rtl::OUString aTemp( aValue );
+                sal_Int32 nIndex = 0;
+                do
+                {
+                    ::rtl::OUString aToken = aTemp.getToken( 0, '+', nIndex );
+                    if ( aToken.getLength() > 0 )
+                    {
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_TEXT ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::TEXT;
+                        if ( aToken.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( ATTRIBUTE_ITEMSTYLE_IMAGE ) ) )
+                            nItemBits |= ::com::sun::star::ui::ItemStyle::ICON;
+                    }
+                }
+                while ( nIndex >= 0 );                    
+            }
+
 		}
 
 		if ( aCommandId.getLength() > 0 )
 		{
+#ifdef IZ105626
+            Sequence< PropertyValue > aMenuItem( 6 );
+#else
             Sequence< PropertyValue > aMenuItem( 5 );
-			initPropertyCommon( aMenuItem, aCommandId, aHelpId, aLabel );
+#endif 
+            initPropertyCommon( aMenuItem, aCommandId, aHelpId, aLabel, nItemBits );
 			aMenuItem[2].Value <<= Reference< XIndexContainer >();
 
             m_xMenuContainer->insertByIndex( m_xMenuContainer->getCount(), makeAny( aMenuItem ) );
@@ -809,15 +918,16 @@
             ::rtl::OUString    aLabel;
             ::rtl::OUString    aHelpURL;
             sal_Int16   nType( ::com::sun::star::ui::ItemType::DEFAULT );
+            sal_Int16   nItemBits( 0 );
             Reference< XIndexAccess > xSubMenu;
 
-            ExtractMenuParameters( aProps, aCommandURL, aLabel, aHelpURL, xSubMenu, nType );
+            ExtractMenuParameters( aProps, aCommandURL, aLabel, aHelpURL, xSubMenu, nType, nItemBits );
             if ( xSubMenu.is() )
 		    {
                 if ( aCommandURL.equalsAscii( ADDDIRECT_CMD ) ||
                     aCommandURL.equalsAscii( AUTOPILOTMENU_CMD ))
                 {
-                    WriteMenuItem( aCommandURL, aLabel, aHelpURL );
+                    WriteMenuItem( aCommandURL, aLabel, aHelpURL, nItemBits );
                     bSeparator = sal_False;
                 }
 			    else if (( aCommandURL.getLength() > 0 ) && !AddonPopupMenu::IsCommandURLPrefix ( aCommandURL ))
@@ -857,7 +967,7 @@
                     if ( aCommandURL.getLength() > 0 )
                     {
                         bSeparator = FALSE;
-                        WriteMenuItem( aCommandURL, aLabel, aHelpURL );
+                        WriteMenuItem( aCommandURL, aLabel, aHelpURL, nItemBits );
                     }
 			    }
 			    else if ( !bSeparator )
@@ -872,7 +982,7 @@
 }
 
 
-void OWriteMenuDocumentHandler::WriteMenuItem( const ::rtl::OUString& aCommandURL, const ::rtl::OUString& aLabel, const ::rtl::OUString& aHelpURL)
+void OWriteMenuDocumentHandler::WriteMenuItem( const ::rtl::OUString& aCommandURL, const ::rtl::OUString& aLabel, const ::rtl::OUString& aHelpURL, sal_Int16 nStyle )
 {
 	::comphelper::AttributeList* pList = new ::comphelper::AttributeList;
 	Reference< XAttributeList > xList( (XAttributeList *) pList , UNO_QUERY );
@@ -894,7 +1004,25 @@
 							    m_aAttributeType,
 							    aLabel );
     }
+    if (( nStyle > 0 ) && !( aCommandURL.copy( CMD_PROTOCOL_SIZE ).equalsAscii( CMD_PROTOCOL )))
+    {
+        rtl::OUString aValue;
+        MenuStyleItem* pStyle = MenuItemStyles;
 
+        for ( sal_Int32 nIndex = 0; nIndex < nMenuStyleItemEntries; ++nIndex, ++pStyle )
+        {
+            if ( nStyle & pStyle->nBit )
+            {
+                if ( aValue.getLength() )
+                    aValue = aValue.concat( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("+") ) );
+                aValue += rtl::OUString::createFromAscii( pStyle->attrName );
+            }
+        }
+        pList->AddAttribute( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ATTRIBUTE_NS_STYLE )),
+                                m_aAttributeType,
+                                aValue );
+    }
+
 	m_xWriteDocumentHandler->ignorableWhitespace( ::rtl::OUString() );
 	m_xWriteDocumentHandler->startElement( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ELEMENT_NS_MENUITEM )), xList );
 	m_xWriteDocumentHandler->ignorableWhitespace( ::rtl::OUString() );
Index: framework/inc/uielement/toolbarmanager.hxx
===================================================================
--- framework/inc/uielement/toolbarmanager.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/uielement/toolbarmanager.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -50,10 +50,12 @@
 #include <com/sun/star/lang/XComponent.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/frame/XUIControllerRegistration.hpp>
 #include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/XUIConfigurationManager.hpp>
 #include <com/sun/star/frame/XStatusListener.hpp>
 #include <com/sun/star/frame/XSubToolbarController.hpp>
 #include <com/sun/star/frame/XToolbarController.hpp>
@@ -200,6 +202,7 @@
         typedef ::std::vector< ::com::sun::star::uno::Reference< ::com::sun::star::frame::XSubToolbarController > > SubToolBarControllerVector;
         typedef BaseHash< SubToolBarControllerVector >                                                              SubToolBarToSubToolBarControllerMap;
 
+        typedef ::std::hash_map< sal_uInt16, ::com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess > > MenuDescriptionMap;
         sal_Bool                                                                               m_bDisposed : 1,
                                                                                                m_bIsHiContrast : 1,
                                                                                                m_bSmallSymbols : 1,
@@ -225,10 +228,14 @@
         ::com::sun::star::uno::Reference< ::com::sun::star::ui::XImageManager >                m_xModuleImageManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::ui::XImageManager >                m_xDocImageManager;
         ::com::sun::star::uno::Reference< ::com::sun::star::lang::XComponent >                 m_xImageOrientationListener;
+        ::com::sun::star::uno::Reference< ::com::sun::star::ui::XUIConfigurationManager >                m_xUICfgMgr;
+        ::com::sun::star::uno::Reference< ::com::sun::star::ui::XUIConfigurationManager >                m_xDocUICfgMgr;
+
         CommandToInfoMap                                                                       m_aCommandMap;
         SubToolBarToSubToolBarControllerMap                                                    m_aSubToolBarControllerMap;
         Timer				                                                                   m_aAsyncUpdateControllersTimer;
         sal_Int16                                                                              m_nSymbolsStyle;
+        MenuDescriptionMap m_aMenuMap;
 };
     
 }
Index: framework/inc/uielement/generictoolbarcontroller.hxx
===================================================================
--- framework/inc/uielement/generictoolbarcontroller.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/uielement/generictoolbarcontroller.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -37,7 +37,10 @@
 
 #include <svtools/toolboxcontroller.hxx>
 #include <vcl/toolbox.hxx>
+#include <memory>
 
+class PopupMenu;
+
 namespace framework
 {
 
@@ -64,7 +67,7 @@
 
          DECL_STATIC_LINK( GenericToolbarController, ExecuteHdl_Impl, ExecuteInfo* ); 
     
-    private:
+    protected:
         ToolBox*        m_pToolbar;
         sal_uInt16      m_nID;
         sal_Bool        m_bEnumCommand : 1,
@@ -72,6 +75,28 @@
         rtl::OUString   m_aEnumCommand;
 };
 
+class MenuToolbarController : public GenericToolbarController
+{
+    com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess > m_xMenuDesc;
+    PopupMenu* pMenu;
+    com::sun::star::uno::Reference< com::sun::star::lang::XComponent > m_xMenuManager;
+    rtl::OUString m_aModuleIdentifier;
+    public:
+        MenuToolbarController( const com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory >& rServiceManager, 
+                                  const com::sun::star::uno::Reference< com::sun::star::frame::XFrame >& rFrame,
+                                  ToolBox* pToolBar,
+                                  USHORT   nID,
+                                  const rtl::OUString& aCommand, 
+                                  const rtl::OUString& aModuleIdentifier, 
+                                  const com::sun::star::uno::Reference< com::sun::star::container::XIndexAccess >& xMenuDesc );
+
+    ~MenuToolbarController();
+    // XToolbarController
+    virtual void SAL_CALL click() throw ( ::com::sun::star::uno::RuntimeException );
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindow > SAL_CALL createPopupWindow() throw (::com::sun::star::uno::RuntimeException);
+
+};
+
 }
 
 #endif // __FRAMEWORK_UIELEMENT_GENERICTOOLBARCONTROLLER_HXX_
Index: framework/inc/xml/toolboxconfigurationdefines.hxx
===================================================================
--- framework/inc/xml/toolboxconfigurationdefines.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/xml/toolboxconfigurationdefines.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -29,6 +29,7 @@
 #define ATTRIBUTE_WIDTH				"width"
 #define ATTRIBUTE_USER				"userdefined"
 #define ATTRIBUTE_HELPID			"helpid"
+#define ATTRIBUTE_TOOLTIP			"tooltip"
 #define ATTRIBUTE_ITEMSTYLE			"style"
 
 #define ATTRIBUTE_ID				"id"
@@ -78,6 +79,8 @@
 #define ATTRIBUTE_ITEMSTYLE_AUTOSIZE	    "autosize"
 #define ATTRIBUTE_ITEMSTYLE_DROPDOWN	    "dropdown"
 #define ATTRIBUTE_ITEMSTYLE_REPEAT		    "repeat"
+#define ATTRIBUTE_ITEMSTYLE_TEXT    "text"
 #define ATTRIBUTE_ITEMSTYLE_DROPDOWNONLY    "dropdownonly"
+#define ATTRIBUTE_ITEMSTYLE_IMAGE    "image"
 
 #endif // __FRAMEWORK_XML_TOOLBOXCONFIGURATIONDEFINES_HXX_
Index: framework/inc/xml/toolboxdocumenthandler.hxx
===================================================================
--- framework/inc/xml/toolboxdocumenthandler.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/xml/toolboxdocumenthandler.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -77,6 +77,7 @@
 			TB_ATTRIBUTE_HELPID,
 			TB_ATTRIBUTE_STYLE,
             TB_ATTRIBUTE_UINAME,
+            TB_ATTRIBUTE_TOOLTIP,
 			TB_XML_ENTRY_COUNT
 		};
 
@@ -159,10 +160,13 @@
 		sal_Int32																	    m_nHashCode_Style_DropDown;
 		sal_Int32																	    m_nHashCode_Style_Repeat;
         sal_Int32                                                                       m_nHashCode_Style_DropDownOnly;
+        sal_Int32                                                                       m_nHashCode_Style_Text;
+        sal_Int32                                                                       m_nHashCode_Style_Image;
 		rtl::OUString                                                                   m_aType;
 		rtl::OUString                                                                   m_aLabel;
 		rtl::OUString                                                                   m_aStyle;
 		rtl::OUString                                                                   m_aHelpURL;
+        rtl::OUString                                                                   m_aTooltip;
 		rtl::OUString                                                                   m_aIsVisible;
 		rtl::OUString                                                                   m_aCommandURL;
 };
@@ -181,7 +185,7 @@
 			  ::com::sun::star::uno::RuntimeException );
 	
 	protected:
-        virtual void WriteToolBoxItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL,
+        virtual void WriteToolBoxItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL, const rtl::OUString& aTooltip, sal_Int16 nStyle,
                                        sal_Int16 nWidth, sal_Bool bVisible ) throw
 			( ::com::sun::star::xml::sax::SAXException,
 			  ::com::sun::star::uno::RuntimeException );
Index: framework/inc/xml/menuconfiguration.hxx
===================================================================
--- framework/inc/xml/menuconfiguration.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/xml/menuconfiguration.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -85,6 +85,7 @@
 			::rtl::OUString aTargetFrame;
 			::rtl::OUString	aImageId;
             ::com::sun::star::uno::WeakReference< ::com::sun::star::frame::XDispatchProvider > xDispatchProvider;
+                        sal_Int16 nStyle;
 		};
 						
 		MenuConfiguration(
Index: framework/inc/xml/menudocumenthandler.hxx
===================================================================
--- framework/inc/xml/menudocumenthandler.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ framework/inc/xml/menudocumenthandler.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -109,13 +109,14 @@
 		::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler> m_xReader;
 		void initPropertyCommon( com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue > &rProps,
 								 const rtl::OUString &rCommandURL, const rtl::OUString &rHelpId,
-								 const rtl::OUString &rLabel);
+                                 const rtl::OUString &rLabel, sal_Int16 nItemStyleBits );
 	private:
 		rtl::OUString m_aType;
 		rtl::OUString m_aLabel;
 		rtl::OUString m_aContainer;
 		rtl::OUString m_aHelpURL;
 		rtl::OUString m_aCommandURL;
+        rtl::OUString m_aStyle;
 		::com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue > m_aItemProp;
 };
 
@@ -306,7 +307,7 @@
 		virtual void WriteMenu( const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >& rSubMenuContainer ) throw
 			( ::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException );
 
-        virtual void WriteMenuItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL );
+        virtual void WriteMenuItem( const rtl::OUString& aCommandURL, const rtl::OUString& aLabel, const rtl::OUString& aHelpURL, sal_Int16 nStyle = 0 );
 		virtual void WriteMenuSeparator();
 
         com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess > m_xMenuBarContainer;
Index: comphelper/source/misc/makefile.mk
===================================================================
--- comphelper/source/misc/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ comphelper/source/misc/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -60,6 +60,7 @@
             $(SLO)$/docpasswordhelper.obj \
             $(SLO)$/docpasswordrequest.obj \
             $(SLO)$/documentinfo.obj \
+	    $(SLO)$/evtmethodhelper.obj \
             $(SLO)$/documentiologring.obj \
             $(SLO)$/evtlistenerhlp.obj \
             $(SLO)$/ihwrapnofilter.obj \
Index: comphelper/source/misc/evtmethodhelper.cxx
===================================================================
--- comphelper/source/misc/evtmethodhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ comphelper/source/misc/evtmethodhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.cxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_comphelper.hxx"
+#include "comphelper/evtmethodhelper.hxx"
+#include "cppuhelper/typeprovider.hxx"
+
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Type;
+
+namespace comphelper
+{
+
+	Sequence< ::rtl::OUString> getEventMethodsForType(const Type& type)
+	{
+		typelib_InterfaceTypeDescription *pType=0;
+		type.getDescription( (typelib_TypeDescription**)&pType);
+	
+		if(!pType)
+			return Sequence< ::rtl::OUString>();
+	    
+		Sequence< ::rtl::OUString> aNames(pType->nMembers);
+		::rtl::OUString* pNames = aNames.getArray();
+		for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
+		{
+			// the decription reference
+			typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
+			// the description for the reference
+			typelib_TypeDescription* pMemberDescription = NULL;
+			typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
+			if (pMemberDescription)
+			{
+				typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
+				reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
+				*pNames = pRealMemberDescription->pMemberName;
+			}
+		}
+		typelib_typedescription_release( (typelib_TypeDescription *)pType );
+		return aNames;
+	}
+
+}
+
+
+
+
+
+
+
Index: comphelper/inc/comphelper/servicedecl.hxx
===================================================================
--- comphelper/inc/comphelper/servicedecl.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ comphelper/inc/comphelper/servicedecl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -169,21 +169,20 @@
 
 /// @internal
 namespace detail {
-
 template <typename ImplT>
-class ServiceImpl
-    : public ::cppu::ImplInheritanceHelper1<ImplT, css::lang::XServiceInfo>,
+class OwnServiceImpl
+    : public ImplT,
       private ::boost::noncopyable
 {
-    typedef ::cppu::ImplInheritanceHelper1<ImplT,css::lang::XServiceInfo> BaseT;
+    typedef ImplT BaseT;
     
 public:    
-    ServiceImpl(
+    OwnServiceImpl(
         ServiceDecl const& rServiceDecl,
         css::uno::Sequence<css::uno::Any> const& args,
         css::uno::Reference<css::uno::XComponentContext> const& xContext )
-        : BaseT(args, xContext), m_rServiceDecl(rServiceDecl) {}
-    ServiceImpl(
+        :BaseT(args, xContext), m_rServiceDecl(rServiceDecl) {}
+    OwnServiceImpl(
         ServiceDecl const& rServiceDecl,
         css::uno::Reference<css::uno::XComponentContext> const& xContext )
         : BaseT(xContext), m_rServiceDecl(rServiceDecl) {}
@@ -206,6 +205,22 @@
     ServiceDecl const& m_rServiceDecl;
 };
 
+template <typename ImplT>
+class ServiceImpl : public OwnServiceImpl< ::cppu::ImplInheritanceHelper1<ImplT,css::lang::XServiceInfo> >
+{
+typedef OwnServiceImpl< ::cppu::ImplInheritanceHelper1<ImplT,css::lang::XServiceInfo> > ServiceImpl_BASE;
+public:
+    ServiceImpl(
+        ServiceDecl const& rServiceDecl,
+        css::uno::Sequence<css::uno::Any> const& args,
+        css::uno::Reference<css::uno::XComponentContext> const& xContext )
+        : ServiceImpl_BASE(rServiceDecl, args, xContext) {}
+    ServiceImpl(
+        ServiceDecl const& rServiceDecl,
+        css::uno::Reference<css::uno::XComponentContext> const& xContext )
+        : ServiceImpl_BASE(rServiceDecl, xContext) {}
+};
+
 template <typename ServiceImplT>
 struct PostProcessDefault {
     css::uno::Reference<css::uno::XInterface>
@@ -230,7 +245,7 @@
                 const& xContext ) const
     {
         return m_postProcessFunc(
-            new ServiceImpl<ImplT>( rServiceDecl, xContext ) );
+            new ImplT( rServiceDecl, xContext ) );
     }
 };
 
@@ -247,7 +262,7 @@
                 const& xContext ) const
     {
         return m_postProcessFunc(
-            new ServiceImpl<ImplT>( rServiceDecl, args, xContext ) );
+            new ImplT( rServiceDecl, args, xContext ) );
     }
 };
 
@@ -261,18 +276,17 @@
                or just (uno::Reference<uno::XComponentContext>)
 */
 template <typename ImplT_, typename WithArgsT = with_args<false> >
-struct class_ {
+struct serviceimpl_base {
     typedef ImplT_ ImplT;
-    typedef detail::ServiceImpl<ImplT_> ServiceImplT;
     
     detail::CreateFuncF const m_createFunc;
     
-    typedef detail::PostProcessDefault<ServiceImplT> PostProcessDefaultT;
+    typedef detail::PostProcessDefault<ImplT> PostProcessDefaultT;
 
     /** Default ctor.  Implementation class without args, expecting
         component context as single argument.
     */
-    class_() : m_createFunc(
+    serviceimpl_base() : m_createFunc(
         detail::CreateFunc<ImplT, PostProcessDefaultT, WithArgsT>(
             PostProcessDefaultT() ) ) {}
 
@@ -284,11 +298,29 @@
                                uno::Reference<uno::XInterface>
     */
     template <typename PostProcessFuncT>
-    explicit class_( PostProcessFuncT const& postProcessFunc )
+    explicit serviceimpl_base( PostProcessFuncT const& postProcessFunc )
         : m_createFunc( detail::CreateFunc<ImplT, PostProcessFuncT, WithArgsT>(
                             postProcessFunc ) ) {}
 };
 
+template <typename ImplT_, typename WithArgsT = with_args<false> >
+struct class_ : public serviceimpl_base< detail::ServiceImpl<ImplT_>, WithArgsT >
+{
+    typedef serviceimpl_base< detail::ServiceImpl<ImplT_>, WithArgsT > baseT;
+    /** Default ctor.  Implementation class without args, expecting
+        component context as single argument.
+    */
+    class_() : baseT() {}
+    template <typename PostProcessFuncT>
+    /** Ctor to pass a post processing function/functor.
+        
+        @tpl PostProcessDefaultT let your compiler deduce this
+        @param postProcessFunc function/functor that gets the yet unacquired
+                               ImplT_ pointer returning a
+                               uno::Reference<uno::XInterface>
+    */
+    explicit class_( PostProcessFuncT const& postProcessFunc ) : baseT( postProcessFunc ) {}
+};
 
 //
 // component_... helpers with arbitrary service declarations:
Index: comphelper/inc/comphelper/evtmethodhelper.hxx
===================================================================
--- comphelper/inc/comphelper/evtmethodhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ comphelper/inc/comphelper/evtmethodhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,41 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: evtlistenerhlp.hxx,v $
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef COMPHELPER_EVENTMEHODHELPER_HXX
+#define COMPHELPER_EVENMETHODHELPER_HXX
+#include <comphelper/sequence.hxx>
+//........................................................................
+namespace comphelper
+{
+	COMPHELPER_DLLPUBLIC ::com::sun::star::uno::Sequence< ::rtl::OUString> getEventMethodsForType(const ::com::sun::star::uno::Type& type);
+//........................................................................
+
+}	// namespace comphelper
+//........................................................................
+#endif // COMPHELPER_EVENTMEHODHELPER_HXX
Index: basctl/source/dlged/dlged.cxx
===================================================================
--- basctl/source/dlged/dlged.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/dlged/dlged.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -208,7 +208,7 @@
 
 //----------------------------------------------------------------------------
 
-DlgEditor::DlgEditor()
+DlgEditor::DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel )
 	:pHScroll(NULL)
 	,pVScroll(NULL)
 	,pDlgEdModel(NULL)
@@ -230,6 +230,7 @@
 	,bCreateOK(TRUE)
 	,bDialogModelChanged(FALSE)
 	,mnPaintGuard(0)
+	,m_xDocument( xModel )
 {
 	pDlgEdModel = new DlgEdModel();
 	pDlgEdModel->GetItemPool().FreezeIdRanges();
@@ -838,7 +839,7 @@
     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+	Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
 	Reference< XInputStream > xStream( xISP->createInputStream() );
 	Sequence< sal_Int8 > DialogModelBytes;
 	implCopyStreamToByteSequence( xStream, DialogModelBytes );
@@ -871,7 +872,7 @@
 			uno::Reference< resource::XStringResourceManager >
 				xStringResourceManager( xStringResourcePersistence, uno::UNO_QUERY );
 			LocalizationMgr::resetResourceForDialog( xClipDialogModel, xStringResourceManager );
-			Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext );
+			Reference< XInputStreamProvider > xISP2 = ::xmlscript::exportDialogModel( xClipDialogModel, xContext, m_xDocument );
 			Reference< XInputStream > xStream2( xISP2->createInputStream() );
 			Sequence< sal_Int8 > NoResourceDialogModelBytes;
 			implCopyStreamToByteSequence( xStream2, NoResourceDialogModelBytes );
@@ -1017,7 +1018,7 @@
                     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-					::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext );
+					::xmlscript::importDialogModel( ::xmlscript::createInputStream( *((::rtl::ByteSequence*)(&DialogModelBytes)) ) , xClipDialogModel, xContext, m_xDocument );
 				}
 
 				// get control models from clipboard dialog model
Index: basctl/source/dlged/dlgedobj.cxx
===================================================================
--- basctl/source/dlged/dlgedobj.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/dlged/dlgedobj.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -77,6 +77,22 @@
 DBG_NAME(DlgEdObj);
 
 //----------------------------------------------------------------------------
+MapMode lcl_getMapModeForForm( DlgEdForm* pForm )
+{
+	MapMode aMode( MAP_APPFONT ); //Default
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps( pForm ? pForm->GetUnoControlModel() : NULL, uno::UNO_QUERY_THROW );
+		sal_Bool bVBAForm = sal_False;
+		xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBAForm;	
+		if ( bVBAForm )
+			aMode = MapMode( MAP_100TH_MM );
+	}
+	catch ( Exception& )
+	{
+	}
+	return aMode;
+}
 
 DlgEdObj::DlgEdObj()
 		  :SdrUnoObj(String(), sal_False)
@@ -197,8 +213,9 @@
 	}
     
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -245,10 +262,10 @@
 		aSize.Width() -= aDeviceInfo.LeftInset + aDeviceInfo.RightInset;
 		aSize.Height() -= aDeviceInfo.TopInset + aDeviceInfo.BottomInset;
 	}
-
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
     // convert pixel to logic units
-    aPos = pDevice->PixelToLogic( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->PixelToLogic( aSize, MapMode( MAP_APPFONT ) );
+    aPos = pDevice->PixelToLogic( aPos, aConvMode );
+    aSize = pDevice->PixelToLogic( aSize, aConvMode );
 
     // set out parameters
     nXOut = aPos.Width();
@@ -290,9 +307,10 @@
     DBG_ASSERT( pDevice, "DlgEdObj::TransformControlToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
-    aFormPos = pDevice->LogicToPixel( aFormPos, MapMode( MAP_APPFONT ) );
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+    aFormPos = pDevice->LogicToPixel( aFormPos, aConvMode );
 
     // add form position
     aPos.Width() += aFormPos.Width();
@@ -336,14 +354,16 @@
     DBG_ASSERT( pDevice, "DlgEdObj::TransformFormToSdrCoordinates: missing default device!" );
     if ( !pDevice )
         return false;
-    aPos = pDevice->LogicToPixel( aPos, MapMode( MAP_APPFONT ) );
-    aSize = pDevice->LogicToPixel( aSize, MapMode( MAP_APPFONT ) );
 
     // take window borders into account
     DlgEdForm* pForm = NULL;
     if ( !lcl_getDlgEdForm( this, pForm ) )
         return false;
 
+    MapMode aConvMode = lcl_getMapModeForForm( pForm );
+    aPos = pDevice->LogicToPixel( aPos, aConvMode );
+    aSize = pDevice->LogicToPixel( aSize, aConvMode );
+
     // take window borders into account
     Reference< beans::XPropertySet > xPSetForm( pForm->GetUnoControlModel(), UNO_QUERY );
     DBG_ASSERT( xPSetForm.is(), "DlgEdObj::TransformFormToSdrCoordinates: no form property set!" );
Index: basctl/source/basicide/basidesh.cxx
===================================================================
--- basctl/source/basicide/basidesh.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/basidesh.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -80,6 +80,9 @@
 #include <com/sun/star/script/XLibraryContainer.hpp>
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
 #include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/container/XContainerListener.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 
 #include <svx/xmlsecctrl.hxx>
 
@@ -87,7 +90,72 @@
 using namespace ::com::sun::star;
 using ::rtl::OUString;
 
+static const rtl::OUString sStandardLibName(  rtl::OUString::createFromAscii("Standard") );
 
+typedef ::cppu::WeakImplHelper1< container::XContainerListener > ContainerListenerBASE;
+
+class ContainerListenerImpl : public ContainerListenerBASE
+{
+    BasicIDEShell* mpShell;
+public:
+
+    ContainerListenerImpl( BasicIDEShell* pShell ) : mpShell( pShell ) {}
+
+    ~ContainerListenerImpl() 
+    {
+    }
+
+    void addContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument() && xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+                xContainer->addContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+    void removeContainerListener( const ScriptDocument& rScriptDocument )
+    {
+        uno::Reference< container::XContainer > xContainer( rScriptDocument.getLibrary( E_SCRIPTS, sStandardLibName, FALSE ), uno::UNO_QUERY );
+        if ( rScriptDocument.isDocument(), xContainer.is() )
+        {
+            uno::Reference< container::XContainerListener > xContainerListener( this );
+            try
+            {
+               xContainer->removeContainerListener( xContainerListener );
+            }
+            catch( uno::Exception& ) {}
+        }
+    }
+
+    // XEventListener
+    virtual void SAL_CALL disposing( const lang::EventObject& ) throw( uno::RuntimeException ) {}
+
+    // XContainerListener
+    virtual void SAL_CALL elementInserted( const container::ContainerEvent& Event ) throw( uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell && ( Event.Accessor >>= sModuleName ) )
+            mpShell->FindBasWin( mpShell->m_aCurDocument, sStandardLibName, sModuleName, TRUE, FALSE );
+    }
+    virtual void SAL_CALL elementReplaced( const container::ContainerEvent& ) throw( com::sun::star::uno::RuntimeException ) { }
+    virtual void SAL_CALL elementRemoved( const container::ContainerEvent& Event ) throw( com::sun::star::uno::RuntimeException )
+    {
+        rtl::OUString sModuleName;
+        if( mpShell  && ( Event.Accessor >>= sModuleName ) )
+        {
+            IDEBaseWindow* pWin = mpShell->FindWindow( mpShell->m_aCurDocument, sStandardLibName, sModuleName, BASICIDE_TYPE_MODULE, TRUE );
+            if( pWin )
+                mpShell->RemoveWindow( pWin, FALSE, TRUE );
+        }
+    }
+
+};
+
 TYPEINIT1( BasicIDEShell, SfxViewShell );
 
 SFX_IMPL_VIEWFACTORY( BasicIDEShell, IDEResId( SVX_INTERFACE_BASIDE_VIEWSH ) )
@@ -124,6 +192,7 @@
         m_bAppBasicModified( FALSE ),
         m_aNotifier( *this )
 {
+    m_xLibListener = new ContainerListenerImpl( this );
 	Init();
     GnBasicIDEShellCount++;
 }
@@ -215,6 +284,12 @@
 	delete pTabBar;
 	delete pObjectCatalog;
 	DestroyModulWindowLayout();
+
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        // Destroy all ContainerListeners for Basic Container.
+        if ( pListener )
+            pListener->removeContainerListener( m_aCurDocument );
+    
 	// MI: Das gab einen GPF im SDT beim Schliessen da dann der ViewFrame die
 	// ObjSh loslaesst. Es wusste auch keiner mehr wozu das gut war.
 	// GetViewFrame()->GetObjectShell()->Broadcast( SfxSimpleHint( SFX_HINT_DYING ) );
@@ -921,7 +996,15 @@
 {
     if ( !bCheck || ( rDocument != m_aCurDocument || aLibName != m_aCurLibName ) )
     {
+        ContainerListenerImpl* pListener = dynamic_cast< ContainerListenerImpl* >( m_xLibListener.get() );
+        if ( pListener )
+        	pListener->removeContainerListener( m_aCurDocument );
+
         m_aCurDocument = rDocument;
+
+        if ( pListener )
+            pListener->addContainerListener( m_aCurDocument );
+
         m_aCurLibName = aLibName;
         if ( bUpdateWindows )
             UpdateWindows();
Index: basctl/source/basicide/bastype2.cxx
===================================================================
--- basctl/source/basicide/bastype2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/bastype2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -53,11 +53,26 @@
 #include <com/sun/star/frame/XModuleManager.hpp>
 #include <comphelper/processfactory.hxx>
 #include <comphelper/componentcontext.hxx>
+#include <map>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName );
 
+sal_Int32 lcl_getModuleType(  const uno::Reference< container::XNameContainer >& rLib, const String& rModName )
+{
+    sal_Int32 nType = com::sun::star::script::ModuleType::Normal;
+    uno::Any aElement( rLib->getByName( rModName ) );
+    script::ModuleInfo aModuleInfo;
+    if( aElement >>= aModuleInfo )
+        nType = aModuleInfo.ModuleType;
+    return nType;    
+}
+
 BasicEntry::~BasicEntry()
 {
 }
@@ -91,20 +106,22 @@
 {
 }
 
-BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, BasicEntryType eType )
+BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, BasicEntryType eType )
     :m_aDocument( rDocument )
     ,m_eLocation( eLocation )
     ,m_aLibName( rLibName )
+    ,m_aLibSubName( rLibSubName )
     ,m_aName( rName )
     ,m_eType( eType )
 {
     OSL_ENSURE( m_aDocument.isValid(), "BasicEntryDescriptor::BasicEntryDescriptor: invalid document!" );
 }
 
-BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, const String& rMethodName, BasicEntryType eType )
+BasicEntryDescriptor::BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, const String& rMethodName, BasicEntryType eType )
     :m_aDocument( rDocument )
     ,m_eLocation( eLocation )
     ,m_aLibName( rLibName )
+    ,m_aLibSubName( rLibSubName )
     ,m_aName( rName )
     ,m_aMethodName( rMethodName )
     ,m_eType( eType )
@@ -120,6 +137,7 @@
     :m_aDocument( rDesc.m_aDocument )
     ,m_eLocation( rDesc.m_eLocation )
     ,m_aLibName( rDesc.m_aLibName )
+    ,m_aLibSubName( rDesc.m_aLibSubName )
     ,m_aName( rDesc.m_aName )
     ,m_aMethodName( rDesc.m_aMethodName )
     ,m_eType( rDesc.m_eType )
@@ -131,6 +149,7 @@
     m_aDocument = rDesc.m_aDocument;
     m_eLocation = rDesc.m_eLocation;
     m_aLibName = rDesc.m_aLibName;
+    m_aLibSubName = rDesc.m_aLibSubName;
     m_aName = rDesc.m_aName;
     m_aMethodName = rDesc.m_aMethodName;
     m_eType = rDesc.m_eType;
@@ -143,6 +162,7 @@
     return m_aDocument == rDesc.m_aDocument &&
            m_eLocation == rDesc.m_eLocation &&
            m_aLibName == rDesc.m_aLibName &&
+           m_aLibSubName == rDesc.m_aLibSubName &&
            m_aName == rDesc.m_aName &&
            m_aMethodName == rDesc.m_aMethodName &&
            m_eType == rDesc.m_eType;
@@ -286,50 +306,58 @@
         if ( xModLibContainer.is() && xModLibContainer->hasByName( aOULibName ) && xModLibContainer->isLibraryLoaded( aOULibName ) )
         {
             try
-		    {
-                // get a sorted list of module names
-                Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
-                sal_Int32 nModCount = aModNames.getLength();
-	            const ::rtl::OUString* pModNames = aModNames.getConstArray();
+		 	{
+                BasicManager* pBasMgr = rDocument.getBasicManager();
+                StarBASIC* pBasic = pBasMgr ? pBasMgr->GetLib( rLibName ) : 0;
+                sal_Bool bVBAEnabled = pBasic ? pBasic->isVBAEnabled(): sal_False;
+                if( bVBAEnabled )
+                    ImpCreateLibSubEntriesInVBAMode( pLibRootEntry, rDocument, rLibName );
+                else
+                {
+                    // get a sorted list of module names
+                    Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
+                    sal_Int32 nModCount = aModNames.getLength();
+		            const ::rtl::OUString* pModNames = aModNames.getConstArray();
 
-                for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
-				{
-                    String aModName = pModNames[ i ];
-                    SvLBoxEntry* pModuleEntry = FindEntry( pLibRootEntry, aModName, OBJ_TYPE_MODULE );
-                    if ( !pModuleEntry )
-                        pModuleEntry = AddEntry(
-                            aModName,
-                            Image( IDEResId( RID_IMG_MODULE ) ),
-                            Image( IDEResId( RID_IMG_MODULE_HC ) ),
-                            pLibRootEntry, false,
-                            std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
+                    for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
+		 			{
+                        String aModName = pModNames[ i ];
+                        SvLBoxEntry* pModuleEntry = FindEntry( pLibRootEntry, aModName, OBJ_TYPE_MODULE );
+                        if ( !pModuleEntry )
+                            pModuleEntry = AddEntry(
+                                aModName,
+                                Image( IDEResId( RID_IMG_MODULE ) ),
+                                Image( IDEResId( RID_IMG_MODULE_HC ) ),
+                                pLibRootEntry, false,
+                                std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
 
-					// methods
-					if ( nMode & BROWSEMODE_SUBS )
-					{
-                        Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
-						sal_Int32 nCount = aNames.getLength();
-						const ::rtl::OUString* pNames = aNames.getConstArray();
+		 				// methods
+		 				if ( nMode & BROWSEMODE_SUBS )
+		 				{
+                            Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
+		 					sal_Int32 nCount = aNames.getLength();
+		 					const ::rtl::OUString* pNames = aNames.getConstArray();
 
-						for ( sal_Int32 j = 0 ; j < nCount ; j++ )
-						{
-							String aName = pNames[ j ];
-							SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
-                            if ( !pEntry )
-                                pEntry = AddEntry(
-                                    aName,
-                                    Image( IDEResId( RID_IMG_MACRO ) ),
-                                    Image( IDEResId( RID_IMG_MACRO_HC ) ),
-                                    pModuleEntry, false,
-                                    std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
-						}
-                    }
-				}
+		 					for ( sal_Int32 j = 0 ; j < nCount ; j++ )
+		 					{
+		 						String aName = pNames[ j ];
+		 						SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
+                                if ( !pEntry )
+                                    pEntry = AddEntry(
+                                        aName,
+                                        Image( IDEResId( RID_IMG_MACRO ) ),
+                                        Image( IDEResId( RID_IMG_MACRO_HC ) ),
+                                        pModuleEntry, false,
+                                        std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
+		 					}
+                        }
+		 			}
+                }
             }
-		    catch ( const container::NoSuchElementException& )
-		    {
+		 	catch ( const container::NoSuchElementException& )
+		 	{
                 DBG_UNHANDLED_EXCEPTION();
-		    }
+		 	}
         }   
     }
 
@@ -368,6 +396,139 @@
     }
 }
 
+void BasicTreeListBox::ImpCreateLibSubEntriesInVBAMode( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName )
+{
+    ::std::map< BasicEntryType, ::rtl::OUString > aEntryMap;
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_DOCUMENT_OBJECTS, String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_USERFORMS,  String( IDEResId( RID_STR_USERFORMS ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_NORMAL_MODULES, String( IDEResId( RID_STR_NORMAL_MODULES ) ) ) );
+    aEntryMap.insert( ::std::make_pair( OBJ_TYPE_CLASS_MODULES,  String( IDEResId( RID_STR_CLASS_MODULES ) ) ) );
+
+    ::std::map< BasicEntryType, ::rtl::OUString >::iterator iter;
+    for( iter = aEntryMap.begin(); iter != aEntryMap.end(); ++iter )
+    {
+        BasicEntryType eType = iter->first;
+        ::rtl::OUString aEntryName = iter->second;
+        SvLBoxEntry* pLibSubRootEntry = FindEntry( pLibRootEntry, aEntryName, eType );
+        if( pLibSubRootEntry )
+        {
+            SetEntryBitmaps( pLibSubRootEntry, Image( IDEResId( RID_IMG_MODLIB ) ), Image( IDEResId( RID_IMG_MODLIB_HC ) ) );
+            if ( IsExpanded( pLibSubRootEntry ) )
+			    ImpCreateLibSubSubEntriesInVBAMode( pLibSubRootEntry, rDocument, rLibName );
+        }
+        else
+        {
+            pLibSubRootEntry = AddEntry(
+                aEntryName,
+                Image( IDEResId( RID_IMG_MODLIB ) ),
+                Image( IDEResId( RID_IMG_MODLIB_HC ) ),
+                pLibRootEntry, true,
+                std::auto_ptr< BasicEntry >( new BasicEntry( eType ) ) );
+        }
+    }
+}
+
+void BasicTreeListBox::ImpCreateLibSubSubEntriesInVBAMode( SvLBoxEntry* pLibSubRootEntry, const ScriptDocument& rDocument, const String& rLibName )
+{
+    uno::Reference< container::XNameContainer > xLib = rDocument.getOrCreateLibrary( E_SCRIPTS, rLibName );
+    if( !xLib.is() )
+        return;
+
+    try
+	{
+        // get a sorted list of module names
+        Sequence< ::rtl::OUString > aModNames = rDocument.getObjectNames( E_SCRIPTS, rLibName );
+        sal_Int32 nModCount = aModNames.getLength();
+    	const ::rtl::OUString* pModNames = aModNames.getConstArray();
+
+        BasicEntryDescriptor aDesc( GetEntryDescriptor( pLibSubRootEntry ) );
+        BasicEntryType eCurrentType( aDesc.GetType() );
+
+        for ( sal_Int32 i = 0 ; i < nModCount ; i++ )
+		{
+            String aModName = pModNames[ i ];
+            BasicEntryType eType = OBJ_TYPE_UNKNOWN;
+            switch( lcl_getModuleType( xLib, aModName ) )
+            {
+                case script::ModuleType::Document:
+                    eType = OBJ_TYPE_DOCUMENT_OBJECTS;
+                    break;
+                case script::ModuleType::Form:
+                    eType = OBJ_TYPE_USERFORMS;
+                    break;
+                case script::ModuleType::Normal:
+                    eType = OBJ_TYPE_NORMAL_MODULES;
+                    break;
+                case script::ModuleType::Class:
+                    eType = OBJ_TYPE_CLASS_MODULES;
+                    break;
+            }
+            if( eType != eCurrentType )
+                continue;
+
+			// display a nice friendly name in the ObjectModule tab,
+           	// combining the objectname and module name, e.g. Sheet1 ( Financials )
+            String aEntryName( aModName );
+            if( eType == OBJ_TYPE_DOCUMENT_OBJECTS )
+            {
+	       	    String sObjName;
+            	lcl_getObjectName( xLib, aModName, sObjName );
+		    	if( sObjName.Len() )
+        	   	{
+		        	aEntryName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+            	}
+            }
+            SvLBoxEntry* pModuleEntry = FindEntry( pLibSubRootEntry, aEntryName, OBJ_TYPE_MODULE );
+            if ( !pModuleEntry )
+                pModuleEntry = AddEntry(
+                    aEntryName,
+                    Image( IDEResId( RID_IMG_MODULE ) ),
+                    Image( IDEResId( RID_IMG_MODULE_HC ) ),
+                    pLibSubRootEntry, false,
+                    std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
+
+			// methods
+			if ( nMode & BROWSEMODE_SUBS )
+			{
+                Sequence< ::rtl::OUString > aNames = BasicIDE::GetMethodNames( rDocument, rLibName, aModName );
+				sal_Int32 nCount = aNames.getLength();
+				const ::rtl::OUString* pNames = aNames.getConstArray();
+
+				for ( sal_Int32 j = 0 ; j < nCount ; j++ )
+				{
+					String aName = pNames[ j ];
+					SvLBoxEntry* pEntry = FindEntry( pModuleEntry, aName, OBJ_TYPE_METHOD );
+                    if ( !pEntry )
+                        pEntry = AddEntry(
+                            aName,
+                            Image( IDEResId( RID_IMG_MACRO ) ),
+                            Image( IDEResId( RID_IMG_MACRO_HC ) ),
+                            pModuleEntry, false,
+                            std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_METHOD ) ) );
+    			}
+            }
+	    }
+    }
+    catch ( const container::NoSuchElementException& )
+	{
+        DBG_UNHANDLED_EXCEPTION();
+    }
+}
+
+SvLBoxEntry* BasicTreeListBox::ImpFindEntry( SvLBoxEntry* pParent, const String& rText )
+{
+	ULONG nRootPos = 0;
+	SvLBoxEntry* pEntry = pParent ? FirstChild( pParent ) : GetEntry( nRootPos );
+	while ( pEntry )
+	{
+		if (  GetEntryText( pEntry ) == rText ) 
+			return pEntry;
+
+		pEntry = pParent ? NextSibling( pEntry ) : GetEntry( ++nRootPos );
+	}
+	return 0;
+}
+
 void BasicTreeListBox::onDocumentCreated( const ScriptDocument& /*_rDocument*/ )
 {
     UpdateEntries();
@@ -480,10 +641,11 @@
         if ( aDocument.isAlive() )
         {
             String aLibName( aDesc.GetLibName() );
+            String aLibSubName( aDesc.GetLibSubName() );
             String aName( aDesc.GetName() );
             String aMethodName( aDesc.GetMethodName() );
 
-            if ( aLibName.Len() && !aName.Len() && !aMethodName.Len() )
+            if ( aLibName.Len() && !aLibSubName.Len() && !aName.Len() && !aMethodName.Len() )
 		    {
                 // check password, if library is password protected and not verified
                 ::rtl::OUString aOULibName( aLibName );
@@ -636,7 +798,7 @@
         aDesc = BasicEntryDescriptor(
             ScriptDocument::getApplicationScriptDocument(),
             LIBRARY_LOCATION_USER, String::CreateFromAscii( "Standard" ), 
-            String::CreateFromAscii( "." ), OBJ_TYPE_UNKNOWN );
+            String(), String::CreateFromAscii( "." ), OBJ_TYPE_UNKNOWN );
     }
     ScriptDocument aDocument( aDesc.GetDocument() );
     OSL_ENSURE( aDocument.isValid(), "BasicTreeListBox::SetCurrentEntry: invalid document!" );
@@ -653,14 +815,24 @@
             if ( pLibEntry )
             {
                 pCurEntry = pLibEntry;
+                String aLibSubName( aDesc.GetLibSubName() );
+                if( aLibSubName.Len() )
+                {
+                    Expand( pLibEntry );
+                    SvLBoxEntry* pLibSubEntry = ImpFindEntry( pLibEntry, aLibSubName );
+                    if( pLibSubEntry )
+                    {
+                        pCurEntry = pLibSubEntry;
+                    }
+                }
                 String aName( aDesc.GetName() );
                 if ( aName.Len() )
                 {
-                    Expand( pLibEntry );
+                    Expand( pCurEntry );
                     BasicEntryType eType = OBJ_TYPE_MODULE;
                     if ( aDesc.GetType() == OBJ_TYPE_DIALOG )
                         eType = OBJ_TYPE_DIALOG;
-                    SvLBoxEntry* pEntry = FindEntry( pLibEntry, aName, eType );
+                    SvLBoxEntry* pEntry = FindEntry( pCurEntry, aName, eType );
                     if ( pEntry )
                     {
                         pCurEntry = pEntry;
Index: basctl/source/basicide/bastypes.cxx
===================================================================
--- basctl/source/basicide/bastypes.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/bastypes.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -60,6 +60,7 @@
 #include <com/sun/star/script/XLibraryContainer2.hpp>
 #endif
 #include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
@@ -594,8 +595,30 @@
                 aPopup.EnableItem( SID_BASICIDE_RENAMECURRENT, FALSE );
                 aPopup.RemoveDisabledEntries();
             }
+			
+			// disable to delete or remove object modules in IDE
+			BasicManager* pBasMgr = aDocument.getBasicManager();
+			if ( pBasMgr )
+			{
+				StarBASIC* pBasic = pBasMgr->GetLib( aOULibName );
+				if( pBasic )
+				{
+					IDEWindowTable& aIDEWindowTable = pIDEShell->GetIDEWindowTable();
+					IDEBaseWindow* pWin = aIDEWindowTable.Get( GetCurPageId() );
+					if( pWin && pWin->ISA( ModulWindow ) )
+					{
+						SbModule* pActiveModule = (SbModule*)pBasic->FindModule( pWin->GetName() );
+						if( pActiveModule && ( pActiveModule->GetModuleType() == script::ModuleType::Document ) )
+						{
+							aPopup.EnableItem( SID_BASICIDE_DELETECURRENT, FALSE );
+							aPopup.EnableItem( SID_BASICIDE_RENAMECURRENT, FALSE );
+						}
+					}
+				}
+			}
         }
 
+
         SfxViewFrame* pViewFrame = pIDEShell ? pIDEShell->GetViewFrame() : NULL;
 	    SfxDispatcher* pDispatcher = pViewFrame ? pViewFrame->GetDispatcher() : NULL;
         if ( pDispatcher )
Index: basctl/source/basicide/bastype3.cxx
===================================================================
--- basctl/source/basicide/bastype3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/bastype3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -134,6 +134,14 @@
 		    }
         }
     }
+    else if ( eType == OBJ_TYPE_DOCUMENT_OBJECTS 
+            || eType == OBJ_TYPE_USERFORMS
+            || eType == OBJ_TYPE_NORMAL_MODULES
+            || eType == OBJ_TYPE_CLASS_MODULES )
+    {
+        String aLibName( aDesc.GetLibName() );
+        ImpCreateLibSubSubEntriesInVBAMode( pEntry, aDocument, aLibName );
+    }
 	else {
 		DBG_ERROR( "BasicTreeListBox::RequestingChilds: Unknown Type!" );
     }
@@ -204,6 +212,7 @@
     }
 
 	SbxVariable* pVar = 0;
+    bool bDocumentObjects = false;
 	if ( aEntries.Count() )
 	{
 		for ( USHORT n = 0; n < aEntries.Count(); n++ )
@@ -226,6 +235,12 @@
 				case OBJ_TYPE_MODULE:
 				{
 					DBG_ASSERT( pVar && pVar->IsA( TYPE(StarBASIC) ), "FindVariable: Ungueltiges Basic" );
+                    // extract the module name from the string like "Sheet1 (Example1)"
+                    if( bDocumentObjects )
+                    {
+                        sal_uInt16 nIndex = 0;
+                        aName = aName.GetToken( 0, ' ', nIndex );
+                    }
 					pVar = ((StarBASIC*)pVar)->FindModule( aName );
 				}
 				break;
@@ -240,6 +255,15 @@
 					// sbx dialogs removed
 				}
 				break;
+                case OBJ_TYPE_DOCUMENT_OBJECTS:
+                    bDocumentObjects = true;
+                case OBJ_TYPE_USERFORMS:
+                case OBJ_TYPE_NORMAL_MODULES:
+                case OBJ_TYPE_CLASS_MODULES:
+                {
+                    // skip, to find the child entry.
+                    continue;
+                }
                 default:
                 {
                     DBG_ERROR( "FindVariable: Unbekannter Typ!" );
@@ -260,12 +284,13 @@
     ScriptDocument aDocument( ScriptDocument::getApplicationScriptDocument() );
     LibraryLocation eLocation = LIBRARY_LOCATION_UNKNOWN;
 	String aLibName;
+	String aLibSubName;
 	String aName;
 	String aMethodName;
     BasicEntryType eType = OBJ_TYPE_UNKNOWN;
 
 	if ( !pEntry )
-        return BasicEntryDescriptor( aDocument, eLocation, aLibName, aName, aMethodName, eType );
+        return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aName, aMethodName, eType );
 
 	EntryArray aEntries;
 
@@ -332,6 +357,15 @@
 					eType = pBE->GetType();
 				}
 				break;
+                case OBJ_TYPE_DOCUMENT_OBJECTS:
+                case OBJ_TYPE_USERFORMS:
+                case OBJ_TYPE_NORMAL_MODULES:
+                case OBJ_TYPE_CLASS_MODULES:
+				{
+					aLibSubName = GetEntryText( pLE );
+					eType = pBE->GetType();
+				}
+				break;
 				default:
                 {
                     DBG_ERROR( "GetEntryDescriptor: Unbekannter Typ!" );
@@ -345,7 +379,7 @@
 		}
 	}
 
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aName, aMethodName, eType );
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aName, aMethodName, eType );
 }
 
 USHORT BasicTreeListBox::ConvertType( BasicEntryType eType )
@@ -427,6 +461,14 @@
             bIsValid = BasicIDE::HasMethod( aDocument, aLibName, aName, aMethodName );
         }
         break;
+        case OBJ_TYPE_DOCUMENT_OBJECTS:
+        case OBJ_TYPE_USERFORMS:
+        case OBJ_TYPE_NORMAL_MODULES:
+        case OBJ_TYPE_CLASS_MODULES:
+        {
+            bIsValid = true;
+        }
+        break;
 		default: ;
     }
 
Index: basctl/source/basicide/basides1.cxx
===================================================================
--- basctl/source/basicide/basides1.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/basides1.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1201,10 +1201,16 @@
                 // return any non-suspended window
                 return pWin;
             }
-            else if ( pWin->IsDocument( rDocument ) && pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
+            else if ( pWin->IsDocument( rDocument ) )
+            {
+                OSL_TRACE("FindWindow pWin->GetLibName() %s rLibName %s",
+			rtl::OUStringToOString( pWin->GetLibName(), RTL_TEXTENCODING_UTF8 ).getStr(),
+			rtl::OUStringToOString( rLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( ModulWindow ) %d && nType %d = BASICIDE_TYPE_MODULE %d", pWin->IsA( TYPE( ModulWindow ) ), nType, BASICIDE_TYPE_MODULE );
+                OSL_TRACE("pWin->pWin->IsA( TYPE( DialogWindow ) %d && nType %d = BASICIDE_TYPE_DIALOG %d", pWin->IsA( TYPE( DialogWindow ) ), nType, BASICIDE_TYPE_DIALOG );
+		if (  pWin->GetLibName() == rLibName && pWin->GetName() == rName &&
                       ( ( pWin->IsA( TYPE( ModulWindow ) )  && nType == BASICIDE_TYPE_MODULE ) ||
                         ( pWin->IsA( TYPE( DialogWindow ) ) && nType == BASICIDE_TYPE_DIALOG ) ) )
-            {
                 return pWin;
             }
         }
Index: basctl/source/basicide/basides2.cxx
===================================================================
--- basctl/source/basicide/basides2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/basides2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -55,11 +55,38 @@
 #include <tools/diagnose_ex.h>
 #include <sfx2/sfxdefs.hxx>
 #include <sfx2/signaturestate.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 namespace css = ::com::sun::star;
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName )
+{
+    try
+    {
+		uno::Any aElement( rLib->getByName( rModName ) );
+		script::ModuleInfo aModuleInfo;
+		if( aElement >>= aModuleInfo )
+		{
+			uno::Any aObject( aModuleInfo.ModuleObject );
+			uno::Reference< lang::XServiceInfo > xServiceInfo( aObject, uno::UNO_QUERY );
+			if( xServiceInfo.is() && xServiceInfo->supportsService( rtl::OUString::createFromAscii( "ooo.vba.excel.Worksheet" ) ) )
+			{
+				uno::Reference< container::XNamed > xNamed( aObject, uno::UNO_QUERY );
+				if( xNamed.is() )
+					rObjName = xNamed->getName();
+			}
+		}
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
 IMPL_LINK_INLINE_START( BasicIDEShell, ObjectDialogCancelHdl, ObjectCatalog *, EMPTYARG )
 {
 	ShowObjectDialog( FALSE, TRUE );
@@ -232,7 +259,7 @@
     if ( !aLibName.Len() )
         aLibName = String::CreateFromAscii( "Standard" );
 
-    rDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
+    uno::Reference< container::XNameContainer > xLib = rDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
 
 	if ( !aModName.Len() )
         aModName = rDocument.createObjectName( E_SCRIPTS, aLibName );
@@ -251,9 +278,12 @@
 
         if ( bSuccess )
         {
-			// new module window
-			pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
-			nKey = InsertWindowInTable( pWin );
+			pWin = FindBasWin( rDocument, aLibName, aModName, FALSE, TRUE );
+            if( !pWin )
+			{    // new module window
+			    pWin = new ModulWindow( pModulLayout, rDocument, aLibName, aModName, aModule );
+			    nKey = InsertWindowInTable( pWin );
+            }
         }
 	}
 	else
@@ -268,7 +298,21 @@
 		}
 		DBG_ASSERT( nKey, "CreateBasWin: Kein Key- Fenster nicht gefunden!" );
 	}
-	pTabBar->InsertPage( (USHORT)nKey, aModName );
+    if( nKey )
+	{
+		if( xLib.is() )
+		{
+			// display a nice friendly name in the ObjectModule tab,
+			// combining the objectname and module name, e.g. Sheet1 ( Financials )
+			String sObjName;
+			lcl_getObjectName( xLib, rModName, sObjName );
+			if( sObjName.Len() )
+			{
+				aModName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+			}
+		}
+		pTabBar->InsertPage( (USHORT)nKey, aModName );
+	}	
 	pTabBar->Sort();
 	pWin->GrabScrollBars( &aHScrollBar, &aVScrollBar );
 	if ( !pCurWin )
Index: basctl/source/basicide/basides3.cxx
===================================================================
--- basctl/source/basicide/basides3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/basides3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -98,7 +98,7 @@
                 Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
                 OSL_ASSERT( xProps.is() );
                 OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-				::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+				::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.getDocument() );
 				LocalizationMgr::setStringResourceAtDialog( rDocument, rLibName, aDlgName, xDialogModel );
 
 				// new dialog window
Index: basctl/source/basicide/bastype2.hxx
===================================================================
--- basctl/source/basicide/bastype2.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/bastype2.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -42,7 +42,7 @@
 #include <sbxitem.hxx>
 #include "basobj.hxx"
 
-enum BasicEntryType { OBJ_TYPE_UNKNOWN, OBJ_TYPE_DOCUMENT, OBJ_TYPE_LIBRARY, OBJ_TYPE_MODULE, OBJ_TYPE_DIALOG, OBJ_TYPE_METHOD };
+enum BasicEntryType { OBJ_TYPE_UNKNOWN, OBJ_TYPE_DOCUMENT, OBJ_TYPE_LIBRARY, OBJ_TYPE_MODULE, OBJ_TYPE_DIALOG, OBJ_TYPE_METHOD, OBJ_TYPE_DOCUMENT_OBJECTS, OBJ_TYPE_USERFORMS, OBJ_TYPE_NORMAL_MODULES, OBJ_TYPE_CLASS_MODULES };
 
 #define BROWSEMODE_MODULES		0x01
 #define BROWSEMODE_SUBS			0x02
@@ -101,14 +101,15 @@
     ScriptDocument          m_aDocument;
     LibraryLocation         m_eLocation;
     String                  m_aLibName;
+    String                  m_aLibSubName;  // for vba entry:  Document Objects, Class Modules, Forms and Normal Modules
     String                  m_aName;
     String                  m_aMethodName;
     BasicEntryType          m_eType;
 
 public:
                             BasicEntryDescriptor();
-	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, BasicEntryType eType );
-	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rName, const String& rMethodName, BasicEntryType eType );
+	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, BasicEntryType eType );
+	                        BasicEntryDescriptor( const ScriptDocument& rDocument, LibraryLocation eLocation, const String& rLibName, const String& rLibSubName, const String& rName, const String& rMethodName, BasicEntryType eType );
     virtual                 ~BasicEntryDescriptor();
 
                             BasicEntryDescriptor( const BasicEntryDescriptor& rDesc );
@@ -125,6 +126,9 @@
     const String&           GetLibName() const { return m_aLibName; }
     void                    SetLibName( const String& aLibName ) { m_aLibName = aLibName; }
 
+    const String&           GetLibSubName() const { return m_aLibSubName; }
+    void                    SetLibSubName( const String& aLibSubName ) { m_aLibSubName = aLibSubName; }
+
     const String&           GetName() const { return m_aName; }
     void                    SetName( const String& aName ) { m_aName = aName; }
 
@@ -164,6 +168,9 @@
 
     void                    ImpCreateLibEntries( SvLBoxEntry* pShellRootEntry, const ScriptDocument& rDocument, LibraryLocation eLocation );
 	void 					ImpCreateLibSubEntries( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+	void 					ImpCreateLibSubEntriesInVBAMode( SvLBoxEntry* pLibRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+	void 					ImpCreateLibSubSubEntriesInVBAMode( SvLBoxEntry* pLibSubRootEntry, const ScriptDocument& rDocument, const String& rLibName );
+    SvLBoxEntry*            ImpFindEntry( SvLBoxEntry* pParent, const String& rText );
 
     // DocumentEventListener
     virtual void onDocumentCreated( const ScriptDocument& _rDocument );
Index: basctl/source/basicide/scriptdocument.cxx
===================================================================
--- basctl/source/basicide/scriptdocument.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/scriptdocument.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -56,6 +56,7 @@
 #include <com/sun/star/frame/XModel2.hpp>
 #include <com/sun/star/awt/XWindow2.hpp>
 #include <com/sun/star/document/XEmbeddedScripts.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 /** === end UNO includes === **/
 
 #include <sfx2/objsh.hxx>
@@ -142,6 +143,7 @@
     using ::com::sun::star::uno::RuntimeException;
     using ::com::sun::star::document::XEventBroadcaster;
     using ::com::sun::star::document::XEmbeddedScripts;
+    using ::com::sun::star::script::ModuleInfo;
     /** === end UNO using === **/
     namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
     namespace FrameSearchFlag = ::com::sun::star::frame::FrameSearchFlag;
@@ -661,7 +663,7 @@
                 if ( !_rxExistingDialogModel.is() )
                 {
                     Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
-    			    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext() );
+    			    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext(), getDocument() );
                 }
 
 			    // set new name as property
@@ -669,11 +671,20 @@
 			    xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rNewName ) );
 
 			    // export dialog model
-			    xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+			    xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), getDocument() );
 			    aElement <<= xISP;
             }
 
 		    // insert element by new name in container
+            if ( _eType == E_SCRIPTS )
+            {
+                ModuleInfo sModuleInfo;
+                if ( aElement >>= sModuleInfo )
+                {
+                    sModuleInfo.ModuleName = _rNewName;
+                    aElement <<= sModuleInfo;
+                }
+            }
 		    xLib->insertByName( _rNewName, aElement );
             return true;
         }
@@ -738,8 +749,16 @@
             Reference< XNameContainer > xLib( getOrCreateLibrary( E_SCRIPTS, _rLibName ), UNO_QUERY_THROW );
 	        if ( !xLib->hasByName( _rModName ) )
                 return false;
-
-            xLib->replaceByName( _rModName, makeAny( _rModuleCode ) );
+            ModuleInfo mInfo;
+            Any aMod;
+            if ( xLib->getByName( _rModName ) >>= mInfo )
+            {
+                mInfo.ModuleSource = _rModuleCode;
+                aMod <<= mInfo;
+            }
+            else
+                aMod <<= _rModuleCode;
+            xLib->replaceByName( _rModName, aMod );
             return true;
         }
         catch( const Exception& )
@@ -772,7 +791,7 @@
 		    xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rDialogName ) );
 
 		    // export dialog model
-            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext(), getDocument() );
 
 		    // insert dialog into library
 		    xLib->insertByName( _rDialogName, makeAny( _out_rDialogProvider ) );
@@ -1392,7 +1411,15 @@
         Any aCode;
         if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
             return false;
-        OSL_VERIFY( aCode >>= _out_rModuleSource );
+        ModuleInfo sModuleInfo;
+        if ( aCode >>= sModuleInfo )
+        {
+            _out_rModuleSource = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            OSL_VERIFY( aCode >>= _out_rModuleSource );
+        }
         return true;
     }
 
Index: basctl/source/basicide/macrodlg.cxx
===================================================================
--- basctl/source/basicide/macrodlg.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/macrodlg.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -385,7 +385,15 @@
         SbModule* pModule = 0;
         String aModName( aDesc.GetName() );
         if ( aModName.Len() )
+        {
+            // extract the module name from the string like "Sheet1 (Example1)"
+            if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+            {
+                sal_uInt16 nIndex = 0;
+                aModName = aModName.GetToken( 0, ' ', nIndex );
+            }
 	        pModule = pBasic->FindModule( aModName );
+        }    
         else if ( pBasic->GetModules()->Count() )
 	        pModule = (SbModule*)pBasic->GetModules()->Get( 0 );
 
@@ -713,6 +721,12 @@
         BasicManager* pBasMgr = aDocument.getBasicManager();
         String aLib( aDesc.GetLibName() );
         String aMod( aDesc.GetName() );
+        // extract the module name from the string like "Sheet1 (Example1)"
+        if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+        {
+            sal_uInt16 nIndex = 0;
+            aMod = aMod.GetToken( 0, ' ', nIndex );
+        }
         String aSub( aDesc.GetMethodName() );
 		SfxMacroInfoItem aInfoItem( SID_BASICIDE_ARG_MACROINFO, pBasMgr, aLib, aMod, aSub, String() );
 		if ( pButton == &aEditButton )
Index: basctl/source/basicide/basidesh.src
===================================================================
--- basctl/source/basicide/basidesh.src	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/basidesh.src	(.../cws/vbasupportdev300)	(revision 277097)
@@ -639,6 +639,22 @@
 {
 	Text [ en-US ] = "[Default Language]" ;
 };
+String RID_STR_DOCUMENT_OBJECTS
+{
+    Text [ en-US ] = "Document Objects" ;
+};
+String RID_STR_USERFORMS
+{
+    Text [ en-US ] = "Forms" ;
+};
+String RID_STR_NORMAL_MODULES
+{
+    Text [ en-US ] = "Modules" ;
+};
+String RID_STR_CLASS_MODULES
+{
+    Text [ en-US ] = "Class Modules" ;
+};
 
 #define MN_EDIT       20
 #define MN_VIEW 21
Index: basctl/source/basicide/moduldlg.cxx
===================================================================
--- basctl/source/basicide/moduldlg.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/moduldlg.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -87,7 +87,7 @@
     if ( pEntry )
     {
         USHORT nDepth = GetModel()->GetDepth( pEntry );
-        if ( nDepth == 2 )
+        if ( nDepth >= 2 )
         {
             BasicEntryDescriptor aDesc( GetEntryDescriptor( pEntry ) );
             ScriptDocument aDocument( aDesc.GetDocument() );
@@ -165,7 +165,7 @@
     if ( pEntry )
     {
         USHORT nDepth = GetModel()->GetDepth( pEntry );
-        if ( nDepth == 2 )
+        if ( nDepth >= 2 )
         {
             nMode_ = SV_DRAGDROP_CTRL_COPY;
             BasicEntryDescriptor aDesc( GetEntryDescriptor( pEntry ) );
@@ -213,7 +213,7 @@
 
     // don't drop on a library, which is not loaded, readonly or password protected
     // or which already has a module/dialog with this name
-    if ( bValid && ( nDepth == 1 || nDepth == 2 ) )
+    if ( bValid && ( nDepth > 0 ) )
     {
 		// get source module/dialog name
         BasicEntryDescriptor aSourceDesc( GetEntryDescriptor( pSelected ) );
@@ -315,7 +315,7 @@
     Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
     OSL_ASSERT( xProps.is() );
     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-	::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+	::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rSourceDoc.getDocument() );
 
 	if( xDialogModel.is() )
 	{
@@ -332,7 +332,7 @@
 		{
 			LocalizationMgr::setResourceIDsForDialog( xDialogModel, xDestMgr );
 		}
-		io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		io_xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDestDoc.getDocument() );
 	}
 }
 
@@ -351,7 +351,7 @@
 		rpNewParent = pTarget;
 		rNewChildPos = 0;
 	}
-	else if ( nDepth == 2 )
+	else if ( nDepth >= 2 )
 	{
 		// Target = Modul/Dialog => Modul/Dialog unter das uebergeordnete Basic haengen...
 		rpNewParent = GetParent( pTarget );
@@ -626,20 +626,31 @@
 {
     // enable/disable edit button
 	SvLBoxEntry* pCurEntry = aBasicBox.GetCurEntry();
+    BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
+    ScriptDocument aDocument( aDesc.GetDocument() );
+    ::rtl::OUString aOULibName( aDesc.GetLibName() );
+    String aLibSubName( aDesc.GetLibSubName() );
+    BasicManager* pBasMgr = aDocument.getBasicManager();
+    StarBASIC* pBasic = pBasMgr ? pBasMgr->GetLib( aOULibName ) : 0;
+    sal_Bool bVBAEnabled = pBasic ? pBasic->isVBAEnabled(): sal_False;
+    USHORT nMode = aBasicBox.GetMode();
+
 	USHORT nDepth = pCurEntry ? aBasicBox.GetModel()->GetDepth( pCurEntry ) : 0;
-	if ( nDepth == 2 )
-		aEditButton.Enable();
+	if ( nDepth >= 2 )
+    {
+        if( bVBAEnabled && ( nMode & BROWSEMODE_MODULES ) && ( nDepth == 2 ) )
+            aEditButton.Disable();
+        else
+		    aEditButton.Enable();
+    }    
 	else
 		aEditButton.Disable();
 
     // enable/disable new module/dialog buttons
-    BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
     LibraryLocation eLocation( aDesc.GetLocation() );
     BOOL bReadOnly = FALSE;
-    if ( nDepth == 1 || nDepth == 2 )
+    if ( nDepth > 0 )
     {
-        ScriptDocument aDocument( aDesc.GetDocument() );
-        ::rtl::OUString aOULibName( aDesc.GetLibName() );
         Reference< script::XLibraryContainer2 > xModLibContainer( aDocument.getLibraryContainer( E_SCRIPTS ), UNO_QUERY );
         Reference< script::XLibraryContainer2 > xDlgLibContainer( aDocument.getLibraryContainer( E_DIALOGS ), UNO_QUERY );
         if ( ( xModLibContainer.is() && xModLibContainer->hasByName( aOULibName ) && xModLibContainer->isLibraryReadOnly( aOULibName ) ) ||
@@ -660,9 +671,14 @@
     }
 
     // enable/disable delete button
-	if ( nDepth == 2 && !bReadOnly && eLocation != LIBRARY_LOCATION_SHARE )
-		aDelButton.Enable();
-	else
+    if ( nDepth >= 2 && !bReadOnly && eLocation != LIBRARY_LOCATION_SHARE )
+    {
+        if( bVBAEnabled && ( nMode & BROWSEMODE_MODULES ) && ( ( nDepth == 2 ) || aLibSubName.Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) ) )
+            aDelButton.Disable();
+        else
+            aDelButton.Enable();
+    }
+    else
 		aDelButton.Disable();
 }
 
@@ -688,13 +704,20 @@
         SfxDispatcher* pDispatcher = pViewFrame ? pViewFrame->GetDispatcher() : NULL;
         SvLBoxEntry* pCurEntry = aBasicBox.GetCurEntry();
 		DBG_ASSERT( pCurEntry, "Entry?!" );
-		if ( aBasicBox.GetModel()->GetDepth( pCurEntry ) == 2 )
+		if ( aBasicBox.GetModel()->GetDepth( pCurEntry ) >= 2 )
 		{
             BasicEntryDescriptor aDesc( aBasicBox.GetEntryDescriptor( pCurEntry ) );
 			if ( pDispatcher )
 			{
+                String aModName( aDesc.GetName() );
+                // extract the module name from the string like "Sheet1 (Example1)"
+                if( aDesc.GetLibSubName().Equals( String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) ) ) )
+                {
+                    sal_uInt16 nIndex = 0;
+                    aModName = aModName.GetToken( 0, ' ', nIndex );
+                }
                 SbxItem aSbxItem( SID_BASICIDE_ARG_SBX, aDesc.GetDocument(), aDesc.GetLibName(), 
-                                  aDesc.GetName(), aBasicBox.ConvertType( aDesc.GetType() ) );
+                                  aModName, aBasicBox.ConvertType( aDesc.GetType() ) );
 				pDispatcher->Execute( SID_BASICIDE_SHOWSBX, SFX_CALLMODE_SYNCHRON, &aSbxItem, 0L );
 			}
 		}
@@ -976,14 +999,14 @@
 		try
 		{
             ::rtl::OUString sModuleCode;
+            // the module has existed
+            if( rDocument.hasModule( aLibName, aModName ) )
+                return NULL;
             rDocument.createModule( aLibName, aModName, bMain, sModuleCode );
             BasicManager* pBasMgr = rDocument.getBasicManager();
-            if ( pBasMgr )
-            {
-                StarBASIC* pBasic = pBasMgr->GetLib( aLibName );
-                if ( pBasic )
-                    pModule = pBasic->FindModule( aModName );
-            }
+            StarBASIC* pBasic = pBasMgr? pBasMgr->GetLib( aLibName ) : 0;
+            if ( pBasic )
+                pModule = pBasic->FindModule( aModName );
 			SbxItem aSbxItem( SID_BASICIDE_ARG_SBX, rDocument, aLibName, aModName, BASICIDE_TYPE_MODULE );					
 			BasicIDEShell* pIDEShell = IDE_DLL()->GetShell();
 			SfxViewFrame* pViewFrame = pIDEShell ? pIDEShell->GetViewFrame() : NULL;
@@ -1005,14 +1028,27 @@
                 {
                     if ( !rBasicBox.IsExpanded( pLibEntry ) )
                         rBasicBox.Expand( pLibEntry );
-                    SvLBoxEntry* pEntry = rBasicBox.FindEntry( pLibEntry, aModName, OBJ_TYPE_MODULE );
+                    SvLBoxEntry* pSubRootEntry = pLibEntry;
+                    if( pBasic && pBasic->isVBAEnabled() )
+                    {
+                        // add the new module in the "Modules" entry
+                        SvLBoxEntry* pLibSubEntry = rBasicBox.FindEntry( pLibEntry, String( IDEResId( RID_STR_NORMAL_MODULES ) ) , OBJ_TYPE_NORMAL_MODULES );
+                        if( pLibSubEntry )
+                        {
+                            if( !rBasicBox.IsExpanded( pLibSubEntry ) )
+                                rBasicBox.Expand( pLibSubEntry );
+                            pSubRootEntry = pLibSubEntry;    
+                        }
+                    }
+                    
+                    SvLBoxEntry* pEntry = rBasicBox.FindEntry( pSubRootEntry, aModName, OBJ_TYPE_MODULE );
                     if ( !pEntry )
                     {
                         pEntry = rBasicBox.AddEntry(
                             aModName,
                             Image( IDEResId( RID_IMG_MODULE ) ),
                             Image( IDEResId( RID_IMG_MODULE_HC ) ),
-                            pLibEntry, false,
+                            pSubRootEntry, false,
                             std::auto_ptr< BasicEntry >( new BasicEntry( OBJ_TYPE_MODULE ) ) );
                         DBG_ASSERT( pEntry, "InsertEntry fehlgeschlagen!" );
                     }
Index: basctl/source/basicide/baside2.cxx
===================================================================
--- basctl/source/basicide/baside2.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/baside2.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -49,6 +49,7 @@
 #include <com/sun/star/script/XLibraryContainer2.hpp>
 #endif
 #include <com/sun/star/document/MacroExecMode.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
 #include <toolkit/helper/vclunohelper.hxx>
 #include <sfx2/docfile.hxx>
 #include <basic/basrdll.hxx>
@@ -110,6 +111,8 @@
 
 TYPEINIT1( ModulWindow , IDEBaseWindow );
 
+void lcl_getObjectName( const uno::Reference< container::XNameContainer >& rLib, const String& rModName, String& rObjName );
+
 void lcl_PrintHeader( Printer* pPrinter, USHORT nPages, USHORT nCurPage, const String& rTitle )
 {
 	short nLeftMargin 	= LMARGPRN;
@@ -331,6 +334,8 @@
 			DBG_ASSERT( xModule.Is(), "Kein Modul!" );
 			AddStatus( BASWIN_RUNNINGBASIC );
 			USHORT nStart, nEnd, nCurMethodStart = 0;
+			TextSelection aSel = GetEditView()->GetSelection();
+			nCurMethodStart = ( aSel.GetStart().GetPara() + 1 );
 			SbMethod* pMethod = 0;
 			// erstes Macro, sonst blind "Main" (ExtSearch?)
 			for ( USHORT nMacro = 0; nMacro < xModule->GetMethods()->Count(); nMacro++ )
@@ -338,16 +343,16 @@
 				SbMethod* pM = (SbMethod*)xModule->GetMethods()->Get( nMacro );
 				DBG_ASSERT( pM, "Method?" );
 				pM->GetLineRange( nStart, nEnd );
-				if ( !pMethod || ( nStart < nCurMethodStart ) )
+				if (  nCurMethodStart >= nStart && nCurMethodStart <= nEnd ) 
 				{
 					pMethod = pM;
-					nCurMethodStart = nStart;
+					break;
 				}
 			}
 			if ( !pMethod )
-				pMethod = (SbMethod*)xModule->Find( String( RTL_CONSTASCII_USTRINGPARAM( "Main" ) ), SbxCLASS_METHOD );
+				return ( BasicIDE::ChooseMacro( uno::Reference< frame::XModel >(), FALSE, rtl::OUString() ).getLength() > 0 ) ? TRUE : FALSE;
 
-			if ( pMethod )
+			else
 			{
 				pMethod->SetDebugFlags( aStatus.nBasicFlags );
 				BasicDLL::SetDebugMode( TRUE );
@@ -1345,7 +1350,39 @@
     ScriptDocument aDocument( GetDocument() );
     String aLibName( GetLibName() );
     LibraryLocation eLocation = aDocument.getLibraryLocation( aLibName );
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, GetName(), OBJ_TYPE_MODULE );
+    String aModName( GetName() );
+    String aLibSubName;
+    if( xBasic.Is() && xBasic->isVBAEnabled() && xModule.Is() )
+    {
+        switch( xModule->GetModuleType() )
+        {
+            case script::ModuleType::Document:
+            {
+                aLibSubName = String( IDEResId( RID_STR_DOCUMENT_OBJECTS ) );
+                uno::Reference< container::XNameContainer > xLib = aDocument.getOrCreateLibrary( E_SCRIPTS, aLibName );
+                if( xLib.is() )
+                {
+                    String sObjName;
+                    lcl_getObjectName( xLib, aModName, sObjName );
+                    if( sObjName.Len() )
+                    {
+                        aModName.AppendAscii(" (").Append(sObjName).AppendAscii(")");
+                    }
+                }
+                break;
+            }    
+            case script::ModuleType::Form:
+                aLibSubName = String( IDEResId( RID_STR_USERFORMS ) );
+                break;
+            case script::ModuleType::Normal:
+                aLibSubName = String( IDEResId( RID_STR_NORMAL_MODULES ) );
+                break;
+            case script::ModuleType::Class:
+                aLibSubName = String( IDEResId( RID_STR_CLASS_MODULES ) );
+                break;
+        }
+    }
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, aModName, OBJ_TYPE_MODULE );
 }
 
 void ModulWindow::SetReadOnly( BOOL b )
Index: basctl/source/basicide/baside3.cxx
===================================================================
--- basctl/source/basicide/baside3.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/basicide/baside3.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -85,6 +85,7 @@
 #include <com/sun/star/resource/XStringResourceResolver.hpp>
 #include <com/sun/star/resource/StringResourceWithLocation.hpp>
 #include <com/sun/star/task/XInteractionHandler.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 using namespace comphelper;
 using namespace	::com::sun::star;
@@ -115,8 +116,16 @@ DialogWindow::DialogWindow( Window* pParent, const ScriptDocument& rDocument, St
 {
     InitSettings( TRUE, TRUE, TRUE );
 
-    pEditor = new DlgEditor();
+	pEditor = new DlgEditor( rDocument.getDocument() );
     pEditor->SetWindow( this );
+	// set vba mode on DialogModel ( allows it to work in 100thmm instead of MAP_APPFONT )
+	if ( rDocument.getDocument().is() )
+	{
+		uno::Reference< script::XVBACompat > xDocVBAMode( rDocument.getLibraryContainer( E_SCRIPTS ), uno::UNO_QUERY );
+		uno::Reference< script::XVBACompat > xDialogModelVBAMode( xDialogModel, uno::UNO_QUERY );
+		if ( xDocVBAMode.is()  &&  xDialogModelVBAMode.is() )
+			xDialogModelVBAMode->setVBACompatModeOn( xDocVBAMode->getVBACompatModeOn() );
+	}
     pEditor->SetDialog( xDialogModel );
 
     // Undo einrichten
@@ -731,7 +740,7 @@ BOOL DialogWindow::SaveDialog()
         Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
         OSL_ASSERT( xProps.is() );
         OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-        Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+		Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().getDocument() );
         Reference< XInputStream > xInput( xISP->createInputStream() );
 
         Reference< XSimpleFileAccess > xSFI( xMSF->createInstance
@@ -1013,7 +1022,7 @@ BOOL implImportDialog( Window* pWin, const String& rCurPath, const ScriptDocumen
             Reference< beans::XPropertySet > xProps( xMSF, UNO_QUERY );
             OSL_ASSERT( xProps.is() );
             OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-            ::xmlscript::importDialogModel( xInput, xDialogModel, xContext );
+            ::xmlscript::importDialogModel( xInput, xDialogModel, xContext, rDocument.getDocument() );
 
             String aXmlDlgName;
             Reference< beans::XPropertySet > xDialogModelPropSet( xDialogModel, UNO_QUERY );
@@ -1239,7 +1248,7 @@ BOOL implImportDialog( Window* pWin, const String& rCurPath, const ScriptDocumen
                 }
             }
 
-            Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+            Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, rDocument.getDocument() );
             bool bSuccess = rDocument.insertDialog( aLibName, aNewDlgName, xISP );
             if( bSuccess )
             {
@@ -1300,8 +1309,9 @@ BasicEntryDescriptor DialogWindow::CreateEntryDescriptor()
 {
     ScriptDocument aDocument( GetDocument() );
     String aLibName( GetLibName() );
+    String aLibSubName;
     LibraryLocation eLocation = aDocument.getLibraryLocation( aLibName );
-    return BasicEntryDescriptor( aDocument, eLocation, aLibName, GetName(), OBJ_TYPE_DIALOG );
+    return BasicEntryDescriptor( aDocument, eLocation, aLibName, aLibSubName, GetName(), OBJ_TYPE_DIALOG );
 }
 
 void DialogWindow::SetReadOnly( BOOL b )
@@ -1348,7 +1358,7 @@ void DialogWindow::StoreData()
                     Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY );
                     OSL_ASSERT( xProps.is() );
                     OSL_VERIFY( xProps->getPropertyValue( ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext );
-                    Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext );
+					Reference< XInputStreamProvider > xISP = ::xmlscript::exportDialogModel( xDialogModel, xContext, GetDocument().getDocument() );
                     xLib->replaceByName( ::rtl::OUString( GetName() ), makeAny( xISP ) );
                 }
             }

Index: basctl/source/inc/dlged.hxx
===================================================================
--- basctl/source/inc/dlged.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/inc/dlged.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,6 +35,7 @@
 #include <com/sun/star/awt/XControlContainer.hpp>
 #include <com/sun/star/datatransfer/DataFlavor.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/frame/XModel.hpp>
 #include <tools/link.hxx>
 #include <tools/gen.hxx> 
 #include <vcl/timer.hxx>
@@ -129,9 +130,11 @@
 	BOOL				bDialogModelChanged;
     Timer               aMarkTimer;
 	long				mnPaintGuard;
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > m_xDocument;
 
+	DlgEditor(); // not implemented
 public:
-	DlgEditor();
+	DlgEditor( const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel );
 	~DlgEditor();
 
 	void			SetWindow( Window* pWindow );
Index: basctl/source/inc/basidesh.hxx
===================================================================
--- basctl/source/inc/basidesh.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/source/inc/basidesh.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -49,6 +49,7 @@
 #include <com/sun/star/io/XInputStreamProvider.hpp>
 #endif
 
+#include <com/sun/star/container/XContainerListener.hpp>
 
 //----------------------------------------------------------------------------
 
@@ -107,6 +108,8 @@
     BOOL                m_bAppBasicModified;
     ::basctl::DocumentEventNotifier
                         m_aNotifier;
+friend class ContainerListenerImpl;
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XContainerListener > m_xLibListener;
 
 #if _SOLAR__PRIVATE
 	void				Init();
Index: basctl/inc/basidesh.hrc
===================================================================
--- basctl/inc/basidesh.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ basctl/inc/basidesh.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -175,6 +175,10 @@
 #define RID_STR_EXPORTPACKAGE			( RID_BASICIDE_START + 100 )
 #define RID_STR_EXPORTBASIC				( RID_BASICIDE_START + 101 )
 #define RID_STR_PACKAGE_BUNDLE			( RID_BASICIDE_START + 102 )
+#define RID_STR_DOCUMENT_OBJECTS        ( RID_BASICIDE_START + 103 )
+#define RID_STR_USERFORMS               ( RID_BASICIDE_START + 104 )
+#define RID_STR_NORMAL_MODULES          ( RID_BASICIDE_START + 105 )
+#define RID_STR_CLASS_MODULES           ( RID_BASICIDE_START + 106 )
 
 #endif	// _SVX_NOIDERESIDS
 
Index: xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx
===================================================================
--- xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/xmldlg_impmodels.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,18 +31,196 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_xmlscript.hxx"
 #include "imp_share.hxx"
-
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/beans/XPropertyState.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
-
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using ::rtl::OUString;
 
 namespace xmlscript
 {
+Reference< xml::input::XElement > MultiPage::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+rtl::OUString _label = rtl::OUString::createFromAscii("foo");
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement(
+            nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("title") ))
+	{
+		getStringAttr( &_label,
+                       OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                       xAttributes,
+                       _pImport->XMLNS_DIALOGS_UID );
+		
+		return new ElementBase(
+            _pImport->XMLNS_DIALOGS_UID,
+            rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
 
+void MultiPage::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) );
+//		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) );
+	Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		pStyle->importTextColorStyle( xControlModel );
+		pStyle->importTextLineColorStyle( xControlModel );
+		pStyle->importFontStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( 0, 0, _xAttributes ); // inherited from BulletinBoardElement
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("value-max") ),
+                            _xAttributes );
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+// #FIXME cut'n'pasted from xmloff/source/core/xmlimp.cxx:1251 
+// of course we need to find a common home for this helper
+
+bool IsPackageURL( const ::rtl::OUString& rURL )
+{
+    // Some quick tests: Some may rely on the package structure!
+    sal_Int32 nLen = rURL.getLength();
+    if( (nLen > 0 && '/' == rURL[0]) )
+        // RFC2396 net_path or abs_path
+        return false;
+    else if( nLen > 1 && '.' == rURL[0] )
+    {
+        if( '.' == rURL[1] )
+            // ../: We are never going up one level, so we know
+            // it's not an external URI
+            return false;
+        else if( '/' == rURL[1] )
+            // we are remaining on a level, so it's an package URI
+            return true;
+    }
+
+    // Now check for a RFC2396 schema
+    sal_Int32 nPos = 1;
+    while( nPos < nLen )
+    {
+        switch( rURL[nPos] )
+        {
+            case '/':
+                // a relative path segement
+                return true;
+            case ':':
+                // a schema
+                return false;
+            default:
+                break;
+                // we don't care about any other characters
+        }
+        ++nPos;
+    }
+
+    return true;
+}
+
+void importBindableAndListRangeBits( DialogImport* _pImport, const rtl::OUString sLinkedCell, const rtl::OUString & sCellRange, ControlImportContext& ctx )
+{
+    Reference< lang::XMultiServiceFactory > xFac( _pImport->getDocOwner(), UNO_QUERY );
+    if ( xFac.is() && ( sLinkedCell.getLength() ||  sCellRange.getLength() ) )
+    {
+        // Set up Celllink
+        if ( sLinkedCell.getLength() )
+        {
+            Reference< form::binding::XBindableValue > xBindable( ctx.getControlModel(), uno::UNO_QUERY );
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+            if ( xBindable.is() && xConvertor.is() )
+            {
+                table::CellAddress aAddress;
+                xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sLinkedCell ) );
+                xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+                beans::NamedValue aArg1;
+                aArg1.Name = OUSTR("BoundCell");
+                aArg1.Value <<= aAddress;
+           
+                uno::Sequence< uno::Any > aArgs(1);
+                aArgs[ 0 ]  <<= aArg1;
+           
+                uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+                xBindable->setValueBinding( xBinding );
+ 
+            }
+        }
+        // Set up CelllRange
+        if ( sCellRange.getLength() )
+        {
+           Reference< form::binding::XListEntrySink  > xListEntrySink( ctx.getControlModel(), uno::UNO_QUERY );
+           Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+           if ( xListEntrySink.is() && xConvertor.is() )
+           {
+               table::CellRangeAddress aAddress;
+               xConvertor->setPropertyValue( OUSTR( "PersistentRepresentation" ), uno::makeAny( sCellRange ) );
+               xConvertor->getPropertyValue( OUSTR( "Address" ) ) >>= aAddress;     
+               beans::NamedValue aArg1;
+               aArg1.Name = OUSTR("CellRange");
+               aArg1.Value <<= aAddress;
+           
+               uno::Sequence< uno::Any > aArgs(1);
+               aArgs[ 0 ]  <<= aArg1;
+           
+               uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( OUSTR("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+               xListEntrySink->setListEntrySource( xSource );
+ 
+           }
+       }
+   }
+}
+
+sal_Bool isVBACompatModeOn( DialogImport* _pImport )
+{
+	sal_Bool bVBAMode = sal_False;
+	Reference< script::XVBACompat > xVBACompat( _pImport->getScriptLibraryContainer(), UNO_QUERY );
+	if( xVBACompat.is() )
+	{
+		bVBAMode = xVBACompat->getVBACompatModeOn();
+	}
+	return bVBAMode;
+}
+
 // progessmeter
 //__________________________________________________________________________________________________
 Reference< xml::input::XElement > ProgressBarElement::startChildElement(
@@ -122,10 +300,24 @@
 void ScrollBarElement::endElement()
 	throw (xml::sax::SAXException, RuntimeException)
 {
+	OUString sService( OUSTR("com.sun.star.awt.UnoControlScrollBarModel") );
+	// we should probably limit this to vba mode also ( leave for now )
+	if ( isVBACompatModeOn( _pImport ) )
+		sService = OUSTR("com.sun.star.form.component.ScrollBar");
+
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
 	ControlImportContext ctx(
 		_pImport, getControlId( _xAttributes ),
-		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlScrollBarModel") ) );
-	
+		sService );	
+
 	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
 	if (xStyle.is())
 	{
@@ -168,6 +360,10 @@
                                OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
                                _xAttributes );
     
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+
 	ctx.importEvents( _events );
     // avoid ring-reference:
     // vector< event elements > holding event elements holding this (via _pParent)
@@ -176,6 +372,88 @@
 
 //##################################################################################################
 
+// spinbutton
+//__________________________________________________________________________________________________
+Reference< xml::input::XElement > SpinButtonElement::startChildElement(
+	sal_Int32 nUid, OUString const & rLocalName,
+	Reference< xml::input::XAttributes > const & xAttributes )
+	throw (xml::sax::SAXException, RuntimeException)
+{
+	// event
+    if (_pImport->isEventElement( nUid, rLocalName ))
+	{
+		return new EventElement( nUid, rLocalName, xAttributes, this, _pImport );
+	}
+	else
+	{
+		throw xml::sax::SAXException(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("expected event element!") ),
+			Reference< XInterface >(), Any() );
+	}
+}
+//__________________________________________________________________________________________________
+void SpinButtonElement::endElement()
+	throw (xml::sax::SAXException, RuntimeException)
+{
+    OUString sLinkedCell;
+    try
+    {
+        sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+    }
+    catch( Exception& /*e*/ )
+    {
+    }
+
+	ControlImportContext ctx(
+		_pImport, getControlId( _xAttributes ),
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.form.component.SpinButton") ) );
+	
+	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
+	if (xStyle.is())
+	{
+		StyleElement * pStyle = static_cast< StyleElement * >( xStyle.get () );
+		Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
+        pStyle->importBackgroundColorStyle( xControlModel );
+		pStyle->importBorderStyle( xControlModel );
+	}
+	
+	ctx.importDefaults( _nBasePosX, _nBasePosY, _xAttributes );
+	ctx.importOrientationProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                                   OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
+                                   _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("increment") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("curval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                            OUString( RTL_CONSTASCII_USTRINGPARAM("maxval") ),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("SpinValueMin"), OUSTR("minval"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("Repeat"), OUSTR("repeat"),
+                            _xAttributes );
+	ctx.importLongProperty( OUSTR("RepeatDelay"), OUSTR("repeat-delay"),
+                            _xAttributes );
+    ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
+                               _xAttributes );
+    ctx.importHexLongProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                               OUString( RTL_CONSTASCII_USTRINGPARAM("symbol-color") ),
+                               _xAttributes );
+    // import cell-link
+	OUString sCellRange;
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
+    
+	ctx.importEvents( _events );
+    // avoid ring-reference:
+    // vector< event elements > holding event elements holding this (via _pParent)
+    _events.clear();
+}
+
+//##################################################################################################
+
 // fixedline
 //__________________________________________________________________________________________________
 Reference< xml::input::XElement > FixedLineElement::startChildElement(
@@ -1003,9 +1281,37 @@
 	ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
 							   OUString( RTL_CONSTASCII_USTRINGPARAM("scale-image") ),
 							   _xAttributes );
-	ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-							  OUString( RTL_CONSTASCII_USTRINGPARAM("src") ),
-							  _xAttributes );
+    rtl::OUString sURL = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "src" ) );
+    Reference< document::XStorageBasedDocument > xDocStorage( _pImport->getDocOwner(), UNO_QUERY );
+
+    if ( xDocStorage.is() && IsPackageURL( sURL ) )
+    {
+        uno::Sequence< Any > aArgs( 1 );
+        aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+        ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+        uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+        aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicImportHelper" ), aArgs, xGraphicResolver );
+
+        if ( xGraphicResolver.is() )
+        {
+            rtl::OUString aTmp( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.Package:" ) );
+            aTmp += sURL;
+            sURL = xGraphicResolver->resolveGraphicObjectURL( aTmp );
+            Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+            // we must set the url while the graphic object ( held by the resolver is in scope )
+            if ( xProps.is() )
+                xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+        }
+    }
+    
+    else if ( sURL.getLength() > 0 )
+    {
+        Reference< beans::XPropertySet > xProps( ctx.getControlModel(), UNO_QUERY );
+        if ( xProps.is() )
+            xProps->setPropertyValue( OUSTR("ImageURL"), makeAny( sURL ) );
+    }
+
     ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                                OUString( RTL_CONSTASCII_USTRINGPARAM("tabstop") ),
                                _xAttributes );
@@ -1338,10 +1644,24 @@
 		Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
 		Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatModeOn( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
+
 		
 		ControlImportContext ctx(
 			_pImport, getControlId( xAttributes ),
-			OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
 		Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
 		
 		Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1377,6 +1697,9 @@
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
 		
 		sal_Int16 nVal = 0;
 		sal_Bool bChecked = sal_False;
@@ -1390,7 +1713,7 @@
 		}
 		xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
 										 makeAny( nVal ) );
-        
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
 		ctx.importEvents( *radioEvents );
@@ -1466,10 +1789,23 @@
 		Reference< xml::input::XElement > xRadio( _radios[ nPos ] );
 		Reference< xml::input::XAttributes > xAttributes(
             xRadio->getAttributes() );
+		OUString sLinkedCell;
+		OUString sCellRange;
+		OUString sService( OUSTR("com.sun.star.awt.UnoControlRadioButtonModel") );
+		try
+		{
+			sLinkedCell = xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+			// we should probably limit this to vba mode also ( leave for now )
+			if ( isVBACompatModeOn( _pImport ) )
+				sService = OUSTR("com.sun.star.form.component.RadioButton");
+		}
+		catch( Exception& /*e*/ )
+		{
+		}
 		
 		ControlImportContext ctx(
 			_pImport, getControlId( xAttributes ),
-			OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) );
+			sService );
 		Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
 		
 		Reference< xml::input::XElement > xStyle( getStyle( xAttributes ) );
@@ -1505,6 +1841,9 @@
         ctx.importBooleanProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                                    OUString( RTL_CONSTASCII_USTRINGPARAM("multiline") ),
                                    xAttributes );
+        ctx.importStringProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                                  OUString( RTL_CONSTASCII_USTRINGPARAM("group-name") ),
+                                  xAttributes );
 		sal_Int16 nVal = 0;
 		sal_Bool bChecked = sal_False;
 		if (getBoolAttr( &bChecked,
@@ -1518,6 +1857,7 @@
 		xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ),
 										 makeAny( nVal ) );
 		
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
         ::std::vector< Reference< xml::input::XElement > > * radioEvents =
             static_cast< RadioElement * >( xRadio.get() )->getEvents();
 		ctx.importEvents( *radioEvents );
@@ -1638,9 +1978,26 @@
 void MenuListElement::endElement()
 	throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sLinkedCell;
+        OUString sCellRange;
+        OUString sListBoxService( OUSTR("com.sun.star.awt.UnoControlListBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatModeOn( _pImport ) )
+            sListBoxService = OUSTR("com.sun.star.form.component.ListBox");
+
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
 	ControlImportContext ctx(
 		_pImport, getControlId( _xAttributes ),
-		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		//OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) );
+		sListBoxService );
 	Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
 	
 	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1673,13 +2030,16 @@
 	ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
-	
+        // import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
 	if (_popup.is())
 	{
 		MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
-		xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
+        if (  !sCellRange.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
 										 makeAny( p->getItemValues() ) );
-		xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
+        if (  !sLinkedCell.getLength() )
+		    xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") ),
 										 makeAny( p->getSelectedItems() ) );
 	}
 	ctx.importEvents( _events );
@@ -1725,9 +2085,26 @@
 void ComboBoxElement::endElement()
 	throw (xml::sax::SAXException, RuntimeException)
 {
+        OUString sService( OUSTR("com.sun.star.awt.UnoControlComboBoxModel") );
+
+        // we should probably limit this to vba mode also ( leave for now )
+        if ( isVBACompatModeOn( _pImport ) )
+            sService = OUSTR("com.sun.star.form.component.ComboBox");
+
+        OUString sLinkedCell;
+        OUString sCellRange;
+        try
+        {
+            sLinkedCell = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "linked-cell" ) );
+            sCellRange = _xAttributes->getValueByUidName( _pImport->XMLNS_DIALOGS_UID, OUSTR( "source-cell-range" ) );
+        }
+        catch( Exception& /*e*/ )
+        {
+        }
+
 	ControlImportContext ctx(
 		_pImport, getControlId( _xAttributes ),
-		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlComboBoxModel") ) );
+		sService );
 	Reference< beans::XPropertySet > xControlModel( ctx.getControlModel() );
 	
 	Reference< xml::input::XElement > xStyle( getStyle( _xAttributes ) );
@@ -1769,8 +2146,10 @@
 	ctx.importAlignProperty( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                              OUString( RTL_CONSTASCII_USTRINGPARAM("align") ),
                              _xAttributes );
+	// import cell-link and cell source range
+	importBindableAndListRangeBits( _pImport, sLinkedCell, sCellRange, ctx );
 	
-	if (_popup.is())
+	if (_popup.is() && !sCellRange.getLength() )
 	{
 		MenuPopupElement * p = static_cast< MenuPopupElement * >( _popup.get() );
 		xControlModel->setPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ),
@@ -2096,11 +2475,20 @@
 	{
 		return new ScrollBarElement( rLocalName, xAttributes, this, _pImport );
 	}
+	// spinbutton
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("spinbutton") ) && isVBACompatModeOn( _pImport ) )
+	{
+		return new SpinButtonElement( rLocalName, xAttributes, this, _pImport );
+	}
 	// progressmeter
 	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("progressmeter") ))
 	{
 		return new ProgressBarElement( rLocalName, xAttributes, this, _pImport );
 	}
+	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("multipage") ))
+	{
+		return new MultiPage( rLocalName, xAttributes, this, _pImport );
+	}
 	// bulletinboard
 	else if (rLocalName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM("bulletinboard") ))
 	{
Index: xmlscript/source/xmldlg_imexp/xmldlg_import.cxx
===================================================================
--- xmlscript/source/xmldlg_imexp/xmldlg_import.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/xmldlg_import.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -60,9 +60,13 @@
 #include <com/sun/star/script/ScriptEventDescriptor.hpp>
 
 #include <com/sun/star/view/SelectionType.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/script/DocumentScriptLibraryContainer.hpp>
+#include <com/sun/star/script/XVBACompat.hpp>
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 using ::rtl::OUString;
 
 namespace xmlscript
@@ -1891,18 +1895,44 @@
     }
     return 0;
 }
+//__________________________________________________________________________________________________
+Reference< script::XLibraryContainer > DialogImport::getScriptLibraryContainer()
+{
+	if( !_xScriptLibraryContainer.is() )
+	{
+		try
+		{
+			Reference< document::XStorageBasedDocument > xStorageDoc( _xDoc, UNO_QUERY );
+			if( xStorageDoc.is() )
+				_xScriptLibraryContainer.set(
+									script::DocumentScriptLibraryContainer::create( comphelper_getProcessComponentContext(), xStorageDoc ), 
+									UNO_QUERY );
+		}
+		catch( const Exception& )
+		{
+		}
+	}
 
+	return _xScriptLibraryContainer;
+}
+
 //##################################################################################################
 
 //==================================================================================================
 Reference< xml::sax::XDocumentHandler > SAL_CALL importDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
+    DialogImport* pImport = new DialogImport( xContext, xDialogModel, xDocument );
+    uno::Reference< script::XVBACompat > xVBAModeSource( pImport->getScriptLibraryContainer(), uno::UNO_QUERY );
+    
+    uno::Reference< beans::XPropertySet > xDlgProps( xDialogModel, uno::UNO_QUERY );
+    if ( xVBAModeSource.is() && xDlgProps.is() && xVBAModeSource->getVBACompatModeOn() )
+        xDlgProps->setPropertyValue( OUSTR("VBAForm"), uno::makeAny( sal_True ) );
     return ::xmlscript::createDocumentHandler(
-        static_cast< xml::input::XRoot * >(
-            new DialogImport( xContext, xDialogModel ) ) );
+        static_cast< xml::input::XRoot * >( pImport ) );
 }
 
 }
Index: xmlscript/source/xmldlg_imexp/exp_share.hxx
===================================================================
--- xmlscript/source/xmldlg_imexp/exp_share.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/exp_share.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -174,15 +174,17 @@
     //
     void readDialogModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
+    void readMultiPageModel( StyleBag * all_styles )
+        SAL_THROW( (css::uno::Exception) );
     void readButtonModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readEditModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
     void readCheckBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readRadioButtonModel( StyleBag * all_styles )
+    void readRadioButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
-    void readComboBoxModel( StyleBag * all_styles )
+    void readComboBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readCurrencyFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -196,9 +198,9 @@
         SAL_THROW( (css::uno::Exception) );
     void readGroupBoxModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readImageControlModel( StyleBag * all_styles )
+    void readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument  )
         SAL_THROW( (css::uno::Exception) );
-    void readListBoxModel( StyleBag * all_styles )
+    void readListBoxModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
     void readNumericFieldModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
@@ -212,8 +214,10 @@
         SAL_THROW( (css::uno::Exception) );
     void readProgressBarModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
-    void readScrollBarModel( StyleBag * all_styles )
+    void readScrollBarModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
         SAL_THROW( (css::uno::Exception) );
+    void readSpinButtonModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
+        SAL_THROW( (css::uno::Exception) );
 	void readFixedHyperLinkModel( StyleBag * all_styles )
         SAL_THROW( (css::uno::Exception) );
 };
Index: xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx
===================================================================
--- xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/xmldlg_expmodels.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,7 +32,16 @@
 #include "precompiled_xmlscript.hxx"
 #include "exp_share.hxx"
 
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
 #include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/document/XStorageBasedDocument.hpp>
+#include <com/sun/star/document/XGraphicObjectResolver.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <comphelper/processfactory.hxx>
 
 
 using namespace ::com::sun::star;
@@ -42,6 +51,66 @@
 namespace xmlscript
 {
 
+void lclExportBindableAndListSourceBits( Reference< frame::XModel > const & xDocument, const Reference< beans::XPropertySet >& _xProps, ElementDescriptor& rModel )
+{
+    Reference< lang::XMultiServiceFactory > xFac;
+    if ( xDocument.is() )
+        xFac.set( xDocument, uno::UNO_QUERY );
+
+    Reference< form::binding::XBindableValue > xBinding( _xProps, UNO_QUERY );
+
+    if ( xFac.is() && xBinding.is() )
+    {
+        try
+        {
+            Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );  
+        Reference< beans::XPropertySet > xBindable( xBinding->getValueBinding(), UNO_QUERY );
+            if ( xBindable.is() )
+            {
+                table::CellAddress aAddress; 
+                xBindable->getPropertyValue( OUSTR("BoundCell") ) >>= aAddress; 
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                rtl::OUString sAddress;
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                if ( sAddress.getLength() > 0 )
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":linked-cell"), sAddress );
+                
+                OSL_TRACE( "*** Bindable value %s", rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+               
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+    Reference< form::binding::XListEntrySink > xEntrySink( _xProps, UNO_QUERY );
+    if ( xEntrySink.is() )
+    {
+        Reference< beans::XPropertySet > xListSource( xEntrySink->getListEntrySource(), UNO_QUERY );
+        if ( xListSource.is() )
+        {
+            try
+            {
+                Reference< beans::XPropertySet > xConvertor( xFac->createInstance( OUSTR( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );  
+
+                table::CellRangeAddress aAddress; 
+                xListSource->getPropertyValue( OUSTR( "CellRange" ) ) >>= aAddress;
+
+                rtl::OUString sAddress;
+                xConvertor->setPropertyValue( OUSTR("Address"), makeAny( aAddress ) );
+                xConvertor->getPropertyValue( OUSTR("PersistentRepresentation") ) >>= sAddress;
+                OSL_TRACE("**** cell range source list %s",
+                    rtl::OUStringToOString( sAddress, RTL_TEXTENCODING_UTF8 ).getStr() ); 
+                if ( sAddress.getLength() > 0 );
+                    rModel.addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":source-cell-range"), sAddress );
+            }
+            catch( uno::Exception& )
+            {
+            }
+        }
+    }
+
+}
 static inline bool readBorderProps(
     ElementDescriptor * element, Style & style )
 {
@@ -68,6 +137,42 @@
 }
 
 //__________________________________________________________________________________________________
+void ElementDescriptor::readMultiPageModel( StyleBag * all_styles )
+{
+    // collect styles
+    Style aStyle( 0x2 | 0x8 | 0x20 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextColor") ) ) >>= aStyle._textColor)
+        aStyle._set |= 0x2;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("TextLineColor") ) ) >>= aStyle._textLineColor)
+        aStyle._set |= 0x20;
+    if (readFontProps( this, aStyle ))
+        aStyle._set |= 0x8;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+
+    // collect elements
+    readDefaults();
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value-max") ) );
+
+    OUString aTitle;
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("Label") ) ) >>= aTitle)
+    {
+        ElementDescriptor * title = new ElementDescriptor(
+            _xProps, _xPropState,
+            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":title") ) );
+        title->addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":value") ),
+                             aTitle );
+        addSubElement( title );
+    }
+
+    readEvents();
+}
 void ElementDescriptor::readButtonModel( StyleBag * all_styles )
     SAL_THROW( (Exception) )
 {
@@ -209,7 +314,7 @@
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readComboBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readComboBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -250,7 +355,8 @@
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxlength") ) );
     readShortAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("LineCount") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
-
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -276,7 +382,7 @@
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readListBoxModel( StyleBag * all_styles )
+void ElementDescriptor::readListBoxModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -311,7 +417,7 @@
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":linecount") ) );
     readAlignAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Align") ),
                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );
-
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     // string item list
     Sequence< OUString > itemValues;
     if ((readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("StringItemList") ) ) >>= itemValues) &&
@@ -351,7 +457,7 @@
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles )
+void ElementDescriptor::readRadioButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -388,6 +494,8 @@
                            OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":image-position") ) );
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("MultiLine") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multiline") ) );
+    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("GroupName") ),
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":group-name") ) );
 
     sal_Int16 nState = 0;
     if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("State") ) ) >>= nState)
@@ -407,6 +515,7 @@
             break;
         }
     }
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
@@ -579,7 +688,7 @@
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readImageControlModel( StyleBag * all_styles )
+void ElementDescriptor::readImageControlModel( StyleBag * all_styles, com::sun::star::uno::Reference< com::sun::star::frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -598,8 +707,31 @@
     readDefaults();
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ScaleImage") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scale-image") ) );
-    readStringAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("ImageURL") ),
-                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":src") ) );
+    rtl::OUString sURL;
+    _xProps->getPropertyValue( OUSTR("ImageURL") ) >>= sURL;
+    
+    if ( sURL.indexOf( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.GraphicObject:"  ) ) ) == 0 )
+    {
+        Reference< document::XStorageBasedDocument > xDocStorage( xDocument, UNO_QUERY );
+
+        if ( xDocStorage.is() )
+        {
+            uno::Sequence< Any > aArgs( 1 );
+            aArgs[ 0 ] <<= xDocStorage->getDocumentStorage();
+
+            ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+            uno::Reference< document::XGraphicObjectResolver > xGraphicResolver;
+            aContext.createComponentWithArguments( OUSTR( "com.sun.star.comp.Svx.GraphicExportHelper" ), aArgs, xGraphicResolver );
+            if ( xGraphicResolver.is() )
+            {
+                sURL = xGraphicResolver->resolveGraphicObjectURL( sURL );
+            }
+        }     
+    }
+    if ( sURL.getLength() > 0 )
+    {
+        addAttribute( OUSTR(XMLNS_DIALOGS_PREFIX ":src"), sURL );
+    }
     readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
     readEvents();
@@ -1074,7 +1206,7 @@
     readEvents();
 }
 //__________________________________________________________________________________________________
-void ElementDescriptor::readScrollBarModel( StyleBag * all_styles )
+void ElementDescriptor::readScrollBarModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
     SAL_THROW( (Exception) )
 {
     // collect styles
@@ -1112,9 +1244,50 @@
                   OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":live-scroll") ) );
     readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
                      OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
     readEvents();
 }
 //__________________________________________________________________________________________________
+void ElementDescriptor::readSpinButtonModel( StyleBag * all_styles, Reference< frame::XModel > const & xDocument  )
+    SAL_THROW( (Exception) )
+{
+    // collect styles
+    Style aStyle( 0x1 | 0x4 );
+    if (readProp( OUString( RTL_CONSTASCII_USTRINGPARAM("BackgroundColor") ) ) >>= aStyle._backgroundColor)
+        aStyle._set |= 0x1;
+    if (readBorderProps( this, aStyle ))
+        aStyle._set |= 0x4;
+    if (aStyle._set)
+    {
+        addAttribute( OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":style-id") ),
+                      all_styles->getStyleId( aStyle ) );
+    }
+    
+    // collect elements
+    readDefaults();
+    readOrientationAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Orientation") ),
+                         OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":align") ) );  
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinIncrement") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":increment") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValue") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":curval") ) );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":maxval") ) );
+    readLongAttr( OUSTR("SpinValueMin"),
+                  OUSTR(XMLNS_DIALOGS_PREFIX ":minval") );
+    readLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Repeat") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":repeat") ) );
+    readLongAttr( OUSTR("RepeatDelay"), OUSTR(XMLNS_DIALOGS_PREFIX ":repeat-delay") );
+    readBoolAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("Tabstop") ),
+                  OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":tabstop") ) );
+    readHexLongAttr( OUString( RTL_CONSTASCII_USTRINGPARAM("SymbolColor") ),
+                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":symbol-color") ) );
+    // Cell Range, Ref Cell etc.
+    lclExportBindableAndListSourceBits( xDocument, _xProps, *this );
+    readEvents();
+}
+//__________________________________________________________________________________________________
 void ElementDescriptor::readDialogModel( StyleBag * all_styles )
     SAL_THROW( (Exception) )
 {
Index: xmlscript/source/xmldlg_imexp/xmldlg_export.cxx
===================================================================
--- xmlscript/source/xmldlg_imexp/xmldlg_export.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/xmldlg_export.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1328,7 +1328,8 @@
 //==================================================================================================
 void SAL_CALL exportDialogModel(
     Reference< xml::sax::XExtendedDocumentHandler > const & xOut,
-    Reference< container::XNameContainer > const & xDialogModel )
+    Reference< container::XNameContainer > const & xDialogModel,
+    Reference< frame::XModel > const & xDocument )
     SAL_THROW( (Exception) )
 {
     StyleBag all_styles;
@@ -1376,7 +1377,7 @@
                 xProps, xPropState,
                 OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":radio") ) );
             xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-            pElem->readRadioButtonModel( &all_styles );
+            pElem->readRadioButtonModel( &all_styles, xDocument  );
             pRadioGroup->addSubElement( xElem );
         }
         else // no radio
@@ -1405,7 +1406,7 @@
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":combobox") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readComboBoxModel( &all_styles );
+                pElem->readComboBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) ) )
             {
@@ -1413,7 +1414,7 @@
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":menulist") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readListBoxModel( &all_styles );
+                pElem->readListBoxModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) ) )
             {
@@ -1423,6 +1424,14 @@
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
                 pElem->readGroupBoxModel( &all_styles );
             }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":multipage") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readMultiPageModel( &all_styles );
+            }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFixedTextModel") ) ) )
             {
                 pElem = new ElementDescriptor(
@@ -1454,7 +1463,7 @@
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":img") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readImageControlModel( &all_styles );
+                pElem->readImageControlModel( &all_styles, xDocument );
             }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFileControlModel") ) ) )
             {
@@ -1534,8 +1543,16 @@
                     xProps, xPropState,
                     OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":scrollbar") ) );
                 xElem = static_cast< xml::sax::XAttributeList * >( pElem );
-                pElem->readScrollBarModel( &all_styles );
+                pElem->readScrollBarModel( &all_styles, xDocument );
             }
+            else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlSpinButtonModel") ) ) )
+            {
+                pElem = new ElementDescriptor(
+                    xProps, xPropState,
+                    OUString( RTL_CONSTASCII_USTRINGPARAM(XMLNS_DIALOGS_PREFIX ":spinbutton") ) );
+                xElem = static_cast< xml::sax::XAttributeList * >( pElem );
+                pElem->readSpinButtonModel( &all_styles, xDocument );
+            }
             else if (xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlProgressBarModel") ) ) )
             {
                 pElem = new ElementDescriptor(
Index: xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx
===================================================================
--- xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/xmldlg_addfunc.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,6 +44,7 @@
 using namespace ::rtl;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::frame;
 
 namespace xmlscript
 {
@@ -73,7 +74,8 @@
 //==================================================================================================
 Reference< io::XInputStreamProvider > SAL_CALL exportDialogModel(
     Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
 	SAL_THROW( (Exception) )
 {
 	Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -98,7 +100,7 @@
 	
 	Reference< io::XActiveDataSource > xSource( xHandler, UNO_QUERY );
 	xSource->setOutputStream( createOutputStream( &aBytes ) );
-	exportDialogModel( xHandler, xDialogModel );
+	exportDialogModel( xHandler, xDialogModel, xDocument );
 	
 	return new InputStreamProvider( aBytes );
 }
@@ -107,7 +109,8 @@
 void SAL_CALL importDialogModel(
 	Reference< io::XInputStream > xInput,
 	Reference< container::XNameContainer > const & xDialogModel,
-    Reference< XComponentContext > const & xContext )
+    Reference< XComponentContext > const & xContext,
+    Reference< XModel > const & xDocument )
 	SAL_THROW( (Exception) )
 {
 	Reference< lang::XMultiComponentFactory > xSMgr( xContext->getServiceManager() );
@@ -129,7 +132,7 @@
 	}
 	
 	// error handler, entity resolver omitted for this helper function
-	xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext ) );
+	xParser->setDocumentHandler( importDialogModel( xDialogModel, xContext, xDocument ) );
 	
 	xml::sax::InputSource source;
 	source.aInputStream = xInput;
Index: xmlscript/source/xmldlg_imexp/imp_share.hxx
===================================================================
--- xmlscript/source/xmldlg_imexp/imp_share.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/source/xmldlg_imexp/imp_share.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,7 @@
 #include <com/sun/star/awt/FontEmphasisMark.hpp>
 #include <com/sun/star/awt/FontRelief.hpp>
 #include <com/sun/star/xml/input/XRoot.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
 #include <vector>
 
 
@@ -131,6 +132,8 @@
     
     css::uno::Reference< css::container::XNameContainer > _xDialogModel;
     css::uno::Reference< css::lang::XMultiServiceFactory > _xDialogModelFactory;
+    css::uno::Reference< css::frame::XModel > _xDoc;
+    css::uno::Reference< css::script::XLibraryContainer > _xScriptLibraryContainer;
 
     sal_Int32 XMLNS_DIALOGS_UID, XMLNS_SCRIPT_UID;
     
@@ -164,16 +167,20 @@
     inline DialogImport(
         css::uno::Reference<css::uno::XComponentContext> const & xContext,
         css::uno::Reference<css::container::XNameContainer>
-        const & xDialogModel )
+        const & xDialogModel,
+        css::uno::Reference<css::frame::XModel> const & xDoc )
         SAL_THROW( () )
         : _xContext( xContext )
         , _xDialogModel( xDialogModel )
-        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW )
+        , _xDialogModelFactory( xDialogModel, css::uno::UNO_QUERY_THROW ), _xDoc( xDoc )
         { OSL_ASSERT( _xDialogModel.is() && _xDialogModelFactory.is() &&
                       _xContext.is() ); }
     virtual ~DialogImport()
         SAL_THROW( () );
     
+    inline css::uno::Reference< css::frame::XModel > getDocOwner() { return _xDoc; }
+
+	css::uno::Reference< css::script::XLibraryContainer > getScriptLibraryContainer();
     // XRoot
     virtual void SAL_CALL startDocument(
         css::uno::Reference< css::xml::input::XNamespaceMapping >
@@ -999,6 +1006,49 @@
 };
 
 //==============================================================================
+class SpinButtonElement
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline SpinButtonElement(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
+//==============================================================================
+class MultiPage
+    : public ControlElement
+{
+public:
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes> const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    
+    inline MultiPage(
+        ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, DialogImport * pImport )
+        SAL_THROW( () )
+        : ControlElement( rLocalName, xAttributes, pParent, pImport )
+        {}
+};
+
 class ProgressBarElement
     : public ControlElement
 {
Index: xmlscript/inc/xmlscript/xmldlg_imexp.hxx
===================================================================
--- xmlscript/inc/xmlscript/xmldlg_imexp.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/inc/xmlscript/xmldlg_imexp.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -30,6 +30,8 @@
 #ifndef _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 #define _XMLSCRIPT_XMLDLG_IMEXP_HXX_
 
+#include <com/sun/star/frame/XModel.hpp>
+
 #ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HXX_
 #include <com/sun/star/container/XNameContainer.hpp>
 #endif
@@ -54,7 +56,9 @@
 	::com::sun::star::uno::Reference<
     ::com::sun::star::xml::sax::XExtendedDocumentHandler > const & xOut,
 	::com::sun::star::uno::Reference<
-    ::com::sun::star::container::XNameContainer > const & xDialogModel )
+    ::com::sun::star::container::XNameContainer > const & xDialogModel, 
+	::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
 	SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -63,7 +67,9 @@
 	::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
 	SAL_THROW( (::com::sun::star::uno::Exception) );
 
 // additional functions for convenience
@@ -74,7 +80,9 @@
 	::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
 	SAL_THROW( (::com::sun::star::uno::Exception) );
 
 //==============================================================================
@@ -84,7 +92,9 @@
 	::com::sun::star::uno::Reference<
     ::com::sun::star::container::XNameContainer > const & xDialogModel,
     ::com::sun::star::uno::Reference<
-    ::com::sun::star::uno::XComponentContext > const & xContext )
+    ::com::sun::star::uno::XComponentContext > const & xContext,
+    ::com::sun::star::uno::Reference<
+    ::com::sun::star::frame::XModel > const & xDocument )
 	SAL_THROW( (::com::sun::star::uno::Exception) );
 
 }
Index: xmlscript/util/makefile.mk
===================================================================
--- xmlscript/util/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ xmlscript/util/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -58,6 +58,7 @@
 		$(LIB1TARGET)
 
 SHL1STDLIBS= \
+		$(COMPHELPERLIB)                \
 		$(CPPUHELPERLIB)		\
 		$(CPPULIB) 			\
 		$(SALLIB)
Index: xmlscript/util/makefile.mk.patched
===================================================================
--- xmlscript/util/makefile.mk.patched	(.../tags/DEV300_m58)	(revision 0)
+++ xmlscript/util/makefile.mk.patched	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,81 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.12 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+PRJ=..
+
+PRJNAME=xmlscript
+TARGET=xcr
+NO_BSYMBOLIC=TRUE
+#USE_DEFFILE=TRUE
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+#-------------------------------------------------------------------
+
+LIB1TARGET=	$(SLB)$/$(TARGET).lib
+
+LIB1FILES= \
+		$(SLB)$/xml_helper.lib		\
+		$(SLB)$/xmldlg_imexp.lib	\
+		$(SLB)$/xmllib_imexp.lib	\
+		$(SLB)$/xmlmod_imexp.lib	\
+		$(SLB)$/xmlflat_imexp.lib	\
+		$(SLB)$/misc.lib
+
+SHL1TARGET=$(TARGET)$(DLLPOSTFIX)
+
+SHL1LIBS= \
+		$(LIB1TARGET)
+
+SHL1STDLIBS= \
+		$(COMPHELPERLIB)                \
+		$(CPPUHELPERLIB)		\
+		$(CPPULIB) 			\
+		$(SALLIB)
+
+SHL1DEPN=
+SHL1IMPLIB=	i$(TARGET)
+SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
+
+DEF1NAME=	$(SHL1TARGET)
+DEFLIB1NAME=	$(TARGET)
+DEF1DEPN=	$(MISC)$/$(SHL1TARGET).flt
+
+# --- Targets -------------------------------------------------------
+
+.INCLUDE :	target.mk
+
+$(MISC)$/$(SHL1TARGET).flt : makefile.mk xcr.flt
+	@echo ------------------------------
+	@echo Making: $@
+	$(TYPE) xcr.flt > $@
Index: vbahelper/source/msforms/vbacheckbox.cxx
===================================================================
--- vbahelper/source/msforms/vbacheckbox.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacheckbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacheckbox.hxx"
+#include <vbahelper/helperdecl.hxx>
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
+ScVbaCheckbox::ScVbaCheckbox( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : CheckBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaCheckbox::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaCheckbox::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaCheckbox::getValue() throw (css::uno::RuntimeException)
+{
+    sal_Int16 nValue = -1;
+    m_xProps->getPropertyValue( STATE ) >>= nValue;
+    if( nValue != 0 )
+        nValue = -1;
+//    return uno::makeAny( nValue ); 
+// I must be missing something MSO says value should be -1 if selected, 0 if not
+// selected
+    return uno::makeAny( ( nValue == -1 ) ? sal_True : sal_False ); 
+}
+
+void SAL_CALL 
+ScVbaCheckbox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeException)
+{
+    sal_Int16 nValue = 0;
+    sal_Bool bValue = false;
+    if( _value >>= nValue )
+    {
+        if( nValue == -1)
+            nValue = 1;
+    }
+    else if ( _value >>= bValue )
+    {
+        if ( bValue )
+            nValue = 1;
+    }
+    m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
+}
+rtl::OUString& 
+ScVbaCheckbox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCheckbox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaCheckbox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.CheckBox" ) );
+	}
+	return aServiceNames;
+}
+
Index: vbahelper/source/msforms/vbascrollbar.hxx
===================================================================
--- vbahelper/source/msforms/vbascrollbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbascrollbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SCROLLBAR_HXX
+#define SC_VBA_SCROLLBAR_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XScrollBar.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XScrollBar > ScrollBarImpl_BASE;
+
+class ScVbaScrollBar : public ScrollBarImpl_BASE
+{
+public:
+    ScVbaScrollBar( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMax() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMax( ::sal_Int32 _max ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMin() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMin( ::sal_Int32 _min ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getLargeChange() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLargeChange( ::sal_Int32 _largechange ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getSmallChange() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSmallChange( ::sal_Int32 _smallchange ) throw (css::uno::RuntimeException);
+
+
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_LABEL_HXX
Index: vbahelper/source/msforms/vbaprogressbar.cxx
===================================================================
--- vbahelper/source/msforms/vbaprogressbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaprogressbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaprogressbar.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+// uno servicename com.sun.star.awt.UnoControlProgressBarMode
+const rtl::OUString SVALUE( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") );
+
+ScVbaProgressBar::ScVbaProgressBar( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ProgressBarImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+uno::Any SAL_CALL 
+ScVbaProgressBar::getValue() throw (css::uno::RuntimeException)
+{
+    return m_xProps->getPropertyValue( SVALUE );
+}
+
+void SAL_CALL 
+ScVbaProgressBar::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SVALUE,  _value );
+}
+
+rtl::OUString& 
+ScVbaProgressBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaProgressBar") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaProgressBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Label" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbaframe.cxx
===================================================================
--- vbahelper/source/msforms/vbaframe.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaframe.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaframe.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+ScVbaFrame::ScVbaFrame( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : FrameImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaFrame::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaFrame::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaFrame::getValue() throw (css::uno::RuntimeException)
+{
+    return uno::makeAny( getCaption() );
+}
+
+void SAL_CALL 
+ScVbaFrame::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    rtl::OUString sCaption;
+    _value >>= sCaption;
+    setCaption( sCaption ); 
+}
+//liuchen 2009-7-6 
+::sal_Int32 SAL_CALL ScVbaFrame::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	return 0;
+}
+
+void SAL_CALL ScVbaFrame::setForeColor( ::sal_Int32 /*_forecolor*/ ) throw (::com::sun::star::uno::RuntimeException)
+{
+	return;
+}
+//liuchen 2009-7-6 end
+
+rtl::OUString& 
+ScVbaFrame::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFrame") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaFrame::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbacheckbox.hxx
===================================================================
--- vbahelper/source/msforms/vbacheckbox.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacheckbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CHECKBOX_HXX
+#define SC_VBA_CHECKBOX_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <ooo/vba/msforms/XRadioButton.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > CheckBoxImpl_BASE;
+
+class ScVbaCheckbox : public CheckBoxImpl_BASE
+{
+public:
+    ScVbaCheckbox(  const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+   // Attributes
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //SC_VBA_CHECKBOX_HXX
Index: vbahelper/source/msforms/vbaprogressbar.hxx
===================================================================
--- vbahelper/source/msforms/vbaprogressbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaprogressbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PROGRESSBAR_HXX
+#define SC_VBA_PROGRESSBAR_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XProgressBar.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XProgressBar, css::script::XDefaultProperty  > ProgressBarImpl_BASE;
+
+class ScVbaProgressBar : public ProgressBarImpl_BASE
+{
+public:
+    ScVbaProgressBar( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+#endif //SC_VBA_LABEL_HXX
Index: vbahelper/source/msforms/vbaframe.hxx
===================================================================
--- vbahelper/source/msforms/vbaframe.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaframe.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_FRAME_HXX
+#define SC_VBA_FRAME_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XLabel.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XLabel > FrameImpl_BASE;
+
+class ScVbaFrame : public FrameImpl_BASE
+{
+public:
+    ScVbaFrame(  const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	//liuchen 2009-7-6 
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
+	//liuchen 2009-7-6 end
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_LABEL_HXX
Index: vbahelper/source/msforms/vbacontrols.cxx
===================================================================
--- vbahelper/source/msforms/vbacontrols.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacontrols.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,232 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "vbacontrols.hxx"
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/awt/XControlContainer.hpp>
+#include <ooo/vba//XControlProvider.hpp>
+#include <hash_map>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper2< container::XNameAccess, container::XIndexAccess > ArrayWrapImpl;
+
+typedef  std::hash_map< rtl::OUString, sal_Int32, ::rtl::OUStringHash,
+    ::std::equal_to< ::rtl::OUString >  > ControlIndexMap;
+typedef  std::vector< uno::Reference< awt::XControl > > ControlVec;
+
+class ControlArrayWrapper : public ArrayWrapImpl
+{
+    uno::Reference< awt::XControlContainer > mxDialog;
+    uno::Sequence< ::rtl::OUString > msNames;
+    ControlVec mControls;
+    ControlIndexMap mIndices;
+
+    rtl::OUString getControlName( const uno::Reference< awt::XControl >& xCtrl )
+    {
+        uno::Reference< beans::XPropertySet > xProp( xCtrl->getModel(), uno::UNO_QUERY );
+        rtl::OUString sName;
+        xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ) ) >>= sName;
+        return sName;
+    }
+
+public:
+
+    ControlArrayWrapper( const uno::Reference< awt::XControl >& xDialog )
+    {
+        mxDialog.set( xDialog, uno::UNO_QUERY_THROW );
+        uno::Sequence< uno::Reference< awt::XControl > > sXControls = mxDialog->getControls();
+    
+        msNames.realloc( sXControls.getLength() );
+        for ( sal_Int32 i = 0; i < sXControls.getLength(); ++i )
+        {
+            uno::Reference< awt::XControl > xCtrl = sXControls[ i ];
+            msNames[ i ] = getControlName( xCtrl );
+            mControls.push_back( xCtrl );
+            mIndices[ msNames[ i ] ] = i;
+        }
+    }
+    
+    // XElementAccess
+    virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+    {
+        return awt::XControl::static_type(0);
+    }
+    
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
+    {
+        return ( mControls.size() > 0 );
+    }
+    
+    // XNameAcess 
+    virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( !hasByName( aName ) )
+            throw container::NoSuchElementException();
+        return getByIndex( mIndices[ aName ] );
+    }
+    
+    virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException)
+    {
+        return msNames;
+    }
+    
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException)
+    {
+        ControlIndexMap::iterator it = mIndices.find( aName );
+        return it != mIndices.end();
+    }
+    
+    // XElementAccess
+    virtual ::sal_Int32 SAL_CALL getCount(  ) throw (css::uno::RuntimeException)
+    {
+        return mControls.size();
+    }
+    
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        if ( Index < 0 || Index >= static_cast< sal_Int32 >( mControls.size() ) )
+            throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( mControls[ Index ] );
+    }
+};
+
+
+class ControlsEnumWrapper : public EnumerationHelper_BASE
+{
+    uno::Reference<XHelperInterface > m_xParent;
+    uno::Reference<uno::XComponentContext > m_xContext;
+    uno::Reference<container::XIndexAccess > m_xIndexAccess;
+    uno::Reference<awt::XControl > m_xDlg;
+    sal_Int32 nIndex;
+
+public:
+
+    ControlsEnumWrapper(  const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess, const uno::Reference< awt::XControl >& xDlg ) :  m_xParent( xParent ), m_xContext( xContext), m_xIndexAccess( xIndexAccess ), m_xDlg( xDlg ), nIndex( 0 ) {}
+
+    virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+    {
+        return ( nIndex < m_xIndexAccess->getCount() );
+    }
+
+    virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+        if ( nIndex < m_xIndexAccess->getCount() )
+        {
+            uno::Reference< frame::XModel > xModel;
+            uno::Reference< awt::XControl > xControl;
+            m_xIndexAccess->getByIndex( nIndex++ ) >>= xControl;
+
+	uno::Reference<lang::XMultiComponentFactory > xServiceManager( m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+	uno::Reference< XControlProvider > xControlProvider( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.ControlProvider" ) ), m_xContext ), uno::UNO_QUERY_THROW );
+
+	uno::Reference< msforms::XControl > xVBAControl( xControlProvider->createUserformControl(  xControl, m_xDlg, xModel ) );
+            return uno::makeAny( xVBAControl );
+        }
+        throw container::NoSuchElementException();
+    }
+
+};
+
+
+uno::Reference<container::XIndexAccess >
+lcl_controlsWrapper( const uno::Reference< awt::XControl >& xDlg )
+{
+    return new ControlArrayWrapper( xDlg );
+}
+
+ScVbaControls::ScVbaControls( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext,
+                const css::uno::Reference< awt::XControl >& xDialog )
+            : ControlsImpl_BASE( xParent, xContext, lcl_controlsWrapper( xDialog  ) )
+{
+    mxDialog.set( xDialog, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaControls::createEnumeration() throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumeration > xEnum( new ControlsEnumWrapper( mxParent, mxContext, m_xIndexAccess, mxDialog ) );
+    if ( !xEnum.is() )
+        throw uno::RuntimeException();
+    return xEnum;
+}
+
+uno::Any
+ScVbaControls::createCollectionObject( const css::uno::Any& aSource )
+{
+    // Create control from awt::XControl
+    uno::Reference< awt::XControl > xControl;
+    aSource >>= xControl;
+    uno::Reference< frame::XModel > xModel;
+    uno::Reference<lang::XMultiComponentFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+    uno::Reference< XControlProvider > xControlProvider( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.ControlProvider" ) ), mxContext ), uno::UNO_QUERY_THROW );
+
+    uno::Reference< msforms::XControl > xVBAControl( xControlProvider->createUserformControl(  xControl, mxDialog, xModel ) );
+
+    return uno::makeAny( xVBAControl );
+}
+
+void SAL_CALL 
+ScVbaControls::Move( double cx, double cy ) throw (uno::RuntimeException)
+{
+    uno::Reference< container::XEnumeration > xEnum( createEnumeration() );
+    while ( xEnum->hasMoreElements() )
+    {
+        uno::Reference< msforms::XControl > xControl( xEnum->nextElement(), uno::UNO_QUERY_THROW );
+        xControl->setLeft( xControl->getLeft() + cx );
+        xControl->setTop( xControl->getTop() + cy ); 
+    }
+}
+
+uno::Type
+ScVbaControls::getElementType() throw (uno::RuntimeException)
+{
+    return ooo::vba::msforms::XControl::static_type(0);
+}
+rtl::OUString& 
+ScVbaControls::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaControls") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaControls::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Controls" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbacombobox.cxx
===================================================================
--- vbahelper/source/msforms/vbacombobox.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacombobox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,183 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacombobox.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbacombobox.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+//SelectedItems list of integer indexes
+//StringItemList list of items
+
+const static rtl::OUString TEXT( RTL_CONSTASCII_USTRINGPARAM("Text") );
+const static rtl::OUString SELECTEDITEMS( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") );
+const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
+const static rtl::OUString CONTROLSOURCEPROP( RTL_CONSTASCII_USTRINGPARAM("DataFieldProperty") );
+
+ScVbaComboBox::ScVbaComboBox( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, bool bDialogType ) : ComboBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper ), mbDialogType( bDialogType )
+{
+    	mpListHelper.reset( new ListControlHelper( m_xProps ) );
+	// grab the default value property name
+	m_xProps->getPropertyValue( CONTROLSOURCEPROP ) >>= sSourceName;
+}
+
+// Attributes
+
+
+// Value, [read] e.g. getValue returns the value of ooo Text propery e.g. the value in
+// the drop down
+uno::Any SAL_CALL 
+ScVbaComboBox::getValue() throw (uno::RuntimeException)
+{
+	return m_xProps->getPropertyValue( sSourceName );
+}
+
+void SAL_CALL 
+ScVbaComboBox::setListIndex( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+    sal_Int16 nIndex = 0;
+    if( _value >>= nIndex )
+    {
+	    uno::Sequence< rtl::OUString > sItems;
+    	m_xProps->getPropertyValue( ITEMS ) >>= sItems;
+        if( ( nIndex >= 0 ) && ( sItems.getLength() > nIndex ) )
+        {
+            rtl::OUString sText = sItems[ nIndex ];
+            m_xProps->setPropertyValue( TEXT, uno::makeAny( sText ) );
+        }
+    }
+}
+
+uno::Any SAL_CALL 
+ScVbaComboBox::getListIndex() throw (uno::RuntimeException)
+{
+	uno::Sequence< rtl::OUString > sItems;
+	m_xProps->getPropertyValue( ITEMS ) >>= sItems;
+	// should really return the item that has focus regardless of
+	// it been selected
+	if ( sItems.getLength() > 0 )
+	{
+		rtl::OUString sText = getText();
+		sal_Int32 nLen = sItems.getLength();
+		for ( sal_Int32 index = 0; sText.getLength() && index < nLen; ++index )
+		{
+			if ( sItems[ index ].equals( sText ) )
+			{
+				OSL_TRACE("getListIndex returning %d", index );
+				return uno::makeAny( index );
+			}
+				
+		} 
+ 	} 
+	OSL_TRACE("getListIndex returning %d", -1 );
+	return uno::makeAny( sal_Int32( -1 ) );
+}
+
+// Value, [write]e.g. setValue sets the value in the drop down, and if the value is one
+// of the values in the list then the selection is also set
+void SAL_CALL 
+ScVbaComboBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+	m_xProps->setPropertyValue( sSourceName, _value );
+}
+
+// see Value
+
+::rtl::OUString SAL_CALL 
+ScVbaComboBox::getText() throw (uno::RuntimeException)
+{
+	rtl::OUString result;
+	getValue() >>= result;
+	return result;
+}
+
+void SAL_CALL 
+ScVbaComboBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
+{
+	setValue( uno::makeAny( _text ) ); // seems the same
+}
+
+// Methods
+void SAL_CALL 
+ScVbaComboBox::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
+{
+	mpListHelper->AddItem( pvargItem, pvargIndex );
+}
+
+void SAL_CALL 
+ScVbaComboBox::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
+	{
+	mpListHelper->removeItem( index );
+}
+
+void SAL_CALL 
+ScVbaComboBox::Clear(  ) throw (uno::RuntimeException)
+		{
+	mpListHelper->Clear();
+		}
+
+void SAL_CALL
+ScVbaComboBox::setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException)
+{
+	ScVbaControl::setRowSource( _rowsource );
+	mpListHelper->setRowSource( _rowsource );
+		}
+
+sal_Int32 SAL_CALL
+ScVbaComboBox::getListCount() throw (uno::RuntimeException)
+{
+	return mpListHelper->getListCount();
+}
+		
+uno::Any SAL_CALL 
+ScVbaComboBox::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
+{
+	return mpListHelper->List( pvargIndex, pvarColumn );
+	}
+
+rtl::OUString& 
+ScVbaComboBox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaComboBox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaComboBox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ComboBox" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbacontrols.hxx
===================================================================
--- vbahelper/source/msforms/vbacontrols.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacontrols.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CONTROLS_HXX
+#define SC_VBA_CONTROLS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XControls.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <vbahelper/vbahelper.hxx>
+
+typedef CollTestImplHelper< ov::msforms::XControls > ControlsImpl_BASE;
+
+class ScVbaControls : public ControlsImpl_BASE
+{
+	css::uno::Reference< css::awt::XControl > mxDialog;
+protected:
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+public:
+    ScVbaControls( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+                    const css::uno::Reference< css::awt::XControl >& xDialog );
+    // XControls
+     virtual void SAL_CALL Move( double cx, double cy ) throw (css::uno::RuntimeException);
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+    // ScVbaCollectionBaseImpl
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+    
+};
+#endif //SC_VBA_OLEOBJECTS_HXX
+
Index: vbahelper/source/msforms/vbalistcontrolhelper.cxx
===================================================================
--- vbahelper/source/msforms/vbalistcontrolhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalistcontrolhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,146 @@
+#include <vbalistcontrolhelper.hxx>
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
+
+void SAL_CALL 
+ListControlHelper::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
+{
+	if ( pvargItem.hasValue()  )
+	{
+		uno::Sequence< rtl::OUString > sList;
+		m_xProps->getPropertyValue( ITEMS ) >>= sList;
+
+		sal_Int32 nIndex = sList.getLength();
+
+		if ( pvargIndex.hasValue() )
+			pvargIndex >>= nIndex;
+
+		rtl::OUString sString = getAnyAsString( pvargItem );
+
+		// if no index specified or item is to be appended to end of 
+		// list just realloc the array and set the last item
+		if ( nIndex  == sList.getLength() )
+		{
+			sal_Int32 nOldSize = sList.getLength();
+			sList.realloc( nOldSize + 1 );
+			sList[ nOldSize ] = sString; 
+		}
+		else
+		{
+			// just copy those elements above the one to be inserted
+			std::vector< rtl::OUString > sVec;
+			// reserve just the amount we need to copy
+			sVec.reserve( sList.getLength() - nIndex );
+
+			// point at first element to copy
+			rtl::OUString* pString = sList.getArray() + nIndex;
+			const rtl::OUString* pEndString = sList.getArray() + sList.getLength();
+			// insert the new element
+			sVec.push_back( sString );
+			// copy elements	
+			for ( ; pString != pEndString; ++pString )
+				sVec.push_back( *pString );
+		
+			sList.realloc(  sList.getLength() + 1 );
+
+			// point at first element to be overwritten
+			pString = sList.getArray() + nIndex;
+			pEndString = sList.getArray() + sList.getLength();
+			std::vector< rtl::OUString >::iterator it = sVec.begin();
+			for ( ; pString != pEndString; ++pString, ++it)
+				*pString = *it;	
+			//
+		}
+
+		m_xProps->setPropertyValue( ITEMS, uno::makeAny( sList ) );
+		
+	}
+}
+
+void SAL_CALL 
+ListControlHelper::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    // for int index
+	if ( index >>= nIndex  )
+	{
+		uno::Sequence< rtl::OUString > sList;
+		m_xProps->getPropertyValue( ITEMS ) >>= sList;
+        if( nIndex < 0 || nIndex > ( sList.getLength() - 1 ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid index" ), uno::Reference< uno::XInterface > () );
+        if( sList.hasElements() )
+        {
+            if( sList.getLength() == 1 )
+            {
+                Clear();
+                return;
+            }
+            for( sal_Int32 i = nIndex; i < ( sList.getLength()-1 ); i++ )
+            {
+                sList[i] = sList[i+1];
+            }
+			sList.realloc(  sList.getLength() - 1 );
+		}
+
+		m_xProps->setPropertyValue( ITEMS, uno::makeAny( sList ) );
+	}
+}
+
+void SAL_CALL 
+ListControlHelper::Clear(  ) throw (uno::RuntimeException)
+{
+	// urk, setValue doesn't seem to work !!
+	//setValue( uno::makeAny( sal_Int16() ) );
+	m_xProps->setPropertyValue( ITEMS, uno::makeAny( uno::Sequence< rtl::OUString >() ) );
+}
+
+void SAL_CALL
+ListControlHelper::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
+{
+	if ( _rowsource.getLength() == 0 )
+		Clear();
+}
+
+sal_Int32 SAL_CALL
+ListControlHelper::getListCount() throw (uno::RuntimeException)
+{
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    return sList.getLength();
+}
+
+uno::Any SAL_CALL 
+ListControlHelper::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
+{
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
+    uno::Any aRet;
+    if ( pvargIndex.hasValue() )
+    {
+        sal_Int16 nIndex = -1;
+        pvargIndex >>= nIndex;
+        if( nIndex < 0 || nIndex >= nLength )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad row Index" ), uno::Reference< uno::XInterface >() );       
+        aRet <<= sList[ nIndex ];
+    }
+    else if ( pvarColumn.hasValue() ) // pvarColumn on its own would be bad
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Bad column Index" ), uno::Reference< uno::XInterface >() );       
+    else // List() ( e.g. no args )
+    {
+        uno::Sequence< uno::Sequence< rtl::OUString > > sReturnArray( nLength );
+        for ( sal_Int32 i = 0; i < nLength; ++i )
+        {
+            sReturnArray[ i ].realloc( 10 );
+            sReturnArray[ i ][ 0 ] = sList[ i ];
+        }        
+        aRet = uno::makeAny( sReturnArray );
+    }
+    return aRet;
+}
Index: vbahelper/source/msforms/vbacombobox.hxx
===================================================================
--- vbahelper/source/msforms/vbacombobox.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacombobox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacombobox.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMBOBOX_HXX
+#define SC_VBA_COMBOBOX_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <ooo/vba/msforms/XComboBox.hpp>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include "vbacontrol.hxx"
+#include "vbalistcontrolhelper.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper2<ScVbaControl, ov::msforms::XComboBox, css::script::XDefaultProperty > ComboBoxImpl_BASE;
+class ScVbaComboBox : public ComboBoxImpl_BASE
+{		
+	std::auto_ptr< ListControlHelper > mpListHelper;
+	rtl::OUString sSourceName; 
+	rtl::OUString msDftPropName;
+	bool mbDialogType;
+	
+public:
+	ScVbaComboBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, bool bDialogType = false );
+
+	// Attributes
+	virtual css::uno::Any SAL_CALL getListIndex() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setListIndex( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
+	// XControl
+    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
+
+	// XDefaultProperty
+        ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+	//XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //
Index: vbahelper/source/msforms/vbatogglebutton.cxx
===================================================================
--- vbahelper/source/msforms/vbatogglebutton.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbatogglebutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbatogglebutton.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+const static rtl::OUString TOGGLE( RTL_CONSTASCII_USTRINGPARAM("Toggle") );
+const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
+ScVbaToggleButton::ScVbaToggleButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : ToggleButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+    OSL_TRACE("ScVbaToggleButton(ctor)");
+    m_xProps->setPropertyValue( TOGGLE, uno::makeAny( sal_True ) );
+}
+
+ScVbaToggleButton::~ScVbaToggleButton()
+{
+    OSL_TRACE("~ScVbaToggleButton(dtor)");
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaToggleButton::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaToggleButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaToggleButton::getValue() throw (uno::RuntimeException)
+{
+	sal_Int16 nState = 0;
+    	m_xProps->getPropertyValue( STATE ) >>= nState;
+ 	return uno::makeAny( nState ? sal_Int16( -1 ) : sal_Int16( 0 ) );
+}
+
+//liuchen 2009-7-23, resolve the defect that ToggleButton.Value cannot be set correctly
+void SAL_CALL 
+ScVbaToggleButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+	sal_Int16 nState = 0;
+	if (_value.getValueTypeClass() == typelib_TypeClass_BOOLEAN)
+	{
+		sal_Bool bValue;
+		_value >>= bValue;
+		nState = static_cast< sal_Int16 >(bValue);
+	}
+	else if (_value.getValueTypeClass() == typelib_TypeClass_BYTE)
+	{
+		sal_Int8 nValue;
+		_value >>= nValue;
+		nState = ( nValue == 1) ? 1 : 0;
+	}
+	else
+	{
+		_value >>= nState;
+        OSL_TRACE( "nState - %d", nState );
+		nState = ( nState == -1 ) ?  1 : 0;
+        OSL_TRACE( "nState - %d", nState );
+	}
+	m_xProps->setPropertyValue( STATE, uno::makeAny(  nState ) );
+}
+//liuchen 2009-7-23
+
+rtl::OUString& 
+ScVbaToggleButton::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaToggleButton") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaToggleButton::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ToggleButton" ) );
+	}
+	return aServiceNames;
+}
+
Index: vbahelper/source/msforms/vbalabel.cxx
===================================================================
--- vbahelper/source/msforms/vbalabel.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalabel.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalabel.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbalabel.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+const static rtl::OUString FORECOLOR( RTL_CONSTASCII_USTRINGPARAM("TextColor") ); //liuchen 2009-7-6
+ScVbaLabel::ScVbaLabel(  const css::uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper ) : LabelImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaLabel::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaLabel::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+uno::Any SAL_CALL 
+ScVbaLabel::getValue() throw (css::uno::RuntimeException)
+{
+    return uno::makeAny( getCaption() );
+}
+
+void SAL_CALL 
+ScVbaLabel::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    rtl::OUString sCaption;
+    _value >>= sCaption;
+    setCaption( sCaption ); 
+}
+
+
+//liuchen 2009-7-6
+::sal_Int32 SAL_CALL ScVbaLabel::getForeColor() throw (::com::sun::star::uno::RuntimeException)
+{
+	sal_Int32 nForeColor;
+	m_xProps->getPropertyValue( FORECOLOR ) >>= nForeColor; 
+	return OORGBToXLRGB( nForeColor );
+}
+
+void SAL_CALL ScVbaLabel::setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException)
+{	
+	 m_xProps->setPropertyValue( FORECOLOR, uno::makeAny( XLRGBToOORGB( _forecolor ) ) );
+}
+//liuchenn 2009-7-6
+
+rtl::OUString& 
+ScVbaLabel::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaLabel") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaLabel::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Label" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbacontrol.cxx
===================================================================
--- vbahelper/source/msforms/vbacontrol.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacontrol.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,548 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacontrol.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/form/FormComponentType.hpp>
+#include <com/sun/star/awt/XControlModel.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XWindow2.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/view/XControlAccess.hpp>
+#include <com/sun/star/container/XChild.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <ooo/vba/XControlProvider.hpp>
+#ifdef VBA_OOBUILD_HACK
+#include <svtools/bindablecontrolhelper.hxx>
+#endif
+#include"vbacontrol.hxx"
+#include"vbacombobox.hxx"
+#include "vbabutton.hxx"
+#include "vbalabel.hxx"
+#include "vbatextbox.hxx"
+#include "vbaradiobutton.hxx"
+#include "vbalistbox.hxx"
+#include "vbatogglebutton.hxx"
+#include "vbacheckbox.hxx"
+#include "vbaframe.hxx"
+#include "vbascrollbar.hxx"
+#include "vbaprogressbar.hxx"
+#include "vbamultipage.hxx"
+#include "vbaspinbutton.hxx"
+#include "vbaimage.hxx"
+#include <vbahelper/helperdecl.hxx>
+
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+uno::Reference< css::awt::XWindowPeer > 
+ScVbaControl::getWindowPeer() throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY );
+
+    uno::Reference< awt::XControlModel > xControlModel;
+    uno::Reference< css::awt::XWindowPeer >  xWinPeer;
+    if ( !xControlShape.is() ) 
+    { 
+        // would seem to be a Userform control
+        uno::Reference< awt::XControl > xControl( m_xControl, uno::UNO_QUERY_THROW );
+        xWinPeer =  xControl->getPeer();
+	return xWinPeer;
+    }
+    // form control
+    xControlModel.set( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+
+    uno::Reference< view::XControlAccess > xControlAccess( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    try
+    {
+        uno::Reference< awt::XControl > xControl( xControlAccess->getControl( xControlModel ), uno::UNO_QUERY );
+        xWinPeer =  xControl->getPeer();
+    }
+    catch( uno::Exception )
+    {
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "The Control does not exsit" ),
+                uno::Reference< uno::XInterface >() );
+    }
+    return xWinPeer;
+}
+
+//ScVbaControlListener
+class ScVbaControlListener: public cppu::WeakImplHelper1< lang::XEventListener >
+{
+private:
+    ScVbaControl *pControl;
+public:
+    ScVbaControlListener( ScVbaControl *pTmpControl );
+    virtual ~ScVbaControlListener();
+    virtual void SAL_CALL disposing( const lang::EventObject& rEventObject ) throw( uno::RuntimeException );
+};
+
+ScVbaControlListener::ScVbaControlListener( ScVbaControl *pTmpControl ): pControl( pTmpControl )
+{
+}
+
+ScVbaControlListener::~ScVbaControlListener()
+{
+}
+
+void SAL_CALL
+ScVbaControlListener::disposing( const lang::EventObject& ) throw( uno::RuntimeException )
+{
+    if( pControl )
+    {
+        pControl->removeResouce();
+        pControl = NULL;
+    }
+}
+
+//ScVbaControl
+
+ScVbaControl::ScVbaControl( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< ::uno::XInterface >& xControl,  const css::uno::Reference< css::frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ControlImpl_BASE( xParent, xContext ),  m_xControl( xControl ), m_xModel( xModel )
+{
+    //add listener
+    m_xEventListener.set( new ScVbaControlListener( this ) );
+    setGeometryHelper( pGeomHelper );
+    uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
+    xComponent->addEventListener( m_xEventListener );
+   
+    //init m_xProps
+    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY ) ;
+    uno::Reference< awt::XControl> xUserFormControl( m_xControl, uno::UNO_QUERY ) ;
+    if ( xControlShape.is() ) // form control
+        m_xProps.set( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+    else if ( xUserFormControl.is() ) // userform control
+        m_xProps.set( xUserFormControl->getModel(), uno::UNO_QUERY_THROW );
+}
+
+ScVbaControl::~ScVbaControl()
+{
+    if( m_xControl.is() )
+{
+        uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
+    xComponent->removeEventListener( m_xEventListener );
+}
+}
+
+void 
+ScVbaControl::setGeometryHelper( AbstractGeometryAttributes* pHelper )
+{
+    mpGeometryHelper.reset( pHelper );
+}
+
+void ScVbaControl::removeResouce() throw( uno::RuntimeException )
+{
+    uno::Reference< lang::XComponent > xComponent( m_xControl, uno::UNO_QUERY_THROW );
+    xComponent->removeEventListener( m_xEventListener );
+    m_xControl= NULL;
+    m_xProps = NULL;
+}
+
+//In design model has different behavior
+sal_Bool SAL_CALL ScVbaControl::getEnabled() throw (uno::RuntimeException)
+{
+    uno::Any aValue = m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Enabled" ) ) );
+    sal_Bool bRet = false;
+    aValue >>= bRet;
+    return bRet;
+}
+
+void SAL_CALL ScVbaControl::setEnabled( sal_Bool bVisible ) throw (uno::RuntimeException)
+{
+    uno::Any aValue( bVisible );
+    m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Enabled" ) ), aValue);
+
+}
+
+sal_Bool SAL_CALL ScVbaControl::getVisible() throw (uno::RuntimeException)
+{
+    sal_Bool bVisible( sal_True );
+    m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) )) >>= bVisible;
+    return bVisible;
+}
+
+void SAL_CALL ScVbaControl::setVisible( sal_Bool bVisible ) throw (uno::RuntimeException)
+{
+    uno::Any aValue( bVisible );
+    m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) ), aValue);
+}
+double SAL_CALL ScVbaControl::getHeight() throw (uno::RuntimeException)
+{
+    return mpGeometryHelper->getHeight();
+}
+void SAL_CALL ScVbaControl::setHeight( double _height ) throw (uno::RuntimeException)
+{
+    mpGeometryHelper->setHeight( _height );
+}
+
+double SAL_CALL ScVbaControl::getWidth() throw (uno::RuntimeException)
+{
+    return mpGeometryHelper->getWidth();
+}
+void SAL_CALL ScVbaControl::setWidth( double _width ) throw (uno::RuntimeException)
+{
+    mpGeometryHelper->setWidth( _width );
+}
+
+double SAL_CALL
+ScVbaControl::getLeft() throw (uno::RuntimeException)
+{
+    return mpGeometryHelper->getLeft();
+}
+
+void SAL_CALL
+ScVbaControl::setLeft( double _left ) throw (uno::RuntimeException)
+{
+    mpGeometryHelper->setLeft( _left );
+
+}
+
+double SAL_CALL
+ScVbaControl::getTop() throw (uno::RuntimeException)
+{
+    return mpGeometryHelper->getTop();
+}
+
+void SAL_CALL
+ScVbaControl::setTop( double _top ) throw (uno::RuntimeException)
+{
+    mpGeometryHelper->setTop( _top );
+}
+
+uno::Reference< uno::XInterface > SAL_CALL
+ScVbaControl::getObject() throw (uno::RuntimeException)
+{
+	uno::Reference< msforms::XControl > xRet( this );
+	return xRet;
+}
+
+void SAL_CALL ScVbaControl::SetFocus() throw (uno::RuntimeException) 
+{
+    uno::Reference< awt::XWindow > xWin( m_xControl, uno::UNO_QUERY_THROW );
+    xWin->setFocus();
+}
+
+rtl::OUString SAL_CALL 
+ScVbaControl::getControlSource() throw (uno::RuntimeException)
+{
+// #FIXME I *hate* having these upstream differences
+// but this is necessary until I manage to upstream other
+// dependant parts
+#ifdef VBA_OOBUILD_HACK
+	rtl::OUString sControlSource;
+	uno::Reference< form::binding::XBindableValue > xBindable( m_xProps, uno::UNO_QUERY );
+	if ( xBindable.is() )
+	{
+		try
+		{
+			uno::Reference< lang::XMultiServiceFactory > xFac( m_xModel, uno::UNO_QUERY_THROW );
+			uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.table.CellAddressConversion" ))), uno::UNO_QUERY );
+			uno::Reference< beans::XPropertySet > xProps( xBindable->getValueBinding(), uno::UNO_QUERY_THROW );
+			table::CellAddress aAddress;
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BoundCell") ) ) >>= aAddress;
+			xConvertor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Address") ), uno::makeAny( aAddress ) );
+                	xConvertor->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("XL_A1_Representation") ) ) >>= sControlSource;
+		}
+		catch( uno::Exception& )
+		{
+		}	
+	}
+	return sControlSource;
+#else
+	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getControlSource not supported") ), uno::Reference< uno::XInterface >()); // not supported
+#endif
+}
+
+void SAL_CALL 
+ScVbaControl::setControlSource( const rtl::OUString& _controlsource ) throw (uno::RuntimeException)
+{
+#ifdef VBA_OOBUILD_HACK
+    rtl::OUString sEmpty;
+    svt::BindableControlHelper::ApplyListSourceAndBindableData( m_xModel, m_xProps, _controlsource, sEmpty );
+#else
+	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setControlSource not supported ") ).concat( _controlsource ), uno::Reference< uno::XInterface >()); // not supported
+#endif
+}
+
+rtl::OUString SAL_CALL 
+ScVbaControl::getRowSource() throw (uno::RuntimeException)
+{
+#ifdef VBA_OOBUILD_HACK
+	rtl::OUString sRowSource;
+	uno::Reference< form::binding::XListEntrySink > xListSink( m_xProps, uno::UNO_QUERY );
+	if ( xListSink.is() )
+    {
+		try
+		{
+			uno::Reference< lang::XMultiServiceFactory > xFac( m_xModel, uno::UNO_QUERY_THROW );
+			uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.table.CellRangeAddressConversion" ))), uno::UNO_QUERY );
+
+			uno::Reference< beans::XPropertySet > xProps( xListSink->getListEntrySource(), uno::UNO_QUERY_THROW );
+			table::CellRangeAddress aAddress;
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CellRange") ) ) >>= aAddress;
+			xConvertor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Address")), uno::makeAny( aAddress ) );
+			xConvertor->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("XL_A1_Representation") ) ) >>= sRowSource;
+		}
+		catch( uno::Exception& )
+		{
+		}	
+	}
+	return sRowSource;
+#else
+	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getRowSource not supported") ), uno::Reference< uno::XInterface >()); // not supported
+#endif
+}
+
+void SAL_CALL 
+ScVbaControl::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
+{
+#ifdef VBA_OOBUILD_HACK
+    rtl::OUString sEmpty;
+    svt::BindableControlHelper::ApplyListSourceAndBindableData( m_xModel, m_xProps, sEmpty, _rowsource );
+#else
+	throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setRowSource not supported ") ).concat( _rowsource ), uno::Reference< uno::XInterface >()); // not supported
+#endif
+}
+
+rtl::OUString SAL_CALL 
+ScVbaControl::getName() throw (uno::RuntimeException)
+{
+	rtl::OUString sName;
+	m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ) ) >>= sName;
+	return sName;
+
+}
+
+void SAL_CALL
+ScVbaControl::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
+{
+	m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Name" ) ), uno::makeAny( _name ) );
+    }
+
+rtl::OUString SAL_CALL 
+ScVbaControl::getControlTipText() throw (css::uno::RuntimeException)
+{
+	rtl::OUString sName;
+	m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "HelpText" ) ) ) >>= sName;
+	return sName;
+}
+
+void SAL_CALL 
+ScVbaControl::setControlTipText( const rtl::OUString& rsToolTip ) throw (css::uno::RuntimeException)
+{
+	m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "HelpText" ) ), uno::makeAny( rsToolTip ) );
+}
+//ScVbaControlFactory
+
+ScVbaControlFactory::ScVbaControlFactory( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel ): m_xContext( xContext ), m_xControl( xControl ), m_xModel( xModel )
+{
+}
+
+ScVbaControl* ScVbaControlFactory::createControl()  throw (uno::RuntimeException)
+{
+    return createControl( m_xModel );
+}
+ScVbaControl* ScVbaControlFactory::createControl( const uno::Reference< uno::XInterface >& xParent )  throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XControlShape > xControlShape( m_xControl, uno::UNO_QUERY );
+    if ( xControlShape.is() ) // form controls
+        return createControl( xControlShape, xParent );
+    uno::Reference< awt::XControl > xControl( m_xControl, uno::UNO_QUERY );
+    if ( !xControl.is() )
+        throw uno::RuntimeException(); // really we should be more informative
+    return createControl( xControl, xParent );
+    
+}
+
+ScVbaControl* ScVbaControlFactory::createControl(const uno::Reference< drawing::XControlShape >& xControlShape,  const uno::Reference< uno::XInterface >& /*xParent*/ )  throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xProps( xControlShape->getControl(), uno::UNO_QUERY_THROW );
+    sal_Int32 nClassId = -1;
+    const static rtl::OUString sClassId( RTL_CONSTASCII_USTRINGPARAM("ClassId") );
+    xProps->getPropertyValue( sClassId ) >>= nClassId;
+    uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
+    sal_Bool bToggle = sal_False;  //liuchen 2009-8-11,  
+	switch( nClassId )
+    {
+        case form::FormComponentType::COMBOBOX:
+            return new ScVbaComboBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::COMMANDBUTTON:
+			//liuchen 2009-8-11
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toggle") ) ) >>= bToggle;
+			if ( bToggle )
+				return new ScVbaToggleButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			else
+				return new ScVbaButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+			//liuchen 2009-8-11
+		case form::FormComponentType::FIXEDTEXT:
+            return new ScVbaLabel( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::TEXTFIELD:
+            return new ScVbaTextBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::CHECKBOX:
+            return new ScVbaCheckbox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::RADIOBUTTON:
+            return new ScVbaRadioButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::LISTBOX:
+            return new ScVbaListBox( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::SPINBUTTON:
+            return new ScVbaSpinButton( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        case form::FormComponentType::IMAGECONTROL:
+            return new ScVbaImage( xVbaParent, m_xContext, xControlShape, m_xModel, new ConcreteXShapeGeometryAttributes( m_xContext, uno::Reference< drawing::XShape >( xControlShape, uno::UNO_QUERY_THROW ) ) );
+        default:
+            throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Donot support this Control Type." ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+ScVbaControl* ScVbaControlFactory::createControl( const uno::Reference< awt::XControl >& xControl,  const uno::Reference< uno::XInterface >& xParent  )  throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xProps( xControl->getModel(), uno::UNO_QUERY_THROW );
+    uno::Reference< lang::XServiceInfo > xServiceInfo( xProps, uno::UNO_QUERY_THROW );
+    ScVbaControl* pControl = NULL;
+    uno::Reference< XHelperInterface > xVbaParent; // #FIXME - should be worksheet I guess
+    if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlCheckBoxModel") ) ) )
+	pControl = new ScVbaCheckbox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );	
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlRadioButtonModel") ) ) )
+	pControl = new ScVbaRadioButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );	
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlEditModel") ) ) )
+        pControl = new ScVbaTextBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), true );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlButtonModel") ) ) )
+    {
+        sal_Bool bToggle = sal_False;
+        xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toggle") ) ) >>= bToggle;
+        if ( bToggle )
+            pControl = new ScVbaToggleButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+        else
+            pControl = new ScVbaButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    }
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlComboBoxModel") ) ) )
+        pControl = new ScVbaComboBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), true );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlListBoxModel") ) ) )
+	pControl = new ScVbaListBox( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlFixedTextModel") ) ) )
+	pControl = new ScVbaLabel( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlImageControlModel") ) ) )
+	pControl = new ScVbaImage( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlProgressBarModel") ) ) )
+	pControl = new ScVbaProgressBar( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlGroupBoxModel") ) ) )
+	pControl = new ScVbaFrame( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlScrollBarModel") ) ) )
+	pControl = new ScVbaScrollBar( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoMultiPageModel") ) ) )
+	pControl = new ScVbaMultiPage( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ), xParent );
+    else if ( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.awt.UnoControlSpinButtonModel") ) ) )
+	pControl = new ScVbaSpinButton( xVbaParent, m_xContext, xControl, m_xModel, new UserFormGeometryHelper( m_xContext, xControl ) );
+    else
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Unsupported control " ), uno::Reference< uno::XInterface >() );
+    return pControl;
+}
+
+rtl::OUString& 
+ScVbaControl::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaControl") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaControl::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.Control" ) );
+    }
+	return aServiceNames;
+}
+
+
+
+typedef cppu::WeakImplHelper1< XControlProvider > ControlProvider_BASE;
+class ControlProviderImpl : public ControlProvider_BASE
+{
+    uno::Reference< uno::XComponentContext > m_xCtx;
+public:
+    ControlProviderImpl( const uno::Reference< uno::XComponentContext >& xCtx ) : m_xCtx( xCtx ) {}
+    virtual uno::Reference< msforms::XControl > SAL_CALL createControl( const uno::Reference< drawing::XControlShape >& xControl, const uno::Reference< frame::XModel >& xDocOwner ) throw (uno::RuntimeException);
+    virtual uno::Reference< msforms::XControl > SAL_CALL createUserformControl( const uno::Reference< awt::XControl >& xControl, const uno::Reference< awt::XControl >& xDialog, const uno::Reference< frame::XModel >& xDocOwner ) throw (uno::RuntimeException);
+};
+
+uno::Reference< msforms::XControl > SAL_CALL 
+ControlProviderImpl::createControl( const uno::Reference< drawing::XControlShape >& xControlShape, const uno::Reference< frame::XModel >& xDocOwner ) throw (uno::RuntimeException)
+{
+	uno::Reference< msforms::XControl > xControlToReturn;
+	if ( xControlShape.is() ) 
+	{
+		ScVbaControlFactory controlFactory( m_xCtx, xControlShape, xDocOwner );
+		xControlToReturn.set( controlFactory.createControl( xDocOwner ) );
+	}
+	return xControlToReturn;
+		
+}
+uno::Reference< msforms::XControl > SAL_CALL 
+ControlProviderImpl::createUserformControl( const uno::Reference< awt::XControl >& xControl, const uno::Reference< awt::XControl >& xDialog, const uno::Reference< frame::XModel >& xDocOwner ) throw (uno::RuntimeException)
+{
+	uno::Reference< msforms::XControl > xControlToReturn;
+	if ( xControl.is() && xDialog.is() ) 
+	{ 
+			
+		ScVbaControlFactory controlFactory( m_xCtx, xControl, xDocOwner );
+		xControlToReturn.set( controlFactory.createControl( xDialog->getModel() ) );
+		ScVbaControl* pControl  = dynamic_cast< ScVbaControl* >( xControlToReturn.get() );
+		pControl->setGeometryHelper( new UserFormGeometryHelper( m_xCtx, xControl ) );
+	}
+	return xControlToReturn;
+}
+
+namespace controlprovider
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::class_<ControlProviderImpl, sdecl::with_args<false> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ControlProviderImpl",
+    "ooo.vba.ControlProvider" );
+}
+
+
Index: vbahelper/source/msforms/vbalistcontrolhelper.hxx
===================================================================
--- vbahelper/source/msforms/vbalistcontrolhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalistcontrolhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,20 @@
+#ifndef SC_VBA_LISTCONTROLHELPER
+#define SC_VBA_LISTCONTROLHELPER
+
+#include <vbahelper/vbahelper.hxx>
+
+class ListControlHelper
+{
+	css::uno::Reference< css::beans::XPropertySet > m_xProps;
+
+public:
+	ListControlHelper( const css::uno::Reference< css::beans::XPropertySet >& rxControl ) : m_xProps( rxControl ){}
+	virtual ~ListControlHelper() {}
+	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);   
+    	virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
+};
+#endif
Index: vbahelper/source/msforms/vbatogglebutton.hxx
===================================================================
--- vbahelper/source/msforms/vbatogglebutton.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbatogglebutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_TOGGLEBUTTON_HXX
+#define SC_VBA_TOGGLEBUTTON_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <ooo/vba/msforms/XToggleButton.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XToggleButton, css::script::XDefaultProperty  > ToggleButtonImpl_BASE;
+
+class ScVbaToggleButton : public ToggleButtonImpl_BASE
+{
+	rtl::OUString msDftPropName;
+public:
+    ScVbaToggleButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+    ~ScVbaToggleButton();
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+#endif //SC_VBA_TOGGLEBUTTON_HXX
Index: vbahelper/source/msforms/vbaimage.cxx
===================================================================
--- vbahelper/source/msforms/vbaimage.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaimage.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaimage.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+ScVbaImage::ScVbaImage( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ImageImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+rtl::OUString& 
+ScVbaImage::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaImage") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaImage::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Image" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbalabel.hxx
===================================================================
--- vbahelper/source/msforms/vbalabel.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalabel.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalabel.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_LABEL_HXX
+#define SC_VBA_LABEL_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XLabel.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XLabel, css::script::XDefaultProperty  > LabelImpl_BASE;
+
+class ScVbaLabel : public LabelImpl_BASE
+{
+public:
+    ScVbaLabel( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	//liuchen 2009-7-6 
+	virtual ::sal_Int32 SAL_CALL getForeColor() throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL setForeColor( ::sal_Int32 _forecolor ) throw (::com::sun::star::uno::RuntimeException);
+	//liuchen 2009-7-6 end
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+#endif //SC_VBA_LABEL_HXX
Index: vbahelper/source/msforms/vbalistbox.cxx
===================================================================
--- vbahelper/source/msforms/vbalistbox.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalistbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,292 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalistbox.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/form/validation/XValidatableFormComponent.hpp>
+
+#include "vbalistbox.hxx"
+#include <vector>
+#include <comphelper/anytostring.hxx>
+#include <com/sun/star/script/ArrayWrapper.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+const static rtl::OUString TEXT( RTL_CONSTASCII_USTRINGPARAM("Text") );
+const static rtl::OUString SELECTEDITEMS( RTL_CONSTASCII_USTRINGPARAM("SelectedItems") );
+const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
+
+
+ScVbaListBox::ScVbaListBox( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< css::uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ListBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+    mpListHelper.reset( new ListControlHelper( m_xProps ) );
+}
+
+// Attributes
+void SAL_CALL 
+ScVbaListBox::setListIndex( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+    sal_Int32 nIndex = 0;
+    _value >>= nIndex;
+    uno::Reference< XPropValue > xPropVal( Selected( nIndex ), uno::UNO_QUERY_THROW );
+    xPropVal->setValue( uno::makeAny( sal_True ) ); 
+}
+
+uno::Any SAL_CALL 
+ScVbaListBox::getListIndex() throw (uno::RuntimeException)
+{
+    uno::Sequence< sal_Int16 > sSelection;
+    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= sSelection;
+    if ( sSelection.getLength() == 0 )
+        return uno::Any( sal_Int32( -1 ) );
+    return uno::Any( sSelection[ 0 ] );
+}
+
+uno::Any SAL_CALL 
+ScVbaListBox::getValue() throw (uno::RuntimeException)
+{
+    uno::Sequence< sal_Int16 > sSelection;
+    uno::Sequence< rtl::OUString > sItems;
+    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= sSelection;
+    m_xProps->getPropertyValue( ITEMS ) >>= sItems;
+    if( getMultiSelect() )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
+    uno::Any aRet;
+    if ( sSelection.getLength() )
+        aRet = uno::makeAny( sItems[ sSelection[ 0 ] ] ); 
+    return aRet;
+}
+
+void SAL_CALL 
+ScVbaListBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+    if( getMultiSelect() )
+    {	
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
+    }
+    rtl::OUString sValue = getAnyAsString( _value );
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    uno::Sequence< sal_Int16 > nList;
+    sal_Int16 nLength = static_cast<sal_Int16>( sList.getLength() );
+    sal_Int16 nValue = -1;
+    sal_Int16 i = 0;
+    for( i = 0; i < nLength; i++ )
+    {
+        if( sList[i].equals( sValue ) )
+        {
+            nValue = i; 
+            break;
+        }
+    }
+    if( nValue == -1 )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Attribute use invalid." ), uno::Reference< uno::XInterface >() );
+
+    uno::Sequence< sal_Int16 > nSelectedIndices(1);
+    nSelectedIndices[ 0 ] = nValue;
+    m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nSelectedIndices ) ); 
+	//m_xProps->setPropertyValue( TEXT, uno::makeAny( sValue ) );   //liuchen 2009-8-12 solve the problem that ListBox.Text and ListBox.Value cannot be set
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaListBox::getText() throw (uno::RuntimeException)
+{
+	rtl::OUString result;
+	getValue() >>= result;
+	return result;
+}
+
+void SAL_CALL 
+ScVbaListBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
+{
+	setValue( uno::makeAny( _text ) ); // seems the same
+}
+
+sal_Int32 SAL_CALL 
+ScVbaListBox::getMultiSelect() throw (css::uno::RuntimeException)
+{
+    sal_Bool bMultiSelect = sal_False;
+    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ) ) >>= bMultiSelect;
+    return bMultiSelect ? 1 : 0 ;
+}
+
+void SAL_CALL 
+ScVbaListBox::setMultiSelect( sal_Int32 _multiselect ) throw (css::uno::RuntimeException)
+{
+	sal_Bool bMultiSelect = _multiselect == 1 ? 1 : 0;
+    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiSelection" ) ), uno::makeAny( bMultiSelect ) );
+}
+
+
+css::uno::Any SAL_CALL 
+ScVbaListBox::Selected( sal_Int32 index ) throw (css::uno::RuntimeException)
+{
+    uno::Sequence< rtl::OUString > sList;
+    m_xProps->getPropertyValue( ITEMS ) >>= sList;
+    sal_Int16 nLength = static_cast< sal_Int16 >( sList.getLength() );
+    // no choice but to do a horror cast as internally
+    // the indices are but sal_Int16 
+    sal_Int16 nIndex = static_cast< sal_Int16 >( index );
+    if( nIndex < 0 || nIndex >= nLength )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Error Number." ), uno::Reference< uno::XInterface >() );
+    m_nIndex = nIndex;
+    return uno::makeAny( uno::Reference< XPropValue > ( new ScVbaPropValue( this ) ) );
+}
+
+// Methods
+void SAL_CALL 
+ScVbaListBox::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
+{
+	mpListHelper->AddItem( pvargItem, pvargIndex );
+		}
+
+void SAL_CALL 
+ScVbaListBox::removeItem( const uno::Any& index ) throw (uno::RuntimeException)
+{
+	mpListHelper->removeItem( index );
+}
+
+void SAL_CALL 
+ScVbaListBox::Clear(  ) throw (uno::RuntimeException)
+{
+	mpListHelper->Clear();
+}
+
+// this is called when something like the following vba code is used
+// to set the selected state of particular entries in the Listbox
+// ListBox1.Selected( 3 ) = false
+//PropListener
+void 
+ScVbaListBox::setValueEvent( const uno::Any& value )
+{
+    sal_Bool bValue = sal_False;
+    if( !(value >>= bValue) )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+                    "Invalid type\n. need boolean." ), uno::Reference< uno::XInterface >() );
+    uno::Sequence< sal_Int16 > nList;
+    m_xProps->getPropertyValue( SELECTEDITEMS ) >>= nList;
+    sal_Int16 nLength = static_cast<sal_Int16>( nList.getLength() );
+    sal_Int16 nIndex = m_nIndex;
+    for( sal_Int16 i = 0; i < nLength; i++ )
+    {
+        if( nList[i] == nIndex )
+        {
+            if( bValue )
+                return;
+            else
+            {
+                for( ; i < nLength - 1; i++ )
+                {
+                    nList[i] = nList[i + 1];
+                }
+                nList.realloc( nLength - 1 );
+                //m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
+		m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nList ) );
+                return;
+            }
+        }
+    }
+    if( bValue )
+    {
+        if( getMultiSelect() )
+        {
+            nList.realloc( nLength + 1 );
+            nList[nLength] = nIndex;
+        }
+        else
+        {
+            nList.realloc( 1 );
+            nList[0] = nIndex;
+        }
+        //m_xProps->setPropertyValue( sSourceName, uno::makeAny( nList ) );
+        m_xProps->setPropertyValue( SELECTEDITEMS, uno::makeAny( nList ) );
+    }
+}
+
+// this is called when something like the following vba code is used
+// to determine the selected state of particular entries in the Listbox
+// msgbox ListBox1.Selected( 3 )
+
+css::uno::Any 
+ScVbaListBox::getValueEvent()
+{
+    uno::Sequence< sal_Int16 > nList;
+    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "SelectedItems" ) ) ) >>= nList;
+    sal_Int32 nLength = nList.getLength();
+    sal_Int32 nIndex = m_nIndex;
+    
+    for( sal_Int32 i = 0; i < nLength; i++ )
+    {
+        if( nList[i] == nIndex )
+            return uno::makeAny( sal_True );
+    }
+
+    return uno::makeAny( sal_False );
+}
+
+void SAL_CALL
+ScVbaListBox::setRowSource( const rtl::OUString& _rowsource ) throw (uno::RuntimeException)
+{
+	ScVbaControl::setRowSource( _rowsource );
+	mpListHelper->setRowSource( _rowsource );
+}
+
+sal_Int32 SAL_CALL
+ScVbaListBox::getListCount() throw (uno::RuntimeException)
+{
+	return mpListHelper->getListCount();
+}
+
+uno::Any SAL_CALL 
+ScVbaListBox::List( const ::uno::Any& pvargIndex, const uno::Any& pvarColumn ) throw (uno::RuntimeException)
+{
+	return mpListHelper->List( pvargIndex, pvarColumn );
+}
+
+rtl::OUString& 
+ScVbaListBox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaListBox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaListBox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ScVbaListBox" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbacontrol.hxx
===================================================================
--- vbahelper/source/msforms/vbacontrol.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbacontrol.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,114 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacontrol.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CONTROL_HXX
+#define SC_VBA_CONTROL_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XWindowPeer.hpp>
+#include <ooo/vba/msforms/XControl.hpp>
+
+#include <vbahelper/vbahelper.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <memory>
+
+//typedef ::cppu::WeakImplHelper1< ov::msforms::XControl > ControlImpl_BASE;
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XControl > ControlImpl_BASE;
+
+class ScVbaControl : public ControlImpl_BASE
+{
+private:
+    com::sun::star::uno::Reference< com::sun::star::lang::XEventListener > m_xEventListener;
+protected:
+    std::auto_ptr< ov::AbstractGeometryAttributes > mpGeometryHelper;
+    css::uno::Reference< css::beans::XPropertySet > m_xProps;
+    css::uno::Reference< css::uno::XInterface > m_xControl;
+    css::uno::Reference< css::frame::XModel > m_xModel;
+
+    virtual css::uno::Reference< css::awt::XWindowPeer > getWindowPeer() throw (css::uno::RuntimeException);
+public:
+    ScVbaControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+                    const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pHelper );
+    virtual ~ScVbaControl();
+    // This class will own the helper, so make sure it is allocated from 
+    // the heap
+    void setGeometryHelper( ov::AbstractGeometryAttributes* pHelper );
+    // XControl
+    virtual sal_Bool SAL_CALL getEnabled() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnabled( sal_Bool _enabled ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( double _width ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getLeft() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLeft( double _left ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getTop() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTop( double _top ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL SetFocus(  ) throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::uno::XInterface > SAL_CALL getObject() throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getControlSource() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setControlSource( const rtl::OUString& _controlsource ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getRowSource() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getControlTipText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setControlTipText( const rtl::OUString& ) throw (css::uno::RuntimeException);
+    //remove resouce because ooo.vba.excel.XControl is a wrapper of com.sun.star.drawing.XControlShape
+    virtual void removeResouce() throw( css::uno::RuntimeException );
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+
+class ScVbaControlFactory
+{
+public:
+    ScVbaControlFactory( const css::uno::Reference< css::uno::XComponentContext >& xContext, 
+                    const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel );
+    ScVbaControl* createControl()  throw ( css::uno::RuntimeException );
+    ScVbaControl* createControl( const css::uno::Reference< css::uno::XInterface >& xParent )  throw ( css::uno::RuntimeException );
+private:
+    ScVbaControl* createControl( const css::uno::Reference< css::awt::XControl >&, const css::uno::Reference< css::uno::XInterface >&  )  throw ( css::uno::RuntimeException );
+    ScVbaControl* createControl( const css::uno::Reference< css::drawing::XControlShape >&, const css::uno::Reference< css::uno::XInterface >& )  throw ( css::uno::RuntimeException );
+    css::uno::Reference< css::uno::XComponentContext > m_xContext;
+    css::uno::Reference< css::uno::XInterface > m_xControl;
+    css::uno::Reference< css::frame::XModel > m_xModel;
+};
+
+#endif//SC_VBA_CONTROL_HXX
Index: vbahelper/source/msforms/vbaimage.hxx
===================================================================
--- vbahelper/source/msforms/vbaimage.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaimage.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,48 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_IMAGE_HXX
+#define SC_VBA_IMAGE_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XImage.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XImage > ImageImpl_BASE;
+
+class ScVbaImage : public ImageImpl_BASE
+{
+public:
+    ScVbaImage( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_IMAGE_HXX
Index: vbahelper/source/msforms/vbamultipage.cxx
===================================================================
--- vbahelper/source/msforms/vbamultipage.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbamultipage.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbamultipage.hxx"
+#include <ooo/vba/XCollection.hpp>
+#include "vbapages.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+// uno servicename com.sun.star.awt.UnoControlProgressBarMode
+const rtl::OUString SVALUE( RTL_CONSTASCII_USTRINGPARAM("ProgressValue") );
+const rtl::OUString SVALUEMAX( RTL_CONSTASCII_USTRINGPARAM("ProgressValueMax") );
+const rtl::OUString SSTEP( RTL_CONSTASCII_USTRINGPARAM("Step") );
+
+typedef cppu::WeakImplHelper1< container::XIndexAccess > PagesImpl_Base;
+class PagesImpl : public PagesImpl_Base
+{
+	sal_Int32 mnPages;
+public:
+	PagesImpl( sal_Int32 nPages ) : mnPages( nPages ) {}
+	virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException) { return mnPages; }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, ::uno::RuntimeException)
+	{
+		if ( Index < 0 || Index > mnPages )
+			throw lang::IndexOutOfBoundsException();
+		return uno::makeAny( uno::Reference< uno::XInterface >() );
+	}
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+	{
+		// no Pages object yet #FIXME
+		//return msforms::XPage::static_type(0);
+		return uno::XInterface::static_type(0);
+	}
+	virtual ::sal_Bool SAL_CALL hasElements( ) throw (uno::RuntimeException)
+	{
+		return ( mnPages > 0 );
+	}
+};
+uno::Reference< container::XIndexAccess > 
+ScVbaMultiPage::getPages( sal_Int32 nPages )
+{
+	return new PagesImpl( nPages );
+}
+
+ScVbaMultiPage::ScVbaMultiPage( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, const uno::Reference< uno::XInterface >& xDialog ) : MultiPageImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+    mxDialogProps.set( xDialog, uno::UNO_QUERY_THROW );
+    // set dialog step to value of multipage pseudo model
+    setValue(getValue());
+}
+
+// Attributes
+sal_Int32 SAL_CALL 
+ScVbaMultiPage::getValue() throw (css::uno::RuntimeException)
+{
+    sal_Int32 nValue = 0;
+    m_xProps->getPropertyValue( SVALUE ) >>= nValue;
+    return nValue;
+}
+
+void SAL_CALL 
+ScVbaMultiPage::setValue( const sal_Int32 _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    // track change in dialog ( dialog value is 1 based, 0 is a special value )
+    m_xProps->setPropertyValue( SVALUE, uno::makeAny( _value ) );
+    mxDialogProps->setPropertyValue( SSTEP, uno::makeAny( _value + 1) );
+}
+
+
+rtl::OUString& 
+ScVbaMultiPage::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaMultiPage") );
+	return sImplName;
+}
+
+uno::Any SAL_CALL 
+ScVbaMultiPage::Pages( const uno::Any& index ) throw (uno::RuntimeException)
+{
+	sal_Int32 nValue = 0;
+	m_xProps->getPropertyValue( SVALUEMAX ) >>= nValue;
+	uno::Reference< XCollection > xColl( new ScVbaPages( this, mxContext, getPages( nValue ) ) );
+	if ( !index.hasValue() )
+		return uno::makeAny( xColl );
+	return xColl->Item( uno::makeAny( index ), uno::Any() );
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaMultiPage::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.MultiPage" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/makefile.mk
===================================================================
--- vbahelper/source/msforms/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,80 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.45 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..
+PRJNAME=vbahelper
+TARGET=msforms
+
+ENABLE_EXCEPTIONS := TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+CDEFS+=-DVBA_OOBUILD_HACK
+
+SLOFILES=\
+    $(SLO)$/vbacontrol.obj \
+    $(SLO)$/vbacontrols.obj \
+    $(SLO)$/vbabutton.obj \
+    $(SLO)$/vbacombobox.obj \
+    $(SLO)$/vbalabel.obj \
+    $(SLO)$/vbatextbox.obj \
+    $(SLO)$/vbaradiobutton.obj \
+    $(SLO)$/vbalistbox.obj \
+    $(SLO)$/vbatogglebutton.obj \
+    $(SLO)$/vbacheckbox.obj \
+    $(SLO)$/vbaframe.obj \
+    $(SLO)$/vbascrollbar.obj \
+    $(SLO)$/vbaprogressbar.obj \
+    $(SLO)$/vbamultipage.obj \
+    $(SLO)$/vbalistcontrolhelper.obj \
+    $(SLO)$/vbaspinbutton.obj \
+    $(SLO)$/vbaimage.obj \
+    $(SLO)$/vbapages.obj \
+    $(SLO)$/vbauserform.obj \
+    $(SLO)$/service.obj \
+
+# #FIXME vbapropvalue needs to move to vbahelper
+
+# --- Targets -------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
Index: vbahelper/source/msforms/vbalistbox.hxx
===================================================================
--- vbahelper/source/msforms/vbalistbox.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbalistbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalistbox.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_LISTBOX_HXX
+#define SC_VBA_LISTBOX_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <ooo/vba/msforms/XListBox.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbapropvalue.hxx>
+#include "vbalistcontrolhelper.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper2<ScVbaControl, ov::msforms::XListBox, css::script::XDefaultProperty > ListBoxImpl_BASE;
+class ScVbaListBox : public ListBoxImpl_BASE
+    ,public PropListener
+{		
+	std::auto_ptr< ListControlHelper > mpListHelper;
+	rtl::OUString sSourceName; 
+	rtl::OUString msDftPropName;
+
+    sal_Int16 m_nIndex;
+	
+public:
+	ScVbaListBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+
+	// Attributes
+	virtual css::uno::Any SAL_CALL getListIndex() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setListIndex( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getListCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+	virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMultiSelect() throw (css::uno::RuntimeException);  //liuchen 2009-7-31
+    virtual void SAL_CALL setMultiSelect( ::sal_Int32 _multiselect ) throw (css::uno::RuntimeException); //liuchen 2009-7-31
+    virtual css::uno::Any SAL_CALL Selected( ::sal_Int32 index ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeItem( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL List( const css::uno::Any& pvargIndex, const css::uno::Any& pvarColumn ) throw (css::uno::RuntimeException);
+	// XControl
+    virtual void SAL_CALL setRowSource( const rtl::OUString& _rowsource ) throw (css::uno::RuntimeException);
+
+	// XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+    
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();    
+
+    //PropListener
+    virtual void setValueEvent( const css::uno::Any& value );
+    virtual css::uno::Any getValueEvent();
+
+
+};
+
+#endif //
Index: vbahelper/source/msforms/vbaradiobutton.cxx
===================================================================
--- vbahelper/source/msforms/vbaradiobutton.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaradiobutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaradiobutton.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbaradiobutton.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+const static rtl::OUString STATE( RTL_CONSTASCII_USTRINGPARAM("State") );
+ScVbaRadioButton::ScVbaRadioButton( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : RadioButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaRadioButton::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaRadioButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaRadioButton::getValue() throw (css::uno::RuntimeException)
+{
+    sal_Int16 nValue = -1;
+    m_xProps->getPropertyValue( STATE ) >>= nValue;
+    if( nValue != 0 )
+        nValue = -1;
+//    return uno::makeAny( nValue ); 
+// I must be missing something MSO says value should be -1 if selected, 0 if not
+// selected
+    return uno::makeAny( ( nValue == -1 ) ? sal_True : sal_False ); 
+
+}
+
+void SAL_CALL 
+ScVbaRadioButton::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+    sal_Int16 nValue = 0;
+    sal_Bool bValue = sal_False;
+    if( _value >>= nValue )
+    {
+        if( nValue == -1)
+        nValue = 1;
+    }
+    else if ( _value >>= bValue )
+    {
+        if ( bValue )
+            nValue = 1;
+    }
+    m_xProps->setPropertyValue( STATE, uno::makeAny( nValue ) );
+}
+
+rtl::OUString& 
+ScVbaRadioButton::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaRadioButton") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaRadioButton::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.RadioButton" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbamultipage.hxx
===================================================================
--- vbahelper/source/msforms/vbamultipage.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbamultipage.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,65 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_MULTIPAGE_HXX
+#define SC_VBA_MULTIPAGE_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XMultiPage.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+//#include <cppuhelper/implbase2.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XMultiPage > MultiPageImpl_BASE;
+
+class ScVbaMultiPage : public MultiPageImpl_BASE
+{
+    css::uno::Reference< css::container::XIndexAccess > getPages( sal_Int32 nPages );
+    css::uno::Reference< css::beans::XPropertySet > mxDialogProps;
+public:
+    ScVbaMultiPage( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, const css::uno::Reference< css::uno::XInterface >& xDialog );
+   // Attributes
+    virtual sal_Int32 SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( sal_Int32 _value ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Pages( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+#endif //SC_VBA_LABEL_HXX
Index: vbahelper/source/msforms/vbatextbox.cxx
===================================================================
--- vbahelper/source/msforms/vbatextbox.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbatextbox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbatextbox.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/text/XTextRange.hpp>
+
+#include "vbatextbox.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+
+ScVbaTextBox::ScVbaTextBox( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper, bool bDialog ) : TextBoxImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper ), mbDialog( bDialog )
+{
+}
+
+// Attributes
+uno::Any SAL_CALL 
+ScVbaTextBox::getValue() throw (css::uno::RuntimeException)
+{
+	return uno::makeAny( getText() );
+}
+
+void SAL_CALL 
+ScVbaTextBox::setValue( const uno::Any& _value ) throw (css::uno::RuntimeException)
+{
+	rtl::OUString sVal = getAnyAsString( _value );
+	setText( sVal );
+}
+
+//getString() will cause some imfo lose.
+rtl::OUString SAL_CALL 
+ScVbaTextBox::getText() throw (css::uno::RuntimeException)
+{
+    uno::Any aValue;
+    aValue = m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Text" ) ) );
+    rtl::OUString sString;
+    aValue >>= sString;
+    return sString;
+}
+
+void SAL_CALL 
+ScVbaTextBox::setText( const rtl::OUString& _text ) throw (css::uno::RuntimeException)
+{
+    if ( !mbDialog )
+    {
+    uno::Reference< text::XTextRange > xTextRange( m_xProps, uno::UNO_QUERY_THROW );
+    xTextRange->setString( _text );
+}
+    else
+        m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Text") ), uno::makeAny( _text ) ); 
+}
+
+sal_Int32 SAL_CALL 
+ScVbaTextBox::getMaxLength() throw (css::uno::RuntimeException)
+{
+    uno::Any aValue;
+    aValue = m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ) );
+    sal_Int32 nMaxLength = 0;
+    aValue >>= nMaxLength;
+    return nMaxLength;
+}
+
+void SAL_CALL 
+ScVbaTextBox::setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException)
+{
+	sal_Int16 _maxlength16 = static_cast<sal_Int16> (_maxlength); //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
+    uno::Any aValue( _maxlength16 );                              //liuchen 2009-7-24, resolve the problem that MaxLength cannot be set correctly
+    m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MaxTextLen" ) ), aValue);
+}
+
+sal_Bool SAL_CALL 
+ScVbaTextBox::getMultiline() throw (css::uno::RuntimeException)
+{
+    uno::Any aValue;
+    aValue = m_xProps->getPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiLine" ) ) );
+    sal_Bool bRet = false;
+    aValue >>= bRet;
+    return bRet;
+}
+
+void SAL_CALL 
+ScVbaTextBox::setMultiline( sal_Bool _multiline ) throw (css::uno::RuntimeException)
+{
+    uno::Any aValue( _multiline );
+    m_xProps->setPropertyValue
+            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MultiLine" ) ), aValue);
+}
+
+rtl::OUString& 
+ScVbaTextBox::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaTextBox") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaTextBox::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.TextBox" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbapages.cxx
===================================================================
--- vbahelper/source/msforms/vbapages.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbapages.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbapages.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+ScVbaPages::ScVbaPages( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xPages ) throw( lang::IllegalArgumentException ) : ScVbaPages_BASE( xParent, xContext, xPages )
+{
+}
+
+uno::Type SAL_CALL 
+ScVbaPages::getElementType() throw (uno::RuntimeException)
+{
+	// return msforms::XPage::static_type(0); 
+	return uno::XInterface::static_type(0); 
+}
+
+uno::Any 
+ScVbaPages::createCollectionObject( const css::uno::Any& aSource )
+{
+	return aSource;
+}
+
+rtl::OUString& 
+ScVbaPages::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaPages") );
+	return sImplName;
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaPages::createEnumeration() throw (uno::RuntimeException)
+{
+	return uno::Reference< container::XEnumeration >();
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaPages::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Pages" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbaradiobutton.hxx
===================================================================
--- vbahelper/source/msforms/vbaradiobutton.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaradiobutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaradiobutton.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_RADIOBUTTON_HXX
+#define SC_VBA_RADIOBUTTON_HXX
+#include <ooo/vba/msforms/XRadioButton.hpp>
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XRadioButton, css::script::XDefaultProperty > RadioButtonImpl_BASE;
+
+class ScVbaRadioButton : public RadioButtonImpl_BASE
+{
+public:
+    ScVbaRadioButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper );
+   // Attributes
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue(const com::sun::star::uno::Any&) throw (css::uno::RuntimeException);
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+
+};
+#endif //SC_VBA_RADIOBUTTON_HXX
Index: vbahelper/source/msforms/vbauserform.cxx
===================================================================
--- vbahelper/source/msforms/vbauserform.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbauserform.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,227 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+#include "vbauserform.hxx"
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XControlContainer.hpp>
+#include <com/sun/star/beans/PropertyConcept.hpp>
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbmeth.hxx>
+#include "vbacontrols.hxx"
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// some little notes
+// XDialog implementation has the following interesting bits
+// a Controls property ( which is an array of the container controls )
+//   each item in the controls array is a XControl, where the model is 
+//   basically a property bag
+// additionally the XDialog instance has itself a model
+//     this model has a ControlModels ( array of models ) property
+//     the models in ControlModels can be accessed by name
+// also the XDialog is a XControl ( to access the model above
+
+ScVbaUserForm::ScVbaUserForm( uno::Sequence< uno::Any > const& aArgs, uno::Reference< uno::XComponentContext >const& xContext ) throw ( lang::IllegalArgumentException ) :  ScVbaUserForm_BASE( getXSomethingFromArgs< XHelperInterface >( aArgs, 0 ), xContext, getXSomethingFromArgs< uno::XInterface >( aArgs, 1 ), getXSomethingFromArgs< frame::XModel >( aArgs, 2 ), static_cast< ooo::vba::AbstractGeometryAttributes* >(0) ),  mbDispose( true )
+{
+    m_xDialog.set( m_xControl, uno::UNO_QUERY_THROW );
+    uno::Reference< awt::XControl > xControl( m_xDialog, uno::UNO_QUERY_THROW );
+    m_xProps.set( xControl->getModel(), uno::UNO_QUERY_THROW );
+    setGeometryHelper( new UserFormGeometryHelper( xContext, xControl ) );
+}
+
+ScVbaUserForm::~ScVbaUserForm()
+{
+}
+
+void SAL_CALL 
+ScVbaUserForm::Show(  ) throw (uno::RuntimeException)
+{
+	OSL_TRACE("ScVbaUserForm::Show(  )");
+	short aRet = 0;
+        mbDispose = true;
+	if ( m_xDialog.is() )
+		aRet = m_xDialog->execute();
+	OSL_TRACE("ScVbaUserForm::Show() execute returned %d", aRet);
+	if ( mbDispose )
+	{
+		try
+		{
+			uno::Reference< lang::XComponent > xComp( m_xDialog, uno::UNO_QUERY_THROW );
+			m_xDialog = NULL;
+			xComp->dispose();
+			mbDispose = false; 
+		}
+		catch( uno::Exception& )
+		{
+		}
+	}
+}
+
+rtl::OUString SAL_CALL 
+ScVbaUserForm::getCaption() throw (::com::sun::star::uno::RuntimeException)
+{
+    rtl::OUString sCaption;
+    m_xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Title") ) ) >>= sCaption;
+    return sCaption;
+}
+void
+ScVbaUserForm::setCaption( const ::rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Title") ), uno::makeAny( _caption ) );
+}
+
+void SAL_CALL 
+ScVbaUserForm::Hide(  ) throw (uno::RuntimeException)
+{
+	mbDispose = false;  // hide not dispose
+	if ( m_xDialog.is() )
+		m_xDialog->endExecute();
+}
+
+void SAL_CALL 
+ScVbaUserForm::RePaint(  ) throw (uno::RuntimeException)
+{
+	// do nothing
+}
+
+void SAL_CALL 
+ScVbaUserForm::UnloadObject(  ) throw (uno::RuntimeException)
+{
+	mbDispose = true;
+	if ( m_xDialog.is() )
+		m_xDialog->endExecute();
+}
+
+rtl::OUString& 
+ScVbaUserForm::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaUserForm") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaUserForm::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.UserForm" ) );
+	}
+	return aServiceNames;
+}
+
+uno::Reference< beans::XIntrospectionAccess > SAL_CALL 
+ScVbaUserForm::getIntrospection(  ) throw (uno::RuntimeException)
+{
+	return uno::Reference< beans::XIntrospectionAccess >();
+}
+
+uno::Any SAL_CALL 
+ScVbaUserForm::invoke( const ::rtl::OUString& /*aFunctionName*/, const uno::Sequence< uno::Any >& /*aParams*/, uno::Sequence< ::sal_Int16 >& /*aOutParamIndex*/, uno::Sequence< uno::Any >& /*aOutParam*/ ) throw (lang::IllegalArgumentException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	throw uno::RuntimeException(); // unsupported operation
+}
+
+void SAL_CALL 
+ScVbaUserForm::setValue( const ::rtl::OUString& aPropertyName, const uno::Any& aValue ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	uno::Any aObject = getValue( aPropertyName );
+	// The Object *must* support XDefaultProperty here because getValue will
+	// only return properties that are Objects ( e.g. controls )
+	// e.g. Userform1.aControl = something
+	// 'aControl' has to support XDefaultProperty to make sense here
+	uno::Reference< script::XDefaultProperty > xDfltProp( aObject, uno::UNO_QUERY_THROW );
+	rtl::OUString aDfltPropName = xDfltProp->getDefaultPropertyName();
+	uno::Reference< beans::XIntrospectionAccess > xUnoAccess( getIntrospectionAccess( aObject ) );
+	uno::Reference< beans::XPropertySet > xPropSet( xUnoAccess->queryAdapter( ::getCppuType( (const uno::Reference< beans::XPropertySet > *)0 ) ), uno::UNO_QUERY_THROW );
+	xPropSet->setPropertyValue( aDfltPropName, aValue );
+}
+
+uno::Any SAL_CALL 
+ScVbaUserForm::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::UnknownPropertyException, uno::RuntimeException)
+{
+	uno::Reference< awt::XControl > xDialogControl( m_xDialog, uno::UNO_QUERY_THROW );
+	uno::Reference< awt::XControlContainer > xContainer( m_xDialog, uno::UNO_QUERY_THROW );
+	uno::Reference< awt::XControl > xControl = xContainer->getControl( aPropertyName );
+	ScVbaControlFactory aFac( mxContext, xControl, m_xModel );
+        uno::Reference< msforms::XControl > xVBAControl( aFac.createControl( xDialogControl->getModel() ) );
+        ScVbaControl* pControl  = dynamic_cast< ScVbaControl* >( xVBAControl.get() );
+        pControl->setGeometryHelper( new UserFormGeometryHelper( mxContext, xControl ) );
+	return uno::makeAny( xVBAControl );
+}
+
+::sal_Bool SAL_CALL 
+ScVbaUserForm::hasMethod( const ::rtl::OUString& /*aName*/ ) throw (uno::RuntimeException)
+{
+	return sal_False;
+}
+uno::Any SAL_CALL 
+ScVbaUserForm::Controls( const uno::Any& index ) throw (uno::RuntimeException)
+{
+	uno::Reference< awt::XControl > xDialogControl( m_xDialog, uno::UNO_QUERY_THROW );
+	uno::Reference< XCollection > xControls( new ScVbaControls( this, mxContext, xDialogControl ) );
+	if ( index.hasValue() )
+		return uno::makeAny( xControls->Item( index, uno::Any() ) );
+	return uno::makeAny( xControls );
+}
+
+::sal_Bool SAL_CALL 
+ScVbaUserForm::hasProperty( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+{
+	uno::Reference< awt::XControl > xControl( m_xDialog, uno::UNO_QUERY );
+	OSL_TRACE("ScVbaUserForm::hasProperty(%s) %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), xControl.is() );
+	if ( xControl.is() )
+	{
+		uno::Reference< container::XNameAccess > xNameAccess( xControl->getModel(), uno::UNO_QUERY_THROW );	
+		sal_Bool bRes =  xNameAccess->hasByName( aName );
+	OSL_TRACE("ScVbaUserForm::hasProperty(%s) %d ---> %d", rtl::OUStringToOString( aName, RTL_TEXTENCODING_UTF8 ).getStr(), xControl.is(), bRes );
+		return bRes;
+	}
+	return sal_False;
+}
+
+namespace userform
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaUserForm, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "ScVbaUserForm",
+    "ooo.vba.msforms.UserForm" );
+}
+
Index: vbahelper/source/msforms/vbatextbox.hxx
===================================================================
--- vbahelper/source/msforms/vbatextbox.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbatextbox.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbatextbox.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_TEXTBOX_HXX
+#define SC_VBA_TEXTBOX_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <ooo/vba/msforms/XTextBox.hpp>
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper2< ScVbaControl, ov::msforms::XTextBox, css::script::XDefaultProperty > TextBoxImpl_BASE;
+
+class ScVbaTextBox : public TextBoxImpl_BASE
+{
+    bool mbDialog;
+public:
+    ScVbaTextBox( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper, bool bDialog = false );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setText( const rtl::OUString& _text ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxLength() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMaxLength( sal_Int32 _maxlength ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getMultiline() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMultiline( sal_Bool _multiline ) throw (css::uno::RuntimeException);
+    // XDefaultProperty
+    rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_TEXTBOX_HXX
Index: vbahelper/source/msforms/vbapages.hxx
===================================================================
--- vbahelper/source/msforms/vbapages.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbapages.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PAGES_HXX
+#define SC_VBA_PAGES_HXX
+
+#include <ooo/vba/office/MsoShapeType.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/msforms/XPages.hpp>
+#include <cppuhelper/implbase2.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+#include <vbahelper/vbacollectionimpl.hxx>
+typedef CollTestImplHelper< 
+ov::msforms::XPages > ScVbaPages_BASE;
+
+class ScVbaPages : public ScVbaPages_BASE
+{
+protected:
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+public:
+    ScVbaPages( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xPages ) throw ( css::lang::IllegalArgumentException );
+    virtual ~ScVbaPages() {}
+        // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+     // ScVbaPages_BASE
+     virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+};
+#endif//SC_VBA_SHAPE_HXX
Index: vbahelper/source/msforms/vbaspinbutton.cxx
===================================================================
--- vbahelper/source/msforms/vbaspinbutton.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaspinbutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaspinbutton.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString ORIENTATION( RTL_CONSTASCII_USTRINGPARAM("Orientation") );
+const static rtl::OUString SPINVALUE( RTL_CONSTASCII_USTRINGPARAM("SpinValue") );
+const static rtl::OUString SPINMAX( RTL_CONSTASCII_USTRINGPARAM("SpinValueMax") );
+const static rtl::OUString SPINMIN( RTL_CONSTASCII_USTRINGPARAM("SpinValueMin") );
+
+ScVbaSpinButton::ScVbaSpinButton(  const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : SpinButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+uno::Any SAL_CALL 
+ScVbaSpinButton::getValue() throw (css::uno::RuntimeException)
+{
+    return  m_xProps->getPropertyValue( SPINVALUE );
+}
+
+void SAL_CALL 
+ScVbaSpinButton::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SPINVALUE, _value );
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaSpinButton::getMax() throw (uno::RuntimeException)
+{
+    sal_Int32 nMax = 0;
+    m_xProps->getPropertyValue( SPINMAX ) >>= nMax;
+    return nMax;
+}
+
+void SAL_CALL 
+ScVbaSpinButton::setMax( sal_Int32 nVal ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SPINMAX, uno::makeAny( nVal ) ); 
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaSpinButton::getMin() throw (uno::RuntimeException)
+{
+    sal_Int32 nVal = 0;
+    m_xProps->getPropertyValue( SPINMIN ) >>= nVal;
+    return nVal;
+}
+
+void SAL_CALL 
+ScVbaSpinButton::setMin( sal_Int32 nVal ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SPINMIN, uno::makeAny( nVal ) ); 
+}
+
+rtl::OUString& 
+ScVbaSpinButton::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaSpinButton") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaSpinButton::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/service.cxx
===================================================================
--- vbahelper/source/msforms/service.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/service.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: service.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+#include "comphelper/servicedecl.hxx"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace sdecl = comphelper::service_decl;
+
+// reference service helper(s)
+namespace  controlprovider
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
+namespace  userform
+{
+extern sdecl::ServiceDecl const serviceDecl;
+}
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+    {
+		OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_writeInfo");
+
+	// Component registration
+         return component_writeInfoHelper( pServiceManager, pRegistryKey, 
+		controlprovider::serviceDecl, userform::serviceDecl );
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_getFactory for %s", pImplName );
+	void* pRet =  component_getFactoryHelper(
+        	pImplName, pServiceManager, pRegistryKey, controlprovider::serviceDecl, userform::serviceDecl );
+	OSL_TRACE("Ret is 0x%x", pRet);
+	return pRet;
+    }
+}
Index: vbahelper/source/msforms/vbauserform.hxx
===================================================================
--- vbahelper/source/msforms/vbauserform.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbauserform.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_USERFORM_HXX
+#define SC_VBA_USERFORM_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XUserForm.hpp>
+#include <com/sun/star/awt/XDialog.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbacontrol.hxx"
+
+//typedef InheritedHelperInterfaceImpl1< ov::msforms::XUserForm > ScVbaUserForm_BASE;
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XUserForm > ScVbaUserForm_BASE;
+
+class ScVbaUserForm : public ScVbaUserForm_BASE
+{
+private:
+    css::uno::Reference< css::awt::XDialog > m_xDialog;
+    bool mbDispose;
+protected:
+public:
+    ScVbaUserForm( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext ) throw ( css::lang::IllegalArgumentException );
+    virtual ~ScVbaUserForm();
+    // XUserForm
+    virtual void SAL_CALL RePaint(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Show(  ) throw (css::uno::RuntimeException);
+    // XIntrospection
+    virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const ::rtl::OUString& aPropertyName, const css::uno::Any& aValue ) throw (css::beans::UnknownPropertyException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getValue( const ::rtl::OUString& aPropertyName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasMethod( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasProperty( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL Hide(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL UnloadObject(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& index ) throw (css::uno::RuntimeException);
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif
Index: vbahelper/source/msforms/vbaspinbutton.hxx
===================================================================
--- vbahelper/source/msforms/vbaspinbutton.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbaspinbutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SPINBUTTON_HXX
+#define SC_VBA_SPINBUTTON_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XSpinButton.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XSpinButton > SpinButtonImpl_BASE;
+
+class ScVbaSpinButton : public SpinButtonImpl_BASE
+{
+public:
+    ScVbaSpinButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
+   // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMax() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMax( ::sal_Int32 _max ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getMin() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMin( ::sal_Int32 _min ) throw (css::uno::RuntimeException);
+
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_SPINBUTTON_HXX
Index: vbahelper/source/msforms/vbabutton.cxx
===================================================================
--- vbahelper/source/msforms/vbabutton.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbabutton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbabutton.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbabutton.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LABEL( RTL_CONSTASCII_USTRINGPARAM("Label") );
+ScVbaButton::ScVbaButton( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ButtonImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaButton::getCaption() throw (css::uno::RuntimeException)
+{
+    rtl::OUString Label;
+    m_xProps->getPropertyValue( LABEL ) >>= Label;
+    return Label;
+}
+
+void SAL_CALL 
+ScVbaButton::setCaption( const rtl::OUString& _caption ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LABEL, uno::makeAny( _caption ) );
+}
+
+rtl::OUString& 
+ScVbaButton::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaButton") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaButton::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Button" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/msforms/vbabutton.hxx
===================================================================
--- vbahelper/source/msforms/vbabutton.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbabutton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbabutton.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_BUTTON_HXX
+#define SC_VBA_BUTTON_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/msforms/XButton.hpp>
+
+#include "vbacontrol.hxx"
+#include <vbahelper/vbahelper.hxx>
+
+typedef cppu::ImplInheritanceHelper1< ScVbaControl, ov::msforms::XButton > ButtonImpl_BASE;
+
+class ScVbaButton : public ButtonImpl_BASE
+{
+public:
+    ScVbaButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::uno::XInterface >& xControl, const css::uno::Reference< css::frame::XModel >& xModel, ov::AbstractGeometryAttributes* pGeomHelper  );
+   // Attributes
+    virtual rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    //XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif //SC_VBA_BUTTON_HXX
Index: vbahelper/source/msforms/vbascrollbar.cxx
===================================================================
--- vbahelper/source/msforms/vbascrollbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/msforms/vbascrollbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,139 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbascrollbar.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+const static rtl::OUString LARGECHANGE( RTL_CONSTASCII_USTRINGPARAM("BlockIncrement") );
+const static rtl::OUString SMALLCHANGE( RTL_CONSTASCII_USTRINGPARAM("LineIncrement") );
+const static rtl::OUString ORIENTATION( RTL_CONSTASCII_USTRINGPARAM("Orientation") );
+const static rtl::OUString SCROLLVALUE( RTL_CONSTASCII_USTRINGPARAM("ScrollValue") );
+const static rtl::OUString SCROLLMAX( RTL_CONSTASCII_USTRINGPARAM("ScrollValueMax") );
+const static rtl::OUString SCROLLMIN( RTL_CONSTASCII_USTRINGPARAM("ScrollValueMin") );
+
+ScVbaScrollBar::ScVbaScrollBar(  const css::uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< uno::XInterface >& xControl, const uno::Reference< frame::XModel >& xModel, AbstractGeometryAttributes* pGeomHelper ) : ScrollBarImpl_BASE( xParent, xContext, xControl, xModel, pGeomHelper )
+{
+}
+
+// Attributes
+uno::Any SAL_CALL 
+ScVbaScrollBar::getValue() throw (css::uno::RuntimeException)
+{
+    return  m_xProps->getPropertyValue( SCROLLVALUE );
+}
+
+void SAL_CALL 
+ScVbaScrollBar::setValue( const uno::Any& _value ) throw (::com::sun::star::uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SCROLLVALUE, _value );
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaScrollBar::getMax() throw (uno::RuntimeException)
+{
+    sal_Int32 nMax = 0;
+    m_xProps->getPropertyValue( SCROLLMAX ) >>= nMax;
+    return nMax;
+}
+
+void SAL_CALL 
+ScVbaScrollBar::setMax( sal_Int32 nVal ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SCROLLMAX, uno::makeAny( nVal ) ); 
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaScrollBar::getMin() throw (uno::RuntimeException)
+{
+    sal_Int32 nVal = 0;
+    m_xProps->getPropertyValue( SCROLLMIN ) >>= nVal;
+    return nVal;
+}
+
+void SAL_CALL 
+ScVbaScrollBar::setMin( sal_Int32 nVal ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SCROLLMIN, uno::makeAny( nVal ) ); 
+}
+
+void SAL_CALL 
+ScVbaScrollBar::setLargeChange( ::sal_Int32 _largechange ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( LARGECHANGE, uno::makeAny( _largechange ) );
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaScrollBar::getLargeChange() throw (uno::RuntimeException)
+{
+    sal_Int32 nVal = 0;
+    m_xProps->getPropertyValue( LARGECHANGE ) >>= nVal;
+    return nVal;
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaScrollBar::getSmallChange() throw (uno::RuntimeException)
+{
+    sal_Int32 nSmallChange = 0;
+    m_xProps->getPropertyValue( SMALLCHANGE ) >>= nSmallChange;
+    return nSmallChange;
+}
+
+void SAL_CALL 
+ScVbaScrollBar::setSmallChange( ::sal_Int32 _smallchange ) throw (uno::RuntimeException)
+{
+    m_xProps->setPropertyValue( SMALLCHANGE, uno::makeAny( _smallchange ) );
+}
+
+rtl::OUString& 
+ScVbaScrollBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaScrollBar") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaScrollBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.Frame" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbaglobalbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbaglobalbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbaglobalbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,126 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbahelper/vbaglobalbase.hxx"
+
+#include <cppuhelper/component_context.hxx>
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/container/XNameContainer.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+rtl::OUString sApplication( RTL_CONSTASCII_USTRINGPARAM("Application") );
+
+VbaGlobalsBase::VbaGlobalsBase( 
+const uno::Reference< ov::XHelperInterface >& xParent, 
+const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sDocCtxName ) 
+:  Globals_BASE( xParent, xContext )
+{
+    // overwrite context with custom one ( that contains the application )
+    ::cppu::ContextEntry_Init aHandlerContextInfo[] =
+    {
+        ::cppu::ContextEntry_Init( sApplication, uno::Any() ), 
+        ::cppu::ContextEntry_Init( sDocCtxName, uno::Any() ), 
+    };
+
+    mxContext = ::cppu::createComponentContext( aHandlerContextInfo, sizeof( aHandlerContextInfo ) / sizeof( aHandlerContextInfo[0] ), xContext );
+
+}
+
+
+void
+VbaGlobalsBase::init(  const uno::Sequence< beans::PropertyValue >& aInitArgs )
+{
+    sal_Int32 nLen = aInitArgs.getLength();
+    for ( sal_Int32 nIndex = 0; nIndex < nLen; ++nIndex )
+    {
+        uno::Reference< container::XNameContainer > xNameContainer( mxContext, uno::UNO_QUERY_THROW );
+        if ( aInitArgs[ nIndex ].Name.equals( sApplication ) )
+        {
+            xNameContainer->replaceByName( sApplication, aInitArgs[ nIndex ].Value );
+            uno::Reference< XHelperInterface > xParent( aInitArgs[ nIndex ].Value, uno::UNO_QUERY );
+            mxParent = xParent;
+        }
+        else 
+            xNameContainer->replaceByName( aInitArgs[ nIndex ].Name, aInitArgs[ nIndex ].Value );
+    }
+}
+
+uno::Reference< uno::XInterface > SAL_CALL 
+VbaGlobalsBase::createInstance( const ::rtl::OUString& aServiceSpecifier ) throw (uno::Exception, uno::RuntimeException)
+{
+    uno::Reference< uno::XInterface > xReturn;
+
+    if ( hasServiceName( aServiceSpecifier ) )
+        xReturn = mxContext->getServiceManager()->createInstanceWithContext( aServiceSpecifier, mxContext );
+    return xReturn;
+}
+
+uno::Reference< uno::XInterface > SAL_CALL 
+VbaGlobalsBase::createInstanceWithArguments( const ::rtl::OUString& ServiceSpecifier, const uno::Sequence< uno::Any >& Arguments ) throw (uno::Exception, uno::RuntimeException)
+{
+    
+    uno::Reference< uno::XInterface > xReturn;
+
+    if ( hasServiceName( ServiceSpecifier ) )
+        xReturn = mxContext->getServiceManager()->createInstanceWithArgumentsAndContext( ServiceSpecifier, Arguments, mxContext );
+    return xReturn;
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL 
+VbaGlobalsBase::getAvailableServiceNames(  ) throw (uno::RuntimeException)
+{
+    static const rtl::OUString names[] = { 
+    // common
+        ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ( "ooo.vba.msforms.UserForm" ) ),
+      };
+    static uno::Sequence< rtl::OUString > serviceNames( names, sizeof( names )/ sizeof( names[0] ) );
+    return serviceNames;
+}
+
+bool
+VbaGlobalsBase::hasServiceName( const rtl::OUString& serviceName )
+{
+    uno::Sequence< rtl::OUString > sServiceNames( getAvailableServiceNames() );
+    sal_Int32 nLen = sServiceNames.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index )
+    {
+        if ( sServiceNames[ index ].equals( serviceName ) )
+            return true;
+    }
+    return false;
+}
+
+
Index: vbahelper/source/vbahelper/vbadocumentsbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbadocumentsbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbadocumentsbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,305 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbadocumentsbase.hxx>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase3.hxx>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/frame/XComponentLoader.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/FrameSearchFlag.hpp>
+#include <com/sun/star/util/XModifiable.hpp>
+#include <com/sun/star/frame/XStorable.hpp>
+#include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/beans/PropertyVetoException.hpp>
+#include <com/sun/star/util/XCloseable.hpp>
+#include <com/sun/star/lang/IndexOutOfBoundsException.hpp>
+#include <com/sun/star/document/XTypeDetection.hpp>
+#include <com/sun/star/document/MacroExecMode.hpp>
+#include <com/sun/star/uri/XUriReference.hpp>
+#include <com/sun/star/uri/XUriReferenceFactory.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <sfx2/objsh.hxx>
+#include <tools/urlobj.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include <hash_map>
+#include <osl/file.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+static const rtl::OUString sSpreadsheetDocument( rtl::OUString::createFromAscii( "com.sun.star.sheet.SpreadsheetDocument" ) );
+static const rtl::OUString sTextDocument( rtl::OUString::createFromAscii( "com.sun.star.text.TextDocument" ) );
+
+typedef  std::hash_map< rtl::OUString,
+sal_Int32, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameIndexHash;
+
+typedef std::vector < uno::Reference< frame::XModel > > Documents;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > DocumentsEnumImpl_BASE;
+
+// #FIXME clearly this is a candidate for some sort of helper base class as
+// this is a copy of SelectedSheetsEnum ( vbawindow.cxx )
+
+class DocumentsEnumImpl : public DocumentsEnumImpl_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	Documents m_documents;
+	Documents::const_iterator m_it;
+
+public:
+	DocumentsEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const Documents& docs ) throw ( uno::RuntimeException ) :  m_xContext( xContext ), m_documents( docs )
+	{
+		m_it = m_documents.begin();
+	}
+	DocumentsEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException ) :  m_xContext( xContext )
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr(
+			m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+		uno::Reference< frame::XDesktop > xDesktop
+			(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), m_xContext), uno::UNO_QUERY_THROW );
+		uno::Reference< container::XEnumeration > mxComponents = xDesktop->getComponents()->createEnumeration();
+		while( mxComponents->hasMoreElements() )
+		{
+			uno::Reference< frame::XModel > xNext( mxComponents->nextElement(), uno::UNO_QUERY );
+			if ( xNext.is() )
+				m_documents.push_back( xNext );
+		}
+		m_it = m_documents.begin();
+	}
+	// XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_it != m_documents.end();
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( !hasMoreElements() )
+		{
+			throw container::NoSuchElementException();
+		}
+		return makeAny( *(m_it++) );
+	}
+};
+
+// #FIXME clearly this is also a candidate for some sort of helper base class as
+// a very similar one is used in vbawindow ( SelectedSheetsEnumAccess )
+// Maybe a template base class that does all of the operations on the hashmap
+// and vector only, and the sub-class does everything else
+// => ctor, createEnumeration & factory method need be defined ( to be called 
+// by getByIndex, getByName )
+typedef ::cppu::WeakImplHelper3< container::XEnumerationAccess 
+	, com::sun::star::container::XIndexAccess
+	, com::sun::star::container::XNameAccess
+	> DocumentsAccessImpl_BASE;
+
+class DocumentsAccessImpl : public DocumentsAccessImpl_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	Documents m_documents;
+	NameIndexHash namesToIndices;
+    VbaDocumentsBase::DOCUMENT_TYPE meDocType;
+public:	
+	DocumentsAccessImpl( const uno::Reference< uno::XComponentContext >& xContext, VbaDocumentsBase::DOCUMENT_TYPE eDocType ) throw (uno::RuntimeException) :m_xContext( xContext ), meDocType( eDocType )
+	{
+		uno::Reference< container::XEnumeration > xEnum = new DocumentsEnumImpl( m_xContext );
+		sal_Int32 nIndex=0;
+		while( xEnum->hasMoreElements() )
+		{
+            uno::Reference< lang::XServiceInfo > xServiceInfo( xEnum->nextElement(), uno::UNO_QUERY );
+			if ( xServiceInfo.is() 
+                && (  ( xServiceInfo->supportsService( sSpreadsheetDocument ) && meDocType == VbaDocumentsBase::EXCEL_DOCUMENT )
+                || ( xServiceInfo->supportsService( sTextDocument ) && meDocType == VbaDocumentsBase::WORD_DOCUMENT ) ) )
+			{
+				uno::Reference< frame::XModel > xModel( xServiceInfo, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
+				m_documents.push_back( xModel );
+				INetURLObject aURL( xModel->getURL() );
+				namesToIndices[ aURL.GetLastName() ] = nIndex++;
+			}
+		}
+			
+	}
+	
+	//XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new DocumentsEnumImpl( m_xContext, m_documents ); 
+	}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_documents.size();
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw ( lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( Index < 0 
+			|| static_cast< Documents::size_type >(Index) >= m_documents.size() ) 
+			throw lang::IndexOutOfBoundsException();
+		return makeAny( m_documents[ Index ] ); // returns xspreadsheetdoc
+	}
+
+	//XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{ 
+		return frame::XModel::static_type(0); 
+	}
+
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return (m_documents.size() > 0);
+	}
+
+	//XNameAccess
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		if ( it == namesToIndices.end() )
+			throw container::NoSuchElementException();
+		return makeAny( m_documents[ it->second ] );
+		
+	}
+
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException) 
+	{ 
+		uno::Sequence< ::rtl::OUString > names( namesToIndices.size() );
+		::rtl::OUString* pString = names.getArray();
+		NameIndexHash::const_iterator it = namesToIndices.begin();
+		NameIndexHash::const_iterator it_end = namesToIndices.end();
+		for ( ; it != it_end; ++it, ++pString )
+			*pString = it->first;	
+		return names;	
+	}
+
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		return (it != namesToIndices.end());
+	}
+
+};
+
+VbaDocumentsBase::VbaDocumentsBase( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< css::uno::XComponentContext >& xContext, DOCUMENT_TYPE eDocType ) throw (uno::RuntimeException) : VbaDocumentsBase_BASE( xParent, xContext, uno::Reference< container::XIndexAccess >( new DocumentsAccessImpl( xContext, eDocType ) ) ), meDocType( eDocType )
+{
+}
+
+uno::Any SAL_CALL
+VbaDocumentsBase::Add() throw (uno::RuntimeException)
+{
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+        mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+	 uno::Reference< frame::XComponentLoader > xLoader(
+        xSMgr->createInstanceWithContext(
+            ::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
+                mxContext), uno::UNO_QUERY_THROW );
+    rtl::OUString sURL;
+    if( meDocType == WORD_DOCUMENT )
+        sURL = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("private:factory/swriter") );
+    else if( meDocType == EXCEL_DOCUMENT )
+        sURL = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("private:factory/scalc") );
+    else
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL(
+									   sURL ,
+									   rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_blank") ), 0, 
+									   uno::Sequence< beans::PropertyValue >(0) );			   
+    return uno::makeAny( xComponent );
+}
+
+void
+VbaDocumentsBase::Close() throw (uno::RuntimeException)
+{
+// #FIXME this *MUST* be wrong documents::close surely closes ALL documents
+// in the collection, use of getCurrentDocument here is totally wrong
+/*
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+		mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CloseDoc"));
+	dispatchRequests(xModel,url);
+*/
+}
+
+// #TODO# #FIXME# can any of the unused params below be used?
+uno::Any
+VbaDocumentsBase::Open( const rtl::OUString& rFileName, const uno::Any& ReadOnly, const uno::Sequence< beans::PropertyValue >& rProps ) throw (uno::RuntimeException)
+{
+	// we need to detect if this is a URL, if not then assume its a file path
+        rtl::OUString aURL;
+        INetURLObject aObj;
+	aObj.SetURL( rFileName );
+	bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+	if ( bIsURL )
+		aURL = rFileName;
+	else
+		osl::FileBase::getFileURLFromSystemPath( rFileName, aURL );
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+		mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XDesktop > xDesktop
+		(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop")                    , mxContext),
+		uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XComponentLoader > xLoader(
+		xSMgr->createInstanceWithContext(
+		::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
+		mxContext),
+		uno::UNO_QUERY_THROW );
+
+	uno::Sequence< beans::PropertyValue > sProps( rProps );
+	sProps.realloc( sProps.getLength() + 1 );
+	sProps[ sProps.getLength() - 1 ].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("MacroExecutionMode") );
+	sProps[ sProps.getLength() - 1 ].Value <<= uno::makeAny( document::MacroExecMode::ALWAYS_EXECUTE_NO_WARN );
+
+	sal_Int32 nIndex = sProps.getLength() - 1;
+	
+	if ( ReadOnly.hasValue()  )
+	{
+		sal_Bool bIsReadOnly = sal_False; ReadOnly >>= bIsReadOnly;
+		if ( bIsReadOnly )
+		{
+			static const rtl::OUString sReadOnly( RTL_CONSTASCII_USTRINGPARAM("ReadOnly") );
+			sProps.realloc( sProps.getLength() + 1 );
+			sProps[ nIndex ].Name = sReadOnly;
+			sProps[ nIndex++ ].Value = uno::makeAny( (sal_Bool)sal_True );
+		}
+	}
+
+	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL( aURL,
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_default") ),
+		frame::FrameSearchFlag::CREATE,
+		sProps);
+    return uno::makeAny( xComponent );
+}
+
Index: vbahelper/source/vbahelper/vbafillformat.cxx
===================================================================
--- vbahelper/source/vbahelper/vbafillformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbafillformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbafillformat.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/awt/Gradient.hpp>
+#include <com/sun/star/awt/GradientStyle.hpp>
+#include <ooo/vba/office/MsoGradientStyle.hpp>
+#include "vbafillformat.hxx"
+#include "vbacolorformat.hxx"
+
+using namespace ooo::vba;
+using namespace com::sun::star;
+
+ScVbaFillFormat::ScVbaFillFormat( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape > xShape ) : ScVbaFillFormat_BASE( xParent, xContext ), m_xShape( xShape )
+{
+    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
+    m_nFillStyle = drawing::FillStyle_SOLID;
+    m_nForeColor = 0;
+    m_nBackColor = 0;
+    m_nGradientAngle = 0;
+}
+
+void
+ScVbaFillFormat::setFillStyle( drawing::FillStyle nFillStyle ) throw (uno::RuntimeException)
+{
+    m_nFillStyle = nFillStyle;
+    if( m_nFillStyle == drawing::FillStyle_GRADIENT )
+    {
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny( drawing::FillStyle_GRADIENT ) );
+        awt::Gradient aGradient;
+        // AXIAL
+        // RADIAL
+        // ELLIPTICAL
+        // SQUARE
+        // RECT
+        aGradient.Style = awt::GradientStyle_LINEAR;
+        aGradient.StartColor = ForeColor()->getRGB();
+        aGradient.EndColor = BackColor()->getRGB();
+        aGradient.Angle = m_nGradientAngle;
+        aGradient.Border = 0;
+        aGradient.XOffset = 0;
+        aGradient.YOffset = 0;
+        aGradient.StartIntensity = 100;
+        aGradient.EndIntensity = 100;
+        aGradient.StepCount = 1;
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillGradient"), uno::makeAny( aGradient ) );
+    }
+    else if( m_nFillStyle == drawing::FillStyle_SOLID )
+    {
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny(drawing::FillStyle_SOLID) );
+    }
+}
+
+void
+ScVbaFillFormat::setForeColorAndInternalStyle( sal_Int32 nForeColor ) throw (css::uno::RuntimeException)
+{
+    m_nForeColor = nForeColor;
+    setFillStyle( m_nFillStyle );
+}
+
+// Attributes
+sal_Bool SAL_CALL 
+ScVbaFillFormat::getVisible() throw (uno::RuntimeException)
+{
+    drawing::FillStyle nFillStyle;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillStyle") ) >>= nFillStyle;
+    if( nFillStyle == drawing::FillStyle_NONE )
+        return sal_False;
+    return sal_True;
+}
+
+void SAL_CALL 
+ScVbaFillFormat::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
+{
+    drawing::FillStyle aFillStyle;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillStyle") ) >>= aFillStyle;
+    if( !_visible )
+    {
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("FillStyle"), uno::makeAny( drawing::FillStyle_NONE ) );
+    }
+    else
+    {
+        if( aFillStyle == drawing::FillStyle_NONE )
+        {
+            setFillStyle( m_nFillStyle );
+        }
+    }
+}
+
+double SAL_CALL 
+ScVbaFillFormat::getTransparency() throw (uno::RuntimeException)
+{
+    sal_Int16 nTransparence = 0;
+    double dTransparence = 0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "FillTransparence" ) ) >>= nTransparence;
+    dTransparence = static_cast<double>( nTransparence );
+    dTransparence /= 100;
+    return dTransparence;
+}
+
+void SAL_CALL 
+ScVbaFillFormat::setTransparency( double _transparency ) throw (uno::RuntimeException)
+{
+    sal_Int16 nTransparence = static_cast< sal_Int16 >( _transparency * 100 );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillTransparence" ), uno::makeAny( nTransparence ) );
+}
+
+
+// Methods
+void SAL_CALL 
+ScVbaFillFormat::Solid() throw (uno::RuntimeException)
+{
+    setFillStyle( drawing::FillStyle_SOLID );
+}
+
+void SAL_CALL 
+ScVbaFillFormat::TwoColorGradient( sal_Int32 style, sal_Int32 /*variant*/ ) throw (uno::RuntimeException)
+{
+    if( style == office::MsoGradientStyle::msoGradientHorizontal )
+    {
+        m_nGradientAngle = 0;
+        setFillStyle( drawing::FillStyle_GRADIENT );
+    }
+    else if( style == office::MsoGradientStyle::msoGradientVertical )
+    {
+        m_nGradientAngle = 900;
+        setFillStyle( drawing::FillStyle_GRADIENT );
+    }
+    else if( style == office::MsoGradientStyle::msoGradientDiagonalDown )
+    {
+        m_nGradientAngle = 450;
+        setFillStyle( drawing::FillStyle_GRADIENT );
+    }
+    else if( style == office::MsoGradientStyle::msoGradientDiagonalUp )
+    {
+        m_nGradientAngle = 900 + 450;
+        setFillStyle( drawing::FillStyle_GRADIENT );
+    }
+}
+
+uno::Reference< msforms::XColorFormat > SAL_CALL 
+ScVbaFillFormat::BackColor() throw (uno::RuntimeException)
+{
+    if( !m_xColorFormat.is() )
+        m_xColorFormat.set( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ColorFormatType::FILLFORMAT_BACKCOLOR ) );
+    return m_xColorFormat;
+}
+
+uno::Reference< msforms::XColorFormat > SAL_CALL 
+ScVbaFillFormat::ForeColor() throw (uno::RuntimeException)
+{
+    if( !m_xColorFormat.is() )
+        m_xColorFormat.set( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ColorFormatType::FILLFORMAT_FORECOLOR ) );
+    return m_xColorFormat;
+}
+
+
+rtl::OUString&
+ScVbaFillFormat::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaFillFormat") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+ScVbaFillFormat::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.FillFormat" ) );
+    }
+    return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbalineformat.cxx
===================================================================
--- vbahelper/source/vbahelper/vbalineformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbalineformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,458 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalineformat.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <ooo/vba/office/MsoArrowheadStyle.hpp>
+#include <ooo/vba/office/MsoArrowheadLength.hpp>
+#include <ooo/vba/office/MsoArrowheadWidth.hpp>
+#include <ooo/vba/office/MsoLineDashStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/drawing/LineDash.hpp>
+#include "vbalineformat.hxx"
+#include "vbacolorformat.hxx"
+
+using namespace ooo::vba;
+using namespace com::sun::star;
+
+ScVbaLineFormat::ScVbaLineFormat( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape > xShape ) : ScVbaLineFormat_BASE( xParent, xContext ), m_xShape( xShape ) 
+{
+    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
+    m_nLineDashStyle = office::MsoLineDashStyle::msoLineSolid;
+    m_nLineWeight = 1;
+}
+
+sal_Int32
+ScVbaLineFormat::calculateArrowheadSize()
+{
+    return 0;
+}
+
+sal_Int32
+ScVbaLineFormat::convertLineStartEndNameToArrowheadStyle( rtl::OUString sLineName )
+{
+    sal_Int32 nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
+    if (sLineName.equals(rtl::OUString::createFromAscii("Small Arrow")) ||
+        sLineName.equals(rtl::OUString::createFromAscii("Arrow")) ||
+        sLineName.equals(rtl::OUString::createFromAscii("msArrowEnd")) ||
+        sLineName.equals(rtl::OUString::createFromAscii("Double Arrow")))
+    {
+        // msoArrowheadTriangle
+        nLineType = office::MsoArrowheadStyle::msoArrowheadTriangle;
+    }
+    else if (sLineName.equals(rtl::OUString::createFromAscii("Square 45")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("Square")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("msArrowDiamondEnd")))
+    {
+        // msoArrowheadDiamond
+        nLineType = office::MsoArrowheadStyle::msoArrowheadDiamond;
+    }
+    else if (sLineName.equals(rtl::OUString::createFromAscii("Circle")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("msArrowOvalEnd")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("Dimension Lines")) )
+    {
+        // msoArrowheadOval
+        nLineType = office::MsoArrowheadStyle::msoArrowheadOval;
+    }
+    else if (sLineName.equals(rtl::OUString::createFromAscii("Arrow concave")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("msArrowStealthEnd")))
+    {
+        // msoArrowheadStealth
+        nLineType = office::MsoArrowheadStyle::msoArrowheadStealth;
+    }
+    else if (sLineName.equals(rtl::OUString::createFromAscii("Rounded short Arrow")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("Rounded large Arrow")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("Symmetric Arrow")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("msArrowOpenEnd")) ||
+             sLineName.equals(rtl::OUString::createFromAscii("Line Arrow")))
+    {
+        // msoArrowheadOpen
+        nLineType = office::MsoArrowheadStyle::msoArrowheadOpen;
+    }
+    else
+    {
+        // msoArrowheadNone
+        nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
+    }
+    return nLineType;
+}
+
+rtl::OUString 
+ScVbaLineFormat::convertArrowheadStyleToLineStartEndName( sal_Int32 nArrowheadStyle ) throw (uno::RuntimeException)
+{
+    switch( nArrowheadStyle )
+    {
+        case office::MsoArrowheadStyle::msoArrowheadNone:
+            return rtl::OUString(rtl::OUString::createFromAscii( "" ) );
+        case office::MsoArrowheadStyle::msoArrowheadStealth:
+            return rtl::OUString::createFromAscii( "Arrow concave" );
+        case office::MsoArrowheadStyle::msoArrowheadOpen:
+            return rtl::OUString::createFromAscii("Line Arrow" );
+        case office::MsoArrowheadStyle::msoArrowheadOval:
+            return  rtl::OUString::createFromAscii("Circle" );
+        case office::MsoArrowheadStyle::msoArrowheadDiamond:
+            return rtl::OUString::createFromAscii( "Square 45" );
+        case office::MsoArrowheadStyle::msoArrowheadTriangle:
+            return rtl::OUString::createFromAscii( "Arrow" );
+        default:
+            throw uno::RuntimeException( rtl::OUString::createFromAscii("Invalid Arrow Style!"), uno::Reference< uno::XInterface >() );
+    }
+}
+
+// Attributes
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getBeginArrowheadStyle() throw (uno::RuntimeException)
+{
+    sal_Int32 nLineType = office::MsoArrowheadStyle::msoArrowheadNone;
+    rtl::OUString sLineName;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStartName" ) ) >>= sLineName;
+    if( ( sLineName.getLength() > 7 ) && ( sLineName.indexOf( rtl::OUString::createFromAscii( "msArray" ) ) ) != -1 )
+    {
+        sal_Int32 nIndex = sLineName.indexOf( rtl::OUString::createFromAscii(" ") );
+        rtl::OUString sName = sLineName.copy( 0, nIndex );
+        //sal_Int32 nSize = sLineName.copy( nIndex + 1 ).toInt32();
+        nLineType = convertLineStartEndNameToArrowheadStyle( sName );
+    }
+    else
+    {
+        nLineType = convertLineStartEndNameToArrowheadStyle( sLineName );
+    }
+    return nLineType;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setBeginArrowheadStyle( sal_Int32 _beginarrowheadstyle ) throw (uno::RuntimeException)
+{
+    rtl::OUString sArrayName = convertArrowheadStyleToLineStartEndName( _beginarrowheadstyle );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStartName" ), uno::makeAny( sArrayName ) );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getBeginArrowheadLength() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setBeginArrowheadLength( sal_Int32 /*_beginarrowheadlength*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getBeginArrowheadWidth() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setBeginArrowheadWidth( sal_Int32 /*_beginarrowheadwidth*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getEndArrowheadStylel() throw (uno::RuntimeException)
+{
+    return 0;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setEndArrowheadStylel( sal_Int32 /*_endarrowheadstylel*/ ) throw (uno::RuntimeException)
+{
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getEndArrowheadLength() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setEndArrowheadLength( sal_Int32 /*_endarrowheadlength*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getEndArrowheadWidth() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setEndArrowheadWidth( sal_Int32 /*_endarrowheadwidth*/ ) throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString::createFromAscii("Property 'EndArrowheadWidth' is not supported."), uno::Reference< uno::XInterface >() );
+}
+
+double SAL_CALL 
+ScVbaLineFormat::getWeight() throw (uno::RuntimeException)
+{
+    sal_Int32 nLineWidth=0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineWidth") ) >>= nLineWidth;
+    double dLineWidth = Millimeter::getInPoints( nLineWidth );
+    return dLineWidth;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setWeight( double _weight ) throw (uno::RuntimeException)
+{
+    if( _weight < 0 )
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter: Must be positv."), uno::Reference< uno::XInterface >() );
+    if( _weight == 0 )
+        _weight = 0.5;
+    m_nLineWeight = _weight;
+    Millimeter aMillimeter;
+    aMillimeter.setInPoints( _weight );
+        
+    sal_Int32 nLineWidth = static_cast<sal_Int32>( aMillimeter.getInHundredthsOfOneMillimeter() );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineWidth" ), uno::makeAny( nLineWidth ) );
+    setDashStyle( m_nLineDashStyle );
+}
+
+sal_Bool SAL_CALL 
+ScVbaLineFormat::getVisible() throw (uno::RuntimeException)
+{
+    drawing::LineStyle aLineStyle;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= aLineStyle;
+    if( aLineStyle == drawing::LineStyle_NONE )
+    {
+        return sal_False;
+    }
+    return sal_True;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
+{
+    drawing::LineStyle aLineStyle;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= aLineStyle;
+    if( !_visible )
+    {
+        aLineStyle = drawing::LineStyle_NONE;
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( aLineStyle ) );
+    }
+    else
+    {
+        if( aLineStyle == drawing::LineStyle_NONE )
+        {
+            setDashStyle( m_nLineDashStyle );
+        }
+    }
+}
+
+double SAL_CALL 
+ScVbaLineFormat::getTransparency() throw (uno::RuntimeException)
+{
+    sal_Int16 nTransparency = 0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineTransparence" ) ) >>= nTransparency;
+    double fTransparency = static_cast<double>( nTransparency );
+    return fTransparency / 100;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setTransparency( double _transparency ) throw (uno::RuntimeException)
+{
+    sal_Int16 nTransparency = static_cast<sal_Int16>( _transparency * 100 );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineTransparence" ), uno::makeAny( nTransparency ) );
+}
+
+sal_Int16 SAL_CALL 
+ScVbaLineFormat::getStyle() throw (uno::RuntimeException)
+{
+    //OpenOffice.org only supports one LineStyle (other than the DashStyles)
+    //Therefore we can only return the SingleLine
+    return 1;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setStyle( sal_Int16 /*_style */) throw (uno::RuntimeException)
+{
+    //OpenOffice.org only supports one LineStyle (other than the DashStyles)
+    //Therefore we do not set the LineStyle, because it maybe is already set
+    //to Dashed or Single Line. Setting the 'Visible' or 'DashStyle' properties
+    //will be done with the according methods.
+}
+
+sal_Int32 SAL_CALL 
+ScVbaLineFormat::getDashStyle() throw (uno::RuntimeException)
+{
+    drawing::LineStyle eLineStyle;
+    //LineStyle integer in Xray
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ) ) >>= eLineStyle;
+    if( eLineStyle == drawing::LineStyle_SOLID )
+        m_nLineDashStyle = office::MsoLineDashStyle::msoLineSolid;
+    else
+    {
+        drawing::LineDash aLineDash;
+        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "LineDash" ) ) >>= aLineDash;
+        if( aLineDash.Dots == 0 )
+        {
+            //LineDash
+            //LineLongDash
+            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDash;
+            if( aLineDash.Distance > 0 && ( aLineDash.DashLen / aLineDash.Distance > 1 ) )
+            {
+                m_nLineDashStyle = office::MsoLineDashStyle::msoLineLongDash;
+            }
+        }
+        else if( aLineDash.Dots == 1 )
+        {
+            // LineDashDot
+            // LineLongDashDot
+            // LineSquareDot
+            // LineRoundDot ! not supported
+            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDashDot;
+            if( aLineDash.Dashes == 0 )
+            {
+                m_nLineDashStyle = office::MsoLineDashStyle::msoLineSquareDot;
+            }
+            else
+            {
+                if( aLineDash.Distance > 0 && ( aLineDash.DashLen / aLineDash.Distance > 1 ) )
+                {
+                    m_nLineDashStyle = office::MsoLineDashStyle::msoLineLongDashDot;
+                }
+            }
+        }
+        else if( aLineDash.Dots == 2 )
+        {
+            // LineDashDotDot
+            m_nLineDashStyle = office::MsoLineDashStyle::msoLineDashDotDot;
+        }
+    }
+
+    return m_nLineDashStyle;
+}
+
+void SAL_CALL 
+ScVbaLineFormat::setDashStyle( sal_Int32 _dashstyle ) throw (uno::RuntimeException)
+{
+    m_nLineDashStyle = _dashstyle;
+    if( _dashstyle == office::MsoLineDashStyle::msoLineSolid )
+    {
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( drawing::LineStyle_SOLID  ));
+    }
+    else
+    {
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( drawing::LineStyle_DASH ) );
+        drawing::LineDash  pLineDash;
+        Millimeter aMillimeter( m_nLineWeight );
+        sal_Int32 nPixel = static_cast< sal_Int32 >( aMillimeter.getInHundredthsOfOneMillimeter() );
+        switch( _dashstyle )
+        {
+        case office::MsoLineDashStyle::msoLineDashDot:
+            pLineDash.Dots = 1;
+            pLineDash.DotLen = nPixel;
+            pLineDash.Dashes = 1;
+            pLineDash.DashLen = 5 * nPixel;
+            pLineDash.Distance = 4 * nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineLongDashDot:
+            pLineDash.Dots = 1;
+            pLineDash.DotLen = nPixel;
+            pLineDash.Dashes = 1;
+            pLineDash.DashLen = 10 * nPixel;
+            pLineDash.Distance = 4 * nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineDash:
+            pLineDash.Dots = 0;
+            pLineDash.DotLen = 0;
+            pLineDash.Dashes = 1;
+            pLineDash.DashLen = 6 * nPixel;
+            pLineDash.Distance = 4 * nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineDashDotDot:
+            pLineDash.Dots = 2;
+            pLineDash.DotLen = nPixel;
+            pLineDash.Dashes = 1;
+            pLineDash.DashLen = 10 * nPixel;
+            pLineDash.Distance = 3 * nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineLongDash:
+            pLineDash.Dots = 0;
+            pLineDash.DotLen = 0;
+            pLineDash.Dashes = 1;
+            pLineDash.DashLen = 10 * nPixel;
+            pLineDash.Distance = 4 * nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineSquareDot:
+            pLineDash.Dots = 1;
+            pLineDash.DotLen = nPixel;
+            pLineDash.Dashes = 0;
+            pLineDash.DashLen = 0;
+            pLineDash.Distance = nPixel;
+            break;
+        case office::MsoLineDashStyle::msoLineRoundDot:
+            pLineDash.Dots = 1;
+            pLineDash.DotLen = nPixel;
+            pLineDash.Dashes = 0;
+            pLineDash.DashLen = 0;
+            pLineDash.Distance = nPixel;
+            break;
+        default:
+            throw uno::RuntimeException( rtl::OUString::createFromAscii("this MsoLineDashStyle is not supported."), uno::Reference< uno::XInterface >() );
+        }
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineDash" ), uno::makeAny( pLineDash ) );
+    }
+}
+
+// Methods
+uno::Reference< msforms::XColorFormat > SAL_CALL
+ScVbaLineFormat::BackColor() throw (uno::RuntimeException)
+{
+    return uno::Reference< msforms::XColorFormat >( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ::ColorFormatType::LINEFORMAT_BACKCOLOR ) );
+}
+
+uno::Reference< msforms::XColorFormat > SAL_CALL
+ScVbaLineFormat::ForeColor() throw (uno::RuntimeException)
+{
+    return uno::Reference< msforms::XColorFormat >( new ScVbaColorFormat( getParent(), mxContext, this, m_xShape, ::ColorFormatType::LINEFORMAT_FORECOLOR ) );
+}
+
+
+rtl::OUString& 
+ScVbaLineFormat::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaLineFormat") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaLineFormat::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.LineFormat" ) );
+	}
+	return aServiceNames;
+}
+
+
Index: vbahelper/source/vbahelper/vbawindowbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbawindowbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbawindowbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,180 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+#include <vbahelper/vbawindowbase.hxx>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XWindow2.hpp>
+#include <com/sun/star/awt/PosSize.hpp>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+VbaWindowBase::VbaWindowBase( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ) : WindowBaseImpl_BASE( xParent, xContext ), m_xModel( xModel ) 
+{
+}
+
+VbaWindowBase::VbaWindowBase( uno::Sequence< uno::Any > const & args, uno::Reference< uno::XComponentContext > const & xContext )  
+        : WindowBaseImpl_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext ),
+          m_xModel( getXSomethingFromArgs< frame::XModel >( args, 1 ) )
+{
+}
+
+sal_Bool SAL_CALL
+VbaWindowBase::getVisible() throw (uno::RuntimeException)
+{
+	sal_Bool bVisible = sal_True;	
+	uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
+	uno::Reference< css::awt::XWindow2 > xWindow2 (xWindow, uno::UNO_QUERY_THROW );
+	if( xWindow2.is() )
+	{
+		bVisible = xWindow2->isVisible();	
+	}
+	return bVisible;
+}
+
+void SAL_CALL
+VbaWindowBase::setVisible(sal_Bool _visible) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XController > xController( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
+	if( xWindow.is() )
+	{
+		xWindow->setVisible( _visible );	
+	}
+}
+
+css::awt::Rectangle getPosSize( const uno::Reference< frame::XModel >& xModel )
+{
+	css::awt::Rectangle aRect;
+	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
+	if( xWindow.is() )
+	{
+		aRect = xWindow->getPosSize();
+	}
+	return aRect;
+}
+
+void setPosSize( const uno::Reference< frame::XModel >& xModel, sal_Int32 nValue, USHORT nFlag )
+{
+	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< css::awt::XWindow > xWindow (xController->getFrame()->getContainerWindow(), uno::UNO_QUERY_THROW );
+	if( xWindow.is() )
+	{
+		css::awt::Rectangle aRect = xWindow->getPosSize();
+		switch( nFlag )
+		{
+			case css::awt::PosSize::X:
+				xWindow->setPosSize( nValue, aRect.Y,	0, 0, css::awt::PosSize::X );
+				break;
+			case css::awt::PosSize::Y:
+				xWindow->setPosSize( aRect.X, nValue,	0, 0, css::awt::PosSize::Y );
+				break;
+			case css::awt::PosSize::WIDTH:
+				xWindow->setPosSize( 0, 0,	nValue, aRect.Height, css::awt::PosSize::WIDTH );
+				break;
+			case css::awt::PosSize::HEIGHT:
+				xWindow->setPosSize( 0, 0,	aRect.Width, nValue, css::awt::PosSize::HEIGHT );
+				break;
+			default:
+				break;
+		}
+	}
+}	
+
+sal_Int32 SAL_CALL 
+VbaWindowBase::getHeight() throw (uno::RuntimeException)
+{
+	css::awt::Rectangle aRect = getPosSize(m_xModel);
+	return aRect.Height;
+}
+
+void SAL_CALL 
+VbaWindowBase::setHeight( sal_Int32 _height ) throw (uno::RuntimeException)
+{
+	setPosSize(m_xModel, _height, css::awt::PosSize::HEIGHT);
+}
+
+sal_Int32 SAL_CALL 
+VbaWindowBase::getLeft() throw (uno::RuntimeException)
+{
+	css::awt::Rectangle aRect = getPosSize(m_xModel);
+	return aRect.X;
+}
+
+void SAL_CALL 
+VbaWindowBase::setLeft( sal_Int32 _left ) throw (uno::RuntimeException)
+{
+	setPosSize(m_xModel, _left, css::awt::PosSize::X);
+}
+sal_Int32 SAL_CALL 
+VbaWindowBase::getTop() throw (uno::RuntimeException)
+{
+	css::awt::Rectangle aRect = getPosSize(m_xModel);
+	return aRect.Y;
+}
+
+void SAL_CALL 
+VbaWindowBase::setTop( sal_Int32 _top ) throw (uno::RuntimeException)
+{
+	setPosSize(m_xModel, _top, css::awt::PosSize::Y);
+}
+sal_Int32 SAL_CALL 
+VbaWindowBase::getWidth() throw (uno::RuntimeException)
+{
+	css::awt::Rectangle aRect = getPosSize(m_xModel);
+	return aRect.Width;
+}
+
+void SAL_CALL 
+VbaWindowBase::setWidth( sal_Int32 _width ) throw (uno::RuntimeException)
+{
+	setPosSize(m_xModel, _width, css::awt::PosSize::WIDTH);
+}
+
+rtl::OUString& 
+VbaWindowBase::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaWindowBase") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+VbaWindowBase::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.VbaWindowBase" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbacommandbar.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,212 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacommandbar.hxx" 
+#include "vbacommandbarcontrols.hxx" 
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <ooo/vba/office/MsoBarType.hpp>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaCommandBar::ScVbaCommandBar( const uno::Reference< ov::XHelperInterface > xParent, const uno::Reference< uno::XComponentContext > xContext, VbaCommandBarHelperRef pHelper, const uno::Reference< container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Bool bIsMenu, sal_Bool bTemporary ) throw( uno::RuntimeException ) : CommandBar_BASE( xParent, xContext ), pCBarHelper( pHelper ), m_xBarSettings( xBarSettings ), m_sResourceUrl( sResourceUrl ), m_bIsMenu( bIsMenu ), m_bTemporary( bTemporary )
+{
+}
+
+::rtl::OUString SAL_CALL
+ScVbaCommandBar::getName() throw ( uno::RuntimeException )
+{
+    // This will get a "NULL length string" when Name is not set. 
+    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
+    uno::Any aName = xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("UIName") );
+    rtl::OUString sName;
+    aName >>= sName;
+    if( sName.getLength() < 1 )
+    {
+        if( m_bIsMenu )
+        {
+            if( m_sResourceUrl.equalsAscii( ITEM_MENUBAR_URL ) )
+            {
+                if( pCBarHelper->getModuleId().equalsAscii("com.sun.star.sheet.SpreadsheetDocument") )
+                    sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Worksheet Menu Bar") );
+                else if( pCBarHelper->getModuleId().equalsAscii("com.sun.star.text.TextDocument") )
+                    sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Menu Bar") );
+                return sName;    
+            }
+        }
+        // Toolbar name
+        uno::Reference< container::XNameAccess > xNameAccess = pCBarHelper->getPersistentWindowState();
+        if( xNameAccess->hasByName( m_sResourceUrl ) )
+        {
+            uno::Sequence< beans::PropertyValue > aToolBar; 
+            xNameAccess->getByName( m_sResourceUrl ) >>= aToolBar;
+            getPropertyValue( aToolBar, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ) ) >>= sName;
+        }
+    }
+    return sName;
+}
+void SAL_CALL 
+ScVbaCommandBar::setName( const ::rtl::OUString& _name ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xPropertySet( m_xBarSettings, uno::UNO_QUERY_THROW );
+    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("UIName"), uno::makeAny( _name ) );
+    
+    pCBarHelper->ApplyChange( m_sResourceUrl, m_xBarSettings );
+}
+::sal_Bool SAL_CALL 
+ScVbaCommandBar::getVisible() throw (uno::RuntimeException)
+{
+    // menu bar is allways visible in OOo 
+    if( m_bIsMenu )
+        return sal_True;
+
+    sal_Bool bVisible = sal_False;
+    try
+    {
+        uno::Reference< container::XNameAccess > xNameAccess = pCBarHelper->getPersistentWindowState();
+        if( xNameAccess->hasByName( m_sResourceUrl ) )
+        {
+            uno::Sequence< beans::PropertyValue > aToolBar; 
+            xNameAccess->getByName( m_sResourceUrl ) >>= aToolBar;
+            getPropertyValue( aToolBar, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Visible") ) ) >>= bVisible;
+        }
+    }
+    catch ( uno::Exception e )
+    {
+    }
+    return bVisible;
+}
+void SAL_CALL 
+ScVbaCommandBar::setVisible( ::sal_Bool _visible ) throw (uno::RuntimeException)
+{
+    try
+    {
+        uno::Reference< frame::XLayoutManager > xLayoutManager = pCBarHelper->getLayoutManager();
+        if( _visible )
+        {
+            xLayoutManager->createElement( m_sResourceUrl );
+            xLayoutManager->showElement( m_sResourceUrl );
+        }
+        else
+        {
+            xLayoutManager->hideElement( m_sResourceUrl );
+            xLayoutManager->destroyElement( m_sResourceUrl );
+        }
+    }
+    catch( uno::Exception e )
+    {
+        OSL_TRACE( "SetVisible get an exception\n" );
+    }
+}
+
+::sal_Bool SAL_CALL 
+ScVbaCommandBar::getEnabled() throw (uno::RuntimeException)
+{
+    // emulated with Visible
+    return getVisible();
+}
+
+void SAL_CALL
+ScVbaCommandBar::setEnabled( sal_Bool _enabled ) throw (uno::RuntimeException)
+{
+    // emulated with Visible
+    setVisible( _enabled );
+}
+
+void SAL_CALL 
+ScVbaCommandBar::Delete(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    pCBarHelper->removeSettings( m_sResourceUrl );
+    uno::Reference< container::XNameContainer > xNameContainer( pCBarHelper->getPersistentWindowState(), uno::UNO_QUERY_THROW );
+    if( xNameContainer->hasByName( m_sResourceUrl ) )
+    {
+        xNameContainer->removeByName( m_sResourceUrl );
+    }
+}
+uno::Any SAL_CALL 
+ScVbaCommandBar::Controls( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    uno::Reference< awt::XMenu > xMenu;
+    if( m_bIsMenu )
+    {
+        uno::Reference< frame::XLayoutManager > xLayoutManager = pCBarHelper->getLayoutManager();
+        uno::Reference< beans::XPropertySet > xPropertySet( xLayoutManager->getElement( m_sResourceUrl ), uno::UNO_QUERY_THROW );
+        xMenu.set( xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("XMenuBar") ), uno::UNO_QUERY );
+    }
+    uno::Reference< XCommandBarControls > xCommandBarControls( new ScVbaCommandBarControls( this, mxContext, m_xBarSettings, pCBarHelper, m_xBarSettings, m_sResourceUrl, xMenu ) );
+    if( aIndex.hasValue() )
+    {
+        return xCommandBarControls->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xCommandBarControls );
+}
+
+sal_Int32 SAL_CALL
+ScVbaCommandBar::Type() throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // #FIXME support msoBarTypePopup
+    sal_Int32 nType = office::MsoBarType::msoBarTypePopup;
+    nType = m_bIsMenu? office::MsoBarType::msoBarTypeNormal : office::MsoBarType::msoBarTypeMenuBar;
+    return nType;
+}
+
+uno::Any SAL_CALL 
+ScVbaCommandBar::FindControl( const uno::Any& /*aType*/, const uno::Any& /*aId*/, const uno::Any& /*aTag*/, const uno::Any& /*aVisible*/, const uno::Any& /*aRecursive*/ ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // alwayse fail to find control
+    return uno::makeAny( uno::Reference< XCommandBarControl > () );
+}
+
+rtl::OUString& 
+ScVbaCommandBar::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBar") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBar::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBar" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbafillformat.hxx
===================================================================
--- vbahelper/source/vbahelper/vbafillformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbafillformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbafillformat.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_XFILLFORMAT_HXX
+#define SC_VBA_XFILLFORMAT_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <ooo/vba/msforms/XFillFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XFillFormat > ScVbaFillFormat_BASE;
+
+class ScVbaFillFormat : public ScVbaFillFormat_BASE
+{
+private:
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+    css::uno::Reference< ov::msforms::XColorFormat > m_xColorFormat;
+    css::drawing::FillStyle m_nFillStyle;
+    sal_Int32 m_nForeColor;
+    sal_Int32 m_nBackColor;
+    sal_Int16 m_nGradientAngle;
+private:
+    void setFillStyle( css::drawing::FillStyle nFillStyle ) throw (css::uno::RuntimeException);
+protected:
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+
+public:
+    ScVbaFillFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape > xShape );
+
+    void setForeColorAndInternalStyle( sal_Int32 nForeColor ) throw (css::uno::RuntimeException);
+    // Attributes
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getTransparency() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTransparency( double _transparency ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Solid() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL TwoColorGradient( sal_Int32 style, sal_Int32 variant ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL BackColor() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL ForeColor() throw (css::uno::RuntimeException);
+
+};
+
+#endif//SC_VBA_XFILLFORMAT_HXX
Index: vbahelper/source/vbahelper/vbalineformat.hxx
===================================================================
--- vbahelper/source/vbahelper/vbalineformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbalineformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbalineformat.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_XLINEFORMAT_HXX
+#define SC_VBA_XLINEFORMAT_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/msforms/XLineFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XLineFormat > ScVbaLineFormat_BASE;
+
+class ScVbaLineFormat : public ScVbaLineFormat_BASE
+{
+private:
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+    sal_Int32 m_nLineDashStyle;
+    double m_nLineWeight;
+protected:
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    sal_Int32 convertLineStartEndNameToArrowheadStyle( rtl::OUString sLineName );
+    rtl::OUString convertArrowheadStyleToLineStartEndName( sal_Int32 nArrowheadStyle ) throw (css::uno::RuntimeException);
+    sal_Int32 calculateArrowheadSize();
+public:
+    ScVbaLineFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape > xShape );
+
+    // Attributes
+    virtual sal_Int32 SAL_CALL getBeginArrowheadStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBeginArrowheadStyle( sal_Int32 _beginarrowheadstyle ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getBeginArrowheadLength() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBeginArrowheadLength( sal_Int32 _beginarrowheadlength ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getBeginArrowheadWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBeginArrowheadWidth( sal_Int32 _beginarrowheadwidth ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getEndArrowheadStylel() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEndArrowheadStylel( sal_Int32 _endarrowheadstylel ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getEndArrowheadLength() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEndArrowheadLength( sal_Int32 _endarrowheadlength ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getEndArrowheadWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEndArrowheadWidth( sal_Int32 _endarrowheadwidth ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getWeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWeight( double _weight ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getTransparency() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTransparency( double _transparency ) throw (css::uno::RuntimeException);
+    virtual sal_Int16 SAL_CALL getStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStyle( sal_Int16 _style ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getDashStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDashStyle( sal_Int32 _dashstyle ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL BackColor() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XColorFormat > SAL_CALL ForeColor() throw (css::uno::RuntimeException);
+};
+
+#endif//SC_VBA_XLINEFORMAT_HXX
Index: vbahelper/source/vbahelper/vbacommandbar.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMANDBAR_HXX
+#define SC_VBA_COMMANDBAR_HXX
+
+#include <ooo/vba/XCommandBar.hpp>
+#include <com/sun/star/ui/XUIConfigurationManager.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/beans/PropertyValues.hpp>
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbacommandbarhelper.hxx"
+
+#include <map>
+
+typedef InheritedHelperInterfaceImpl1< ov::XCommandBar > CommandBar_BASE;
+
+class ScVbaCommandBar : public CommandBar_BASE
+{
+private:
+    VbaCommandBarHelperRef pCBarHelper;
+    css::uno::Reference< css::container::XIndexAccess > m_xBarSettings;
+    rtl::OUString   m_sResourceUrl;
+    sal_Bool        m_bIsMenu;
+    sal_Bool        m_bTemporary;
+
+public:
+    ScVbaCommandBar( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext > xContext, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Bool bIsMenu, sal_Bool bTemporary = sal_True ) throw( css::uno::RuntimeException );
+    
+    sal_Bool IsMenu() { return m_bIsMenu; }
+
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const ::rtl::OUString& _name ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( ::sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getEnabled() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnabled( ::sal_Bool _enabled ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL Type(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL FindControl( const css::uno::Any& aType, const css::uno::Any& aId, const css::uno::Any& aTag, const css::uno::Any& aVisible, const css::uno::Any& aRecursive ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif//SC_VBA_COMMANDBAR_HXX
Index: vbahelper/source/vbahelper/vbadocumentbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbadocumentbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbadocumentbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,228 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbadocumentbase.hxx>
+#include <vbahelper/helperdecl.hxx>
+#include <comphelper/unwrapargs.hxx>
+
+#include <com/sun/star/util/XModifiable.hpp>
+#include <com/sun/star/util/XProtectable.hpp>
+#include <com/sun/star/util/XCloseable.hpp>
+#include <com/sun/star/frame/XStorable.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+VbaDocumentBase::VbaDocumentBase( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext) :VbaDocumentBase_BASE( xParent, xContext ), mxModel(NULL)
+{
+}
+
+VbaDocumentBase::VbaDocumentBase( const uno::Reference< ov::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, uno::Reference< frame::XModel > xModel ) : VbaDocumentBase_BASE( xParent, xContext ),  mxModel( xModel ) 
+{ 
+}
+
+VbaDocumentBase::VbaDocumentBase( uno::Sequence< uno::Any> const & args,
+    uno::Reference< uno::XComponentContext> const & xContext ) : VbaDocumentBase_BASE( getXSomethingFromArgs< XHelperInterface >( args, 0 ), xContext ),  mxModel( getXSomethingFromArgs< frame::XModel >( args, 1 ) ) 
+{
+}
+
+::rtl::OUString
+VbaDocumentBase::getName() throw (uno::RuntimeException)
+{
+	rtl::OUString sName = getModel()->getURL();
+	if ( sName.getLength() )
+	{
+
+		INetURLObject aURL( getModel()->getURL() );
+		::osl::File::getSystemPathFromFileURL( aURL.GetLastName(), sName );
+	}
+	else
+	{
+		const static rtl::OUString sTitle( RTL_CONSTASCII_USTRINGPARAM("Title" ) );
+		// process "UntitledX - $(PRODUCTNAME)"
+		uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+		xProps->getPropertyValue(sTitle ) >>= sName;
+		sal_Int32 pos = 0;
+		sName = sName.getToken(0,' ',pos);	
+	}
+	return sName;
+}
+::rtl::OUString
+VbaDocumentBase::getPath() throw (uno::RuntimeException)
+{
+       INetURLObject aURL( getModel()->getURL() );
+	rtl::OUString sURL( aURL.GetMainURL( INetURLObject::DECODE_TO_IURI ) );
+	sURL = sURL.copy( 0, sURL.getLength() - aURL.GetLastName().getLength() - 1 );
+        rtl::OUString sPath;
+	::osl::File::getSystemPathFromFileURL( sURL, sPath );
+	return sPath;
+}
+
+::rtl::OUString
+VbaDocumentBase::getFullName() throw (uno::RuntimeException)
+{
+        rtl::OUString sPath;
+	::osl::File::getSystemPathFromFileURL( getModel()->getURL(), sPath );
+	return sPath;
+}
+
+void
+VbaDocumentBase::Close( const uno::Any &rSaveArg, const uno::Any &rFileArg,
+					  const uno::Any &rRouteArg ) throw (uno::RuntimeException)
+{
+	sal_Bool bSaveChanges = sal_False;
+	rtl::OUString aFileName;
+	sal_Bool bRouteWorkbook = sal_True;
+
+	rSaveArg >>= bSaveChanges;
+	sal_Bool bFileName =  ( rFileArg >>= aFileName );
+	rRouteArg >>= bRouteWorkbook;
+	uno::Reference< frame::XStorable > xStorable( getModel(), uno::UNO_QUERY_THROW );
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+
+	if( bSaveChanges )
+	{
+		if( xStorable->isReadonly() )
+		{	
+			throw uno::RuntimeException(::rtl::OUString( 
+				RTL_CONSTASCII_USTRINGPARAM( "Unable to save to a read only file ") ),
+                        	uno::Reference< XInterface >() );
+		}
+		if( bFileName )
+			xStorable->storeAsURL( aFileName, uno::Sequence< beans::PropertyValue >(0) ); 
+		else
+			xStorable->store();
+	}	
+	else
+		xModifiable->setModified( false );		
+
+	uno::Reference< util::XCloseable > xCloseable( getModel(), uno::UNO_QUERY );
+
+	if( xCloseable.is() )
+		// use close(boolean DeliverOwnership)
+	
+		// The boolean parameter DeliverOwnership tells objects vetoing the close process that they may
+		// assume ownership if they object the closure by throwing a CloseVetoException
+		// Here we give up ownership. To be on the safe side, catch possible veto exception anyway.
+		xCloseable->close(sal_True);
+	// If close is not supported by this model - try to dispose it.
+	// But if the model disagree with a reset request for the modify state
+	// we shouldn't do so. Otherwhise some strange things can happen.
+	else
+	{
+		uno::Reference< lang::XComponent > xDisposable ( getModel(), uno::UNO_QUERY );
+		if ( xDisposable.is() )
+			xDisposable->dispose();
+	}
+}
+
+void
+VbaDocumentBase::Protect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+	rtl::OUString rPassword;
+	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
+	SC_VBA_FIXME(("Workbook::Protect stub"));
+	if(  aPassword >>= rPassword )
+		xProt->protect( rPassword );
+	else
+		xProt->protect( rtl::OUString() );
+}
+
+void 
+VbaDocumentBase::Unprotect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+	rtl::OUString rPassword;
+	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
+	if( !xProt->isProtected() )
+		throw uno::RuntimeException(::rtl::OUString(
+			RTL_CONSTASCII_USTRINGPARAM( "File is already unprotected" ) ),
+			uno::Reference< XInterface >() );
+	else
+	{
+		if( aPassword >>= rPassword )
+			xProt->unprotect( rPassword );
+		else
+			xProt->unprotect( rtl::OUString() );
+	}
+}
+		
+void 
+VbaDocumentBase::setSaved( sal_Bool bSave ) throw (uno::RuntimeException)
+{
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+	xModifiable->setModified( bSave );
+}
+
+sal_Bool
+VbaDocumentBase::getSaved() throw (uno::RuntimeException)
+{
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+	return xModifiable->isModified();
+}
+
+void
+VbaDocumentBase::Save() throw (uno::RuntimeException)
+{
+	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Save"));
+	uno::Reference< frame::XModel > xModel = getModel();
+	dispatchRequests(xModel,url);
+}
+
+void 
+VbaDocumentBase::Activate() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+	xFrame->activate();
+}	
+
+rtl::OUString& 
+VbaDocumentBase::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaDocumentBase") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+VbaDocumentBase::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.VbaDocumentBase" ) );
+	}
+	return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbahelper.cxx
===================================================================
--- vbahelper/source/vbahelper/vbahelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbahelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,1199 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.cxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <cppuhelper/bootstrap.hxx>
+#include <com/sun/star/util/XURLTransformer.hpp>
+#include <com/sun/star/frame/XDispatchProvider.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <ooo/vba/msforms/XShape.hpp>
+
+#include <comphelper/processfactory.hxx>
+
+#include <sfx2/objsh.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/dispatch.hxx>
+#include <sfx2/app.hxx>
+#include <svtools/stritem.hxx>
+#include <svtools/eitem.hxx>
+#include <svtools/intitem.hxx>
+#include <svtools/itemset.hxx>
+//#include <svtools/itempool.hxx>
+#include <sfx2/docfac.hxx>
+#include <sfx2/viewfac.hxx>
+
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <rtl/math.hxx>
+#include <sfx2/viewsh.hxx>
+#include <math.h>
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <toolkit/helper/vclunohelper.hxx>
+#include <com/sun/star/frame/XModel2.hpp>
+#include <com/sun/star/lang/XUnoTunnel.hpp>
+#include <vcl/window.hxx>
+#include <vcl/syswin.hxx>
+#include <tools/diagnose_ex.h>
+
+#ifndef OOVBA_DLLIMPLEMENTATION
+#define OOVBA_DLLIMPLEMENTATION
+#endif 
+
+#include <vbahelper/vbahelper.hxx>
+#include <sfx2/app.hxx>
+// #FIXME needs service
+//#include "vbashape.hxx"
+//#include "unonames.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+#define NAME_HEIGHT "Height"
+#define NAME_WIDTH "Width"
+
+#define POINTTO100THMILLIMETERFACTOR 35.27778
+
+
+void unoToSbxValue( SbxVariable* pVar, const uno::Any& aValue );
+
+uno::Any sbxToUnoValue( SbxVariable* pVar );
+
+
+namespace ooo
+{
+namespace vba
+{
+
+uno::Reference< lang::XMultiServiceFactory > getVBAServiceFactory( SfxObjectShell* pShell )
+{
+    uno::Any aUnoVar;
+    if ( !pShell || ! pShell->GetBasicManager()->GetGlobalUNOConstant( "VBAGlobals", aUnoVar ) )
+        throw lang::IllegalArgumentException();
+    uno::Reference< lang::XMultiServiceFactory > xVBAFactory( aUnoVar, uno::UNO_QUERY_THROW );
+    return xVBAFactory;
+}
+
+css::uno::Reference< css::uno::XInterface > createVBAUnoAPIService( SfxObjectShell* pShell, const sal_Char* _pAsciiName ) throw (css::uno::RuntimeException)
+{
+    OSL_PRECOND( pShell, "createVBAUnoAPIService: no shell!" );
+    ::rtl::OUString sVarName( ::rtl::OUString::createFromAscii( _pAsciiName ) );
+    return getVBAServiceFactory( pShell )->createInstance( sVarName );
+}
+
+css::uno::Reference< css::uno::XInterface > createVBAUnoAPIServiceWithArgs( SfxObjectShell* pShell, const sal_Char* _pAsciiName, const uno::Sequence< uno::Any >& aArgs ) throw ( css::uno::RuntimeException )
+{
+    OSL_PRECOND( pShell, "createVBAUnoAPIService: no shell!" );
+    ::rtl::OUString sVarName( ::rtl::OUString::createFromAscii( _pAsciiName ) );
+    uno::Reference< uno::XInterface > xIf = getVBAServiceFactory( pShell )->createInstanceWithArguments( sVarName, aArgs  );
+    return xIf;
+}
+// helper method to determine if the view ( calc ) is in print-preview mode
+bool isInPrintPreview( SfxViewFrame* pView )
+{
+	sal_uInt16 nViewNo = SID_VIEWSHELL1 - SID_VIEWSHELL0;
+	if ( pView->GetObjectShell()->GetFactory().GetViewFactoryCount() >
+nViewNo && !pView->GetObjectShell()->IsInPlaceActive() )
+	{
+		SfxViewFactory &rViewFactory =
+			pView->GetObjectShell()->GetFactory().GetViewFactory(nViewNo);
+		if (  pView->GetCurViewId() == rViewFactory.GetOrdinal() )
+			return true;
+	}
+	return false;
+}
+#if 0
+namespace excel // all in this namespace probably can be moved to sc
+{
+
+
+const ::rtl::OUString REPLACE_CELLS_WARNING(  RTL_CONSTASCII_USTRINGPARAM( "ReplaceCellsWarning"));
+class PasteCellsWarningReseter
+{
+private:
+	bool bInitialWarningState;
+	static uno::Reference< beans::XPropertySet > getGlobalSheetSettings() throw ( uno::RuntimeException )
+	{
+		static uno::Reference< beans::XPropertySet > xTmpProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		static uno::Reference<uno::XComponentContext > xContext( xTmpProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW );
+		static uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+				xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+		static uno::Reference< beans::XPropertySet > xProps( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sheet.GlobalSheetSettings" ) ) ,xContext ), uno::UNO_QUERY_THROW );
+		return xProps;
+	}
+
+	bool getReplaceCellsWarning() throw ( uno::RuntimeException )
+	{
+		sal_Bool res = sal_False;
+		getGlobalSheetSettings()->getPropertyValue( REPLACE_CELLS_WARNING ) >>= res;
+		return ( res == sal_True );
+	}
+
+	void setReplaceCellsWarning( bool bState ) throw ( uno::RuntimeException )
+	{
+		getGlobalSheetSettings()->setPropertyValue( REPLACE_CELLS_WARNING, uno::makeAny( bState ) );
+	}
+public:
+	PasteCellsWarningReseter() throw ( uno::RuntimeException )
+	{
+		bInitialWarningState = getReplaceCellsWarning();
+		if ( bInitialWarningState )
+			setReplaceCellsWarning( false );
+	}
+	~PasteCellsWarningReseter()
+	{
+		if ( bInitialWarningState )
+		{
+			// don't allow dtor to throw
+			try
+			{
+				setReplaceCellsWarning( true );
+			}
+			catch ( uno::Exception& /*e*/ ){}
+		}
+	}
+};
+
+void
+implnPaste()
+{
+	PasteCellsWarningReseter resetWarningBox;
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	if ( pViewShell )
+	{
+		pViewShell->PasteFromSystem();
+		pViewShell->CellContentChanged();
+	}
+}
+
+
+void
+implnCopy()
+{
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	if ( pViewShell )
+		pViewShell->CopyToClip(NULL,false,false,true);
+}
+
+void 
+implnCut()
+{
+	ScTabViewShell* pViewShell =  getCurrentBestViewShell();
+	if ( pViewShell )
+		pViewShell->CutToClip( NULL, TRUE );
+}
+void implnPasteSpecial(SfxViewShell* pViewShell, USHORT nFlags,USHORT nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose)
+{
+	PasteCellsWarningReseter resetWarningBox;
+	sal_Bool bAsLink(sal_False), bOtherDoc(sal_False);
+	InsCellCmd eMoveMode = INS_NONE;
+
+	if ( !pTabViewShell ) 
+		// none active, try next best
+		pTabViewShell = getCurrentBestViewShell();
+	if ( pTabViewShell )
+	{
+		ScViewData* pView = pTabViewShell->GetViewData();	
+		Window* pWin = ( pView != NULL ) ? pView->GetActiveWin() : NULL;
+		if ( pView && pWin )
+		{
+			if ( bAsLink && bOtherDoc )
+				pTabViewShell->PasteFromSystem(0);//SOT_FORMATSTR_ID_LINK
+			else 
+			{
+				ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( pWin );
+				ScDocument* pDoc = NULL; 
+				if ( pOwnClip )
+					pDoc = pOwnClip->GetDocument();	
+				pTabViewShell->PasteFromClip( nFlags, pDoc,
+					nFunction, bSkipEmpty, bTranspose, bAsLink,
+					eMoveMode, IDF_NONE, TRUE );
+				pTabViewShell->CellContentChanged();
+			}
+		}
+	}
+
+}
+
+ScDocShell* 
+getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) 
+{
+	uno::Reference< uno::XInterface > xIf( xModel, uno::UNO_QUERY_THROW );
+	ScModelObj* pModel = dynamic_cast< ScModelObj* >( xIf.get() );
+	ScDocShell* pDocShell = NULL;
+	if ( pModel )
+		pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
+	return pDocShell;
+
+}
+
+ScTabViewShell* 
+getBestViewShell(  css::uno::Reference< css::frame::XModel>& xModel )
+{
+	ScDocShell* pDocShell = getDocShell( xModel );
+	if ( pDocShell )
+		return pDocShell->GetBestViewShell();
+	return NULL;
+}
+
+ScTabViewShell* 
+getCurrentBestViewShell()
+{ 
+	uno::Reference< frame::XModel > xModel = getCurrentDocument();
+	return getBestViewShell( xModel );
+}
+
+SfxViewFrame* 
+getCurrentViewFrame()
+{
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();	
+	if ( pViewShell )
+		return pViewShell->GetViewFrame();
+	return NULL;
+}
+};
+
+#endif
+const double Millimeter::factor =  35.27778;
+
+uno::Reference< beans::XIntrospectionAccess >
+getIntrospectionAccess( const uno::Any& aObject ) throw (uno::RuntimeException)
+{
+	static uno::Reference< beans::XIntrospection > xIntrospection;
+	if( !xIntrospection.is() )
+	{
+		uno::Reference< lang::XMultiServiceFactory > xFactory( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		xIntrospection.set( xFactory->createInstance( rtl::OUString::createFromAscii("com.sun.star.beans.Introspection") ), uno::UNO_QUERY_THROW );
+	}
+	return xIntrospection->inspect( aObject );
+}
+
+uno::Reference< script::XTypeConverter >
+getTypeConverter( const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
+{
+	static uno::Reference< script::XTypeConverter > xTypeConv( xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), xContext ), uno::UNO_QUERY_THROW );
+	return xTypeConv;
+}
+const uno::Any&
+aNULL()
+{
+ 	static  uno::Any aNULLL = uno::makeAny( uno::Reference< uno::XInterface >() );
+	return aNULLL;
+}
+
+void dispatchExecute(SfxViewShell* pViewShell, USHORT nSlot, SfxCallMode nCall)
+{
+	SfxViewFrame* pViewFrame = NULL;
+	if ( pViewShell )
+		pViewFrame = pViewShell->GetViewFrame();
+	if ( pViewFrame )
+	{
+		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
+		if( pDispatcher )
+		{
+			pDispatcher->Execute( nSlot , nCall );
+		}
+	}	
+}
+	
+void
+dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl, uno::Sequence< beans::PropertyValue >& sProps )
+{
+
+	util::URL  url ;
+	url.Complete = aUrl;
+	rtl::OUString emptyString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "" ));
+	uno::Reference<frame::XController> xController = xModel->getCurrentController();
+	uno::Reference<frame::XFrame> xFrame = xController->getFrame();
+	uno::Reference<frame::XDispatchProvider> xDispatchProvider (xFrame,uno::UNO_QUERY_THROW);
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+		uno::Reference<uno::XComponentContext > xContext( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), uno::UNO_QUERY_THROW  );
+		if ( !xContext.is() )
+		{
+			return ;
+		}
+
+		uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+				xContext->getServiceManager() );
+		if ( !xServiceManager.is() )
+		{
+			return ;
+		}
+		uno::Reference<util::XURLTransformer> xParser( xServiceManager->createInstanceWithContext(     rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.util.URLTransformer" ) )
+			,xContext), uno::UNO_QUERY_THROW );
+		if (!xParser.is())
+			return;
+		xParser->parseStrict (url);
+	}
+	catch ( uno::Exception & /*e*/ )
+	{
+		return ;
+	}
+
+	uno::Reference<frame::XDispatch> xDispatcher = xDispatchProvider->queryDispatch(url,emptyString,0);
+
+	uno::Sequence<beans::PropertyValue> dispatchProps(1);
+
+	sal_Int32 nProps = sProps.getLength();
+	beans::PropertyValue* pDest = dispatchProps.getArray();
+	if ( nProps )
+	{
+		dispatchProps.realloc( nProps + 1 );
+		// need to reaccquire pDest after realloc
+		pDest = dispatchProps.getArray();
+		beans::PropertyValue* pSrc = sProps.getArray();
+		for ( sal_Int32 index=0; index<nProps; ++index, ++pSrc, ++pDest )
+			*pDest = *pSrc;
+	}
+
+	(*pDest).Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Silent" ));
+	(*pDest).Value <<= (sal_Bool)sal_True;
+
+	if (xDispatcher.is())
+		xDispatcher->dispatch( url, dispatchProps );
+}
+
+void
+dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl) 
+{
+	uno::Sequence<beans::PropertyValue> dispatchProps;
+	dispatchRequests( xModel, aUrl, dispatchProps );
+}
+
+
+
+
+ uno::Reference< frame::XModel > 
+getCurrentDoc( const rtl::OUString& sKey ) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel;
+	SbxObject* pBasic = dynamic_cast< SbxObject* > ( SFX_APP()->GetBasic() );
+	SbxObject* basicChosen =  pBasic ;
+	if ( basicChosen == NULL)
+	{
+		OSL_TRACE("getModelFromBasic() StarBASIC* is NULL" );
+		return xModel;
+	}    
+    SbxObject* p = pBasic;
+    SbxObject* pParent = p->GetParent();
+    SbxObject* pParentParent = pParent ? pParent->GetParent() : NULL;
+
+    if( pParentParent )
+    {
+        basicChosen = pParentParent;
+    }
+    else if( pParent )
+    {
+        basicChosen = pParent;
+    }
+
+
+    uno::Any aModel; 
+    SbxVariable *pCompVar = basicChosen->Find(  sKey, SbxCLASS_OBJECT );
+
+	if ( pCompVar )
+	{
+		aModel = sbxToUnoValue( pCompVar );
+		if ( sal_False == ( aModel >>= xModel ) ||
+			!xModel.is() )
+		{
+			throw uno::RuntimeException( 
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't extract model from basic ( its obviously not set yet ) therefore don't know the current documet context") ), uno::Reference< uno::XInterface >() );
+		}
+		else
+		{
+			OSL_TRACE("Have model points to url %s",
+			::rtl::OUStringToOString( xModel->getURL(),
+				RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+		}
+	}
+	else
+	{
+		OSL_TRACE("Failed to get %s", rtl::OUStringToOString( sKey, RTL_TEXTENCODING_UTF8 ).getStr() );
+		throw uno::RuntimeException( 
+			rtl::OUString( 
+				RTL_CONSTASCII_USTRINGPARAM(
+					"Can't determine the currently selected document") ),
+			uno::Reference< uno::XInterface >() );
+	}
+	return xModel;
+}
+
+ uno::Reference< frame::XModel > 
+getCurrentDocCtx( const rtl::OUString& ctxName, const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
+{
+    uno::Reference< frame::XModel > xModel;
+     // try fallback to calling doc
+     css::uno::Reference< css::container::XNameAccess > xNameAccess( xContext, css::uno::UNO_QUERY_THROW );
+     xModel.set( xNameAccess->getByName( ctxName ), uno::UNO_QUERY_THROW );
+     return xModel;
+}
+
+ uno::Reference< frame::XModel > 
+getCurrentExcelDoc( const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
+{
+    static const rtl::OUString sThisExcelDoc( RTL_CONSTASCII_USTRINGPARAM("ThisExcelDoc" ) );
+    uno::Reference< frame::XModel > xModel;
+    try
+    {
+        xModel = getCurrentDoc( sThisExcelDoc ); 
+    }
+    catch( uno::Exception& e )
+    {
+        xModel = getCurrentDocCtx( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ExcelDocumentContext" ) ), xContext );
+    }
+    return xModel;
+}
+
+ uno::Reference< frame::XModel > 
+getCurrentWordDoc( const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException)
+{
+    static const rtl::OUString sThisWordDoc( RTL_CONSTASCII_USTRINGPARAM("ThisWordDoc" ) );
+    uno::Reference< frame::XModel > xModel;
+    try
+    {
+        xModel = getCurrentDoc( sThisWordDoc ); 
+    }
+    catch( uno::Exception& e )
+    {
+        xModel = getCurrentDocCtx( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("WordDocumentContext" ) ), xContext );
+    }
+    return xModel;
+}
+
+sal_Int32 
+OORGBToXLRGB( sal_Int32 nCol )
+{
+        sal_Int32 nAutoBits = nCol;
+        nAutoBits &= 0xFF000000;
+	sal_Int32 nRed = nCol;
+	nRed &= 0x00FF0000;
+	nRed >>= 16;
+	sal_Int32 nGreen = nCol;
+	nGreen &= 0x0000FF00;
+	nGreen >>= 8;
+	sal_Int32 nBlue = nCol;
+	nBlue &= 0x000000FF;
+	sal_Int32 nRGB =  ( nAutoBits | (nBlue << 16) | (nGreen << 8) | nRed );
+	return nRGB;
+}
+sal_Int32 
+XLRGBToOORGB( sal_Int32 nCol )
+{
+        sal_Int32 nAutoBits = nCol;
+        nAutoBits &= 0xFF000000;
+
+	sal_Int32 nBlue = nCol;
+	nBlue &= 0x00FF0000;
+	nBlue >>= 16;
+	sal_Int32 nGreen = nCol;
+	nGreen &= 0x0000FF00;
+	nGreen >>= 8;
+	sal_Int32 nRed = nCol;
+	nRed &= 0x000000FF;
+	sal_Int32 nRGB =  ( nAutoBits | (nRed << 16) | (nGreen << 8) | nBlue );
+	return nRGB;
+}
+uno::Any 
+OORGBToXLRGB( const uno::Any& aCol )
+{
+	sal_Int32 nCol;
+	aCol >>= nCol;
+	nCol = OORGBToXLRGB( nCol );
+	return uno::makeAny( nCol );
+}
+uno::Any 
+XLRGBToOORGB(  const uno::Any& aCol )
+{
+	sal_Int32 nCol;
+	aCol >>= nCol;
+	nCol = XLRGBToOORGB( nCol );
+	return uno::makeAny( nCol );
+}
+
+void PrintOutHelper( SfxViewShell* pViewShell, const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& /*ActivePrinter*/, const uno::Any& /*PrintToFile*/, const uno::Any& Collate, const uno::Any& PrToFileName, sal_Bool bUseSelection  )
+{
+	sal_Int32 nTo = 0;
+	sal_Int32 nFrom = 0;
+	sal_Int16 nCopies = 1;
+	sal_Bool bPreview = sal_False;
+	sal_Bool bCollate = sal_False;
+	sal_Bool bSelection = bUseSelection;
+	From >>= nFrom;
+	To >>= nTo;
+	Copies >>= nCopies;
+	Preview >>= bPreview;
+	if ( nCopies > 1 ) // Collate only useful when more that 1 copy
+		Collate >>= bCollate;
+
+	rtl::OUString sRange(  RTL_CONSTASCII_USTRINGPARAM( "-" ) );
+	rtl::OUString sFileName;
+	
+	if (( nFrom || nTo ) )
+	{
+		if ( nFrom )
+			sRange = ( ::rtl::OUString::valueOf( nFrom ) + sRange );
+		if ( nTo )
+			sRange += ::rtl::OUString::valueOf( nTo );
+	}
+
+	if (  PrToFileName.getValue() )
+	{
+		PrToFileName >>= sFileName;
+	}
+	SfxViewFrame* pViewFrame = NULL;
+	if ( pViewShell )
+		pViewFrame = pViewShell->GetViewFrame();
+	if ( pViewFrame )
+	{
+		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
+				
+		SfxBoolItem sfxCollate( SID_PRINT_COLLATE, bCollate );
+		aArgs.Put( sfxCollate, sfxCollate.Which() );
+		SfxInt16Item sfxCopies( SID_PRINT_COPIES, nCopies );
+		aArgs.Put( sfxCopies, sfxCopies.Which() );
+		if ( sFileName.getLength() )
+		{
+			SfxStringItem sfxFileName( SID_FILE_NAME, sFileName);
+			aArgs.Put( sfxFileName, sfxFileName.Which() );
+		
+		}
+		if (  sRange.getLength() )
+		{
+			SfxStringItem sfxRange( SID_PRINT_PAGES, sRange );
+			aArgs.Put( sfxRange, sfxRange.Which() );
+		}
+		SfxBoolItem sfxSelection( SID_SELECTION, bSelection );
+		aArgs.Put( sfxSelection, sfxSelection.Which() );
+		SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
+		aArgs.Put( sfxAsync, sfxAsync.Which() );
+		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
+
+		if ( pDispatcher )
+		{
+			if ( bPreview )
+			{
+				if ( !pViewFrame->GetFrame()->IsInPlace() ) 	
+				{
+					// #TODO is this necessary ( calc specific )
+//					SC_MOD()->InputEnterHandler();
+					pViewFrame->GetDispatcher()->Execute( SID_VIEWSHELL1, SFX_CALLMODE_SYNCHRON );
+					while ( isInPrintPreview( pViewFrame ) )
+						Application::Yield();
+				}
+			}
+			else
+				pDispatcher->Execute( (USHORT)SID_PRINTDOC, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
+		}
+			
+	}
+	
+	// #FIXME #TODO
+	// 1 ActivePrinter ( how/can we switch a printer via API? )
+	// 2 PrintToFile ( ms behaviour if this option is specified but no 
+	//   filename supplied 'PrToFileName' then the user will be prompted )
+	// 3 Need to check behaviour of Selected sheets with range ( e.g. From & To
+	//    values ) in oOO these options are mutually exclusive
+	// 4 There is a pop up to do with transparent objects in the print source
+	//   should be able to disable that via configuration for the duration
+	//   of this method
+}
+
+ void PrintPreviewHelper( const css::uno::Any& /*EnableChanges*/, SfxViewShell* pViewShell )
+{
+	dispatchExecute( pViewShell, SID_VIEWSHELL1 );
+}
+
+rtl::OUString getAnyAsString( const uno::Any& pvargItem ) throw ( uno::RuntimeException )
+{
+	uno::Type aType = pvargItem.getValueType();
+	uno::TypeClass eTypeClass = aType.getTypeClass();
+	rtl::OUString sString;
+	switch ( eTypeClass )
+	{
+		case uno::TypeClass_BOOLEAN:
+		{
+			sal_Bool bBool = sal_False;
+			pvargItem >>= bBool;
+			sString = rtl::OUString::valueOf( bBool );
+			break;
+		}
+		case uno::TypeClass_STRING:
+			pvargItem >>= sString;
+			break;
+		case uno::TypeClass_FLOAT:
+			{
+				float aFloat = 0;
+				pvargItem >>= aFloat;
+				sString = rtl::OUString::valueOf( aFloat );
+				break;
+			}
+		case uno::TypeClass_DOUBLE:
+			{
+				double aDouble = 0;
+				pvargItem >>= aDouble;
+				sString = rtl::OUString::valueOf( aDouble );
+				break;
+			}
+		case uno::TypeClass_SHORT:
+		case uno::TypeClass_LONG:
+		case uno::TypeClass_BYTE:
+			{
+				sal_Int32 aNum = 0;
+				pvargItem >>= aNum;
+				sString = rtl::OUString::valueOf( aNum );
+				break;
+			}
+
+		case uno::TypeClass_HYPER:
+			{
+				sal_Int64 aHyper = 0;
+				pvargItem >>= aHyper;
+				sString = rtl::OUString::valueOf( aHyper );
+				break;
+			}
+		default:
+       			throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid type, can't convert" ), uno::Reference< uno::XInterface >() );
+	}
+	return sString;
+}
+
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator)
+{
+	return getUniqueName(_slist, _sElementName, _sSuffixSeparator, sal_Int32(2));
+}
+
+rtl::OUString 
+ContainerUtilities::getUniqueName( const uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix)
+{
+	sal_Int32 a = _nStartSuffix;
+	rtl::OUString scompname = _sElementName;
+	bool bElementexists = true;
+	sal_Int32 nLen = _slist.getLength();
+	if ( nLen == 0 )
+		return _sElementName;
+
+	while (bElementexists == true) 
+	{
+		for (sal_Int32 i = 0; i < nLen; i++)
+		{
+			if (FieldInList(_slist, scompname) == -1)
+			{
+				return scompname;
+			}
+		}
+		scompname = _sElementName + _sSuffixSeparator + rtl::OUString::valueOf( a++ );
+	}
+	return rtl::OUString();
+}
+
+sal_Int32 
+ContainerUtilities::FieldInList( const uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString )
+{
+	sal_Int32 FieldLen = SearchList.getLength();
+	sal_Int32 retvalue = -1;
+	for (sal_Int32 i = 0; i < FieldLen; i++) 
+	{
+		// I wonder why comparing lexicographically is done
+		// when its a match is whats interesting?
+		//if (SearchList[i].compareTo(SearchString) == 0) 
+		if ( SearchList[i].equals( SearchString ) ) 
+		{
+			retvalue = i;
+			break;
+		}
+	}
+	return retvalue;
+
+}
+bool NeedEsc(sal_Unicode cCode)
+{
+	String sEsc(RTL_CONSTASCII_USTRINGPARAM(".^$+\\|{}()"));
+	return (STRING_NOTFOUND != sEsc.Search(cCode));
+}
+
+rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike )
+{
+	rtl::OUStringBuffer sResult;
+	const sal_Unicode *start = rIn.getStr();
+	const sal_Unicode *end = start + rIn.getLength();
+
+	int seenright = 0;
+	if ( bForLike )
+		sResult.append(static_cast<sal_Unicode>('^'));
+
+	while (start < end) 
+	{
+		switch (*start)
+		{
+			case '?':
+				sResult.append(static_cast<sal_Unicode>('.'));
+				start++;
+				break;
+			case '*':
+				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(".*")));
+				start++;
+				break;
+			case '#':
+				sResult.append(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[0-9]")));
+				start++;
+				break;
+			case '~':
+				sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*(++start));
+				start++;
+				break;
+				// dump the ~ and escape the next characture
+			case ']':
+				sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*start++);
+				break;
+			case '[':
+				sResult.append(*start++);
+				seenright = 0;
+				while (start < end && !seenright)
+				{
+					switch (*start)
+					{
+						case '[':
+						case '?':
+						case '*':
+						sResult.append(static_cast<sal_Unicode>('\\'));
+						sResult.append(*start);
+							break;
+						case ']':
+						sResult.append(*start);
+							seenright = 1;
+							break;
+						case '!':
+							sResult.append(static_cast<sal_Unicode>('^'));
+							break;
+						default:
+						if (NeedEsc(*start))
+							sResult.append(static_cast<sal_Unicode>('\\'));
+						sResult.append(*start);
+							break;
+					}
+					start++;
+				}
+				break;
+			default:
+				if (NeedEsc(*start))
+					sResult.append(static_cast<sal_Unicode>('\\'));
+				sResult.append(*start++);
+		}
+	}
+
+	if ( bForLike )
+		sResult.append(static_cast<sal_Unicode>('$'));
+
+	return sResult.makeStringAndClear( );
+}
+
+double getPixelTo100thMillimeterConversionFactor( css::uno::Reference< css::awt::XDevice >& xDevice, sal_Bool bVertical)
+{
+	double fConvertFactor = 1.0;
+	if( bVertical )
+	{
+		fConvertFactor = xDevice->getInfo().PixelPerMeterY/100000;
+	}
+	else
+	{
+		fConvertFactor = xDevice->getInfo().PixelPerMeterX/100000;	
+	}
+	return fConvertFactor;
+}
+
+double PointsToPixels( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical)
+{
+	double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
+	return fPoints * POINTTO100THMILLIMETERFACTOR * fConvertFactor;
+}
+double PixelsToPoints( css::uno::Reference< css::awt::XDevice >& xDevice, double fPixels, sal_Bool bVertical)
+{
+	double fConvertFactor = getPixelTo100thMillimeterConversionFactor( xDevice, bVertical );
+	return (fPixels/fConvertFactor)/POINTTO100THMILLIMETERFACTOR;
+}
+
+ConcreteXShapeGeometryAttributes::ConcreteXShapeGeometryAttributes( const css::uno::Reference< css::uno::XComponentContext >& /*xContext*/, const css::uno::Reference< css::drawing::XShape >& xShape )
+{
+    m_pShapeHelper.reset( new ShapeHelper( xShape ) );
+}
+
+sal_Int32 getPointerStyle( const uno::Reference< frame::XModel >& xModel )
+{
+    
+    sal_Int32 nPointerStyle( POINTER_ARROW );
+    try
+    {
+        const uno::Reference< frame::XController > xController( xModel->getCurrentController(),     uno::UNO_SET_THROW );
+        const uno::Reference< frame::XFrame >      xFrame     ( xController->getFrame(),        uno::UNO_SET_THROW );
+        const uno::Reference< awt::XWindow >       xWindow    ( xFrame->getContainerWindow(),   uno::UNO_SET_THROW );
+        // why the heck isn't there an XWindowPeer::getPointer, but a setPointer only?
+        const Window* pWindow = VCLUnoHelper::GetWindow( xWindow );
+        if ( pWindow )
+            nPointerStyle = pWindow->GetSystemWindow()->GetPointer().GetStyle();
+    }
+    catch( const uno::Exception& )
+    {
+    	DBG_UNHANDLED_EXCEPTION();
+    }
+    return nPointerStyle;
+}
+
+// #FIXME this method looks wrong, shouldn't it just affect calc *or* writer
+// document/frame/window(s) but not both ( and depending on what api called 
+// this )
+void setCursorHelper( const uno::Reference< frame::XModel >& xModel, const Pointer& rPointer, sal_Bool bOverWrite )
+{
+    ::std::vector< uno::Reference< frame::XController > > aControllers;
+
+    uno::Reference< frame::XModel2 > xModel2( xModel, uno::UNO_QUERY );
+    if ( xModel2.is() )
+    {
+        const uno::Reference< container::XEnumeration > xEnumControllers( xModel2->getControllers(), uno::UNO_SET_THROW );
+        while ( xEnumControllers->hasMoreElements() )
+        {
+            const uno::Reference< frame::XController > xController( xEnumControllers->nextElement(), uno::UNO_QUERY_THROW );
+            aControllers.push_back( xController );
+        }
+    }
+    else
+    {
+        if ( xModel.is() )
+        {
+            const uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_SET_THROW );
+            aControllers.push_back( xController );
+        }
+    }
+
+    for (   ::std::vector< uno::Reference< frame::XController > >::const_iterator controller = aControllers.begin();
+            controller != aControllers.end();
+            ++controller
+        )
+    {
+        const uno::Reference< frame::XFrame >      xFrame     ( (*controller)->getFrame(),       uno::UNO_SET_THROW   );
+        const uno::Reference< awt::XWindow >       xWindow    ( xFrame->getContainerWindow(),    uno::UNO_SET_THROW   );
+
+        Window* pWindow = VCLUnoHelper::GetWindow( xWindow );
+        OSL_ENSURE( pWindow, "ScVbaApplication::setCursor: no window!" );
+        if ( !pWindow )
+            continue;
+
+        pWindow->GetSystemWindow()->SetPointer( rPointer );
+        pWindow->GetSystemWindow()->EnableChildPointerOverwrite( bOverWrite );
+    }
+}
+
+void setDefaultPropByIntrospection( const uno::Any& aObj, const uno::Any& aValue  ) throw ( uno::RuntimeException )
+{
+    uno::Reference< beans::XIntrospectionAccess > xUnoAccess( getIntrospectionAccess( aObj ) );
+
+    // #MAYBE #FIXME sort of a bit of a hack, 
+    uno::Reference<  script::XDefaultProperty > xDflt( aObj, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xPropSet;
+
+    if ( xUnoAccess.is() )
+        xPropSet.set( xUnoAccess->queryAdapter( ::getCppuType( (const uno::Reference< beans::XPropertySet > *)0 ) ), uno::UNO_QUERY);
+           
+    if ( xPropSet.is() )
+        xPropSet->setPropertyValue( xDflt->getDefaultPropertyName(), aValue );
+    else
+        throw uno::RuntimeException();
+}
+
+uno::Any getPropertyValue( const uno::Sequence< beans::PropertyValue >& aProp, const rtl::OUString& aName )
+{
+    uno::Any result;
+    for ( sal_Int32 i = 0; i < aProp.getLength(); i++ )
+    {
+        if ( aProp[i].Name.equals(aName) )
+        {
+            aProp[i].Value >>= result;
+            return result;
+        }
+    }
+    return result;
+}
+
+sal_Bool setPropertyValue( uno::Sequence< beans::PropertyValue >& aProp, const rtl::OUString& aName, const uno::Any& aValue )
+{
+    for ( sal_Int32 i = 0; i < aProp.getLength(); i++ )
+    {
+        if ( aProp[i].Name.equals(aName) )
+        {
+            aProp[i].Value = aValue;
+            return sal_True;
+        }
+    }
+    return sal_False;
+}
+
+#define VBA_LEFT "PositionX"
+#define VBA_TOP "PositionY"
+UserFormGeometryHelper::UserFormGeometryHelper( const uno::Reference< uno::XComponentContext >& /*xContext*/, const uno::Reference< awt::XControl >& xControl )
+{
+    mxModel.set( xControl->getModel(), uno::UNO_QUERY_THROW );
+}
+    double UserFormGeometryHelper::getLeft()
+    {
+	sal_Int32 nLeft = 0;
+	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ) ) >>= nLeft;	
+	return Millimeter::getInPoints( nLeft );
+    }
+    void UserFormGeometryHelper::setLeft( double nLeft )
+    {
+        mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_LEFT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nLeft ) ) );
+    }
+    double UserFormGeometryHelper::getTop()
+    {
+	sal_Int32 nTop = 0;
+	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( VBA_TOP ) ) ) >>= nTop;	
+	return Millimeter::getInPoints( nTop );
+    }
+    void UserFormGeometryHelper::setTop( double nTop )
+    {
+	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	VBA_TOP ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nTop ) ) );
+    }
+    double UserFormGeometryHelper::getHeight()
+    {
+	sal_Int32 nHeight = 0;
+	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( NAME_HEIGHT ) ) ) >>= nHeight;	
+	return Millimeter::getInPoints( nHeight );
+    }
+    void UserFormGeometryHelper::setHeight( double nHeight )
+    {
+	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	NAME_HEIGHT ) ), uno::makeAny( Millimeter::getInHundredthsOfOneMillimeter( nHeight ) ) );
+    }
+    double UserFormGeometryHelper::getWidth()
+    {
+	sal_Int32 nWidth = 0;
+	mxModel->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	NAME_WIDTH ) ) ) >>= nWidth;	
+	return Millimeter::getInPoints( nWidth );
+    }
+    void UserFormGeometryHelper::setWidth( double nWidth)
+    {
+	mxModel->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 	NAME_WIDTH ) ), uno::makeAny(  Millimeter::getInHundredthsOfOneMillimeter( nWidth ) ) );
+    }
+
+    double ConcreteXShapeGeometryAttributes::getLeft()
+    {
+        return m_pShapeHelper->getLeft();
+    }
+    void ConcreteXShapeGeometryAttributes::setLeft( double nLeft )
+    {
+        m_pShapeHelper->setLeft( nLeft );
+    }
+    double ConcreteXShapeGeometryAttributes::getTop()
+    {
+        return m_pShapeHelper->getTop();
+    }
+    void ConcreteXShapeGeometryAttributes::setTop( double nTop )
+    {
+        m_pShapeHelper->setTop( nTop );
+    }
+
+    double ConcreteXShapeGeometryAttributes::getHeight()
+    {
+        return m_pShapeHelper->getHeight();
+    }
+    void ConcreteXShapeGeometryAttributes::setHeight( double nHeight )
+    {
+        m_pShapeHelper->setHeight( nHeight );
+    }
+    double ConcreteXShapeGeometryAttributes::getWidth()
+    {
+        return m_pShapeHelper->getWidth();
+    }
+    void ConcreteXShapeGeometryAttributes::setWidth( double nWidth)
+    {
+        m_pShapeHelper->setWidth( nWidth );
+    }
+
+
+	ShapeHelper::ShapeHelper( const css::uno::Reference< css::drawing::XShape >& _xShape) throw (css::script::BasicErrorException ) : xShape( _xShape )
+	{ 
+		if( !xShape.is() ) 
+			throw css::uno::RuntimeException( rtl::OUString::createFromAscii("No valid shape for helper"), css::uno::Reference< css::uno::XInterface >() );
+	}
+    
+	double ShapeHelper::getHeight()
+	{
+        	return  Millimeter::getInPoints(xShape->getSize().Height);
+    	}
+
+
+    	void ShapeHelper::setHeight(double _fheight) throw ( css::script::BasicErrorException )
+	{
+		try
+		{
+			css::awt::Size aSize = xShape->getSize();
+			aSize.Height = Millimeter::getInHundredthsOfOneMillimeter(_fheight);
+			xShape->setSize(aSize);
+		}
+		catch ( css::uno::Exception& /*e*/)
+		{
+			throw css::script::BasicErrorException( rtl::OUString(), css::uno::Reference< css::uno::XInterface >(), SbERR_METHOD_FAILED, rtl::OUString() );
+    		}
+	}
+    
+    
+	double ShapeHelper::getWidth()
+	{ 
+		return Millimeter::getInPoints(xShape->getSize().Width);
+    	}
+
+	void ShapeHelper::setWidth(double _fWidth) throw ( css::script::BasicErrorException )
+	{
+		try
+		{
+			css::awt::Size aSize = xShape->getSize();
+			aSize.Width = Millimeter::getInHundredthsOfOneMillimeter(_fWidth);
+			xShape->setSize(aSize);
+		}
+		catch (css::uno::Exception& /*e*/)
+		{
+			throw css::script::BasicErrorException( rtl::OUString(), css::uno::Reference< css::uno::XInterface >(), SbERR_METHOD_FAILED, rtl::OUString() );
+		}
+	}
+    
+    
+	double ShapeHelper::getLeft()
+	{
+		return Millimeter::getInPoints(xShape->getPosition().X);
+	}
+
+    
+	void ShapeHelper::setLeft(double _fLeft)
+	{
+		css::awt::Point aPoint = xShape->getPosition();
+		aPoint.X = Millimeter::getInHundredthsOfOneMillimeter(_fLeft);
+		xShape->setPosition(aPoint);
+	}
+    
+
+	double ShapeHelper::getTop()
+	{
+        	return Millimeter::getInPoints(xShape->getPosition().Y);
+	}
+
+    
+	void ShapeHelper::setTop(double _fTop)
+	{
+		css::awt::Point aPoint = xShape->getPosition();
+		aPoint.Y = Millimeter::getInHundredthsOfOneMillimeter(_fTop);
+		xShape->setPosition(aPoint);
+	}
+    
+	void DebugHelper::exception( const rtl::OUString&  DetailedMessage, const css::uno::Exception& ex,  int err, const rtl::OUString& /*additionalArgument*/ ) throw( css::script::BasicErrorException )
+	{
+		// #TODO #FIXME ( do we want to support additionalArg here )
+		throw css::script::BasicErrorException( DetailedMessage.concat( rtl::OUString::createFromAscii(" ") ).concat( ex.Message ), css::uno::Reference< css::uno::XInterface >(), err, rtl::OUString() );
+	}
+
+	void DebugHelper::exception( int err,  const rtl::OUString& additionalArgument ) throw( css::script::BasicErrorException )
+	{
+		exception( rtl::OUString(), css::uno::Exception(), err, additionalArgument );
+	}
+	void DebugHelper::exception( css::uno::Exception& ex ) throw( css::script::BasicErrorException )
+	{
+		exception( rtl::OUString(), ex, SbERR_INTERNAL_ERROR, rtl::OUString() );
+	}
+
+	Millimeter::Millimeter():m_nMillimeter(0) {}
+    
+	Millimeter::Millimeter(double mm):m_nMillimeter(mm) {}
+    
+	void Millimeter::set(double mm) { m_nMillimeter = mm; }
+	void Millimeter::setInPoints(double points) 
+	{ 
+		m_nMillimeter = points * 0.352777778; 
+		// 25.4mm / 72 
+	}
+      
+	void Millimeter::setInHundredthsOfOneMillimeter(double hmm)
+	{
+		m_nMillimeter = hmm / 100;
+	}
+    
+	double Millimeter::get()
+	{
+		return m_nMillimeter;
+	}
+	double Millimeter::getInHundredthsOfOneMillimeter()
+	{
+		return m_nMillimeter * 100;
+	}
+	double Millimeter::getInPoints()
+	{
+		return m_nMillimeter * 2.834645669; // 72 / 25.4mm
+	}    
+
+	sal_Int32 Millimeter::getInHundredthsOfOneMillimeter(double points)
+	{
+		sal_Int32 mm = static_cast<sal_Int32>(points * factor);
+		return mm;
+	}
+    
+	double Millimeter::getInPoints(int _hmm)
+	{
+		double points = double( static_cast<double>(_hmm) / factor);
+		return points;
+	}
+        
+        SfxObjectShell* getSfxObjShell( const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException)
+        {
+            SfxObjectShell* pFoundShell = NULL;
+            if ( xModel.is() )
+            {
+                uno::Reference< lang::XUnoTunnel >  xObjShellTunnel( xModel, uno::UNO_QUERY_THROW );
+                pFoundShell = reinterpret_cast<SfxObjectShell*>( xObjShellTunnel->getSomething(SfxObjectShell::getUnoTunnelId()));
+            }
+            if ( !pFoundShell )
+                throw uno::RuntimeException();
+            return pFoundShell;
+        }
+
+} // openoffice
+} //org
Index: vbahelper/source/vbahelper/vbashapes.cxx
===================================================================
--- vbahelper/source/vbahelper/vbashapes.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbashapes.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,491 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashapes.cxx,v $
+ * $Revision: 1.3.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/text/WrapTextMode.hpp>
+#include <ooo/vba/msforms/XShapeRange.hpp>
+#include <ooo/vba/office/MsoAutoShapeType.hpp>
+#include <ooo/vba/office/MsoTextOrientation.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XTextContent.hpp>
+#include <com/sun/star/text/TextContentAnchorType.hpp>
+#include <com/sun/star/text/HoriOrientation.hpp>
+#include <com/sun/star/text/VertOrientation.hpp>
+#include <com/sun/star/text/RelOrientation.hpp>
+#include <com/sun/star/text/SizeType.hpp>
+#include <com/sun/star/text/WritingMode.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+
+#include <vbahelper/vbahelper.hxx>
+#include <vbahelper/vbashape.hxx>
+#include <vbahelper/vbashapes.hxx>
+#include <vbahelper/vbashaperange.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class VbShapeEnumHelper : public EnumerationHelper_BASE
+{
+        uno::Reference<msforms::XShapes > m_xParent;
+        uno::Reference<container::XIndexAccess > m_xIndexAccess;
+        sal_Int32 nIndex;
+public:
+	VbShapeEnumHelper( const uno::Reference< msforms::XShapes >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+        {
+                return ( nIndex < m_xIndexAccess->getCount() );
+        }
+        virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+        {
+                ScVbaShapes* pShapes = dynamic_cast< ScVbaShapes* >(m_xParent.get());
+                if ( pShapes && hasMoreElements() )
+                    return pShapes->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
+                throw container::NoSuchElementException();
+        }
+
+};
+
+void ScVbaShapes::initBaseCollection()
+{
+	if ( m_xNameAccess.is() ) // already has NameAccess
+		return;
+	// no NameAccess then use ShapeCollectionHelper
+	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
+	sal_Int32 nLen = m_xIndexAccess->getCount();
+	mShapes.reserve( nLen );
+	for ( sal_Int32 index=0; index<nLen; ++index )
+		mShapes.push_back( uno::Reference< drawing::XShape >( m_xIndexAccess->getByIndex( index ) , uno::UNO_QUERY ) );
+	uno::Reference< container::XIndexAccess > xShapes( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
+	m_xIndexAccess.set( xShapes, uno::UNO_QUERY );
+	m_xNameAccess.set( xShapes, uno::UNO_QUERY );
+}
+
+ScVbaShapes::ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const uno::Reference< frame::XModel>& xModel ): ScVbaShapes_BASE( xParent, xContext, xShapes ), m_nNewShapeCount(0), m_xModel( xModel )
+{
+    m_xShapes.set( xShapes, uno::UNO_QUERY_THROW );
+    m_xDrawPage.set( xShapes, uno::UNO_QUERY_THROW ); 
+    initBaseCollection();
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaShapes::createEnumeration() throw (uno::RuntimeException)
+{
+    return new VbShapeEnumHelper( this,  m_xIndexAccess );
+}
+
+uno::Any
+ScVbaShapes::createCollectionObject( const css::uno::Any& aSource ) throw (uno::RuntimeException)
+{
+    if( aSource.hasValue() )
+    {
+        uno::Reference< drawing::XShape > xShape( aSource, uno::UNO_QUERY_THROW );
+        return uno::makeAny( uno::Reference< msforms::XShape >( new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) ) ) );
+    }
+    return uno::Any();
+}
+
+uno::Type
+ScVbaShapes::getElementType() throw (uno::RuntimeException)
+{
+    return ooo::vba::msforms::XShape::static_type(0);
+}
+rtl::OUString& 
+ScVbaShapes::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShapes") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaShapes::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Shapes" ) );
+	}
+	return aServiceNames;
+}
+
+css::uno::Reference< css::container::XIndexAccess > 
+ScVbaShapes::getShapesByArrayIndices( const uno::Any& Index  ) throw (uno::RuntimeException)
+{
+	if ( Index.getValueTypeClass() != uno::TypeClass_SEQUENCE )
+		throw uno::RuntimeException();
+	
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter(mxContext);
+	uno::Any aConverted;
+	aConverted = xConverter->convertTo( Index, getCppuType((uno::Sequence< uno::Any >*)0) );
+
+	uno::Sequence< uno::Any > sIndices;
+	aConverted >>= sIndices;
+	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec mShapes;
+	sal_Int32 nElems = sIndices.getLength();
+	for( sal_Int32 index = 0; index < nElems; ++index )
+	{
+		uno::Reference< drawing::XShape > xShape;
+		if ( sIndices[ index ].getValueTypeClass() == uno::TypeClass_STRING )
+		{
+			rtl::OUString sName;
+			sIndices[ index ] >>= sName;
+			xShape.set( m_xNameAccess->getByName( sName ), uno::UNO_QUERY );
+		}
+		else
+		{
+			sal_Int32 nIndex = 0;
+			sIndices[ index ] >>= nIndex;
+			// adjust for 1 based mso indexing
+			xShape.set( m_xIndexAccess->getByIndex( nIndex - 1 ), uno::UNO_QUERY );		
+			
+		}
+		// populate map with drawing::XShapes
+		if ( xShape.is() )
+			mShapes.push_back( xShape );
+	}  
+	uno::Reference< container::XIndexAccess > xIndexAccess( new XNamedObjectCollectionHelper< drawing::XShape >( mShapes ) );
+	return xIndexAccess;
+}
+
+uno::Any SAL_CALL 
+ScVbaShapes::Item( const uno::Any& Index, const uno::Any& Index2 ) throw (uno::RuntimeException)
+{
+	// I don't think we need to support Array of indices for shapes	
+/*
+	if ( Index.getValueTypeClass() == uno::TypeClass_SEQUENCE )
+	{
+		uno::Reference< container::XIndexAccess > xIndexAccess( getShapesByArrayIndices( Index ) );
+		// return new collection instance
+		uno::Reference< XCollection > xShapesCollection(  new ScVbaShapes( this->getParent(), mxContext, xIndexAccess ) );
+		return uno::makeAny( xShapesCollection );
+	}
+*/
+	return 	ScVbaShapes_BASE::Item( Index, Index2 );
+}
+
+uno::Reference< msforms::XShapeRange > SAL_CALL 
+ScVbaShapes::Range( const uno::Any& shapes ) throw (css::uno::RuntimeException)
+{
+	// shapes, can be an index or an array of indices
+	uno::Reference< container::XIndexAccess > xShapes;
+	if ( shapes.getValueTypeClass() == uno::TypeClass_SEQUENCE )
+		xShapes = getShapesByArrayIndices( shapes );
+	else
+	{
+		// wrap single index into a sequence
+		uno::Sequence< uno::Any > sIndices(1);
+		sIndices[ 0 ] = shapes;
+		uno::Any aIndex;
+		aIndex <<= sIndices;
+		xShapes = getShapesByArrayIndices( aIndex );
+	}
+	return new ScVbaShapeRange(  getParent(), mxContext, xShapes, m_xDrawPage, m_xModel );
+}
+
+void SAL_CALL 
+ScVbaShapes::SelectAll() throw (uno::RuntimeException)
+{
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    try
+    {
+        xSelectSupp->select( uno::makeAny( m_xShapes ) );
+    }
+    // viewuno.cxx ScTabViewObj::select will throw IllegalArgumentException
+    // if one of the shapes is no 'markable' e.g. a button 
+    // the method still works
+    catch( lang::IllegalArgumentException& )
+    {
+    }
+}
+
+uno::Reference< drawing::XShape > 
+ScVbaShapes::createShape( rtl::OUString service ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< lang::XMultiServiceFactory > xMSF( m_xModel, uno::UNO_QUERY_THROW );
+    uno::Reference< drawing::XShape > xShape( xMSF->createInstance( service ), uno::UNO_QUERY_THROW );
+    return xShape;
+}
+
+uno::Any 
+ScVbaShapes::AddRectangle( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, uno::Any aRange ) throw (css::uno::RuntimeException)
+{
+    rtl::OUString sCreateShapeName( rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) );
+    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( startX );
+    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( startY );
+    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
+
+    uno::Reference< drawing::XShape > xShape( createShape( sCreateShapeName ), uno::UNO_QUERY_THROW );
+    m_xShapes->add( xShape );
+
+    rtl::OUString sName = createName( rtl::OUString::createFromAscii( "Rectangle" ) );
+    setDefaultShapeProperties( xShape );
+    setShape_NameProperty( xShape, sName );
+
+    awt::Point aMovePositionIfRange(0, 0);
+    awt::Point position;
+    position.X = nXPos - aMovePositionIfRange.X;
+    position.Y = nYPos - aMovePositionIfRange.Y;
+    xShape->setPosition( position );
+
+    awt::Size size;
+    size.Height = nHeight;
+    size.Width = nWidth;
+    xShape->setSize( size );
+
+    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) );
+    pScVbaShape->setRange( aRange ); 
+    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
+}
+
+uno::Any 
+ScVbaShapes::AddEllipse( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, uno::Any aRange ) throw (css::uno::RuntimeException)
+{
+    rtl::OUString sCreateShapeName( rtl::OUString::createFromAscii( "com.sun.star.drawing.EllipseShape" ) );
+    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( startX );
+    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( startY );
+    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
+
+    uno::Reference< drawing::XShape > xShape( createShape( sCreateShapeName ), uno::UNO_QUERY_THROW );
+    m_xShapes->add( xShape );
+
+    awt::Point aMovePositionIfRange( 0, 0 );
+    //TODO helperapi using a writer document
+    /*
+    XDocument xDocument = (XDocument)getParent();
+    if (AnyConverter.isVoid(_aRange))
+    {
+        _aRange = xDocument.Range(new Integer(0), new Integer(1));
+        // Top&Left in Word is Top&Left of the paper and not the writeable area.
+        aMovePositionIfRange = calculateTopLeftMargin((HelperInterfaceAdaptor)xDocument);
+    }
+
+    setShape_AnchorTypeAndRangeProperty(xShape, _aRange);
+    */
+    rtl::OUString name = createName( rtl::OUString::createFromAscii( "Oval" ));
+    setDefaultShapeProperties(xShape);
+    setShape_NameProperty(xShape, name);
+
+    awt::Point position;
+    position.X = nXPos - aMovePositionIfRange.X;
+    position.Y = nYPos - aMovePositionIfRange.Y;
+    xShape->setPosition(position);
+
+    awt::Size size;
+    size.Height = nHeight;
+    size.Width = nWidth;
+    xShape->setSize(size);
+
+    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) );
+    pScVbaShape->setRange( aRange ); 
+    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
+}
+
+//helpeapi calc
+uno::Any SAL_CALL
+ScVbaShapes::AddLine( sal_Int32 StartX, sal_Int32 StartY, sal_Int32 endX, sal_Int32 endY ) throw (uno::RuntimeException)
+{
+    sal_Int32 nLineWidth = endX - StartX;
+    sal_Int32 nLineHeight = endY - StartY;
+
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( nLineHeight );
+    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( nLineWidth );
+    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( StartX );
+    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( StartY );
+    
+    uno::Reference< drawing::XShape > xShape( createShape( rtl::OUString::createFromAscii("com.sun.star.drawing.LineShape") ), uno::UNO_QUERY_THROW );
+    m_xShapes->add( xShape );
+
+    awt::Point aMovePositionIfRange( 0, 0 );
+    
+    rtl::OUString name = createName( rtl::OUString::createFromAscii( "Line" ) );
+    setDefaultShapeProperties(xShape);
+    setShape_NameProperty(xShape, name);
+
+    awt::Point position;
+    position.X = nXPos - aMovePositionIfRange.X;
+    position.Y = nYPos - aMovePositionIfRange.Y;
+    xShape->setPosition(position);
+
+    awt::Size size;
+    size.Height = nHeight;
+    size.Width = nWidth;
+    xShape->setSize(size);
+
+    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) );
+    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
+}
+
+uno::Any SAL_CALL
+ScVbaShapes::AddShape( sal_Int32 _nType, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (uno::RuntimeException)
+{
+    uno::Any _aAnchor;
+    if (_nType == office::MsoAutoShapeType::msoShapeRectangle)
+    {
+        return AddRectangle(_nLeft, _nTop, _nWidth, _nHeight, _aAnchor);
+    }
+    else if (_nType == office::MsoAutoShapeType::msoShapeOval)
+    {
+        return AddEllipse(_nLeft, _nTop, _nWidth, _nHeight, _aAnchor);
+    }
+    return uno::Any();
+}
+
+uno::Any SAL_CALL
+ScVbaShapes::AddTextbox( sal_Int32 _nOrientation, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XServiceInfo > xServiceInfo( m_xModel, uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) )
+    {
+        return AddTextboxInWriter( _nOrientation, _nLeft, _nTop, _nWidth, _nHeight );
+    }
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+uno::Any
+ScVbaShapes::AddTextboxInWriter( sal_Int32 /*_nOrientation*/, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (uno::RuntimeException)
+{
+    rtl::OUString sCreateShapeName( rtl::OUString::createFromAscii( "com.sun.star.drawing.TextShape" ) );
+    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( _nLeft );
+    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( _nTop );
+    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( _nWidth );
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( _nHeight );
+
+    uno::Reference< drawing::XShape > xShape( createShape( sCreateShapeName ), uno::UNO_QUERY_THROW );
+    m_xShapes->add( xShape );
+
+    setDefaultShapeProperties(xShape);
+
+    rtl::OUString sName =  createName( rtl::OUString::createFromAscii( "Text Box") );
+    setShape_NameProperty( xShape, sName );
+
+    awt::Size size;
+    size.Height = nHeight;
+    size.Width = nWidth;
+    xShape->setSize(size);
+
+    uno::Reference< beans::XPropertySet > xShapeProps( xShape, uno::UNO_QUERY_THROW );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "AnchorType" ), uno::makeAny( text::TextContentAnchorType_AT_PAGE ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "HoriOrientRelation" ), uno::makeAny( text::RelOrientation::PAGE_LEFT ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "HoriOrient" ), uno::makeAny( text::HoriOrientation::NONE ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "HoriOrientPosition" ), uno::makeAny( nXPos ) );
+
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "VertOrientRelation" ), uno::makeAny( text::RelOrientation::PAGE_FRAME ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "VertOrient" ), uno::makeAny( text::VertOrientation::NONE ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "VertOrientPosition" ), uno::makeAny( nYPos ) );
+
+    // set to visible
+    drawing::LineStyle aLineStyle = drawing::LineStyle_SOLID;
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "LineStyle" ), uno::makeAny( aLineStyle ) );
+    // set to font
+    sal_Int16 nLayerId = 1;
+    rtl::OUString sLayerName = rtl::OUString::createFromAscii("Heaven");
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "LayerID" ), uno::makeAny( nLayerId ) );
+    xShapeProps->setPropertyValue( rtl::OUString::createFromAscii( "LayerName" ), uno::makeAny( sLayerName ) );
+
+
+    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) );
+    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
+}
+
+uno::Any
+ScVbaShapes::AddShape( const rtl::OUString& sService, const rtl::OUString& sName, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (uno::RuntimeException)
+{
+    sal_Int32 nXPos = Millimeter::getInHundredthsOfOneMillimeter( _nLeft );
+    sal_Int32 nYPos = Millimeter::getInHundredthsOfOneMillimeter( _nTop );
+    sal_Int32 nWidth = Millimeter::getInHundredthsOfOneMillimeter( _nWidth );
+    sal_Int32 nHeight = Millimeter::getInHundredthsOfOneMillimeter( _nHeight );
+
+    uno::Reference< drawing::XShape > xShape( createShape( sService ), uno::UNO_QUERY_THROW );
+    m_xShapes->add( xShape );
+
+    setDefaultShapeProperties(xShape);
+    setShape_NameProperty( xShape, sName );
+
+    awt::Point aMovePositionIfRange( 0, 0 );
+    awt::Point position;
+    position.X = nXPos - aMovePositionIfRange.X;
+    position.Y = nYPos - aMovePositionIfRange.Y;
+    xShape->setPosition(position);
+
+    awt::Size size;
+    size.Height = nHeight;
+    size.Width = nWidth;
+    xShape->setSize(size);
+
+    ScVbaShape *pScVbaShape = new ScVbaShape( getParent(), mxContext, xShape, m_xShapes, m_xModel, ScVbaShape::getType( xShape ) );
+    return uno::makeAny( uno::Reference< msforms::XShape > ( pScVbaShape ) );
+}
+void
+ScVbaShapes::setDefaultShapeProperties( uno::Reference< drawing::XShape > xShape ) throw (uno::RuntimeException)
+{
+    uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
+    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillStyle" ), uno::makeAny( rtl::OUString::createFromAscii( "SOLID" ) ) );
+    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillColor"), uno::makeAny( sal_Int32(0xFFFFFF) )  );
+    xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextWordWrap"), uno::makeAny( text::WrapTextMode_THROUGHT )  );
+    //not find in OOo2.3
+    //xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "Opaque"), uno::makeAny( sal_True )  );
+}
+
+void
+ScVbaShapes::setShape_NameProperty( uno::Reference< css::drawing::XShape > xShape, rtl::OUString sName )
+{
+    uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
+    try
+    {
+        xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "Name" ), uno::makeAny( sName ) );
+    }
+    catch( script::BasicErrorException e )
+    {
+    }
+}
+
+rtl::OUString
+ScVbaShapes::createName( rtl::OUString sName )
+{
+    sal_Int32 nActNumber = 1 + m_nNewShapeCount;
+    m_nNewShapeCount++; 
+    sName += rtl::OUString::valueOf( nActNumber );
+    return sName;
+}
+
+#if 0
+//TODO helperapi using a writer document
+awt::Point
+calculateTopLeftMargin( uno::Reference< XHelperInterface > xDocument )
+{
+    awt::Point aPoint( 0, 0 );
+    uno::Reference< frame::XModel > xModel( xDocument, uno::UNO_QUERY_THROW );
+    return awt::Point();
+}
+#endif
Index: vbahelper/source/vbahelper/vbapictureformat.cxx
===================================================================
--- vbahelper/source/vbahelper/vbapictureformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbapictureformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,148 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbapictureformat.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbapictureformat.hxx"
+
+using namespace ooo::vba;
+using namespace com::sun::star;
+
+ScVbaPictureFormat::ScVbaPictureFormat( const css::uno::Reference< ov::XHelperInterface >& xParent,
+    const css::uno::Reference< css::uno::XComponentContext >& xContext,
+    uno::Reference< drawing::XShape > xShape ) 
+    throw( lang::IllegalArgumentException ) : ScVbaPictureFormat_BASE( xParent, xContext ), m_xShape( xShape )
+{
+    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
+}
+
+void
+ScVbaPictureFormat::checkParameterRangeInDouble( double nRange, double nMin, double nMax ) throw (css::uno::RuntimeException)
+{
+    if( nRange < nMin )
+    {
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter out of range, value is too small.") , uno::Reference< uno::XInterface >() );
+    }
+    if( nRange > nMax )
+    {
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Parameter out of range, value is too high.") , uno::Reference< uno::XInterface >() );
+    }
+}
+
+// Attributes
+double SAL_CALL 
+ScVbaPictureFormat::getBrightness() throw (uno::RuntimeException)
+{
+    sal_Int16 nLuminance = 0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("AdjustLuminance") ) >>= nLuminance;
+    double fBrightness = static_cast< double >( nLuminance );
+    fBrightness = ( fBrightness +100 ) / 200;
+    return fBrightness; 
+}
+
+void SAL_CALL 
+ScVbaPictureFormat::setBrightness( double _brightness ) throw (uno::RuntimeException)
+{
+    checkParameterRangeInDouble( _brightness, 0.0, 1.0 );
+    double fLuminance = _brightness * 200 - 100;
+    sal_Int16 nLuminance = static_cast< sal_Int16 >( fLuminance );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("AdjustLuminance"), uno::makeAny( nLuminance ) ); 
+}
+
+double SAL_CALL 
+ScVbaPictureFormat::getContrast() throw (uno::RuntimeException)
+{
+    sal_Int16 nContrast = 0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("AdjustContrast") ) >>= nContrast;
+    double fContrast = static_cast< double >( nContrast );
+    fContrast = ( fContrast + 100 ) / 200;
+    return fContrast;
+}
+
+void SAL_CALL 
+ScVbaPictureFormat::setContrast( double _contrast ) throw (uno::RuntimeException)
+{
+    checkParameterRangeInDouble( _contrast, 0.0, 1.0 );
+    double fContrast = _contrast * 200 - 100;
+    sal_Int16 nContrast = static_cast< sal_Int16 >( fContrast );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("AdjustContrast"), uno::makeAny( nContrast ) );
+}
+
+
+// Methods
+void SAL_CALL 
+ScVbaPictureFormat::IncrementBrightness( double increment ) throw (uno::RuntimeException)
+{
+    double fBrightness = getBrightness();
+    fBrightness += increment;
+    if( fBrightness < 0 )
+    {
+        fBrightness = 0.0;
+    }
+    if( fBrightness > 1 )
+    {
+        fBrightness = 1;
+    }
+    setBrightness( fBrightness );
+}
+
+void SAL_CALL 
+ScVbaPictureFormat::IncrementContrast( double increment ) throw (uno::RuntimeException)
+{
+    double nContrast = getContrast();
+    nContrast += increment;
+	//VBA, minz@cn.ibm.com.
+    if( nContrast < 0 )
+    {
+        nContrast = 0.0;
+    }
+    if( nContrast > 1 )
+    {
+        nContrast = 1.0;
+    }
+    setContrast( nContrast );
+}
+
+
+rtl::OUString&
+ScVbaPictureFormat::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaPictureFormat") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+ScVbaPictureFormat::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.PictureFormat" ) );
+    }
+    return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbacommandbars.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbars.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbars.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,238 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/XUIConfigurationStorage.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManager.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+
+#include "vbacommandbars.hxx"
+#include "vbacommandbar.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > CommandBarEnumeration_BASE;
+
+class CommandBarEnumeration : public CommandBarEnumeration_BASE
+{
+    uno::Reference< XHelperInterface > m_xParent;
+    uno::Reference< uno::XComponentContext > m_xContext;
+    VbaCommandBarHelperRef pCBarHelper;
+    uno::Sequence< rtl::OUString > m_sNames;
+    sal_Int32 m_nCurrentPosition;
+public:
+    CommandBarEnumeration( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, VbaCommandBarHelperRef pHelper) throw ( uno::RuntimeException ) : m_xParent( xParent ), m_xContext( xContext ), pCBarHelper( pHelper ) , m_nCurrentPosition( 0 )
+    {
+        uno::Reference< container::XNameAccess > xNameAccess = pCBarHelper->getPersistentWindowState();
+        m_sNames = xNameAccess->getElementNames();
+    }
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        if( m_nCurrentPosition < m_sNames.getLength() )
+            return sal_True;
+        return sal_False;
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        // FIXME: should be add menubar
+        if( hasMoreElements() )
+        {
+            rtl::OUString sResourceUrl( m_sNames[ m_nCurrentPosition++ ] );
+            if( sResourceUrl.indexOf( rtl::OUString::createFromAscii("private:resource/toolbar/") ) != -1 ) 
+            {
+                uno::Reference< container::XIndexAccess > xCBarSetting = pCBarHelper->getSettings( sResourceUrl );
+                uno::Reference< XCommandBar > xCommandBar( new ScVbaCommandBar( m_xParent, m_xContext, pCBarHelper, xCBarSetting, sResourceUrl, sal_False, sal_False ) );
+             }
+             else
+                return nextElement();
+        }
+        else
+            throw container::NoSuchElementException();
+        return uno::Any();
+    }
+};
+
+ScVbaCommandBars::ScVbaCommandBars( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess, const uno::Reference< frame::XModel >& xModel ) throw ( uno::RuntimeException ) : CommandBars_BASE( xParent, xContext, xIndexAccess )
+{
+    pCBarHelper.reset( new VbaCommandBarHelper( mxContext, xModel ) );
+    m_xNameAccess = pCBarHelper->getPersistentWindowState();
+}
+
+ScVbaCommandBars::~ScVbaCommandBars()
+{
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL 
+ScVbaCommandBars::getElementType() throw ( uno::RuntimeException )
+{
+    return XCommandBar::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaCommandBars::createEnumeration() throw ( uno::RuntimeException )
+{
+    return uno::Reference< container::XEnumeration >( new CommandBarEnumeration( this, mxContext, pCBarHelper ) );
+}
+
+uno::Any
+ScVbaCommandBars::createCollectionObject( const uno::Any& aSource )
+{
+    // aSource should be a name at this time, because of the class is API wrapper.
+    rtl::OUString sResourceUrl;
+    uno::Reference< container::XIndexAccess > xBarSettings;
+    rtl::OUString sBarName;
+    sal_Bool bMenu = sal_False;
+    if( aSource >>= sBarName )
+    {
+        if( sBarName.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii("Worksheet Menu Bar") )
+            || sBarName.equalsIgnoreAsciiCase( rtl::OUString::createFromAscii("Menu Bar") ) )
+        {
+            // menu bar
+            sResourceUrl = rtl::OUString::createFromAscii( ITEM_MENUBAR_URL );
+            bMenu = sal_True;
+        }
+        else
+        {
+            sResourceUrl = pCBarHelper->findToolbarByName( m_xNameAccess, sBarName );
+            bMenu = sal_False;
+        }
+    }
+
+    if( sResourceUrl.getLength() )
+        xBarSettings = pCBarHelper->getSettings( sResourceUrl );
+    else
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toolbar do not exist") ), uno::Reference< uno::XInterface >() );
+
+    return uno::Any( uno::Reference< XCommandBar >( new ScVbaCommandBar( this, mxContext, pCBarHelper, xBarSettings, sResourceUrl, bMenu, sal_False ) ) );
+}
+
+// XCommandBars
+uno::Reference< XCommandBar > SAL_CALL 
+ScVbaCommandBars::Add( const css::uno::Any& Name, const css::uno::Any& /*Position*/, const css::uno::Any& /*MenuBar*/, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException)
+{
+    // FIXME: only support to add Toolbar
+    // Position - MsoBar MenuBar - sal_Bool
+    // Currently only the Name is supported.
+    rtl::OUString sName;
+    if( Name.hasValue() )
+        Name >>= sName;
+
+    rtl::OUString sResourceUrl;
+    if( sName.getLength() )
+    {
+        sResourceUrl = pCBarHelper->findToolbarByName( m_xNameAccess, sName );
+        if( sResourceUrl.getLength() )
+            throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Toolbar exists") ), uno::Reference< uno::XInterface >() );
+    }
+    else
+    {
+        sName = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Custom1") );
+    }    
+
+    sal_Bool bTemporary = sal_False;
+    if( Temporary.hasValue() )
+        Temporary >>= bTemporary;
+    
+    sResourceUrl = VbaCommandBarHelper::generateCustomURL();
+    uno::Reference< container::XIndexAccess > xBarSettings( pCBarHelper->getSettings( sResourceUrl ), uno::UNO_QUERY_THROW );
+    uno::Reference< XCommandBar > xCBar( new ScVbaCommandBar( this, mxContext, pCBarHelper, xBarSettings, sResourceUrl, sal_False, bTemporary ) );
+    xCBar->setName( sName );
+    return xCBar;
+}
+sal_Int32 SAL_CALL 
+ScVbaCommandBars::getCount() throw(css::uno::RuntimeException)
+{
+    // Filter out all toolbars from the window collection
+    sal_Int32 nCount = 1; // there is a Menubar in OOo
+    uno::Sequence< ::rtl::OUString > allNames = m_xNameAccess->getElementNames();
+    for( sal_Int32 i = 0; i < allNames.getLength(); i++ )
+    {
+        if(allNames[i].indexOf( rtl::OUString::createFromAscii("private:resource/toolbar/") ) != -1 )
+        {
+            nCount++;
+        }
+    }
+    return nCount;
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any SAL_CALL
+ScVbaCommandBars::Item( const uno::Any& aIndex, const uno::Any& /*aIndex2*/ ) throw( uno::RuntimeException )
+{
+    if( aIndex.getValueTypeClass() == uno::TypeClass_STRING )
+    {
+        return createCollectionObject( aIndex );    
+    }
+
+    // hardcode if "aIndex = 1" that would return "main menu".
+    sal_Int16 nIndex = 0;
+    aIndex >>= nIndex;
+    if( nIndex == 1 )
+    {
+        uno::Any aSource;
+        if( pCBarHelper->getModuleId().equalsAscii( "com.sun.star.sheet.SpreadsheetDocument" ) )
+            aSource <<= rtl::OUString::createFromAscii( "Worksheet Menu Bar" );
+        else if( pCBarHelper->getModuleId().equalsAscii("com.sun.star.text.TextDocument") )
+            aSource <<= rtl::OUString::createFromAscii( "Menu Bar" );
+        if( aSource.hasValue() )    
+            return createCollectionObject( aSource );
+    }
+    return uno::Any();
+}
+
+// XHelperInterface
+rtl::OUString& 
+ScVbaCommandBars::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBars") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBars::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBars" ) );
+    }
+    return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbacolorformat.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacolorformat.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacolorformat.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacolorformat.cxx,v $
+ * $Revision: 1.3.146.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/msforms/XLineFormat.hpp>
+#include "vbacolorformat.hxx"
+
+using namespace ooo::vba;
+using namespace com::sun::star;
+
+sal_Int32
+MsoColorIndizes::getColorIndex( sal_Int32 nIndex )
+{
+    const static sal_Int32 COLORINDIZES[56] =
+    {   HAPICOLOR_BLACK, HAPICOLOR_WITHE, HAPICOLOR_RED, HAPICOLOR_BRIGHTGREEN, HAPICOLOR_BLUE, HAPICOLOR_YELLOW, HAPICOLOR_PINK,
+        HAPICOLOR_TURQUOISE, HAPICOLOR_DARKRED, HAPICOLOR_GREEN, HAPICOLOR_DARKBLUE, HAPICOLOR_DARKYELLOW, HAPICOLOR_VIOLET,
+        HAPICOLOR_TEAL, HAPICOLOR_GRAY_25_PERCENT, HAPICOLOR_GRAY_50_PERCENT, HAPICOLOR_PERIWINCKLE, HAPICOLOR_PLUM,
+        HAPICOLOR_IVORY, HAPICOLOR_LIGHTTURQUOISE, HAPICOLOR_DARKPRUPLE, HAPICOLOR_CORAL, HAPICOLOR_OCEANBLUE, HAPICOLOR_ICEBLUE,
+        HAPICOLOR_GREEN, HAPICOLOR_PINK, HAPICOLOR_YELLOW, HAPICOLOR_TURQUOISE, HAPICOLOR_VIOLET, HAPICOLOR_DARKRED, HAPICOLOR_TEAL,
+        HAPICOLOR_BLUE, HAPICOLOR_SKYBLUE, HAPICOLOR_LIGHTTURQUOISE, HAPICOLOR_LIGHTGREEN, HAPICOLOR_LIGHTYELLOW, HAPICOLOR_PALEBLUE,
+        HAPICOLOR_ROSE, HAPICOLOR_LAVENDER, HAPICOLOR_TAN, HAPICOLOR_LIGHTBLUE, HAPICOLOR_AQUA, HAPICOLOR_LIME, HAPICOLOR_GOLD,
+        HAPICOLOR_LIGHTORANGE, HAPICOLOR_ORANGE, HAPICOLOR_BLUEGRAY, HAPICOLOR_GRAY_40_PERCENT, HAPICOLOR_DARKTEAL,
+        HAPICOLOR_SEAGREEN, HAPICOLOR_NONAME, HAPICOLOR_OLIVEGREEN, HAPICOLOR_BROWN, HAPICOLOR_PLUM, HAPICOLOR_INDIGO,
+        HAPICOLOR_GRAY_80_PERCENT
+    };
+    return COLORINDIZES[nIndex];
+}
+ScVbaColorFormat::ScVbaColorFormat( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< XHelperInterface > xInternalParent, const uno::Reference< drawing::XShape > xShape, const sal_Int16 nColorFormatType ) : ScVbaColorFormat_BASE( xParent, xContext ), m_xInternalParent( xInternalParent ), m_xShape( xShape ), m_nColorFormatType( nColorFormatType )
+{
+    m_xPropertySet.set( xShape, uno::UNO_QUERY_THROW );
+    m_nFillFormatBackColor = 0;
+    try
+    {
+        uno::Reference< ov::msforms::XFillFormat > xFillFormat( xInternalParent, uno::UNO_QUERY_THROW );
+        m_pFillFormat = ( ScVbaFillFormat* )( xFillFormat.get() );
+    }catch ( uno::RuntimeException  e )
+    {
+        m_pFillFormat = NULL;
+    }
+}
+
+void
+ScVbaColorFormat::setColorFormat( sal_Int16 _ntype )
+{
+    m_nColorFormatType = _ntype;
+}
+
+// Attribute
+sal_Int32 SAL_CALL 
+ScVbaColorFormat::getRGB() throw (uno::RuntimeException)
+{
+    sal_Int32 nRGB = 0;
+    switch( m_nColorFormatType )
+    {
+    case ColorFormatType::LINEFORMAT_FORECOLOR:
+        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("LineColor") ) >>= nRGB;
+        break;
+    case ColorFormatType::LINEFORMAT_BACKCOLOR:
+        //TODO BackColor not supported
+        // m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii("Color"), uno::makeAny( nRGB ) );
+        break;
+    case ColorFormatType::FILLFORMAT_FORECOLOR:
+        m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("FillColor") ) >>= nRGB;
+        break;
+    case ColorFormatType::FILLFORMAT_BACKCOLOR:
+        nRGB = m_nFillFormatBackColor;
+        break;
+    default:
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Second parameter of ColorFormat is wrong."), uno::Reference< uno::XInterface >() );
+    }
+    nRGB = OORGBToXLRGB( nRGB );
+    return nRGB;
+}
+
+void SAL_CALL 
+ScVbaColorFormat::setRGB( sal_Int32 _rgb ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRGB = XLRGBToOORGB( _rgb );
+    switch( m_nColorFormatType )
+    {
+    case ColorFormatType::LINEFORMAT_FORECOLOR:
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "LineColor" ), uno::makeAny( nRGB ) );
+        break;
+    case ColorFormatType::LINEFORMAT_BACKCOLOR:
+        // TODO BackColor not supported
+        break;
+    case ColorFormatType::FILLFORMAT_FORECOLOR:
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "FillColor" ), uno::makeAny( nRGB ) );
+        if( m_pFillFormat )
+        {
+            m_pFillFormat->setForeColorAndInternalStyle(nRGB);
+        }
+        break;
+    case ColorFormatType::FILLFORMAT_BACKCOLOR:
+        m_nFillFormatBackColor = nRGB;
+        if( m_pFillFormat )
+        {
+            m_pFillFormat->setForeColorAndInternalStyle(nRGB);
+        }
+        break;
+    default:    
+        throw uno::RuntimeException( rtl::OUString::createFromAscii("Second parameter of ColorFormat is wrong."), uno::Reference< uno::XInterface >() );
+    }
+}
+
+sal_Int32 SAL_CALL 
+ScVbaColorFormat::getSchemeColor() throw (uno::RuntimeException)
+{
+    sal_Int32 nColor = getRGB();
+    // #TODO I guess the number of elements is determined by the correct scheme
+    // the implementation here seems to be a rehash of color index ( which seems to be a 
+    // different thing ) - I would guess we need to know/import etc. the correct color scheme
+    // or at least find out a little more
+    sal_Int32 i = 0;
+    for( ; i < 56; i++ )
+    {
+        if( nColor == MsoColorIndizes::getColorIndex(i) )
+	   break;
+    }
+
+    if( i == 56 ) // this is most likely an error condition
+        --i;
+    return i; 
+    // #TODO figure out what craziness is this, 
+    // the 56 colors seems incorrect, as in default XL ( 2003 ) there are 80 colors
+/*
+    if( i == 56 )
+    {
+        i = -2;
+    }
+
+    return ( i + 2 );
+*/
+}
+
+void SAL_CALL 
+ScVbaColorFormat::setSchemeColor( sal_Int32 _schemecolor ) throw (uno::RuntimeException)
+{
+    // the table is 0 based
+    sal_Int32 nColor = MsoColorIndizes::getColorIndex( _schemecolor );
+    // nColor is already xl RGB
+    setRGB( nColor );
+}
+
+
+rtl::OUString&
+ScVbaColorFormat::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaColorFormat") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+ScVbaColorFormat::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.ColorFormat" ) );
+    }
+    return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbacommandbarcontrols.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarcontrols.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarcontrols.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,256 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacommandbarcontrols.hxx"
+#include "vbacommandbarcontrol.hxx"
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > CommandBarControlEnumeration_BASE;
+class CommandBarControlEnumeration : public CommandBarControlEnumeration_BASE
+{
+    //uno::Reference< uno::XComponentContext > m_xContext;
+    ScVbaCommandBarControls* m_pCommandBarControls;
+    sal_Int32 m_nCurrentPosition;
+public:
+    CommandBarControlEnumeration( ScVbaCommandBarControls* pCommandBarControls ) : m_pCommandBarControls( pCommandBarControls ), m_nCurrentPosition( 0 ) {}
+    virtual sal_Bool SAL_CALL hasMoreElements() throw ( uno::RuntimeException )
+    {
+        if( m_nCurrentPosition < m_pCommandBarControls->getCount() )
+            return sal_True;
+        return sal_False;
+    }
+    virtual uno::Any SAL_CALL nextElement() throw ( container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException )
+    {
+        if( hasMoreElements() )
+        {
+            return m_pCommandBarControls->createCollectionObject( uno::makeAny( m_nCurrentPosition++ ) );
+        }
+        else
+            throw container::NoSuchElementException();
+    }
+};
+
+ScVbaCommandBarControls::ScVbaCommandBarControls( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess>& xIndexAccess, VbaCommandBarHelperRef pHelper, const uno::Reference< container::XIndexAccess>& xBarSettings, const rtl::OUString& sResourceUrl, const uno::Reference< awt::XMenu >& xMenu  ) throw (uno::RuntimeException) : CommandBarControls_BASE( xParent, xContext, xIndexAccess ), pCBarHelper( pHelper ), m_xBarSettings( xBarSettings ), m_sResourceUrl( sResourceUrl ), m_xMenu( xMenu )
+{
+    m_bIsMenu = sResourceUrl.equalsAscii( ITEM_MENUBAR_URL ) ? sal_True : sal_False;
+}
+
+uno::Sequence< beans::PropertyValue > ScVbaCommandBarControls::CreateMenuItemData( const rtl::OUString& sCommandURL, const rtl::OUString& sHelpURL, const rtl::OUString& sLabel, sal_uInt16 nType, const uno::Any& aSubMenu )
+{
+    uno::Sequence< beans::PropertyValue > aProps(5);
+
+    aProps[0].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_COMMANDURL );
+    aProps[0].Value <<= sCommandURL;
+    aProps[1].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_HELPURL );
+    aProps[1].Value <<= sHelpURL;
+    aProps[2].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_LABEL );
+    aProps[2].Value <<= sLabel;
+    aProps[3].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_TYPE );
+    aProps[3].Value <<= nType;
+    aProps[4].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_CONTAINER );
+    aProps[4].Value = aSubMenu;
+
+    return aProps;
+}
+
+uno::Sequence< beans::PropertyValue > ScVbaCommandBarControls::CreateToolbarItemData( const rtl::OUString& sCommandURL, const rtl::OUString& sHelpURL, const rtl::OUString& sLabel, sal_uInt16 nType, const uno::Any& aSubMenu, sal_Bool isVisible, sal_Int32 nStyle )
+{
+    uno::Sequence< beans::PropertyValue > aProps(7);
+
+    aProps[0].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_COMMANDURL );
+    aProps[0].Value <<= sCommandURL;
+    aProps[1].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_HELPURL );
+    aProps[1].Value <<= sHelpURL;
+    aProps[2].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_LABEL );
+    aProps[2].Value <<= sLabel;
+    aProps[3].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_TYPE );
+    aProps[3].Value <<= nType;
+    aProps[4].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_CONTAINER );
+    aProps[4].Value = aSubMenu;
+    aProps[5].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_ISVISIBLE );
+    aProps[5].Value <<= isVisible;
+    aProps[6].Name = rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_STYLE );
+    aProps[6].Value <<= nStyle;
+
+    return aProps;
+}
+
+// XEnumerationAccess
+uno::Type SAL_CALL
+ScVbaCommandBarControls::getElementType() throw ( uno::RuntimeException )
+{
+    return XCommandBarControl::static_type( 0 );
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaCommandBarControls::createEnumeration() throw ( uno::RuntimeException )
+{
+    return uno::Reference< container::XEnumeration >( new CommandBarControlEnumeration( this ) );
+}
+
+uno::Any
+ScVbaCommandBarControls::createCollectionObject( const uno::Any& aSource )
+{
+    sal_Int32 nPosition = -1;
+    aSource >>= nPosition;
+    uno::Sequence< beans::PropertyValue > aProps;
+    m_xIndexAccess->getByIndex( nPosition ) >>= aProps;
+    uno::Reference< container::XIndexAccess > xSubMenu;
+    getPropertyValue( aProps, rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_CONTAINER ) ) >>= xSubMenu;
+    ScVbaCommandBarControl* pNewCommandBarControl = NULL;
+    if( xSubMenu.is() )
+        pNewCommandBarControl = new ScVbaCommandBarPopup( this, mxContext, m_xIndexAccess, pCBarHelper, m_xBarSettings, m_sResourceUrl, nPosition, sal_True, m_xMenu );
+    else
+        pNewCommandBarControl = new ScVbaCommandBarButton( this, mxContext, m_xIndexAccess, pCBarHelper, m_xBarSettings, m_sResourceUrl, nPosition, sal_True, m_xMenu );
+
+    return uno::makeAny( uno::Reference< XCommandBarControl > ( pNewCommandBarControl ) );
+}
+
+// Methods
+uno::Any SAL_CALL 
+ScVbaCommandBarControls::Item( const uno::Any& aIndex, const uno::Any& /*aIndex*/ ) throw (uno::RuntimeException)
+{
+    sal_Int32 nPosition = -1;
+    if( aIndex.getValueTypeClass() == uno::TypeClass_STRING )
+    {
+        rtl::OUString sName;
+        aIndex >>= sName;
+        nPosition = VbaCommandBarHelper::findControlByName( m_xIndexAccess, sName );
+    } 
+    else
+    {
+        aIndex >>= nPosition;
+    }
+
+    if( nPosition < 0 || nPosition >= getCount() )
+    {
+        throw uno::RuntimeException();
+    }
+    
+    return createCollectionObject( uno::makeAny( nPosition ) ); 
+}
+
+uno::Reference< XCommandBarControl > SAL_CALL 
+ScVbaCommandBarControls::Add( const uno::Any& Type, const uno::Any& Id, const uno::Any& Parameter, const uno::Any& Before, const uno::Any& Temporary ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // Parameter is not supported
+    // the following name needs to be individually created;
+    rtl::OUString sLabel( rtl::OUString::createFromAscii("Custom") );
+    rtl::OUString sCommandUrl = rtl::OUString::createFromAscii( CUSTOM_MENU_STR ) + sLabel;
+    sal_Int32 nType = office::MsoControlType::msoControlButton;
+    sal_Int32 nPosition = 0;
+    sal_Bool bTemporary = sal_True;
+    
+    if( Type.hasValue() )
+    {
+        Type >>= nType;
+    }
+
+    if( nType != office::MsoControlType::msoControlButton &&
+        nType != office::MsoControlType::msoControlPopup )
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+
+    if( Id.hasValue() || Parameter.hasValue( ) )
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+
+    if( Before.hasValue() )
+        Before >>= nPosition;
+    else
+        nPosition = m_xIndexAccess->getCount();
+
+    if( Temporary.hasValue() )
+        Temporary >>= bTemporary;
+    
+    uno::Any aSubMenu;
+    if( nType == office::MsoControlType::msoControlPopup )
+    {
+        // it is a Popmenu
+        uno::Reference< lang::XSingleComponentFactory > xSCF( m_xBarSettings, uno::UNO_QUERY_THROW );
+        aSubMenu <<= xSCF->createInstanceWithContext( mxContext );
+    }
+
+    // create control 
+    uno::Sequence< beans::PropertyValue > aProps;
+    rtl::OUString sHelpUrl;
+    sal_uInt16 nItemType = 0;
+    if( IsMenu() )
+    {
+        aProps = CreateMenuItemData( sCommandUrl, sHelpUrl, sLabel, nItemType, aSubMenu );
+    }
+    else
+    {
+        sal_Bool isVisible = sal_True;
+        sal_Int32 nStyle = 0;
+        aProps = CreateToolbarItemData( sCommandUrl, sHelpUrl, sLabel, nItemType, aSubMenu, isVisible, nStyle );
+    }
+
+
+    uno::Reference< container::XIndexContainer > xIndexContainer( m_xIndexAccess, uno::UNO_QUERY_THROW );
+    xIndexContainer->insertByIndex( nPosition, uno::makeAny( aProps ) );
+
+    pCBarHelper->ApplyChange( m_sResourceUrl, m_xBarSettings );
+
+    // sometimes it would crash if passing m_xMenu instead of uno::Reference< awt::XMenu >() in Linux. 
+    ScVbaCommandBarControl* pNewCommandBarControl = NULL;
+    if( nType == office::MsoControlType::msoControlPopup )
+        pNewCommandBarControl = new ScVbaCommandBarPopup( this, mxContext, m_xIndexAccess, pCBarHelper, m_xBarSettings, m_sResourceUrl, nPosition, bTemporary, uno::Reference< awt::XMenu >() );
+    else
+        pNewCommandBarControl = new ScVbaCommandBarButton( this, mxContext, m_xIndexAccess, pCBarHelper, m_xBarSettings, m_sResourceUrl, nPosition, bTemporary, uno::Reference< awt::XMenu >() );
+
+    return uno::Reference< XCommandBarControl >( pNewCommandBarControl );
+}
+   
+// XHelperInterface
+rtl::OUString& 
+ScVbaCommandBarControls::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarControls") );
+    return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBarControls::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarControls" ) );
+    }
+    return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbapagesetupbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbapagesetupbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbapagesetupbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,325 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbapagesetupbase.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::ooo::vba;
+
+VbaPageSetupBase::VbaPageSetupBase(const uno::Reference< XHelperInterface >& xParent, 
+				const uno::Reference< uno::XComponentContext >& xContext ) throw (uno::RuntimeException): VbaPageSetupBase_BASE( xParent, xContext )
+{
+}		
+
+double SAL_CALL VbaPageSetupBase::getTopMargin() throw (css::uno::RuntimeException)
+{
+    sal_Bool headerOn = sal_False;
+    sal_Int32 topMargin = 0;
+    sal_Int32 headerHeight = 0;
+
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")));
+        aValue >>= headerOn;
+
+        aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")));
+        aValue >>= topMargin;
+
+        if( headerOn )
+        {
+            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight")));
+            aValue >>= headerHeight;
+            topMargin = topMargin + headerHeight;
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( topMargin );
+}
+
+void SAL_CALL VbaPageSetupBase::setTopMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 topMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    sal_Bool headerOn = sal_False;
+    sal_Int32 headerHeight = 0;
+
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderIsOn")));
+        aValue >>= headerOn;
+        
+        if( headerOn )
+        {
+            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HeaderHeight")));
+            aValue >>= headerHeight;
+            topMargin -= headerHeight;
+        }
+
+        aValue <<= topMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+double SAL_CALL VbaPageSetupBase::getBottomMargin() throw (css::uno::RuntimeException)
+{
+    sal_Bool footerOn = sal_False;
+    sal_Int32 bottomMargin = 0;
+    sal_Int32 footerHeight = 0;
+
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")));
+        aValue >>= footerOn;
+
+        aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")));
+        aValue >>= bottomMargin;
+
+        if( footerOn )
+        {
+            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight")));
+            aValue >>= footerHeight;
+            bottomMargin += footerHeight;
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( bottomMargin );
+}
+
+void SAL_CALL VbaPageSetupBase::setBottomMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 bottomMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    sal_Bool footerOn = sal_False;
+    sal_Int32 footerHeight = 0;
+
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterIsOn")));
+        aValue >>= footerOn;
+        
+        if( footerOn )
+        {
+            aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FooterHeight")));
+            aValue >>= footerHeight;
+            bottomMargin -= footerHeight;
+        }
+
+        aValue <<= bottomMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+double SAL_CALL VbaPageSetupBase::getRightMargin() throw (css::uno::RuntimeException)
+{
+    sal_Int32 rightMargin = 0;
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin")));
+        aValue >>= rightMargin;
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( rightMargin );;
+}
+
+void SAL_CALL VbaPageSetupBase::setRightMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 rightMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    try
+    {
+        uno::Any aValue;
+        aValue <<= rightMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("RightMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+
+}
+
+double SAL_CALL VbaPageSetupBase::getLeftMargin() throw (css::uno::RuntimeException)
+{
+    sal_Int32 leftMargin = 0;
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin")));
+        aValue >>= leftMargin;
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( leftMargin );;
+}
+
+void SAL_CALL VbaPageSetupBase::setLeftMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 leftMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    try
+    {
+        uno::Any aValue;
+        aValue <<= leftMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LeftMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+double SAL_CALL VbaPageSetupBase::getHeaderMargin() throw (css::uno::RuntimeException)
+{
+    sal_Int32 headerMargin = 0;
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")));
+        aValue >>= headerMargin;
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( headerMargin );;
+}
+
+void SAL_CALL VbaPageSetupBase::setHeaderMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 headerMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    try
+    {
+        uno::Any aValue;
+        aValue <<= headerMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("TopMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+double SAL_CALL VbaPageSetupBase::getFooterMargin() throw (css::uno::RuntimeException)
+{
+    sal_Int32 footerMargin = 0;
+    try
+    {
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")));
+        aValue >>= footerMargin;
+    }
+    catch( uno::Exception& )
+    {
+    }
+    
+    return Millimeter::getInPoints( footerMargin );;
+}
+
+void SAL_CALL VbaPageSetupBase::setFooterMargin( double margin ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 footerMargin = Millimeter::getInHundredthsOfOneMillimeter( margin );
+    try
+    {
+        uno::Any aValue;
+        aValue <<= footerMargin;
+        mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("BottomMargin")), aValue );
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
+sal_Int32 SAL_CALL VbaPageSetupBase::getOrientation() throw (css::uno::RuntimeException)
+{
+    sal_Int32 orientation = mnOrientPortrait;
+    try
+    {
+        sal_Bool isLandscape = sal_False;
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")));
+        aValue >>= isLandscape;
+
+        if( isLandscape )
+        {
+            orientation = mnOrientLandscape;
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+    return orientation;
+}
+
+void SAL_CALL VbaPageSetupBase::setOrientation( sal_Int32 orientation ) throw (css::uno::RuntimeException)
+{
+    if( ( orientation != mnOrientPortrait ) &&
+        ( orientation != mnOrientLandscape ) )
+    {
+        DebugHelper::exception(SbERR_BAD_PARAMETER, rtl::OUString() );
+    }
+
+    try
+    {
+        sal_Bool isLandscape = sal_False;
+        uno::Any aValue = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")));
+        aValue >>= isLandscape;
+
+        sal_Bool switchOrientation = sal_False;
+        if(( isLandscape && orientation != mnOrientLandscape ) || 
+            ( !isLandscape && orientation != mnOrientPortrait ))
+        {
+            switchOrientation = sal_True;
+        }
+
+        if( switchOrientation )
+        {
+            aValue <<= !isLandscape;
+            uno::Any aHeight = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height")));
+            uno::Any aWidth = mxPageProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width")));
+            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("IsLandscape")), aValue );
+            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width")),  aHeight );
+            mxPageProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height")), aWidth );
+        }
+
+        if( isLandscape )
+        {
+            orientation = mnOrientLandscape;
+        }
+    }
+    catch( uno::Exception& )
+    {
+    }
+}
+
Index: vbahelper/source/vbahelper/makefile.mk
===================================================================
--- vbahelper/source/vbahelper/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,80 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.45 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/../
+PRJNAME=vbahelper
+TARGET=vbahelperbits
+
+ENABLE_EXCEPTIONS := TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+SLOFILES=\
+    $(SLO)$/vbahelper.obj \
+    $(SLO)$/vbapropvalue.obj \
+    $(SLO)$/vbacommandbars.obj \
+    $(SLO)$/vbacommandbar.obj \
+    $(SLO)$/vbacommandbarcontrols.obj \
+    $(SLO)$/vbacommandbarcontrol.obj \
+    $(SLO)$/vbacommandbarhelper.obj \
+    $(SLO)$/vbaapplicationbase.obj \
+    $(SLO)$/vbawindowbase.obj \
+    $(SLO)$/vbadocumentbase.obj \
+    $(SLO)$/vbadocumentsbase.obj \
+    $(SLO)$/vbaglobalbase.obj \
+    $(SLO)$/vbafontbase.obj \
+    $(SLO)$/vbadialogbase.obj \
+    $(SLO)$/vbadialogsbase.obj \
+    $(SLO)$/vbashape.obj \
+    $(SLO)$/vbacolorformat.obj \
+    $(SLO)$/vbashapes.obj \
+    $(SLO)$/vbalineformat.obj \
+    $(SLO)$/vbafillformat.obj \
+    $(SLO)$/vbapictureformat.obj \
+    $(SLO)$/vbashaperange.obj \
+    $(SLO)$/vbatextframe.obj \
+    $(SLO)$/vbapagesetupbase.obj \
+
+# --- Targets -------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
Index: vbahelper/source/vbahelper/vbapictureformat.hxx
===================================================================
--- vbahelper/source/vbahelper/vbapictureformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbapictureformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbapictureformat.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PICTUREFORMAT_HXX
+#define SC_VBA_PICTUREFORMAT_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/msforms/XPictureFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XPictureFormat > ScVbaPictureFormat_BASE;
+
+class ScVbaPictureFormat : public ScVbaPictureFormat_BASE
+{
+private:
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+protected:
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+private:
+    void checkParameterRangeInDouble( double nRange, double nMin, double nMax ) throw (css::uno::RuntimeException);
+public:
+    ScVbaPictureFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, css::uno::Reference< css::drawing::XShape > xShape ) throw( css::lang::IllegalArgumentException );
+
+    // Attributes
+    virtual double SAL_CALL getBrightness() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBrightness( double _brightness ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getContrast() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setContrast( double _contrast ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL IncrementBrightness( double increment ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementContrast( double increment ) throw (css::uno::RuntimeException);
+};
+
+#endif//SC_VBA_PICTUREFORMAT_HXX
Index: vbahelper/source/vbahelper/vbadialogbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbadialogbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbadialogbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialog.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbadialogbase.hxx>
+#include <vbahelper/vbahelper.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+// fails silently
+void
+VbaDialogBase::Show() throw(uno::RuntimeException)
+{
+	rtl::OUString aURL;
+	if ( m_xModel.is() )
+	{
+		aURL = mapIndexToName( mnIndex );
+		if( aURL.getLength() == 0  )
+			throw uno::RuntimeException(
+				::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Unable to open the specified dialog " ) ),
+				uno::Reference< XInterface > () );
+		dispatchRequests( m_xModel, aURL );
+	}
+}	
+
Index: vbahelper/source/vbahelper/vbacommandbars.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbars.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbars.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMANDBARS_HXX
+#define SC_VBA_COMMANDBARS_HXX
+
+#include <ooo/vba/XCommandBar.hpp>
+#include <ooo/vba/XCommandBars.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "vbacommandbarhelper.hxx"
+
+typedef CollTestImplHelper< ov::XCommandBars > CommandBars_BASE;
+
+class ScVbaCommandBars : public CommandBars_BASE
+{
+private:
+    VbaCommandBarHelperRef pCBarHelper;
+
+public:
+    ScVbaCommandBars( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException);
+    virtual ~ScVbaCommandBars();
+
+    // XCommandBars
+    virtual css::uno::Reference< ov::XCommandBar > SAL_CALL Add( const css::uno::Any& Name, const css::uno::Any& Position, const css::uno::Any& MenuBar, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    virtual sal_Int32 SAL_CALL getCount() throw(css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& aIndex, const css::uno::Any& /*aIndex2*/ ) throw( css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_COMMANDBARS_HXX
Index: vbahelper/source/vbahelper/vbacommandbarcontrols.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarcontrols.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarcontrols.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMANDBARCONTROLS_HXX
+#define SC_VBA_COMMANDBARCONTROLS_HXX
+
+#include <ooo/vba/XCommandBarControls.hpp>
+#include <com/sun/star/awt/XMenu.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include "vbacommandbarhelper.hxx"
+
+typedef CollTestImplHelper< ov::XCommandBarControls > CommandBarControls_BASE;
+
+class ScVbaCommandBarControls : public CommandBarControls_BASE
+{
+private:
+    VbaCommandBarHelperRef pCBarHelper;
+    css::uno::Reference< css::container::XIndexAccess >          m_xBarSettings;
+    rtl::OUString       m_sResourceUrl;
+    css::uno::Reference< css::awt::XMenu >                        m_xMenu;
+    sal_Bool m_bIsMenu;
+
+    css::uno::Sequence< css::beans::PropertyValue > CreateMenuItemData( const rtl::OUString& sCommandURL, const rtl::OUString& sHelpURL, const rtl::OUString& sLabel, sal_uInt16 nType, const css::uno::Any& aSubMenu );
+    css::uno::Sequence< css::beans::PropertyValue > CreateToolbarItemData( const rtl::OUString& sCommandURL, const rtl::OUString& sHelpURL, const rtl::OUString& sLabel, sal_uInt16 nType, const css::uno::Any& aSubMenu, sal_Bool isVisible, sal_Int32 nStyle );
+
+public:
+    ScVbaCommandBarControls( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, const css::uno::Reference< css::awt::XMenu >& xMenu ) throw( css::uno::RuntimeException );
+    sal_Bool IsMenu(){ return m_bIsMenu; }
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+
+    // Methods     
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index, const css::uno::Any& /*Index2*/ ) throw (css::uno::RuntimeException); 
+    virtual css::uno::Reference< ov::XCommandBarControl > SAL_CALL Add( const css::uno::Any& Type, const css::uno::Any& Id, const css::uno::Any& Parameter, const css::uno::Any& Before, const css::uno::Any& Temporary ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    // XHelperInterface
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_COMMANDBARCONTROLS_HXX
Index: vbahelper/source/vbahelper/vbacolorformat.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacolorformat.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacolorformat.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacolorformat.hxx,v $
+ * $Revision: 1.3.146.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_XCOLORFORMAT_HXX
+#define SC_VBA_XCOLORFORMAT_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <ooo/vba/msforms/XColorFormat.hpp>
+#include <ooo/vba/msforms/XFillFormat.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbafillformat.hxx"
+
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XColorFormat > ScVbaColorFormat_BASE;
+
+class ColorFormatType
+{
+public:
+    const static sal_Int16 LINEFORMAT_FORECOLOR = 1;
+    const static sal_Int16 LINEFORMAT_BACKCOLOR = 2;
+    const static sal_Int16 FILLFORMAT_FORECOLOR = 3;
+    const static sal_Int16 FILLFORMAT_BACKCOLOR = 4;
+    const static sal_Int16 THREEDFORMAT_EXTRUSIONCOLOR = 5;
+};
+
+struct MsoColorIndizes
+{
+    const static sal_Int32 HAPICOLOR_BLACK = 0;
+    const static sal_Int32 HAPICOLOR_WITHE = 16777215;
+    const static sal_Int32 HAPICOLOR_RED = 16711680;
+    const static sal_Int32 HAPICOLOR_BRIGHTGREEN = 65280;
+    const static sal_Int32 HAPICOLOR_BLUE = 255;
+    const static sal_Int32 HAPICOLOR_YELLOW = 16776960;
+    const static sal_Int32 HAPICOLOR_PINK = 16711935;
+    const static sal_Int32 HAPICOLOR_TURQUOISE = 65535;
+    const static sal_Int32 HAPICOLOR_DARKRED = 8388608;
+    const static sal_Int32 HAPICOLOR_GREEN = 32768;
+    const static sal_Int32 HAPICOLOR_DARKBLUE = 128;
+    const static sal_Int32 HAPICOLOR_DARKYELLOW = 8421376;
+    const static sal_Int32 HAPICOLOR_VIOLET = 8388736;
+    const static sal_Int32 HAPICOLOR_TEAL = 32896;
+    const static sal_Int32 HAPICOLOR_GRAY_25_PERCENT = 12632256;
+    const static sal_Int32 HAPICOLOR_GRAY_50_PERCENT = 8421504;
+    const static sal_Int32 HAPICOLOR_PERIWINCKLE = 10066431;
+    const static sal_Int32 HAPICOLOR_PLUM = 10040166;
+    const static sal_Int32 HAPICOLOR_IVORY = 16777164;
+    const static sal_Int32 HAPICOLOR_LIGHTTURQUOISE = 13434879;
+    const static sal_Int32 HAPICOLOR_DARKPRUPLE = 6684774;
+    const static sal_Int32 HAPICOLOR_CORAL = 16744576;
+    const static sal_Int32 HAPICOLOR_OCEANBLUE = 26316;
+    const static sal_Int32 HAPICOLOR_ICEBLUE = 13421823;
+    const static sal_Int32 HAPICOLOR_SKYBLUE = 52479;
+    const static sal_Int32 HAPICOLOR_LIGHTGREEN = 13434828;
+    const static sal_Int32 HAPICOLOR_LIGHTYELLOW = 16777113;
+    const static sal_Int32 HAPICOLOR_PALEBLUE = 10079487;
+    const static sal_Int32 HAPICOLOR_ROSE = 16751052;
+    const static sal_Int32 HAPICOLOR_LAVENDER = 13408767;
+    const static sal_Int32 HAPICOLOR_TAN = 16764057;
+    const static sal_Int32 HAPICOLOR_LIGHTBLUE = 3368703;
+    const static sal_Int32 HAPICOLOR_AQUA = 3394764;
+    const static sal_Int32 HAPICOLOR_LIME = 10079232;
+    const static sal_Int32 HAPICOLOR_GOLD = 16763904;
+    const static sal_Int32 HAPICOLOR_LIGHTORANGE = 16750848;
+    const static sal_Int32 HAPICOLOR_ORANGE = 16737792;
+    const static sal_Int32 HAPICOLOR_BLUEGRAY = 6710937;
+    const static sal_Int32 HAPICOLOR_GRAY_40_PERCENT = 9868950;
+    const static sal_Int32 HAPICOLOR_DARKTEAL = 13158;
+    const static sal_Int32 HAPICOLOR_SEAGREEN = 3381606;
+    const static sal_Int32 HAPICOLOR_NONAME = 13056;
+    const static sal_Int32 HAPICOLOR_OLIVEGREEN = 3355392;
+    const static sal_Int32 HAPICOLOR_BROWN = 10040064;
+    const static sal_Int32 HAPICOLOR_INDIGO = 3355545;
+    const static sal_Int32 HAPICOLOR_GRAY_80_PERCENT = 3355443;
+
+    static sal_Int32 getColorIndex( sal_Int32 nIndex );
+    
+};
+
+class ScVbaColorFormat : public ScVbaColorFormat_BASE
+{
+private:
+    css::uno::Reference< ov::XHelperInterface > m_xInternalParent;
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+    ScVbaFillFormat *m_pFillFormat;
+    sal_Int16 m_nColorFormatType;
+    sal_Int32 m_nFillFormatBackColor;
+protected:
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    void setColorFormat( sal_Int16 nType );
+public:
+    ScVbaColorFormat( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< ov::XHelperInterface > xInternalParent, const css::uno::Reference< css::drawing::XShape > xShape, const sal_Int16 nColorFormatType );
+
+    // Attributes
+    virtual sal_Int32 SAL_CALL getRGB() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRGB( sal_Int32 _rgb ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getSchemeColor() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSchemeColor( sal_Int32 _schemecolor ) throw (css::uno::RuntimeException);
+
+};
+
+#endif//SC_VBA_XCOLORFORMAT_HXX
Index: vbahelper/source/vbahelper/vbaapplicationbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbaapplicationbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbaapplicationbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,218 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbahelper/vbaapplicationbase.hxx"
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+#include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+
+#include "vbacommandbars.hxx"
+#include <svx/msvbahelper.hxx>
+
+// start basic includes
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbuno.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+// end basic includes
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+#define OFFICEVERSION "11.0"
+
+VbaApplicationBase::VbaApplicationBase( const uno::Reference< uno::XComponentContext >& xContext )
+                    : ApplicationBase_BASE( uno::Reference< XHelperInterface >(), xContext )
+{
+}
+
+VbaApplicationBase::~VbaApplicationBase()
+{
+}
+
+sal_Bool SAL_CALL
+VbaApplicationBase::getScreenUpdating() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	return !xModel->hasControllersLocked();
+}
+
+void SAL_CALL
+VbaApplicationBase::setScreenUpdating(sal_Bool bUpdate) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	if (bUpdate)
+		xModel->unlockControllers();
+	else
+		xModel->lockControllers();
+}
+
+sal_Bool SAL_CALL
+VbaApplicationBase::getDisplayStatusBar() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+    if( xProps.is() ){
+        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
+        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
+        if( xLayoutManager.is() && xLayoutManager->isElementVisible( url ) ){
+            return sal_True;
+        }
+    }
+    return sal_False;
+}
+
+void SAL_CALL
+VbaApplicationBase::setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+    if( xProps.is() ){
+        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
+        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
+        if( xLayoutManager.is() ){
+            if( bDisplayStatusBar && !xLayoutManager->isElementVisible( url ) ){
+                if( !xLayoutManager->showElement( url ) )
+                    xLayoutManager->createElement( url );
+                return;
+            }
+            else if( !bDisplayStatusBar && xLayoutManager->isElementVisible( url ) ){
+                xLayoutManager->hideElement( url ); 
+                return;
+            }
+        }
+    }
+    return;
+}
+
+uno::Any SAL_CALL
+VbaApplicationBase::CommandBars( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< XCommandBars > xCommandBars( new ScVbaCommandBars( this, mxContext, uno::Reference< container::XIndexAccess >(), getCurrentDocument() ) );
+    if( aIndex.hasValue() )
+        return uno::makeAny( xCommandBars->Item( aIndex, uno::Any() ) );
+    return uno::makeAny( xCommandBars );
+}
+
+::rtl::OUString SAL_CALL
+VbaApplicationBase::getVersion() throw (uno::RuntimeException)
+{
+	return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(OFFICEVERSION));
+}
+
+void SAL_CALL VbaApplicationBase::Run( const ::rtl::OUString& MacroName, const uno::Any& varg1, const uno::Any& varg2, const uno::Any& varg3, const uno::Any& varg4, const uno::Any& varg5, const uno::Any& varg6, const uno::Any& varg7, const uno::Any& varg8, const uno::Any& varg9, const uno::Any& varg10, const uno::Any& varg11, const uno::Any& varg12, const uno::Any& varg13, const uno::Any& varg14, const uno::Any& varg15, const uno::Any& varg16, const uno::Any& varg17, const uno::Any& varg18, const uno::Any& varg19, const uno::Any& varg20, const uno::Any& varg21, const uno::Any& varg22, const uno::Any& varg23, const uno::Any& varg24, const uno::Any& varg25, const uno::Any& varg26, const uno::Any& varg27, const uno::Any& varg28, const uno::Any& varg29, const uno::Any& varg30 ) throw (uno::RuntimeException)
+{
+    VBAMacroResolvedInfo aMacroInfo = resolveVBAMacro( getSfxObjShell( getCurrentDocument() ), MacroName );
+    if( aMacroInfo.IsResolved() )
+    {
+        // handle the arguments
+        const uno::Any* aArgsPtrArray[] = { &varg1, &varg2, &varg3, &varg4, &varg5, &varg6, &varg7, &varg8, &varg9, &varg10, &varg11, &varg12, &varg13, &varg14, &varg15, &varg16, &varg17, &varg18, &varg19, &varg20, &varg21, &varg22, &varg23, &varg24, &varg25, &varg26, &varg27, &varg28, &varg29, &varg30 };
+
+        int nArg = sizeof( aArgsPtrArray ) / sizeof( aArgsPtrArray[0] );
+        uno::Sequence< uno::Any > aArgs( nArg );
+
+        const uno::Any** pArg = aArgsPtrArray;
+        const uno::Any** pArgEnd = ( aArgsPtrArray + nArg );
+
+        sal_Int32 nLastArgWithValue = 0;
+        sal_Int32 nArgProcessed = 0;
+
+        for ( ; pArg != pArgEnd; ++pArg, ++nArgProcessed )
+        {
+            aArgs[ nArgProcessed ] =  **pArg;
+            if( (*pArg)->hasValue() )
+                nLastArgWithValue = nArgProcessed;
+        }
+
+        // resize array to position of last param with value
+        aArgs.realloc( nArgProcessed + 1 );
+
+        uno::Any aRet;
+        uno::Any aDummyCaller;
+        executeMacro( aMacroInfo.MacroDocContext(), aMacroInfo.ResolvedMacro(), aArgs, aRet, aDummyCaller );
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("The macro doesn't exist") ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+float SAL_CALL VbaApplicationBase::CentimetersToPoints( float _Centimeters ) throw (uno::RuntimeException)
+{
+    // i cm = 28.35 points
+    static const float rate = 28.35f;
+    return ( _Centimeters * rate );
+}
+
+rtl::OUString& 
+VbaApplicationBase::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaApplicationBase") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+VbaApplicationBase::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.VbaApplicationBase" ) );
+	}
+	return aServiceNames;
+}
+
+void VbaApplicationBase::Quit() throw (uno::RuntimeException)
+{
+    // need to stop basic
+    SbMethod* pMeth = StarBASIC::GetActiveMethod();
+    if ( pMeth )
+    {
+        SbModule* pMod = dynamic_cast< SbModule* >( pMeth->GetParent() );
+        if ( pMod )
+        { 
+            StarBASIC* pBasic = dynamic_cast< StarBASIC* >( pMod->GetParent() );
+            if ( pBasic )
+                pBasic->QuitAndExitApplication();
+        }
+    }
+}
Index: vbahelper/source/vbahelper/vbatextframe.cxx
===================================================================
--- vbahelper/source/vbahelper/vbatextframe.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbatextframe.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbatextframe.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/helperdecl.hxx>
+#include <com/sun/star/drawing/TextFitToSizeType.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include <vbahelper/vbatextframe.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+VbaTextFrame::VbaTextFrame( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, uno::Reference< drawing::XShape > xShape ) : VbaTextFrame_BASE( xParent, xContext ), m_xShape( xShape )
+{
+    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
+}
+
+void
+VbaTextFrame::setAsMSObehavior()
+{
+    //set property TextWordWrap default as False.
+    // TextFitToSize control the text content. it seems we should set the default as False.
+    // com.sun.star.drawing.TextFitToSizeType.NONE
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextWordWrap" ), uno::makeAny( sal_False ) );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextFitToSize" ), uno::makeAny( drawing::TextFitToSizeType_NONE ) );
+}
+
+sal_Int32 VbaTextFrame::getMargin( rtl::OUString sMarginType )
+{
+    sal_Int32 nMargin = 0;
+    uno::Any aMargin = m_xPropertySet->getPropertyValue( sMarginType );
+    aMargin >>= nMargin;
+    return nMargin;
+}
+
+void VbaTextFrame::setMargin( rtl::OUString sMarginType, float fMargin )
+{
+    sal_Int32 nMargin = Millimeter::getInHundredthsOfOneMillimeter( fMargin );
+    m_xPropertySet->setPropertyValue( sMarginType, uno::makeAny( nMargin ) );
+}
+
+// Attributes
+sal_Bool SAL_CALL 
+VbaTextFrame::getAutoSize() throw (uno::RuntimeException)
+{
+    // I don't know why, but in OOo, TextAutoGrowHeight is the property control autosize. not TextFitToSize.
+    // TextFitToSize control the text content. 
+    // and in mso, there isnot option TextWordWrap which means auto wrap. the default is False.
+    sal_Bool bAutosize = sal_False;
+    uno::Any aTextAutoGrowHeight = m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "TextAutoGrowHeight" ) );
+    aTextAutoGrowHeight >>= bAutosize;
+    return bAutosize;
+}
+
+void SAL_CALL 
+VbaTextFrame::setAutoSize( sal_Bool _autosize ) throw (uno::RuntimeException)
+{
+    setAsMSObehavior();
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "TextAutoGrowHeight" ), uno::makeAny( _autosize ) );
+}
+
+float SAL_CALL 
+VbaTextFrame::getMarginBottom() throw (uno::RuntimeException)
+{
+    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextLowerDistance" ) );
+    float fMargin = (float)Millimeter::getInPoints( nMargin );
+    return fMargin;
+}
+
+void SAL_CALL 
+VbaTextFrame::setMarginBottom( float _marginbottom ) throw (uno::RuntimeException)
+{
+    setMargin( rtl::OUString::createFromAscii( "TextLowerDistance" ), _marginbottom );
+}
+
+float SAL_CALL 
+VbaTextFrame::getMarginTop() throw (uno::RuntimeException)
+{
+    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextUpperDistance" ) );
+    float fMargin = (float)Millimeter::getInPoints( nMargin );
+    return fMargin;
+}
+
+void SAL_CALL 
+VbaTextFrame::setMarginTop( float _margintop ) throw (uno::RuntimeException)
+{
+    setMargin( rtl::OUString::createFromAscii( "TextUpperDistance" ), _margintop );
+}
+
+float SAL_CALL 
+VbaTextFrame::getMarginLeft() throw (uno::RuntimeException)
+{
+    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextLeftDistance" ) );
+    float fMargin = (float)Millimeter::getInPoints( nMargin );
+    return fMargin;
+}
+
+void SAL_CALL 
+VbaTextFrame::setMarginLeft( float _marginleft ) throw (uno::RuntimeException)
+{
+    setMargin( rtl::OUString::createFromAscii( "TextLeftDistance" ), _marginleft );
+}
+
+float SAL_CALL 
+VbaTextFrame::getMarginRight() throw (uno::RuntimeException)
+{
+    sal_Int32 nMargin = getMargin( rtl::OUString::createFromAscii( "TextRightDistance" ) );
+    float fMargin = (float)Millimeter::getInPoints( nMargin );
+    return fMargin;
+}
+
+void SAL_CALL 
+VbaTextFrame::setMarginRight( float _marginright ) throw (uno::RuntimeException)
+{
+    setMargin( rtl::OUString::createFromAscii( "TextRightDistance" ), _marginright );
+}
+
+
+// Methods
+uno::Any SAL_CALL 
+VbaTextFrame::Characters() throw (uno::RuntimeException)
+{
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+rtl::OUString&
+VbaTextFrame::getServiceImplName()
+{
+    static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("VbaTextFrame") );
+    return sImplName;
+}
+
+uno::Sequence< rtl::OUString >
+VbaTextFrame::getServiceNames()
+{
+    static uno::Sequence< rtl::OUString > aServiceNames;
+    if ( aServiceNames.getLength() == 0 )
+    {
+        aServiceNames.realloc( 1 );
+        aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msforms.TextFrame" ) );
+    }
+    return aServiceNames;
+}
+
Index: vbahelper/source/vbahelper/vbashape.cxx
===================================================================
--- vbahelper/source/vbahelper/vbashape.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbashape.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,676 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashape.cxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include<ooo/vba/office/MsoZOrderCmd.hpp>
+#include<ooo/vba/office/MsoScaleFrom.hpp>
+#include<com/sun/star/container/XNamed.hpp>
+#include<com/sun/star/drawing/ConnectorType.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include<com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include<com/sun/star/drawing/XDrawPages.hpp>
+#include<com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/text/TextContentAnchorType.hpp>
+#include <ooo/vba/word/WdRelativeHorizontalPosition.hpp>
+#include <ooo/vba/word/WdRelativeVerticalPosition.hpp>
+
+#include <comphelper/processfactory.hxx>
+#include <vos/mutex.hxx>
+#include <vcl/svapp.hxx>
+#include <svx/unopage.hxx>
+#include <svx/unoshape.hxx>
+
+#include <vbahelper/vbashape.hxx>
+#include <vbahelper/vbatextframe.hxx>
+#include "vbalineformat.hxx"
+#include "vbafillformat.hxx"
+#include "vbapictureformat.hxx"
+#include <vbahelper/vbashaperange.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+using namespace ::vos;
+
+ScVbaShape::ScVbaShape( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< drawing::XShapes >& xShapes, const uno::Reference< frame::XModel >& xModel, sal_Int32 nType ) throw( lang::IllegalArgumentException ) : ScVbaShape_BASE( xParent, xContext ), m_xShape( xShape ), m_xShapes( xShapes ), m_nType( nType ), m_xModel( xModel )
+{
+    m_xPropertySet.set( m_xShape, uno::UNO_QUERY_THROW );
+    m_pShapeHelper.reset( new ShapeHelper( m_xShape ) );
+    addListeners();
+}
+
+ScVbaShape::ScVbaShape( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< drawing::XShape >& xShape, const uno::Reference< frame::XModel >& xModel ) throw( lang::IllegalArgumentException ) : ScVbaShape_BASE( uno::Reference< XHelperInterface >(), xContext ), m_xShape( xShape ), m_xModel( xModel )
+{
+    // add listener
+    addListeners();
+}
+
+ScVbaShape::~ScVbaShape()
+{ 
+    // dtor must never ever throw
+    /*try
+    {
+        removeShapeListener();
+        removeShapesListener();
+    }
+    catch( uno::Exception& )
+    {
+    }*/   
+}
+
+void SAL_CALL 
+ScVbaShape::disposing( const lang::EventObject& rEventObject ) throw( uno::RuntimeException )
+{
+    try
+    {
+    uno::Reference< drawing::XShapes > xShapes( rEventObject.Source, uno::UNO_QUERY );
+    uno::Reference< drawing::XShape > xShape( rEventObject.Source, uno::UNO_QUERY );
+    if ( xShapes.is() )
+        removeShapesListener();
+    if ( xShape.is() )
+        removeShapeListener();
+    }    
+    catch( uno::Exception& )
+    {
+    }
+}
+
+
+void ScVbaShape::addListeners()
+{
+    uno::Reference< lang::XComponent > xComponent( m_xShape, uno::UNO_QUERY );
+    if ( xComponent.is() )
+    	xComponent->addEventListener( this );
+
+    xComponent.set( m_xShapes, uno::UNO_QUERY );
+    if ( xComponent.is() )
+    	xComponent->addEventListener( this );
+}
+
+void
+ScVbaShape::removeShapeListener() throw( uno::RuntimeException )
+{
+    if( m_xShape.is() )
+    {
+        uno::Reference< lang::XComponent > xComponent( m_xShape, uno::UNO_QUERY_THROW );
+        xComponent->removeEventListener( this );
+    }
+    m_xShape = NULL;
+    m_xPropertySet = NULL;
+}
+
+void
+ScVbaShape::removeShapesListener() throw( uno::RuntimeException )
+{
+    if( m_xShapes.is() )
+    {
+        uno::Reference< lang::XComponent > xComponent( m_xShapes, uno::UNO_QUERY_THROW );
+        xComponent->removeEventListener( this );
+    }
+    m_xShapes = NULL;
+}
+
+sal_Int32 
+ScVbaShape::getType( const css::uno::Reference< drawing::XShape > xShape ) throw (uno::RuntimeException)
+{
+    rtl::OUString sShapeType;
+    uno::Reference< drawing::XShapeDescriptor > xShapeDescriptor( xShape, uno::UNO_QUERY_THROW );
+    sShapeType = xShapeDescriptor->getShapeType();
+    OSL_TRACE("ScVbaShape::getType: %s", rtl::OUStringToOString( sShapeType, RTL_TEXTENCODING_UTF8 ).getStr() );
+    // office::MsoShapeType::msoDiagram to "com.sun.star.drawing.GroupShape"
+    if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.GroupShape" ) ) )
+        return office::MsoShapeType::msoGroup;
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.GraphicObjectShape" ) ) )
+        return office::MsoShapeType::msoPicture;
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.ControlShape" ) ) || 
+            sShapeType.equals( rtl::OUString::createFromAscii( "FrameShape" ) ) )
+        return office::MsoShapeType::msoOLEControlObject;
+    // OOo don't support office::MsoShapeType::msoComment as a Shape.
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.OLE2Shape" ) ) )
+        return office::MsoShapeType::msoChart;
+    // Art characters office::MsoShapeType::msoTextEffect, in OOo corresponding to "com.sun.star.drawing.CustomShape"
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.ConnectorShape" ) ) )
+    {
+        enum drawing::ConnectorType connectorType;
+        uno::Reference< beans::XPropertySet > xPropertySet( xShape, uno::UNO_QUERY_THROW );
+        xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("EdgeKind")) >>= connectorType;
+        if( connectorType == drawing::ConnectorType_CURVE )
+            return office::MsoShapeType::msoFreeform;
+        else if( connectorType == drawing::ConnectorType_LINE )
+            return office::MsoShapeType::msoLine;
+        else 
+            return office::MsoShapeType::msoAutoShape;
+    }
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.LineShape" ) ) )
+        return office::MsoShapeType::msoLine;
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.CustomShape" ) ) ||
+            sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape") ) )
+        return office::MsoShapeType::msoAutoShape;
+    else if( sShapeType.equals( rtl::OUString::createFromAscii( "com.sun.star.drawing.TextShape" ) ) )
+        return office::MsoShapeType::msoTextBox;
+    else
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "the shape type do not be supported: " ) + sShapeType, uno::Reference< uno::XInterface >() );
+}
+
+// Attributes
+rtl::OUString SAL_CALL 
+ScVbaShape::getName() throw (uno::RuntimeException)
+{
+    rtl::OUString sName;
+    uno::Reference< container::XNamed > xNamed( m_xShape, uno::UNO_QUERY_THROW );
+    sName = xNamed->getName();
+    return sName;
+}
+
+void SAL_CALL 
+ScVbaShape::setName( const rtl::OUString& _name ) throw (uno::RuntimeException)
+{
+    uno::Reference< container::XNamed > xNamed( m_xShape, uno::UNO_QUERY_THROW );
+    xNamed->setName( _name );
+}
+
+double SAL_CALL 
+ScVbaShape::getHeight() throw (uno::RuntimeException)
+{
+    return m_pShapeHelper->getHeight();
+}
+
+void SAL_CALL 
+ScVbaShape::setHeight( double _height ) throw (uno::RuntimeException)
+{
+    m_pShapeHelper->setHeight( _height );
+}
+
+double SAL_CALL 
+ScVbaShape::getWidth() throw (uno::RuntimeException)
+{
+    return m_pShapeHelper->getWidth();
+}
+
+void SAL_CALL 
+ScVbaShape::setWidth( double _width ) throw (uno::RuntimeException)
+{
+    m_pShapeHelper->setWidth( _width );
+}
+
+double SAL_CALL 
+ScVbaShape::getLeft() throw (uno::RuntimeException)
+{
+    return m_pShapeHelper->getLeft();
+}
+
+void SAL_CALL 
+ScVbaShape::setLeft( double _left ) throw (uno::RuntimeException)
+{
+    m_pShapeHelper->setLeft( _left );
+}
+
+double SAL_CALL 
+ScVbaShape::getTop() throw (uno::RuntimeException)
+{
+    return m_pShapeHelper->getTop();
+}
+
+void SAL_CALL 
+ScVbaShape::setTop( double _top ) throw (uno::RuntimeException)
+{
+    return m_pShapeHelper->setTop( _top );
+}
+
+sal_Bool SAL_CALL 
+ScVbaShape::getVisible() throw (uno::RuntimeException)
+{
+    //UNO Shapes are always visible
+    return sal_True;
+}
+
+void SAL_CALL 
+ScVbaShape::setVisible( sal_Bool /*_visible*/ ) throw (uno::RuntimeException)
+{
+    //UNO Shapes are always visible
+}
+
+sal_Int32 SAL_CALL 
+ScVbaShape::getZOrderPosition() throw (uno::RuntimeException)
+{
+    sal_Int32 nZOrderPosition = 0;
+    uno::Any aZOrderPosition =  m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ) );
+    aZOrderPosition >>= nZOrderPosition;
+    return nZOrderPosition + 1;
+}
+
+sal_Int32 SAL_CALL 
+ScVbaShape::getType() throw (uno::RuntimeException)
+{
+    return m_nType;
+}
+
+double SAL_CALL 
+ScVbaShape::getRotation() throw (uno::RuntimeException)
+{
+    double dRotation = 0;
+    sal_Int32 nRotation = 0;
+    m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "RotateAngle" ) ) >>= nRotation;
+    dRotation = static_cast< double >( nRotation /100 );
+    return dRotation;
+}
+
+void SAL_CALL 
+ScVbaShape::setRotation( double _rotation ) throw (uno::RuntimeException)
+{
+    sal_Int32 nRotation = static_cast < sal_Int32 > ( _rotation * 100 );
+    m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "RotateAngle" ), uno::makeAny( nRotation ) );
+}
+
+uno::Reference< msforms::XLineFormat > SAL_CALL 
+ScVbaShape::getLine() throw (uno::RuntimeException)
+{
+    // TODO should ongly return line
+    return uno::Reference< msforms::XLineFormat >( new ScVbaLineFormat( this, mxContext, m_xShape ) );
+}
+
+uno::Reference< msforms::XFillFormat > SAL_CALL
+ScVbaShape::getFill() throw (uno::RuntimeException)
+{
+    return uno::Reference< msforms::XFillFormat >( new ScVbaFillFormat( this, mxContext, m_xShape ) );
+}
+
+uno::Reference<  msforms::XPictureFormat > SAL_CALL
+ScVbaShape::getPictureFormat() throw (uno::RuntimeException)
+{
+    return uno::Reference< msforms::XPictureFormat >( new ScVbaPictureFormat( this, mxContext, m_xShape ) );
+}
+
+// Methods
+uno::Any SAL_CALL 
+ScVbaShape::TextFrame() throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XServiceInfo > xServiceInfo( m_xModel, uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument" ) ) ) )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Sequence< uno::Any > aArgs(2);
+        aArgs[0] = uno::makeAny( getParent() );
+        aArgs[1] <<= m_xShape;
+        uno::Reference< uno::XInterface > xTextFrame( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.excel.TextFrame") ) , aArgs ) , uno::UNO_QUERY_THROW );
+        return uno::makeAny( xTextFrame );
+    }
+
+    return uno::makeAny( uno::Reference< msforms::XTextFrame >( new VbaTextFrame( this, mxContext, m_xShape ) ) );
+}
+
+void SAL_CALL 
+ScVbaShape::Delete() throw (uno::RuntimeException)
+{
+    OGuard aGuard( Application::GetSolarMutex() );
+    m_xShapes->remove( m_xShape );
+}
+
+void SAL_CALL 
+ScVbaShape::ZOrder( sal_Int32 ZOrderCmd ) throw (uno::RuntimeException)
+{
+    sal_Int32 nOrderPositon;
+    uno::Any aOrderPostion = m_xPropertySet->getPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ) );
+    aOrderPostion >>= nOrderPositon;
+    switch( ZOrderCmd )
+    {
+    case office::MsoZOrderCmd::msoBringToFront:
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( SAL_MAX_INT32 ) );
+        break;
+    case office::MsoZOrderCmd::msoSendToBack:
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( (sal_Int32)0 ) );
+        break;
+    case office::MsoZOrderCmd::msoBringForward:
+        nOrderPositon += 1;
+        m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( nOrderPositon ) );
+        break;
+    case office::MsoZOrderCmd::msoSendBackward:
+        if( nOrderPositon > 0 )
+        {
+            nOrderPositon -= 1;
+            m_xPropertySet->setPropertyValue( rtl::OUString::createFromAscii( "ZOrder" ), uno::makeAny( nOrderPositon ) );
+        }
+        break;
+    // below two commands use with Writer for text and image object.
+    case office::MsoZOrderCmd::msoBringInFrontOfText:
+    case office::MsoZOrderCmd::msoSendBehindText:
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "This ZOrderCmd is not implemented, it is use with writer." ), uno::Reference< uno::XInterface >() );
+    default:
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid Parameter." ), uno::Reference< uno::XInterface >() );
+    }
+}
+
+void SAL_CALL 
+ScVbaShape::IncrementRotation( double Increment ) throw (uno::RuntimeException)
+{
+    double nCurrentRotation = getRotation();
+    nCurrentRotation += Increment;
+    setRotation(nCurrentRotation);
+}
+
+void SAL_CALL 
+ScVbaShape::IncrementLeft( double Increment ) throw (uno::RuntimeException)
+{
+    double nCurrentLeft = getLeft();
+    nCurrentLeft += Increment;
+    setLeft(nCurrentLeft);
+}
+
+void SAL_CALL 
+ScVbaShape::IncrementTop( double Increment ) throw (uno::RuntimeException)
+{
+    double nCurrentTop = getTop();
+    nCurrentTop += Increment;
+    setTop(nCurrentTop);
+}
+
+void SAL_CALL 
+ScVbaShape::ScaleHeight( double Factor, sal_Bool /*RelativeToOriginalSize*/, sal_Int32 Scale ) throw (uno::RuntimeException)
+{
+    double nHeight = getHeight();
+    double nNewHeight = nHeight * Factor;
+    if( Scale == office::MsoScaleFrom::msoScaleFromTopLeft )
+    {
+        setHeight(nNewHeight);
+    }
+    else if( Scale == office::MsoScaleFrom::msoScaleFromBottomRight )
+    {
+        double nDeltaHeight = nNewHeight - nHeight;
+        double nNewTop = getTop() - nDeltaHeight;
+        setTop(nNewTop);
+        setHeight(nNewHeight);
+    }
+    else if( Scale == office::MsoScaleFrom::msoScaleFromMiddle )
+    {
+        double nDeltaHeight = (nNewHeight - nHeight) / 2;
+        double nNewTop = getTop() - nDeltaHeight;
+        setTop(nNewTop);
+        setHeight(nNewHeight);
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "ScaleHeight.Scale wrong value is given." ) , uno::Reference< uno::XInterface >() );
+    }
+}
+
+void SAL_CALL 
+ScVbaShape::ScaleWidth( double Factor, sal_Bool /*RelativeToOriginalSize*/, sal_Int32 Scale ) throw (uno::RuntimeException)
+{
+    double nWidth = getWidth();
+    double nNewWidth = nWidth * Factor;
+    if( Scale == office::MsoScaleFrom::msoScaleFromTopLeft )
+    {
+        setWidth(nNewWidth);
+    }
+    else if( Scale == office::MsoScaleFrom::msoScaleFromBottomRight )
+    {
+        double nDeltaWidth = nNewWidth - nWidth;
+        double nNewLeft = getLeft() - nDeltaWidth;
+        setLeft(nNewLeft);
+        setWidth(nNewWidth);
+    }
+    else if( Scale == office::MsoScaleFrom::msoScaleFromMiddle )
+    {
+        double nDeltaWidth = (nNewWidth - nWidth) / 2;
+        double nNewLeft = getLeft() - nDeltaWidth;
+        setLeft(nNewLeft);
+        setWidth(nNewWidth);
+    }
+    else
+    {
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "ScaleHeight.Scale wrong value is given." ) , uno::Reference< uno::XInterface >() );
+    }
+}
+
+void SAL_CALL
+ScVbaShape::Select( const uno::Any& /*Replace*/ ) throw ( uno::RuntimeException )
+{
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( m_xShape ) );
+}
+
+// This method should not be part of Shape, what we reall need to do is...
+// dynamically create the appropriate objects e.g. TextBox, Oval, Picture etc. 
+// ( e.g. the ones that really do have ShapeRange as an attribute )
+uno::Any SAL_CALL 
+ScVbaShape::ShapeRange( const uno::Any& index ) throw ( uno::RuntimeException )
+{
+	// perhaps we should store a reference to the Shapes Collection 
+	// in this class
+	// but anyway this method should not even be in this class
+	// #TODO not sure what the parent of the Shapes collection should be
+	
+	XNamedObjectCollectionHelper< drawing::XShape >::XNamedVec aVec;
+	aVec.push_back( m_xShape );
+	uno::Reference< container::XIndexAccess > xIndexAccess( new XNamedObjectCollectionHelper< drawing::XShape >( aVec ) );
+	uno::Reference< container::XChild > xChild( m_xShape, uno::UNO_QUERY_THROW );	
+	// #FIXME for want of a better parent, setting this
+	uno::Reference< msforms::XShapeRange > xShapeRange( new ScVbaShapeRange( mxParent, mxContext, xIndexAccess,  uno::Reference< drawing::XDrawPage >( xChild->getParent(), uno::UNO_QUERY_THROW ), m_xModel ) );
+	if ( index.hasValue() )
+		return xShapeRange->Item( index, uno::Any() );
+	return uno::makeAny( xShapeRange );
+}
+
+sal_Bool SAL_CALL 
+ScVbaShape::getLockAspectRatio() throw (uno::RuntimeException)
+{
+    // FIXME:
+    return sal_False;
+}
+
+void SAL_CALL 
+ScVbaShape::setLockAspectRatio( sal_Bool /*_lockaspectratio*/ ) throw (uno::RuntimeException)
+{
+    // FIXME:
+}
+
+sal_Bool SAL_CALL 
+ScVbaShape::getLockAnchor() throw (uno::RuntimeException)
+{
+    // FIXME:
+    return sal_True;
+}
+
+void SAL_CALL 
+ScVbaShape::setLockAnchor( sal_Bool /*_lockanchor*/ ) throw (uno::RuntimeException)
+{
+    // FIXME:
+}
+
+sal_Int32 SAL_CALL 
+ScVbaShape::getRelativeHorizontalPosition() throw (uno::RuntimeException)
+{
+    sal_Int32 nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
+    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    
+    switch( eType )
+    {
+        case text::TextContentAnchorType_AT_PARAGRAPH:
+        {
+            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn;
+            break;
+        }
+        case text::TextContentAnchorType_AT_PAGE:
+        {
+            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage;
+            break;
+        }
+        case text::TextContentAnchorType_AT_CHARACTER:
+        {
+            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter;
+            break;
+        }
+        case text::TextContentAnchorType_AT_FRAME:
+        case text::TextContentAnchorType_AS_CHARACTER:
+        {
+            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
+            break;
+        }
+        default:
+        {
+            nRelativeHorizontalPosition = word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin;
+        }
+    }
+    return nRelativeHorizontalPosition;
+}
+
+void SAL_CALL 
+ScVbaShape::setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (uno::RuntimeException)
+{
+    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    switch( _relativehorizontalposition )
+    {
+        case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionCharacter:
+        {
+            eType = text::TextContentAnchorType_AT_CHARACTER;
+            break;
+        }
+        case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionColumn:
+        case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionMargin:
+        {
+            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            break;
+        }
+        case word::WdRelativeHorizontalPosition::wdRelativeHorizontalPositionPage:
+        {
+            eType = text::TextContentAnchorType_AT_PAGE;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+        }
+    }
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaShape::getRelativeVerticalPosition() throw (uno::RuntimeException)
+{
+    sal_Int32 nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
+    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    m_xPropertySet->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ) ) >>= eType;
+    
+    switch( eType )
+    {
+        case text::TextContentAnchorType_AT_PARAGRAPH:
+        {
+            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph;
+            break;
+        }
+        case text::TextContentAnchorType_AT_PAGE:
+        {
+            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage;
+            break;
+        }
+        case text::TextContentAnchorType_AT_CHARACTER:
+        {
+            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine;
+            break;
+        }
+        case text::TextContentAnchorType_AT_FRAME:
+        case text::TextContentAnchorType_AS_CHARACTER:
+        {
+            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
+            break;
+        }
+        default:
+        {
+            nRelativeVerticalPosition = word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin;
+        }
+    }
+    return nRelativeVerticalPosition;
+}
+
+void SAL_CALL 
+ScVbaShape::setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (uno::RuntimeException)
+{
+    text::TextContentAnchorType eType = text::TextContentAnchorType_AT_PARAGRAPH;
+    switch( _relativeverticalposition )
+    {
+        case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionLine:
+        {
+            eType = text::TextContentAnchorType_AT_CHARACTER;
+            break;
+        }
+        case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionParagraph:
+        case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionMargin:
+        {
+            eType = text::TextContentAnchorType_AT_PARAGRAPH;
+            break;
+        }
+        case word::WdRelativeVerticalPosition::wdRelativeVerticalPositionPage:
+        {
+            eType = text::TextContentAnchorType_AT_PAGE;
+            break;
+        }
+        default:
+        {
+            DebugHelper::exception(SbERR_BAD_ARGUMENT, rtl::OUString());
+        }
+    }
+    m_xPropertySet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AnchorType") ), uno::makeAny( eType ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaShape::WrapFormat() throw (uno::RuntimeException)
+{
+    uno::Reference< lang::XServiceInfo > xServiceInfo( m_xModel, uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xSF( comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Sequence< uno::Any > aArgs(2);
+        aArgs[0] = uno::makeAny( getParent() );
+        aArgs[1] <<= m_xShape;
+        uno::Reference< uno::XInterface > xWrapFormat( xSF->createInstanceWithArguments( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.word.WrapFormat") ) , aArgs ) , uno::UNO_QUERY_THROW );
+        return uno::makeAny( xWrapFormat );
+    }
+    throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+}
+
+
+rtl::OUString& 
+ScVbaShape::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShape") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaShape::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.Shape" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbafontbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbafontbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbafontbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,309 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbafont.cxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XProperty.hpp>
+#include <com/sun/star/awt/FontWeight.hpp>
+#include <com/sun/star/awt/FontUnderline.hpp>
+#include <com/sun/star/awt/FontStrikeout.hpp>
+#include <com/sun/star/awt/FontSlant.hpp>
+#include <com/sun/star/text/XSimpleText.hpp>
+#include <vbahelper/vbafontbase.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+VbaFontBase::VbaFontBase( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< css::container::XIndexAccess >& xPalette, uno::Reference< beans::XPropertySet > xPropertySet  ) throw ( uno::RuntimeException ) : VbaFontBase_BASE( xParent, xContext ), mxFont( xPropertySet, css::uno::UNO_QUERY_THROW ), mxPalette( xPalette )
+{
+}
+
+VbaFontBase::~VbaFontBase()
+{
+}
+
+
+void SAL_CALL
+VbaFontBase::setSuperscript( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	sal_Int16 nValue = NORMAL;
+	sal_Int8 nValue2 = NORMALHEIGHT;
+
+        if( bValue )
+	{
+		nValue = SUPERSCRIPT;
+	        nValue2 = SUPERSCRIPTHEIGHT;
+	}
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ), ( uno::Any )nValue );
+ 	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapementHeight" ) ), ( uno::Any )nValue2 );
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getSuperscript() throw ( uno::RuntimeException )
+{
+	short nValue = 0;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ) ) >>= nValue;
+	return uno::makeAny( ( nValue == SUPERSCRIPT ) );
+}
+
+void SAL_CALL
+VbaFontBase::setSubscript( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	sal_Int16 nValue = NORMAL;
+	sal_Int8 nValue2 = NORMALHEIGHT;
+
+        if( bValue )
+	{
+		nValue= SUBSCRIPT;
+	        nValue2 = SUBSCRIPTHEIGHT;
+	}
+
+ 	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapementHeight" ) ), ( uno::Any )nValue2 );
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ), ( uno::Any )nValue );
+
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getSubscript() throw ( uno::RuntimeException )
+{
+	short nValue = NORMAL;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ) ) >>= nValue;
+	return uno::makeAny( ( nValue == SUBSCRIPT ) );
+}
+
+void SAL_CALL
+VbaFontBase::setSize( const uno::Any& aValue ) throw( uno::RuntimeException )
+{
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ), aValue );
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getSize() throw ( uno::RuntimeException )
+{
+        return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ) );
+}
+
+void SAL_CALL
+VbaFontBase::setColorIndex( const uno::Any& _colorindex ) throw( uno::RuntimeException )
+{
+	sal_Int32 nIndex = 0;
+	_colorindex >>= nIndex;
+
+	--nIndex; // OOo indices are zero bases
+
+	// setColor expects colors in XL RGB values
+	// #FIXME this is daft we convert OO RGB val to XL RGB val and
+	// then back again to OO RGB value
+	setColor( OORGBToXLRGB(mxPalette->getByIndex( nIndex )) );
+}
+
+
+uno::Any SAL_CALL
+VbaFontBase::getColorIndex() throw ( uno::RuntimeException )
+{
+	sal_Int32 nColor = 0;
+
+	XLRGBToOORGB( getColor() ) >>= nColor;
+	sal_Int32 nElems = mxPalette->getCount();
+	sal_Int32 nIndex = -1;
+	for ( sal_Int32 count=0; count<nElems; ++count )
+       	{
+		sal_Int32 nPaletteColor = 0;
+		mxPalette->getByIndex( count ) >>= nPaletteColor;
+		if ( nPaletteColor == nColor )
+		{
+			nIndex = count + 1; // 1 based
+			break;
+		}
+	}
+	return uno::makeAny( nIndex );
+}
+
+void SAL_CALL
+VbaFontBase::setBold( const uno::Any& aValue ) throw( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	double fBoldValue = awt::FontWeight::NORMAL;
+	if( bValue )
+		fBoldValue = awt::FontWeight::BOLD;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ), ( uno::Any )fBoldValue );
+
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getBold() throw ( uno::RuntimeException )
+{
+	double fValue = 0.0;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ) ) >>= fValue;
+	return uno::makeAny( fValue == awt::FontWeight::BOLD );
+}
+
+void SAL_CALL
+VbaFontBase::setStrikethrough( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	short nValue = awt::FontStrikeout::NONE;
+	if( bValue )
+		nValue = awt::FontStrikeout::SINGLE;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ), ( uno::Any )nValue );
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getStrikethrough() throw ( uno::RuntimeException )
+{
+	short nValue = 0;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ) ) >>= nValue;
+	return uno::Any( nValue == awt::FontStrikeout::SINGLE );
+}
+
+void  SAL_CALL
+VbaFontBase::setShadow( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ), aValue );
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getShadow() throw (uno::RuntimeException)
+{
+	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ) );
+}
+
+void  SAL_CALL
+VbaFontBase::setItalic( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	short nValue = awt::FontSlant_NONE;
+	if( bValue )
+		nValue = awt::FontSlant_ITALIC;
+    mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ), ( uno::Any )nValue );
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getItalic() throw ( uno::RuntimeException )
+{
+
+    awt::FontSlant aFS;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ) ) >>= aFS;
+	return uno::makeAny( aFS == awt::FontSlant_ITALIC );
+}
+
+void  SAL_CALL
+VbaFontBase::setName( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	rtl::OUString sString;
+	aValue >>= sString;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ), aValue);
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getName() throw ( uno::RuntimeException )
+{
+	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ) );
+}
+uno::Any
+VbaFontBase::getColor() throw (uno::RuntimeException)
+{
+	uno::Any aAny;
+	aAny = OORGBToXLRGB( mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ) ) );
+	return aAny;
+}
+
+void
+VbaFontBase::setColor( const uno::Any& _color  ) throw (uno::RuntimeException)
+{
+	mxFont->setPropertyValue(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ) , XLRGBToOORGB(_color));
+}
+
+void SAL_CALL
+VbaFontBase::setUnderline( const uno::Any& /*aValue*/ ) throw ( uno::RuntimeException )
+{
+/*
+	// default
+	sal_Int32 nValue = excel::XlUnderlineStyle::xlUnderlineStyleNone;
+	aValue >>= nValue;
+	switch ( nValue )
+	{
+// NOTE:: #TODO #FIMXE
+// xlUnderlineStyleDoubleAccounting & xlUnderlineStyleSingleAccounting
+// don't seem to be supported in Openoffice.
+// The import filter converts them to single or double underlines as appropriate
+// So, here at the moment we are similarly silently converting
+// xlUnderlineStyleSingleAccounting to xlUnderlineStyleSingle.
+
+		case excel::XlUnderlineStyle::xlUnderlineStyleNone:
+			nValue = awt::FontUnderline::NONE;
+			break;
+		case excel::XlUnderlineStyle::xlUnderlineStyleSingle:
+		case excel::XlUnderlineStyle::xlUnderlineStyleSingleAccounting:
+			nValue = awt::FontUnderline::SINGLE;
+			break;
+		case excel::XlUnderlineStyle::xlUnderlineStyleDouble:
+		case excel::XlUnderlineStyle::xlUnderlineStyleDoubleAccounting:
+			nValue = awt::FontUnderline::DOUBLE;
+			break;
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Unknown value for Underline")), uno::Reference< uno::XInterface >() );
+	}
+
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharUnderline" ) ), ( uno::Any )nValue );
+*/
+
+}
+
+uno::Any SAL_CALL
+VbaFontBase::getUnderline() throw ( uno::RuntimeException )
+{
+	sal_Int32 nValue = awt::FontUnderline::NONE;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharUnderline" ) ) ) >>= nValue;
+/*
+	switch ( nValue )
+	{
+		case  awt::FontUnderline::DOUBLE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleDouble;
+			break;
+		case  awt::FontUnderline::SINGLE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleSingle;
+			break;
+		case  awt::FontUnderline::NONE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleNone;
+			break;
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Unknown value retrieved for Underline") ), uno::Reference< uno::XInterface >() );
+
+	}
+*/
+	return uno::makeAny( nValue );
+}
+
+
Index: vbahelper/source/vbahelper/vbacommandbarhelper.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,282 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacommandbarhelper.hxx" 
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/XUIConfigurationStorage.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManager.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIElement.hpp>
+#ifndef _COM_SUN_STAR_UI_UIElementType_HPP_
+#include <com/sun/star/ui/UIElementType.hpp>
+#endif
+#include <comphelper/processfactory.hxx>
+#include <vbahelper/vbahelper.hxx>
+#include <time.h>
+#include <map>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+#define CREATEOUSTRING(asciistr) rtl::OUString::createFromAscii(asciistr)
+
+typedef std::map< rtl::OUString, rtl::OUString > MSO2OOCommandbarMap;
+
+class MSO2OOCommandbarHelper
+{
+private:
+    static MSO2OOCommandbarHelper* pMSO2OOCommandbarHelper;
+    MSO2OOCommandbarMap maBuildinToolbarMap;
+
+    MSO2OOCommandbarHelper()
+    {
+        // Buildin toolbars
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Standard"),CREATEOUSTRING("private:resource/toolbar/standardbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Formatting"),CREATEOUSTRING("private:resource/toolbar/formatobjectbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Drawing"),CREATEOUSTRING("private:resource/toolbar/drawbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Toolbar List"),CREATEOUSTRING("private:resource/toolbar/toolbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Forms"),CREATEOUSTRING("private:resource/toolbar/formcontrols") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Form Controls"),CREATEOUSTRING("private:resource/toolbar/formcontrols") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Full Screen"),CREATEOUSTRING("private:resource/toolbar/fullscreenbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Chart"),CREATEOUSTRING("private:resource/toolbar/flowchartshapes") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("Picture"),CREATEOUSTRING("private:resource/toolbar/graphicobjectbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("WordArt"),CREATEOUSTRING("private:resource/toolbar/fontworkobjectbar") ) );
+        maBuildinToolbarMap.insert( std::make_pair( CREATEOUSTRING("3-D Settings"),CREATEOUSTRING("private:resource/toolbar/extrusionobjectbar") ) );
+    }
+
+public:
+    virtual ~MSO2OOCommandbarHelper() {};
+    static MSO2OOCommandbarHelper* getMSO2OOCommandbarHelper()
+    {
+        if( pMSO2OOCommandbarHelper == NULL )
+        {
+            pMSO2OOCommandbarHelper = new MSO2OOCommandbarHelper();
+        }
+        return pMSO2OOCommandbarHelper;
+    }
+
+    rtl::OUString findBuildinToolbar( const rtl::OUString& sToolbarName )
+    {
+        MSO2OOCommandbarMap::iterator it = maBuildinToolbarMap.begin();
+        for(; it != maBuildinToolbarMap.end(); it++ )
+        {
+            rtl::OUString sName = it->first;
+            if( sName.equalsIgnoreAsciiCase( sToolbarName ) )
+                return it->second;
+        }
+        return rtl::OUString();
+    }
+};
+
+MSO2OOCommandbarHelper* MSO2OOCommandbarHelper::pMSO2OOCommandbarHelper = NULL;
+
+
+VbaCommandBarHelper::VbaCommandBarHelper( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel ) throw (css::uno::RuntimeException) : mxContext( xContext ), mxModel( xModel )
+{
+    Init();
+}
+
+void VbaCommandBarHelper::Init( ) throw (css::uno::RuntimeException)
+{
+    uno::Reference< css::ui::XUIConfigurationManagerSupplier > xUICfgSupplier( mxModel, uno::UNO_QUERY_THROW );
+    m_xDocCfgMgr = xUICfgSupplier->getUIConfigurationManager();
+
+    uno::Reference< lang::XServiceInfo > xServiceInfo( mxModel, uno::UNO_QUERY_THROW );
+    if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument") ) ) )
+    {
+        maModuleId = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.SpreadsheetDocument") );
+    }
+    else if( xServiceInfo->supportsService( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) )
+    {
+        maModuleId = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument") );
+    }
+
+    if( maModuleId.getLength() == 0 )
+    {
+        throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Not implemented") ), uno::Reference< uno::XInterface >() );
+    }
+
+	uno::Reference< lang::XMultiServiceFactory > xServiceManager( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+        
+	css::uno::Reference< css::ui::XModuleUIConfigurationManagerSupplier > xUICfgMgrSupp( xServiceManager->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ))), uno::UNO_QUERY_THROW );
+
+    m_xAppCfgMgr.set( xUICfgMgrSupp->getUIConfigurationManager( maModuleId ), uno::UNO_QUERY_THROW );
+
+	css::uno::Reference< css::container::XNameAccess > xNameAccess( xServiceManager->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.WindowStateConfiguration" ))), uno::UNO_QUERY_THROW );
+
+    m_xWindowState.set( xNameAccess->getByName( maModuleId ), uno::UNO_QUERY_THROW );
+}
+
+css::uno::Reference< css::container::XIndexAccess > VbaCommandBarHelper::getSettings( const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException)
+{
+    if( m_xDocCfgMgr->hasSettings( sResourceUrl ) )
+        return m_xDocCfgMgr->getSettings( sResourceUrl, sal_True );
+    else if( m_xAppCfgMgr->hasSettings( sResourceUrl ) )
+        return m_xAppCfgMgr->getSettings( sResourceUrl, sal_True );
+    else
+    {
+        css::uno::Reference< css::container::XIndexAccess > xSettings( m_xAppCfgMgr->createSettings( ), uno::UNO_QUERY_THROW );
+        return xSettings;
+    }
+}
+
+void VbaCommandBarHelper::removeSettings( const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException)
+{
+    if( m_xDocCfgMgr->hasSettings( sResourceUrl ) )
+        m_xDocCfgMgr->removeSettings( sResourceUrl );
+    else if( m_xAppCfgMgr->hasSettings( sResourceUrl ) )
+        m_xAppCfgMgr->removeSettings( sResourceUrl );
+    
+    // persistChanges();
+}
+
+void VbaCommandBarHelper::ApplyChange( const rtl::OUString& sResourceUrl, const css::uno::Reference< css::container::XIndexAccess >& xSettings, sal_Bool bTemporary ) throw (css::uno::RuntimeException)
+{
+    if( m_xDocCfgMgr->hasSettings( sResourceUrl ) )
+    {
+        m_xDocCfgMgr->replaceSettings( sResourceUrl, xSettings );
+    }
+    else
+    {
+        m_xDocCfgMgr->insertSettings( sResourceUrl, xSettings );
+    }
+    if( !bTemporary )
+    {
+        persistChanges();
+    }
+}
+
+sal_Bool VbaCommandBarHelper::persistChanges() throw (css::uno::RuntimeException)
+{
+    uno::Reference< css::ui::XUIConfigurationPersistence > xConfigPersistence( m_xDocCfgMgr, uno::UNO_QUERY_THROW );
+    sal_Bool result = sal_False;
+    if( xConfigPersistence->isModified() )
+    {
+        xConfigPersistence->store();
+        result = sal_True;
+    }
+    return result;
+}
+
+uno::Reference< frame::XLayoutManager > VbaCommandBarHelper::getLayoutManager() throw (uno::RuntimeException)
+{
+    uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW ); 
+    uno::Reference< beans::XPropertySet > xPropertySet( xFrame, uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XLayoutManager > xLayoutManager( xPropertySet->getPropertyValue( rtl::OUString::createFromAscii("LayoutManager") ), uno::UNO_QUERY_THROW );
+    return xLayoutManager;
+}
+
+sal_Bool VbaCommandBarHelper::hasToolbar( const rtl::OUString& sResourceUrl, const rtl::OUString& sName ) throw (css::uno::RuntimeException)
+{
+    if( m_xDocCfgMgr->hasSettings( sResourceUrl ) )
+    {
+        rtl::OUString sUIName;
+        uno::Reference< beans::XPropertySet > xPropertySet( m_xDocCfgMgr->getSettings( sResourceUrl, sal_False ), uno::UNO_QUERY_THROW );
+        xPropertySet->getPropertyValue( rtl::OUString::createFromAscii(ITEM_DESCRIPTOR_UINAME) ) >>= sUIName;
+        if( sName.equalsIgnoreAsciiCase( sUIName ) )
+            return sal_True;
+    }
+    return sal_False;
+}
+
+// return the resource url if found
+rtl::OUString VbaCommandBarHelper::findToolbarByName( const css::uno::Reference< css::container::XNameAccess >& xNameAccess, const rtl::OUString& sName ) throw (css::uno::RuntimeException)
+{
+    rtl::OUString sResourceUrl;
+
+    // check if it is an buildin toolbar
+    sResourceUrl = MSO2OOCommandbarHelper::getMSO2OOCommandbarHelper()->findBuildinToolbar( sName );
+    if( sResourceUrl.getLength() > 0 )
+        return sResourceUrl;
+
+    uno::Sequence< ::rtl::OUString > allNames = xNameAccess->getElementNames();
+    for( sal_Int32 i = 0; i < allNames.getLength(); i++ )
+    {
+        sResourceUrl = allNames[i];
+        if(sResourceUrl.indexOf( rtl::OUString::createFromAscii( ITEM_TOOLBAR_URL ) ) == 0 )
+        {
+            if( hasToolbar( sResourceUrl, sName ) )
+                return sResourceUrl;
+        }
+    }
+    
+    // the customize toolbars creating during importing, shoud found there.
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    sResourceUrl = sToolbarPrefix.concat( sName );
+    if( hasToolbar( sResourceUrl, sName ) )
+        return sResourceUrl;
+
+    return rtl::OUString();
+}
+
+// if found, return the position of the control. if not found, return -1
+sal_Int32 VbaCommandBarHelper::findControlByName( const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, const rtl::OUString& sName ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nCount = xIndexAccess->getCount();
+    css::uno::Sequence< css::beans::PropertyValue > aProps;
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        rtl::OUString sLabel;
+        xIndexAccess->getByIndex( i ) >>= aProps;
+        getPropertyValue( aProps, rtl::OUString::createFromAscii(ITEM_DESCRIPTOR_LABEL) ) >>= sLabel;
+        // handle the hotkey character '~'
+        rtl::OUString sNewLabel;
+        sal_Int32 index = sLabel.indexOf( sal_Unicode('~') );
+        if( index < 0 )
+            sNewLabel = sLabel;
+        else if( index == 0 )
+            sNewLabel = sLabel.copy( index + 1);
+        else if( index == sNewLabel.getLength() - 1 )
+            sNewLabel = sLabel.copy(0, index );
+        else
+            sNewLabel = sLabel.copy( 0, index ) + sLabel.copy( index + 1 ); 
+        OSL_TRACE("VbaCommandBarHelper::findControlByName, control name: %s", rtl::OUStringToOString( sNewLabel, RTL_TEXTENCODING_UTF8 ).getStr() );
+        if( sName.equalsIgnoreAsciiCase( sNewLabel ) )
+            return i;
+    }
+
+    // not found
+    return -1;
+}
+
+rtl::OUString VbaCommandBarHelper::generateCustomURL()
+{
+    rtl::OUString url = rtl::OUString::createFromAscii( ITEM_TOOLBAR_URL );
+    url += rtl::OUString::createFromAscii( CUSTOM_TOOLBAR_STR );
+
+    // use a random number to minimize possible clash with existing custom toolbars
+    srand( unsigned( time( NULL ) ));
+    url += rtl::OUString::valueOf( sal_Int64( rand() ), 16 );
+    return url;
+}
Index: vbahelper/source/vbahelper/vbacommandbarcontrol.cxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarcontrol.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarcontrol.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,259 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacommandbarcontrol.hxx"
+#include "vbacommandbarcontrols.hxx"
+#include <vbahelper/vbahelper.hxx>
+#include <svx/msvbahelper.hxx>
+
+using namespace com::sun::star;
+using namespace ooo::vba;
+
+ScVbaCommandBarControl::ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException) : CommandBarControl_BASE( xParent, xContext ), pCBarHelper( pHelper ), m_sResourceUrl( sResourceUrl ), m_xCurrentSettings( xSettings ), m_xBarSettings( xBarSettings ), m_nPosition( 0 ), m_bTemporary( sal_True )
+{
+}
+
+ScVbaCommandBarControl::ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary ) throw (css::uno::RuntimeException) : CommandBarControl_BASE( xParent, xContext ), pCBarHelper( pHelper ), m_sResourceUrl( sResourceUrl ), m_xCurrentSettings( xSettings ), m_xBarSettings( xBarSettings ), m_nPosition( nPosition ), m_bTemporary( bTemporary )
+{
+    m_xCurrentSettings->getByIndex( nPosition ) >>= m_aPropertyValues;
+}
+
+void ScVbaCommandBarControl::ApplyChange() throw ( uno::RuntimeException )
+{
+    uno::Reference< container::XIndexContainer > xIndexContainer( m_xCurrentSettings, uno::UNO_QUERY_THROW );
+    xIndexContainer->replaceByIndex( m_nPosition, uno::makeAny( m_aPropertyValues ) );
+    pCBarHelper->ApplyChange( m_sResourceUrl, m_xBarSettings );
+}
+
+::rtl::OUString SAL_CALL
+ScVbaCommandBarControl::getCaption() throw ( uno::RuntimeException )
+{
+    // "Label" always empty
+    rtl::OUString sCaption;
+    getPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("Label") ) >>= sCaption;
+    return sCaption;
+}
+
+void SAL_CALL 
+ScVbaCommandBarControl::setCaption( const ::rtl::OUString& _caption ) throw (uno::RuntimeException)
+{
+    rtl::OUString sCaption = _caption.replace('&','~');
+    setPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("Label"), uno::makeAny( sCaption ) );
+    ApplyChange();
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaCommandBarControl::getOnAction() throw (uno::RuntimeException)
+{
+    rtl::OUString sCommandURL;
+    getPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("CommandURL") ) >>= sCommandURL;
+    return sCommandURL;
+}
+
+void SAL_CALL 
+ScVbaCommandBarControl::setOnAction( const ::rtl::OUString& _onaction ) throw (uno::RuntimeException)
+{
+    // get the current model
+    uno::Reference< frame::XModel > xModel( pCBarHelper->getModel() ); 
+    VBAMacroResolvedInfo aResolvedMacro = ooo::vba::resolveVBAMacro( getSfxObjShell( xModel ), _onaction, true );
+    if ( aResolvedMacro.IsResolved() )
+    {
+        rtl::OUString aCommandURL = ooo::vba::makeMacroURL( aResolvedMacro.ResolvedMacro() );
+		OSL_TRACE(" ScVbaCommandBarControl::setOnAction: %s", rtl::OUStringToOString( aCommandURL, RTL_TEXTENCODING_UTF8 ).getStr() );
+        setPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("CommandURL"), uno::makeAny( aCommandURL ) );
+        ApplyChange();
+    }
+}
+
+::sal_Bool SAL_CALL 
+ScVbaCommandBarControl::getVisible() throw (uno::RuntimeException)
+{
+    sal_Bool bVisible = sal_True;
+    uno::Any aValue = getPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("IsVisible") );
+    if( aValue.hasValue() )
+        aValue >>= bVisible;
+    return bVisible;
+}
+void SAL_CALL 
+ScVbaCommandBarControl::setVisible( ::sal_Bool _visible ) throw (uno::RuntimeException)
+{
+    uno::Any aValue = getPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("IsVisible") );
+    if( aValue.hasValue() )
+    {
+        setPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii("IsVisible"), uno::makeAny( _visible ) );
+        ApplyChange();
+    }
+}
+
+::sal_Bool SAL_CALL 
+ScVbaCommandBarControl::getEnabled() throw (uno::RuntimeException)
+{
+    sal_Bool bEnabled = sal_True;
+    if( m_xParentMenu.is() )
+    {
+        // currently only the menu in the MenuBat support Enable/Disable
+        // FIXME: how to support the menu item in Toolbar
+        bEnabled = m_xParentMenu->isItemEnabled( m_xParentMenu->getItemId( sal::static_int_cast< sal_Int16 >( m_nPosition ) ) );
+    }
+    else
+    {
+        // emulated with Visible
+        bEnabled = getVisible();
+    }    
+    return bEnabled;
+}
+
+void SAL_CALL
+ScVbaCommandBarControl::setEnabled( sal_Bool _enabled ) throw (uno::RuntimeException)
+{
+    if( m_xParentMenu.is() )
+    {
+        // currently only the menu in the MenuBat support Enable/Disable
+        m_xParentMenu->enableItem( m_xParentMenu->getItemId( sal::static_int_cast< sal_Int16 >( m_nPosition ) ), _enabled );
+    }
+    else
+    {
+        // emulated with Visible
+        setVisible( _enabled );
+    }    
+}
+
+void SAL_CALL 
+ScVbaCommandBarControl::Delete(  ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    if( m_xCurrentSettings.is() )
+    {
+        uno::Reference< container::XIndexContainer > xIndexContainer( m_xCurrentSettings, uno::UNO_QUERY_THROW );
+        xIndexContainer->removeByIndex( m_nPosition );
+
+        pCBarHelper->ApplyChange( m_sResourceUrl, m_xBarSettings );
+    }
+}
+
+uno::Any SAL_CALL 
+ScVbaCommandBarControl::Controls( const uno::Any& aIndex ) throw (script::BasicErrorException, uno::RuntimeException)
+{
+    // only Popup Menu has controls
+    uno::Reference< container::XIndexAccess > xSubMenu;
+    getPropertyValue( m_aPropertyValues, rtl::OUString::createFromAscii( ITEM_DESCRIPTOR_CONTAINER ) ) >>= xSubMenu;
+    if( !xSubMenu.is() )
+        throw uno::RuntimeException();
+    
+    uno::Reference< awt::XMenu > xMenu;
+    if( m_xParentMenu.is() )
+    {
+        sal_Int16 nItemId = m_xParentMenu->getItemId( sal::static_int_cast< sal_Int16 >( m_nPosition ) );
+        xMenu.set( m_xParentMenu->getPopupMenu( nItemId ), uno::UNO_QUERY );
+    }    
+
+    uno::Reference< XCommandBarControls > xCommandBarControls( new ScVbaCommandBarControls( this, mxContext, xSubMenu, pCBarHelper, m_xBarSettings, m_sResourceUrl, xMenu ) );
+    if( aIndex.hasValue() )
+    {
+        return xCommandBarControls->Item( aIndex, uno::Any() );
+    }
+    return uno::makeAny( xCommandBarControls );
+}
+
+rtl::OUString& 
+ScVbaCommandBarControl::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarControl") );
+	return sImplName;
+}
+
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBarControl::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarControl" ) );
+	}
+	return aServiceNames;
+}
+
+//////////// ScVbaCommandBarPopup //////////////////////////////
+ScVbaCommandBarPopup::ScVbaCommandBarPopup( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary, const css::uno::Reference< css::awt::XMenu >& xMenu ) throw (css::uno::RuntimeException) : CommandBarPopup_BASE( xParent, xContext, xSettings, pHelper, xBarSettings, sResourceUrl )
+{
+    m_nPosition = nPosition;
+    m_bTemporary = bTemporary;
+    m_xCurrentSettings->getByIndex( m_nPosition ) >>= m_aPropertyValues;
+    m_xParentMenu = xMenu;
+}
+
+rtl::OUString& 
+ScVbaCommandBarPopup::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarPopup") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBarPopup::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarPopup" ) );
+	}
+	return aServiceNames;
+}
+
+//////////// ScVbaCommandBarButton //////////////////////////////
+ScVbaCommandBarButton::ScVbaCommandBarButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary, const css::uno::Reference< css::awt::XMenu >& xMenu ) throw (css::uno::RuntimeException) : CommandBarButton_BASE( xParent, xContext, xSettings, pHelper, xBarSettings, sResourceUrl )
+{
+    m_nPosition = nPosition;
+    m_bTemporary = bTemporary;
+    m_xCurrentSettings->getByIndex( m_nPosition ) >>= m_aPropertyValues;
+    m_xParentMenu = xMenu;
+}
+
+rtl::OUString& 
+ScVbaCommandBarButton::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaCommandBarButton") );
+	return sImplName;
+}
+uno::Sequence<rtl::OUString> 
+ScVbaCommandBarButton::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.CommandBarButton" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbacommandbarhelper.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef VBA_COMMANDBARHELPER_HXX
+#define VBA_COMMANDBARHELPER_HXX
+
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/ui/XUIConfigurationManager.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <boost/shared_ptr.hpp>
+
+
+static const char ITEM_DESCRIPTOR_COMMANDURL[]  = "CommandURL";
+static const char ITEM_DESCRIPTOR_HELPURL[]     = "HelpURL";
+static const char ITEM_DESCRIPTOR_CONTAINER[]   = "ItemDescriptorContainer";
+static const char ITEM_DESCRIPTOR_LABEL[]       = "Label";
+static const char ITEM_DESCRIPTOR_TYPE[]        = "Type";
+static const char ITEM_DESCRIPTOR_STYLE[]       = "Style";
+static const char ITEM_DESCRIPTOR_ISVISIBLE[]   = "IsVisible";
+static const char ITEM_DESCRIPTOR_RESOURCEURL[] = "ResourceURL";
+static const char ITEM_DESCRIPTOR_UINAME[]		= "UIName";
+
+static const char ITEM_MENUBAR_URL[] = "private:resource/menubar/menubar";
+static const char ITEM_TOOLBAR_URL[] = "private:resource/toolbar/";
+
+static const char CUSTOM_TOOLBAR_STR[] = "custom_toolbar_";
+static const char CUSTOM_MENU_STR[] = "vnd.openoffice.org:CustomMenu";
+
+class VbaCommandBarHelper;
+typedef ::boost::shared_ptr< VbaCommandBarHelper > VbaCommandBarHelperRef;
+
+class VbaCommandBarHelper
+{
+private:
+    css::uno::Reference< css::uno::XComponentContext > mxContext;
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xDocCfgMgr; // current document
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xAppCfgMgr;
+    css::uno::Reference< css::container::XNameAccess > m_xWindowState;
+    rtl::OUString maModuleId;
+
+    void Init() throw (css::uno::RuntimeException);
+    sal_Bool hasToolbar( const rtl::OUString& sResourceUrl, const rtl::OUString& sName )  throw (css::uno::RuntimeException);
+public:
+    VbaCommandBarHelper( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel ) throw( css::uno::RuntimeException );
+
+    css::uno::Reference< css::frame::XModel > getModel() { return mxModel; }
+
+    css::uno::Reference< css::ui::XUIConfigurationManager > getDocCfgManager() throw (css::uno::RuntimeException)
+    {
+        return m_xDocCfgMgr;
+    }
+    css::uno::Reference< css::ui::XUIConfigurationManager > getAppCfgManager() throw (css::uno::RuntimeException)
+    {
+        return m_xAppCfgMgr;
+    }
+    css::uno::Reference< css::container::XNameAccess > getPersistentWindowState() throw (css::uno::RuntimeException)
+    {
+        return m_xWindowState;
+    }
+    sal_Bool persistChanges() throw (css::uno::RuntimeException);
+    css::uno::Reference< css::container::XIndexAccess > getSettings( const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException);
+    void removeSettings( const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException);
+    void ApplyChange( const rtl::OUString& sResourceUrl, const css::uno::Reference< css::container::XIndexAccess >& xSettings, sal_Bool bTemporary = sal_True ) throw (css::uno::RuntimeException);
+
+    css::uno::Reference< css::frame::XLayoutManager > getLayoutManager() throw (css::uno::RuntimeException);
+
+    const rtl::OUString getModuleId(){ return maModuleId; }
+    rtl::OUString findToolbarByName( const css::uno::Reference< css::container::XNameAccess >& xNameAccess, const rtl::OUString& sName ) throw (css::uno::RuntimeException);
+    static sal_Int32 findControlByName( const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess, const rtl::OUString& sName ) throw (css::uno::RuntimeException);
+    static rtl::OUString generateCustomURL();
+};
+
+#endif//VBA_COMMANDBARHELPER_HXX
Index: vbahelper/source/vbahelper/vbacommandbarcontrol.hxx
===================================================================
--- vbahelper/source/vbahelper/vbacommandbarcontrol.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbacommandbarcontrol.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,122 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMANDBARCONTROL_HXX
+#define SC_VBA_COMMANDBARCONTROL_HXX
+
+#include <ooo/vba/XCommandBarControl.hpp>
+#include <ooo/vba/XCommandBarPopup.hpp>
+#include <ooo/vba/XCommandBarButton.hpp>
+#include <ooo/vba/office/MsoControlType.hpp>
+#include <com/sun/star/awt/XMenu.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include "vbacommandbarhelper.hxx"
+#include <cppuhelper/implbase1.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::XCommandBarControl > CommandBarControl_BASE;
+
+class ScVbaCommandBarControl : public CommandBarControl_BASE
+{
+protected:
+    VbaCommandBarHelperRef pCBarHelper;
+    rtl::OUString       m_sResourceUrl;
+    css::uno::Reference< css::container::XIndexAccess >          m_xCurrentSettings;
+    css::uno::Reference< css::container::XIndexAccess >          m_xBarSettings;
+    css::uno::Sequence< css::beans::PropertyValue >              m_aPropertyValues;
+    css::uno::Reference< css::awt::XMenu >                        m_xParentMenu;
+
+    sal_Int32           m_nPosition;
+    sal_Bool            m_bTemporary;
+
+private:
+    void ApplyChange() throw (css::uno::RuntimeException);
+
+public:
+    ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl ) throw (css::uno::RuntimeException);
+    ScVbaCommandBarControl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary ) throw (css::uno::RuntimeException);
+    
+    // Attributes
+    virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getOnAction() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setOnAction( const ::rtl::OUString& _onaction ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( ::sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getEnabled() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnabled( ::sal_Bool _enabled ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException)
+    {
+        return ov::office::MsoControlType::msoControlButton;
+    }
+
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Controls( const css::uno::Any& aIndex ) throw (css::script::BasicErrorException, css::uno::RuntimeException);
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+typedef cppu::ImplInheritanceHelper1< ScVbaCommandBarControl, ov::XCommandBarPopup > CommandBarPopup_BASE;
+class ScVbaCommandBarPopup : public CommandBarPopup_BASE
+{
+public:
+    ScVbaCommandBarPopup( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary, const css::uno::Reference< css::awt::XMenu >& xMenu ) throw (css::uno::RuntimeException);
+
+    virtual sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException)
+    {
+        return ov::office::MsoControlType::msoControlPopup;
+    }
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+typedef cppu::ImplInheritanceHelper1< ScVbaCommandBarControl, ov::XCommandBarButton > CommandBarButton_BASE;
+class ScVbaCommandBarButton : public CommandBarButton_BASE
+{
+public:
+    ScVbaCommandBarButton( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xSettings, VbaCommandBarHelperRef pHelper, const css::uno::Reference< css::container::XIndexAccess >& xBarSettings, const rtl::OUString& sResourceUrl, sal_Int32 nPosition, sal_Bool bTemporary, const css::uno::Reference< css::awt::XMenu >& xMenu ) throw (css::uno::RuntimeException);
+
+    virtual sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException)
+    {
+        return ov::office::MsoControlType::msoControlButton;
+    }
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif//SC_VBA_COMMANDBARCONTROL_HXX
Index: vbahelper/source/vbahelper/vbashaperange.cxx
===================================================================
--- vbahelper/source/vbahelper/vbashaperange.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbashaperange.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,382 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashaperange.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <com/sun/star/drawing/XShapeGrouper.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include<com/sun/star/view/XSelectionSupplier.hpp>
+
+#include <vbahelper/vbahelper.hxx>
+#include <vbahelper/vbashaperange.hxx>
+#include <vbahelper/vbashape.hxx>
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+class VbShapeRangeEnumHelper : public EnumerationHelper_BASE
+{
+        uno::Reference< XCollection > m_xParent;
+        uno::Reference<container::XIndexAccess > m_xIndexAccess;
+        sal_Int32 nIndex;
+public:
+	VbShapeRangeEnumHelper( const uno::Reference< XCollection >& xParent,  const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xParent( xParent ), m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+        {
+                return ( nIndex < m_xIndexAccess->getCount() );
+        }
+        virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+        {
+                ScVbaShapeRange* pCollectionImpl = dynamic_cast< ScVbaShapeRange* >(m_xParent.get());
+                if ( pCollectionImpl && hasMoreElements() )
+                    return pCollectionImpl->createCollectionObject(  m_xIndexAccess->getByIndex( nIndex++ ) );
+                throw container::NoSuchElementException();
+        }
+
+};
+
+ScVbaShapeRange::ScVbaShapeRange( const uno::Reference< XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xShapes, const uno::Reference< drawing::XDrawPage >& xDrawPage, const uno::Reference< frame::XModel >& xModel  ) : ScVbaShapeRange_BASE( xParent, xContext, xShapes ), m_xDrawPage( xDrawPage ), m_nShapeGroupCount(0), m_xModel( xModel )
+{
+}
+
+// Methods
+void SAL_CALL 
+ScVbaShapeRange::Select(  ) throw (uno::RuntimeException)
+{
+    uno::Reference< view::XSelectionSupplier > xSelectSupp( m_xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    xSelectSupp->select( uno::makeAny( getShapes() ) );
+}
+
+uno::Reference< msforms::XShape > SAL_CALL 
+ScVbaShapeRange::Group() throw (uno::RuntimeException)
+{
+    uno::Reference< drawing::XShapeGrouper > xShapeGrouper( m_xDrawPage, uno::UNO_QUERY_THROW );
+    uno::Reference< drawing::XShapeGroup > xShapeGroup( xShapeGrouper->group( getShapes() ), uno::UNO_QUERY_THROW );
+    uno::Reference< drawing::XShape > xShape( xShapeGroup, uno::UNO_QUERY_THROW );
+    return uno::Reference< msforms::XShape >( new ScVbaShape( getParent(), mxContext, xShape, getShapes(), m_xModel, office::MsoShapeType::msoGroup ) );
+}
+
+uno::Reference< drawing::XShapes > 
+ScVbaShapeRange::getShapes() throw (uno::RuntimeException)
+{
+	if ( !m_xShapes.is() )
+	{
+		uno::Reference< lang::XMultiServiceFactory > xMSF( mxContext->getServiceManager(), uno::UNO_QUERY_THROW );
+		m_xShapes.set( xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.drawing.ShapeCollection" ) ), uno::UNO_QUERY_THROW );
+		sal_Int32 nLen = m_xIndexAccess->getCount();
+		for ( sal_Int32 index = 0; index < nLen; ++index )
+			m_xShapes->add( uno::Reference< drawing::XShape >( m_xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ) );
+
+	}
+	return m_xShapes;
+}
+
+
+void SAL_CALL 
+ScVbaShapeRange::IncrementRotation( double Increment ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->IncrementRotation( Increment );
+	}
+}
+
+void SAL_CALL 
+ScVbaShapeRange::IncrementLeft( double Increment ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->IncrementLeft( Increment );
+	}
+}
+
+void SAL_CALL 
+ScVbaShapeRange::IncrementTop( double Increment ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->IncrementTop( Increment );
+	}
+}
+
+double SAL_CALL ScVbaShapeRange::getHeight() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getHeight( );
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setHeight( double _height ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setHeight( _height );
+	}
+}
+
+double SAL_CALL ScVbaShapeRange::getWidth() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getWidth( );
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setWidth( double _width ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setWidth( _width );
+	}
+}
+
+double SAL_CALL ScVbaShapeRange::getLeft() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getLeft();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setLeft( double _left ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setLeft( _left );
+	}
+}
+
+double SAL_CALL ScVbaShapeRange::getTop() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getTop();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setTop( double _top ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setTop( _top );
+	}
+}
+
+uno::Reference< ov::msforms::XLineFormat > SAL_CALL ScVbaShapeRange::getLine() throw (css::uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getLine();
+	}
+    throw uno::RuntimeException();
+}
+
+uno::Reference< ov::msforms::XFillFormat > SAL_CALL ScVbaShapeRange::getFill() throw (css::uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getFill();
+	}
+    throw uno::RuntimeException();
+}
+
+::sal_Bool SAL_CALL ScVbaShapeRange::getLockAspectRatio() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getLockAspectRatio();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setLockAspectRatio( ::sal_Bool _lockaspectratio ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setLockAspectRatio( _lockaspectratio );
+	}
+}
+
+::sal_Bool SAL_CALL ScVbaShapeRange::getLockAnchor() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getLockAnchor();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setLockAnchor( ::sal_Bool _lockanchor ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setLockAnchor( _lockanchor );
+	}
+}
+
+::sal_Int32 SAL_CALL ScVbaShapeRange::getRelativeHorizontalPosition() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getRelativeHorizontalPosition();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setRelativeHorizontalPosition( _relativehorizontalposition );
+	}
+}
+
+::sal_Int32 SAL_CALL ScVbaShapeRange::getRelativeVerticalPosition() throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->getRelativeVerticalPosition();
+	}
+    throw uno::RuntimeException();
+}
+
+void SAL_CALL ScVbaShapeRange::setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		xShape->setRelativeVerticalPosition( _relativeverticalposition );
+	}
+}
+
+uno::Any SAL_CALL ScVbaShapeRange::TextFrame(  ) throw (css::uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->TextFrame();
+	}
+    throw uno::RuntimeException();
+}
+
+uno::Any SAL_CALL ScVbaShapeRange::WrapFormat(  ) throw (css::uno::RuntimeException)
+{
+	sal_Int32 nLen = getCount();
+	for ( sal_Int32 index = 1; index <= nLen; ++index )
+	{
+		uno::Reference< msforms::XShape > xShape( Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
+		return xShape->WrapFormat();
+	}
+    throw uno::RuntimeException();
+}
+
+uno::Type SAL_CALL
+ScVbaShapeRange::getElementType() throw (uno::RuntimeException)
+{
+    return msforms::XShape::static_type(0);
+}
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaShapeRange::createEnumeration() throw (uno::RuntimeException)
+{
+	return new VbShapeRangeEnumHelper( this, m_xIndexAccess );
+}
+
+uno::Any
+ScVbaShapeRange:: createCollectionObject( const css::uno::Any& aSource )
+{
+	uno::Reference< drawing::XShape > xShape( aSource, uno::UNO_QUERY_THROW );
+	// #TODO  #FIXME Shape parent should always be the sheet the shapes belong 
+	// to 
+	uno::Reference< msforms::XShape > xVbShape( new ScVbaShape( uno::Reference< XHelperInterface >(), mxContext, xShape, getShapes(), m_xModel, ScVbaShape::getType( xShape ) ) ); 
+        return uno::makeAny( xVbShape );
+}
+
+rtl::OUString& 
+ScVbaShapeRange::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaShapeRange") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaShapeRange::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ooo.vba.msform.ShapeRange" ) );
+	}
+	return aServiceNames;
+}
Index: vbahelper/source/vbahelper/vbapropvalue.cxx
===================================================================
--- vbahelper/source/vbahelper/vbapropvalue.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbapropvalue.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,48 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbapropvalue.cxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include "vbahelper/vbapropvalue.hxx"
+
+using namespace com::sun::star;
+ 
+ScVbaPropValue::ScVbaPropValue( PropListener* pListener ) : m_pListener( pListener )
+{
+}
+
+css::uno::Any SAL_CALL 
+ScVbaPropValue::getValue() throw (css::uno::RuntimeException)
+{
+    return m_pListener->getValueEvent();
+}
+
+void SAL_CALL 
+ScVbaPropValue::setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException)
+{
+    m_pListener->setValueEvent( _value );
+}
Index: vbahelper/source/vbahelper/vbadialogsbase.cxx
===================================================================
--- vbahelper/source/vbahelper/vbadialogsbase.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/source/vbahelper/vbadialogsbase.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,47 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialogs.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#include <vbahelper/vbadialogsbase.hxx>
+
+using namespace ::ooo::vba;
+using namespace ::com::sun::star;
+
+::sal_Int32
+VbaDialogsBase::getCount() throw (uno::RuntimeException)
+{
+	//#TODO #FIXEME
+	return 0;
+}
+
+uno::Any
+VbaDialogsBase::Item( const uno::Any& /* &aItem */) throw (uno::RuntimeException)
+{
+	return uno::Any();
+}
+
Index: vbahelper/inc/vbahelper/vbashapes.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbashapes.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbashapes.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashapes.hxx,v $
+ * $Revision: 1.3.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SHAPES_HXX
+#define SC_VBA_SHAPES_HXX
+
+#include <com/sun/star/drawing/XShapes.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <ooo/vba/msforms/XShapes.hpp>
+
+#include <vbahelper/vbahelperinterface.hxx>
+
+#include <vbahelper/vbacollectionimpl.hxx>
+
+typedef CollTestImplHelper< ov::msforms::XShapes > ScVbaShapes_BASE;
+
+class VBAHELPER_DLLPUBLIC ScVbaShapes : public ScVbaShapes_BASE
+{
+private: 
+    css::uno::Reference< css::drawing::XShapes > m_xShapes;
+    css::uno::Reference< css::drawing::XDrawPage > m_xDrawPage;
+    sal_Int32 m_nNewShapeCount;
+    void initBaseCollection();
+protected:
+    css::uno::Reference< css::frame::XModel > m_xModel;
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+	virtual css::uno::Reference< css::container::XIndexAccess > getShapesByArrayIndices( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+    css::uno::Reference< css::drawing::XShape > createShape( rtl::OUString service ) throw (css::uno::RuntimeException);
+    css::uno::Any AddRectangle( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, css::uno::Any aRange ) throw (css::uno::RuntimeException);
+    css::uno::Any AddEllipse( sal_Int32 startX, sal_Int32 startY, sal_Int32 nLineWidth, sal_Int32 nLineHeight, css::uno::Any aRange ) throw (css::uno::RuntimeException);
+    css::uno::Any AddTextboxInWriter( sal_Int32 _nOrientation, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (css::uno::RuntimeException);
+    rtl::OUString createName( rtl::OUString sName );
+    css::uno::Any AddShape( const rtl::OUString& sService, const rtl::OUString& sName, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (css::uno::RuntimeException);
+    //TODO helperapi using a writer document
+    //css::awt::Point calculateTopLeftMargin( css::uno::Reference< ov::XHelperInterface > xDocument );
+    
+public:
+    ScVbaShapes( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess > xShapes, const css::uno::Reference< css::frame::XModel >& xModel );
+    static void setDefaultShapeProperties( css::uno::Reference< css::drawing::XShape > xShape ) throw (css::uno::RuntimeException);
+    static void setShape_NameProperty( css::uno::Reference< css::drawing::XShape > xShape, rtl::OUString sName );
+    //XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL SelectAll() throw (css::uno::RuntimeException);
+    //helper::calc
+    virtual css::uno::Any SAL_CALL AddLine( sal_Int32 StartX, sal_Int32 StartY, sal_Int32 endX, sal_Int32 endY ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL AddShape( sal_Int32 _nType, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL AddTextbox( sal_Int32 _nOrientation, sal_Int32 _nLeft, sal_Int32 _nTop, sal_Int32 _nWidth, sal_Int32 _nHeight ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XShapeRange > SAL_CALL Range( const css::uno::Any& shapes ) throw (css::uno::RuntimeException);
+    // ScVbaCollectionBaseImpl
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& Index2 ) throw (css::uno::RuntimeException);
+};
+
+#endif//SC_VBA_SHAPES_HXX
Index: vbahelper/inc/vbahelper/vbadllapi.h
===================================================================
--- vbahelper/inc/vbahelper/vbadllapi.h	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbadllapi.h	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,44 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: svldllapi.h,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_VBADLLAPI_H
+#define INCLUDED_VBADLLAPI_H
+
+#include "sal/types.h"
+
+#if defined(VBAHELPER_DLLIMPLEMENTATION)
+#define VBAHELPER_DLLPUBLIC  SAL_DLLPUBLIC_EXPORT
+#else
+#define VBAHELPER_DLLPUBLIC  SAL_DLLPUBLIC_IMPORT
+#endif
+#define VBAHELPER_DLLPRIVATE SAL_DLLPRIVATE
+
+#endif /* INCLUDED_SVLDLLAPI_H */
+
Index: vbahelper/inc/vbahelper/vbapagesetupbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbapagesetupbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbapagesetupbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_PAGESETUPBASE_HXX
+#define VBA_PAGESETUPBASE_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/XPageSetupBase.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::XPageSetupBase > VbaPageSetupBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaPageSetupBase :  public VbaPageSetupBase_BASE 
+{
+protected:
+    css::uno::Reference< css::frame::XModel > mxModel;
+    css::uno::Reference< css::beans::XPropertySet > mxPageProps;
+    sal_Int32 mnOrientLandscape;
+    sal_Int32 mnOrientPortrait;
+
+	VbaPageSetupBase( const css::uno::Reference< ov::XHelperInterface >& xParent, 
+                    const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException); 
+public:
+	virtual ~VbaPageSetupBase(){}
+    
+    // Attribute
+	virtual double SAL_CALL getTopMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setTopMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getBottomMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setBottomMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getRightMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setRightMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getLeftMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setLeftMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getHeaderMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setHeaderMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getFooterMargin() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setFooterMargin( double margin ) throw (css::uno::RuntimeException);
+	virtual sal_Int32 SAL_CALL getOrientation() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setOrientation( sal_Int32 orientation ) throw (css::uno::RuntimeException);
+};
+#endif
Index: vbahelper/inc/vbahelper/vbadialogbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbadialogbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbadialogbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialog.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_DIALOG_BASE_HXX
+#define VBA_DIALOG_BASE_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/XDialogBase.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/frame/XModel.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ov::XDialogBase > VbaDialogBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaDialogBase : public VbaDialogBase_BASE
+{
+protected:
+	sal_Int32 mnIndex;
+        css::uno::Reference< css::frame::XModel > m_xModel;
+public:
+	VbaDialogBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel, sal_Int32 nIndex ):VbaDialogBase_BASE( xParent, xContext ), mnIndex( nIndex ), m_xModel( xModel ) {}
+	virtual ~VbaDialogBase() {}
+
+	// Methods
+	virtual void SAL_CALL Show() throw (css::uno::RuntimeException);
+	virtual rtl::OUString mapIndexToName( sal_Int32 nIndex ) = 0;
+};
+
+#endif /* VBA_DIALOG_BASE_HXX */
Index: vbahelper/inc/vbahelper/vbaglobalbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbaglobalbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbaglobalbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaapplicationbase.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_GLOBAL_BASE_HXX
+#define VBA_GLOBAL_BASE_HXX
+
+#include "vbahelperinterface.hxx"
+#include <ooo/vba/XGlobalsBase.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ov::XGlobalsBase > Globals_BASE;
+class VBAHELPER_DLLPUBLIC VbaGlobalsBase : public Globals_BASE
+
+{
+protected:
+
+    bool hasServiceName( const rtl::OUString& serviceName );
+    void init(  const css::uno::Sequence< css::beans::PropertyValue >& aInitArgs );
+
+public:
+    VbaGlobalsBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const rtl::OUString& sDocCtxName );
+    virtual ~VbaGlobalsBase(){};
+    // XMultiServiceFactory
+    virtual css::uno::Reference< css::uno::XInterface > SAL_CALL createInstance( const ::rtl::OUString& aServiceSpecifier ) throw (css::uno::Exception, css::uno::RuntimeException);
+    virtual css::uno::Reference< css::uno::XInterface > SAL_CALL createInstanceWithArguments( const ::rtl::OUString& ServiceSpecifier, const css::uno::Sequence< css::uno::Any >& Arguments ) throw (css::uno::Exception, css::uno::RuntimeException);
+    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getAvailableServiceNames(  ) throw (css::uno::RuntimeException);
+};
+#endif
Index: vbahelper/inc/vbahelper/vbadocumentsbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbadocumentsbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbadocumentsbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_WORKBOOKS_HXX
+#define VBA_WORKBOOKS_HXX
+
+
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/XDocumentsBase.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+
+typedef CollTestImplHelper< ooo::vba::XDocumentsBase > VbaDocumentsBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaDocumentsBase : public VbaDocumentsBase_BASE
+{
+public:
+    enum DOCUMENT_TYPE
+    {
+        WORD_DOCUMENT = 1,
+        EXCEL_DOCUMENT
+    };
+
+private:
+    DOCUMENT_TYPE meDocType;
+
+public:
+	VbaDocumentsBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, DOCUMENT_TYPE eDocType ) throw (css::uno::RuntimeException);
+	virtual ~VbaDocumentsBase() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException) = 0;
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException) = 0;
+
+	// VbaDocumentsBase_BASE
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ) = 0;
+
+	// XDocumentsBase
+	virtual css::uno::Any SAL_CALL Add() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& ReadOnly, const css::uno::Sequence< css::beans::PropertyValue >& rProps ) throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_WORKBOOKS_HXX */
Index: vbahelper/inc/vbahelper/vbaapplicationbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbaapplicationbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbaapplicationbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbaapplicationbase.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_APPLICATION_BASE_HXX
+#define VBA_APPLICATION_BASE_HXX
+
+#include <ooo/vba/XHelperInterface.hpp>
+#include <ooo/vba/XApplicationBase.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <sfx2/objsh.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::XApplicationBase > ApplicationBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaApplicationBase : public ApplicationBase_BASE
+{
+protected:
+    VbaApplicationBase( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+    virtual ~VbaApplicationBase();
+
+    virtual css::uno::Reference< css::frame::XModel > getCurrentDocument() throw (css::uno::RuntimeException) = 0;
+public:
+	// XHelperInterface ( parent is itself )
+	virtual css::uno::Reference< ov::XHelperInterface > SAL_CALL getParent(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { return this; }
+
+	virtual sal_Bool SAL_CALL getScreenUpdating() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setScreenUpdating(sal_Bool bUpdate) throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getDisplayStatusBar() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL CommandBars( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);  
+	virtual ::rtl::OUString SAL_CALL getVersion() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Run( const ::rtl::OUString& MacroName, const css::uno::Any& varg1, const css::uno::Any& varg2, const css::uno::Any& varg3, const css::uno::Any& varg4, const css::uno::Any& varg5, const css::uno::Any& varg6, const css::uno::Any& varg7, const css::uno::Any& varg8, const css::uno::Any& varg9, const css::uno::Any& varg10, const css::uno::Any& varg11, const css::uno::Any& varg12, const css::uno::Any& varg13, const css::uno::Any& varg14, const css::uno::Any& varg15, const css::uno::Any& varg16, const css::uno::Any& varg17, const css::uno::Any& varg18, const css::uno::Any& varg19, const css::uno::Any& varg20, const css::uno::Any& varg21, const css::uno::Any& varg22, const css::uno::Any& varg23, const css::uno::Any& varg24, const css::uno::Any& varg25, const css::uno::Any& varg26, const css::uno::Any& varg27, const css::uno::Any& varg28, const css::uno::Any& varg29, const css::uno::Any& varg30 ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL CentimetersToPoints( float _Centimeters ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Quit(  ) throw (::com::sun::star::uno::RuntimeException);
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+#endif
Index: vbahelper/inc/vbahelper/vbatextframe.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbatextframe.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbatextframe.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,70 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbatextframe.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_TEXTFRAME_HXX
+#define VBA_TEXTFRAME_HXX
+#include <ooo/vba/msforms/XTextFrame.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ov::msforms::XTextFrame > VbaTextFrame_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaTextFrame : public VbaTextFrame_BASE
+{
+protected:    
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+protected:
+    virtual rtl::OUString& getServiceImplName();
+    virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+    virtual void setAsMSObehavior();
+    sal_Int32 getMargin( rtl::OUString sMarginType );
+    void setMargin( rtl::OUString sMarginType, float fMargin );
+public:
+    VbaTextFrame( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext , css::uno::Reference< css::drawing::XShape > xShape);
+    virtual ~VbaTextFrame() {}
+    // Attributes
+    virtual sal_Bool SAL_CALL getAutoSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAutoSize( sal_Bool _autosize ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getMarginBottom() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMarginBottom( float _marginbottom ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getMarginTop() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMarginTop( float _margintop ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getMarginLeft() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMarginLeft( float _marginleft ) throw (css::uno::RuntimeException);
+    virtual float SAL_CALL getMarginRight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setMarginRight( float _marginright ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual css::uno::Any SAL_CALL Characters(  ) throw (css::uno::RuntimeException);
+
+};
+
+#endif//SC_VBA_TEXTFRAME_HXX
Index: vbahelper/inc/vbahelper/vbahelperinterface.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbahelperinterface.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbahelperinterface.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelperinterface.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef OOVBAAPI_VBA_HELPERINTERFACE_HXX
+#define OOVBAAPI_VBA_HELPERINTERFACE_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/XHelperInterface.hpp>
+#include <vbahelper/vbahelper.hxx>
+#include <com/sun/star/container/XNameAccess.hpp>
+
+// use this class when you have an a object like
+// interface  XAnInterface which contains XHelperInterface in its inheritance hierarchy
+// interface XAnInterface
+// { 
+//     interface XHelperInterface;
+//     [attribute, string] name;
+// }
+// or
+// interface XAnInterface : XHelperInterface;
+// { 
+//     [attribute, string] name;
+// }
+//
+// then this class can provide a default implementation of XHelperInterface,
+// you can use it like this
+// typedef InheritedHelperInterfaceImpl< XAnInterface > > AnInterfaceImpl_BASE;
+// class AnInterfaceImpl : public AnInterfaceImpl_BASE
+// {
+// public:
+//     AnInterface( const Reference< HelperInterface >& xParent ) : AnInterfaceImpl_BASE( xParent ) {}
+//     // implement XAnInterface methods only, no need to implement the XHelperInterface 
+//     // methods
+//     virtual void setName( const OUString& );  
+//     virtual OUString getName();  
+// }
+//
+const ::rtl::OUString sHelperServiceName( RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.HelperServiceBase" ) );
+
+template< typename Ifc1 >
+class VBAHELPER_DLLPUBLIC InheritedHelperInterfaceImpl : public Ifc1
+{
+protected: 
+	css::uno::WeakReference< ov::XHelperInterface > mxParent;
+	css::uno::Reference< css::uno::XComponentContext > mxContext;
+public:
+	InheritedHelperInterfaceImpl() {}
+	InheritedHelperInterfaceImpl( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) : mxParent( xParent ), mxContext( xContext ) {}
+	virtual rtl::OUString& getServiceImplName() = 0;
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames() = 0;
+
+	// XHelperInterface Methods
+	virtual ::sal_Int32 SAL_CALL getCreator() throw (css::script::BasicErrorException, css::uno::RuntimeException)
+	{
+		return 0x53756E4F;
+	}
+	virtual css::uno::Reference< ov::XHelperInterface > SAL_CALL getParent(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { return mxParent; }
+	
+	virtual css::uno::Any SAL_CALL Application(  ) throw (css::script::BasicErrorException, css::uno::RuntimeException) { 
+            // The application could certainly be passed around in the context - seems
+            // to make sense
+            css::uno::Reference< css::container::XNameAccess > xNameAccess( mxContext, css::uno::UNO_QUERY_THROW );
+            return xNameAccess->getByName( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Application" ) ) );
+	}
+
+
+	// XServiceInfo Methods
+	virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (css::uno::RuntimeException) { return getServiceImplName(); }
+	virtual ::sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (css::uno::RuntimeException) 
+	{ 
+		css::uno::Sequence< rtl::OUString > sServices = getSupportedServiceNames();
+		const rtl::OUString* pStart = sServices.getConstArray();
+		const rtl::OUString* pEnd = pStart + sServices.getLength();
+		for ( ; pStart != pEnd ; ++pStart )
+			if ( (*pStart).equals( ServiceName ) )
+				return sal_True;
+		return sal_False;	
+	}
+	virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) throw (css::uno::RuntimeException) 
+	{ 
+		css::uno::Sequence< rtl::OUString > aNames = getServiceNames();;
+		return aNames;
+	}
+ };
+
+template< typename Ifc1 >
+class VBAHELPER_DLLPUBLIC InheritedHelperInterfaceImpl1 : public InheritedHelperInterfaceImpl< ::cppu::WeakImplHelper1< Ifc1 > >
+
+{
+typedef InheritedHelperInterfaceImpl< ::cppu::WeakImplHelper1< Ifc1 > > Base;
+public:
+	InheritedHelperInterfaceImpl1< Ifc1 > ( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext ) : Base( xParent, xContext ) {}	
+
+};
+#endif
Index: vbahelper/inc/vbahelper/vbashape.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbashape.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbashape.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashape.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SHAPE_HXX
+#define SC_VBA_SHAPE_HXX
+
+#include <ooo/vba/office/MsoShapeType.hpp>
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/drawing/XShapes.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <ooo/vba/msforms/XShape.hpp>
+#include <ooo/vba/msforms/XLineFormat.hpp>
+#include <cppuhelper/implbase2.hxx>
+
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef  ::cppu::WeakImplHelper2< ov::msforms::XShape, css::lang::XEventListener > ListeningShape;
+
+typedef InheritedHelperInterfaceImpl< ListeningShape > ScVbaShape_BASE;
+
+class VBAHELPER_DLLPUBLIC ScVbaShape : public ScVbaShape_BASE
+{
+private:
+protected:
+    std::auto_ptr< ov::ShapeHelper > m_pShapeHelper;
+    css::uno::Reference< css::drawing::XShape > m_xShape;
+    css::uno::Reference< css::drawing::XShapes > m_xShapes;
+    css::uno::Reference< css::beans::XPropertySet > m_xPropertySet;
+    sal_Int32 m_nType;
+    css::uno::Reference< css::frame::XModel > m_xModel;
+    css::uno::Any m_aRange;
+	virtual void addListeners();
+	virtual void removeShapeListener() throw( css::uno::RuntimeException );
+	virtual void removeShapesListener() throw( css::uno::RuntimeException );
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+public:
+    ScVbaShape( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape, const css::uno::Reference< css::drawing::XShapes >& xShapes, const css::uno::Reference< css::frame::XModel >& xModel, sal_Int32 nType ) throw ( css::lang::IllegalArgumentException );
+    ScVbaShape( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape, const css::uno::Reference< css::frame::XModel >& xModel ) throw ( css::lang::IllegalArgumentException );
+    virtual ~ScVbaShape();
+    css::uno::Any getRange() { return m_aRange; };
+    void setRange( css::uno::Any aRange ) { m_aRange = aRange; };
+
+    static sal_Int32 getType( const css::uno::Reference< css::drawing::XShape > xShape ) throw (css::uno::RuntimeException);
+
+    // Attributes
+    virtual rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const rtl::OUString& _name ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( double _width ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getLeft() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLeft( double _left ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getTop() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTop( double _top ) throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getZOrderPosition() throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getType() throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getRotation() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRotation( double _rotation ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XLineFormat > SAL_CALL getLine() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XFillFormat > SAL_CALL getFill() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XPictureFormat > SAL_CALL getPictureFormat() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLockAspectRatio() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLockAspectRatio( ::sal_Bool _lockaspectratio ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLockAnchor() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLockAnchor( ::sal_Bool _lockanchor ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getRelativeHorizontalPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getRelativeVerticalPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual css::uno::Any SAL_CALL SAL_CALL TextFrame(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL SAL_CALL WrapFormat(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Delete() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ZOrder( sal_Int32 ZOrderCmd ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ScaleHeight( double Factor, sal_Bool RelativeToOriginalSize, sal_Int32 Scale ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL ScaleWidth( double Factor, sal_Bool RelativeToOriginalSize, sal_Int32 Scale ) throw (css::uno::RuntimeException);
+    // Replace??
+    virtual void SAL_CALL Select( const css::uno::Any& Replace ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL ShapeRange( const css::uno::Any& index ) throw ( css::uno::RuntimeException );
+    // XEventListener
+    virtual void SAL_CALL disposing( const css::lang::EventObject& rEventObject ) throw( css::uno::RuntimeException );
+};
+#endif//SC_VBA_SHAPE_HXX
Index: vbahelper/inc/vbahelper/vbafontbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbafontbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbafontbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbafont.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBAHELPER_FONTBASE_HXX
+#define VBAHELPER_FONTBASE_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <ooo/vba/XFontBase.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+// use local constants there is no need to expose these constants
+// externally. Looking at the Format->Character dialog it seem that
+// these may infact be even be calculated. Leave hardcoded for now
+// #FIXEME #TBD investigate the code for dialog mentioned above
+
+// The font baseline is not specified.
+const short NORMAL = 0;
+
+// specifies a superscripted.
+const short SUPERSCRIPT = 33;
+
+// specifies a subscripted.
+const short SUBSCRIPT = -33;
+
+// specifies a hight of superscripted font
+ const sal_Int8 SUPERSCRIPTHEIGHT = 58;
+
+// specifies a hight of subscripted font
+const sal_Int8 SUBSCRIPTHEIGHT = 58;
+
+// specifies a hight of normal font
+const short NORMALHEIGHT = 100;
+
+typedef  InheritedHelperInterfaceImpl1< ov::XFontBase > VbaFontBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaFontBase : public VbaFontBase_BASE
+{
+protected:
+    css::uno::Reference< css::beans::XPropertySet > mxFont;
+    css::uno::Reference< css::container::XIndexAccess > mxPalette;
+public:
+	VbaFontBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xPalette, css::uno::Reference< css::beans::XPropertySet > xPropertySet ) throw ( css::uno::RuntimeException );
+	virtual ~VbaFontBase();// {}
+
+	// Attributes
+    virtual css::uno::Any SAL_CALL getSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSize( const css::uno::Any& _size ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getColorIndex() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getBold() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBold( const css::uno::Any& _bold ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getUnderline() throw (css::uno::RuntimeException) = 0;
+    virtual void SAL_CALL setUnderline( const css::uno::Any& _underline ) throw (css::uno::RuntimeException) = 0;
+    virtual css::uno::Any SAL_CALL getStrikethrough() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStrikethrough( const css::uno::Any& _strikethrough ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getShadow() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setShadow( const css::uno::Any& _shadow ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getItalic() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setItalic( const css::uno::Any& _italic ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getSubscript() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSubscript( const css::uno::Any& _subscript ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getSuperscript() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSuperscript( const css::uno::Any& _superscript ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const css::uno::Any& _name ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getColor() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setColor( const css::uno::Any& _color ) throw (css::uno::RuntimeException) ;
+};
+
+#endif
+
Index: vbahelper/inc/vbahelper/vbawindowbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbawindowbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbawindowbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_WINDOWBASE_HXX
+#define VBA_WINDOWBASE_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/XWindowBase.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/awt/XDevice.hpp>
+
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1<ov::XWindowBase > WindowBaseImpl_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaWindowBase : public WindowBaseImpl_BASE
+{		
+protected:		
+	css::uno::Reference< css::frame::XModel > m_xModel;
+public:
+	VbaWindowBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel );
+    VbaWindowBase( css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext > const& xContext );
+
+	// XWindowBase
+    virtual sal_Int32 SAL_CALL getHeight() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setHeight( sal_Int32 _height ) throw (css::uno::RuntimeException) ;
+    virtual sal_Int32 SAL_CALL getLeft() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setLeft( sal_Int32 _left ) throw (css::uno::RuntimeException) ;
+    virtual sal_Int32 SAL_CALL getTop() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setTop( sal_Int32 _top ) throw (css::uno::RuntimeException) ;
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getWidth() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setWidth( sal_Int32 _width ) throw (css::uno::RuntimeException) ;
+
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif //VBA_WINDOWBASE_HXX
Index: vbahelper/inc/vbahelper/vbadocumentbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbadocumentbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbadocumentbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_DOCUMENTBASE_HXX
+#define VBA_DOCUMENTBASE_HXX
+
+#include <com/sun/star/frame/XModel.hpp>
+#include <ooo/vba/XDocumentBase.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+
+typedef InheritedHelperInterfaceImpl1< ooo::vba::XDocumentBase > VbaDocumentBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaDocumentBase : public VbaDocumentBase_BASE
+{
+protected:
+	css::uno::Reference< css::frame::XModel > mxModel;
+protected:
+	virtual css::uno::Reference< css::frame::XModel >  getModel() { return mxModel; }
+	VbaDocumentBase( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext);
+public:
+	VbaDocumentBase( 	const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,
+			css::uno::Reference< css::frame::XModel > xModel );
+	VbaDocumentBase( 	css::uno::Sequence< css::uno::Any > const& aArgs, css::uno::Reference< css::uno::XComponentContext >const& xContext );
+	virtual ~VbaDocumentBase() {}
+
+    // Attributes
+	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getFullName() throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getSaved() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setSaved( sal_Bool bSave ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL Close( const css::uno::Any &bSaveChanges,
+								 const css::uno::Any &aFileName,
+								 const css::uno::Any &bRouteWorkbook ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Unprotect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Save() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+    
+	// XHelperInterface
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+};
+
+#endif /* VBA_DOCUMENTBASE_HXX */
Index: vbahelper/inc/vbahelper/vbadialogsbase.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbadialogsbase.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbadialogsbase.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbadialogs.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef VBA_DIALOGS_BASE_HXX
+#define VBA_DIALOGS_BASE_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <ooo/vba/XHelperInterface.hpp>
+#include <ooo/vba/XDialogsBase.hpp>
+#include <vbahelper/vbahelperinterface.hxx>
+#include <com/sun/star/frame/XModel.hpp>
+
+typedef InheritedHelperInterfaceImpl1< ov::XDialogsBase > VbaDialogsBase_BASE;
+
+class VBAHELPER_DLLPUBLIC VbaDialogsBase : public VbaDialogsBase_BASE
+{
+protected:
+        css::uno::Reference< css::frame::XModel > m_xModel;
+public:
+	VbaDialogsBase( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext > &xContext, const css::uno::Reference< css::frame::XModel >& xModel ): VbaDialogsBase_BASE( xParent, xContext ), m_xModel( xModel ) {} 
+	virtual ~VbaDialogsBase() {}
+
+	// XCollection
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+};
+
+#endif /* VBA_DIALOGS_BASE_HXX */
Index: vbahelper/inc/vbahelper/vbapropvalue.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbapropvalue.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbapropvalue.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbapropvalue.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PROPVALULE_HXX
+#define SC_VBA_PROPVALULE_HXX
+#include <ooo/vba/XPropValue.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+#include <vbahelper/vbahelper.hxx>
+
+typedef ::cppu::WeakImplHelper1< ov::XPropValue > PropValueImpl_BASE;
+
+class VBAHELPER_DLLPUBLIC PropListener 
+{
+public:
+    virtual void setValueEvent( const css::uno::Any& value ) = 0;
+    virtual css::uno::Any getValueEvent() = 0; 
+};
+
+
+class VBAHELPER_DLLPUBLIC ScVbaPropValue : public PropValueImpl_BASE 
+{
+    PropListener* m_pListener;
+public:
+    ScVbaPropValue( PropListener* pListener );
+
+    // Attributes
+    virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+
+    rtl::OUString SAL_CALL getDefaultPropertyName() throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+
+};
+#endif //SC_VBA_PROPVALULE_HXX
Index: vbahelper/inc/vbahelper/vbashaperange.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbashaperange.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbashaperange.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbashaperange.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SHAPERANGE_HXX
+#define SC_VBA_SHAPERANGE_HXX
+
+#include <com/sun/star/drawing/XShapes.hpp>
+#include <ooo/vba/msforms/XShapeRange.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <vbahelper/vbacollectionimpl.hxx>
+#include <ooo/vba/msforms/XLineFormat.hpp>
+#include <ooo/vba/msforms/XFillFormat.hpp>
+
+typedef CollTestImplHelper< ov::msforms::XShapeRange > ScVbaShapeRange_BASE;
+
+class VBAHELPER_DLLPUBLIC ScVbaShapeRange : public ScVbaShapeRange_BASE
+{
+private:
+    css::uno::Reference< css::drawing::XDrawPage > m_xDrawPage;
+    css::uno::Reference< css::drawing::XShapes > m_xShapes;
+    sal_Int32 m_nShapeGroupCount;
+protected:
+    css::uno::Reference< css::frame::XModel > m_xModel;
+	virtual rtl::OUString& getServiceImplName();
+	virtual css::uno::Sequence<rtl::OUString> getServiceNames();
+	css::uno::Reference< css::drawing::XShapes > getShapes() throw (css::uno::RuntimeException) ;
+public:
+    ScVbaShapeRange( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xShapes, const css::uno::Reference< css::drawing::XDrawPage>& xDrawShape, const css::uno::Reference< css::frame::XModel >& xModel );
+
+    // Methods
+    virtual void SAL_CALL Select(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ::ooo::vba::msforms::XShape > SAL_CALL Group() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementRotation( double Increment ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL IncrementLeft( double Increment ) throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL IncrementTop( double Increment ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getHeight() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setHeight( double _height ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getWidth() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWidth( double _width ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getLeft() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLeft( double _left ) throw (css::uno::RuntimeException);
+    virtual double SAL_CALL getTop() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setTop( double _top ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XLineFormat > SAL_CALL getLine() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< ov::msforms::XFillFormat > SAL_CALL getFill() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLockAspectRatio() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLockAspectRatio( ::sal_Bool _lockaspectratio ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getLockAnchor() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLockAnchor( ::sal_Bool _lockanchor ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getRelativeHorizontalPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRelativeHorizontalPosition( ::sal_Int32 _relativehorizontalposition ) throw (css::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getRelativeVerticalPosition() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setRelativeVerticalPosition( ::sal_Int32 _relativeverticalposition ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL SAL_CALL TextFrame(  ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL SAL_CALL WrapFormat(  ) throw (css::uno::RuntimeException);
+    //XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException); 
+    // ScVbaCollectionBaseImpl
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource );
+};
+
+#endif//SC_VBA_SHAPERANGE_HXX
Index: vbahelper/inc/vbahelper/vbacollectionimpl.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbacollectionimpl.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbacollectionimpl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,257 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbacollectionimpl.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef OOVBAAPI_VBA_COLLECTION_IMPL_HXX
+#define OOVBAAPI_VBA_COLLECTION_IMPL_HXX
+
+#include <ooo/vba/XCollection.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+
+#include <cppuhelper/implbase3.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+#include "vbahelper/vbahelper.hxx"
+#include "vbahelper/vbahelperinterface.hxx"
+
+#include <vector>
+
+typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumerationHelper_BASE;
+
+class VBAHELPER_DLLPUBLIC EnumerationHelperImpl : public EnumerationHelper_BASE
+{
+protected:
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::container::XEnumeration > m_xEnumeration;
+public:
+
+	EnumerationHelperImpl( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XEnumeration >& xEnumeration ) throw ( css::uno::RuntimeException ) : m_xContext( xContext ),  m_xEnumeration( xEnumeration ) { }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException) { return m_xEnumeration->hasMoreElements(); }
+};
+
+// a wrapper class for a providing a XIndexAccess, XNameAccess, XEnumerationAccess impl based on providing a vector of interfaces 
+// only requirement is the object needs to implement XName
+
+
+
+typedef ::cppu::WeakImplHelper3< css::container::XNameAccess, css::container::XIndexAccess, css::container::XEnumerationAccess > XNamedCollectionHelper_BASE;
+
+template< typename Ifc1 >
+class VBAHELPER_DLLPUBLIC XNamedObjectCollectionHelper : public XNamedCollectionHelper_BASE
+{
+public:
+typedef std::vector< css::uno::Reference< Ifc1 > >  XNamedVec;
+private:
+
+	class XNamedEnumerationHelper : public EnumerationHelper_BASE
+	{
+		XNamedVec mXNamedVec;
+		typename XNamedVec::iterator mIt;
+	public:
+	        XNamedEnumerationHelper( const XNamedVec& sMap ) : mXNamedVec( sMap ), mIt( mXNamedVec.begin() ) {}
+	
+	        virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException)
+	        {
+			return ( mIt != mXNamedVec.end() );
+	        }
+	
+	        virtual css::uno::Any SAL_CALL nextElement(  ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException)
+	        {
+	                if ( hasMoreElements() )
+				return css::uno::makeAny( *mIt++ );
+	                throw css::container::NoSuchElementException();
+	        }
+	};
+
+protected:
+	XNamedVec mXNamedVec;
+	typename XNamedVec::iterator cachePos;
+public:
+	XNamedObjectCollectionHelper( const XNamedVec& sMap ) : mXNamedVec( sMap ), cachePos(mXNamedVec.begin()) {}
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType(  ) throw (css::uno::RuntimeException) { return  Ifc1::static_type(0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (css::uno::RuntimeException) { return ( mXNamedVec.size() > 0 ); }
+	// XNameAcess 
+	virtual css::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException)
+	{
+		if ( !hasByName(aName) )
+			throw css::container::NoSuchElementException();
+		return css::uno::makeAny( *cachePos );
+	}
+	virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (css::uno::RuntimeException)
+	{
+		css::uno::Sequence< rtl::OUString > sNames( mXNamedVec.size() );
+		rtl::OUString* pString = sNames.getArray();
+		typename XNamedVec::iterator it = mXNamedVec.begin();
+		typename XNamedVec::iterator it_end = mXNamedVec.end();
+
+		for ( ; it != it_end; ++it, ++pString )
+		{
+			css::uno::Reference< css::container::XNamed > xName( *it, css::uno::UNO_QUERY_THROW );	
+			*pString = xName->getName();
+		}
+		return sNames;
+	}
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException)
+	{
+		cachePos = mXNamedVec.begin();
+		typename XNamedVec::iterator it_end = mXNamedVec.end();
+		for ( ; cachePos != it_end; ++cachePos )
+		{
+			css::uno::Reference< css::container::XNamed > xName( *cachePos, css::uno::UNO_QUERY_THROW );	
+			if ( aName.equals( xName->getName() ) )
+				break;
+		}
+		return ( cachePos != it_end );
+	}
+
+	// XElementAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (css::uno::RuntimeException) { return mXNamedVec.size(); }	
+	virtual css::uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (css::lang::IndexOutOfBoundsException, css::lang::WrappedTargetException, css::uno::RuntimeException )
+	{
+		if ( Index < 0 || Index >= getCount() )
+			throw css::lang::IndexOutOfBoundsException();
+	
+		return css::uno::makeAny( mXNamedVec[ Index ] );
+
+	}
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration(  ) throw (css::uno::RuntimeException)
+	{
+		return new XNamedEnumerationHelper( mXNamedVec );
+	}
+};
+
+// including a HelperInterface implementation
+template< typename Ifc1 >
+class ScVbaCollectionBase : public InheritedHelperInterfaceImpl< Ifc1 >
+{
+typedef InheritedHelperInterfaceImpl< Ifc1 > BaseColBase;
+protected:
+	css::uno::Reference< css::container::XIndexAccess > m_xIndexAccess;
+	css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
+
+	virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException)
+	{
+		if ( !m_xNameAccess.is() )
+			throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase string index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
+	
+		return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
+	}		
+
+	virtual css::uno::Any getItemByIntIndex( const sal_Int32 nIndex ) throw (css::uno::RuntimeException)
+	{
+		if ( !m_xIndexAccess.is() )
+			throw css::uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBase numeric index access not supported by this object") ), css::uno::Reference< css::uno::XInterface >() );
+		if ( nIndex <= 0 )
+		{
+			throw  css::lang::IndexOutOfBoundsException( 
+				::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
+				"index is 0 or negative" ) ), 
+				css::uno::Reference< css::uno::XInterface >() );
+		}
+		// need to adjust for vba index ( for which first element is 1 )
+		return createCollectionObject( m_xIndexAccess->getByIndex( nIndex - 1 ) );		
+	}
+public:
+	ScVbaCollectionBase( const css::uno::Reference< ov::XHelperInterface >& xParent,   const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) : BaseColBase( xParent, xContext ), m_xIndexAccess( xIndexAccess ){ m_xNameAccess.set(m_xIndexAccess, css::uno::UNO_QUERY); }
+	//XCollection
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException)
+	{
+		return m_xIndexAccess->getCount();
+	}
+
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index1, const css::uno::Any& /*not processed in this base class*/ ) throw (css::uno::RuntimeException)
+	{
+		if ( Index1.getValueTypeClass() != css::uno::TypeClass_STRING )
+		{
+			sal_Int32 nIndex = 0;
+	
+			if ( ( Index1 >>= nIndex ) != sal_True )
+			{
+				rtl::OUString message;
+				message = rtl::OUString::createFromAscii(
+					"Couldn't convert index to Int32");
+				throw  css::lang::IndexOutOfBoundsException( message,
+					css::uno::Reference< css::uno::XInterface >() );
+			}
+			return 	getItemByIntIndex( nIndex );
+		}
+		rtl::OUString aStringSheet;
+
+		Index1 >>= aStringSheet;
+		return getItemByStringIndex( aStringSheet );	
+	}
+	// XDefaultMethod
+	::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (css::uno::RuntimeException)
+	{
+		const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
+		return sName;
+	}
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException) = 0;	
+
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException) = 0;
+	// XElementAccess
+	virtual ::sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException)
+	{
+		return ( m_xIndexAccess->getCount() > 0 );
+	}
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ) = 0;
+	
+};
+
+typedef ::cppu::WeakImplHelper1<ov::XCollection> XCollection_InterfacesBASE;
+
+typedef ScVbaCollectionBase< XCollection_InterfacesBASE > CollImplBase1;
+// compatible with the old collections ( pre XHelperInterface base class ) ( some internal objects still use this )
+class VBAHELPER_DLLPUBLIC ScVbaCollectionBaseImpl : public CollImplBase1
+{
+public:
+	ScVbaCollectionBaseImpl( const css::uno::Reference< ov::XHelperInterface > xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : CollImplBase1( xParent, xContext, xIndexAccess){}
+
+};
+
+template <typename Ifc> // where Ifc must implement XCollectionTest
+class VBAHELPER_DLLPUBLIC CollTestImplHelper :  public ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc > >
+{
+typedef ScVbaCollectionBase< ::cppu::WeakImplHelper1< Ifc >  > ImplBase1;
+
+public:
+	CollTestImplHelper( const css::uno::Reference< ov::XHelperInterface >& xParent, const css::uno::Reference< css::uno::XComponentContext >& xContext,  const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException ) : ImplBase1( xParent, xContext, xIndexAccess ) {}
+};
+
+
+#endif //SC_VBA_COLLECTION_IMPL_HXX
Index: vbahelper/inc/vbahelper/helperdecl.hxx
===================================================================
--- vbahelper/inc/vbahelper/helperdecl.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/helperdecl.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: helperdecl.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef OOVBAAPI_SERV_DECL
+#define OOVBAAPI_SERV_DECL
+#include <comphelper/servicedecl.hxx>
+#include <ooo/vba/XHelperInterface.hpp>
+
+namespace comphelper {
+namespace service_decl {
+template <typename ImplT_, typename WithArgsT = with_args<false> >
+struct vba_service_class_ : public serviceimpl_base< detail::OwnServiceImpl<ImplT_>, WithArgsT >
+{
+    typedef serviceimpl_base< detail::OwnServiceImpl<ImplT_>, WithArgsT > baseT;
+    /** Default ctor.  Implementation class without args, expecting
+        component context as single argument.
+    */
+    vba_service_class_() : baseT() {}
+    template <typename PostProcessFuncT>
+    /** Ctor to pass a post processing function/functor.
+        
+        @tpl PostProcessDefaultT let your compiler deduce this
+        @param postProcessFunc function/functor that gets the yet unacquired
+                               ImplT_ pointer returning a
+                               uno::Reference<uno::XInterface>
+    */
+    explicit vba_service_class_( PostProcessFuncT const& postProcessFunc ) : baseT( postProcessFunc ) {}
+};
+
+} // namespace service_decl
+} // namespace comphelper
+#endif
Index: vbahelper/inc/vbahelper/vbahelper.hxx
===================================================================
--- vbahelper/inc/vbahelper/vbahelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/inc/vbahelper/vbahelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,231 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vbahelper.hxx,v $
+ * $Revision: 1.5.32.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef OOVBAAPI_VBA_HELPER_HXX
+#define OOVBAAPI_VBA_HELPER_HXX
+
+#include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/beans/XIntrospectionAccess.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/script/BasicErrorException.hpp>
+#include <com/sun/star/script/XTypeConverter.hpp>
+#include <com/sun/star/lang/IllegalArgumentException.hpp>
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/XDevice.hpp>
+#include <basic/sberrors.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/frame/XModel.hpp>
+#include <sfx2/dispatch.hxx>
+//#include <ooo/vba/msforms/XShape.hpp>
+#include <vcl/pointr.hxx>
+#define VBAHELPER_DLLIMPLEMENTATION
+#include <vbahelper/vbadllapi.h>
+#include <memory>
+namespace css = ::com::sun::star;
+
+namespace ooo 
+{
+	namespace vba 
+	{
+		template < class T > 
+		css::uno::Reference< T > getXSomethingFromArgs( css::uno::Sequence< css::uno::Any > const & args, sal_Int32 nPos, bool bCanBeNull = true ) throw (css::lang::IllegalArgumentException)
+		{
+			if ( args.getLength() < ( nPos + 1) )
+				throw css::lang::IllegalArgumentException();
+			css::uno::Reference< T > aSomething( args[ nPos ], css::uno::UNO_QUERY );
+			if ( !bCanBeNull && !aSomething.is() )
+				throw css::lang::IllegalArgumentException();
+			return aSomething;
+		}
+        VBAHELPER_DLLPUBLIC SfxObjectShell* getSfxObjShell( const css::uno::Reference< css::frame::XModel >& xModel ) throw ( css::uno::RuntimeException);
+        VBAHELPER_DLLPUBLIC css::uno::Reference< css::uno::XInterface > createVBAUnoAPIService( SfxObjectShell* pShell,  const sal_Char* _pAsciiName ) throw (css::uno::RuntimeException);
+        VBAHELPER_DLLPUBLIC css::uno::Reference< css::uno::XInterface > createVBAUnoAPIServiceWithArgs( SfxObjectShell* pShell,  const sal_Char* _pAsciiName, const css::uno::Sequence< css::uno::Any >& aArgs ) throw (css::uno::RuntimeException);
+        css::uno::Reference< css::frame::XModel > getCurrentDoc( const rtl::OUString& sKey ) throw (css::uno::RuntimeException);
+        VBAHELPER_DLLPUBLIC css::uno::Reference< css::frame::XModel > getCurrentExcelDoc( const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException);
+        VBAHELPER_DLLPUBLIC css::uno::Reference< css::frame::XModel > getCurrentWordDoc( const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException);
+
+		VBAHELPER_DLLPUBLIC css::uno::Reference< css::beans::XIntrospectionAccess > getIntrospectionAccess( const css::uno::Any& aObject ) throw (css::uno::RuntimeException);
+		VBAHELPER_DLLPUBLIC css::uno::Reference< css::script::XTypeConverter > getTypeConverter( const css::uno::Reference< css::uno::XComponentContext >& xContext ) throw (css::uno::RuntimeException);
+
+		VBAHELPER_DLLPUBLIC void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl) ;
+		VBAHELPER_DLLPUBLIC void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl, css::uno::Sequence< css::beans::PropertyValue >& sProps ) ;
+		VBAHELPER_DLLPUBLIC void dispatchExecute(SfxViewShell* pView, USHORT nSlot, SfxCallMode nCall = SFX_CALLMODE_SYNCHRON );
+		VBAHELPER_DLLPUBLIC sal_Int32 OORGBToXLRGB( sal_Int32 );
+		VBAHELPER_DLLPUBLIC sal_Int32 XLRGBToOORGB( sal_Int32 );
+		VBAHELPER_DLLPUBLIC css::uno::Any OORGBToXLRGB( const css::uno::Any& );
+		VBAHELPER_DLLPUBLIC css::uno::Any XLRGBToOORGB( const css::uno::Any& );
+		// provide a NULL object that can be passed as variant so that 
+		// the object when passed to IsNull will return true. aNULL 
+		// contains an empty object reference
+		VBAHELPER_DLLPUBLIC const css::uno::Any& aNULL();
+		VBAHELPER_DLLPUBLIC void PrintOutHelper( SfxViewShell* pViewShell, const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName, sal_Bool bSelection  );
+		VBAHELPER_DLLPUBLIC void PrintPreviewHelper( const css::uno::Any& EnableChanges,  SfxViewShell* );
+
+		VBAHELPER_DLLPUBLIC rtl::OUString getAnyAsString( const css::uno::Any& pvargItem ) throw ( css::uno::RuntimeException );
+		VBAHELPER_DLLPUBLIC rtl::OUString VBAToRegexp(const rtl::OUString &rIn, bool bForLike = false); // needs to be in an uno service ( already this code is duplicated in basic )
+	    VBAHELPER_DLLPUBLIC double getPixelTo100thMillimeterConversionFactor( css::uno::Reference< css::awt::XDevice >& xDevice, sal_Bool bVertical);
+    	VBAHELPER_DLLPUBLIC double PointsToPixels( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical);
+	    VBAHELPER_DLLPUBLIC double PixelsToPoints( css::uno::Reference< css::awt::XDevice >& xDevice, double fPoints, sal_Bool bVertical);
+        VBAHELPER_DLLPUBLIC sal_Int32 getPointerStyle( const css::uno::Reference< css::frame::XModel >& );
+        VBAHELPER_DLLPUBLIC void setCursorHelper( const css::uno::Reference< css::frame::XModel >& xModel, const Pointer& rPointer, sal_Bool bOverWrite );
+        VBAHELPER_DLLPUBLIC void setDefaultPropByIntrospection( const css::uno::Any& aObj, const css::uno::Any& aValue  ) throw ( css::uno::RuntimeException );
+        VBAHELPER_DLLPUBLIC css::uno::Any getPropertyValue( const css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName );
+        VBAHELPER_DLLPUBLIC sal_Bool setPropertyValue( css::uno::Sequence< css::beans::PropertyValue >& aProp, const rtl::OUString& aName, const css::uno::Any& aValue );
+
+class VBAHELPER_DLLPUBLIC Millimeter
+{
+//Factor to translate between points and hundredths of millimeters:
+private:
+	static const double factor;
+    
+	double m_nMillimeter;
+
+public:
+	Millimeter();
+    
+	Millimeter(double mm);
+    
+	void set(double mm);
+	void setInPoints(double points) ;
+	void setInHundredthsOfOneMillimeter(double hmm);
+	double get();
+	double getInHundredthsOfOneMillimeter();
+	double getInPoints();
+	static sal_Int32 getInHundredthsOfOneMillimeter(double points);
+	static double getInPoints(int _hmm);
+};
+
+class VBAHELPER_DLLPUBLIC AbstractGeometryAttributes // probably should replace the ShapeHelper below
+{
+public:
+    virtual ~AbstractGeometryAttributes() {}
+    virtual double getLeft() = 0;
+    virtual void setLeft( double ) = 0;
+    virtual double getTop() = 0;
+    virtual void setTop( double ) = 0;
+    virtual double getHeight() = 0;
+    virtual void setHeight( double ) = 0;
+    virtual double getWidth() = 0;
+    virtual void setWidth( double ) = 0;
+};
+
+namespace msforms {
+    class XShape;
+}
+
+class VBAHELPER_DLLPUBLIC ShapeHelper
+{
+protected:
+	css::uno::Reference< css::drawing::XShape > xShape;
+public:
+	ShapeHelper( const css::uno::Reference< css::drawing::XShape >& _xShape) throw (css::script::BasicErrorException );
+    
+	double getHeight();
+
+    	void setHeight(double _fheight) throw ( css::script::BasicErrorException );
+    
+	double getWidth();
+
+	void setWidth(double _fWidth) throw ( css::script::BasicErrorException );
+    
+	double getLeft();
+    
+	void setLeft(double _fLeft);
+
+	double getTop();
+    
+	void setTop(double _fTop);
+};
+
+class VBAHELPER_DLLPUBLIC ConcreteXShapeGeometryAttributes : public AbstractGeometryAttributes
+{
+    std::auto_ptr< ShapeHelper > m_pShapeHelper;
+public:
+    ConcreteXShapeGeometryAttributes( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::drawing::XShape >& xShape );
+    virtual double getLeft();
+    virtual void setLeft( double nLeft );
+    virtual double getTop();
+    virtual void setTop( double nTop );
+    virtual double getHeight();
+    virtual void setHeight( double nHeight );
+    virtual double getWidth();
+    virtual void setWidth( double nWidth);
+};
+#define VBA_LEFT "PositionX"
+#define VBA_TOP "PositionY"
+class VBAHELPER_DLLPUBLIC UserFormGeometryHelper : public AbstractGeometryAttributes
+{
+
+    css::uno::Reference< css::beans::XPropertySet > mxModel;
+public:
+    UserFormGeometryHelper( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::awt::XControl >& xControl );
+    virtual double getLeft();
+    virtual void setLeft( double nLeft );
+    virtual double getTop();
+    virtual void setTop( double nTop );
+    virtual double getHeight();
+    virtual void setHeight( double nHeight );
+    virtual double getWidth();
+    virtual void setWidth( double nWidth);
+};
+
+class VBAHELPER_DLLPUBLIC ContainerUtilities
+{
+
+public: 
+	static rtl::OUString getUniqueName( const css::uno::Sequence< ::rtl::OUString >&  _slist, const rtl::OUString& _sElementName, const ::rtl::OUString& _sSuffixSeparator);
+	static rtl::OUString getUniqueName( const css::uno::Sequence< rtl::OUString >& _slist, const rtl::OUString _sElementName, const rtl::OUString& _sSuffixSeparator, sal_Int32 _nStartSuffix );
+
+	static sal_Int32 FieldInList( const css::uno::Sequence< rtl::OUString >& SearchList, const rtl::OUString& SearchString );
+};
+
+// really just a a place holder to ease the porting pain
+class VBAHELPER_DLLPUBLIC DebugHelper
+{
+public:
+	static void exception( const rtl::OUString&  DetailedMessage, const css::uno::Exception& ex,  int err, const rtl::OUString& /*additionalArgument*/ ) throw( css::script::BasicErrorException );
+
+	static void exception( int err,  const rtl::OUString& additionalArgument ) throw( css::script::BasicErrorException );
+
+	static void exception( css::uno::Exception& ex ) throw( css::script::BasicErrorException );
+};
+	} // openoffice
+} // org
+
+namespace ov = ooo::vba;
+
+#ifdef DEBUG
+#  define SC_VBA_FIXME(a) OSL_TRACE( a )
+#  define SC_VBA_STUB() SC_VBA_FIXME(( "%s - stubbed\n", __FUNCTION__ ))
+#else
+#  define SC_VBA_FIXME(a)
+#  define SC_VBA_STUB()
+#endif
+
+#endif
Index: vbahelper/prj/build.lst
===================================================================
--- vbahelper/prj/build.lst	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/prj/build.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,6 @@
+vba	vbahelper	:	oovbaapi basic sfx2 svx cppuhelper vcl comphelper svtools tools sal NULL
+vba	vbahelper									usr1	-	all	  vba_mkout NULL
+#vba	vbahelper\inc								nmake	-	all	vba_inc NULL
+vba	vbahelper\source\vbahelper                        nmake	-	all	vba_vbahelper NULL
+vba	vbahelper\source\msforms                        nmake	-	all	vba_msforms NULL
+vba	vbahelper\util								nmake	-	all	vba_util vba_vbahelper vba_msforms NULL
Index: vbahelper/prj/d.lst
===================================================================
--- vbahelper/prj/d.lst	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/prj/d.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,27 @@
+..\%__SRC%\lib\lib*.so %_DEST%\lib%_EXT%
+..\%__SRC%\lib\lib*.dylib %_DEST%\lib%_EXT%
+..\%__SRC%\lib\ivbahelper.lib %_DEST%\lib%_EXT%\vbahelper.lib
+..\%__SRC%\lib\vbahelp*.* %_DEST%\lib%_EXT%\vba*.*
+..\%__SRC%\bin\vbahelper*.* %_DEST%\bin%_EXT%\vbahelper*.*
+..\%__SRC%\bin\msforms*.* %_DEST%\bin%_EXT%\msforms*.*
+
+mkdir: %_DEST%\inc%_EXT%\basic
+..\inc\vbahelper\vbacollectionimpl.hxx %_DEST%\inc%_EXT%\vbahelper\vbacollectionimpl.hxx
+..\inc\vbahelper\vbahelper.hxx %_DEST%\inc%_EXT%\vbahelper\vbahelper.hxx
+..\inc\vbahelper\helperdecl.hxx %_DEST%\inc%_EXT%\vbahelper\helperdecl.hxx
+..\inc\vbahelper\vbahelperinterface.hxx %_DEST%\inc%_EXT%\vbahelper\vbahelperinterface.hxx
+..\inc\vbahelper\vbaapplicationbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbaapplicationbase.hxx
+..\inc\vbahelper\vbafontbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbafontbase.hxx
+..\inc\vbahelper\vbadllapi.h %_DEST%\inc%_EXT%\vbahelper\vbadllapi.h
+..\inc\vbahelper\vbawindowbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbawindowbase.hxx
+..\inc\vbahelper\vbadocumentbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbadocumentbase.hxx
+..\inc\vbahelper\vbadocumentsbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbadocumentsbase.hxx
+..\inc\vbahelper\vbapropvalue.hxx %_DEST%\inc%_EXT%\vbahelper\vbapropvalue.hxx
+..\inc\vbahelper\vbaglobalbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbaglobalbase.hxx
+..\inc\vbahelper\vbadialogbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbadialogbase.hxx
+..\inc\vbahelper\vbadialogsbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbadialogsbase.hxx
+..\inc\vbahelper\vbashape.hxx %_DEST%\inc%_EXT%\vbahelper\vbashape.hxx
+..\inc\vbahelper\vbashapes.hxx %_DEST%\inc%_EXT%\vbahelper\vbashapes.hxx
+..\inc\vbahelper\vbatextframe.hxx %_DEST%\inc%_EXT%\vbahelper\vbatextframe.hxx
+..\inc\vbahelper\vbashaperange.hxx %_DEST%\inc%_EXT%\vbahelper\vbashaperange.hxx
+..\inc\vbahelper\vbapagesetupbase.hxx %_DEST%\inc%_EXT%\vbahelper\vbapagesetupbase.hxx
Index: vbahelper/util/msforms.map
===================================================================
--- vbahelper/util/msforms.map	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/util/msforms.map	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,9 @@
+OOO_1.1 {
+	global:
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
Index: vbahelper/util/makefile.mk
===================================================================
--- vbahelper/util/makefile.mk	(.../tags/DEV300_m58)	(revision 0)
+++ vbahelper/util/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,104 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.24 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..
+
+PRJNAME=vbahelper
+TARGET=vbahelper
+
+# --- Settings ---------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+
+TARGET_HELPER=vbahelper
+
+LIB1TARGET=     $(SLB)$/$(TARGET).lib
+LIB1FILES=$(SLB)$/$(TARGET)bits.lib
+
+SHL1TARGET= $(TARGET_HELPER)$(DLLPOSTFIX)
+
+
+# dynamic libraries
+SHL1STDLIBS=       \
+		$(CPPULIB) \
+		$(COMPHELPERLIB) \
+		$(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(TOOLSLIB) \
+		$(SALLIB)\
+		$(SFXLIB)	\
+		$(SVTOOLLIB)    \
+		$(SVLLIB) \
+        $(VCLLIB) \
+		$(SVTOOLLIB)    \
+        $(TKLIB) \
+        $(SVXMSFILTERLIB) \
+
+SHL1DEPN=
+SHL1IMPLIB= i$(TARGET_HELPER)
+SHL1USE_EXPORTS=name
+SHL1LIBS=$(LIB1TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+DEF1NAME=$(SHL1TARGET)
+DEFLIB1NAME=$(TARGET)
+
+TARGET_MSFORMS=msforms
+SHL2TARGET=$(TARGET_MSFORMS)$(DLLPOSTFIX).uno
+SHL2IMPLIB=     i$(TARGET_MSFORMS)
+
+SHL2VERSIONMAP=$(TARGET_MSFORMS).map
+SHL2DEF=$(MISC)$/$(SHL2TARGET).def
+DEF2NAME=$(SHL2TARGET)
+SHL2STDLIBS= \
+                $(CPPUHELPERLIB) \
+                $(CPPULIB) \
+                $(COMPHELPERLIB) \
+                $(SVLIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)\
+		$(VBAHELPERLIB) \
+                $(SFXLIB)       \
+                $(SVXLIB)       \
+                $(SVTOOLLIB)    \
+                $(SVLLIB) \
+        $(VCLLIB) \
+        $(TKLIB) \
+                $(BASICLIB) \
+
+SHL2DEPN=$(SHL1TARGETN)
+SHL2LIBS=$(SLB)$/$(TARGET_MSFORMS).lib
+
+# --- Targets -----------------------------------------------------------
+
+.INCLUDE :  target.mk
Index: officecfg/registry/schema/org/openoffice/Office/Calc.xcs
===================================================================
--- officecfg/registry/schema/org/openoffice/Office/Calc.xcs	(.../tags/DEV300_m58)	(revision 277097)
+++ officecfg/registry/schema/org/openoffice/Office/Calc.xcs	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1223,7 +1223,7 @@
               <desc>Indicates whether VBA macros are imported without comments to be executable.</desc>
               <label>Executable code</label>
             </info>
-            <value>false</value>
+            <value>true</value>
           </prop>
           <prop oor:name="Save" oor:type="xs:boolean">
 						<!-- OldPath: Filter/MS_Office/Basic/Excel -->
Index: officecfg/registry/schema/org/openoffice/Office/Writer.xcs
===================================================================
--- officecfg/registry/schema/org/openoffice/Office/Writer.xcs	(.../tags/DEV300_m58)	(revision 277097)
+++ officecfg/registry/schema/org/openoffice/Office/Writer.xcs	(.../cws/vbasupportdev300)	(revision 277097)
@@ -749,6 +749,17 @@
 		</group>
 	</templates>
 	<component>
+        <group oor:name="GlobalTemplateList">
+            <info>
+               <desc>Contains the most recently opened documents.</desc>
+            </info>
+            <prop oor:name="Paths" oor:type="oor:string-list">
+                <info>
+                    <desc>Lists the file global templates loaded when importing writer documents.</desc>
+                </info>
+                <value oor:separator=";"></value> 
+            </prop>
+        </group>
         <group oor:name="MailMergeWizard">
             <info>
                 <desc>Settings of the mail merge wizard.</desc>
Index: officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu
===================================================================
--- officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu	(.../tags/DEV300_m58)	(revision 277097)
+++ officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1189,6 +1189,12 @@
 					<value xml:lang="en-US">~Remove Filter</value>
 				</prop>
 			</node>
+                        <node oor:name=".uno:DataForm" oor:op="replace">
+                                <prop oor:name="Label" oor:type="xs:string">
+                                        <value xml:lang="de">D~atenForm...</value>
+                                        <value xml:lang="en-US">D~ataForm...</value>
+                                </prop>
+                        </node>
 			<node oor:name=".uno:DataSubTotals" oor:op="replace">
 				<prop oor:name="Label" oor:type="xs:string">
 					<value xml:lang="en-US">Sub~totals...</value>
Index: svx/source/cui/cfg.cxx
===================================================================
--- svx/source/cui/cfg.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/cui/cfg.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -5724,7 +5724,7 @@
 				if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
 				{
 					BitmapEx aBitmap = aImage.GetBitmapEx();
-					BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
 					aImage = Image( aBitmapex);
 				}
 				aTbSymbol.InsertItem( nId,aImage, aURL, 0, 0 ); //modify
@@ -5888,7 +5888,7 @@
                 if ( bOK && ((aSize.Width != m_nExpectedSize) || (aSize.Height != m_nExpectedSize)) )
 				{
 					BitmapEx aBitmap = aImage.GetBitmapEx();
-					BitmapEx aBitmapex = AutoScaleBitmap(aBitmap, m_nExpectedSize);
+                    BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, m_nExpectedSize);
 					aImage = Image( aBitmapex);
 				}
 				if ( bOK && !!aImage )
Index: svx/source/msfilter/makefile.mk
===================================================================
--- svx/source/msfilter/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -54,7 +54,9 @@
 	$(SLO)$/svxmsbas.obj	\
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/mscodec.obj		\
-	$(SLO)$/msfiltertracer.obj
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
+	$(SLO)$/msvbahelper.obj\
 
 LIB2TARGET= $(SLB)$/$(TARGET)-core.lib
 LIB2OBJFILES= \
@@ -70,7 +72,9 @@
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msoleexp.obj	\
 	$(SLO)$/svxmsbas.obj	\
-	$(SLO)$/msfiltertracer.obj
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
+	$(SLO)$/msvbahelper.obj\
 
 .INCLUDE :  target.mk
 
Index: svx/source/msfilter/msoleexp.cxx
===================================================================
--- svx/source/msfilter/msoleexp.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/msoleexp.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -231,7 +231,12 @@
             aSeq[1].Name = ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "FilterName" ) );
             aSeq[1].Value <<= ::rtl::OUString( pExpFilter->GetName() );
             uno::Reference < frame::XStorable > xStor( rObj->getComponent(), uno::UNO_QUERY );
+        try
+        {
             xStor->storeToURL( ::rtl::OUString::createFromAscii( "private:stream" ), aSeq );
+        }
+        catch( uno::Exception& ) {} // #TODO really handle exceptions - interactionalhandler etc. ? 
+        
             SotStorageRef xOLEStor = new SotStorage( pStream, TRUE );
             xOLEStor->CopyTo( &rDestStg );
             rDestStg.Commit();
Index: svx/source/msfilter/eschesdo.cxx
===================================================================
--- svx/source/msfilter/eschesdo.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/eschesdo.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -251,6 +251,19 @@
         // #i51348# shape name
         if( aShapeName.Len() > 0 )
             aPropOpt.AddOpt( ESCHER_Prop_wzName, aShapeName );
+        if ( InteractionInfo* pInteraction = mpHostAppData->GetInteractionInfo() )
+		{
+			const std::auto_ptr< SvMemoryStream >& pMemStrm = pInteraction->getHyperlinkRecord();
+			if ( pMemStrm.get() )
+			{
+				pMemStrm->ObjectOwnsMemory( FALSE );
+				sal_uInt8* pBuf = (sal_uInt8*) pMemStrm->GetData();
+				sal_uInt32 nSize = pMemStrm->Seek( STREAM_SEEK_TO_END );
+				aPropOpt.AddOpt( ESCHER_Prop_pihlShape, sal_False, nSize, pBuf, nSize );;       
+			}
+			if ( pInteraction->hasInteraction() )
+				aPropOpt.AddOpt( ESCHER_Prop_fPrint, 0x00080008 );       
+        }
 
 		if ( rObj.GetType().EqualsAscii( "drawing.Custom" ) )
 		{
Index: svx/source/msfilter/mstoolbar.cxx
===================================================================
--- svx/source/msfilter/mstoolbar.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ svx/source/msfilter/mstoolbar.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,817 @@
+#include <svx/mstoolbar.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <com/sun/star/ui/ItemStyle.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <fstream>
+#include <vcl/graph.hxx>
+#include <vcl/bitmapex.hxx>
+#include <vcl/image.hxx>
+#include <map>
+#include <sfx2/objsh.hxx>
+#include <basic/basmgr.hxx>
+#include <svtools/filterutils.hxx>
+#include <boost/scoped_array.hpp>
+#include <svx/msvbahelper.hxx>
+#include <svtools/miscopt.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/window.hxx>
+
+using namespace com::sun::star;
+
+int TBBase::nIndent = 0;
+
+void CustomToolBarImportHelper::showToolbar( const rtl::OUString& rName )
+{
+    try
+    {
+        uno::Reference< frame::XController > xCntrller( mrDocSh.GetModel()->getCurrentController(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xCntrller->getFrame(), uno::UNO_QUERY_THROW );
+        uno::Reference< frame::XLayoutManager > xLayoutMgr( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("LayoutManager") ) ), uno::UNO_QUERY_THROW );
+        xLayoutMgr->showElement( rName );
+    }
+    catch( uno::Exception& ) {}
+}
+
+void CustomToolBarImportHelper::ScaleImage( uno::Reference< graphic::XGraphic >& xGraphic, long nNewSize )
+{
+    Graphic aGraphic( xGraphic );
+    Size aSize = aGraphic.GetSizePixel();
+    if ( aSize.Height() && ( aSize.Height() == aSize.Width() ) )
+    {
+        Image aImage( xGraphic );
+        if ( aSize.Height() != nNewSize )
+        {
+            BitmapEx aBitmap = aImage.GetBitmapEx();
+            BitmapEx aBitmapex = BitmapEx::AutoScaleBitmap(aBitmap, nNewSize );
+            aImage = Image( aBitmapex);
+            xGraphic = aImage.GetXGraphic();
+        }
+    } 
+}
+
+void CustomToolBarImportHelper::applyIcons()
+{
+    for ( std::vector< iconcontrolitem >::iterator it = iconcommands.begin(); it != iconcommands.end(); ++it )
+    {
+        uno::Sequence< rtl::OUString > commands(1);
+        commands[ 0 ] = it->sCommand;
+        uno::Sequence< uno::Reference< graphic::XGraphic > > images(1);
+        images[ 0 ] = it->image;
+       
+        OSL_TRACE("About to applyIcons for command %s, have image ? %s", rtl::OUStringToOString( commands[ 0 ], RTL_TEXTENCODING_UTF8 ).getStr(), images[ 0 ].is() ? "yes" : "no" );
+        uno::Reference< ui::XImageManager > xImageManager( getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        sal_uInt16 nColor = ui::ImageType::COLOR_NORMAL; 
+
+        Window* topwin = Application::GetActiveTopWindow();
+	if ( topwin != NULL && topwin->GetDisplayBackground().GetColor().IsDark() )
+            nColor = css::ui::ImageType::COLOR_HIGHCONTRAST;
+
+        ScaleImage( images[ 0 ], 16 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_DEFAULT | nColor,  commands, images );
+        ScaleImage( images[ 0 ], 26 );
+        xImageManager->replaceImages( ui::ImageType::SIZE_LARGE | nColor,  commands, images );
+    }
+}
+
+void CustomToolBarImportHelper::addIcon( const uno::Reference< graphic::XGraphic >& xImage, const rtl::OUString& sString )
+{
+    iconcontrolitem item;
+    item.sCommand = sString;
+    item.image = xImage;
+    iconcommands.push_back( item );
+}
+
+CustomToolBarImportHelper::CustomToolBarImportHelper( SfxObjectShell& rDocShell,  const css::uno::Reference< css::ui::XUIConfigurationManager>& rxAppCfgMgr ) : mrDocSh( rDocShell ) 
+{
+    m_xCfgSupp.set( mrDocSh.GetModel(), uno::UNO_QUERY_THROW );
+    m_xAppCfgMgr.set( rxAppCfgMgr, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getCfgManager()
+{
+    return m_xCfgSupp->getUIConfigurationManager();
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getAppCfgManager()
+{
+    return m_xAppCfgMgr;
+}
+
+uno::Any 
+CustomToolBarImportHelper::createCommandFromMacro( const rtl::OUString& sCmd )
+{
+//"vnd.sun.star.script:Standard.Module1.Main?language=Basic&location=document"    
+    static rtl::OUString scheme = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document");
+    // create script url
+    rtl::OUString scriptURL = scheme + sCmd + part2;
+    return uno::makeAny( scriptURL );
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOCommandToOOCommand( sal_Int16 msoCmd )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOCommandToOOCommand( msoCmd );
+    return result;
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOTCIDToOOCommand( sal_Int16 msoTCID )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOTCIDToOOCommand( msoTCID );
+    return result;
+}
+
+bool
+CustomToolBarImportHelper::createMenu( const rtl::OUString& rName, const uno::Reference< container::XIndexAccess >& xMenuDesc, bool bPersist )
+{
+    bool bRes = true;
+    try
+    {
+        uno::Reference< ui::XUIConfigurationManager > xCfgManager( getCfgManager() );
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        sMenuBar += rName;
+        uno::Reference< container::XIndexContainer > xPopup( xCfgManager->createSettings(), uno::UNO_QUERY_THROW );
+        uno::Reference< beans::XPropertySet > xProps( xPopup, uno::UNO_QUERY_THROW ); 
+        // set name for menubar
+        xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( rName ) );
+        if ( xPopup.is() )
+        {
+            uno::Sequence< beans::PropertyValue > aPopupMenu( 4 );
+            aPopupMenu[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            aPopupMenu[0].Value = uno::makeAny( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("vnd.openoffice.org:") ) + rName );
+            aPopupMenu[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+            aPopupMenu[1].Value <<= rName;
+            aPopupMenu[2].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ItemDescriptorContainer") );
+            aPopupMenu[2].Value = uno::makeAny( xMenuDesc );
+            aPopupMenu[3].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type" ) );
+            aPopupMenu[3].Value <<= sal_Int32( 0 );
+            
+            xPopup->insertByIndex( xPopup->getCount(), uno::makeAny( aPopupMenu ) );
+            if ( bPersist )
+            {
+                xCfgManager->insertSettings( sMenuBar, uno::Reference< container::XIndexAccess >( xPopup, uno::UNO_QUERY ) );
+                uno::Reference< ui::XUIConfigurationPersistence > xPersistence( xCfgManager, uno::UNO_QUERY_THROW );
+                xPersistence->store();
+            }
+        }
+    }
+    catch( uno::Exception& )
+    {
+        bRes = false;
+    }
+    return bRes;
+}
+
+void
+TBBase::indent_printf( FILE* fp, const char* format, ... )
+{
+   va_list ap;
+   va_start ( ap, format );
+
+   // indent nIndent spaces
+   for ( int i=0; i<nIndent; ++i)
+      fprintf(fp," ");
+   // append the rest of the message
+   vfprintf( fp, format, ap );
+   va_end( ap );
+}
+
+rtl::OUString TBBase::readUnicodeString( SvStream* pS, sal_Int32 nChars )
+{
+    sal_Int32 nBufSize = nChars * 2;
+    boost::scoped_array< sal_uInt8 > pArray( new sal_uInt8[ nBufSize ] );
+    pS->Read( pArray.get(), nBufSize );
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray(  reinterpret_cast< const char* >( pArray.get() ), nBufSize );
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+}
+
+bool TBCHeader::Read( SvStream* pS )
+{
+    OSL_TRACE("TBCHeader::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width.reset( new sal_uInt16 );
+        height.reset( new sal_uInt16 );
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCHeader -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  bFlagsTCR 0x%x\n", bFlagsTCR );
+    indent_printf(fp,"  tct 0x%x\n", tct );
+    indent_printf(fp,"  tcid 0x%x\n", tcid );
+    indent_printf(fp,"  tbct 0x%x\n", static_cast< unsigned int >( tbct ));
+    indent_printf(fp,"  bPriority 0x%x\n", bPriority );
+    if ( width.get() )
+        indent_printf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height.get() )
+        indent_printf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+TBCData::TBCData( const TBCHeader& Header ) : rHeader( Header )
+{
+}
+
+bool TBCData::Read(SvStream *pS)
+{
+    OSL_TRACE("TBCData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    switch ( rHeader.getTct() )
+    {
+        case 0x01: // (Button control)
+        case 0x10: // (ExpandingGrid control)
+            controlSpecificInfo.reset( new TBCBSpecific() );
+            break;
+        case 0x0A: // (Popup control)
+        case 0x0C: // (ButtonPopup control)
+        case 0x0D: // (SplitButtonPopup control)
+        case 0x0E: // (SplitButtonMRUPopup control)
+            controlSpecificInfo.reset( new TBCMenuSpecific() );
+            break;
+        case 0x02: // (Edit control)
+        case 0x04: // (ComboBox control)
+        case 0x14: // (GraphicCombo control)
+        case 0x03: // (DropDown control)
+        case 0x06: // (SplitDropDown control)
+        case 0x09: // (GraphicDropDown control)
+            controlSpecificInfo.reset( new TBCComboDropdownSpecific( rHeader ) );
+            break;
+        default:
+            break;
+    }
+    if ( controlSpecificInfo.get() )
+        return controlSpecificInfo->Read( pS );
+    //#FIXME I need to be able to handle different controlSpecificInfo types.
+    return true;
+}
+
+TBCMenuSpecific* TBCData::getMenuSpecific()
+{
+    TBCMenuSpecific* pMenu = dynamic_cast< TBCMenuSpecific* >( controlSpecificInfo.get() );
+    return pMenu;
+}
+bool TBCData::ImportToolBarControl( CustomToolBarImportHelper& helper, std::vector< css::beans::PropertyValue >& props, bool& bBeginGroup, bool bIsMenuBar )
+{
+    sal_uInt16  nStyle = 0;
+    bBeginGroup = rHeader.isBeginGroup();
+    controlGeneralInfo.ImportToolBarControlData( helper, props );
+    beans::PropertyValue aProp;
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Visible") ) ;
+    aProp.Value = uno::makeAny( rHeader.isVisible() ); // where is the visible attribute stored
+    props.push_back( aProp );
+    if ( rHeader.getTct() == 0x01
+    || rHeader.getTct() == 0x10 )
+    {
+        TBCBSpecific* pSpecificInfo = dynamic_cast< TBCBSpecific* >( controlSpecificInfo.get() );
+        if ( pSpecificInfo )
+        {
+            // if we have a icon then lets  set it for the command 
+            rtl::OUString sCommand;
+            for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it )
+            {
+                if ( it->Name.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ) )
+                    it->Value >>= sCommand;
+            }
+            if ( TBCBitMap* pIcon = pSpecificInfo->getIcon() )
+            {
+                // Without a command openoffice won't display the icon
+                if ( sCommand.getLength() )
+                {    
+                    BitmapEx aBitEx( pIcon->getBitMap() );
+                    if ( pSpecificInfo->getIconMask() )
+                         // according to the spec:
+                         // "the iconMask is white in all the areas in which the icon is
+                         // displayed as transparent and is black in all other areas."
+                         aBitEx = BitmapEx( aBitEx.GetBitmap(), pSpecificInfo->getIconMask()->getBitMap().CreateMask( Color( COL_WHITE ) ) );
+    
+                    Graphic aGraphic( aBitEx );
+                    helper.addIcon( aGraphic.GetXGraphic(), sCommand );
+                }
+            }
+            else if ( pSpecificInfo->getBtnFace() )
+            {
+               
+                rtl::OUString sBuiltInCmd = helper.MSOTCIDToOOCommand(  *pSpecificInfo->getBtnFace() );
+                if ( sBuiltInCmd.getLength() )
+                {
+                    uno::Sequence< rtl::OUString> sCmds(1);
+                    sCmds[ 0 ] = sBuiltInCmd;
+                    uno::Reference< ui::XImageManager > xImageManager( helper.getAppCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+                    // 0 = default image size
+                    uno::Sequence< uno::Reference< graphic::XGraphic > > sImages = xImageManager->getImages( 0, sCmds );
+                    if ( sImages.getLength() && sImages[0].is() )
+                        helper.addIcon( sImages[0], sCommand );
+                }
+            }
+        }
+    }
+    else if ( rHeader.getTct() == 0x0a )
+    {
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ;
+        rtl::OUString sMenuBar( RTL_CONSTASCII_USTRINGPARAM("private:resource/menubar/") );
+        
+        TBCMenuSpecific* pMenu = getMenuSpecific();
+        if ( pMenu )
+            aProp.Value = uno::makeAny( sMenuBar += pMenu->Name() ); // name of popup
+        nStyle |= ui::ItemStyle::DROP_DOWN;
+        props.push_back( aProp );
+    }
+
+    short icontext =  ( rHeader.getTbct() & 0x03 );
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Style") ) ;
+    if ( bIsMenuBar )
+    {
+        nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || icontext == 0x3 )
+            // Text And image
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    else 
+    {
+        if ( ( icontext & 0x02 ) == 0x02 )
+            nStyle |= ui::ItemStyle::TEXT;
+        if ( !icontext || ( icontext & 0x03 ) == 0x03 )
+            nStyle |= ui::ItemStyle::ICON;
+    }
+    aProp.Value <<= nStyle;
+    props.push_back( aProp );
+    return true; // just ignore
+}
+
+void TBCData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCData -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    //if ( rHeader.getTct() == 1 )
+    if ( controlSpecificInfo.get() )
+    {
+        indent_printf(fp,"  dumping controlSpecificInfo( TBCBSpecificInfo )\n");
+        controlSpecificInfo->Print( fp );
+    }
+}
+
+bool
+WString::Read( SvStream *pS )
+{
+    OSL_TRACE("WString::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCExtraInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCExtraInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    indent_printf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tbcu 0x%x\n", tbcu );
+    indent_printf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+rtl::OUString
+TBCExtraInfo::getOnAction()
+{
+    return wstrOnAction.getString();
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCGeneralInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    if ( ( bFlags & 0x1 ) && !customText.Read( pS ) )
+        return false;
+    if ( ( bFlags & 0x2 ) && ( !descriptionText.Read( pS ) ||  !tooltip.Read( pS ) ) )
+        return false;
+    if ( ( bFlags & 0x4 ) && !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCGeneralInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    indent_printf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( bFlags & 0x4 ) 
+        extraInfo.Print( fp );
+}
+
+bool 
+TBCGeneralInfo::ImportToolBarControlData( CustomToolBarImportHelper& helper, std::vector< beans::PropertyValue >& sControlData )
+{
+    if ( ( bFlags & 0x5 ) )
+    {
+        beans::PropertyValue aProp;
+        // probably access to the header would be a better test than seeing if there is an action, e.g.
+        // if ( rHeader.getTct() == 0x01 && rHeader.getTcID() == 0x01 ) // not defined, probably this is a command
+        if ( extraInfo.getOnAction().getLength() )
+        {
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            ooo::vba::VBAMacroResolvedInfo aMacroInf = ooo::vba::resolveVBAMacro( &helper.GetDocShell(), extraInfo.getOnAction(), true );
+            if ( aMacroInf.IsResolved() )
+                aProp.Value = helper.createCommandFromMacro( aMacroInf.ResolvedMacro() );
+            else
+                aProp.Value <<= rtl::OUString::createFromAscii("UnResolvedMacro[").concat( extraInfo.getOnAction() ).concat( rtl::OUString::createFromAscii("]") );
+            sControlData.push_back( aProp );
+        }
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+        aProp.Value = uno::makeAny( customText.getString().replace('&','~') );
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+        aProp.Value = uno::makeAny( ui::ItemType::DEFAULT ); 
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Tooltip") );
+        aProp.Value = uno::makeAny( tooltip.getString() ); 
+        sControlData.push_back( aProp );
+/*
+aToolbarItem(0).Name = "CommandURL" wstrOnAction
+aToolbarItem(0).Value = Command
+aToolbarItem(1).Name = "Label"      customText
+aToolbarItem(1).Value = Label
+aToolbarItem(2).Name = "Type"
+aToolbarItem(2).Value = 0
+aToolbarItem(3).Name = "Visible"
+aToolbarItem(3).Value = true        
+*/
+    }
+    return true;
+}
+
+TBCMenuSpecific::TBCMenuSpecific() : tbid( 0 )
+{
+}
+
+bool
+TBCMenuSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCMenuSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbid;
+    if ( tbid == 1 ) 
+    {
+        name.reset( new WString() );
+        return name->Read( pS );
+    }
+    return true;
+}
+
+void 
+TBCMenuSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCMenuSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  tbid 0x%x\n", static_cast< unsigned int >( tbid ) );
+    if ( tbid == 1 )
+        indent_printf( fp, "  name %s\n", rtl::OUStringToOString( name->getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+rtl::OUString TBCMenuSpecific::Name()
+{
+    rtl::OUString aName;
+    if ( name.get() )
+        aName = name->getString();
+    return aName;
+}
+TBCBSpecific::TBCBSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCBSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCBSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCBSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCBSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    indent_printf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent b;
+        indent_printf( fp, "  icon: \n");
+        icon->Print( fp ); // will dump size
+    }
+    bResult = ( iconMask.get() != NULL );
+    indent_printf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent c;
+        indent_printf( fp, "  icon mask: \n");
+        iconMask->Print( fp ); // will dump size
+    }
+    if ( iBtnFace.get() )
+    {
+        indent_printf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    }
+    bResult = ( wstrAcc.get() != NULL );
+    indent_printf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCBitMap* 
+TBCBSpecific::getIcon()
+{
+    return icon.get();
+}
+
+TBCBitMap* 
+TBCBSpecific::getIconMask()
+{
+    return iconMask.get();
+}
+
+TBCComboDropdownSpecific::TBCComboDropdownSpecific(const TBCHeader& header ) 
+{
+    if ( header.getTcID() == 0x01 )
+        data.reset( new TBCCDData() );
+}
+
+bool TBCComboDropdownSpecific::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    if ( data.get() )
+        return data->Read( pS );
+    return true;
+}
+
+void TBCComboDropdownSpecific::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCComboDropdownSpecific -- dump\n", nOffSet );
+    if ( data.get() )
+        data->Print( fp );
+    else
+        indent_printf(fp," no data " );
+}
+
+TBCCDData::TBCCDData() : cwstrItems( 0 )
+,iSel( 0 )
+,cLines( 0 )
+,dxWidth( 0 )
+{
+}
+
+TBCCDData::~TBCCDData()
+{
+}
+
+bool TBCCDData::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    *pS >> cwstrItems;
+    if ( cwstrItems )
+    {
+        for( sal_Int32 index=0; index < cwstrItems; ++index )
+        {
+            WString aString;
+            if ( !aString.Read( pS ) )
+                return false;
+            wstrList.push_back( aString );
+        } 
+    }
+    *pS >> cwstrMRU >> iSel >> cLines >> dxWidth;
+
+    return wstrEdit.Read( pS );
+}
+
+void TBCCDData::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCCDData -- dump\n", nOffSet );
+    indent_printf(fp,"  cwstrItems items in wstrList 0x%d\n", cwstrItems);
+    for ( sal_Int32 index=0; index < cwstrItems; ++index )
+    {
+        Indent b;
+        indent_printf(fp, "  wstrList[%d] %s", static_cast< int >( index ), rtl::OUStringToOString( wstrList[index].getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    indent_printf(fp,"  cwstrMRU num most recently used string 0x%d item\n", cwstrMRU);
+    indent_printf(fp,"  iSel index of selected item 0x%d item\n", iSel);
+    indent_printf(fp,"  cLines num of suggested lines to display 0x%d", cLines);
+    indent_printf(fp,"  dxWidth width in pixels 0x%d", dxWidth);
+    indent_printf(fp,"  wstrEdit %s", rtl::OUStringToOString( wstrEdit.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), size( 0 )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+}
+
+// #FIXME Const-ness
+Bitmap& 
+TBCBitMap::getBitMap()
+{
+    return mBitMap;
+}
+
+bool TBCBitMap::Read( SvStream* pS)
+{
+    OSL_TRACE("TBCBitMap::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    return mBitMap.Read( *pS, FALSE, TRUE );
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] TBCBitMap -- dump\n", nOffSet );
+    indent_printf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
+
+TB::TB() : bSignature(0x2),
+bVersion(0x1),
+cCL(0),
+ltbid( 0x1 ),
+ltbtr(0),
+cRowsDefault( 0 ),
+bFlags( 0 )
+{
+}
+
+bool TB::Read(SvStream *pS)
+{
+    OSL_TRACE("TB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    name.Read( pS );
+    return true;
+ 
+}
+
+bool TB::IsEnabled()
+{
+    return ( bFlags & 0x01 ) != 0x01;
+}
+
+bool TB::NeedsPositioning()
+{
+    return ( bFlags & 0x10 ) == 0x10;
+}
+
+void TB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TB -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%x\n", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  cCL 0x%x\n", cCL );
+    indent_printf(fp,"  ltbid 0x%x\n", ltbid );
+    indent_printf(fp,"  ltbtr 0x%x\n", ltbtr );
+    indent_printf(fp,"  cRowsDefault 0x%x\n", cRowsDefault );
+    indent_printf(fp,"  bFlags 0x%x\n", bFlags );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBVisualData::TBVisualData() : tbds(0), tbv(0), tbdsDock(0), iRow(0)
+{
+}
+
+bool TBVisualData::Read( SvStream* pS )
+{
+    OSL_TRACE("TBVisualData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbds >> tbv >> tbdsDock >> iRow;
+    rcDock.Read( pS );
+    rcFloat.Read( pS );
+    return true;
+}
+
+void SRECT::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "  left 0x%x\n", left);
+    indent_printf( fp, "  top 0x%x\n", top);
+    indent_printf( fp, "  right 0x%x\n", right);
+    indent_printf( fp, "  bottom 0x%x\n", bottom);
+}
+
+void TBVisualData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBVisualData -- dump\n", nOffSet );
+    indent_printf( fp, "  tbds 0x%x\n", tbds);
+    indent_printf( fp, "  tbv  0x%x\n", tbv);
+    indent_printf( fp, "  tbdsDoc  0x%x\n", tbdsDock);
+    indent_printf( fp, "  iRow  0x%x\n", iRow);
+    rcDock.Print( fp );
+    rcFloat.Print( fp );
+}
+
Index: svx/source/msfilter/svxmsbas.cxx
===================================================================
--- svx/source/msfilter/svxmsbas.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/svxmsbas.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -53,6 +53,7 @@
 
 #include <com/sun/star/container/XNameContainer.hpp>
 #include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
 using namespace com::sun::star::container;
 using namespace com::sun::star::script;
 using namespace com::sun::star::uno;
@@ -61,17 +62,45 @@
 
 using rtl::OUString;
 
+static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
+
+void SvxImportMSVBasic::extractAttribute( const String& rAttribute, const String& rModName )
+{
+    // format of the attribute we are interested in is
+    // Attribute VB_Control = "ControlName", intString, MSForms, ControlTypeAsString
+    // e.g.
+    // Attribute VB_Control = "CommandButton1, 201, 19, MSForms, CommandButton"
+    String sControlAttribute( RTL_CONSTASCII_USTRINGPARAM("Attribute VB_Control = \"") );
+    if ( rAttribute.Search( sControlAttribute ) !=  STRING_NOTFOUND )
+    {
+        String sRest = rAttribute.Copy( sControlAttribute.Len() );
+        xub_StrLen nPos = 0; 
+        String sCntrlName = sRest.GetToken( 0, ',', nPos );
+        
+        sal_Int32 nCntrlId = sRest.GetToken( 0, ',', nPos).ToInt32();
+        m_ModuleNameToObjIdHash[ rModName ][ nCntrlId ] =  sCntrlName;
+    }
+}
 int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
 {
+    std::vector< String > codeNames;
+    return Import(  rStorageName, rSubStorageName, codeNames, bAsComment, bStripped );
+}
+int SvxImportMSVBasic::Import( const String& rStorageName,
+								const String &rSubStorageName,
+								const std::vector< String >& codeNames,
+								BOOL bAsComment, BOOL bStripped )
+{
+        msProjectName = rtl::OUString();
 	int nRet = 0;
-	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName,
+	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName, codeNames, 
 									bAsComment, bStripped ))
 		nRet |= 1;
 
     if (bImport)
-        ImportForms_Impl(rStorageName, rSubStorageName);
+        ImportForms_Impl(rStorageName, rSubStorageName, !bAsComment);
 
 	if( bCopy && CopyStorage_Impl( rStorageName, rSubStorageName ))
 		nRet |= 2;
@@ -80,9 +109,44 @@
 }
 
 bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
-    const String& rSubStorageName)
+    const String& rSubStorageName, BOOL bVBAMode )
 {
-    SvStorageRef xVBAStg(xRoot->OpenSotStorage(rStorageName,
+    BOOL bRet = FALSE;
+    // #FIXME VBA_Impl ( or some other new class ) should handle both userforms
+    // and code 
+	VBA_Impl aVBA( *xRoot, TRUE );
+    // This call is a waste we read the source ( again ) only to get the refereneces
+    // *AGAIN*, we really need to rewrite all of this
+    aVBA.Open( rStorageName, rSubStorageName ); 
+
+    bRet = ImportForms_Impl( aVBA, rStorageName, rSubStorageName, bVBAMode );
+	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+
+	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+    {
+       rtl::OUString sFileName = *it;
+#ifndef WIN 
+#ifdef DEBUG
+       // hacky test code to read referenced projects on linux
+       sal_Int32 nPos = (*it).lastIndexOf('\\');
+       sFileName = (*it).copy( nPos + 1 );
+       sFileName =  rtl::OUString::createFromAscii("~/Documents/") + sFileName;
+#endif
+#endif
+       SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+	   VBA_Impl refVBA( *rRoot, TRUE );        
+       refVBA.Open( rStorageName, rSubStorageName );
+       // The return from ImportForms doesn't indicate and error ( it could )
+       // but also it just means no userforms were imported
+       if ( ImportForms_Impl( refVBA, rStorageName, rSubStorageName, bVBAMode ) )
+           bRet = true; // mark that at least on userform was imported
+    }
+    return bRet;
+}
+
+bool SvxImportMSVBasic::ImportForms_Impl( VBA_Impl& rVBA, const String& rStorageName, const String& rSubStorageName, BOOL bVBAMode )
+{
+    SvStorageRef xVBAStg(rVBA.GetStorage()->OpenSotStorage(rStorageName,
         STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL));
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
@@ -115,6 +179,10 @@
         DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
 
         String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
+        if (rVBA.ProjectName().getLength() )
+            aLibName = rVBA.ProjectName();
+        OSL_TRACE( "userformage lib name %s", rtl::OUStringToOString( aLibName, RTL_TEXTENCODING_UTF8 ).getStr() );
         Reference<XNameContainer> xLib;
         if (xLibContainer.is())
         {
@@ -164,7 +232,17 @@
                     xSF->createInstance(
                        OUString(RTL_CONSTASCII_USTRINGPARAM(
                            "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
-
+                // #FIXME HACK - mark the Model with the VBA mode
+                // In vba mode the imported userform uses 100th mm as units
+                // or geometry 
+                // In non vba mode MAP_APPFONT is used ( same as normal basic
+                // dialogs
+                if ( bVBAMode )
+                {
+                    Reference<XPropertySet> xDlgProps(xDialog, UNO_QUERY); 
+                    if ( xDlgProps.is() )
+                        xDlgProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("VBAForm") ), uno::makeAny( sal_True ) );
+                }
                 OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
                 aForm.pDocSh = &rDocSh;
                 sal_Bool bOk = aForm.Read(xTypes);
@@ -228,29 +306,80 @@
 
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 										const String &rSubStorageName,
+										const std::vector< String >& codeNames,
 										BOOL bAsComment, BOOL bStripped )
 {
 	BOOL bRet = FALSE;
 	VBA_Impl aVBA( *xRoot, bAsComment );
+        
 	if( aVBA.Open(rStorageName,rSubStorageName) )
 	{
+        msProjectName = aVBA.ProjectName();
+
+        if ( msProjectName.getLength() )
+            rDocSh.GetBasicManager()->SetName( msProjectName ); // set name of Project
+
+        bRet = ImportCode_Impl( aVBA, codeNames, bAsComment, bStripped );
+    	std::vector<rtl::OUString> sProjectRefs = aVBA.ProjectReferences();
+    
+    	for ( std::vector<rtl::OUString>::iterator it = sProjectRefs.begin(); it != sProjectRefs.end(); ++it )
+        {
+            rtl::OUString sFileName = *it;
+    		OSL_TRACE("referenced project %s ", rtl::OUStringToOString( sFileName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            SotStorageRef rRoot = new SotStorage( sFileName, STREAM_STD_READWRITE, STORAGE_TRANSACTED );
+    	    VBA_Impl refVBA( *rRoot, bAsComment );
+			std::vector< String > codeNamesNone;
+    	    if( refVBA.Open(rStorageName,rSubStorageName) && ImportCode_Impl( refVBA, codeNamesNone, bAsComment, bStripped ) )
+                bRet = TRUE; // mark that some code was imported
+        }
+    }
+    return bRet;
+}
+
+BOOL SvxImportMSVBasic::ImportCode_Impl( VBA_Impl& aVBA, const std::vector< String >& codeNames, BOOL bAsComment, BOOL bStripped )
+{
+        BOOL bRet = FALSE;
 		SFX_APP()->EnterBasicCall();
         Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
 		DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
 
         UINT16 nStreamCount = aVBA.GetNoStreams();
 		Reference<XNameContainer> xLib;
+
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+
         if( xLibContainer.is() && nStreamCount )
         {
-            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+            if ( aVBA.ProjectName().getLength() )
+                aLibName = aVBA.ProjectName();
+
 		    if( !xLibContainer->hasByName( aLibName ) )
 			    xLibContainer->createLibrary( aLibName );
 
             Any aLibAny = xLibContainer->getByName( aLibName );
 		    aLibAny >>= xLib;
         }
-		if( xLib.is() )
+		if( xLib.is()  )
 		{
+            Reference< container::XNameAccess > xVBACodeNamedObjectAccess;
+			if ( !bAsComment )
+            {
+                rDocSh.GetBasicManager()->GetLib( aLibName )->SetVBAEnabled( true );
+                Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                if ( xSF.is() )
+                {
+                    try
+                    {
+                        xVBACodeNamedObjectAccess.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAObjectModuleObjectProvider"))), UNO_QUERY );
+                    }
+                    catch( Exception& ) { }
+                }
+            }
+            typedef  std::hash_map< rtl::OUString, uno::Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameModuleDataHash;
+
+            NameModuleDataHash moduleData;
+
 			for( UINT16 i=0; i<nStreamCount;i++)
 			{
 				StringArray aDecompressed = aVBA.Decompress(i);
@@ -284,7 +413,7 @@
                 // is the same as the encoding for the names
                 // that are keys in the map used by GetModuleType method
                 const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+                ModType mType = aVBA.GetModuleType( sOrigVBAModName );
 
                 rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
 
@@ -292,23 +421,23 @@
 
                 switch( mType )
                 {
-                    case Class:
+                    case ModuleType::Class:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
                         break;
-                    case Form:
+                    case ModuleType::Form:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
                         break;
-                    case Document:
+                    case ModuleType::Document:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
                         break;
-                    case Normal:
+                    case ModuleType::Normal:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
                         break;
-                    case Unknown:
+                    case ModuleType::Unknown:
                         modeTypeComment = sClassRem +
                             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
                         break;
@@ -316,12 +445,11 @@
                         DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
                         break;
                 }
-				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
 				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
+				if ( !bAsComment /*&& !rDocSh.GetBasic()->isVBAEnabled() */)
 				{
 					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
+					if ( mType == ModuleType::Class )
 						modeTypeComment = modeTypeComment + sClassOption;
 
 				}
@@ -369,7 +497,12 @@
                             if( nEnd == STRING_NOTFOUND )
                                 pStr->Erase();
                             else
+                            {
+								//OSL_TRACE("Erase %s", rtl::OUStringToOString(*pStr, RTL_TEXTENCODING_UTF8 ).getStr() );
+                                String sAttr= pStr->Copy( nBegin, (nEnd-nBegin)+1);
+                                extractAttribute( sAttr, sModule );
                                 pStr->Erase(nBegin, (nEnd-nBegin)+1);
+                            }
 						}
 					}
 					if( aDecompressed.Get(j)->Len() )
@@ -383,24 +516,79 @@
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
-				{
-					aSource = modeTypeComment + aSource;
+				aSource = modeTypeComment + aSource;
 
-					Any aSourceAny;
-					aSourceAny <<= aSource;
-					if( xLib->hasByName( aModName ) )
-						xLib->replaceByName( aModName, aSourceAny );
-					else
-						xLib->insertByName( aModName, aSourceAny );
-				}                                
+				Any aSourceAny;
+                OSL_TRACE("erm %d", mType );
+                if (  !bAsComment )
+                {
+                    OSL_TRACE("vba processing  %d", mType );
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = aModName;
+                    sModuleInfo.ModuleSource = aSource;
+                    sModuleInfo.ModuleType = mType;
+                    aSourceAny <<= sModuleInfo;
+                }
+                else
+                    aSourceAny <<= aSource;
+                moduleData[ aModName ] = aSourceAny;
+            }
 
-				bRet = true;
-			}
-		}
-		SFX_APP()->LeaveBasicCall();
-	}
-	return bRet;
+            // Hack for missing codenames ( only know to happen in excel but... )
+            // only makes sense to do this if we are importing non-commented basic
+            if ( !bAsComment )
+            {
+                for ( std::vector< String >::const_iterator it =  codeNames.begin(); it != codeNames.end(); ++it )
+                {
+                    script::ModuleInfo sModuleInfo;
+                    sModuleInfo.ModuleName = *it;
+                    sModuleInfo.ModuleType = ModuleType::Document ;
+                    sModuleInfo.ModuleSource = sVBAOption;
+                    moduleData[ *it ] = uno::makeAny( sModuleInfo );
+                }
+            }
+            NameModuleDataHash::iterator it_end = moduleData.end();
+            for ( NameModuleDataHash::iterator it = moduleData.begin(); it != it_end; ++it )
+            {
+                script::ModuleInfo sModuleInfo;
+                if ( it->second >>=sModuleInfo )
+                {
+            
+                    if ( sModuleInfo.ModuleType == ModuleType::Form )
+                        // hack, the module ( imo document basic should...
+                        // know the XModel... ) but it doesn't
+                        sModuleInfo.ModuleObject.set( rDocSh.GetModel(), UNO_QUERY );
+                    //  document modules, we should be able to access
+			        //  the api objects at this time
+                    else if ( sModuleInfo.ModuleType == ModuleType::Document )
+			        {
+                        if ( xVBACodeNamedObjectAccess.is() )
+                        {
+                            try
+                            {
+                                sModuleInfo.ModuleObject.set( xVBACodeNamedObjectAccess->getByName( sModuleInfo.ModuleName ), uno::UNO_QUERY );    
+                                OSL_TRACE("** Straight up creation of Module");
+                            }
+                            catch(uno::Exception& e)
+                            {
+    						    OSL_TRACE("Failed to get documument object for %s", rtl::OUStringToOString( sModuleInfo.ModuleName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    					    }
+    				    }
+    			    }
+                    it->second = uno::makeAny( sModuleInfo );
+                }
+                     
+                if( xLib->hasByName( it->first ) )
+                    xLib->replaceByName( it->first, it->second );
+                else
+                    xLib->insertByName( it->first, it->second );
+                bRet = true;
+            }                                
+
+        }
+        if( bRet )
+            SFX_APP()->LeaveBasicCall();
+	    return bRet;
 }
 
 /* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: svx/source/msfilter/msvbasic.cxx
===================================================================
--- svx/source/msfilter/msvbasic.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/msvbasic.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -40,7 +40,802 @@
 #include <osl/endian.h>
 #include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
 #include "msvbasic.hxx"
+#include <fstream>
+#include <memory>
+#include <rtl/ustrbuf.hxx>
+#include <boost/shared_ptr.hpp>
+#include <boost/scoped_array.hpp>
+#include <boost/shared_array.hpp>
+#include <svtools/filterutils.hxx>
 
+using namespace ::com::sun::star::script;
+
+namespace MSLZSS {
+
+static unsigned int getShift( sal_uInt32 nPos )
+{
+    if (nPos <= 0x80) {
+        if (nPos <= 0x20)
+            return (nPos <= 0x10) ? 12 : 11;
+        else
+            return (nPos <= 0x40) ? 10 : 9;
+    } else {
+    if (nPos <= 0x200)
+        return (nPos <= 0x100) ? 8 : 7;
+    else if (nPos <= 0x800)
+        return (nPos <= 0x400) ? 6 : 5;
+    else
+        return 4;
+    }
+}
+
+SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL )
+{
+    SvMemoryStream *pResult;
+    const sal_Int32 nWINDOWLEN = 4096;
+    pResult = new SvMemoryStream();
+
+    sal_uInt8 nLeadbyte;
+    unsigned int nPos = 0;
+    int nLen, nDistance, nShift, nClean=1;
+    sal_uInt8 aHistory[ nWINDOWLEN ];
+
+    pStream->Seek( nOffset + 3 );
+
+    while( pStream->Read( &nLeadbyte, 1 ) )
+    {
+        for(int nMask=0x01; nMask < 0x100; nMask = nMask<<1)
+        {
+            // we see if the leadbyte has flagged this location as a dataunit
+            // which is actually a token which must be looked up in the history
+            if( nLeadbyte & nMask )
+            {
+                sal_uInt16 nToken;
+            
+                *pStream >> nToken;
+    
+                if (nClean == 0)
+                    nClean=1;
+    
+                //For some reason the division of the token into the length
+                //field of the data to be inserted, and the distance back into
+                //the history differs depending on how full the history is
+                nShift = getShift( nPos % nWINDOWLEN );
+        
+                nLen = (nToken & ((1<<nShift) - 1)) + 3;
+                nDistance = nToken >> nShift;
+        
+                //read the len of data from the history, wrapping around the
+                //nWINDOWLEN boundary if necessary data read from the history
+                //is also copied into the recent part of the history as well.
+                for (int i = 0; i < nLen; i++)
+                {
+                    unsigned char c;
+                    c = aHistory[(nPos-nDistance-1) % nWINDOWLEN];
+                    aHistory[nPos % nWINDOWLEN] = c;
+                    nPos++;
+                }
+            }
+            else
+            {
+                // special boundary case code, not guarantueed to be correct
+                // seems to work though, there is something wrong with the
+                // compression scheme (or maybe a feature) where when the data
+                // ends on a nWINDOWLEN boundary and the excess bytes in the 8
+                // dataunit list are discarded, and not interpreted as tokens
+                // or normal data.
+                if ((nPos != 0) && ((nPos % nWINDOWLEN) == 0) && (nClean))
+                {
+                    pStream->SeekRel(2);
+                    nClean=0;
+                    pResult->Write( aHistory, nWINDOWLEN );
+                    break;
+                }
+                //This is the normal case for when the data unit is not a
+                //token to be looked up, but instead some normal data which
+                //can be output, and placed in the history.
+                if (pStream->Read(&aHistory[nPos % nWINDOWLEN],1))
+                    nPos++;
+                    
+                if (nClean == 0)
+                    nClean=1;
+            }
+        }
+    }
+    if (nPos % nWINDOWLEN)
+        pResult->Write( aHistory, nPos % nWINDOWLEN );
+    pResult->Flush();
+
+    if( pCompressedLength )
+        *pCompressedLength = nPos;
+    
+    if( pLength )
+        *pLength = pResult->Tell();
+
+    pResult->Seek( 0 );
+
+    return pResult;
+} 
+
+} //MSZSS
+
+// also _VBA_PROJECT_VDPI can be used to create a usable 
+// ( and much smaller ) "_VBA_PROJECT" stream
+
+// _VBA_PROJECT Stream Version Dependant Project Information
+// _VBA_PROJECT Stream Version Dependant Project Information
+
+class _VBA_PROJECT_VDPI
+{
+public:
+sal_Int16 Reserved1;
+sal_Int16 Version;
+sal_Int8 Reserved2;
+sal_Int16 Reserved3;
+boost::scoped_array< sal_uInt8 > PerformanceCache;
+sal_Int32 PerformanceCacheSize;
+_VBA_PROJECT_VDPI(): Reserved1( 0x61CC), Version( 0xFFFF ), Reserved2(0x0), Reserved3(0x0), PerformanceCacheSize(0) {}
+~_VBA_PROJECT_VDPI()
+{
+    PerformanceCacheSize = 0;
+}
+void read(){}
+void write( SvStream* pStream )
+{
+    *pStream << Reserved1 << Version << Reserved2 << Reserved3;
+    if ( PerformanceCacheSize )
+    {
+        PerformanceCache.reset( new sal_uInt8[ PerformanceCacheSize ] );
+        pStream->Read( PerformanceCache.get(), PerformanceCacheSize );
+    }
+}
+};
+
+class ProjectSysKindRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 SysKind;
+ProjectSysKindRecord(): Id(0x1), Size(0x4), SysKind( 0x1 ) {}
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> Size >> SysKind;
+}
+};
+
+class ProjectLcidRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 Lcid;
+
+ProjectLcidRecord() : Id( 0x2 ), Size( 0x4 ), Lcid( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> Lcid;
+}
+};
+
+class ProjectLcidInvokeRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 LcidInvoke;
+public:
+ProjectLcidInvokeRecord() : Id( 0x14 ), Size( 0x4 ), LcidInvoke( 0x409 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectLcidInvokeRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> LcidInvoke;
+}
+};
+
+class ProjectCodePageRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int16 CodePage;
+public:
+// #FIXME get a better default for the CodePage
+ProjectCodePageRecord() : Id( 0x03 ), Size( 0x2 ), CodePage( 0x0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectCodePageRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> CodePage;
+}
+};
+class ProjectNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfProjectName;
+rtl::OUString ProjectName;
+ProjectNameRecord() : Id( 0x04 ), SizeOfProjectName( 0x0 ){}
+~ProjectNameRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectNameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfProjectName;
+
+    if ( SizeOfProjectName ) 
+    {
+        boost::scoped_array< sal_uInt8 > pProjectName( new sal_uInt8[ SizeOfProjectName ] );
+        OSL_TRACE("ProjectNameRecord about to read name from [0x%x], size %d", pStream->Tell(), SizeOfProjectName );
+        pStream->Read( pProjectName.get(), SizeOfProjectName );
+        ProjectName = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pProjectName.get() ), SizeOfProjectName );
+    }
+}
+};
+
+class ProjectDocStringRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfDocString;
+sal_Int16 Reserved;
+sal_Int32 SizeOfDocStringUnicode;
+rtl::OUString DocString;
+rtl::OUString DocStringUnicode; 
+
+ProjectDocStringRecord() : Id( 0x5 ), SizeOfDocString( 0x0 ), Reserved( 0x0 ), SizeOfDocStringUnicode( 0 ){}
+
+~ProjectDocStringRecord()
+{
+}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectDocStringRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfDocString;
+
+
+    boost::scoped_array< sal_uInt8 > pDocString( new sal_uInt8[ SizeOfDocString ] );
+    pStream->Read( pDocString.get(), SizeOfDocString );
+ 
+    DocString = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pDocString.get() ), SizeOfDocString );
+
+    *pStream >> Reserved >> SizeOfDocStringUnicode;
+
+    boost::scoped_array< sal_uInt8 > pDocStringUnicode( new sal_uInt8[ SizeOfDocStringUnicode ] );
+
+    pStream->Read( pDocStringUnicode.get(), SizeOfDocStringUnicode );
+    DocStringUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pDocStringUnicode.get() ), SizeOfDocString );
+
+}
+
+};
+
+class ProjectHelpFilePath
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfHelpFile1;
+boost::scoped_array< sal_uInt8 > HelpFile1;
+sal_Int16 Reserved;
+sal_Int32 SizeOfHelpFile2;
+boost::scoped_array< sal_uInt8 > HelpFile2;
+
+ProjectHelpFilePath() : Id( 0x06 ), SizeOfHelpFile1(0), Reserved(0x0), SizeOfHelpFile2(0) {}
+~ProjectHelpFilePath()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectHelpFilePath [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfHelpFile1;
+
+    HelpFile1.reset( new sal_uInt8[ SizeOfHelpFile1 ] );
+    pStream->Read( HelpFile1.get(), SizeOfHelpFile1 );
+
+    *pStream >> Reserved >> SizeOfHelpFile2;
+
+    HelpFile2.reset( new sal_uInt8[ SizeOfHelpFile2 ] );
+    pStream->Read( HelpFile2.get(), SizeOfHelpFile2 );
+  
+}
+};
+
+class ProjectHelpContextRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Size;    
+sal_Int32 HelpContext;    
+
+ProjectHelpContextRecord() : Id( 0x7 ), Size( 0x4 ), HelpContext( 0 ) {}
+void read( SvStream* pStream )
+{
+    
+   OSL_TRACE("ProjectHelpContextRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> Size >> HelpContext;
+}
+
+};
+
+class ProjectLibFlagsRecord
+{
+sal_Int16 Id;
+sal_Int32 Size;
+sal_Int32 ProjectLibFlags;
+
+public:
+ProjectLibFlagsRecord() : Id( 0x8 ), Size( 0x4 ), ProjectLibFlags( 0x0 ) {}
+void read( SvStream* pStream ) 
+{
+    OSL_TRACE("ProjectLibFlagsRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Size >> ProjectLibFlags;
+}
+};
+
+class ProjectVersionRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 Reserved;
+sal_Int32 VersionMajor;
+sal_Int16 VersionMinor;
+ProjectVersionRecord() : Id( 0x9 ), Reserved( 0x4 ), VersionMajor( 0x1 ), VersionMinor( 0 ) {}
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectVersionRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> Reserved >> VersionMajor >> VersionMinor;
+}
+};
+
+class ProjectConstantsRecord
+{
+sal_Int16 Id;
+sal_Int32 SizeOfConstants;
+boost::scoped_array< sal_uInt8 > Constants;
+sal_Int16 Reserved;
+sal_Int32 SizeOfConstantsUnicode;
+boost::scoped_array< sal_uInt8 > ConstantsUnicode;
+public:
+ProjectConstantsRecord() : Id( 0xC ), SizeOfConstants( 0 ), Constants( 0 ), Reserved( 0x3C ), SizeOfConstantsUnicode( 0 ), ConstantsUnicode(0) {}
+
+~ProjectConstantsRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("ProjectConstantsRecord [0x%x]", pStream->Tell() );
+   *pStream >> Id >> SizeOfConstants;
+    Constants.reset( new sal_uInt8[ SizeOfConstants ] );
+
+    pStream->Read( Constants.get(), SizeOfConstants );
+
+    *pStream >> Reserved;
+
+    *pStream >> SizeOfConstantsUnicode;
+
+    ConstantsUnicode.reset( new sal_uInt8[ SizeOfConstantsUnicode ] );
+    pStream->Read( ConstantsUnicode.get(), SizeOfConstantsUnicode );
+}
+
+};
+
+class ReferenceNameRecord
+{
+public:
+sal_Int16 Id;
+sal_Int32 SizeOfName;
+rtl::OUString Name;
+sal_Int16 Reserved;
+sal_Int32 SizeOfNameUnicode;
+rtl::OUString NameUnicode;
+
+ReferenceNameRecord() : Id( 0x16 ), SizeOfName( 0 ), Reserved( 0x3E ), SizeOfNameUnicode( 0 ){}
+~ReferenceNameRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    OSL_TRACE("NameRecord [0x%x]", pStream->Tell() );
+    *pStream >> Id >> SizeOfName;
+ 
+    boost::scoped_array< sal_uInt8 > pName( new sal_uInt8[ SizeOfName ] );
+
+    pStream->Read( pName.get(), SizeOfName );
+    Name = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pName.get() ), SizeOfName );
+
+    *pStream >> Reserved >> SizeOfNameUnicode;
+
+    boost::scoped_array< sal_uInt8 > pNameUnicode( new sal_uInt8[ SizeOfNameUnicode ] );
+    pStream->Read( pNameUnicode.get(), SizeOfNameUnicode );
+    NameUnicode = svt::BinFilterUtils::CreateOUStringFromUniStringArray( reinterpret_cast< const char* >( pNameUnicode.get() ), SizeOfName );
+}
+
+};
+
+// Baseclass for ReferenceControlRecord, ReferenceRegisteredRecord, ReferenceProjectRecord
+class DirDumper; 
+
+class BaseReferenceRecord 
+{
+public:
+virtual ~BaseReferenceRecord(){}
+virtual bool read( SvStream* pStream ) = 0;
+virtual void import( VBA_Impl& ){}
+};
+
+
+class ReferenceProjectRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibidAbsolute;
+    sal_uInt32 SizeOfLibidRelative; 
+    sal_uInt32 MajorVersion;
+    sal_uInt16 MinorVersion;
+    rtl::OUString AbsoluteLibid; 
+    rtl::OUString RelativeLibid; 
+
+    virtual bool read( SvStream* pStream );
+    virtual void import( VBA_Impl& rDir );
+    ReferenceProjectRecord();
+    ~ReferenceProjectRecord();
+};
+
+ReferenceProjectRecord::ReferenceProjectRecord() : Id( 0x000E ), Size( 0 ), SizeOfLibidAbsolute( 0 ), SizeOfLibidRelative( 0 ), MajorVersion( 0 ), MinorVersion( 0 )
+{ 
+}
+
+ReferenceProjectRecord::~ReferenceProjectRecord()
+{
+}
+
+bool ReferenceProjectRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceProjectRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibidAbsolute;
+
+    boost::scoped_array< sal_uInt8 > pLibidAbsolute( new sal_uInt8[ SizeOfLibidAbsolute ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidAbsolute at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidAbsolute.get(), SizeOfLibidAbsolute );
+
+    *pStream >> SizeOfLibidRelative; 
+
+    boost::scoped_array< sal_uInt8 > pLibidRelative( new sal_uInt8[ SizeOfLibidRelative ] );
+    OSL_TRACE("ReferenceProjectRecord about to read LibidRelative at [0x%x]", pStream->Tell() );
+    pStream->Read( pLibidRelative.get(), SizeOfLibidRelative );
+
+    *pStream >> MajorVersion >> MinorVersion;
+
+    // array size is ORed with SVX_MSOCX_COMPRESSED to force processing of ascii bytes ( and not 
+    // 16 bit unicode )
+    // the offset of 3 is needed to skip the ProjectReference "*\" and project kind ( 0x4[1-4] ) info.
+
+    AbsoluteLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidAbsolute.get() + 3 ), (SizeOfLibidAbsolute - 3 ) );
+    RelativeLibid = svt::BinFilterUtils::CreateOUStringFromStringArray( reinterpret_cast< const char* >( pLibidRelative.get() + 3 ), ( SizeOfLibidRelative -3 ) );
+
+    OSL_TRACE("ReferenceProjectRecord - absolute path %s", rtl::OUStringToOString( AbsoluteLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    OSL_TRACE("ReferenceProjectRecord - relative path %s", rtl::OUStringToOString( RelativeLibid, RTL_TEXTENCODING_UTF8 ).getStr() );
+    return true;
+}
+
+void ReferenceProjectRecord::import( VBA_Impl& rDir )
+{
+    rDir.AddProjectReference( AbsoluteLibid );
+}
+
+class ReferenceRegisteredRecord : public BaseReferenceRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 Size;
+    sal_uInt32 SizeOfLibid;
+    boost::scoped_array< sal_uInt8> pLibid;
+    sal_Int32 Reserved1;
+    sal_Int16 Reserved2;
+
+    ReferenceRegisteredRecord();
+    ~ReferenceRegisteredRecord();
+    bool read( SvStream* pStream );
+};
+
+ReferenceRegisteredRecord::ReferenceRegisteredRecord() : Id( 0x000D ), Size( 0 ), SizeOfLibid( 0 ), Reserved1( 0 ), Reserved2( 0 )
+{
+}
+
+ReferenceRegisteredRecord::~ReferenceRegisteredRecord()
+{
+}
+
+bool 
+ReferenceRegisteredRecord::read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRegisteredRecord [0x%x]", pStream->Tell() ); 
+    *pStream >> Id >> Size >> SizeOfLibid;
+    if ( SizeOfLibid )
+    {
+        pLibid.reset( new sal_uInt8[ SizeOfLibid] );
+        pStream->Read( pLibid.get(), SizeOfLibid );
+    }
+    *pStream >> Reserved1 >> Reserved2;
+    return true;
+}
+
+class ReferenceOriginalRecord
+{
+public:
+    sal_uInt16 Id;
+    sal_uInt32 SizeOfLibOriginal;
+    boost::scoped_array< sal_uInt8 > pLibidOriginal;
+
+
+ReferenceOriginalRecord() : Id( 0x033 ), SizeOfLibOriginal( 0 )
+{
+}
+
+~ReferenceOriginalRecord()
+{
+}
+
+void read( SvStream* pStream )
+{
+    *pStream >> Id >> SizeOfLibOriginal;
+    if ( SizeOfLibOriginal )
+    {
+        pLibidOriginal.reset( new sal_uInt8[ SizeOfLibOriginal ] );
+        pStream->Read( pLibidOriginal.get(), SizeOfLibOriginal );
+    }
+}
+
+};
+
+class ReferenceControlRecord : public BaseReferenceRecord
+{
+public:
+std::auto_ptr< ReferenceOriginalRecord > OriginalRecord;
+sal_Int16 Id;
+sal_uInt32 SizeTwiddled;
+sal_uInt32 SizeOfLibidTwiddled;
+boost::shared_array< sal_uInt8 > LibidTwiddled;
+sal_uInt32 Reserved1;
+sal_uInt16 Reserved2;
+std::auto_ptr< ReferenceNameRecord > NameRecordExtended;// Optional
+sal_uInt16 Reserved3;
+sal_uInt32 SizeExtended;
+sal_uInt32 SizeOfLibidExtended;
+boost::shared_array< sal_uInt8 > LibidExtended;
+sal_uInt32 Reserved4;
+sal_uInt16 Reserved5;
+sal_uInt8  OriginalTypeLib[ 16 ];
+sal_uInt32 Cookie;
+
+ReferenceControlRecord() : Id( 0x2F ), SizeTwiddled( 0 ), SizeOfLibidTwiddled( 0 ), Reserved1( 0 ), Reserved2( 0 ), Reserved3( 0x30 ), SizeExtended( 0 ), SizeOfLibidExtended( 0 ), Reserved4( 0 ), Reserved5( 0 ), Cookie( 0 )
+{
+    for( int i = 0; i < 16; ++i )
+        OriginalTypeLib[ i ] = 0;
+}
+
+~ReferenceControlRecord()
+{
+}
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceControlRecord [0x%x]", pStream->Tell() ); 
+    long nPos = pStream->Tell();
+
+    *pStream >> Id;
+    pStream->Seek( nPos ); // point before the peeked Id
+    if ( Id == 0x33 ) // we have an OriginalRecord
+    {
+        OriginalRecord.reset( new ReferenceOriginalRecord() );
+        OriginalRecord->read( pStream );
+    }
+    *pStream >> Id >> SizeTwiddled >> SizeOfLibidTwiddled;
+
+    if ( SizeOfLibidTwiddled )
+    {
+        LibidTwiddled.reset( new sal_uInt8[ SizeOfLibidTwiddled ] );
+        pStream->Read( LibidTwiddled.get(),  SizeOfLibidTwiddled );
+    }
+
+    *pStream >> Reserved1 >> Reserved2;
+
+    nPos = pStream->Tell();
+    // peek at the id for optional NameRecord
+    sal_Int16 nTmpId;
+    *pStream >> nTmpId;
+    if ( nTmpId == 0x30 )
+    {
+        Reserved3 = 0x30;
+    }
+    else
+    {
+        pStream->Seek( nPos );
+        NameRecordExtended.reset( new ReferenceNameRecord() );
+        NameRecordExtended->read( pStream );
+        *pStream >> Reserved3;
+    }
+    *pStream >> SizeExtended >> SizeOfLibidExtended;
+
+    if ( SizeExtended )
+    {
+        LibidExtended.reset( new sal_uInt8[ SizeOfLibidExtended ] ); 
+        pStream->Read( LibidExtended.get(), SizeOfLibidExtended );
+    } 
+
+    *pStream >> Reserved4;
+    *pStream >> Reserved5;
+
+    pStream->Read( OriginalTypeLib, sizeof( OriginalTypeLib ) );
+    *pStream >> Cookie;
+    return true;
+}
+
+};
+
+class ReferenceRecord : public BaseReferenceRecord
+{
+public:
+// NameRecord is Optional
+std::auto_ptr< ReferenceNameRecord > NameRecord;
+std::auto_ptr< BaseReferenceRecord >  aReferenceRecord;
+
+ReferenceRecord(){}
+~ReferenceRecord()
+{
+}
+
+// false return would mean failed to read Record e.g. end of array encountered
+// Note: this read routine will make sure the stream is pointing to where it was the 
+// method was called ) 
+
+bool read( SvStream* pStream )
+{
+    OSL_TRACE("ReferenceRecord [0x%x]", pStream->Tell() );
+    bool bRead = true;
+    long nStart = pStream->Tell();
+    long nPos = nStart;
+    // Peek at the ID 
+    sal_Int16 Id;
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+    if ( Id == 0x16 ) // Optional NameRecord
+    {
+        NameRecord.reset( new ReferenceNameRecord() );
+        NameRecord->read( pStream ); 
+    }
+    else if ( Id == 0x0f )
+    {
+        pStream->Seek( nStart );
+        bRead = false;
+        return bRead; // start of module, terminate read
+    }
+
+    nPos = pStream->Tell(); // mark position, peek at next Id
+    *pStream >> Id;
+    pStream->Seek( nPos ); // place back before Id
+
+    switch( Id )
+    {
+        case 0x0D:
+            aReferenceRecord.reset( new ReferenceRegisteredRecord() );
+            break; 
+        case 0x0E:
+            aReferenceRecord.reset( new ReferenceProjectRecord() );
+            break; 
+        case 0x2F:
+        case 0x33:
+            aReferenceRecord.reset( new ReferenceControlRecord() );
+            break; 
+        default:
+            bRead = false;
+            OSL_TRACE("Big fat error, unknown ID 0x%x", Id);
+            break;
+    } 
+    if ( bRead )
+        aReferenceRecord->read( pStream );
+    return bRead;
+}
+
+void import( VBA_Impl& rVBA )
+{
+    if ( aReferenceRecord.get() )
+        aReferenceRecord->import( rVBA );
+}
+
+};
+
+class DirDumper
+{
+public:
+ProjectSysKindRecord mSysKindRec;
+ProjectLcidRecord mLcidRec;
+ProjectLcidInvokeRecord mLcidInvokeRec;
+ProjectCodePageRecord mCodePageRec;
+ProjectNameRecord mProjectNameRec;
+ProjectDocStringRecord mDocStringRec;
+ProjectHelpFilePath mHelpFileRec;
+ProjectHelpContextRecord mHelpContextRec;
+ProjectLibFlagsRecord mLibFlagsRec;
+ProjectVersionRecord mVersionRec;
+ProjectConstantsRecord mConstantsRecord;
+std::vector< ReferenceRecord* > ReferenceArray;
+
+DirDumper() {}
+~DirDumper() 
+{
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        delete *it;
+    
+}
+
+void read( SvStream* pStream )
+{
+    sal_Int32 nPos = pStream->Tell();
+#ifdef DEBUG
+    std::ofstream aDump("dir.dump");
+    while ( !pStream->IsEof() ) 
+    {
+        sal_Int8 aByte;
+        *pStream >> aByte;
+        aDump << aByte;
+    }
+    aDump.flush();
+#endif
+    pStream->Seek( nPos );
+    readProjectInformation( pStream );
+    readProjectReferenceInformation( pStream );
+}
+
+void readProjectReferenceInformation( SvStream* pStream )
+{
+    bool bKeepReading = true;
+    while( bKeepReading )
+    {
+        ReferenceRecord* pRef = new ReferenceRecord();
+        bKeepReading = pRef->read( pStream );
+        if ( bKeepReading ) 
+            ReferenceArray.push_back( pRef );
+    }
+}
+
+void readProjectInformation( SvStream* pStream )
+{
+    mSysKindRec.read( pStream );
+    mLcidRec.read( pStream ); 
+    mLcidInvokeRec.read( pStream );
+    mCodePageRec.read( pStream );
+    mProjectNameRec.read( pStream );
+    mDocStringRec.read( pStream );
+    mHelpFileRec.read( pStream );
+    mHelpContextRec.read( pStream );
+    mLibFlagsRec.read( pStream );
+    mVersionRec.read( pStream ); 
+    sal_Int32 nPos = pStream->Tell();
+    sal_uInt16 nTmp;
+    *pStream >> nTmp;
+    if ( nTmp == 0x0C )
+    {
+        pStream->Seek( nPos );
+        mConstantsRecord.read( pStream );
+    }
+    OSL_TRACE("After Information pos is 0x%x", pStream->Tell() );
+}
+
+void import( VBA_Impl& rVBA )
+{
+    // get project references
+    for ( std::vector< ReferenceRecord* >::iterator it = ReferenceArray.begin(); it != ReferenceArray.end(); ++it )
+        (*it)->import( rVBA );
+    rVBA.SetProjectName( mProjectNameRec.ProjectName );
+    
+}
+};
+
+
 /*
 A few urls which may in the future be of some use
 http://www.virusbtn.com/vb2000/Programme/papers/bontchev.pdf
@@ -153,7 +948,21 @@
     xVBAProject = rxVBAStorage->OpenSotStream(
                     String( RTL_CONSTASCII_USTRINGPARAM( "_VBA_PROJECT" ) ),
 					STREAM_STD_READ | STREAM_NOCREATE );
-
+    // read Dir stream
+    SvStorageStreamRef xDir = rxVBAStorage->OpenSotStream(
+                    String( RTL_CONSTASCII_USTRINGPARAM( "dir" ) ),
+					STREAM_STD_READ | STREAM_NOCREATE );
+// disable read and import of Dir stream bits, e.g. project references and
+// project name for 3.1 ( a bit unstable yet )
+#if 1
+    // decompress the stream
+    std::auto_ptr< SvMemoryStream > xCmpDir;
+    xCmpDir.reset( MSLZSS::decompressAsStream( xDir, 0 ) );
+    // try to parse the dir stream
+    DirDumper dDump;
+    dDump.read( xCmpDir.get() );
+    dDump.import( *this );
+#endif
 	if( !xVBAProject.Is() || SVSTREAM_OK != xVBAProject->GetError() )
 	{
 		DBG_WARNING("Not able to find vba project, cannot find macros");
@@ -432,7 +1241,7 @@
  *
 */
 
-ModuleType VBA_Impl::GetModuleType( const UniString& rModuleName )
+ModType VBA_Impl::GetModuleType( const UniString& rModuleName )
 {
     ModuleTypeHash::iterator iter = mhModHash.find( rModuleName );
     ModuleTypeHash::iterator iterEnd = mhModHash.end();
@@ -440,7 +1249,7 @@
     {
         return iter->second;
     }
-    return Unknown;
+    return ModuleType::Unknown;
 }
 
 bool VBA_Impl::Open( const String &rToplevel, const String &rSublevel )
@@ -453,6 +1262,7 @@
 	if( !xMacros.Is() || SVSTREAM_OK != xMacros->GetError() )
 	{
 		DBG_WARNING("No Macros Storage");
+		OSL_TRACE("No Macros Storage");
 	}
 	else
 	{
@@ -462,6 +1272,7 @@
 		if( !xVBA.Is() || SVSTREAM_OK != xVBA->GetError() )
 		{
 			DBG_WARNING("No Visual Basic in Storage");
+			OSL_TRACE("No Visual Basic in Storage");
 		}
 		else
 		{
@@ -476,6 +1287,7 @@
          * ( value ) is either a Class Module, Form Module or a plain VB Module.        */
         SvStorageStreamRef xProject = xMacros->OpenSotStream(
             String( RTL_CONSTASCII_USTRINGPARAM( "PROJECT" ) ) );
+
         SvStorageStream* pStp = xProject;
         UniString tmp;
         static const String sThisDoc(   RTL_CONSTASCII_USTRINGPARAM( "ThisDocument" ) );
@@ -483,7 +1295,7 @@
         static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
         static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
         static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
-        mhModHash[ sThisDoc ] = Class;
+        mhModHash[ sThisDoc ] = ModuleType::Class;
         while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
         {
             xub_StrLen index = tmp.Search( '=' );
@@ -493,14 +1305,14 @@
                 String value = tmp.Copy( index + 1 );
                 if ( key == sClass )
                 {
-                    mhModHash[ value ] = Class;
+                    mhModHash[ value ] = ModuleType::Class;
                     OSL_TRACE("Module %s is of type Class",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sBaseClass )
                 {
-                    mhModHash[ value ] =  Form;
+                    mhModHash[ value ] =  ModuleType::Form;
                     OSL_TRACE("Module %s is of type Form",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
@@ -513,14 +1325,14 @@
                     // value is of form <name>/&H<identifier>, strip the identifier
                     value.Erase( value.Search( '/' ) );
 
-                    mhModHash[ value ] = Document;
+                    mhModHash[ value ] = ModuleType::Document;
                     OSL_TRACE("Module %s is of type Document VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
                 }
                 else if ( key == sModule )
                 {
-                    mhModHash[ value ] = Normal;
+                    mhModHash[ value ] = ModuleType::Normal;
                     OSL_TRACE("Module %s is of type Normal VBA",
                         ::rtl::OUStringToOString( value ,
                             RTL_TEXTENCODING_ASCII_US ).pData->buffer );
Index: svx/source/msfilter/msvbahelper.cxx
===================================================================
--- svx/source/msfilter/msvbahelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ svx/source/msfilter/msvbahelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,384 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#include "precompiled_svx.hxx"
+#include <svx/msvbahelper.hxx>
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbmeth.hxx>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <com/sun/star/document/XDocumentProperties.hpp>
+#include <com/sun/star/document/XDocumentInfoSupplier.hpp>
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+
+using namespace ::com::sun::star;
+
+const static rtl::OUString sUrlPart0 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+const static rtl::OUString sUrlPart1 = rtl::OUString::createFromAscii( "?language=Basic&location=document"); 
+
+namespace ooo { namespace vba {
+
+String makeMacroURL( const String& sMacroName )
+{
+	return sUrlPart0.concat( sMacroName ).concat( sUrlPart1 ) ;
+}
+
+SfxObjectShell* findShellForUrl( const rtl::OUString& sMacroURLOrPath )
+{
+    SfxObjectShell* pFoundShell=NULL;
+    SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+    INetURLObject aObj;
+    aObj.SetURL( sMacroURLOrPath );
+    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+    rtl::OUString aURL;
+    if ( bIsURL )
+        aURL = sMacroURLOrPath;
+    else
+    {
+        osl::FileBase::getFileURLFromSystemPath( sMacroURLOrPath, aURL );
+        aObj.SetURL( aURL );
+    }    
+    OSL_TRACE("Trying to find shell for url %s", rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() );
+    while ( pShell )
+    {
+
+        uno::Reference< frame::XModel > xModel = pShell->GetModel();
+        // are we searching for a template? if so we have to cater for the
+        // fact that in openoffice a document opened from a template is always
+        // a new document :/
+        if ( xModel.is() )
+        {
+            OSL_TRACE("shell 0x%x has model with url %s and we look for %s", pShell
+                , rtl::OUStringToOString( xModel->getURL(), RTL_TEXTENCODING_UTF8 ).getStr() 
+                , rtl::OUStringToOString( aURL, RTL_TEXTENCODING_UTF8 ).getStr() 
+            );
+            if ( sMacroURLOrPath.endsWithIgnoreAsciiCaseAsciiL( ".dot", 4 ) )
+            {
+                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( xModel, uno::UNO_QUERY );
+                if( xDocInfoSupp.is() )
+                {
+                    uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+                    uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+                    rtl::OUString sCurrName = xDocProps->getTemplateName();
+                    if( sMacroURLOrPath.lastIndexOf( sCurrName ) >= 0 )
+                    {
+                        pFoundShell = pShell; 
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                if ( aURL.equals( xModel->getURL() ) )
+                {
+                    pFoundShell = pShell; 
+                    break;
+                }
+            }
+        }
+        pShell = SfxObjectShell::GetNext( *pShell );
+    }
+    return pFoundShell;
+}
+
+// sMod can be empty ( but we really need the library to search in )
+// if sMod is empty and a macro is found then sMod is updated
+bool hasMacro( SfxObjectShell* pShell, const String& sLibrary, String& sMod, const String& sMacro )
+{
+    bool bFound = false;
+    if ( sLibrary.Len() && sMacro.Len() )
+    {
+        OSL_TRACE("** Searching for %s.%s in library %s"
+            ,rtl::OUStringToOString( sMod, RTL_TEXTENCODING_UTF8 ).getStr()
+            ,rtl::OUStringToOString( sMacro, RTL_TEXTENCODING_UTF8 ).getStr()
+            ,rtl::OUStringToOString( sLibrary, RTL_TEXTENCODING_UTF8 ).getStr() );
+        BasicManager* pBasicMgr = pShell-> GetBasicManager();
+        if ( pBasicMgr )
+        {
+            StarBASIC* pBasic = pBasicMgr->GetLib( sLibrary );
+            if ( !pBasic )
+            {
+                USHORT nId = pBasicMgr->GetLibId( sLibrary );
+                pBasicMgr->LoadLib( nId );
+                pBasic = pBasicMgr->GetLib( sLibrary );
+            }
+            if ( pBasic )
+            {
+                if ( sMod.Len() ) // we wish to find the macro is a specific module
+                {
+                    SbModule* pModule = pBasic->FindModule( sMod );
+                    if ( pModule )
+                    {
+                        SbxArray* pMethods = pModule->GetMethods();
+                        if ( pMethods )
+                        {
+                            SbMethod* pMethod = static_cast< SbMethod* >( pMethods->Find( sMacro, SbxCLASS_METHOD ) );
+                            if ( pMethod )
+                              bFound = true;
+                        }
+                    }
+                }
+                else if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( sMacro, SbxCLASS_METHOD ) ) )
+                {
+                    if( SbModule* pModule = pMethod->GetModule() )
+                    {
+                        sMod = pModule->GetName();
+                        bFound = true;
+                    }
+                }
+            }
+        }
+    }
+    return bFound;
+}
+void parseMacro( const rtl::OUString& sMacro, String& sContainer, String& sModule, String& sProcedure )
+{
+    sal_Int32 nMacroDot = sMacro.lastIndexOf( '.' );
+    
+    if ( nMacroDot != -1 )
+    {
+        sProcedure = sMacro.copy( nMacroDot + 1 );
+ 
+        sal_Int32 nContainerDot = sMacro.lastIndexOf( '.',  nMacroDot - 1 );
+        if ( nContainerDot != -1 )
+        {
+            sModule = sMacro.copy( nContainerDot + 1, nMacroDot - nContainerDot - 1 );
+            sContainer = sMacro.copy( 0, nContainerDot );
+        }
+        else
+            sModule = sMacro.copy( 0, nMacroDot );
+    }
+    else
+       sProcedure = sMacro;
+}
+
+VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUString& MacroName, bool bSearchGlobalTemplates )
+{
+    VBAMacroResolvedInfo aRes;
+    if ( !pShell )
+        return aRes;
+    aRes.SetMacroDocContext( pShell );
+    // parse the macro name
+    sal_Int32 nDocSepIndex = MacroName.indexOfAsciiL( "!", 1 );
+    String sMacroUrl = MacroName;
+
+    String sContainer;
+    String sModule;
+    String sProcedure;
+    
+    if( nDocSepIndex > 0 )
+    {
+        // macro specified by document name
+        // find document shell for document name and call ourselves 
+        // recursively
+
+        // assume for now that the document name is *this* document
+        String sDocUrlOrPath = MacroName.copy( 0, nDocSepIndex );
+        sMacroUrl = MacroName.copy( nDocSepIndex + 1 );
+        OSL_TRACE("doc search, current shell is 0x%x", pShell );
+        SfxObjectShell* pFoundShell = findShellForUrl( sDocUrlOrPath );
+        OSL_TRACE("doc search, after find, found shell is 0x%x", pFoundShell );
+        aRes = resolveVBAMacro( pFoundShell, sMacroUrl ); 
+    }    
+    else
+    {
+        // macro is contained in 'this' document ( or code imported from a template
+        // where that template is a global template or perhaps the template this
+        // document is created from ) 
+    
+        // macro format = Container.Module.Procedure
+        parseMacro( MacroName, sContainer, sModule, sProcedure ); 
+        uno::Reference< lang::XMultiServiceFactory> xSF( pShell->GetModel(), uno::UNO_QUERY);
+        uno::Reference< container::XNameContainer > xPrjNameCache;
+        if ( xSF.is() )
+            xPrjNameCache.set( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "ooo.vba.VBAProjectNameProvider" ) ) ), uno::UNO_QUERY );
+    
+        std::vector< rtl::OUString > sSearchList; 
+
+        if ( sContainer.Len() > 0 )
+        { 
+            // get the Project associated with the Container
+            if ( xPrjNameCache.is() )
+            {
+                if ( xPrjNameCache->hasByName( sContainer ) )
+                {
+                    rtl::OUString sProject;
+                    xPrjNameCache->getByName( sContainer ) >>= sProject;
+                    sContainer = sProject;
+                }
+            }
+            sSearchList.push_back( sContainer ); // First Lib to search
+        }
+        else
+        {
+            // Ok, if we have no Container specified then we need to search them in order, this document, template this document created from, global templates, 
+            // get the name of Project/Library for 'this' document
+            rtl::OUString sThisProject;
+            BasicManager* pBasicMgr = pShell-> GetBasicManager();
+            if ( pBasicMgr )
+            {
+                if ( pBasicMgr->GetName().Len() )
+                   sThisProject = pBasicMgr->GetName();
+                else // cater for the case where VBA is not enabled
+                   sThisProject = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+            }
+            sSearchList.push_back( sThisProject ); // First Lib to search
+            if ( xPrjNameCache.is() )
+            {
+                // is this document created from a template?
+                uno::Reference< document::XDocumentInfoSupplier > xDocInfoSupp( pShell->GetModel(), uno::UNO_QUERY_THROW );
+                uno::Reference< document::XDocumentPropertiesSupplier > xDocPropSupp( xDocInfoSupp->getDocumentInfo(), uno::UNO_QUERY_THROW );
+                uno::Reference< document::XDocumentProperties > xDocProps( xDocPropSupp->getDocumentProperties(), uno::UNO_QUERY_THROW );
+            
+                rtl::OUString sCreatedFrom = xDocProps->getTemplateURL();
+                if ( sCreatedFrom.getLength() )
+                {
+                    INetURLObject aObj;
+                    aObj.SetURL( sCreatedFrom );
+                    bool bIsURL = aObj.GetProtocol() != INET_PROT_NOT_VALID;
+                    rtl::OUString aURL;
+                    if ( bIsURL )
+                        aURL = sCreatedFrom;
+                    else
+                    {
+                        osl::FileBase::getFileURLFromSystemPath( sCreatedFrom, aURL );
+                        aObj.SetURL( aURL );
+                    }        
+                    sCreatedFrom =  aObj.GetLastName();
+                } 
+                
+                sal_Int32 nIndex =  sCreatedFrom.lastIndexOf( '.' );
+                if ( nIndex != -1 )
+                    sCreatedFrom = sCreatedFrom.copy( 0, nIndex );
+        
+                rtl::OUString sPrj;
+                if ( sCreatedFrom.getLength() && xPrjNameCache->hasByName( sCreatedFrom ) )
+                {
+                    xPrjNameCache->getByName( sCreatedFrom ) >>= sPrj;
+                    // Make sure we don't double up with this project
+                    if ( !sPrj.equals( sThisProject ) )
+                        sSearchList.push_back( sPrj );
+                }
+        
+                // get list of global template Names
+                uno::Sequence< rtl::OUString > sTemplateNames = xPrjNameCache->getElementNames();
+                sal_Int32 nLen = sTemplateNames.getLength();
+                for ( sal_Int32 index = 0; ( bSearchGlobalTemplates && index < nLen ); ++index )
+                {
+                    
+                    if ( !sCreatedFrom.equals( sTemplateNames[ index ] ) )
+                    {
+                        if ( xPrjNameCache->hasByName( sTemplateNames[ index ] ) )
+                        {
+                            xPrjNameCache->getByName( sTemplateNames[ index ] ) >>= sPrj;
+                            // Make sure we don't double up with this project
+                            if ( !sPrj.equals( sThisProject ) )
+                                sSearchList.push_back( sPrj );
+                        }
+                    }
+        
+                }
+            }
+        }
+        std::vector< rtl::OUString >::iterator it_end = sSearchList.end();
+        for ( std::vector< rtl::OUString >::iterator it = sSearchList.begin(); it != it_end; ++it )
+        {
+            bool bRes = hasMacro( pShell, *it, sModule, sProcedure );
+            if ( bRes )
+            {
+                aRes.SetResolved( true );
+                aRes.SetMacroDocContext( pShell );
+                sContainer = *it;
+                break;
+            }
+        }
+    }
+    aRes.SetResolvedMacro( sProcedure.Insert( '.', 0 ).Insert( sModule, 0).Insert( '.', 0 ).Insert( sContainer, 0 ) );
+
+    return aRes;
+}
+
+// Treat the args as possible inouts ( convertion at bottom of method )
+sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, uno::Sequence< uno::Any >& aArgs, uno::Any& /*aRet*/, const uno::Any& aCaller )
+{
+    sal_Bool bRes = sal_False;
+    if ( !pShell )
+        return bRes;
+    rtl::OUString sUrl = makeMacroURL( sMacroName );
+
+    uno::Sequence< sal_Int16 > aOutArgsIndex;
+    uno::Sequence< uno::Any > aOutArgs;
+
+    try
+    {    
+        uno::Reference< script::provider::XScriptProvider > xScriptProvider;
+        uno::Reference< script::provider::XScriptProviderSupplier > xSPS( pShell->GetModel(), uno::UNO_QUERY_THROW );
+
+        xScriptProvider.set( xSPS->getScriptProvider(), uno::UNO_QUERY_THROW );
+
+        uno::Reference< script::provider::XScript > xScript( xScriptProvider->getScript( sUrl ), uno::UNO_QUERY_THROW );
+
+        if ( aCaller.hasValue() )
+        {
+            uno::Reference< beans::XPropertySet > xProps( xScript, uno::UNO_QUERY );
+            if ( xProps.is() )
+            {
+                uno::Sequence< uno::Any > aCallerHack(1);
+                aCallerHack[ 0 ] = aCaller;
+                xProps->setPropertyValue( rtl::OUString::createFromAscii( "Caller" ), uno::makeAny( aCallerHack ) );
+            }
+        }
+
+
+        xScript->invoke( aArgs, aOutArgsIndex, aOutArgs  );
+        
+        sal_Int32 nLen = aOutArgs.getLength();
+        // convert any out params to seem like they were inouts
+        if ( nLen )
+        {
+            for ( sal_Int32 index=0; index < nLen; ++index )
+            {
+                sal_Int32 nOutIndex = aOutArgsIndex[ index ];
+                aArgs[ nOutIndex ] = aOutArgs[ index ];
+           }
+        }
+
+        bRes = sal_True;
+    }
+    catch ( uno::Exception& e )
+    {
+       bRes = sal_False;
+    }
+    return bRes; 
+}
+} } // vba // ooo
Index: svx/source/msfilter/msocximex.cxx
===================================================================
--- svx/source/msfilter/msocximex.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/msocximex.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -49,6 +49,10 @@
 #include <com/sun/star/drawing/XDrawPageSupplier.hpp>
 #include <com/sun/star/form/XFormsSupplier.hpp>
 #include <com/sun/star/form/XForm.hpp>
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
 #include <com/sun/star/form/FormComponentType.hpp>
 #include <com/sun/star/awt/FontWeight.hpp>
 #include <com/sun/star/awt/FontSlant.hpp>
@@ -79,7 +83,22 @@
 
 #include <algorithm>
 #include <memory>
+#include <com/sun/star/graphic/GraphicObject.hpp>
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <comphelper/componentcontext.hxx>
+#include <unotools/streamwrap.hxx>
 
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <svtools/filterutils.hxx>
+ 
 #ifndef C2S
 #define C2S(cChar)	String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(cChar))
 #endif
@@ -102,6 +121,7 @@
 
 
 #define WW8_ASCII2STR(s) String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(s))
+#define GRAPHOBJ_URLPREFIX "vnd.sun.star.GraphicObject:"
 
 
 static char sWW8_form[] = "WW-Standard";
@@ -130,127 +150,49 @@
     return 0;
 }
 
-
 // NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
 // referenced externally. On import from ms document try to save images for controls here.
 // Images are stored in directory called temp in the user installation directory. Next version of OO/SO
 // hopefully will address this issue and allow a choice e.g. images for controls to be stored as links
 // or embeded in the document.
-
-// [out]location     path to the stream to where the image is to be stored,
-//               if same name exists in folder then this function calcuates a new name
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-//
-// returns, true if successful
-
-bool storePictureInFileSystem( OUString& location, sal_uInt8* data, sal_uInt32 dataLen )
+uno::Reference< graphic::XGraphicObject> lcl_readGraphicObject( SotStorageStream *pS )
 {
-    bool result = true;
-    OUString origPath = location;
-    try
-    {
-        uno::Reference<lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(),
-                                                      uno::UNO_QUERY_THROW );
-        uno::Reference< com::sun::star::ucb::XSimpleFileAccess> xSFA( xMSF->createInstance(
-                                                       S2U("com.sun.star.ucb.SimpleFileAccess" ) ),
-                                                       uno::UNO_QUERY_THROW );
-        OUString ext;
-        sal_Int32 index = 0;
-        while (  xSFA->exists( location ) )
-        {
-            ext = OUString::valueOf( ++index );
-            location = origPath + ext;
-        }
-
-        SvStream*  pStream = ::utl::UcbStreamHelper::CreateStream( location, STREAM_WRITE | STREAM_TRUNC );
-        if ( pStream )
-        {
-            pStream->Write(data, dataLen);
-            delete pStream;
-        }
-        else
-        {
-            result = false;
-        }
-    }
-    catch( uno::Exception& )
-    {
-        result = false;
-    }
-    return result;
+	uno::Reference< graphic::XGraphicObject > xGrfObj;
+	uno::Reference< lang::XMultiServiceFactory > xServiceManager = ::comphelper::getProcessServiceFactory();
+	if( xServiceManager.is() )
+	{
+		try
+		{
+			// use the GraphicProvider service to get the XGraphic
+			uno::Reference< graphic::XGraphicProvider > xGraphProvider(
+					xServiceManager->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.graphic.GraphicProvider" ) ), uno::UNO_QUERY );
+			if( xGraphProvider.is() )
+			{
+				uno::Reference< io::XInputStream > xStream( new utl::OInputStreamWrapper( *pS ) );
+				if( xStream.is() )
+				{
+					uno::Sequence< beans::PropertyValue > aMediaProps( 1 );
+					aMediaProps[0].Name = ::rtl::OUString::createFromAscii( "InputStream" );
+					aMediaProps[0].Value <<= xStream;
+					uno::Reference< graphic::XGraphic > xGraphic = xGraphProvider->queryGraphic( aMediaProps );
+					if( xGraphic.is() )
+					{
+						// create an XGraphicObject
+						::comphelper::ComponentContext aContext( xServiceManager );
+						xGrfObj = graphic::GraphicObject::create( aContext.getUNOContext() );
+						xGrfObj->setGraphic(xGraphic);
+					}
+				}
+			}
+		}
+		catch( uno::Exception& )
+		{
+		}
+	}
+	return xGrfObj;
 }
 
-// NP - Images in controls in OO2.0/SO8 exist as links, e.g. they are not part of the document so are
-// referenced externally. On import from ms document try to save images from controls here so this
-// at least a macro programmer has a chance to accessed them manually later. Next version of OO/SO
-// hopefully will address this issue.
-// Images will be stored in a top level folder in the document package, folder is named "MigratedImages"
 
-// [in] pDocSh*  the document shell.
-// [in] name     name of stream image to stored in.
-// [in] data     raw bytes of image to be stored.
-// [in] dataLen  no. byte to be stored
-
-bool storePictureInDoc( SfxObjectShell* pDocSh, OUString& name, sal_uInt8* data, sal_uInt32 dataLen )
-{
-    uno::Reference < embed::XStorage > xStor;
-    if (pDocSh)
-    {
-        xStor = pDocSh->GetStorage();
-        if( xStor.is() )
-        {
-            try
-            {
-                uno::Reference< embed::XStorage > xPictures = xStor->openStorageElement(
-                    OUString( RTL_CONSTASCII_USTRINGPARAM( "MigratedImages" ) ),
-                    embed::ElementModes::READWRITE );
-                uno::Reference< beans::XPropertySet > xPropSet( xPictures, uno::UNO_QUERY );
-
-                // Set media type of folder MigratedImages to something ( that is unknown ) so that
-                // it will get copied to exported OO/SO format after SaveAs
-                if ( xPropSet.is() )
-                {
-                    OUString aMediaType = C2U("MigrationImages");
-                    uno::Any a;
-                    a <<= aMediaType;
-                    xPropSet->setPropertyValue( C2U("MediaType"), a );
-                }
-
-                uno::Reference< io::XStream > xObjReplStr = xPictures->openStreamElement(
-                        name,
-                        embed::ElementModes::READWRITE | embed::ElementModes::TRUNCATE );
-                uno::Reference< io::XOutputStream > xOutStream( xObjReplStr->getOutputStream(), uno::UNO_QUERY_THROW );
-                uno::Sequence< sal_Int8 > imageBytes( (sal_Int8*)data, dataLen );
-                xOutStream->writeBytes( imageBytes );
-                xOutStream->closeOutput();
-
-                uno::Reference< embed::XTransactedObject > xTransact( xPictures, uno::UNO_QUERY );
-                if ( xTransact.is() )
-                {
-                    xTransact->commit();
-                }
-            }
-            catch( uno::Exception& )
-            {
-                return false;
-            }
-
-        }
-        else
-        {
-            // no storage something wrong
-            return false;
-        }
-    }
-    else
-    {
-        //No doc shell
-        return false;
-    }
-    return true;
-}
-
 long WriteAlign(SvStorageStream *pS, int nAmount)
 {
 	if (long nAlign = pS->Tell() % nAmount)
@@ -413,35 +355,11 @@
  */
 OUString lclCreateOUString( const char* pcCharArr, sal_uInt32 nLenFld )
 {
-    OUStringBuffer aBuffer;
     sal_uInt32 nBufSize = lclGetBufferSize( nLenFld );
     if( lclIsCompressed( nLenFld ) )
-    {
-        // buffer contains compressed Unicode, not encoded bytestring
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
-    }
-    else
-    {
-        // buffer contains Little-Endian Unicode
-        sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
-        aBuffer.setLength( nStrLen );
-        const char* pcCurrChar = pcCharArr;
-        for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
-        {
-            /*  *pcCurrChar may contain negative values and therefore MUST be
-                casted to unsigned char, before assigned to a sal_Unicode. */
-            sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
-            cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
-            aBuffer.setCharAt( nChar, cChar );
-        }
-    }
-    return aBuffer.makeStringAndClear();
+        return svt::BinFilterUtils::CreateOUStringFromStringArray( pcCharArr, nBufSize );
+
+    return svt::BinFilterUtils::CreateOUStringFromUniStringArray( pcCharArr, nBufSize );
 }
 
 // export ---------------------------------------------------------------------
@@ -561,8 +479,129 @@
 const sal_uInt16 SCROLLBAR = (sal_uInt16)0x2F;
 
 const sal_uInt16 MULTIPAGE = (sal_uInt16)0x39;
+// The IDs with bit 0x8000 set appear to be generated.
+// It looks like these ID's are used with the non-toolbox [1]
+// ActiveX controls that can be present in a Userform
+// ( note: RefEdit seems to be an exception )
+// In UserForm::Read just before the Container record starts
+// you will notice there can be sometimes trailing records, 
+// it seems that these records have a 1:1 relationship with the non-toolbox
+// controls present in the Userform. An id in the trailing record
+// seems to identify the specific ActiveX control and an artificial nTypeIdent
+// e.g. 0x8000, 0x8001 etc. is created so as to be able to associate
+// the ActiveX control when referenced later 
+// [1] Such ActiveX controls are added via Tools/AddionalControls
+// menu
+
+// create a fixed set of those special id(s)
+// ahem, we can only read one Progress bars at the moment so....
 const sal_uInt16 PROGRESSBAR = (sal_uInt16)0x8000;
 
+// A set of IDs from the trailing records mentioned above that seem to
+// identify the following ActiveX controls 
+// Currently we only can process ( in a limited way ) the ProgressBar
+// the other ID's are for reference ( & future )
+
+// RefEdit control {00024512-0000-0000-c000-000000000046}
+const sal_uInt8 aRefEditID[] =
+{
+0x12, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+// Microsoft ProgressBar Control, version 6.0 {35053A22-8589-11D1-B16A-00C0F0283628}
+const sal_uInt8 aProgressID[] =
+{
+0x22, 0x3a, 0x05, 0x35, 0x89, 0x85, 0xd1, 0x11,  0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Calendar Control 10.0 
+const sal_uInt8 aCalendarID[] =
+{
+0x2b, 0xc9, 0x27, 0x8e, 0x64, 0x12, 0x1c, 0x10, 0x8a, 0x2f, 0x04, 0x02, 0x24, 0x00, 0x9c, 0x02,
+};
+
+
+// Microsoft ImageComboxBox Control, version 6.0 {DD9DA666-8594-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageComboID[] =
+{
+0x66, 0xa6, 0x9d, 0xdd, 0x94, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft ImageList Control, version 6.0 {2C247F23-8591-11D1-B16A-00C0F0283628}
+const sal_uInt8 aImageListID[] =
+{
+0x23, 0x7f, 0x24, 0x2c, 0x91, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Slider Control, version 6.0 {F08DF954-8592-11D1-B16A-00C0F0283628}
+const sal_uInt8 aSliderID[] =
+{
+0x54, 0xf9, 0x8d, 0xf0, 0x92, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft StatusBar Control, version 6.0 {8E3867A3-8586-11D1-B16A-00C0F0283628}
+const sal_uInt8 aStatusBarID[] =
+{
+0xa3, 0x67, 0x38, 0x8e, 0x86, 0x85, 0xd1, 0x11, 0xb1, 0x6a, 0x00, 0xc0, 0xf0, 0x28, 0x36, 0x28,
+};
+
+// Microsoft Office Chart 10.0
+const sal_uInt8 aChartSpaceID[] =
+{
+0x46, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
+};
+
+const sal_Int16 ActiveXIDLen = 0x10; // CLSID len
+const sal_Int16 ActiveXIDBlockLen = 0x30; // the block len that contains the CLSID
+
+bool lcl_handleActiveXControl(  SvStorageStream *pS, sal_uInt16& nTypeID )
+{
+    nTypeID = 0; // Illegal ActiveX ID 
+    bool bRes = false;
+    sal_uInt16 nIdentifier, nFixedAreaLen;
+    *pS >> nIdentifier;    
+    *pS >> nFixedAreaLen;    
+    pS->SeekRel( ( nFixedAreaLen - ActiveXIDBlockLen ) );
+    sal_uInt8 aID[ ActiveXIDLen ];
+    if ( !pS->IsEof() )
+    {
+        pS->Read( aID, ActiveXIDLen );
+        pS->SeekRel( ActiveXIDBlockLen - ActiveXIDLen ); // read remainer of record
+        if ( memcmp( aID, aProgressID, ActiveXIDLen ) == 0 )
+        {
+            nTypeID = PROGRESSBAR;
+            OSL_TRACE("Found supported ***PROGRESSBAR*** ActiveX control");
+            bRes = true;
+        }
+#if (OSL_DEBUG_LEVEL > 0)
+        // If we really want to process these more controls we should put them in 
+        // a list or array and have a single loop testing each id. For the moment 
+        // as we only can process PROGRESSBAR, not much point doing that until 
+        // we add support for at least another activex control
+
+        else if ( memcmp( aID, aCalendarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CALENDAR*** ActiveX control");
+        else if ( memcmp( aID, aRefEditID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***REFEDIT*** ActiveX control");
+        else if ( memcmp( aID, aImageComboID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGECOMBO*** ActiveX control");
+        else if ( memcmp( aID, aImageListID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***IMAGELIST*** ActiveX control");
+        else if ( memcmp( aID, aChartSpaceID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***CHARTSPACE*** ActiveX control");
+        else if ( memcmp( aID, aSliderID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***SLIDER*** ActiveX control");
+        else if ( memcmp( aID, aStatusBarID, ActiveXIDLen ) == 0 )
+            OSL_TRACE("Found unsupported ***STATUSBAR*** ActiveX control");
+#endif
+        else
+        {
+            OSL_TRACE("Unknown activeX ID !");
+        }
+    }
+    return bRes;
+}
+
 typedef std::vector< ContainerRecord > ContainerRecordList;
 
 class ContainerRecReader
@@ -637,6 +676,8 @@
             // control type
             if( nContentFlags & 0x00000080 )
                 *pS >> rec.nTypeIdent;
+            if( nContentFlags & 0x00000200 )
+                pS->SeekRel( 4 ); // Grouping?
             // length of infotip
             sal_uInt32 nTipLen = 0;
             if( nContentFlags & 0x00000800 )
@@ -711,14 +752,22 @@
             if( nCtrlSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nCtrlSrcBufSize );
+                std::auto_ptr< sal_Char > pCtrlSrcName;
+                pCtrlSrcName.reset( new sal_Char[ nCtrlSrcBufSize ] );
+                pS->Read( pCtrlSrcName.get(), nCtrlSrcBufSize );
+                rec.sCtrlSource = lclCreateOUString( pCtrlSrcName.get(), nCtrlSrcLen );
+                OSL_TRACE("*** *** *** ControlSourceName -> %s ", rtl::OUStringToOString( rec.sCtrlSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
             // row source name
             sal_uInt32 nRowSrcBufSize = lclGetBufferSize( nRowSrcLen );
             if( nRowSrcBufSize > 0 )
             {
                 ReadAlign( pS, pS->Tell() - nStartPos, 4 );
-                pS->SeekRel( nRowSrcBufSize );
+                std::auto_ptr< sal_Char > pRowSrcName;
+                pRowSrcName.reset( new sal_Char[ nRowSrcBufSize ] );
+                pS->Read( pRowSrcName.get(), nRowSrcBufSize );
+                rec.sRowSource =  lclCreateOUString( pRowSrcName.get(), nRowSrcLen );
+                OSL_TRACE("*** *** *** RowSourceName -> %s ", rtl::OUStringToOString( rec.sRowSource, RTL_TEXTENCODING_UTF8 ).getStr() );
             }
 
             // seek to end of data
@@ -735,6 +784,13 @@
                 pControl->pDocSh = pContainerControl->pDocSh;
                 pContainerControl->ProcessControl( pControl, pS, rec );
             }
+            else if ( rec.nTypeIdent & 0x8000 )
+            {
+                // Skip ActiveX Controls we can't import
+                SotStorageStreamRef oStream = pContainerControl->getContainedControlsStream(); 
+                ULONG nStrmPos = oStream->Tell();
+                oStream->Seek( nStrmPos + rec.nSubStreamLen );
+            }  
             else
             {
                 DBG_ERROR("Terminating import, unexpected error");
@@ -755,6 +811,11 @@
     {
         sal_uInt8 aUnknown11[4];
         pS->Read(aUnknown11, sizeof(aUnknown11));
+        // discovered a dialog with value of 0xFF for aUnknown11 
+        // needed an extra 4 bytes to offset correctly  into the control
+        // records. Valid test or coincidence ?
+        if ( aUnknown11[1] == 0xFF )
+           pS->Read( aUnknown11, sizeof(aUnknown11));
         return true;
     }
 
@@ -829,176 +890,6 @@
 
 // ============================================================================
 
-void RBGroup::add(OCX_Control* pRB)
-{
-    // The tab index for the group is calculated as
-    // the lowest tab index found in the list of RadioButtons
-    if ( pRB->mnTabPos < mRBGroupPos )
-    {
-        mRBGroupPos = pRB->mnTabPos;
-        CtrlIterator aEnd = mpControls.end();
-        for (CtrlIterator aIter = mpControls.begin(); aIter != aEnd; ++ aIter )
-        {
-            (*aIter)->mnTabPos = mRBGroupPos;
-        }
-    }
-    mpControls.push_back( pRB );
-}
-
-struct SortGroupByTabPos
-{
-    bool operator()( const RBGroup* a, const RBGroup* b )
-    {
-        return a->tabPos() < b->tabPos();
-    }
-};
-
-RBGroupManager::RBGroupManager( String& defaultName ):mSDefaultName( defaultName ),
-    numRadioButtons(0)
-{
-    groupList.reserve( 8 ); // reserve far more than we expect
-}
-
-RBGroupManager::~RBGroupManager()
-{
-    for ( GroupIterator gIter=groupList.begin(); gIter!=groupList.end(); ++gIter )
-    {
-        delete( *gIter );
-    }
-}
-
-// Loose description of the method below ( I sure there is a better way to do
-// this )
-// In order to "fake" MS grouping behavior for OptionButtons the OptionButtons
-// in the same group need to have consecutive tab indices ( regardless of the
-// imported tab indices of the RadioButtons ). Additionally if two
-// groups of OptionButtons end up having all consecutive indices they
-// will be treated as a single group by OpenOffice. In this case
-// a dummy seperator control needs to be inserted between the groups.
-//
-// This method returns a new list "destinationList" containing the controls
-// passed in "sourceList" and the OptionButtons contained in the various
-// Groups maintained by this  class.
-// Controls are ordered in the destination list by tab index.
-// Each RadioButtonGroup has a tab index associated with it.
-// ( Tab index of a RadioGroup is determined as the tab index of the
-// OptionButton control with the lowest tab index in the group )
-
-
-void RBGroupManager::addRadioButton( OCX_OptionButton* pRButton )
-{
-    if ( pRButton )
-    {
-        OUString groupName = mSDefaultName;
-        if ( pRButton->nGroupNameLen )
-        {
-            groupName =
-                lclCreateOUString(pRButton->pGroupName,
-                    pRButton->nGroupNameLen);
-        }
-        ++numRadioButtons;
-        RBGroupHash::iterator iter = rbGroups.find( groupName );
-        if ( iter != rbGroups.end() )
-        {
-            iter->second->controls().push_back( pRButton );
-        }
-        else
-        {
-            RBGroup* newGroup = new RBGroup(pRButton->mnTabPos);
-            newGroup->controls().push_back( pRButton );
-            rbGroups[ groupName ] = newGroup;
-            groupList.push_back( newGroup );
-        }
-
-    }
-}
-
-CtrlList RBGroupManager::insertGroupsIntoControlList( const CtrlList& sourceList )
-{
-    ::std::sort( groupList.begin(), groupList.end(), SortGroupByTabPos() );
-    std::vector<OCX_Control*> destinationList;
-    if ( groupList.size() )
-    {
-        destinationList.reserve( sourceList.size() + numRadioButtons );
-
-        GroupIterator groupEnd = groupList.end();
-        CtrlIteratorConst sourceEnd = sourceList.end();
-
-        size_t prevGroupListSize = 0;
-
-        CtrlIteratorConst containees = sourceList.begin();
-        GroupIterator groupIter=groupList.begin();
-        while ( containees != sourceEnd ||
-                groupIter != groupEnd )
-        {
-            bool addGroupSeperator = false;
-            if ( containees != sourceEnd )
-            {
-                if ( groupIter != groupEnd )
-                {
-                    sal_Int16 groupTabPos = (*groupIter)->tabPos();
-                    if ( (*containees)->mnTabPos >= groupTabPos )
-                    {
-                       if ( !(destinationList.size() >=  prevGroupListSize ))
-                        {
-                            addGroupSeperator = true;
-                        }
-                        copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                        ++groupIter;
-
-                        prevGroupListSize = destinationList.size();
-                    }
-                }
-                destinationList.push_back(*containees);
-                ++containees;
-            }
-            else
-            {
-               if ( groupIter != groupEnd )
-               {
-                    if ( !(destinationList.size() >  prevGroupListSize ))
-                    {
-                        addGroupSeperator = true;
-                    }
-                    copyList( (*groupIter)->controls(), destinationList, addGroupSeperator );
-                    ++groupIter;
-                    prevGroupListSize = destinationList.size();
-                }
-            }
-        }
-    }
-    else
-    {
-        destinationList = sourceList;
-    }
-    return destinationList;
-
-}
-
-
-void RBGroupManager::addSeperator( std::vector< OCX_Control* >& dest )
-{
-    OCX_Control* seperator = new OCX_CommandButton;
-    seperator->SetInDialog(true);
-    seperator->sName = C2S("GroupSeperator");
-    dest.push_back( seperator );
-}
-
-void RBGroupManager::copyList( std::vector< OCX_Control* >& src,
-    std::vector< OCX_Control* >& dest,
-    bool addGroupSeperator )
-{
-    if ( addGroupSeperator )
-    {
-        addSeperator( dest );
-    }
-
-    for ( CtrlIterator rbIter = src.begin(); rbIter != src.end(); ++rbIter )
-    {
-        dest.push_back( *rbIter );
-    }
-}
-
 class OCX_UserFormLabel : public OCX_Label
 {
 public:
@@ -1165,6 +1056,9 @@
 sal_Bool OCX_Control::Import(uno::Reference<container::XNameContainer> &rDialog
     )
 {
+    uno::Reference<beans::XPropertySet > xDlgProps( rDialog, uno::UNO_QUERY);
+
+    
     uno::Reference<lang::XMultiServiceFactory>
         xFactory(rDialog, uno::UNO_QUERY);
 
@@ -1177,11 +1071,15 @@
 	if (!xModel.is())
 		return sal_False;
 
+    sal_Bool bVBA = sal_False;
     /*  #147900# sometimes insertion of a control fails due to existing name,
         do not break entire form import then... */
     try
     {
         rDialog->insertByName(sName, uno::makeAny(xModel));
+        if ( xDlgProps.is() )
+            xDlgProps->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+
     }
     catch( uno::Exception& )
     {
@@ -1197,16 +1095,32 @@
 
     if (!Import(xPropSet))
         return sal_False;
+    
+    uno::Any aTmp;
+    sal_Int32 nFactor = 3528; 
 
-    uno::Any aTmp;
-    aTmp <<= sal_Int32((mnLeft * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
-    aTmp <<= sal_Int32((mnTop * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    if ( !bVBA  )
+    {
+        aTmp <<= sal_Int32((mnLeft * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32((mnTop * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32((nWidth * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100);
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32(mnLeft); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionX"), aTmp);
+        aTmp <<= sal_Int32(mnTop); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("PositionY"), aTmp);
+        aTmp <<= sal_Int32(nWidth); // 100thmm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight); //100th mm
+        xPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
     if ( msToolTip.Len() > 0 )
 		xPropSet->setPropertyValue(WW8_ASCII2STR("HelpText"), uno::Any(OUString(msToolTip)));
 
@@ -1421,6 +1335,12 @@
     rPropSet->setPropertyValue( WW8_ASCII2STR( "FocusOnClick" ), aTmp );
 
 	aFontData.Import(rPropSet);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
 	return sal_True;
 }
 
@@ -1668,7 +1588,100 @@
 	return WriteContents(xContents,rPropSet,rSize);
 }
 
+bool lcl_isNamedRange( const rtl::OUString& sAddress, uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
 
+void lcl_ApplyListSourceAndBindableStuff( uno::Reference< frame::XModel >& xModel, const uno::Reference< beans::XPropertySet >& rPropSet, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rPropSet, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+}
+
 sal_Bool OCX_OptionButton::Import(com::sun::star::uno::Reference<
         com::sun::star::beans::XPropertySet> &rPropSet)
 {
@@ -1700,12 +1713,51 @@
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-	if (pValue && !bSetInDialog)
+	if (pValue)
 	{
 		INT16 nTmp = pValue[0]-0x30;
 		aTmp <<= nTmp;
-		rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		if (!bSetInDialog)
+			rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		{
+			// dialog ( but we might be using the form model )
+			if ( rPropSet->getPropertySetInfo()->hasPropertyByName( WW8_ASCII2STR("DefaultState") ) )
+				rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+			else
+				rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
+		}
 	}
+    // If this is a dialog control then we need to  set a groupname *always*
+    rtl::OUString sGroupName = lclCreateOUString( pGroupName, nGroupNameLen );
+    if ( GetInDialog() ) // Userform/Dialog
+    {
+        // By default groupnames are not set in Excel, it's not unusual to have
+        // a number of groups of radiobuttons located inside frame ( or other container
+        // controls ) where there is *no* specific groupname set for the radiobuttons.
+        // But... there is implicit grouping for radio buttons in seperate containers
+        // e.g. radio buttons in a frame are by default in the same group.
+        // Unfortunately in openoffice there are no containers below the dialog itself :-(
+        // To ensure correct grouping for imported radiobuttons either with no groupname
+        // or identical groupnames that are in separate containers we *must* ensure
+        // that a suitable groupname is applied. 
+        // Because controlNames are unique even across different containers we can use the
+        // controls container (e.g. parent) name as a prefix for a group name
+	rtl::OUString sParentName = msParentName;
+        sGroupName = sParentName.concat( C2U( ":" ) ).concat( sGroupName );
+    }
+    if ( sGroupName.getLength() == 0 )
+        sGroupName = rtl::OUString::createFromAscii("DefaultGroup");
+	OSL_TRACE("RadioButton %s has groupname %s", 
+		rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( sGroupName, RTL_TEXTENCODING_UTF8 ).getStr() );
+        try
+        {
+            aTmp <<= sGroupName;
+            rPropSet->setPropertyValue( WW8_ASCII2STR("GroupName"), aTmp);
+        }
+        catch( uno::Exception& )
+        {
+        }
 
 	if (pCaption)
 	{
@@ -1717,6 +1769,14 @@
     aTmp <<= ::com::sun::star::style::VerticalAlignment_MIDDLE;
     rPropSet->setPropertyValue( WW8_ASCII2STR("VerticalAlign"), aTmp );
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
+
 	aFontData.Import(rPropSet);
 	return sal_True;
 }
@@ -2352,6 +2412,12 @@
 	}
 
 	aFontData.Import(rPropSet);
+	
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+        rPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+    }
 	return sal_True;
 }
 
@@ -2608,6 +2674,8 @@
 	rPropSet->setPropertyValue( WW8_ASCII2STR("MaxTextLen"), aTmp);
 
 	aFontData.Import(rPropSet);
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
 	return sal_True;
 }
 
@@ -2827,7 +2895,8 @@
 
     aTmp <<= ImportColor( nBorderColor );
     rPropSet->setPropertyValue( WW8_ASCII2STR("BorderColor"), aTmp);
-
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
 	aFontData.Import(rPropSet);
 	return sal_True;
 }
@@ -3205,8 +3274,15 @@
 	{
 		pS->Read(pPictureHeader,20);
 		*pS >> nPictureLen;
-		pPicture = new sal_uInt8[nPictureLen];
-		pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
 	}
 
 	return sal_True;
@@ -3296,8 +3372,15 @@
 	{
 		pS->Read(pPictureHeader,20);
 		*pS >> nPictureLen;
-		pPicture = new sal_uInt8[nPictureLen];
-		pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nPictureLen );
 	}
 
 	return sal_True;
@@ -3418,7 +3501,7 @@
             const ::rtl::OUString& sN,
             const uno::Reference< container::XNameContainer >  &rParent,
             OCX_Control* pParent ) :
-                OCX_Control(sN, pParent), rbGroupMgr( sName ), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
+                OCX_Control(sN, pParent), mxParent(rParent), nNoRecords(0), nTotalLen(0), containerType( STDCONTAINER )
 {
 
     mContainerStorage = parent->OpenSotStorage(storageName,
@@ -3481,9 +3564,18 @@
     return buf.makeStringAndClear();
 }
 
-bool OCX_ContainerControl::createFromContainerRecord( const ContainerRecord& record, OCX_Control*& pControl )
+
+bool OCX_ContainerControl::createFromContainerRecord( ContainerRecord& record, OCX_Control*& pControl )
 {
     pControl = NULL;
+    if (  record.nTypeIdent & 0x8000 )
+    {
+        std::hash_map<sal_uInt16, sal_uInt16>::iterator it = mActiveXIDMap.find( record.nTypeIdent );
+        if ( it == mActiveXIDMap.end() )
+            return false;
+        // replace the generated id with our hardcoded one
+        record.nTypeIdent = it->second; 
+    }
     switch ( record.nTypeIdent)
         {
             case CMDBUTTON:
@@ -3591,8 +3683,7 @@
     SotStorageStreamRef oStream = mContainedControlsStream;
 
     // can insert into OO Dialog (e.g is this a supported dialog control)??
-    if ( rec.nTypeIdent == SPINBUTTON ||
-        rec.nTypeIdent == TABSTRIP)
+    if ( rec.nTypeIdent == TABSTRIP )
     {
         // skip the record in the stream, discard the control
         oStream->SeekRel( rec.nSubStreamLen );
@@ -3602,15 +3693,27 @@
     {
         // A container control needs to read the f stream in
         // the folder ( substorage ) associated with this control
-        if (  rec.nTypeIdent ==  FRAME ||
-            rec.nTypeIdent ==  MULTIPAGE||
-            rec.nTypeIdent ==  PAGE )
+        switch ( rec.nTypeIdent )
         {
-            OCX_ContainerControl* pContainer =
-               static_cast< OCX_ContainerControl* >( pControl );
-            oStream = pContainer->getContainerStream();
+            case FRAME:
+            case MULTIPAGE:
+            case PAGE:
+                {
+                    OCX_ContainerControl* pContainer =
+                        static_cast< OCX_ContainerControl* >( pControl );
+                    oStream = pContainer->getContainerStream();
+                    break;
+                }
+            case LISTBOX:
+            case OPTIONBUTTON:
+            case COMBOBOX:
+			case SPINBUTTON:
+			case SCROLLBAR:
+                {
+                    pControl->msCtrlSource = rec.sCtrlSource;
+                    pControl->msRowSource = rec.sRowSource;
+                }
         }
-
         pControl->sName = rec.cName;
         pControl->msToolTip = rec.controlTip;
         // Position of controls is relative to the container
@@ -3630,6 +3733,7 @@
             // applied to all containees
             pControl->mnStep = mnStep;
         }
+        pControl->msParentName = sName;
 
         // #117490# DR: container records provide size of substream, use it here...
 
@@ -3640,17 +3744,7 @@
         // set stream to position behind substream of this control
         oStream->Seek( nStrmPos + rec.nSubStreamLen );
 
-        //need to fake grouping behaviour for radio ( option ) buttons
-        if ( rec.nTypeIdent == OPTIONBUTTON )
-        {
-            OCX_OptionButton* pRButton =
-                static_cast< OCX_OptionButton*>(pControl);
-            rbGroupMgr.addRadioButton( pRButton );
-        }
-        else
-        {
-            mpControls.push_back( pControl );
-        }
+        mpControls.push_back( pControl );
     }
 }
 
@@ -3673,7 +3767,6 @@
     // this ensures that the default tab index created by Star/Open office
     // reflects the "flattened" ms tab order.
     ::std::sort( mpControls.begin(), mpControls.end(), SortOrderByTabPos() );
-    mpControls = rbGroupMgr.insertGroupsIntoControlList( mpControls );
 	return true;
 }
 
@@ -3691,7 +3784,8 @@
 		nScrollWidth(0), nScrollHeight(0), nIconLen(0), pIcon(0), nPictureLen(0),
 		pPicture(0)
 {
-    msDialogType = C2U("NotSupported");
+    //msDialogType = C2U("NotSupported");
+    msDialogType = C2U("com.sun.star.awt.UnoMultiPageModel");
     mnForeColor = 0x80000012L,
     mnBackColor = 0x8000000FL;
     bSetInDialog = true;// UserForm control only
@@ -3755,7 +3849,6 @@
 sal_Bool OCX_MultiPage::Import(com::sun::star::uno::Reference<
     com::sun::star::beans::XPropertySet> &rPropSet)
 {
-    // Calls import on contained controls
     OCX_ContainerControl::Import( rPropSet );
     return sal_True;
 }
@@ -3776,6 +3869,43 @@
 
     if ( xPropSet.is() )
     {
+        uno::Reference<lang::XMultiServiceFactory>
+            xFactory(rDialog, uno::UNO_QUERY);
+	OSL_TRACE("** MultiPage creating control %s", rtl::OUStringToOString( msDialogType, RTL_TEXTENCODING_UTF8 ).getStr() );
+	uno::Reference<uno::XInterface> xCreate = xFactory->createInstance(msDialogType);
+	if (!xCreate.is())
+		return sal_False;
+
+	uno::Reference<awt::XControlModel> xModel(xCreate, uno::UNO_QUERY);
+	if (!xModel.is())
+		return sal_False;
+
+        try
+        {
+		// we should just call MultiPage::Import( XPropertySet )
+    		OSL_TRACE("********* MULTIPAGE cName %s", rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() );
+		uno::Any aTmp(&sName,getCppuType((OUString *)0));
+		uno::Reference<beans::XPropertySet> xPrps(xModel, uno::UNO_QUERY);
+		xPrps->setPropertyValue( WW8_ASCII2STR("Name"), aTmp );
+		aTmp = uno::makeAny( mnCurrentPageStep );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValueMax"), aTmp );
+		// default current page to 0 ( #FIXME, we need to read this value )
+		aTmp = uno::makeAny( sal_Int32(0) );
+		xPrps->setPropertyValue( WW8_ASCII2STR("ProgressValue"), aTmp );
+    		OSL_TRACE("********* MULTIPAGE vomitted out properties");
+
+    // Calls import on contained controls
+            rDialog->insertByName(sName, uno::makeAny(xModel));
+            OSL_TRACE("*** inserted ***");
+        }
+        catch( uno::Exception& )
+        {
+            DBG_ERRORFILE(
+                ByteString( "OCX_Control::Import - cannot insert control \"" ).
+                Append( ByteString( sName, RTL_TEXTENCODING_UTF8 ) ).
+                Append( '"' ).GetBuffer() );
+        }
+
         // Calls import on contained pages
         return OCX_ContainerControl::Import( xPropSet );
     }
@@ -4062,8 +4192,7 @@
 		nKeepScrollBarsVisible(3), nCycle(0), nBorderStyle(0), nSpecialEffect(0),
 		nPicture(0), nPictureAlignment(2), nPictureSizeMode(0),
 		bPictureTiling(FALSE), nAccelerator(0), nIcon(0), pCaption(0),
-		nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0),
-		pPicture(0)
+		nScrollWidth(0), nScrollHeight(0), nScrollLeft(0), nScrollTop(0), nIconLen(0), pIcon(0), nPictureLen(0)
 	{
             mnForeColor = 0x80000012;
 		    mnBackColor = 0x8000000F;
@@ -4193,25 +4322,31 @@
 		pS->Read(pIcon,nIconLen);
 	}
 
+	ReadAlign( pS, pS->Tell() - nStart, 4);
+	if (pBlockFlags[2] & 0x10)
+	{
+		//Font Stuff..
+		pS->SeekRel(0x1a);
+		sal_uInt8 nFontLen;
+		*pS >> nFontLen;
+		pS->SeekRel(nFontLen);
+	}
 	if (nPicture)
 	{
 		pS->Read(pPictureHeader,20);
 		*pS >> nPictureLen;
-		pPicture = new sal_uInt8[nPictureLen];
-		pS->Read(pPicture,nPictureLen);
+		long imagePos = pS->Tell();
+		// great embedded object
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image.
+		pS->Seek( imagePos + nPictureLen );
 	}
 
-    ReadAlign( pS, pS->Tell() - nStart, 4);
-
-    if (pBlockFlags[2] & 0x10)
-    {
-        //Font Stuff..
-        pS->SeekRel(0x1a);
-        sal_uInt8 nFontLen;
-        *pS >> nFontLen;
-        pS->SeekRel(nFontLen);
-    }
-
     sal_Int16 numTrailingRecs = 0;
     *pS >> numTrailingRecs;
     // seems to be no. of trailing records,
@@ -4219,10 +4354,14 @@
     // ( unknown what these trailing records are for)
     if ( numTrailingRecs )
     {
-        for ( ; numTrailingRecs ; --numTrailingRecs )
+        for ( sal_Int16 i = 0 ; numTrailingRecs ; --numTrailingRecs, ++i )
         {
-            OCX_Control skip(C2S("dummy")) ;
-            skip.Read( pS );
+            sal_uInt16 nTypeID = 0;
+            if ( lcl_handleActiveXControl( pS, nTypeID ) )
+            {
+                if ( nTypeID & 0x8000 ) // valid ActiveXID
+                    mActiveXIDMap[ ( i | 0x8000 ) ] = nTypeID;
+            }
         }
     }
 	return OCX_ContainerControl::Read( pS );
@@ -4233,6 +4372,8 @@
 {
     uno::Reference<beans::XPropertySet>
         xDialogPropSet(mxParent, uno::UNO_QUERY);
+    if ( !xDialogPropSet.is() )
+        return sal_False;
     uno::Any aTmp(&sName,getCppuType((OUString *)0));
     xDialogPropSet->setPropertyValue(
         OUString(RTL_CONSTASCII_USTRINGPARAM("Name")), aTmp);
@@ -4240,22 +4381,56 @@
         OUString(RTL_CONSTASCII_USTRINGPARAM("Title")), aTmp);
     aTmp <<= ImportColor(mnBackColor);
 	xDialogPropSet->setPropertyValue( WW8_ASCII2STR("BackgroundColor"), aTmp);
+    sal_Bool bVBA = sal_False;
+    // Ok we are importing xls but maybe we aren't in VBA mode
+    // if we are not in VBA mode then we should import sizes etc. ( as before )
+    try
+    {
+        xDialogPropSet->getPropertyValue( OUString(RTL_CONSTASCII_USTRINGPARAM("VBAForm") ) ) >>= bVBA;
+    }
+    catch( uno::Exception& e )
+    {
+    }
+    sal_Int32 nFactor( 3528 );
+    if ( !bVBA )
+    {
+        aTmp <<= sal_Int32((nWidth * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32((nHeight * 2) / 100); 
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
+    else
+    {
+        aTmp <<= sal_Int32( nWidth + 160 ); // 100thmm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
+        aTmp <<= sal_Int32(nHeight + 662 - 714); //100th mm
+        xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
+    }
 
-    aTmp <<= sal_Int32((nWidth * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Width"), aTmp);
-    aTmp <<= sal_Int32((nHeight * 2) / 100);
-    xDialogPropSet->setPropertyValue(WW8_ASCII2STR("Height"), aTmp);
 
     uno::Reference<beans::XPropertySet> xPropSet( mxParent, uno::UNO_QUERY );
     OCX_ContainerControl::Import( xPropSet );
 
     uno::Reference<io::XInputStreamProvider> xSource =
-        xmlscript::exportDialogModel(mxParent, mxCtx);
+        xmlscript::exportDialogModel(mxParent, mxCtx, pDocSh->GetModel() );
     uno::Any aSourceAny(uno::makeAny(xSource));
     if (rLib->hasByName(sName))
         rLib->replaceByName(sName, aSourceAny);
     else
         rLib->insertByName(sName, aSourceAny);
+
+    if ( sImageUrl.getLength() )
+    {
+        aTmp <<= sImageUrl;
+		try
+		{
+        	xDialogPropSet->setPropertyValue( WW8_ASCII2STR("ImageURL"), aTmp);
+		}
+		catch( uno::Exception& )
+		{
+			OSL_TRACE("OCX_UserForm::Import, Image fails to import");
+		}
+    }
     return sal_True;
 }
 
@@ -4780,11 +4955,14 @@
     aTmp <<= ImportSpecEffect( nSpecialEffect );
     rPropSet->setPropertyValue( WW8_ASCII2STR("VisualEffect"), aTmp);
 
-	if (pValue && !bSetInDialog)
+	if (pValue)
 	{
 		INT16 nTmp=pValue[0]-0x30;
 		aTmp <<= nTmp;
-		rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		if ( !bSetInDialog )
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("DefaultState"), aTmp);
+		else
+		 	rPropSet->setPropertyValue( WW8_ASCII2STR("State"), aTmp);
 	}
 
 	if (pCaption)
@@ -5194,12 +5372,6 @@
 
 sal_Bool OCX_Image::Read(SotStorageStream *pS)
 {
-    if ( !bSetInDialog )
-    {
-        // preserve the present behavior at the moment.
-        // only import image control for UserForms
-        return sal_False;
-    }
     ULONG nStart = pS->Tell();
 	*pS >> nIdentifier;
 	DBG_ASSERT(nStandardId==nIdentifier,
@@ -5290,16 +5462,14 @@
 
         long imagePos = pS->Tell();
 
-        pS->Seek( imagePos );
-
-        sImageUrl =  C2U("vnd.sun.star.expand:${$BRAND_BASE_DIR/program/") + C2U( SAL_CONFIGFILE( "bootstrap" ) ) + C2U("::UserInstallation}/user/temp/") + sName;
-
-        sal_uInt8* pImage = new sal_uInt8[ nImageLen ];
-        pS->Read(pImage, nImageLen);
-        bool result = storePictureInFileSystem( sImageUrl, pImage, nImageLen );
-        OUString pictName = sImageUrl.copy( sImageUrl.lastIndexOf('/') + 1 );
-        result = storePictureInDoc( pDocSh, pictName, pImage, nImageLen );
-        delete pImage;
+		mxGrfObj = lcl_readGraphicObject( pS );
+		if( mxGrfObj.is() )
+		{
+			sImageUrl = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( GRAPHOBJ_URLPREFIX ) );
+			sImageUrl = sImageUrl + mxGrfObj->getUniqueID();
+		}
+		// make sure the stream position should be pointing after the image
+		pS->Seek( imagePos + nImageLen );
     }
     return sal_True;
 }
@@ -5467,7 +5637,7 @@
     mbPropThumb( true )
 {
     msFormType = C2U("com.sun.star.form.component.SpinButton");
-    msDialogType = C2U("com.sun.star.awt.UnoControlSpinButtonModel");
+    msDialogType = C2U("com.sun.star.form.component.SpinButton");
     mnBackColor = 0x8000000F;
     mnForeColor = 0x80000012;
 }
@@ -5504,8 +5674,8 @@
     if( mnBlockFlags & 0x00000080 )     rStrm >> mnValue;
     if( mnBlockFlags & 0x00000100 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00000200 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000400 )     rStrm.SeekRel( 4 );     // unknown
-    if( mnBlockFlags & 0x00000800 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000400 )     rStrm >> mnSmallStep;
+    if( mnBlockFlags & 0x00000800 )     rStrm.SeekRel( 4 );     // unknown
     if( mnBlockFlags & 0x00001000 )     rStrm >> mnPageStep;
     if( mnBlockFlags & 0x00002000 )     rStrm >> mnOrient;
     if( mnBlockFlags & 0x00004000 )
@@ -5590,6 +5760,9 @@
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
@@ -5757,7 +5930,7 @@
     sName = OUString( RTL_CONSTASCII_USTRINGPARAM( "ScrollBar" ) );
     mnMax = 32767;
     msFormType = C2U("com.sun.star.form.component.ScrollBar");
-    msDialogType = C2U("com.sun.star.awt.UnoControlScrollBarModel");
+    msDialogType = C2U("com.sun.star.form.component.ScrollBar");
 
 }
 
@@ -5823,6 +5996,9 @@
     aTmp <<= sal_Int16( 0 );
     rPropSet->setPropertyValue( WW8_ASCII2STR("Border"), aTmp);
 
+	uno::Reference< frame::XModel > xModel ( pDocSh ? pDocSh->GetModel() : NULL );
+	lcl_ApplyListSourceAndBindableStuff( xModel, rPropSet, msCtrlSource, msRowSource );
+
     return sal_True;
 }
 
Index: svx/source/msfilter/msvbasic.hxx
===================================================================
--- svx/source/msfilter/msvbasic.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/msfilter/msvbasic.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,8 @@
 #include <vector>
 #endif
 #include<map>
+#include <com/sun/star/script/ModuleType.hpp>
+using namespace ::com::sun::star::script::ModuleType;
 
 /* class VBA:
  * The VBA class provides a set of methods to handle Visual Basic For
@@ -68,13 +70,12 @@
 // #117718# define internal types to distinguish between
 // module types, form, class & normal
 // #i37965# DR 2004-12-03: add "Document", used in Excel for macros attached to sheet
-enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
 
 // #117718# define map to hold types of module
 //
-
+typedef sal_Int32 ModType;
 typedef ::std::map< UniString,
-    ModuleType > ModuleTypeHash;
+    ModType > ModuleTypeHash;
 
 class VBA_Impl
 {
@@ -95,10 +96,15 @@
     void Output(int len, const sal_uInt8 *data);
     //
     // #117718# member map of module names to types of module
-    ModuleType GetModuleType( const UniString& rModuleName );
-
-    std::vector<String> maReferences;
+    ModType GetModuleType( const UniString& rModuleName );
+    rtl::OUString& ProjectName() { return msProjectName; }
+    void SetProjectName( const rtl::OUString& rPName ) { msProjectName = rPName; }
+    const std::vector<rtl::OUString>& ProjectReferences() { return maPrjReferences; }
+    void AddProjectReference( const rtl::OUString& rProject ) { maPrjReferences.push_back( rProject); }
+    SvStorage* GetStorage() { return xStor; }
 private:
+    std::vector<rtl::OUString> maReferences;
+    std::vector<rtl::OUString> maPrjReferences;
     struct VBAOffset_Impl
     {
         String sName;
@@ -124,6 +130,7 @@
     int ReadVBAProject(const SvStorageRef &rxVBAStorage);
     int DecompressVBA(int index, SvStorageStreamRef &rxVBAStream);
     sal_uInt8 ReadPString(SvStorageStreamRef &xVBAProject, bool bIsUnicode);
+    rtl::OUString msProjectName;
 };
 
 #endif
Index: svx/source/form/fmtools.cxx
===================================================================
--- svx/source/form/fmtools.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/form/fmtools.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -103,7 +103,7 @@
 #include <comphelper/extract.hxx>
 #include <comphelper/uno3.hxx>
 #include <connectivity/dbexception.hxx>
-#include <comphelper/extract.hxx>
+#include <comphelper/evtmethodhelper.hxx>
 #include <cppuhelper/typeprovider.hxx>
 #include <algorithm>
 #include <rtl/logfile.hxx>
@@ -720,37 +720,6 @@
 	return ::rtl::OUString();
 }
 //------------------------------------------------------------------------------
-Sequence< ::rtl::OUString> getEventMethods(const Type& type)
-{
-    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "svx", "Ocke.Janssen@sun.com", "fmtools::getEventMethods" );
-	typelib_InterfaceTypeDescription *pType=0;
-	type.getDescription( (typelib_TypeDescription**)&pType);
-
-	if(!pType)
-		return Sequence< ::rtl::OUString>();
-
-	Sequence< ::rtl::OUString> aNames(pType->nMembers);
-	::rtl::OUString* pNames = aNames.getArray();
-	for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
-	{
-		// the decription reference
-		typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
-		// the description for the reference
-		typelib_TypeDescription* pMemberDescription = NULL;
-		typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
-		if (pMemberDescription)
-		{
-			typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
-				reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
-			*pNames = pRealMemberDescription->pMemberName;
-		}
-	}
-	typelib_typedescription_release( (typelib_TypeDescription *)pType );
-	return aNames;
-}
-
-
-//------------------------------------------------------------------------------
 void TransferEventScripts(const Reference< ::com::sun::star::awt::XControlModel>& xModel, const Reference< ::com::sun::star::awt::XControl>& xControl,
 	const Sequence< ::com::sun::star::script::ScriptEventDescriptor>& rTransferIfAvailable)
 {
@@ -824,7 +793,8 @@
 					continue;
 
 				// now check the methods
-				Sequence< ::rtl::OUString> aMethodsNames = getEventMethods(*pCurrentListeners);
+				Sequence< ::rtl::OUString> aMethodsNames = ::comphelper::getEventMethodsForType(*pCurrentListeners);
+
 				const ::rtl::OUString* pMethodsNames = aMethodsNames.getConstArray();
 				for (k=0; k<aMethodsNames.getLength(); ++k, ++pMethodsNames)
 				{
Index: svx/source/form/fmscriptingenv.cxx
===================================================================
--- svx/source/form/fmscriptingenv.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/form/fmscriptingenv.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -39,6 +39,8 @@
 #include <com/sun/star/container/XHierarchicalNameAccess.hpp>
 #include <com/sun/star/reflection/XInterfaceMethodTypeDescription.hpp>
 #include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/lang/EventObject.hpp>
+#include <com/sun/star/awt/XControl.hpp>
 /** === end UNO includes === **/
 #include <tools/diagnose_ex.h>
 #include <cppuhelper/implbase1.hxx>
@@ -74,6 +76,9 @@
     using ::com::sun::star::uno::Exception;
     using ::com::sun::star::uno::Sequence;
     using ::com::sun::star::uno::XInterface;
+    using ::com::sun::star::lang::EventObject;
+    using ::com::sun::star::awt::XControl;
+    using ::com::sun::star::beans::XPropertySet;
 	/** === end UNO using === **/
 
     class FormScriptingEnvironment;
@@ -236,6 +241,11 @@
     void SAL_CALL FormScriptListener::firing( const ScriptEvent& _rEvent ) throw (RuntimeException)
     {
         ::osl::ClearableMutexGuard aGuard( m_aMutex );
+       static const ::rtl::OUString vbaInterOp =
+           ::rtl::OUString::createFromAscii("VBAInterop");
+       if ( _rEvent.ScriptType.equals(vbaInterOp) )
+           return; // not handled here
+	
         if ( impl_isDisposed_nothrow() )
             return;
 
@@ -411,8 +421,19 @@
         {
             Sequence< sal_Int16 > aOutArgsIndex;
             Sequence< Any > aOutArgs;
-
-            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs );
+            EventObject aEvent;
+            Any aCaller;
+            if ( ( _rArguments.getLength() > 0 ) && ( _rArguments[ 0 ] >>= aEvent ) )
+            {
+                try
+                {
+                    Reference< XControl > xControl( aEvent.Source, UNO_QUERY_THROW );
+                    Reference< XPropertySet > xProps( xControl->getModel(), UNO_QUERY_THROW );
+                    aCaller = xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Name") ) );
+                }
+                catch( Exception& ) {}
+            }
+            m_rObjectShell.CallXScript( m_sScriptCode, _rArguments, _rSynchronousResult, aOutArgsIndex, aOutArgs, true, aCaller.hasValue() ? &aCaller : 0 );
         }
 
         //................................................................
Index: svx/source/form/makefile.mk
===================================================================
--- svx/source/form/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/form/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -44,6 +44,10 @@
 
 # --- Files --------------------------------------------------------
 
+.IF "$(ENABLE_VBA)"=="YES"
+	CDEFS+=-DENABLE_VBA
+.ENDIF
+
 SRS1NAME=form
 SRC1FILES= \
 	fmexpl.src 		\
Index: svx/source/form/fmundo.cxx
===================================================================
--- svx/source/form/fmundo.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/form/fmundo.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -87,6 +87,90 @@
 using namespace ::com::sun::star::form::binding;
 using namespace ::svxform;
 
+
+#include <com/sun/star/script/XScriptListener.hdl>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+typedef cppu::WeakImplHelper1< XScriptListener > ScriptEventListener_BASE;
+class ScriptEventListenerWrapper : public ScriptEventListener_BASE
+{
+public:
+	ScriptEventListenerWrapper( FmFormModel& _rModel) throw ( RuntimeException ) : pModel(&_rModel) 
+	{
+		Reference < XPropertySet > xProps(
+			::comphelper::getProcessServiceFactory(), UNO_QUERY );
+		if ( xProps.is() )
+		{
+			Reference< XComponentContext > xCtx( xProps->getPropertyValue(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), UNO_QUERY );
+			if ( xCtx.is() )
+			{
+				Reference< XMultiComponentFactory > xMFac( 
+					xCtx->getServiceManager(), UNO_QUERY );
+				if ( xMFac.is() )
+				{
+					m_vbaListener.set( xMFac->createInstanceWithContext( 
+						rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
+							"ooo.vba.EventListener"  ) ), xCtx ), 
+								UNO_QUERY_THROW );
+				}
+			}
+		}
+	}
+    // XEventListener
+    virtual void SAL_CALL disposing(const EventObject& ) throw( RuntimeException ){}
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const  ScriptEvent& evt) throw(RuntimeException)	
+	{
+		setModel();
+		if ( m_vbaListener.is() )
+		{
+			m_vbaListener->firing( evt );	
+		}
+	}
+
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw( com::sun::star::reflection::InvocationTargetException, RuntimeException)
+	{
+		setModel();
+		if ( m_vbaListener.is() )
+		{
+			return m_vbaListener->approveFiring( evt );	
+		}
+		return Any();	
+	}
+    
+private:
+	void setModel()
+	{
+		Reference< XPropertySet > xProps( m_vbaListener, UNO_QUERY );
+		if ( xProps.is() )
+		{
+			try
+			{
+				SfxObjectShellRef xObjSh = pModel->GetObjectShell();
+				if ( xObjSh.Is() && m_vbaListener.is() )
+				{
+					Any aVal;
+					aVal <<= xObjSh->GetModel();
+					xProps->setPropertyValue( 
+						::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) ), 
+						aVal );
+				}
+			}
+			catch( Exception& e )
+			{
+				//swallow any errors
+			}
+		}
+	}
+    FmFormModel* pModel;
+	Reference< XScriptListener > m_vbaListener;
+
+
+};
+
 //------------------------------------------------------------------------------
 // some helper structs for caching property infos
 //------------------------------------------------------------------------------
@@ -130,6 +214,13 @@
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "svx", "Ocke.Janssen@sun.com", "FmXUndoEnvironment::FmXUndoEnvironment" );
 	DBG_CTOR(FmXUndoEnvironment,NULL);
+	try
+	{
+		m_vbaListener =  new ScriptEventListenerWrapper( _rModel );
+	}
+	catch( Exception& )
+	{
+	}
 }
 
 //------------------------------------------------------------------------------
@@ -771,9 +862,17 @@
 	    if ( xManager.is() )
 	    {
             if ( _bStartListening )
+            {
 		        m_pScriptingEnv->registerEventAttacherManager( xManager );
+                if ( m_vbaListener.is() )
+                    xManager->addScriptListener( m_vbaListener );
+            }
             else
+            {
 		        m_pScriptingEnv->revokeEventAttacherManager( xManager );
+                if ( m_vbaListener.is() )
+                    xManager->removeScriptListener( m_vbaListener );
+            }
 		}
 
         // also handle all children of this element
Index: svx/source/inc/fmundo.hxx
===================================================================
--- svx/source/inc/fmundo.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/source/inc/fmundo.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -217,7 +217,7 @@
 
     void    switchListening( const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexContainer >& _rxContainer, bool _bStartListening ) SAL_THROW(());
     void    switchListening( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& _rxObject, bool _bStartListening ) SAL_THROW(());
-
+    ::com::sun::star::uno::Reference< com::sun::star::script::XScriptListener > m_vbaListener;
 public:
 	// Methoden zur Zuordnung von Controls zu Forms,
 	// werden von der Seite und der UndoUmgebung genutzt
Index: svx/inc/svxmsbas.hxx
===================================================================
--- svx/inc/svxmsbas.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/inc/svxmsbas.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -35,6 +35,8 @@
 #include "svx/svxdllapi.h"
 
 #include <sot/storage.hxx>
+#include <map>
+#include <hash_map>
 
 class SfxObjectShell;
 
@@ -53,8 +55,17 @@
  * probably what the user expects to see when viewing the code
  */
 
+typedef std::hash_map< sal_Int32, String >  ObjIdToName;
+
+typedef std::map< String, ObjIdToName >  ControlAttributeInfo;
+
+class VBA_Impl;
+
 class SVX_DLLPUBLIC SvxImportMSVBasic
-{
+{ 
+	ControlAttributeInfo m_ModuleNameToObjIdHash;
+	void extractAttribute( const String& rAttribute, const String& rModName );
+
 public:
 	SvxImportMSVBasic( SfxObjectShell &rDocS, SotStorage &rRoot,
 						BOOL bImportCode = TRUE, BOOL bCopyStorage = TRUE )
@@ -65,33 +76,41 @@
 	// 0 - nothing has done
 	// bit 0 = 1 -> any code is imported to the SO-Basic
 	// bit 1 = 1 -> the VBA - storage is copy to the ObjectShell storage
-	int Import( const String& rStorageName, const String &rSubStorageName,
+	int Import( const String& rStorageName, const String &rSubStorageName, 
 				BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
+	int Import( const String& rStorageName, const String &rSubStorageName, 
+				const std::vector< String >& codeNames, BOOL bAsComment=TRUE, BOOL bStripped=TRUE );
 
 	// only for the export - copy or delete the saved VBA-macro-storage
 	// form the ObjectShell
 	// - returns a warning code if a modified basic exist, in all other
 	//   cases return ERRCODE_NONE.
 	ULONG SaveOrDelMSVBAStorage( BOOL bSaveInto, const String& rStorageName );
-
 	// check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
 	// If it exist, then return the WarningId for loosing the information.
+
+        const ControlAttributeInfo& ControlNameForObjectId(){ return m_ModuleNameToObjIdHash; }
 	static ULONG GetSaveWarningOfMSVBAStorage( SfxObjectShell &rDocS );
 
 	static String GetMSBasicStorageName();
+        rtl::OUString GetVBAProjectName() { return msProjectName; }
 private:
 	SotStorageRef xRoot;
 	SfxObjectShell &rDocSh;
 	BOOL bImport;
 	BOOL bCopy;
 
-	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
-						  const String &rSubStorageName,
-						  BOOL bAsComment, BOOL bStripped);
+    SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
+                                                  const String &rSubStorageName,
+	                                              const std::vector< String >&,
+                                                  BOOL bAsComment, BOOL bStripped );
 	SVX_DLLPRIVATE bool ImportForms_Impl(const String& rStorageName, 
-		const String &rSubStorageName);
+		const String &rSubStorageName, BOOL bVBAMode );
 	SVX_DLLPRIVATE BOOL CopyStorage_Impl( const String& rStorageName,
 						   const String &rSubStorageName);
+        rtl::OUString msProjectName;
+	SVX_DLLPRIVATE BOOL ImportCode_Impl( VBA_Impl&, const std::vector< String >&, BOOL, BOOL );
+	SVX_DLLPRIVATE bool ImportForms_Impl( VBA_Impl&, const String&, const String&, BOOL);
 };
 
 #endif
Index: svx/inc/svx/escherex.hxx
===================================================================
--- svx/inc/svx/escherex.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/inc/svx/escherex.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -47,6 +47,7 @@
 #include <com/sun/star/drawing/Hatch.hpp>
 #include <svx/msdffdef.hxx>
 #include "svx/svxdllapi.h"
+#include <memory>
 
 		/*Record Name       FBT-Value   Instance                  Contents                                                          Wrd Exl PPt Ver*/
 // In der Mickysoft-Doku heissen die msofbt... statt ESCHER_...
@@ -1306,6 +1307,19 @@
 									const Rectangle& rRect ) = 0;
 };
 
+class InteractionInfo
+{
+	bool 			mbHasInteraction;
+	std::auto_ptr<SvMemoryStream>		mpHyperlinkRecord;
+	InteractionInfo();
+public:
+	InteractionInfo( SvMemoryStream* pStream, bool bInteraction ) : mbHasInteraction( bInteraction )
+	{
+		mpHyperlinkRecord.reset( pStream );
+	}
+	bool	hasInteraction() { return mbHasInteraction; }
+	const std::auto_ptr< SvMemoryStream >&	getHyperlinkRecord() { return mpHyperlinkRecord; }
+};
 
 class EscherExHostAppData
 {
@@ -1313,14 +1327,17 @@
 		EscherExClientAnchor_Base*	pClientAnchor;
 		EscherExClientRecord_Base*	pClientData;
 		EscherExClientRecord_Base*	pClientTextbox;
+		InteractionInfo*		pInteractionInfo;
 		// ignore single shape if entire pages are written
 		BOOL						bDontWriteShape;
 
 public:
 		EscherExHostAppData() : pClientAnchor(0), pClientData(0),
-								pClientTextbox(0), bDontWriteShape(FALSE)
+								pClientTextbox(0), pInteractionInfo(0), bDontWriteShape(FALSE)
 		{}
 
+		void SetInteractionInfo( InteractionInfo* p )
+			{ pInteractionInfo = p; }
 		void SetClientAnchor( EscherExClientAnchor_Base* p )
 			{ pClientAnchor = p; }
 		void SetClientData( EscherExClientRecord_Base* p )
@@ -1329,6 +1346,8 @@
 			{ pClientTextbox = p; }
 		void SetDontWriteShape( BOOL b )
 			{ bDontWriteShape = b; }
+		InteractionInfo* GetInteractionInfo() const
+			{ return pInteractionInfo; }
 		EscherExClientAnchor_Base* GetClientAnchor() const
 			{ return pClientAnchor; }
 		EscherExClientRecord_Base* GetClientData() const
Index: svx/inc/svx/msocximex.hxx
===================================================================
--- svx/inc/svx/msocximex.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/inc/svx/msocximex.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -32,6 +32,7 @@
 
 #include <sot/storage.hxx>
 #include <tools/debug.hxx>
+#include <com/sun/star/graphic/XGraphicObject.hpp>
 
 //!! no such defines in global namespaces - it will break other existing code that uses the same define!!
 //#ifndef C2U
@@ -290,7 +291,10 @@
 	bool mbVisible;
 	UniString sName;
 	UniString msToolTip;
+	UniString msParentName;
 	OCX_FontData aFontData;
+    rtl::OUString msCtrlSource;
+    rtl::OUString msRowSource;
         SfxObjectShell *pDocSh;
 protected:
 
@@ -327,14 +331,13 @@
     nMultiState(0), nValueLen(0), nCaptionLen(0), nVertPos(1), nHorzPos(7),
 	nSpecialEffect(2), nIcon(0), nPicture(0), nAccelerator(0), nGroupNameLen(0),
 	pValue(0), pCaption(0), pGroupName(0), nIconLen(0), pIcon(0),
-    nPictureLen(0), pPicture(0) {}
+    nPictureLen(0) {}
 
 	~OCX_ModernControl() {
 		if (pValue) delete[] pValue;
 		if (pCaption) delete[] pCaption;
 		if (pGroupName) delete[] pGroupName;
 		if (pIcon) delete[] pIcon;
-		if (pPicture) delete[] pPicture;
 	}
 	sal_Bool Read(SotStorageStream *pS);
 
@@ -415,7 +418,8 @@
 
 	sal_uInt8 pPictureHeader[20];
 	sal_uInt32 nPictureLen;
-	sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
 };
 
@@ -464,6 +468,7 @@
 
         bool bAutoSize;
         ::rtl::OUString sImageUrl;
+		com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
         sal_Bool Read(SotStorageStream *pS);
 
 	using OCX_Control::Import; // to not hide the other two import methods
@@ -488,6 +493,8 @@
 
     ::rtl::OUString cName;
     ::rtl::OUString controlTip;
+    ::rtl::OUString sCtrlSource;
+    ::rtl::OUString sRowSource;
 
     sal_uInt32 nTop;
     sal_uInt32 nLeft;
@@ -502,54 +509,8 @@
 typedef std::vector<OCX_Control*>::const_iterator CtrlIteratorConst;
 typedef std::vector<OCX_Control*>  CtrlList;
 
-
-
-class RBGroup
-{
-    public:
-    RBGroup():mRBGroupPos(0){}
-    RBGroup(sal_uInt16& groupPos ):mRBGroupPos(groupPos){}
-    sal_Int16 tabPos() const { return mRBGroupPos; }
-    std::vector<OCX_Control*>::size_type numControls()
-    { return mpControls.size(); }
-    std::vector<OCX_Control*>& controls() { return mpControls; }
-
-    void add(OCX_Control* pRB);
-    private:
-    sal_uInt16 mRBGroupPos;
-    std::vector<OCX_Control*> mpControls;
-};
-
-typedef ::std::hash_map < ::rtl::OUString, RBGroup*, ::rtl::OUStringHash,
-    ::std::equal_to< ::rtl::OUString > > RBGroupHash;
-typedef std::vector<RBGroup*>::iterator GroupIterator;
-
 class OCX_OptionButton;
 
-class RBGroupManager
-{
-public:
-    RBGroupManager( String& defaultName );
-    ~RBGroupManager();
-
-    CtrlList insertGroupsIntoControlList( const CtrlList& sourceList );
-    void addRadioButton( OCX_OptionButton* pRButton );
-private:
-
-    void addSeperator( std::vector< OCX_Control* >& dest );
-    void copyList( std::vector< OCX_Control* >& src,
-                  std::vector< OCX_Control* >& dest,
-                  bool addGroupSeperator );
-
-    RBGroupHash rbGroups;
-    String mSDefaultName;
-    std::vector< RBGroup* > groupList;
-    sal_uInt16 numRadioButtons;
-};
-
-
-
-
 class OCX_ContainerControl : public OCX_Control
 {
 public:
@@ -575,8 +536,9 @@
         SotStorageStreamRef getContainerStream() { return mContainerStream; }
 
         virtual void ProcessControl( OCX_Control* pControl, SvStorageStream* pS, ContainerRecord& rec );
-        bool createFromContainerRecord( const ContainerRecord& record,
+        bool createFromContainerRecord( ContainerRecord& record,
             OCX_Control*& );
+        SotStorageStreamRef getContainedControlsStream(){ return mContainedControlsStream; }
 protected:
         // This class not meant to be instantiated
         // needs to be subclassed
@@ -588,10 +550,10 @@
             OCX_Control* pParent = NULL );
         rtl::OUString createSubStreamName( const sal_uInt32& subStorageID );
 
-        RBGroupManager rbGroupMgr;
         com::sun::star::uno::Reference<
                 com::sun::star::container::XNameContainer > mxParent;
 	std::vector<OCX_Control*> mpControls;
+        std::hash_map<sal_uInt16, sal_uInt16> mActiveXIDMap;
         SotStorageRef mContainerStorage;
         SotStorageStreamRef mContainerStream;
         SotStorageStreamRef mContainedControlsStream;
@@ -859,7 +821,6 @@
 	{
 		delete[] pCaption;
 		delete[] pIcon;
-		delete[] pPicture;
 	}
 
 	virtual sal_Bool Read(SvStorageStream *pS);
@@ -923,7 +884,8 @@
 
 	sal_uInt8 pPictureHeader[20];
 	sal_uInt32  nPictureLen;
-	sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 private:
         com::sun::star::uno::Reference<
                 com::sun::star::uno::XComponentContext> mxCtx;
@@ -962,7 +924,8 @@
 	OCX_OptionButton() : OCX_ModernControl(rtl::OUString::createFromAscii("OptionButton"))
 	{
 		msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
-		msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlRadioButtonModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.RadioButton");
         mnBackColor = 0x80000005L;
         mnForeColor = 0x80000008L;
         aFontData.SetHasAlign(TRUE);
@@ -1063,7 +1026,7 @@
 public:
 	OCX_ComboBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ComboBox")){
 		msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
-	        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlComboBoxModel");
+	        msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ComboBox");
 		mnBackColor = 0x80000005;
 		mnForeColor = 0x80000008;
 		nBorderColor = 0x80000006;
@@ -1088,7 +1051,8 @@
 public:
 	OCX_ListBox() : OCX_ModernControl(rtl::OUString::createFromAscii("ListBox")){
 		msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
-		msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		//msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlListBoxModel");
+		msDialogType = rtl::OUString::createFromAscii("com.sun.star.form.component.ListBox");
 		mnBackColor = 0x80000005;
 		mnForeColor = 0x80000008;
 		nBorderColor = 0x80000006;
@@ -1116,7 +1080,7 @@
 	fEnabled(1), fLocked(0), fBackStyle(1), fWordWrap(0), fAutoSize(0),
         nCaptionLen(0), nVertPos(1), nHorzPos(7), nMousePointer(0), nPicture(0),
         nAccelerator(0), nIcon(0), pCaption(0), nIconLen(0), pIcon(0), nPictureLen(0),
-        pPicture(0), mbTakeFocus( true )
+        mbTakeFocus( true )
 	{
 	        msFormType = rtl::OUString::createFromAscii("com.sun.star.form.component.CommandButton");
 	        msDialogType = rtl::OUString::createFromAscii("com.sun.star.awt.UnoControlButtonModel");
@@ -1127,7 +1091,6 @@
 	~OCX_CommandButton() {
 		if (pCaption) delete[] pCaption;
 		if (pIcon) delete[] pIcon;
-		if (pPicture) delete[] pPicture;
 	}
 	sal_Bool Read(SotStorageStream *pS);
 
@@ -1170,7 +1133,8 @@
 
 	sal_uInt8 pPictureHeader[20];
 	sal_uInt32  nPictureLen;
-	sal_uInt8 *pPicture;
+    ::rtl::OUString sImageUrl;
+	com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicObject> mxGrfObj;
 
     bool        mbTakeFocus;
 
@@ -1288,7 +1252,7 @@
 
 	sal_uInt8 pPictureHeader[20];
 	sal_uInt32  nPictureLen;
-	sal_uInt8 *pPicture;
+ 	sal_uInt8 *pPicture;
 
 	static OCX_Control *Create() { return new OCX_Label;}
 
Index: svx/inc/svx/msvbahelper.hxx
===================================================================
--- svx/inc/svx/msvbahelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ svx/inc/svx/msvbahelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: 
+ * $Revision: 
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef _MSVBAHELPER_HXX
+#define _MSVBAHELPER_HXX
+
+#include <sfx2/objsh.hxx>
+#include "svx/svxdllapi.h"
+
+namespace ooo { namespace vba 
+{
+    class SVX_DLLPUBLIC VBAMacroResolvedInfo
+    {
+        SfxObjectShell* mpDocContext;
+        bool mbFound;
+        String msResolvedMacro;
+        public:
+        VBAMacroResolvedInfo() : mpDocContext(NULL), mbFound( false ){}
+        void SetResolved( bool bRes ) { mbFound = bRes; }
+        bool IsResolved() { return mbFound; }
+        void SetMacroDocContext(SfxObjectShell* pShell )  { mpDocContext = pShell; }
+        SfxObjectShell* MacroDocContext() { return mpDocContext; }
+        String ResolvedMacro() { return msResolvedMacro; }
+        void SetResolvedMacro(const String& sMacro ) { msResolvedMacro = sMacro; }
+    };
+
+    SVX_DLLPUBLIC String makeMacroURL( const String& sMacroName );
+    SVX_DLLPUBLIC  VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUString& sMod, bool bSearchGlobalTemplates = false );
+    SVX_DLLPUBLIC sal_Bool executeMacro( SfxObjectShell* pShell, const String& sMacroName, com::sun::star::uno::Sequence< com::sun::star::uno::Any >& aArgs, com::sun::star::uno::Any& aRet, const com::sun::star::uno::Any& aCaller );
+} }
+
+#endif
Index: svx/inc/svx/mstoolbar.hxx
===================================================================
--- svx/inc/svx/mstoolbar.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ svx/inc/svx/mstoolbar.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,334 @@
+#ifndef _MSTOOLBAR_HXX
+#define _MSTOOLBAR_HXX
+#include "svx/svxdllapi.h"
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/ui/ImageType.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vcl/bitmap.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+namespace css = ::com::sun::star;
+
+class TBCHeader;
+
+
+class MSOCommandConvertor
+{
+public:
+    virtual ~MSOCommandConvertor() {}
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd ) = 0; 
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID ) = 0; 
+};
+
+class SfxObjectShell;
+
+class SVX_DLLPUBLIC CustomToolBarImportHelper
+{
+    struct iconcontrolitem
+    {
+        rtl::OUString sCommand;
+        css::uno::Reference< css::graphic::XGraphic > image;
+    };
+    std::vector< iconcontrolitem > iconcommands;
+    std::auto_ptr< MSOCommandConvertor > pMSOCmdConvertor;
+    css::uno::Reference< css::ui::XUIConfigurationManagerSupplier > m_xCfgSupp;
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xAppCfgMgr;
+    SfxObjectShell& mrDocSh;
+    void ScaleImage( css::uno::Reference< css::graphic::XGraphic >& xGraphic, long nNewSize );
+public:
+    CustomToolBarImportHelper( SfxObjectShell& rDocSh, const css::uno::Reference< css::ui::XUIConfigurationManager >& rxAppCfgMgr );
+
+    void setMSOCommandMap( MSOCommandConvertor* pCnvtr ) { pMSOCmdConvertor.reset( pCnvtr ); }
+    css::uno::Reference< css::ui::XUIConfigurationManager > getCfgManager();
+    css::uno::Reference< css::ui::XUIConfigurationManager > getAppCfgManager();
+
+
+    css::uno::Any createCommandFromMacro( const rtl::OUString& sCmd );
+
+    void addIcon( const css::uno::Reference< css::graphic::XGraphic >& xImage, const rtl::OUString& sString );
+    void applyIcons();
+    rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID );
+    SfxObjectShell& GetDocShell() { return mrDocSh; }
+    void showToolbar( const rtl::OUString& rName );
+    bool createMenu( const rtl::OUString& rName, const css::uno::Reference< css::container::XIndexAccess >& xMenuDesc, bool bPersist );
+};
+
+class SVX_DLLPUBLIC TBBase
+{
+friend class Indent;
+    static int nIndent; // num spaces to indent before printing 
+protected:
+    void indent_printf(FILE* fp, const char* format, ... );
+    sal_uInt32 nOffSet; // usually for debug we can store the offset in the stream to this record
+public:
+    TBBase() : nOffSet( 0 ) {}
+    virtual ~TBBase(){}
+    rtl::OUString readUnicodeString( SvStream* pS, sal_Int32 nChars );
+
+    virtual bool Read(SvStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+    sal_uInt32 GetOffset() { return nOffSet; }
+};
+
+class Indent
+{
+public:
+    Indent( bool binit = false ) 
+    { 
+        if ( binit )
+            init();
+        else
+            TBBase::nIndent = TBBase::nIndent + 2; 
+    }
+    ~Indent() { TBBase::nIndent = TBBase::nIndent - 2; }
+    void init() { TBBase::nIndent = 0; }
+};
+
+
+class SVX_DLLPUBLIC WString : public TBBase
+{
+    rtl::OUString sString;
+
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SvStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class SVX_DLLPUBLIC TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString getOnAction();
+};
+
+class SVX_DLLPUBLIC TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControlData( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >& );
+    rtl::OUString CustomText() { return customText.getString(); }
+    rtl::OUString DescriptionText() { return descriptionText.getString(); }
+    rtl::OUString Tooltip() { return tooltip.getString(); }
+};
+
+class SVX_DLLPUBLIC TBCBitMap : public TBBase
+{
+friend class TBCBSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+    Bitmap mBitMap;
+    int size;
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    Bitmap& getBitMap(); 
+};
+
+class SVX_DLLPUBLIC TBCMenuSpecific : public TBBase
+{
+    sal_Int32 tbid;
+    boost::shared_ptr< WString > name; //exist only if tbid equals 0x00000001
+public:
+    TBCMenuSpecific();
+    ~TBCMenuSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString Name();
+};
+
+class SVX_DLLPUBLIC TBCCDData : public TBBase
+{
+    sal_Int16 cwstrItems; //Signed integer that specifies the number of items in wstrList. MUST be positive.
+    std::vector< WString > wstrList;  // Zero-based index array of WString structures. Number of elements MUST be equal to cwstrItems.
+    sal_Int16 cwstrMRU; // Signed integer that specifies the number of most recently used string
+    sal_Int16 iSel ; // Signed integer that specifies the zero-based index of the selected item in the wstrList field. MUST be equal to 0xFFFF (-1) or greater than or equal to 0x0000.
+    sal_Int16 cLines; // Signed integer that specifies the suggested number of lines that the toolbar control will display at any time when displaying the elements of wstrList of available items. 
+    sal_Int16 dxWidth; // Signed integer that specifies the width in pixels that the interior of the dropdown has. This excludes the width of the toolbar control border and scroll bar.
+    WString wstrEdit; //Structure of type WString. Editable text for editable area of the ComboBox toolbar control.
+
+public:
+    TBCCDData();
+    ~TBCCDData();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCComboDropdownSpecific : public TBBase
+{
+    boost::shared_ptr< TBCCDData > data;
+public:
+    TBCComboDropdownSpecific( const TBCHeader& header );
+    TBCComboDropdownSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    boost::shared_ptr< TBCBitMap > icon; // optional
+    boost::shared_ptr< TBCBitMap > iconMask; // optional
+    boost::shared_ptr< sal_uInt16 > iBtnFace; // optional
+    boost::shared_ptr< WString > wstrAcc; // optional
+   
+public:
+    TBCBSpecific();
+    ~TBCBSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    // #TODO just add a getGraphic member here
+    TBCBitMap* getIcon();
+    TBCBitMap* getIconMask();
+    sal_uInt16* getBtnFace() { return iBtnFace.get(); }
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+class SVX_DLLPUBLIC TBCHeader : public TBBase
+{
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    boost::shared_ptr< sal_uInt16 > width;  //optional
+    boost::shared_ptr< sal_uInt16 > height; //optional
+
+public:
+    TBCHeader();
+    ~TBCHeader();
+    sal_uInt8 getTct() const { return tct; }
+    sal_uInt16 getTcID() const { return tcid; }
+    bool isVisible() { return !( bFlagsTCR & 0x1 ); }
+    bool isBeginGroup() { return ( bFlagsTCR & 0x2 ); }
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_uInt32 getTbct() { return tbct; };
+};
+
+class SVX_DLLPUBLIC TBCData : public TBBase
+{
+    TBCHeader rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    boost::shared_ptr< TBBase > controlSpecificInfo; // can be one of TBCBSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header );
+    ~TBCData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >&, bool& bBeginGroup, bool bIsMenuBar );
+    TBCGeneralInfo& getGeneralInfo() { return controlGeneralInfo; }
+    TBCMenuSpecific* getMenuSpecific();
+};
+
+class SVX_DLLPUBLIC TB : public TBBase
+{
+    sal_uInt8 bSignature;// Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_uInt8 bVersion; // Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; // Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid;// Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr;// Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault;// Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name
+public:
+    TB();
+    ~TB(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_Int16 getcCL(){ return cCL; }
+    WString& getName(){ return name; }
+    bool IsEnabled();
+    bool IsMenuToolbar(){ return ( ( ltbtr & 0x2000000 ) == 0x2000000 ); }
+    bool NeedsPositioning();
+};
+
+class SVX_DLLPUBLIC SRECT : public TBBase
+{
+public:
+    SRECT() : left(0), top(0), right(0), bottom(0) {}
+    sal_Int16 left;
+    sal_Int16 top;
+    sal_Int16 right;
+    sal_Int16 bottom;
+    bool Read( SvStream* pS ) { *pS >> left >> top >> right >> bottom; return true; }
+    void Print( FILE* fo );
+};
+
+typedef cppu::WeakImplHelper1< css::container::XIndexContainer > PropertyValueIndexContainer_BASE;
+
+class SVX_DLLPUBLIC TBVisualData : public TBBase
+{
+    sal_Int8 tbds;
+    sal_Int8 tbv;
+    sal_Int8 tbdsDock;
+    sal_Int8 iRow;
+
+    SRECT rcDock;
+    SRECT rcFloat;
+
+public:
+    TBVisualData();
+    ~TBVisualData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+#endif
Index: svx/prj/d.lst
===================================================================
--- svx/prj/d.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ svx/prj/d.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -658,5 +658,7 @@
 ..\inc\svx\selectioncontroller.hxx %_DEST%\inc%_EXT%\svx\selectioncontroller.hxx
 ..\inc\svx\helperhittest3d.hxx %_DEST%\inc%_EXT%\svx\helperhittest3d.hxx
 ..\inc\svx\optimprove.hxx %_DEST%\inc%_EXT%\svx\optimprove.hxx
+..\inc\svx\mstoolbar.hxx %_DEST%\inc%_EXT%\svx\mstoolbar.hxx
+..\inc\svx\msvbahelper.hxx %_DEST%\inc%_EXT%\svx\msvbahelper.hxx
 
 ..\%__SRC%\bin\*-layout.zip %_DEST%\pck%_EXT%\*.*
Index: forms/source/component/RadioButton.hxx
===================================================================
--- forms/source/component/RadioButton.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/RadioButton.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -87,6 +87,8 @@
             our mutex is aquired exactly once
     */
     void    setNewAggregateState( const ::com::sun::star::uno::Any& _rValue );
+
+    void setControlSource();
 };
 
 //==================================================================
Index: forms/source/component/FormComponent.cxx
===================================================================
--- forms/source/component/FormComponent.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/FormComponent.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -2754,8 +2754,8 @@
     OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::setValueBinding: How did you reach this method?" );
         // the interface for this method should not have been exposed if we do not
         // support binding to external data
-
-    if ( !impl_approveValueBinding_nolock( _rxBinding ) )
+    // allow reset
+    if ( _rxBinding.is() && !impl_approveValueBinding_nolock( _rxBinding ) )
     {
         throw IncompatibleTypesException(
             FRM_RES_STRING( RID_STR_INCOMPATIBLE_TYPES ),
Index: forms/source/component/GroupManager.hxx
===================================================================
--- forms/source/component/GroupManager.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/GroupManager.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -220,6 +220,8 @@
 	void getGroup(sal_Int32 nGroup, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup, ::rtl::OUString& Name);
 	void getGroupByName(const ::rtl::OUString& Name, ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> >& _rGroup);
 	::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel> > getControlModels();
+
+	static ::rtl::OUString GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent );
 };
 
 
Index: forms/source/component/ListBox.cxx
===================================================================
--- forms/source/component/ListBox.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/ListBox.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -1549,6 +1549,8 @@
     void SAL_CALL OListBoxControl::itemStateChanged(const ItemEvent& _rEvent) throw(RuntimeException)
     {
         // forward this to our listeners
+        Reference< XChild > xChild( getModel(), UNO_QUERY );
+        if ( xChild.is() && xChild->getParent().is() )
         {
             ::osl::MutexGuard aGuard( m_aMutex );
             if ( m_aItemListeners.getLength() )
@@ -1561,6 +1563,8 @@
 		        m_pItemBroadcaster->addEvent( new ItemEventDescription( _rEvent ), this );
             }
         }
+        else
+            m_aItemListeners.notifyEach( &XItemListener::itemStateChanged, _rEvent );
 
         // and do the handling for the ChangeListeners
         ::osl::ClearableMutexGuard aGuard(m_aMutex);
Index: forms/source/component/RadioButton.cxx
===================================================================
--- forms/source/component/RadioButton.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/RadioButton.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -31,6 +31,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_forms.hxx"
 #include "RadioButton.hxx"
+#include "GroupManager.hxx"
 #include "property.hxx"
 #ifndef _FRM_PROPERTY_HRC_
 #include "property.hrc"
@@ -122,6 +123,7 @@
 	m_nClassId = FormComponentType::RADIOBUTTON;
 	m_aLabelServiceName = FRM_SUN_COMPONENT_GROUPBOX;
     initValueProperty( PROPERTY_STATE, PROPERTY_ID_STATE );
+	startAggregatePropertyListening( PROPERTY_GROUP_NAME );
 }
 
 //------------------------------------------------------------------
@@ -169,7 +171,11 @@
 void ORadioButtonModel::SetSiblingPropsTo(const ::rtl::OUString& rPropName, const Any& rValue)
 {
 	// mein Name
-	::rtl::OUString sMyName(m_aName);
+    ::rtl::OUString sMyGroup;
+    if (hasProperty(PROPERTY_GROUP_NAME, this))
+        this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sMyGroup;
+    if (sMyGroup.getLength() == 0)
+        sMyGroup = m_aName;
 
 	// meine Siblings durchiterieren
 	Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
@@ -177,8 +183,9 @@
 	{
 		Reference<XPropertySet> xMyProps;
 		query_interface(static_cast<XWeak*>(this), xMyProps);
-		::rtl::OUString	sCurrentName;
-		for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+		::rtl::OUString	sCurrentGroup;
+		sal_Int32 nNumSiblings = xIndexAccess->getCount();
+		for (sal_Int32 i=0; i<nNumSiblings; ++i)
 		{
 			Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
 			if (!xSiblingProperties.is())
@@ -195,8 +202,8 @@
 				continue;
 
 			// das 'zur selben Gruppe gehoeren' wird am Namen festgemacht
-			xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sCurrentName;
-			if (sCurrentName == sMyName)
+			sCurrentGroup = OGroupManager::GetGroupName( xSiblingProperties );
+			if (sCurrentGroup == sMyGroup)
 				xSiblingProperties->setPropertyValue(rPropName, rValue);
 		}
 	}
@@ -223,40 +230,7 @@
 	// die andere Richtung : wenn sich mein Name aendert ...
 	if (nHandle == PROPERTY_ID_NAME)
 	{
-		// ... muss ich testen, ob ich Siblings mit dem selben Namen habe, damit ich deren ControlSource uebernehmen kann
-		Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
-		if (xIndexAccess.is())
-		{
-			::rtl::OUString			sName;
-			::rtl::OUString			sControlSource;
-
-			Reference<XPropertySet> xMyProps;
-			query_interface(static_cast<XWeak*>(this), xMyProps);
-			for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
-			{
-				Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
-				if (!xSiblingProperties.is())
-					continue;
-
-				if (xMyProps == xSiblingProperties)
-					// nur wenn ich nicht mich selber gefunden habe
-					continue;
-
-				sal_Int16 nType = 0;
-				xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
-				if (nType != FormComponentType::RADIOBUTTON)
-					// nur Radio-Buttons
-					continue;
-
-				xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sName;
-				// Control, das zur gleichen Gruppe gehoert ?
-				if (rValue == sName)
-				{
-					setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
-					break;
-				}
-			}
-		}
+        setControlSource();
 	}
 
 	if (nHandle == PROPERTY_ID_DEFAULT_STATE)
@@ -274,6 +248,52 @@
 	}
 }
 
+void ORadioButtonModel::setControlSource()
+{
+    Reference<XIndexAccess> xIndexAccess(getParent(), UNO_QUERY);
+    if (xIndexAccess.is())
+    {
+        ::rtl::OUString sName, sGroupName;
+
+        if (hasProperty(PROPERTY_GROUP_NAME, this))
+            this->getPropertyValue(PROPERTY_GROUP_NAME) >>= sGroupName;
+        this->getPropertyValue(PROPERTY_NAME) >>= sName;
+
+        Reference<XPropertySet> xMyProps;
+        query_interface(static_cast<XWeak*>(this), xMyProps);
+        for (sal_Int32 i=0; i<xIndexAccess->getCount(); ++i)
+        {
+            Reference<XPropertySet>	xSiblingProperties(*(InterfaceRef*)xIndexAccess->getByIndex(i).getValue(), UNO_QUERY);
+            if (!xSiblingProperties.is())
+                continue;
+
+            if (xMyProps == xSiblingProperties)
+                // nur wenn ich nicht mich selber gefunden habe
+                continue;
+
+            sal_Int16 nType = 0;
+            xSiblingProperties->getPropertyValue(PROPERTY_CLASSID) >>= nType;
+            if (nType != FormComponentType::RADIOBUTTON)
+                // nur Radio-Buttons
+                continue;
+
+            ::rtl::OUString sSiblingName, sSiblingGroupName;
+            if (hasProperty(PROPERTY_GROUP_NAME, xSiblingProperties))
+                xSiblingProperties->getPropertyValue(PROPERTY_GROUP_NAME) >>= sSiblingGroupName;
+            xSiblingProperties->getPropertyValue(PROPERTY_NAME) >>= sSiblingName;
+
+            if ((sGroupName.getLength() == 0 && sSiblingGroupName.getLength() == 0 &&   // (no group name
+                 sName == sSiblingName) ||                                              //  names match) or
+                (sGroupName.getLength() != 0 && sSiblingGroupName.getLength() != 0 &&   // (have group name
+                 sGroupName == sSiblingGroupName))                                      //  they match)
+            {
+                setPropertyValue(PROPERTY_CONTROLSOURCE, xSiblingProperties->getPropertyValue(PROPERTY_CONTROLSOURCE));
+                break;
+            }
+        }
+    }
+}
+
 //------------------------------------------------------------------------------
 void ORadioButtonModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
@@ -363,6 +383,13 @@
 			SetSiblingPropsTo( PROPERTY_STATE, aZero );
 		}
 	}
+    else if ( _rEvent.PropertyName.equals( PROPERTY_GROUP_NAME ) )
+    {
+        setControlSource();
+        // Can't call OReferenceValueComponent::_propertyChanged(), as it
+        // doesn't know what to do with the GroupName property.
+        return;
+    }
 
     OReferenceValueComponent::_propertyChanged( _rEvent );
 }
Index: forms/source/component/GroupManager.cxx
===================================================================
--- forms/source/component/GroupManager.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/component/GroupManager.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -127,14 +127,13 @@
     ,m_xControlModel(rxSet,UNO_QUERY)
     ,m_nPos( nInsertPos )
     ,m_nTabIndex(0)
+    ,m_aName( OGroupManager::GetGroupName( rxSet ) )
 {
 	if (m_xComponent.is())
 	{
 		if (hasProperty( PROPERTY_TABINDEX, m_xComponent ) )
 			// Indices kleiner 0 werden wie 0 behandelt
 			m_nTabIndex = Max(getINT16(m_xComponent->getPropertyValue( PROPERTY_TABINDEX )) , sal_Int16(0));
-
-		m_xComponent->getPropertyValue( PROPERTY_NAME ) >>= m_aName;
 	}
 }
 
@@ -321,7 +320,8 @@
 		aFind->second.RemoveComponent( _xSet );
 
 		// Wenn Anzahl der Gruppenelemente == 1 ist, Gruppe deaktivieren
-		if ( aFind->second.Count() == 1 )
+		sal_Int32 nCount = aFind->second.Count();
+		if ( nCount == 1 || nCount == 0 )
 		{
 			OActiveGroups::iterator aActiveFind = ::std::find(
                 m_aActiveGroupMap.begin(),
@@ -332,7 +332,7 @@
             {
                 // the group is active. Deactivate it if the remaining component
                 // is *no* radio button
-                if ( !isRadioButton( aFind->second.GetObject( 0 ) ) )
+                if ( nCount == 0 || !isRadioButton( aFind->second.GetObject( 0 ) ) )
 				    m_aActiveGroupMap.erase( aActiveFind );
             }
 		}
@@ -341,6 +341,8 @@
 
 	// Bei Component als PropertyChangeListener abmelden
 	_xSet->removePropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, _xSet))
+		_xSet->removePropertyChangeListener( PROPERTY_GROUP_NAME, this );
 	if (hasProperty(PROPERTY_TABINDEX, _xSet))
 		_xSet->removePropertyChangeListener( PROPERTY_TABINDEX, this );
 }
@@ -351,10 +353,23 @@
 
 	// Component aus Gruppe entfernen
 	::rtl::OUString		sGroupName;
-	if (evt.PropertyName == PROPERTY_NAME)
+	if (hasProperty( PROPERTY_GROUP_NAME, xSet ))
+		xSet->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+	if (evt.PropertyName == PROPERTY_NAME) {
+		if (sGroupName.getLength() > 0)
+			return; // group hasn't changed; ignore this name change.
+		// no GroupName; use Name as GroupNme
 		evt.OldValue >>= sGroupName;
+	}
+	else if (evt.PropertyName == PROPERTY_GROUP_NAME) {
+		evt.OldValue >>= sGroupName;
+		if (sGroupName.getLength() == 0) {
+			// No prior GroupName; fallback to Nme
+			xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		}
+	}
 	else
-		xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+		sGroupName = GetGroupName( xSet );
 
 	removeFromGroupMap(sGroupName,xSet);
 
@@ -437,8 +452,7 @@
 	m_pCompGroup->InsertComponent( xSet );
 
 	// Component in Gruppe aufnehmen
-	::rtl::OUString sGroupName;
-	xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString sGroupName( GetGroupName( xSet ) );
 
 	OGroupArr::iterator aFind = m_aGroupArr.find(sGroupName);
 
@@ -476,6 +490,8 @@
 
 	// Bei Component als PropertyChangeListener anmelden
 	xSet->addPropertyChangeListener( PROPERTY_NAME, this );
+	if (hasProperty(PROPERTY_GROUP_NAME, xSet))
+		xSet->addPropertyChangeListener( PROPERTY_GROUP_NAME, this );
 
     // Tabindex muss nicht jeder unterstuetzen
 	if (hasProperty(PROPERTY_TABINDEX, xSet))
@@ -492,12 +508,26 @@
 		return;
 
 	// Component aus Gruppe entfernen
-	::rtl::OUString		sGroupName;
-	xSet->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+	::rtl::OUString		sGroupName( GetGroupName( xSet ) );
 
 	removeFromGroupMap(sGroupName,xSet);
 }
 
+::rtl::OUString OGroupManager::GetGroupName( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet> xComponent )
+{
+    if (!xComponent.is())
+        return ::rtl::OUString();
+    ::rtl::OUString sGroupName;
+    if (hasProperty( PROPERTY_GROUP_NAME, xComponent )) {
+        xComponent->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
+        if (sGroupName.getLength() == 0)
+            xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    }
+    else
+        xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
+    return sGroupName;
+}
+
 //.........................................................................
 }	// namespace frm
 //.........................................................................
Index: forms/source/inc/property.hrc
===================================================================
--- forms/source/inc/property.hrc	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/inc/property.hrc	(.../cws/vbasupportdev300)	(revision 277097)
@@ -63,6 +63,7 @@
 #define PROPERTY_ID_INPUT_REQUIRED      (PROPERTY_ID_START + 19)
 #define PROPERTY_ID_WRITING_MODE        (PROPERTY_ID_START + 20)
 #define PROPERTY_ID_CONTEXT_WRITING_MODE    (PROPERTY_ID_START + 21)
+#define PROPERTY_ID_GROUP_NAME          (PROPERTY_ID_START + 22)
     // free
     // free
     // free
@@ -71,7 +72,6 @@
     // free
     // free
     // free
-    // free
 #define PROPERTY_ID_VALUE               (PROPERTY_ID_START + 31)    // INT32
     // free
 #define PROPERTY_ID_FORMATKEY           (PROPERTY_ID_START + 33)    // UINT32
Index: forms/source/inc/frm_strings.hxx
===================================================================
--- forms/source/inc/frm_strings.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/inc/frm_strings.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -100,6 +100,7 @@
     FORMS_CONSTASCII_STRING( PROPERTY_TABINDEX,                 "TabIndex" );
     FORMS_CONSTASCII_STRING( PROPERTY_TAG,                      "Tag" );
     FORMS_CONSTASCII_STRING( PROPERTY_NAME,                     "Name" );
+    FORMS_CONSTASCII_STRING( PROPERTY_GROUP_NAME,               "GroupName" );
     FORMS_CONSTASCII_STRING( PROPERTY_CLASSID,                  "ClassId" );
     FORMS_CONSTASCII_STRING( PROPERTY_FETCHSIZE,                "FetchSize" );
     FORMS_CONSTASCII_STRING( PROPERTY_VALUE,                    "Value" );
Index: forms/source/inc/InterfaceContainer.hxx
===================================================================
--- forms/source/inc/InterfaceContainer.hxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/inc/InterfaceContainer.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -275,6 +275,9 @@
 	void implCheckIndex( const sal_Int32 _nIndex ) SAL_THROW( ( ::com::sun::star::lang::IndexOutOfBoundsException ) );
 
 private:
+	// hack for Vba Events
+	void fakeVbaEventsHack( sal_Int32 _nIndex );
+
 	// the runtime event format has changed from version SO5.2 to OOo
 	enum EventFormat
 	{
Index: forms/source/misc/makefile.mk
===================================================================
--- forms/source/misc/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/misc/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -45,6 +45,7 @@
 # --- Types -------------------------------------
 
 INCPRE+=$(SOLARINCDIR)$/offuh
+INCPRE*=$(INCCOM)$/$(TARGET)
 
 # --- Files -------------------------------------
 
@@ -62,3 +63,12 @@
 
 .INCLUDE : target.mk
 
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+
+$(SLOFILES) : $(MISC)$/$(TARGET).don
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(INCCOM)$/$(TARGET) -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
Index: forms/source/misc/InterfaceContainer.cxx
===================================================================
--- forms/source/misc/InterfaceContainer.cxx	(.../tags/DEV300_m58)	(revision 277097)
+++ forms/source/misc/InterfaceContainer.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -60,13 +60,20 @@
 #include <memory>
 
 //.........................................................................
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/document/XCodeNameQuery.hpp>
+#include <ooo/vba/XVBAToOOEventDescGen.hpp>
+#include <comphelper/processfactory.hxx>
+
 namespace frm
 {
 //.........................................................................
 
+using namespace ::com::sun::star::frame;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::document;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::script;
 using namespace ::com::sun::star::io;
@@ -82,6 +89,89 @@
 	}
 }
 
+bool
+lcl_hasVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents  )
+{
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+			return true;
+	}
+	return false;
+}
+
+Sequence< ScriptEventDescriptor >
+lcl_stripVbaEvents( const Sequence< ScriptEventDescriptor >& sEvents )
+{
+	Sequence< ScriptEventDescriptor > sStripped( sEvents.getLength() );
+	
+	const ScriptEventDescriptor* pDesc = sEvents.getConstArray();
+	const ScriptEventDescriptor* pEnd = ( pDesc + sEvents.getLength() );
+	sal_Int32 nCopied = 0;
+	for ( ; pDesc != pEnd; ++pDesc )
+	{
+		if ( !pDesc->ScriptType.equals( rtl::OUString::createFromAscii( "VBAInterop" ) ) )
+		{
+			sStripped[ nCopied++ ] = *pDesc;
+		}
+	}
+	if ( nCopied )
+		sStripped.realloc( nCopied );
+	return sStripped;
+}
+
+void
+OInterfaceContainer::fakeVbaEventsHack(  sal_Int32 _nIndex )
+{
+	// we are dealing with form controls
+	try
+	{
+		Reference< XFormComponent > xForm( static_cast< XContainer* >(this), UNO_QUERY_THROW );
+		// grand-parent should be the model, no parent ? if not
+		// we'll ignore,  we'll get called back here  anyway )
+		Reference< XChild > xChild(  xForm->getParent(), UNO_QUERY_THROW );
+		Reference< XModel > xDocOwner( xChild->getParent(), UNO_QUERY );
+		OSL_TRACE(" Is DOC ????? %s", xDocOwner.is() ? "true" : "false" );
+		if ( xDocOwner.is() )
+		{
+			bool hasVBABindings = lcl_hasVbaEvents( m_xEventAttacher->getScriptEvents( _nIndex ) );  
+			if ( hasVBABindings )
+			{
+				OSL_TRACE("Has VBA bindings already, returning ");
+				return;
+			}
+			Reference< XMultiServiceFactory > xFac(  comphelper::getProcessServiceFactory(), UNO_QUERY );
+			Reference< XMultiServiceFactory > xDocFac(  xDocOwner, UNO_QUERY );
+			if ( xFac.is() && xDocFac.is() )
+			{
+				try
+				{
+					Reference< ooo::vba::XVBAToOOEventDescGen > xDescSupplier( xFac->createInstance( rtl::OUString::createFromAscii( "ooo.vba.VBAToOOEventDesc" ) ), UNO_QUERY_THROW );
+					Reference< XInterface > xIf( getByIndex( _nIndex ) , UNO_QUERY_THROW );
+					Reference< XCodeNameQuery > xNameQuery(  xDocFac->createInstance( rtl::OUString::createFromAscii( "ooo.vba.VBACodeNameProvider" ) ), UNO_QUERY_THROW );
+					rtl::OUString sCodeName;	
+					sCodeName = xNameQuery->getCodeNameForObject( xIf );
+					Reference< XPropertySet > xProps( xIf, UNO_QUERY );
+					rtl::OUString sServiceName;
+					xProps->getPropertyValue( rtl::OUString::createFromAscii("DefaultControl" ) ) >>= sServiceName;
+
+					Sequence< ScriptEventDescriptor > vbaEvents = xDescSupplier->getEventDescriptions( xFac->createInstance( sServiceName ), sCodeName );
+					// register the vba script events
+					if ( m_xEventAttacher.is() )
+						m_xEventAttacher->registerScriptEvents( _nIndex, vbaEvents );
+				}
+				catch( Exception& e ){ OSL_TRACE("lcl_fakevbaevents - Caught Exception trying to create control eventstuff "); }
+			}
+
+		}
+	}
+	catch( Exception& e )
+	{
+	}
+
+}
 //==================================================================
 //= ElementDescription
 //==================================================================
@@ -739,6 +829,7 @@
 void OInterfaceContainer::implInsert(sal_Int32 _nIndex, const Reference< XPropertySet >& _rxElement,
 	sal_Bool _bEvents, ElementDescription* _pApprovalResult, sal_Bool _bFire ) throw( IllegalArgumentException )
 {
+        OSL_TRACE("OInterfaceContainer::implInsert( %d)", _nIndex );
 	RTL_LOGFILE_CONTEXT( aLogger, "forms::OInterfaceContainer::implInsert" );
 
 	::osl::ClearableMutexGuard aGuard( m_rMutex );
@@ -788,6 +879,23 @@
 	{
 		m_xEventAttacher->insertEntry(_nIndex);
 		m_xEventAttacher->attach( _nIndex, pElementMetaData->xInterface, makeAny( _rxElement ) );
+		// insert fake events?
+		Reference< XEventAttacherManager > xMgr ( pElementMetaData->xInterface, UNO_QUERY );
+		if ( xMgr.is() )
+		{ 
+			OInterfaceContainer* pIfcMgr = dynamic_cast< OInterfaceContainer* >( xMgr.get() );
+			sal_Int32 nLen = pIfcMgr->getCount();
+			for ( sal_Int32 i = 0; (i < nLen) && pIfcMgr ; ++i )
+			{	
+				// add fake events to the control at index i
+				pIfcMgr->fakeVbaEventsHack( i );
+			}	
+		}
+		else
+		{
+			// add fake events to the control at index i
+			fakeVbaEventsHack(  _nIndex );	
+		}
 	}
 
 	// notify derived classes
@@ -1082,20 +1190,29 @@
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvent( sal_Int32 nIndex, const ScriptEventDescriptor& aScriptEvent ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
 	    m_xEventAttacher->registerScriptEvent( nIndex, aScriptEvent );
+            fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::registerScriptEvents( sal_Int32 nIndex, const Sequence< ScriptEventDescriptor >& aScriptEvents ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** registerScriptEvent(s) %d", nIndex);
     if ( m_xEventAttacher.is() )
+    {
     	m_xEventAttacher->registerScriptEvents( nIndex, aScriptEvents );
+        fakeVbaEventsHack( nIndex ); // add fake vba events
+    }
 }
 
 //------------------------------------------------------------------------
 void SAL_CALL OInterfaceContainer::revokeScriptEvent( sal_Int32 nIndex, const ::rtl::OUString& aListenerType, const ::rtl::OUString& aEventMethod, const ::rtl::OUString& aRemoveListenerParam ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("*** revokeScriptEvent %d listenertype %s, eventMethod %s", nIndex, rtl::OUStringToOString( aListenerType, RTL_TEXTENCODING_UTF8 ).getStr(), rtl::OUStringToOString( aEventMethod, RTL_TEXTENCODING_UTF8 ).getStr());
     if ( m_xEventAttacher.is() )
     	m_xEventAttacher->revokeScriptEvent( nIndex, aListenerType, aEventMethod, aRemoveListenerParam );
 }
@@ -1124,9 +1241,16 @@
 //------------------------------------------------------------------------
 Sequence< ScriptEventDescriptor > SAL_CALL OInterfaceContainer::getScriptEvents( sal_Int32 nIndex ) throw(IllegalArgumentException, RuntimeException)
 {
+    OSL_TRACE("getScriptEvents");
     Sequence< ScriptEventDescriptor > aReturn;
     if ( m_xEventAttacher.is() )
+    {
 	    aReturn = m_xEventAttacher->getScriptEvents( nIndex );
+            if ( lcl_hasVbaEvents( aReturn ) )
+            {
+                aReturn = lcl_stripVbaEvents( aReturn );
+            }
+    }
     return aReturn;
 }
 
Index: svtools/source/misc/bindablecontrolhelper.cxx
===================================================================
--- svtools/source/misc/bindablecontrolhelper.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ svtools/source/misc/bindablecontrolhelper.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.cxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "bindablecontrolhelper.hxx"
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XValueBinding.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <com/sun/star/form/binding/XListEntrySource.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+#ifndef C2U
+#define C2U(cChar)	rtl::OUString::createFromAscii(cChar)
+#endif
+
+    using namespace ::com::sun::star;
+
+bool lcl_isNamedRange( const rtl::OUString& sAddress, const uno::Reference< frame::XModel >& xModel, table::CellRangeAddress& aAddress )
+{
+    bool bRes = false;
+    const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+    uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+    try
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xModel, uno::UNO_QUERY_THROW );
+        uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+        xReferrer.set ( xNamed->getByName( sAddress ), uno::UNO_QUERY );
+    }
+    catch( uno::Exception& /*e*/ )
+    {
+        // do nothing
+    }
+    if ( xReferrer.is() )
+    {
+        uno::Reference< sheet::XCellRangeAddressable > xRangeAddressable( xReferrer->getReferredCells(), uno::UNO_QUERY );
+        if ( xRangeAddressable.is() )
+        {
+            aAddress = xRangeAddressable->getRangeAddress();
+            bRes = true;
+        }
+    }
+    return bRes;
+}
+
+
+void
+BindableControlHelper::ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource )
+{
+// XBindable etc.
+    uno::Reference< lang::XMultiServiceFactory > xFac;
+    if ( xModel.is() )
+        xFac.set( xModel, uno::UNO_QUERY );
+    uno::Reference< form::binding::XBindableValue > xBindable( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsCtrlSource.getLength() && xBindable.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellAddressConversion" )), uno::UNO_QUERY );
+         table::CellAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             // we need this service to properly convert XL notation also
+             // Should be easy to extend
+             xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsCtrlSource ) );
+             xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;    
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("BoundCell");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XValueBinding > xBinding( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellValueBinding" ), aArgs ), uno::UNO_QUERY );
+         xBindable->setValueBinding( xBinding );
+    }
+    else if ( xBindable.is() ) // reset it
+        xBindable->setValueBinding( uno::Reference< form::binding::XValueBinding >() );
+    uno::Reference< form::binding::XListEntrySink > xListEntrySink( rObj, uno::UNO_QUERY );
+    if (  xFac.is() && rsRowSource.getLength() && xListEntrySink.is() )
+    {
+         
+         // OOo address structures
+         // RefCell - convert from XL
+         // pretend we converted the imported string address into the
+         // appropriate address structure
+         uno::Reference< beans::XPropertySet > xConvertor( xFac->createInstance( C2U( "com.sun.star.table.CellRangeAddressConversion" )), uno::UNO_QUERY );
+         table::CellRangeAddress aAddress;
+         if ( xConvertor.is() )
+         {
+             if ( !lcl_isNamedRange( rsRowSource, xModel, aAddress ) )
+             {
+                 // we need this service to properly convert XL notation also
+                 // Should be easy to extend
+                 xConvertor->setPropertyValue( C2U( "XL_A1_Representation" ), uno::makeAny( rsRowSource ) );
+                 xConvertor->getPropertyValue( C2U( "Address" ) ) >>= aAddress;
+             }
+         }
+        
+         beans::NamedValue aArg1;
+         aArg1.Name = C2U("CellRange");
+         aArg1.Value <<= aAddress;
+
+         uno::Sequence< uno::Any > aArgs(1);
+         aArgs[ 0 ]  <<= aArg1;
+
+         uno::Reference< form::binding::XListEntrySource > xSource( xFac->createInstanceWithArguments( C2U("com.sun.star.table.CellRangeListSource" ), aArgs ), uno::UNO_QUERY );
+         xListEntrySink->setListEntrySource( xSource );
+    }
+    else if (  xListEntrySink.is() ) // reset
+         xListEntrySink->setListEntrySource( uno::Reference< form::binding::XListEntrySource >()  );
+
+}
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
Index: svtools/source/misc/filterutils.cxx
===================================================================
--- svtools/source/misc/filterutils.cxx	(.../tags/DEV300_m58)	(revision 0)
+++ svtools/source/misc/filterutils.cxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,56 @@
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svtools.hxx"
+#include "filterutils.hxx"
+#include <rtl/ustrbuf.hxx>
+
+namespace svt
+{
+//........................................................................
+
+    using namespace ::com::sun::star;
+
+    rtl::OUString lcl_createStringFromArray( const char* pcCharArr, sal_uInt32 nBufSize, bool bIsCompressed )
+    {
+        rtl::OUStringBuffer aBuffer;
+        if( bIsCompressed )
+        {
+            // buffer contains compressed Unicode, not encoded bytestring
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize );
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar, ++pcCurrChar )
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                aBuffer.setCharAt( nChar, static_cast< unsigned char >( *pcCurrChar ) );
+        }
+        else
+        {
+            // buffer contains Little-Endian Unicode
+            sal_Int32 nStrLen = static_cast< sal_Int32 >( nBufSize ) / 2;
+            aBuffer.setLength( nStrLen );
+            const char* pcCurrChar = pcCharArr;
+            for( sal_Int32 nChar = 0; nChar < nStrLen; ++nChar )
+            {
+                /*  *pcCurrChar may contain negative values and therefore MUST be
+                    casted to unsigned char, before assigned to a sal_Unicode. */
+                sal_Unicode cChar = static_cast< unsigned char >( *pcCurrChar++ );
+                cChar |= (static_cast< unsigned char >( *pcCurrChar++ ) << 8);
+                aBuffer.setCharAt( nChar, cChar );
+            }
+        }
+        return aBuffer.makeStringAndClear();
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, false );
+    }
+
+    rtl::OUString BinFilterUtils::CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize )
+    {
+        return lcl_createStringFromArray( pcCharArr, nBufSize, true );
+    }    
+//........................................................................
+} // namespace svt
+//........................................................................
+
Index: svtools/source/misc/makefile.mk
===================================================================
--- svtools/source/misc/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ svtools/source/misc/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -85,6 +85,8 @@
     $(SLO)$/lockfilecommon.obj     \
     $(SLO)$/sharecontrolfile.obj   \
     $(SLO)$/documentlockfile.obj   \
+    $(SLO)$/bindablecontrolhelper.obj   \
+    $(SLO)$/filterutils.obj   \
     $(SLO)$/langtab.obj
 
 # --- Targets -------------------------------------------------------
Index: svtools/inc/bindablecontrolhelper.hxx
===================================================================
--- svtools/inc/bindablecontrolhelper.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ svtools/inc/bindablecontrolhelper.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: imageresourceaccess.hxx,v $
+ * $Revision: 1.5 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SVTOOLS_INC_BINDABLECONTROL_HXX
+#define SVTOOLS_INC_BINDABLECONTROL_HXX
+
+#include "svtools/svtdllapi.h"
+
+#include <com/sun/star/frame/XModel.hpp>
+//........................................................................
+namespace svt
+{
+//........................................................................
+
+    //====================================================================
+    //= GraphicAccess
+    //====================================================================
+    /** helper class for obtaining streams (which also can be used with the ImageProducer)
+        from a resource
+    */
+    class BindableControlHelper
+    {
+    private:
+        BindableControlHelper();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  void ApplyListSourceAndBindableData( const com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel, const com::sun::star::uno::Reference< com::sun::star::uno::XInterface >& rObj, const rtl::OUString& rsCtrlSource, const rtl::OUString& rsRowSource );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif // DBA14_SVTOOLS_INC_IMAGERESOURCEACCESS_HXX
+
Index: svtools/inc/filterutils.hxx
===================================================================
--- svtools/inc/filterutils.hxx	(.../tags/DEV300_m58)	(revision 0)
+++ svtools/inc/filterutils.hxx	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,22 @@
+#ifndef SVTOOLS_INC_FILTERUTILS_HXX
+#define SVTOOLS_INC_FILTERUTILS_HXX
+
+#include "svtools/svtdllapi.h"
+#include <com/sun/star/uno/RuntimeException.hpp>
+namespace svt
+{
+    class BinFilterUtils
+    {
+    private:
+        BinFilterUtils();    // never implemented
+
+    public:
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromUniStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+        SVT_DLLPUBLIC static  rtl::OUString CreateOUStringFromStringArray( const char* pcCharArr, sal_uInt32 nBufSize );
+    };
+
+//........................................................................
+} // namespace svt
+//........................................................................
+
+#endif 
Index: svtools/prj/d.lst
===================================================================
--- svtools/prj/d.lst	(.../tags/DEV300_m58)	(revision 277097)
+++ svtools/prj/d.lst	(.../cws/vbasupportdev300)	(revision 277097)
@@ -172,6 +172,8 @@
 ..\inc\svtools\logindlg.hxx %_DEST%\inc%_EXT%\svtools\logindlg.hxx
 ..\inc\svtools\httpcook.hxx %_DEST%\inc%_EXT%\svtools\httpcook.hxx
 ..\inc\imageresourceaccess.hxx %_DEST%\inc%_EXT%\svtools\imageresourceaccess.hxx
+..\inc\bindablecontrolhelper.hxx %_DEST%\inc%_EXT%\svtools\bindablecontrolhelper.hxx
+..\inc\filterutils.hxx %_DEST%\inc%_EXT%\svtools\filterutils.hxx
 ..\inc\svtools\itemprop.hxx %_DEST%\inc%_EXT%\svtools\itemprop.hxx
 ..\inc\addresstemplate.hxx %_DEST%\inc%_EXT%\svtools\addresstemplate.hxx
 ..\inc\svtools\genericunodialog.hxx %_DEST%\inc%_EXT%\svtools\genericunodialog.hxx
Index: udkapi/com/sun/star/script/ModuleType.idl
===================================================================
--- udkapi/com/sun/star/script/ModuleType.idl	(.../tags/DEV300_m58)	(revision 0)
+++ udkapi/com/sun/star/script/ModuleType.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleType.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleType_idl__
+#define __com_sun_star_script_ModuleType_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+published constants ModuleType
+{
+    const long Unknown = 0;
+    const long Normal = 1;  
+    const long Class = 2;
+    const long Form = 3;
+    const long Document = 4;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
Index: udkapi/com/sun/star/script/ModuleInfo.idl
===================================================================
--- udkapi/com/sun/star/script/ModuleInfo.idl	(.../tags/DEV300_m58)	(revision 0)
+++ udkapi/com/sun/star/script/ModuleInfo.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ModuleInfo.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	com::sun::star::uno::XInterface ModuleObject; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
Index: udkapi/com/sun/star/script/XErrorQuery.idl
===================================================================
--- udkapi/com/sun/star/script/XErrorQuery.idl	(.../tags/DEV300_m58)	(revision 0)
+++ udkapi/com/sun/star/script/XErrorQuery.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,25 @@
+#ifndef __com_sun_star_script_XErrorQuery_idl__
+#define __com_sun_star_script_XErrorQuery_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+
+interface XErrorQuery : ::com::sun::star::uno::XInterface
+{
+  //-----------------------------------------------------------------------
+  /**
+    Returns whether this object has an error
+
+    @return
+    <atom>boolean</atom> indicating an error or not
+  */
+  boolean hasError();
+
+};
+
+};  };  };  };
+#endif
Index: udkapi/com/sun/star/script/makefile.mk
===================================================================
--- udkapi/com/sun/star/script/makefile.mk	(.../tags/DEV300_m58)	(revision 277097)
+++ udkapi/com/sun/star/script/makefile.mk	(.../cws/vbasupportdev300)	(revision 277097)
@@ -85,6 +85,10 @@
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+	XAutomationInvocation.idl\
+    ModuleInfo.idl\
+    ModuleType.idl\
+    XErrorQuery.idl\
 
 # ------------------------------------------------------------------
 
Index: udkapi/com/sun/star/script/XAutomationInvocation.idl
===================================================================
--- udkapi/com/sun/star/script/XAutomationInvocation.idl	(.../tags/DEV300_m58)	(revision 0)
+++ udkapi/com/sun/star/script/XAutomationInvocation.idl	(.../cws/vbasupportdev300)	(revision 277097)
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: XInvocation2.idl,v $
+ * $Revision: 1.10 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XAutomationInvocation_idl__ 
+#define __com_sun_star_script_XAutomationInvocation_idl__
+ 
+#ifndef __com_sun_star_script_XInvocation_idl__ 
+#include <com/sun/star/script/XInvocation.idl> 
+#endif 
+ 
+ 
+ module com {  module sun {  module star {  module script {  
+ 
+interface XAutomationInvocation: com::sun::star::script::XInvocation
+{ 
+    any invokeGetProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+    any invokePutProperty(  [in] string aFunctionName, [in] sequence<any> aParams, [out] sequence<short> aOutParamIndex, [out] sequence<any> aOutParam ) raises( com::sun::star::lang::IllegalArgumentException, com::sun::star::script::CannotConvertException, com::sun::star::reflection::InvocationTargetException );
+ 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
