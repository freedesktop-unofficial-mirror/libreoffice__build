--- sc/source/ui/vba/vbarange.cxx	
+++ sc/source/ui/vba/vbarange.cxx
@@ -424,7 +424,7 @@ class NumFormatHelper
 public:
 	NumFormatHelper( const uno::Reference< table::XCellRange >& xRange )
 	{
-		mxSupplier.set( getCurrentDocument(), uno::UNO_QUERY_THROW );
+		mxSupplier.set( getModelFromRange( xRange ), uno::UNO_QUERY_THROW );
 		mxRangeProps.set( xRange, uno::UNO_QUERY_THROW);
 		mxFormats = mxSupplier->getNumberFormats();
 	}
@@ -511,10 +511,11 @@ public:
 
 struct CellPos
 {
-	CellPos():m_nRow(-1), m_nCol(-1) {};
-	CellPos( sal_Int32 nRow, sal_Int32 nCol ):m_nRow(nRow), m_nCol(nCol) {};
+	CellPos():m_nRow(-1), m_nCol(-1), m_nArea(0) {};
+	CellPos( sal_Int32 nRow, sal_Int32 nCol, sal_Int32 nArea ):m_nRow(nRow), m_nCol(nCol), m_nArea( nArea ) {};
 sal_Int32 m_nRow;
 sal_Int32 m_nCol;
+sal_Int32 m_nArea;
 };
 
 typedef ::cppu::WeakImplHelper1< container::XEnumeration > CellsEnumeration_BASE;
@@ -523,18 +524,42 @@ typedef vector< CellPos > vCellPos;
 class CellsEnumeration : public CellsEnumeration_BASE
 {
 	uno::Reference< uno::XComponentContext > mxContext;
-	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< vba::XCollection > m_xAreas;
 	vCellPos m_CellPositions;	
 	vCellPos::const_iterator m_it; 
-public:
-	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): mxContext( xContext ), m_xRange( xRange )
+	uno::Reference< table::XCellRange > getArea( sal_Int32 nVBAIndex ) throw ( uno::RuntimeException )
+	{
+		if ( nVBAIndex < 1 || nVBAIndex > m_xAreas->getCount() )
+			throw uno::RuntimeException();
+		uno::Reference< excel::XRange > xRange( m_xAreas->Item( uno::makeAny(nVBAIndex), uno::Any() ), uno::UNO_QUERY_THROW );
+		ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+		uno::Reference< table::XCellRange > xCellRange;
+		if ( !pRange )
+			throw uno::RuntimeException();
+		xCellRange.set( pRange->getCellRange(), uno::UNO_QUERY_THROW );;
+		return xCellRange;
+		
+	}
+        void populateArea( sal_Int32 nVBAIndex )
 	{
-		uno::Reference< table::XColumnRowRange > xColumnRowRange(m_xRange, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xRange = getArea( nVBAIndex );
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(xRange, uno::UNO_QUERY_THROW );
 		sal_Int32 nRowCount =  xColumnRowRange->getRows()->getCount();
 		sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
 		for ( sal_Int32 i=0; i<nRowCount; ++i )
+		{
 			for ( sal_Int32 j=0; j<nColCount; ++j )
-				m_CellPositions.push_back( CellPos( i,j ) );
+				m_CellPositions.push_back( CellPos( i,j,nVBAIndex ) );
+		}
+	}
+public:
+	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< vba::XCollection >& xAreas ): mxContext( xContext ), m_xAreas( xAreas )
+	{
+		sal_Int32 nItems = m_xAreas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+        		populateArea( index );
+		}
 		m_it = m_CellPositions.begin();
 	}
 	virtual ::sal_Bool SAL_CALL hasMoreElements() throw (::uno::RuntimeException){ return m_it != m_CellPositions.end(); }
@@ -544,9 +569,12 @@ public:
 		if ( !hasMoreElements() )
 			throw container::NoSuchElementException();
 		CellPos aPos = *(m_it)++;
-		uno::Reference< table::XCellRange > xCellRange( m_xRange->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
+		
+		uno::Reference< table::XCellRange > xRangeArea = getArea( aPos.m_nArea );
+		uno::Reference< table::XCellRange > xCellRange( xRangeArea->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
 		// #FIXME need proper (WorkSheet) parent
 		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), mxContext, xCellRange ) ) );
+
 	}
 };
 
@@ -972,34 +1000,6 @@ public:
 	
 };
 
-static table::CellRangeAddress getCellRangeAddress( const uno::Any& aParam,
-const uno::Reference< sheet::XSpreadsheet >& xDoc )
-{
-	uno::Reference< table::XCellRange > xRangeParam;
-	switch ( aParam.getValueTypeClass() )
-	{
-		case uno::TypeClass_STRING:
-		{
-			rtl::OUString rString;
-			aParam >>= rString;
-			xRangeParam = ScVbaRange::getCellRangeForName( rString, xDoc );
-			break;
-		}
-		case uno::TypeClass_INTERFACE:
-		{
-			uno::Reference< excel::XRange > xRange;
-			aParam >>= xRange;
-			if ( xRange.is() )
-				xRange->getCellRange() >>= xRangeParam;
-			break;
-		}
-		default:
-			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't extact CellRangeAddress from type" ) ), uno::Reference< uno::XInterface >() );
-	}
-	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRangeParam, uno::UNO_QUERY_THROW );
-	return xAddressable->getRangeAddress();
-}
-
 bool
 getCellRangesForAddress( USHORT& rResFlags, const rtl::OUString& sAddress, ScDocShell* pDocSh, ScRangeList& rCellRanges, ScAddress::Convention& eConv )
 {
@@ -1020,15 +1020,12 @@ getCellRangesForAddress( USHORT& rResFla
 	return false;
 } 
 
-ScVbaRange*
-getRangeForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sName, ScDocShell* pDocSh, table::CellRangeAddress& pAddr ) throw ( uno::RuntimeException )
+bool getScRangeListForAddress( const rtl::OUString& sName, ScDocShell* pDocSh, ScRange& refRange, ScRangeList& aCellRanges, ScAddress::Convention aConv = ScAddress::CONV_XL_A1 ) throw ( uno::RuntimeException )
 {
-	ScAddress::Convention eConv = ScAddress::CONV_XL_A1; 
 	// see if there is a match with a named range
 	uno::Reference< beans::XPropertySet > xProps( pDocSh->GetModel(), uno::UNO_QUERY_THROW );
 	uno::Reference< container::XNameAccess > xNameAccess( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NamedRanges") ) ), uno::UNO_QUERY_THROW );
 	// Strangly enough you can have Range( "namedRange1, namedRange2, etc," )	
-	ScRangeList aCellRanges;
 	// loop around each ',' seperated name
 	std::vector< rtl::OUString > vNames;
 	sal_Int32 nIndex = 0;
@@ -1045,6 +1042,8 @@ getRangeForName( const uno::Reference< u
 	std::vector< rtl::OUString >::iterator it_end = vNames.end(); 
 	for ( ; it != it_end; ++it )
 	{
+		
+		ScAddress::Convention eConv = aConv; 
 		// spaces are illegal ( but the user of course can enter them )
 		rtl::OUString sAddress = (*it).trim();
 		if ( xNameAccess->hasByName( sAddress ) )
@@ -1055,11 +1054,10 @@ getRangeForName( const uno::Reference< u
 			// style is may not be XL_A1
 			eConv = pDocSh->GetDocument()->GetAddressConvention();
 		}	
-		ScRange refRange;	
-		ScUnoConversion::FillScRange( refRange, pAddr );
+
 		USHORT nFlags = 0;
 		if ( !getCellRangesForAddress( nFlags, sAddress, pDocSh, aCellRanges, eConv ) )
-			throw uno::RuntimeException();
+			return false;
 	
 		bool bTabFromReferrer = !( nFlags & SCA_TAB_3D );
 
@@ -1073,7 +1071,18 @@ getRangeForName( const uno::Reference< u
 			pRange->aEnd.SetTab( bTabFromReferrer ? refRange.aEnd.Tab()  : pRange->aEnd.Tab() );
 		}
 	}
+	return true;
+}
+
 
+ScVbaRange*
+getRangeForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sName, ScDocShell* pDocSh, table::CellRangeAddress& pAddr, ScAddress::Convention eConv = ScAddress::CONV_XL_A1 ) throw ( uno::RuntimeException )
+{
+	ScRangeList aCellRanges;
+	ScRange refRange;
+	ScUnoConversion::FillScRange( refRange, pAddr );
+	if ( !getScRangeListForAddress ( sName, pDocSh, refRange, aCellRanges, eConv ) ) 
+		throw uno::RuntimeException();
 	// Single range
 	if ( aCellRanges.First() == aCellRanges.Last() )
 	{
@@ -1085,7 +1094,51 @@ getRangeForName( const uno::Reference< u
  	
 	// #FIXME need proper (WorkSheet) parent
 	return new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRanges );
-	
+}
+
+css::uno::Reference< excel::XRange >
+ScVbaRange::getRangeObjectForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sRangeName, ScDocShell* pDocSh, ScAddress::Convention eConv ) throw ( uno::RuntimeException )
+{
+	table::CellRangeAddress refAddr;
+	return getRangeForName( xContext, sRangeName, pDocSh, refAddr, eConv );
+}
+
+
+table::CellRangeAddress getCellRangeAddressForVBARange( const uno::Any& aParam, ScDocShell* pDocSh,  ScAddress::Convention aConv = ScAddress::CONV_XL_A1) throw ( uno::RuntimeException )
+{
+	uno::Reference< table::XCellRange > xRangeParam;
+	switch ( aParam.getValueTypeClass() )
+	{
+		case uno::TypeClass_STRING:
+		{
+			rtl::OUString rString;
+			aParam >>= rString;
+			ScRangeList aCellRanges;
+			ScRange refRange;
+			if ( getScRangeListForAddress ( rString, pDocSh, refRange, aCellRanges, aConv ) ) 			
+			{
+				if ( aCellRanges.First() == aCellRanges.Last() )
+				{
+					table::CellRangeAddress aRangeAddress;
+					ScUnoConversion::FillApiRange( aRangeAddress, *aCellRanges.First() );
+					return aRangeAddress;
+				}
+			}
+		}
+		case uno::TypeClass_INTERFACE:
+		{
+			uno::Reference< excel::XRange > xRange;
+			aParam >>= xRange;
+			if ( xRange.is() )
+				xRange->getCellRange() >>= xRangeParam;
+			break;
+		}
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't extact CellRangeAddress from type" ) ), uno::Reference< uno::XInterface >() );
+	}
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRangeParam, uno::UNO_QUERY_THROW );
+	return xAddressable->getRangeAddress();
+
 }
 
 uno::Reference< vba::XCollection >
@@ -1100,39 +1153,8 @@ lcl_setupBorders( const uno::Reference< 
 	return borders;
 }
 
-
-uno::Reference< beans::XPropertySet >
-lcl_getPropertiesFromArgs( uno::Sequence< uno::Any > const & args ) throw ( lang::IllegalArgumentException )
-{
-	boost::optional< uno::Reference< vba::XHelperInterface >  >xParent;
-	uno::Reference< table::XCellRange > xRange;
-	comphelper::unwrapArgs( args, xParent, xRange ); 
-	uno::Reference< beans::XPropertySet > xProps( xRange, uno::UNO_QUERY );
-	if ( !xProps.is() )
-		throw lang::IllegalArgumentException();
-	return xProps;
-}
-
-uno::Reference< frame::XModel > 
-lcl_getModelFromArgs( uno::Sequence< uno::Any > const& args ) throw ( lang::IllegalArgumentException )
-{
-	boost::optional< uno::Reference< vba::XHelperInterface >  >xParent;
-	uno::Reference< table::XCellRange > xRange;
-	comphelper::unwrapArgs( args, xParent, xRange ); 
-	return getModelFromRange( xRange );	
-}
-
-uno::Reference< vba::XHelperInterface > 
-lcl_getParentFromArgs( uno::Sequence< uno::Any > const& args ) throw ( lang::IllegalArgumentException )
-{
-	boost::optional< uno::Reference< vba::XHelperInterface >  >xParent;
-	uno::Reference< table::XCellRange > xRange;
-	comphelper::unwrapArgs( args, xParent, xRange ); 
-	return *xParent;
-}
-
 ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
-    uno::Reference< uno::XComponentContext> const & xContext )  throw ( lang::IllegalArgumentException ) : ScVbaRange_BASE( lcl_getParentFromArgs( args ), xContext, lcl_getPropertiesFromArgs( args ), lcl_getModelFromArgs( args ), true ), mbIsRows( sal_False ), mbIsColumns( sal_False )
+    uno::Reference< uno::XComponentContext> const & xContext )  throw ( lang::IllegalArgumentException ) : ScVbaRange_BASE( getXSomethingFromArgs< vba::XHelperInterface >( args, 0 ), xContext, getXSomethingFromArgs< beans::XPropertySet >( args, 1, false ), getModelFromRange( getXSomethingFromArgs< table::XCellRange >( args, 1 ) ), true ), mbIsRows( sal_False ), mbIsColumns( sal_False )
 {
 	mxRange.set( mxPropertySet, uno::UNO_QUERY_THROW );
 	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, mxRange ) );
@@ -1177,13 +1199,6 @@ uno::Reference< vba::XCollection >& ScVb
 	return m_Borders;
 }
 
-uno::Reference< script::XTypeConverter >
-ScVbaRange::getTypeConverter() throw (uno::RuntimeException)
-{
-	static uno::Reference< script::XTypeConverter > xTypeConv( mxContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), mxContext ), uno::UNO_QUERY_THROW );
-	return xTypeConv;
-}
-
 void
 ScVbaRange::visitArray( ArrayVisitor& visitor )
 {
@@ -1246,7 +1261,7 @@ ScVbaRange::setValue(  const uno::Any  &
 	uno::TypeClass aClass = aValue.getValueTypeClass();
 	if ( aClass == uno::TypeClass_SEQUENCE )
 	{
-		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter();
+		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
 		uno::Any aConverted;
 		try
 		{
@@ -1658,7 +1673,7 @@ ScVbaRange::getFormulaArray() throw (uno
 	}
 	
 	uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
-	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter();
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter( mxContext );
 	uno::Any aMatrix;
 	aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
 	return aMatrix;
@@ -1742,7 +1757,9 @@ ScVbaRange::Address(  const uno::Any& Ro
 			dDetails = ScAddress::Details( ScAddress::CONV_XL_R1C1, 0, 0 );
 	}
 	USHORT nFlags = SCA_VALID;
-	ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	ScDocShell* pDocShell =  getScDocShell();
+	ScDocument* pDoc =  pDocShell->GetDocument();
+
 	RangeHelper thisRange( mxRange );	
 	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
 	ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
@@ -1776,7 +1793,7 @@ ScVbaRange::Address(  const uno::Any& Ro
 	{
 		// #TODO should I throw an error if R1C1 is not set?
 		
-		table::CellRangeAddress refAddress = getCellRangeAddress( RelativeTo, thisRange.getSpreadSheet() );
+		table::CellRangeAddress refAddress = getCellRangeAddressForVBARange( RelativeTo, pDocShell );
 		dDetails = ScAddress::Details( ScAddress::CONV_XL_R1C1, static_cast< SCROW >( refAddress.StartRow ), static_cast< SCCOL >( refAddress.StartColumn ) );
 	}
 	aRange.Format( sRange,  nFlags, pDoc, dDetails ); 
@@ -2294,12 +2311,12 @@ ScVbaRange::Range( const uno::Any &Cell1
 	else
 	{
 		table::CellRangeAddress  cell1, cell2;
-		cell1 = getCellRangeAddress( Cell1, thisRange.getSpreadSheet() ); 	
+		cell1 = getCellRangeAddressForVBARange( Cell1, getScDocShell() ); 	
 		// Cell1 & Cell2 defined
 		// Excel seems to combine the range as the range defined by
 		// the combination of Cell1 & Cell2
 	
-		cell2 = getCellRangeAddress( Cell2, thisRange.getSpreadSheet() ); 	
+		cell2 = getCellRangeAddressForVBARange( Cell2, getScDocShell() ); 	
 
 		resultAddress.StartColumn = ( cell1.StartColumn <  cell2.StartColumn ) ? cell1.StartColumn : cell2.StartColumn;
 		resultAddress.StartRow = ( cell1.StartRow <  cell2.StartRow ) ? cell1.StartRow : cell2.StartRow;
@@ -2674,38 +2691,26 @@ ScVbaRange::Replace( const ::rtl::OUStri
 	return sal_True; // always
 }
 
-uno::Reference< table::XCellRange > 
-ScVbaRange::getCellRangeForName(  const rtl::OUString& sRangeName, const uno::Reference< sheet::XSpreadsheet >& xDoc, ScAddress::Convention aConv )
-{
-	uno::Reference< uno::XInterface > xRanges( xDoc, uno::UNO_QUERY_THROW );
-	ScCellRangeObj* pRanges = dynamic_cast< ScCellRangeObj* >( xRanges.get() );
-    ScAddress::Convention eConv = aConv;//ScAddress::CONV_XL_A1;   the default. 
-
-	ScAddress::Details dDetails( eConv, 0, 0 );
-		
-	uno::Reference< table::XCellRange > xRange;
-	if ( pRanges )
-		xRange = pRanges->getCellRangeByName( sRangeName, dDetails );
-	return xRange;	
-}
-
-uno::Reference< table::XCellRange > processKey( const uno::Any& Key, uno::Reference< table::XCellRange >& xRange )
+uno::Reference< table::XCellRange > processKey( const uno::Any& Key, uno::Reference<  uno::XComponentContext >& xContext, ScDocShell* pDocSh )
 {
-	uno::Reference< table::XCellRange > xKey;
+	uno::Reference< excel::XRange > xKeyRange;
 	if ( Key.getValueType() == excel::XRange::static_type() )
 	{
-		uno::Reference< excel::XRange > xKeyRange( Key, uno::UNO_QUERY_THROW );
-		xKey.set( xKeyRange->getCellRange(), uno::UNO_QUERY_THROW );
+		xKeyRange.set( Key, uno::UNO_QUERY_THROW );
 	}
 	else if ( Key.getValueType() == ::getCppuType( static_cast< const rtl::OUString* >(0) )  )
 			
 	{
 		rtl::OUString sRangeName = ::comphelper::getString( Key );
-		RangeHelper dRange( xRange );
-		xKey = ScVbaRange::getCellRangeForName( sRangeName,  dRange.getSpreadSheet() );
+		table::CellRangeAddress  aRefAddr;
+		if ( !pDocSh )
+			throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort no docshell to calculate key param")), uno::Reference< uno::XInterface >() );
+		xKeyRange = getRangeForName( xContext, sRangeName, pDocSh, aRefAddr ); 
 	}
 	else
 		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort illegal type value for key param")), uno::Reference< uno::XInterface >() );
+	uno::Reference< table::XCellRange > xKey;
+	xKey.set( xKeyRange->getCellRange(), uno::UNO_QUERY_THROW );
 	return xKey;
 }
 
@@ -2913,15 +2918,15 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	uno::Reference< table::XCellRange > xKey1;	
 	uno::Reference< table::XCellRange > xKey2;	
 	uno::Reference< table::XCellRange > xKey3;	
-
-	xKey1 = processKey( Key1, mxRange );
+	ScDocShell* pDocShell = getScDocShell();
+	xKey1 = processKey( Key1, mxContext, pDocShell );
 	if ( !xKey1.is() )
 		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort needs a key1 param")), uno::Reference< uno::XInterface >() );
 
 	if ( Key2.hasValue() )
-		xKey2 = processKey( Key2, mxRange );
+		xKey2 = processKey( Key2, mxContext, pDocShell );
 	if ( Key3.hasValue() )
-		xKey3 = processKey( Key3, mxRange );
+		xKey3 = processKey( Key3, mxContext, pDocShell );
 
 	uno::Reference< util::XSortable > xSort( mxRange, uno::UNO_QUERY_THROW );
 	uno::Sequence< beans::PropertyValue > sortDescriptor = xSort->createSortDescriptor();
@@ -3120,7 +3125,7 @@ ScVbaRange::hasElements() throw (uno::Ru
 uno::Reference< container::XEnumeration > SAL_CALL 
 ScVbaRange::createEnumeration() throw (uno::RuntimeException)
 {
-	return new CellsEnumeration( mxContext, mxRange );
+	return new CellsEnumeration( mxContext, m_Areas );
 }
 
 ::rtl::OUString SAL_CALL 
