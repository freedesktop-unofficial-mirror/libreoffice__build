--- sc/source/ui/vba//vbarange.cxx	
+++ sc/source/ui/vba//vbarange.cxx
@@ -32,10 +32,16 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
+#include "helperdecl.hxx"
+
+#include <comphelper/unwrapargs.hxx>
 #include <comphelper/processfactory.hxx>
 #include <sfx2/objsh.hxx>
 
 #include <com/sun/star/script/ArrayWrapper.hpp>
+#include <com/sun/star/sheet/XDatabaseRange.hpp>
+#include <com/sun/star/sheet/XDatabaseRanges.hpp>
+#include <com/sun/star/sheet/XGoalSeek.hpp>
 #include <com/sun/star/sheet/XSheetOperation.hpp>
 #include <com/sun/star/sheet/CellFlags.hpp>
 #include <com/sun/star/table/XColumnRowRange.hpp>
@@ -45,6 +51,7 @@
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
 #include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/sheet/XSpreadsheetView.hpp>
 #include <com/sun/star/sheet/XCellRangeReferrer.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
@@ -149,9 +156,13 @@
 #include <com/sun/star/sheet/FunctionArgument.hpp>
 // end test includes
 
+#include <org/openoffice/excel/Range.hpp>
+
 using namespace ::org::openoffice;
 using namespace ::com::sun::star;
 
+
+
 //    * 1 point = 1/72 inch = 20 twips
 //    * 1 inch = 72 points = 1440 twips
 //    * 1 cm = 567 twips
@@ -186,31 +197,29 @@ double lcl_Round2DecPlaces( double nVal 
 uno::Any lcl_makeRange( uno::Reference< uno::XComponentContext >& xContext, const uno::Any aAny )
 {
 	uno::Reference< table::XCellRange > xCellRange( aAny, uno::UNO_QUERY_THROW );
-	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( xContext, xCellRange ) ) );
+	// #FIXME need proper (WorkSheet) parent
+	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xCellRange ) ) );
 }
 
 SfxItemSet*  ScVbaRange::getCurrentDataSet( ) throw ( uno::RuntimeException )
 {
 	uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
-	//ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
-	// FOR_UPSTREAM_BUILD
-	/*SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
+	ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
+	SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
 	
 	if ( !pDataSet )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't access Itemset for range" ) ), uno::Reference< uno::XInterface >() );
 	return pDataSet;	
-	*/
-	return NULL;
 }
 
 class SingleRangeEnumeration : public EnumerationHelper_BASE
 {
 	uno::Reference< table::XCellRange > m_xRange;
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	bool bHasMore;
 public:
 
-	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), m_xContext( xContext ), bHasMore( true ) { }
+	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), mxContext( xContext ), bHasMore( true ) { }
 	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) { return bHasMore; }
 	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
 	{
@@ -229,10 +238,10 @@ class SingleRangeIndexAccess : public Si
 {
 private:
 	uno::Reference< table::XCellRange > m_xRange;
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	SingleRangeIndexAccess(); // not defined
 public:
-	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), m_xContext( xContext ) {}
+	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), mxContext( xContext ) {}
 	// XIndexAccess
 	virtual ::sal_Int32 SAL_CALL getCount() throw (::uno::RuntimeException) { return 1; }
 	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
@@ -246,7 +255,7 @@ public:
  
         virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException) { return sal_True; }
 	// XEnumerationAccess
-	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( m_xContext, m_xRange ); }
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( mxContext, m_xRange ); }
 
 };
 
@@ -268,7 +277,7 @@ class ScVbaRangeAreas : public ScVbaColl
 {
 
 public:
-	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : ScVbaCollectionBaseImpl( xContext, xIndexAccess ) {}
+	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : ScVbaCollectionBaseImpl( uno::Reference< vba::XHelperInterface >(), xContext, xIndexAccess ) {}
 
 	// XEnumerationAccess
 	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException);
@@ -277,27 +286,30 @@ public:
 	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return excel::XRange::static_type(0); }
 
 	virtual uno::Any createCollectionObject( const uno::Any& aSource );
-};
 
+	virtual rtl::OUString& getServiceImplName() { static rtl::OUString sDummy; return sDummy; }
+
+	virtual uno::Sequence< rtl::OUString > getServiceNames() { return uno::Sequence< rtl::OUString >(); } 
+
+}; 
 
 uno::Reference< container::XEnumeration > SAL_CALL 
 ScVbaRangeAreas::createEnumeration() throw (uno::RuntimeException)
 {
 	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
-	return new RangesEnumerationImpl( m_xContext, xEnumAccess->createEnumeration() );
+	return new RangesEnumerationImpl( mxContext, xEnumAccess->createEnumeration() );
 
 }
 
 uno::Any 
 ScVbaRangeAreas::createCollectionObject( const uno::Any& aSource )
 {
-	return lcl_makeRange( m_xContext, aSource );
+	return lcl_makeRange( mxContext, aSource );
 }
 
 
-
-
-ScDocShell* getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange )
+ScDocShell* 
+getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange )
 {
 	// need the ScCellRangesBase to get docshell
 	uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
@@ -307,7 +319,8 @@ ScDocShell* getDocShellFromRange( const 
 	return pUno->GetDocShell();
 }
 
-ScDocument* getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
+ScDocument* 
+getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
 {
 	ScDocShell* pDocShell = getDocShellFromRange( xRange );
 	if ( !pDocShell )
@@ -316,6 +329,19 @@ ScDocument* getDocumentFromRange( const 
 	return pDoc;
 }
 
+
+ScDocument* 
+ScVbaRange::getScDocument()
+{
+	return getDocumentFromRange( mxRange );
+}
+
+ScDocShell* 
+ScVbaRange::getScDocShell()
+{
+	return getDocShellFromRange( mxRange );
+}
+
 class NumFormatHelper
 {
 	uno::Reference< util::XNumberFormatsSupplier > mxSupplier;
@@ -353,15 +379,13 @@ public:
 		ScCellRangeObj* pUnoCellRange = dynamic_cast<  ScCellRangeObj* >( xIf.get() );
 		if ( pUnoCellRange )
 		{
-			// FOR_UPSTREAM_BUILD
-			/*
+			
 			SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
 			SfxItemState eState = pDataSet->GetItemState( ATTR_VALUE_FORMAT, TRUE, NULL);
 			// one of the cells in the range is not like the other ;-)
 			// so return a zero length format to indicate that
 			if ( eState == SFX_ITEM_DONTCARE )
 				return rtl::OUString();
-			*/
 		}
 		
 	
@@ -424,12 +448,12 @@ typedef vector< CellPos > vCellPos;
 
 class CellsEnumeration : public CellsEnumeration_BASE
 {
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	uno::Reference< table::XCellRange > m_xRange;
 	vCellPos m_CellPositions;	
 	vCellPos::const_iterator m_it; 
 public:
-	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): m_xContext( xContext ), m_xRange( xRange )
+	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): mxContext( xContext ), m_xRange( xRange )
 	{
 		uno::Reference< table::XColumnRowRange > xColumnRowRange(m_xRange, uno::UNO_QUERY_THROW );
 		sal_Int32 nRowCount =  xColumnRowRange->getRows()->getCount();
@@ -447,7 +471,8 @@ public:
 			throw container::NoSuchElementException();
 		CellPos aPos = *(m_it)++;
 		uno::Reference< table::XCellRange > xCellRange( m_xRange->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
-		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xCellRange ) ) );
+		// #FIXME need proper (WorkSheet) parent
+		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), mxContext, xCellRange ) ) );
 	}
 };
 
@@ -456,7 +481,14 @@ const static ::rtl::OUString ISVISIBLE( 
 const static ::rtl::OUString WIDTH(  RTL_CONSTASCII_USTRINGPARAM( "Width"));
 const static ::rtl::OUString HEIGHT(  RTL_CONSTASCII_USTRINGPARAM( "Height"));
 const static rtl::OUString EQUALS( RTL_CONSTASCII_USTRINGPARAM("=") );
+const static rtl::OUString NOTEQUALS( RTL_CONSTASCII_USTRINGPARAM("<>") );
+const static rtl::OUString GREATERTHAN( RTL_CONSTASCII_USTRINGPARAM(">") );
+const static rtl::OUString GREATERTHANEQUALS( RTL_CONSTASCII_USTRINGPARAM(">=") );
+const static rtl::OUString LESSTHAN( RTL_CONSTASCII_USTRINGPARAM("<") );
+const static rtl::OUString LESSTHANEQUALS( RTL_CONSTASCII_USTRINGPARAM("<=") );
+
 const static rtl::OUString CONTS_HEADER( RTL_CONSTASCII_USTRINGPARAM("ContainsHeader" ));
+const static rtl::OUString STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY( RTL_CONSTASCII_USTRINGPARAM("The command you chose cannot be performed with multiple selections.\nSelect a single range and click the command again") );
 
 class CellValueSetter : public ValueSetter
 {
@@ -559,7 +591,21 @@ void CellValueGetter::visitNode( sal_Int
 			else if ( sFormula.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=FALSE()") ) ) )
 				aValue <<= sal_False;
 			else 	
-				aValue <<= xCell->getValue();
+			{
+				uno::Reference< beans::XPropertySet > xProp( xCell, uno::UNO_QUERY_THROW );
+				
+				table::CellContentType eFormulaType = table::CellContentType_VALUE;
+				// some formulas give textual results
+				xProp->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FormulaResultType" ) ) ) >>= eFormulaType;
+
+				if ( eFormulaType == table::CellContentType_TEXT )
+				{
+					uno::Reference< text::XTextRange > xTextRange(xCell, ::uno::UNO_QUERY_THROW);
+					aValue <<= xTextRange->getString();
+				}
+				else	
+					aValue <<= xCell->getValue();
+			}
 		}
 		else
 		{
@@ -594,7 +640,8 @@ protected:
 		{
 			// get current convention
 			ScAddress::Convention eConv = m_pDoc->GetAddressConvention();
-			if ( eConv != m_eConv )	
+			// only convert/compile 'real' formulas
+			if ( eConv != m_eConv && ( sFormula.trim().indexOf('=') == 0 ) )	
 			{
 				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
 				ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
@@ -786,7 +833,7 @@ public:
 			sal_Int32 nItems = m_Areas->getCount();
 			for ( sal_Int32 index=1; index <= nItems; ++index )
 			{
-				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 				processor.process( xRange ); 
 			}
 		}	
@@ -835,7 +882,8 @@ public:
 	static uno::Reference< excel::XRange > createRangeFromRange( const uno::Reference<uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, const uno::Reference< sheet::XCellRangeAddressable >& xCellRangeAddressable, sal_Int32 nStartColOffset = 0, sal_Int32 nStartRowOffset = 0,
  sal_Int32 nEndColOffset = 0, sal_Int32 nEndRowOffset = 0 )
 	{
-		return uno::Reference< excel::XRange >( new ScVbaRange( xContext, 
+		// #FIXME need proper (WorkSheet) parent
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, 
 			xRange->getCellRangeByPosition(
 				xCellRangeAddressable->getRangeAddress().StartColumn + nStartColOffset,
 				xCellRangeAddressable->getRangeAddress().StartRow + nStartRowOffset,
@@ -899,7 +947,7 @@ getRangeForName( const uno::Reference< u
 	rtl::OUString sAddress = sName;
 	ScAddress::Convention eConv = ScAddress::CONV_XL_A1; 
 	// see if there is a match with a named range
-	uno::Reference< beans::XPropertySet > xProps( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps( pDocSh->GetModel(), uno::UNO_QUERY_THROW );
 	uno::Reference< container::XNameAccess > xNameAccess( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NamedRanges") ) ), uno::UNO_QUERY_THROW );
 
 	if ( xNameAccess->hasByName( sName ) )
@@ -933,28 +981,41 @@ getRangeForName( const uno::Reference< u
 	if ( aCellRanges.First() == aCellRanges.Last() )
 	{
 		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pDocSh, *aCellRanges.First() ) );
-		return new ScVbaRange( xContext, xRange );
+		// #FIXME need proper (WorkSheet) parent
+		return new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRange );
 	}
 	uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pDocSh, aCellRanges ) );
  	
-	return new ScVbaRange( xContext, xRanges );
+	// #FIXME need proper (WorkSheet) parent
+	return new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRanges );
 	
 }
 
 uno::Reference< vba::XCollection >
-lcl_setupBorders( const uno::Reference<uno::XComponentContext>& xContext,  uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
+lcl_setupBorders( const uno::Reference< excel::XRange >& xParentRange, const uno::Reference<uno::XComponentContext>& xContext,  const uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
 {
+	uno::Reference< vba::XHelperInterface > xParent( xParentRange, uno::UNO_QUERY_THROW ); 
 	ScDocument* pDoc = getDocumentFromRange(xRange);
 	if ( !pDoc )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
- 	uno::Reference< vba::XCollection > borders( new ScVbaBorders( xContext, xRange, aPalette ) );
+ 	uno::Reference< vba::XCollection > borders( new ScVbaBorders( xParent, xContext, xRange, aPalette ) );
 	return borders;
 }
 
-ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
-: mxRange( xRange ),
-                m_xContext(xContext),
+
+ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
+    uno::Reference< uno::XComponentContext> const & xContext ) : ScVbaRange_BASE( uno::Reference< vba::XHelperInterface >(), xContext )
+{
+	uno::Reference< vba::XHelperInterface > xParent;
+	comphelper::unwrapArgs( args, xParent, mxRange ); 
+	mxParent = xParent;
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, mxRange ) );
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex );
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< vba::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext ), mxRange( xRange ),
                 mbIsRows( bIsRows ),
                 mbIsColumns( bIsColumns )
 {
@@ -963,36 +1024,38 @@ ScVbaRange::ScVbaRange( const uno::Refer
 	if  ( !xRange.is() )
 		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "range is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
 
-	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( m_xContext, xRange ) );
-	m_Areas = new ScVbaRangeAreas( m_xContext, xIndex );
-	
-	m_Borders = lcl_setupBorders( m_xContext, mxRange );
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, xRange ) );
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex );
 
 }
 
-ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
-:m_xContext(xContext), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
+ScVbaRange::ScVbaRange( const uno::Reference< vba::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext ), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
 
 {
 	uno::Reference< container::XIndexAccess >  xIndex( mxRanges, uno::UNO_QUERY_THROW );
-	m_Areas	 = new ScVbaRangeAreas( m_xContext, xIndex );
+	m_Areas	 = new ScVbaRangeAreas( mxContext, xIndex );
 
-	// Some methods functions seem to operate on the first range defined
-	// but I don't want to enable the line below right now, I'd prefer the 
-	// Selection stuff to be non functional and enable it method by method
-	//m_xRange.set( mxRanges->getByIndex( 0 ); 
-	uno::Reference< table::XCellRange > xRange( mxRanges->getByIndex(0), uno::UNO_QUERY_THROW );
-	m_Borders = lcl_setupBorders( m_xContext, xRange );
 }
 
 ScVbaRange::~ScVbaRange()
 {
 }
 
+uno::Reference< vba::XCollection >& ScVbaRange::getBorders()
+{
+	if ( !m_Borders.is() )
+	{
+		uno::Reference< excel::XRange > xRange( getArea(0), uno::UNO_QUERY_THROW );
+		m_Borders = lcl_setupBorders( this, mxContext, uno::Reference< table::XCellRange >( xRange->getCellRange(), uno::UNO_QUERY_THROW ) );
+	}
+	return m_Borders;
+}
+
 uno::Reference< script::XTypeConverter >
 ScVbaRange::getTypeConverter() throw (uno::RuntimeException)
 {
-	static uno::Reference< script::XTypeConverter > xTypeConv( m_xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), m_xContext ), uno::UNO_QUERY_THROW );
+	static uno::Reference< script::XTypeConverter > xTypeConv( mxContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), mxContext ), uno::UNO_QUERY_THROW );
 	return xTypeConv;
 }
 
@@ -1125,7 +1188,7 @@ ScVbaRange::ClearContents( sal_Int32 nFl
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
 			if ( pRange )
 				pRange->ClearContents( nFlags );	
@@ -1171,7 +1234,7 @@ ScVbaRange::setFormulaValue( const uno::
 		aVisitor.visit( valueProcessor );
 		return;
 	}	
-	CellFormulaValueSetter formulaValueSetter( rFormula, getDocumentFromRange( mxRange ), eConv );
+	CellFormulaValueSetter formulaValueSetter( rFormula, getScDocument(), eConv );
 	setValue( rFormula, formulaValueSetter );
 }
 
@@ -1187,7 +1250,7 @@ ScVbaRange::getFormulaValue( ScAddress::
 		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
 		return xRange->getFormula();
 	}
-	CellFormulaValueGetter valueGetter( getDocumentFromRange( mxRange ), eConv );
+	CellFormulaValueGetter valueGetter( getScDocument(), eConv );
 	return getValue( valueGetter );
 		
 }
@@ -1281,7 +1344,7 @@ ScVbaRange::HasFormula() throw (uno::Run
 		uno::Any aResult = aNULL();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			// if the HasFormula for any area is different to another
 			// return null
 			if ( index > 1 )
@@ -1321,7 +1384,7 @@ ScVbaRange::fillSeries( sheet::FillDirec
 		uno::Reference< vba::XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
 		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			ScVbaRange* pThisRange = dynamic_cast< ScVbaRange* >( xRange.get() );
 			pThisRange->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
 				
@@ -1406,12 +1469,11 @@ ScVbaRange::Offset( const ::uno::Any &nR
 	if ( aCellRanges.Count() > 1 ) // Multi-Area
 	{
 		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
-		
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges ) );
+		return new ScVbaRange( getParent(), mxContext, xRanges );
 	}
 	// normal range
 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
-	return new ScVbaRange( m_xContext, xRange  );
+	return new ScVbaRange( getParent(), mxContext, xRange  );
 }
 
 uno::Reference< excel::XRange >
@@ -1432,7 +1494,7 @@ ScVbaRange::CurrentRegion() throw (uno::
 		helper.getSheetCellCursor();
 	xSheetCellCursor->collapseToCurrentRegion();
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
-	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
 }
 
 uno::Reference< excel::XRange >
@@ -1452,7 +1514,7 @@ ScVbaRange::CurrentArray() throw (uno::R
 		helper.getSheetCellCursor();
 	xSheetCellCursor->collapseToCurrentArray();
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
-	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
 }
 
 uno::Any
@@ -1530,7 +1592,7 @@ ScVbaRange::Address(  const uno::Any& Ro
                 uno::Any aExternalCopy = External;
 		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			if ( index > 1 )
 			{
 				sAddress += rtl::OUString( ',' );
@@ -1603,7 +1665,7 @@ ScVbaRange::Font() throw (uno::RuntimeEx
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );	
-	return uno::Reference< excel::XFont >( new ScVbaFont( aPalette, xProps, getCurrentDataSet() ) );
+	return  new ScVbaFont( this, mxContext, aPalette, xProps, getCurrentDataSet() );
 }
                                                                                                                              
 uno::Reference< excel::XRange >
@@ -1626,7 +1688,8 @@ ScVbaRange::Cells( const uno::Any &nRowI
 	table::CellRangeAddress thisRangeAddress =  thisRange.getCellRangeAddressable()->getRangeAddress();
 	uno::Reference< table::XCellRange > xSheetRange = thisRange.getCellRangeFromSheet();
 	if( !bIsIndex && !bIsColumnIndex ) // .Cells
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange ) );
+		// #FIXE needs proper parent ( Worksheet )
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), mxContext, mxRange ) );
 
 	sal_Int32 nIndex = --nRow;
 	if( bIsIndex && !bIsColumnIndex ) // .Cells(n)
@@ -1644,8 +1707,7 @@ ScVbaRange::Cells( const uno::Any &nRowI
 		--nColumn;
 	nRow = nRow + thisRangeAddress.StartRow;
 	nColumn =  nColumn + thisRangeAddress.StartColumn;	
-
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) ) );
+	return new ScVbaRange( getParent(), mxContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) );
 }
 
 void
@@ -1731,97 +1793,92 @@ ScVbaRange::Activate() throw (uno::Runti
 uno::Reference< excel::XRange >
 ScVbaRange::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	// #TODO code within the test below "if ( m_Areas.... " can be removed
-	// Test is performed only because m_xRange is NOT set to be
-	// the first range in m_Areas ( to force failure while
-	// the implementations for each method are being updated )
-	if ( m_Areas->getCount() > 1 )
-	{
-		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
-		return xRange->Rows( aIndex );
-	}
-	
+	SCROW nStartRow = 0;
+	SCROW nEndRow = 0;
+
 	sal_Int32 nValue;
 	rtl::OUString sAddress;
-	if( aIndex.hasValue() )
+
+	if ( aIndex.hasValue() )
 	{
-		uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxRange, uno::UNO_QUERY );
-		table::CellRangeAddress aAddress = xAddressable->getRangeAddress();
+		ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+		ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+
+		ScRange aRange = *aCellRanges.First();
 		if( aIndex >>= nValue )
 		{
-			aAddress.StartRow = --nValue;
-			aAddress.EndRow = nValue;
+			aRange.aStart.SetRow( aRange.aStart.Row() + --nValue );
+			aRange.aEnd.SetRow( aRange.aStart.Row() );
 		}
-	
+		
 		else if ( aIndex >>= sAddress ) 
 		{
-				ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
-			ScRange aRange;
-			aRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
-			aAddress.StartRow = aRange.aStart.Row();
-			aAddress.EndRow = aRange.aEnd.Row();
+			ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
+			ScRange tmpRange;
+			tmpRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartRow = tmpRange.aStart.Row();
+			nEndRow = tmpRange.aEnd.Row();
+
+			aRange.aStart.SetRow( aRange.aStart.Row() + nStartRow );
+			aRange.aEnd.SetRow( aRange.aStart.Row() + ( nEndRow  - nStartRow ));
 		}
 		else
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
-
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange->getCellRangeByPosition(
-						aAddress.StartColumn, aAddress.StartRow,
-						aAddress.EndColumn, aAddress.EndRow ), true ) 	); 	
-	}
-	// Questionable return, I'm just copying the invalid Any::value path
-	// above. Would seem to me that this is an internal error and 
-	// warrants an exception thrown
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, true ) );
+		
+		if ( aRange.aStart.Row() < 0 || aRange.aEnd.Row() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+		// return a normal range ( even for multi-selection
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+		return new ScVbaRange( getParent(), mxContext, xRange  );
+	}
+	// Rows() - no params
+	return new ScVbaRange(  getParent(), mxContext, mxRange, true );
 }	
 
 uno::Reference< excel::XRange >
-ScVbaRange::Columns( const uno::Any& aIndex ) throw (uno::RuntimeException)
+ScVbaRange::Columns(const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	// #TODO code within the test below "if ( m_Areas.... " can be removed
-	// Test is performed only because m_xRange is NOT set to be
-	// the first range in m_Areas ( to force failure while
-	// the implementations for each method are being updated )
-	if ( m_Areas->getCount() > 1 )
-	{
-		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
-		return xRange->Columns( aIndex );
-	}
+	SCCOL nStartCol = 0;
+	SCCOL nEndCol = 0;
+
+	sal_Int32 nValue;
+	rtl::OUString sAddress;
+
 	if ( aIndex.hasValue() )
 	{
-		uno::Reference< excel::XRange > xRange;
-		sal_Int32 nValue;
-		rtl::OUString sAddress;
-		RangeHelper thisRange( mxRange );
-		uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
-		uno::Reference< table::XCellRange > xRanges = thisRange.getCellRangeFromSheet();		
-		table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
-		uno::Reference< table::XCellRange > xReferrer = xRanges->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, MAXCOL, thisRangeAddress.EndRow );
-	
-		if ( aIndex >>= nValue )
-		{
-			--nValue;
-			// col value can expand outside this range
-			// rows however cannot
+		ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+		ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
 
-			thisRangeAddress.StartColumn = nValue;	
-			thisRangeAddress.EndColumn = nValue;	
+		ScRange aRange = *aCellRanges.First();
+		if( aIndex >>= nValue )
+		{
+			aRange.aStart.SetCol( aRange.aStart.Col() + --nValue );
+			aRange.aEnd.SetCol( aRange.aStart.Col() );
 		}
-		else if ( aIndex >>= sAddress )
+		
+		else if ( aIndex >>= sAddress ) 
 		{
 			ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
-			ScRange aRange;
-			aRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
-			thisRangeAddress.StartColumn = aRange.aStart.Col();
-			thisRangeAddress.EndColumn = aRange.aEnd.Col();
+			ScRange tmpRange;
+			tmpRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartCol = tmpRange.aStart.Col();
+			nEndCol = tmpRange.aEnd.Col();
+
+			aRange.aStart.SetCol( aRange.aStart.Col() + nStartCol );
+			aRange.aEnd.SetCol( aRange.aStart.Col() + ( nEndCol  - nStartCol ));
 		}
 		else
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xReferrer->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, thisRangeAddress.EndColumn, thisRangeAddress.EndRow ), false, true ) );
+		
+		if ( aRange.aStart.Col() < 0 || aRange.aEnd.Col() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+		// return a normal range ( even for multi-selection
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+		return new ScVbaRange( getParent(), mxContext, xRange  );
 	}
-	// otherwise return this object ( e.g for columns property with no
-	// params
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, false, true ) );
-}
+	// Columns() - no params
+	return new ScVbaRange(  getParent(), mxContext, mxRange, true );
+}	
 
 void
 ScVbaRange::setMergeCells( sal_Bool bIsMerged ) throw (uno::RuntimeException)
@@ -1899,7 +1956,7 @@ ScVbaRange::setNumberFormat( const uno::
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setNumberFormat( aFormat );	
 		}
 		return;
@@ -1918,7 +1975,7 @@ ScVbaRange::getNumberFormat() throw (uno
 		uno::Any aResult = aNULL();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			// if the numberformat of one area is different to another
 			// return null
 			if ( index > 1 )
@@ -1954,11 +2011,11 @@ ScVbaRange::Resize( const uno::Any &RowS
 	xCursor->collapseToSize( nColumnSize, nRowSize );
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xCursor, ::uno::UNO_QUERY_THROW );
 	uno::Reference< table::XCellRange > xRange( xSheetRange->getSpreadsheet(), ::uno::UNO_QUERY_THROW );
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext,xRange->getCellRangeByPosition(
+	return new ScVbaRange( getParent(), mxContext,xRange->getCellRangeByPosition(
 										xCellRangeAddressable->getRangeAddress().StartColumn,
 										xCellRangeAddressable->getRangeAddress().StartRow,
 										xCellRangeAddressable->getRangeAddress().EndColumn,
-										xCellRangeAddressable->getRangeAddress().EndRow ) ) );
+										xCellRangeAddressable->getRangeAddress().EndRow ) );
 }
                                                                                                                              
 void
@@ -1970,7 +2027,7 @@ ScVbaRange::setWrapText( const uno::Any&
 		uno::Any aResult;
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setWrapText( aIsWrapped );	
 		}
 		return;
@@ -1989,8 +2046,8 @@ ScVbaRange::getWrapText() throw (uno::Ru
 		uno::Any aResult;
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
-			if ( index > 1 )
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+				if ( index > 1 )
 				if ( aResult != xRange->getWrapText() )
 					return aNULL();
 			aResult = xRange->getWrapText(); 
@@ -2012,7 +2069,7 @@ ScVbaRange::getWrapText() throw (uno::Ru
 uno::Reference< excel::XInterior > ScVbaRange::Interior( ) throw (uno::RuntimeException)
 {
 	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
-        return uno::Reference<excel::XInterior> (new ScVbaInterior ( m_xContext, xProps, getDocumentFromRange( mxRange ) ));
+        return new ScVbaInterior ( this, mxContext, xProps, getScDocument() );
 }                                                                                                                             
 uno::Reference< excel::XRange >
 ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2 ) throw (uno::RuntimeException)
@@ -2051,7 +2108,7 @@ ScVbaRange::Range( const uno::Any &Cell1
 		Cell1 >>= sName;
 		RangeHelper referRange( xReferrer );		
 		table::CellRangeAddress referAddress = referRange.getCellRangeAddressable()->getRangeAddress();
-		return getRangeForName( m_xContext, sName, getDocShellFromRange( mxRange ), referAddress );
+		return getRangeForName( mxContext, sName, getScDocShell(), referAddress );
  
 	}
 	else
@@ -2105,11 +2162,11 @@ ScVbaRange::Range( const uno::Any &Cell1
 		{
 			ScRange aNew( (SCCOL)nStartX, (SCROW)nStartY, parentAddress.aStart.Tab(),
 						  (SCCOL)nEndX, (SCROW)nEndY, parentAddress.aEnd.Tab() );
-			xCellRange = new ScCellRangeObj( getDocShellFromRange( mxRange ), aNew );
+			xCellRange = new ScCellRangeObj( getScDocShell(), aNew );
 		}
 	}
 		
-	return uno::Reference< excel::XRange > ( new ScVbaRange( m_xContext, xCellRange )  );
+	return new ScVbaRange( getParent(), mxContext, xCellRange );
 
 }
 
@@ -2139,8 +2196,7 @@ getPasteFlags (sal_Int32 Paste)
 		nFlags = IDF_FORMULA;break;
         case excel::XlPasteType::xlPasteFormulasAndNumberFormats : 
         case excel::XlPasteType::xlPasteValues: 
-		// FOR_UPSTREAM_BUILD
-		//nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
+		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
 		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING ); break;
         case excel::XlPasteType::xlPasteValuesAndNumberFormats:
 		nFlags = IDF_VALUE | IDF_ATTRIB; break;
@@ -2226,10 +2282,10 @@ ScVbaRange::getEntireColumnOrRow( bool b
 	{
 		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
 		
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges, !bColumn, bColumn ) );
+		return new ScVbaRange( getParent(), mxContext, xRanges, !bColumn, bColumn );
 	}
 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
-	return new ScVbaRange( m_xContext, xRange, !bColumn, bColumn  );
+	return new ScVbaRange( getParent(), mxContext, xRange, !bColumn, bColumn  );
 }
 
 uno::Reference< excel::XRange > SAL_CALL 
@@ -2247,7 +2303,8 @@ ScVbaRange::getEntireColumn() throw (uno
 uno::Reference< excel::XComment > SAL_CALL 
 ScVbaRange::AddComment( const uno::Any& Text ) throw (uno::RuntimeException)
 {
-	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
 	// if you don't pass a valid text or if there is already a comment
 	// associated with the range then return NULL
 	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength() 
@@ -2261,7 +2318,7 @@ ScVbaRange::getComment() throw (uno::Run
 {
 	// intentional behavior to return a null object if no
 	// comment defined
-	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
 	if ( !xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
 		return NULL;
 	return xComment;
@@ -2287,7 +2344,7 @@ ScVbaRange::getHidden() throw (uno::Runt
 	// first area
 	if ( m_Areas->getCount() > 1 )
 	{
-		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)) ), uno::UNO_QUERY_THROW );
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)), uno::Any() ), uno::UNO_QUERY_THROW );
 		return xRange->getHidden();	
 	}
 	bool bIsVisible = false;
@@ -2312,7 +2369,7 @@ ScVbaRange::setHidden( const uno::Any& _
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setHidden( _hidden );	
 		}
 		return;
@@ -2340,7 +2397,7 @@ ScVbaRange::Replace( const ::rtl::OUStri
 	{
 		for ( sal_Int32 index = 1; index <= m_Areas->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->Replace( What, Replacement,  LookAt, SearchOrder, MatchCase, MatchByte, SearchFormat, ReplaceFormat );
 		}
 		return sal_True; // seems to return true always ( or at least I haven't found the trick of 
@@ -2514,17 +2571,16 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	sal_Int16 nDataOption2 = excel::XlSortDataOption::xlSortNormal;;
 	sal_Int16 nDataOption3 = excel::XlSortDataOption::xlSortNormal;
 
-	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	ScDocument* pDoc = getScDocument();
 	if ( !pDoc )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	RangeHelper thisRange( mxRange );
 	table::CellRangeAddress thisRangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
-	//SCTAB nTab = thisRangeAddress.Sheet;
+	SCTAB nTab = thisRangeAddress.Sheet;
 
 	ScSortParam aSortParam;
-	// FOR_UPSTREAM_BUILD
-	//pDoc->GetSortParam( aSortParam, nTab );
+	pDoc->GetSortParam( aSortParam, nTab );
 
 	if ( DataOption1.hasValue() )
 		DataOption1 >>= nDataOption1;
@@ -2578,16 +2634,13 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	if ( nOrientation == excel::XlSortOrientation::xlSortRows )
 		bIsSortColumns = sal_True;
 
-	// FOR_UPSTREAM_BUILD
-	//sal_Int16 nHeader = aSortParam.nCompatHeader;
-	sal_Int16 nHeader = 0;
+	sal_Int16 nHeader = aSortParam.nCompatHeader;
 	sal_Bool bContainsHeader = sal_False;
 
 	if ( Header.hasValue() )
 	{
 		nHeader = ::comphelper::getINT16( Header );
-		// FOR_UPSTREAM_BUILD
-		//aSortParam.nCompatHeader = nHeader;
+		aSortParam.nCompatHeader = nHeader;
 	}			
 
 	if ( nHeader == excel::XlYesNoGuess::xlGuess )
@@ -2599,8 +2652,7 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 		else
 			nHeader =  excel::XlYesNoGuess::xlNo; 
 		// save set param as default
-		// FOR_UPSTREAM_BUILD
-		//aSortParam.nCompatHeader = nHeader;
+		aSortParam.nCompatHeader = nHeader;
 	}
 
 	if ( nHeader == excel::XlYesNoGuess::xlYes )
@@ -2689,8 +2741,7 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	nIndex = 	findSortPropertyIndex( sortDescriptor, CONTS_HEADER );
 	sortDescriptor[ nIndex ].Value <<= bContainsHeader;
 
-	// FOR_UPSTREAM_BUILD
-	//pDoc->SetSortParam( aSortParam, nTab );
+	pDoc->SetSortParam( aSortParam, nTab );
 	xSort->sort( sortDescriptor );
 
 	// #FIXME #TODO
@@ -2719,7 +2770,7 @@ ScVbaRange::End( ::sal_Int32 Direction )
 	// Save ActiveCell pos ( to restore later )
 	uno::Any aDft;
 	rtl::OUString sActiveCell =	ScVbaGlobals::getGlobalsImpl(
-                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// position current cell upper left of this range
 	Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
@@ -2761,17 +2812,17 @@ ScVbaRange::End( ::sal_Int32 Direction )
 
 	// result is the ActiveCell		
 	rtl::OUString sMoved =	ScVbaGlobals::getGlobalsImpl(
-                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// restore old ActiveCell		
 	uno::Any aVoid;
 	uno::Reference< excel::XRange > xOldActiveCell( ScVbaGlobals::getGlobalsImpl(
-		m_xContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
+		mxContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
 	xOldActiveCell->Select();
 
 	uno::Reference< excel::XRange > resultCell;
 	resultCell.set( ScVbaGlobals::getGlobalsImpl(
-		m_xContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
+		mxContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
 
 	// return result
 	
@@ -2798,7 +2849,7 @@ ScVbaRange::characters( const uno::Any& 
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
-	return uno::Reference< excel::XCharacters >( new ScVbaCharacters( m_xContext, aPalette, xSimple, Start, Length ) );
+	return  new ScVbaCharacters( this, mxContext, aPalette, xSimple, Start, Length );
 }
 
  void SAL_CALL 
@@ -2810,7 +2861,7 @@ ScVbaRange::Delete( const uno::Any& Shif
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->Delete( Shift );	
 		}
 		return;
@@ -2859,7 +2910,7 @@ ScVbaRange::hasElements() throw (uno::Ru
 uno::Reference< container::XEnumeration > SAL_CALL 
 ScVbaRange::createEnumeration() throw (uno::RuntimeException)
 {
-	return new CellsEnumeration( m_xContext, mxRange );
+	return new CellsEnumeration( mxContext, mxRange );
 }
 
 ::rtl::OUString SAL_CALL 
@@ -2883,7 +2934,7 @@ getDeviceFromDoc( const uno::Reference< 
 double 
 ScVbaRange::getCalcColWidth( const table::CellRangeAddress& rAddress) throw (uno::RuntimeException)
 {
-	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	ScDocument* pDoc = getScDocument();
 	USHORT nWidth = pDoc->GetOriginalWidth( static_cast< SCCOL >( rAddress.StartColumn ), static_cast< SCTAB >( rAddress.Sheet ) );
 	double nPoints = lcl_TwipsToPoints( nWidth );
 	nPoints = lcl_Round2DecPlaces( nPoints );
@@ -2930,7 +2981,7 @@ uno::Any SAL_CALL 
 ScVbaRange::getColumnWidth() throw (uno::RuntimeException)
 {
 	double nColWidth = 	0;
-	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	ScDocShell* pShell = getScDocShell();
 	if ( pShell )
 	{
 		RangeHelper thisRange( mxRange );
@@ -2951,7 +3002,7 @@ ScVbaRange::setColumnWidth( const uno::A
 	double nColWidth = 0;
 	_columnwidth >>= nColWidth;
 	nColWidth = lcl_Round2DecPlaces( nColWidth );
-        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        ScDocShell* pDocShell = getScDocShell();
         if ( pDocShell )
         {
                 uno::Reference< frame::XModel > xModel = pDocShell->GetModel();
@@ -2995,7 +3046,7 @@ ScVbaRange::Areas( const uno::Any& item)
 {
 	if ( !item.hasValue() )
 		return uno::makeAny( m_Areas );
-	return m_Areas->Item( item );	
+	return m_Areas->Item( item, uno::Any() );	
 }
 
 uno::Reference< excel::XRange >
@@ -3003,7 +3054,7 @@ ScVbaRange::getArea( sal_Int32 nIndex ) 
 {
 	if ( !m_Areas.is() )
 		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("No areas available")), uno::Reference< uno::XInterface >() );
-	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ) ), uno::UNO_QUERY_THROW );
+	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ), uno::Any() ), uno::UNO_QUERY_THROW );
 	return xRange;
 }
 
@@ -3011,16 +3062,16 @@ uno::Any
 ScVbaRange::Borders( const uno::Any& item ) throw( css::uno::RuntimeException )
 {
 	if ( !item.hasValue() )
-		return uno::makeAny( m_Borders );
-	return m_Borders->Item( item );
+		return uno::makeAny( getBorders() );
+	return getBorders()->Item( item, uno::Any() );
 }
 
 uno::Any SAL_CALL
 ScVbaRange::BorderAround( const css::uno::Any& LineStyle, const css::uno::Any& Weight,
                 const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException)
 {
-    sal_Int32 nCount = m_Borders->getCount();
-    uno::Reference< excel::XBorders > xBorders( m_Borders, uno::UNO_QUERY_THROW);
+    sal_Int32 nCount = getBorders()->getCount();
+
     for( sal_Int32 i = 0; i < nCount; i++ )
     {
         const sal_Int32 nLineType = supportedIndexTable[i];
@@ -3031,7 +3082,7 @@ ScVbaRange::BorderAround( const css::uno
             case excel::XlBordersIndex::xlEdgeBottom:
             case excel::XlBordersIndex::xlEdgeRight:
             {
-                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ) ), uno::UNO_QUERY_THROW );
+                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ), uno::Any() ), uno::UNO_QUERY_THROW );
                 if( LineStyle.hasValue() )
                 {
                     xBorder->setLineStyle( LineStyle );
@@ -3177,7 +3228,8 @@ ScVbaRange::getWorksheet() throw (uno::R
 {
 	ScDocShell* pDocShell =  getDocShellFromRange(mxRange);
 	RangeHelper* rHelper = new RangeHelper(mxRange);
-        return new ScVbaWorksheet(m_xContext,rHelper->getSpreadSheet(),pDocShell->GetModel());
+	// parent should be Thisworkbook
+        return new ScVbaWorksheet( uno::Reference< vba::XHelperInterface >(), mxContext,rHelper->getSpreadSheet(),pDocShell->GetModel());
 }
 
 ScCellRangesBase*
@@ -3241,59 +3293,296 @@ ScVbaRange::ApplicationRange( const uno:
 			uno::Reference< table::XCellRange > xRange = xReferrer->getReferredCells();
 			if ( xRange.is() )
 			{
-				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( xContext, xRange );
+				// #FIXME need proper (WorkSheet) parent
+				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRange );
 				return xVbRange;
 			}
 		}
 	}
 	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY );
 	uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
-	ScVbaRange* pRange = new ScVbaRange( xContext, xSheetRange );
+	ScVbaRange* pRange = new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xSheetRange );
 	uno::Reference< excel::XRange > xVbSheetRange( pRange );
 	return pRange->Range( Cell1, Cell2, true ); 
 }
 
+//AutoFilter
+uno::Reference< sheet::XDatabaseRanges > 
+lcl_GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
+{
+	uno::Reference< frame::XModel > xModel;
+	if ( pShell )
+		xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
+	return xDBRanges;	
+}
+// returns the XDatabaseRange for the autofilter on sheet (nSheet)
+// also populates sName with the name of range
+uno::Reference< sheet::XDatabaseRange > 
+lcl_GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName )
+{
+	uno::Reference< container::XIndexAccess > xIndexAccess( lcl_GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
+	table::CellRangeAddress dbAddress;
+	for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
+	{
+		uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+		uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
+		// autofilters work weirdly with openoffice, unnamed is the default 
+		// named range which is used to create an autofilter, but
+		// its also possible that another name could be used
+		//     this also causes problems when an autofilter is created on
+		//     another sheet
+		// ( but.. you can use any named range )
+		dbAddress = xDBRange->getDataArea();
+		if ( dbAddress.Sheet == nSheet )
+		{
+			sal_Bool bHasAuto = sal_False;
+			uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
+			xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
+			if ( bHasAuto )
+			{
+				sName = xNamed->getName();	
+				xDataBaseRange=xDBRange;
+				break;
+			}
+		}
+	}
+	return xDataBaseRange;
+} 
 
-void SAL_CALL 
-ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const uno::Any& Operator, const uno::Any& /*Criteria2*/, const uno::Any& VisibleDropDown ) throw (uno::RuntimeException)
+// Helper functions for AutoFilter
+ScDBData* lcl_GetDBData_Impl( ScDocShell* pDocShell, sal_Int16 nSheet )
+{
+	rtl::OUString sName;
+	lcl_GetAutoFiltRange( pDocShell, nSheet, sName );
+	OSL_TRACE("lcl_GetDBData_Impl got autofilter range %s for sheet %d",
+		rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
+	ScDBData* pRet = NULL;
+	if (pDocShell)
+	{
+		ScDBCollection* pNames = pDocShell->GetDocument()->GetDBCollection();
+		if (pNames)
+		{
+			USHORT nPos = 0;
+			if (pNames->SearchName( sName , nPos ))
+				pRet = (*pNames)[nPos];
+		}
+	}
+	return pRet;
+}
+
+void lcl_SelectAll( ScDocShell* pDocShell, ScQueryParam& aParam )
 {
-	// #TODO We could probably hook into the autofilter stuff better
-	// or at least seperate the code in dbfunc so it could be shared
-	// currently a cut'n'paste fest exists below :-(
+	ScViewData* pViewData = pDocShell->GetViewData();
+	if ( pViewData )
+	{
+		OSL_TRACE("Pushing out SelectAll query");
+		pViewData->GetView()->Query( aParam, NULL, TRUE );
+	}
+}
 
-	ScDocument* pDoc =  getDocumentFromRange( mxRange );
-	ScDocShell* pDocSh = getDocShellFromRange( mxRange );	
-	ScDocShellModificator aModificator( *pDocSh );
-	sal_Bool bHasAuto = sal_True;	
-	RangeHelper thisRange( mxRange );	
-	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+ScQueryParam lcl_GetQueryParam( ScDocShell* pDocShell, sal_Int16 nSheet )
+{
+	ScDBData* pDBData = lcl_GetDBData_Impl( pDocShell, nSheet );	
+	ScQueryParam aParam;	
+	if (pDBData)
+	{
+		pDBData->GetQueryParam( aParam );
+	}
+	return aParam;
+}
 
-	ScRange aRange;	
-	ScUnoConversion::FillScRange( aRange, thisAddress );
-	ScDBData* pDBData = pDocSh->GetDBData( aRange, SC_DB_MAKE, TRUE );
-	ScQueryParam aParam;
-	pDBData->GetQueryParam( aParam );
-	SCROW  nRow = aParam.nRow1;
-	SCTAB  nTab = aRange.aStart.Tab();
-	INT16   nFlag;
+void lcl_SetAllQueryForField( ScQueryParam& aParam, sal_Int32 nField )
+{
+	bool bFound = false;
+	SCSIZE i = 0;
+	for (; i<MAXQUERY && !bFound; i++)
+	{
+		ScQueryEntry& rEntry = aParam.GetEntry(i);
+		if ( rEntry.nField == nField)
+		{
+			OSL_TRACE("found at pos %d", i );
+			bFound = true;
+		}
+	}
+	if ( bFound )
+	{
+		OSL_TRACE("field %d to delete at pos %d", nField, ( i - 1 ) );
+		aParam.DeleteQuery(--i);
+	}
+}
 
-	for (SCCOL nCol=aParam.nCol1; nCol<=aParam.nCol2 && ( bHasAuto == sal_True ); nCol++)
+
+void lcl_SetAllQueryForField( ScDocShell* pDocShell, sal_Int16 nField, sal_Int16 nSheet )
+{
+	ScQueryParam aParam = lcl_GetQueryParam( pDocShell, nSheet );
+	lcl_SetAllQueryForField( aParam, nField );
+	lcl_SelectAll( pDocShell, aParam );
+}
+
+// Modifies sCriteria, and nOp depending on the value of sCriteria
+void lcl_setTableFieldsFromCriteria( rtl::OUString& sCriteria1, uno::Reference< beans::XPropertySet >& xDescProps, sheet::TableFilterField& rFilterField )
+{
+	// #TODO make this more efficient and cycle through 
+	// sCriteria1 character by character to pick up <,<>,=, * etc.
+	// right now I am more concerned with just getting it to work right
+
+	sCriteria1 = sCriteria1.trim();
+	// table of translation of criteria text to FilterOperators
+	// <>searchtext - NOT_EQUAL
+	//  =searchtext - EQUAL
+	//  *searchtext - startwith
+	//  <>*searchtext - doesn't startwith
+	//  *searchtext* - contains
+	//  <>*searchtext* - doesn't contain
+	// [>|>=|<=|...]searchtext for GREATER_value, GREATER_EQUAL_value etc.
+	sal_Int32 nPos = 0;
+	bool bIsNumeric = false;
+	if ( ( nPos = sCriteria1.indexOf( EQUALS ) ) == 0 )
 	{
-		nFlag = ((ScMergeFlagAttr*) pDoc->GetAttr( nCol, nRow, nTab, ATTR_MERGE_FLAG ))->GetValue();
+		if ( sCriteria1.getLength() == EQUALS.getLength() )
+			rFilterField.Operator = sheet::FilterOperator_EMPTY;
+		else
+		{
+			rFilterField.Operator = sheet::FilterOperator_EQUAL;
+			sCriteria1 = sCriteria1.copy( EQUALS.getLength() );
+			sCriteria1 = VBAToRegexp( sCriteria1 );	
+			// UseRegularExpressions 
+			if ( xDescProps.is() )
+				xDescProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "UseRegularExpressions" ) ), uno::Any( sal_True ) );
+		}
 
-		if ( (nFlag & SC_MF_AUTO) == 0 )
-			bHasAuto = sal_False;
+	}
+	else if ( ( nPos = sCriteria1.indexOf( NOTEQUALS ) ) == 0 ) 
+	{
+		if ( sCriteria1.getLength() == NOTEQUALS.getLength() )
+			rFilterField.Operator = sheet::FilterOperator_NOT_EMPTY;	
+		else
+		{
+			rFilterField.Operator = sheet::FilterOperator_NOT_EQUAL;
+			sCriteria1 = sCriteria1.copy( NOTEQUALS.getLength() );
+			sCriteria1 = VBAToRegexp( sCriteria1 );	
+			// UseRegularExpressions 
+			if ( xDescProps.is() )
+				xDescProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "UseRegularExpressions" ) ), uno::Any( sal_True ) );
+		}
 	}	
+	else if ( ( nPos = sCriteria1.indexOf( GREATERTHAN ) ) == 0 ) 
+	{
+		bIsNumeric = true;
+		if ( ( nPos = sCriteria1.indexOf( GREATERTHANEQUALS ) ) == 0 )
+		{
+			sCriteria1 = sCriteria1.copy( GREATERTHANEQUALS.getLength() );
+			rFilterField.Operator = sheet::FilterOperator_GREATER_EQUAL;
+		}
+		else
+		{
+			sCriteria1 = sCriteria1.copy( GREATERTHAN.getLength() );
+			rFilterField.Operator = sheet::FilterOperator_GREATER;
+		}
 
-	OSL_TRACE("Auto is set ? %s", bHasAuto ? "true" : "false" );
+	}
+	else if ( ( nPos = sCriteria1.indexOf( LESSTHAN ) ) == 0 ) 
+	{
+		bIsNumeric = true;
+		if ( ( nPos = sCriteria1.indexOf( LESSTHANEQUALS ) ) == 0 )
+		{
+			sCriteria1 = sCriteria1.copy( LESSTHANEQUALS.getLength() );
+			rFilterField.Operator = sheet::FilterOperator_LESS_EQUAL;
+		}
+		else
+		{
+			sCriteria1 = sCriteria1.copy( LESSTHAN.getLength() );
+			rFilterField.Operator = sheet::FilterOperator_LESS;
+		}
+
+	}
+	else
+		rFilterField.Operator = sheet::FilterOperator_EQUAL;
+
+	if ( bIsNumeric )
+	{
+		rFilterField.IsNumeric= sal_True;
+		rFilterField.NumericValue = sCriteria1.toDouble();
+	}
+	rFilterField.StringValue = sCriteria1;	
+}
+
+void SAL_CALL 
+ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const uno::Any& Operator, const uno::Any& Criteria2, const uno::Any& VisibleDropDown ) throw (uno::RuntimeException)
+{
+	// Is there an existing autofilter	
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	sal_Int16 nSheet = thisAddress.Sheet;
+	ScDocShell* pShell = getScDocShell();
+	sal_Bool bHasAuto = sal_False;	
+	rtl::OUString sAutofiltRangeName;
+	uno::Reference< sheet::XDatabaseRange > xDataBaseRange = lcl_GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
+	if ( xDataBaseRange.is() )
+		bHasAuto = true;	
+
+	uno::Reference< table::XCellRange > xFilterRange;
+	if ( !bHasAuto )
+	{
+		if (  m_Areas->getCount() > 1 )
+			throw uno::RuntimeException( STR_ERRORMESSAGE_APPLIESTOSINGLERANGEONLY, uno::Reference< uno::XInterface >() );
+
+		table::CellRangeAddress autoFiltAddress; 
+		//CurrentRegion()
+		if ( isSingleCellRange() )
+		{
+			uno::Reference< excel::XRange > xCurrent( CurrentRegion() );
+			if ( xCurrent.is() )
+			{
+				ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xCurrent.get() );
+				if ( pRange->isSingleCellRange() )
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't create AutoFilter") ), uno::Reference< uno::XInterface >() );
+				if ( pRange )
+				{
+					RangeHelper currentRegion( pRange->mxRange );
+					autoFiltAddress = currentRegion.getCellRangeAddressable()->getRangeAddress();
+				}
+			}
+		} 
+		else // multi-cell range
+		{
+			RangeHelper multiCellRange( mxRange );
+			autoFiltAddress = multiCellRange.getCellRangeAddressable()->getRangeAddress();
+		}
 
-	// for the moment we only process first Criteria1	
+		uno::Reference< sheet::XDatabaseRanges > xDBRanges = lcl_GetDataBaseRanges( pShell );
+		if ( xDBRanges.is() )
+		{
+			rtl::OUString sGenName( RTL_CONSTASCII_USTRINGPARAM("VBA_Autofilter_") );
+			sGenName += rtl::OUString::valueOf( static_cast< sal_Int32 >( nSheet ) );
+			OSL_TRACE("Going to add new autofilter range.. name %s",
+				rtl::OUStringToOString( sGenName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
+			if ( !xDBRanges->hasByName( sGenName ) )
+				xDBRanges->addNewByName(  sGenName, autoFiltAddress );
+			xDataBaseRange.set( xDBRanges->getByName(  sGenName ), uno::UNO_QUERY_THROW );
+		}
+		if ( !xDataBaseRange.is() )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Failed to find the autofilter placeholder range" ) ), uno::Reference< uno::XInterface >() );		
+
+		uno::Reference< beans::XPropertySet > xDBRangeProps( xDataBaseRange, uno::UNO_QUERY_THROW );
+		// set autofilt
+		xDBRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::Any(sal_True) ); 
+		// set header
+		uno::Reference< beans::XPropertySet > xFiltProps( xDataBaseRange->getFilterDescriptor(), uno::UNO_QUERY_THROW );
+		sal_Bool bHasColHeader = sal_False;
+		ScDocument* pDoc = pShell ? pShell->GetDocument() : NULL;
 		
-	sal_Int32 nField = 0; // *IS* 1 based
-	rtl::OUString sCriteria1;
-	sal_Int32 nOperator = excel::XlAutoFilterOperator::xlAnd; 
+		bHasColHeader = pDoc->HasColHeader(  static_cast< SCCOL >( autoFiltAddress.StartColumn ), static_cast< SCROW >( autoFiltAddress.StartRow ), static_cast< SCCOL >( autoFiltAddress.EndColumn ), static_cast< SCROW >( autoFiltAddress.EndRow ), static_cast< SCTAB >( autoFiltAddress.Sheet ) ) ? sal_True : sal_False;
+		xFiltProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ContainsHeader") ), uno::Any( bHasColHeader ) );	
+	}
 
 
+	sal_Int32 nField = 0; // *IS* 1 based
+	rtl::OUString sCriteria1;
+	sal_Int32 nOperator = excel::XlAutoFilterOperator::xlAnd;
 	
 	sal_Bool bVisible = sal_True;
 	bool  bChangeDropDown = false;
@@ -3304,117 +3593,149 @@ ScVbaRange::AutoFilter( const uno::Any& 
 		bVisible = sal_False;
 	else
 		bChangeDropDown = true;	
-
-	sheet::FilterOperator nOp = sheet::FilterOperator_EQUAL;		
 	sheet::FilterConnection nConn = sheet::FilterConnection_AND;		
 	double nCriteria1 = 0;
 
 	bool bHasCritValue = Criteria1.hasValue();
-	bool bCritHasNumericValue = sal_False;
+	bool bCritHasNumericValue = sal_False; // not sure if a numeric criteria is possible
 	if ( bHasCritValue )
 		bCritHasNumericValue = ( Criteria1 >>= nCriteria1 );
 
-	if ( ( Field >>= nField ) 
-	||   Criteria1.hasValue()
-	||   ( Operator >>= nOperator )
-	||   VisibleDropDown.hasValue()
-	)
-	{
-		Criteria1 >>= sCriteria1;
-		uno::Reference< sheet::XSheetFilterable > xFilt( mxRange, uno::UNO_QUERY_THROW );
-		uno::Reference< sheet::XSheetFilterDescriptor > xDesc = xFilt->createFilterDescriptor( sal_True );
-		uno::Sequence< sheet::TableFilterField > sTabFilts = xDesc->getFilterFields();
-		sTabFilts.realloc( 1 );
-		sTabFilts[0].IsNumeric = bCritHasNumericValue;
-		OSL_TRACE("No filt fields is %d", sTabFilts.getLength() );
-
-		if ( bHasCritValue && sCriteria1.getLength() )
-		{
-			if ( sCriteria1.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=") ) ) )
-				nOp = sheet::FilterOperator_EMPTY;
-			else if ( sCriteria1.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("<>") ) ) )
-				nOp = sheet::FilterOperator_NOT_EMPTY;	
-			else
-				nOp = sheet::FilterOperator_EQUAL;
+	if (  !Field.hasValue() && ( Criteria1.hasValue() || Operator.hasValue() || Criteria2.hasValue() ) ) 
+		throw uno::RuntimeException();
+	// Use the normal uno api, sometimes e.g. when you want to use ALL as the filter
+	// we can't use refresh as the uno interface doesn't have a concept of ALL
+	// in this case we just call the core calc functionality - 
+	bool bAll = false;;
+	if ( ( Field >>= nField )  )
+	{
+		uno::Sequence< sheet::TableFilterField > sTabFilts;
+		uno::Reference< sheet::XSheetFilterDescriptor > xDesc = xDataBaseRange->getFilterDescriptor();
+		uno::Reference< beans::XPropertySet > xDescProps( xDesc, uno::UNO_QUERY_THROW );
+		if ( Criteria1.hasValue() )
+		{ 
+			sTabFilts.realloc( 1 );
+			sTabFilts[0].Operator = sheet::FilterOperator_EQUAL;// sensible default
+			if ( !bCritHasNumericValue )
+			{ 
+				Criteria1 >>= sCriteria1;
+				sTabFilts[0].IsNumeric = bCritHasNumericValue;
+				if ( bHasCritValue && sCriteria1.getLength() )
+					lcl_setTableFieldsFromCriteria( sCriteria1, xDescProps, sTabFilts[0]  );
+				else
+					bAll = true;
+			}
+			else // numeric
+			{
+				sTabFilts[0].IsNumeric = sal_True;
+				sTabFilts[0].NumericValue = nCriteria1;
+			}
 		}
-
-		if ( Operator.hasValue() )
+		else // no value specified
+			bAll = true;
+		// not sure what the relationship between Criteria1 and Operator is,
+		// e.g. can you have a Operator without a Criteria ? in openoffice it 	
+		if ( Operator.hasValue()  && ( Operator >>= nOperator ) )
 		{
 			// if its a bottom/top Ten(Percent/Value) and there
 			// is no value specified for critera1 set it to 10
 			if ( !bCritHasNumericValue && !sCriteria1.getLength() && ( nOperator != excel::XlAutoFilterOperator::xlOr ) && ( nOperator != excel::XlAutoFilterOperator::xlAnd ) )
 			{
-				nCriteria1 = 10;
 				sTabFilts[0].IsNumeric = sal_True;	
+				sTabFilts[0].NumericValue = 10;	
+				bAll = false;
 			}
 			switch ( nOperator )
 			{
 				case excel::XlAutoFilterOperator::xlBottom10Items:
-					nOp = sheet::FilterOperator_BOTTOM_VALUES;
+					sTabFilts[0].Operator = sheet::FilterOperator_BOTTOM_VALUES;
 					break;
 				case excel::XlAutoFilterOperator::xlBottom10Percent:
-					nOp = sheet::FilterOperator_BOTTOM_PERCENT;
+					sTabFilts[0].Operator = sheet::FilterOperator_BOTTOM_PERCENT;
 					break;
 				case excel::XlAutoFilterOperator::xlTop10Items:
-					nOp = sheet::FilterOperator_TOP_VALUES;
+					sTabFilts[0].Operator = sheet::FilterOperator_TOP_VALUES;
 					break;
 				case excel::XlAutoFilterOperator::xlTop10Percent:
-					nOp = sheet::FilterOperator_TOP_PERCENT;
+					sTabFilts[0].Operator = sheet::FilterOperator_TOP_PERCENT;
 					break;
 				case excel::XlAutoFilterOperator::xlOr:
-					nConn = sheet::FilterConnection_OR;		
+					nConn = sheet::FilterConnection_OR;
+					break;
 				case excel::XlAutoFilterOperator::xlAnd:
-					nConn = sheet::FilterConnection_AND;		
+					nConn = sheet::FilterConnection_AND;
+					break;
 				default:
 					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UnknownOption") ), uno::Reference< uno::XInterface >() );
 					
 			}	
 
 		}		
-		sTabFilts[0].Connection = nConn;	
-		if ( nField > 0 )
+		if ( !bAll )
+		{
+			sTabFilts[0].Connection = sheet::FilterConnection_AND;	
 			sTabFilts[0].Field = (nField - 1);	
-		else
-			sTabFilts[0].Field = 0;	
-		sTabFilts[0].Operator = nOp;	
-		if(	sTabFilts[0].IsNumeric )
-			sTabFilts[0].NumericValue = nCriteria1;	
-		else
-			sTabFilts[0].StringValue = sCriteria1;	
+
+			rtl::OUString sCriteria2;
+			if ( Criteria2.hasValue() ) // there is a Criteria2
+			{
+				sTabFilts.realloc(2);
+				sTabFilts[1].Field = sTabFilts[0].Field;
+				sTabFilts[1].Connection = nConn;	
+
+				if ( Criteria2 >>= sCriteria2 )
+				{
+					if ( sCriteria2.getLength() > 0 )
+					{
+						uno::Reference< beans::XPropertySet > xProps;
+						lcl_setTableFieldsFromCriteria( sCriteria2, xProps,  sTabFilts[1] );
+						sTabFilts[1].IsNumeric = sal_False;
+					}
+				}
+				else // numeric
+				{
+					Criteria2 >>= sTabFilts[1].NumericValue;
+					sTabFilts[1].IsNumeric = sal_True;
+					sTabFilts[1].Operator = sheet::FilterOperator_EQUAL;
+				}
+			}
+		}
 
 		xDesc->setFilterFields( sTabFilts );
-		uno::Reference< beans::XPropertySet > xProps( xDesc, uno::UNO_QUERY_THROW );
-		xProps->setPropertyValue( CONTS_HEADER, uno::makeAny( sal_True ) );
-		xFilt->filter( xDesc );
-	
+		if ( !bAll )
+		{
+			xDataBaseRange->refresh();
+		}
+		else
+			// was 0 based now seems to be 1 
+			lcl_SetAllQueryForField( pShell, nField, nSheet );
 	}
 	else 
-		bChangeDropDown = true;	
-	// enable drop down
-	if ( bChangeDropDown )
 	{
-		ScRange aTmpRange;
-		pDBData->GetArea( aTmpRange );
-		for (SCCOL nCol=aParam.nCol1; nCol<=aParam.nCol2; nCol++)
-		{
-			nFlag = ((ScMergeFlagAttr*) pDoc->GetAttr( nCol, nRow, nTab, ATTR_MERGE_FLAG ))->GetValue();
-			if ( bVisible )
-				pDoc->ApplyAttr( nCol, nRow, nTab, ScMergeFlagAttr( nFlag | SC_MF_AUTO ) );
-			else
-				pDoc->ApplyAttr( nCol, nRow, nTab, ScMergeFlagAttr( nFlag &~ SC_MF_AUTO ) );
-		}
-		if ( !bVisible )
+		// this is just to toggle autofilter on and off ( not to be confused with 
+		// a VisibleDropDown option combined with a field, in that case just the 
+		// button should be disabled ) - currently we don't support that
+		bChangeDropDown = true;	
+		uno::Reference< beans::XPropertySet > xDBRangeProps( xDataBaseRange, uno::UNO_QUERY_THROW );
+		if ( bHasAuto )
 		{
-			SCSIZE nEC = aParam.GetEntryCount();
-			for (SCSIZE i=0; i<nEC; i++)
-				aParam.GetEntry(i).bDoQuery = FALSE;
-			aParam.bDuplicate = TRUE;
-			ScDBDocFunc aDBDocFunc( *pDocSh );
-			aDBDocFunc.Query( nTab, aParam, &aTmpRange, TRUE, FALSE );
+			// find the any field with the query and select all
+			ScQueryParam aParam = lcl_GetQueryParam( pShell, nSheet );
+			SCSIZE i = 0;
+			for (; i<MAXQUERY; i++)
+			{
+				ScQueryEntry& rEntry = aParam.GetEntry(i);
+				if ( rEntry.bDoQuery )
+					lcl_SetAllQueryForField( pShell, rEntry.nField, nSheet );
+			}
+			// remove exising filters
+			xDataBaseRange->getFilterDescriptor()->setFilterFields( uno::Sequence< sheet::TableFilterField >() );
 		}
-		pDocSh->PostPaint( aParam.nCol1, nRow, nTab, aParam.nCol2, nRow, nTab, PAINT_GRID );	
-	}		
+		xDBRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::Any(!bHasAuto) );
+
+	}
 }
+
 void SAL_CALL 
 ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& /*CopyOrigin*/ ) throw (uno::RuntimeException)
 {
@@ -3603,7 +3924,7 @@ css::uno::Reference< excel::XValidation 
 ScVbaRange::getValidation() throw (css::uno::RuntimeException)
 {
 	if ( !m_xValidation.is() )	
-		m_xValidation = new ScVbaValidation( m_xContext, mxRange );
+		m_xValidation = new ScVbaValidation( this, mxContext, mxRange );
 	return m_xValidation;
 }
 
@@ -3617,7 +3938,7 @@ ScVbaRange::PrintOut( const uno::Any& Fr
 	uno::Reference< sheet::XPrintAreas > xPrintAreas;
 	for ( sal_Int32 index=1; index <= nItems; ++index )
 	{
-		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 
 		RangeHelper thisRange( xRange->getCellRange() );
 		table::CellRangeAddress rangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
@@ -3716,7 +4037,7 @@ ScVbaRange::AutoFill(  const uno::Refere
 	FillCmd eCmd = FILL_AUTO;
 	FillDateCmd eDateCmd = FILL_DAY;	
 
-	//double fEndValue =  MAXDOUBLE;
+	double fEndValue =  MAXDOUBLE;
 
 	if ( Type.hasValue() )
 	{
@@ -3761,8 +4082,65 @@ ScVbaRange::AutoFill(  const uno::Refere
 		}	
 	}
 	ScDocFunc aFunc(*pDocSh);
-	// FOR_UPSTREAM_BUILD
-	/*aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd,
-								nCount, fStep, fEndValue, TRUE, TRUE );
-	*/
+		aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd,
+									nCount, fStep, fEndValue, TRUE, TRUE );
+}
+#include <comphelper/anytostring.hxx>
+sal_Bool SAL_CALL
+ScVbaRange::GoalSeek( const uno::Any& Goal, const uno::Reference< excel::XRange >& ChangingCell ) throw (uno::RuntimeException)
+{
+	ScDocShell* pDocShell = getScDocShell();
+	sal_Bool bRes = sal_True;
+	ScVbaRange* pRange = static_cast< ScVbaRange* >( ChangingCell.get() );
+	if ( pDocShell && pRange )
+	{
+		uno::Reference< sheet::XGoalSeek > xGoalSeek(  pDocShell->GetModel(), uno::UNO_QUERY_THROW );
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		RangeHelper changingCellRange( pRange->mxRange );
+		table::CellRangeAddress changingCellAddr = changingCellRange.getCellRangeAddressable()->getRangeAddress();
+		rtl::OUString sGoal = getAnyAsString( Goal );
+		table::CellAddress thisCell( thisAddress.Sheet, thisAddress.StartColumn, thisAddress.StartRow );
+		table::CellAddress changingCell( changingCellAddr.Sheet, changingCellAddr.StartColumn, changingCellAddr.StartRow );
+		sheet::GoalResult res = xGoalSeek->seekGoal( thisCell, changingCell, sGoal );
+		ChangingCell->setValue( uno::makeAny( res.Result ) );
+		
+		// openoffice behaves differently, result is 0 if the divergence is too great
+                // but... if it detects 0 is the value it requires then it will use that
+		// e.g. divergence & result both = 0.0 does NOT mean there is an error
+		if ( ( res.Divergence != 0.0 ) && ( res.Result == 0.0 ) )
+			bRes = sal_False;
+	}
+	else
+		bRes = sal_False;
+	return bRes;
+}
+
+rtl::OUString& 
+ScVbaRange::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaRange") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaRange::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range" ) );
+	}
+	return aServiceNames;
+}
+
+namespace range
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaRange, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SvVbaRange",
+    "org.openoffice.excel.Range" );
 }
