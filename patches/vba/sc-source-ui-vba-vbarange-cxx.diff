--- sc/source/ui/vba//vbarange.cxx	
+++ sc/source/ui/vba//vbarange.cxx
@@ -32,10 +32,14 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
+#include "helperdecl.hxx"
+
+#include <comphelper/unwrapargs.hxx>
 #include <comphelper/processfactory.hxx>
 #include <sfx2/objsh.hxx>
 
 #include <com/sun/star/script/ArrayWrapper.hpp>
+#include <com/sun/star/sheet/XGoalSeek.hpp>
 #include <com/sun/star/sheet/XSheetOperation.hpp>
 #include <com/sun/star/sheet/CellFlags.hpp>
 #include <com/sun/star/table/XColumnRowRange.hpp>
@@ -45,6 +49,7 @@
 #include <com/sun/star/text/XTextRange.hpp>
 #include <com/sun/star/sheet/XCellRangeAddressable.hpp>
 #include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
 #include <com/sun/star/sheet/XSpreadsheetView.hpp>
 #include <com/sun/star/sheet/XCellRangeReferrer.hpp>
 #include <com/sun/star/sheet/XSheetCellRange.hpp>
@@ -149,9 +154,13 @@
 #include <com/sun/star/sheet/FunctionArgument.hpp>
 // end test includes
 
+#include <org/openoffice/excel/Range.hpp>
+
 using namespace ::org::openoffice;
 using namespace ::com::sun::star;
 
+
+
 //    * 1 point = 1/72 inch = 20 twips
 //    * 1 inch = 72 points = 1440 twips
 //    * 1 cm = 567 twips
@@ -186,31 +195,29 @@ double lcl_Round2DecPlaces( double nVal 
 uno::Any lcl_makeRange( uno::Reference< uno::XComponentContext >& xContext, const uno::Any aAny )
 {
 	uno::Reference< table::XCellRange > xCellRange( aAny, uno::UNO_QUERY_THROW );
-	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( xContext, xCellRange ) ) );
+	// #FIXME need proper (WorkSheet) parent
+	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xCellRange ) ) );
 }
 
 SfxItemSet*  ScVbaRange::getCurrentDataSet( ) throw ( uno::RuntimeException )
 {
 	uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
-	//ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
-	// FOR_UPSTREAM_BUILD
-	/*SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
+	ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
+	SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
 	
 	if ( !pDataSet )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't access Itemset for range" ) ), uno::Reference< uno::XInterface >() );
 	return pDataSet;	
-	*/
-	return NULL;
 }
 
 class SingleRangeEnumeration : public EnumerationHelper_BASE
 {
 	uno::Reference< table::XCellRange > m_xRange;
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	bool bHasMore;
 public:
 
-	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), m_xContext( xContext ), bHasMore( true ) { }
+	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), mxContext( xContext ), bHasMore( true ) { }
 	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) { return bHasMore; }
 	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
 	{
@@ -229,10 +236,10 @@ class SingleRangeIndexAccess : public Si
 {
 private:
 	uno::Reference< table::XCellRange > m_xRange;
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	SingleRangeIndexAccess(); // not defined
 public:
-	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), m_xContext( xContext ) {}
+	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), mxContext( xContext ) {}
 	// XIndexAccess
 	virtual ::sal_Int32 SAL_CALL getCount() throw (::uno::RuntimeException) { return 1; }
 	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
@@ -246,7 +253,7 @@ public:
  
         virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException) { return sal_True; }
 	// XEnumerationAccess
-	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( m_xContext, m_xRange ); }
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( mxContext, m_xRange ); }
 
 };
 
@@ -268,7 +275,7 @@ class ScVbaRangeAreas : public ScVbaColl
 {
 
 public:
-	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : ScVbaCollectionBaseImpl( xContext, xIndexAccess ) {}
+	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : ScVbaCollectionBaseImpl( uno::Reference< vba::XHelperInterface >(), xContext, xIndexAccess ) {}
 
 	// XEnumerationAccess
 	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException);
@@ -277,27 +284,30 @@ public:
 	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return excel::XRange::static_type(0); }
 
 	virtual uno::Any createCollectionObject( const uno::Any& aSource );
-};
 
+	virtual rtl::OUString& getServiceImplName() { static rtl::OUString sDummy; return sDummy; }
+
+	virtual uno::Sequence< rtl::OUString > getServiceNames() { return uno::Sequence< rtl::OUString >(); } 
+
+}; 
 
 uno::Reference< container::XEnumeration > SAL_CALL 
 ScVbaRangeAreas::createEnumeration() throw (uno::RuntimeException)
 {
 	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
-	return new RangesEnumerationImpl( m_xContext, xEnumAccess->createEnumeration() );
+	return new RangesEnumerationImpl( mxContext, xEnumAccess->createEnumeration() );
 
 }
 
 uno::Any 
 ScVbaRangeAreas::createCollectionObject( const uno::Any& aSource )
 {
-	return lcl_makeRange( m_xContext, aSource );
+	return lcl_makeRange( mxContext, aSource );
 }
 
 
-
-
-ScDocShell* getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange )
+ScDocShell* 
+getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange )
 {
 	// need the ScCellRangesBase to get docshell
 	uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
@@ -307,7 +317,8 @@ ScDocShell* getDocShellFromRange( const 
 	return pUno->GetDocShell();
 }
 
-ScDocument* getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
+ScDocument* 
+getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
 {
 	ScDocShell* pDocShell = getDocShellFromRange( xRange );
 	if ( !pDocShell )
@@ -316,6 +327,19 @@ ScDocument* getDocumentFromRange( const 
 	return pDoc;
 }
 
+
+ScDocument* 
+ScVbaRange::getScDocument()
+{
+	return getDocumentFromRange( mxRange );
+}
+
+ScDocShell* 
+ScVbaRange::getScDocShell()
+{
+	return getDocShellFromRange( mxRange );
+}
+
 class NumFormatHelper
 {
 	uno::Reference< util::XNumberFormatsSupplier > mxSupplier;
@@ -353,15 +377,13 @@ public:
 		ScCellRangeObj* pUnoCellRange = dynamic_cast<  ScCellRangeObj* >( xIf.get() );
 		if ( pUnoCellRange )
 		{
-			// FOR_UPSTREAM_BUILD
-			/*
+			
 			SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
 			SfxItemState eState = pDataSet->GetItemState( ATTR_VALUE_FORMAT, TRUE, NULL);
 			// one of the cells in the range is not like the other ;-)
 			// so return a zero length format to indicate that
 			if ( eState == SFX_ITEM_DONTCARE )
 				return rtl::OUString();
-			*/
 		}
 		
 	
@@ -424,12 +446,12 @@ typedef vector< CellPos > vCellPos;
 
 class CellsEnumeration : public CellsEnumeration_BASE
 {
-	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< uno::XComponentContext > mxContext;
 	uno::Reference< table::XCellRange > m_xRange;
 	vCellPos m_CellPositions;	
 	vCellPos::const_iterator m_it; 
 public:
-	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): m_xContext( xContext ), m_xRange( xRange )
+	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): mxContext( xContext ), m_xRange( xRange )
 	{
 		uno::Reference< table::XColumnRowRange > xColumnRowRange(m_xRange, uno::UNO_QUERY_THROW );
 		sal_Int32 nRowCount =  xColumnRowRange->getRows()->getCount();
@@ -447,7 +469,8 @@ public:
 			throw container::NoSuchElementException();
 		CellPos aPos = *(m_it)++;
 		uno::Reference< table::XCellRange > xCellRange( m_xRange->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
-		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xCellRange ) ) );
+		// #FIXME need proper (WorkSheet) parent
+		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), mxContext, xCellRange ) ) );
 	}
 };
 
@@ -594,7 +617,8 @@ protected:
 		{
 			// get current convention
 			ScAddress::Convention eConv = m_pDoc->GetAddressConvention();
-			if ( eConv != m_eConv )	
+			// only convert/compile 'real' formulas
+			if ( eConv != m_eConv && ( sFormula.trim().indexOf('=') == 0 ) )	
 			{
 				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
 				ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
@@ -786,7 +810,7 @@ public:
 			sal_Int32 nItems = m_Areas->getCount();
 			for ( sal_Int32 index=1; index <= nItems; ++index )
 			{
-				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 				processor.process( xRange ); 
 			}
 		}	
@@ -835,7 +859,8 @@ public:
 	static uno::Reference< excel::XRange > createRangeFromRange( const uno::Reference<uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, const uno::Reference< sheet::XCellRangeAddressable >& xCellRangeAddressable, sal_Int32 nStartColOffset = 0, sal_Int32 nStartRowOffset = 0,
  sal_Int32 nEndColOffset = 0, sal_Int32 nEndRowOffset = 0 )
 	{
-		return uno::Reference< excel::XRange >( new ScVbaRange( xContext, 
+		// #FIXME need proper (WorkSheet) parent
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, 
 			xRange->getCellRangeByPosition(
 				xCellRangeAddressable->getRangeAddress().StartColumn + nStartColOffset,
 				xCellRangeAddressable->getRangeAddress().StartRow + nStartRowOffset,
@@ -899,7 +924,7 @@ getRangeForName( const uno::Reference< u
 	rtl::OUString sAddress = sName;
 	ScAddress::Convention eConv = ScAddress::CONV_XL_A1; 
 	// see if there is a match with a named range
-	uno::Reference< beans::XPropertySet > xProps( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps( pDocSh->GetModel(), uno::UNO_QUERY_THROW );
 	uno::Reference< container::XNameAccess > xNameAccess( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NamedRanges") ) ), uno::UNO_QUERY_THROW );
 
 	if ( xNameAccess->hasByName( sName ) )
@@ -933,28 +958,41 @@ getRangeForName( const uno::Reference< u
 	if ( aCellRanges.First() == aCellRanges.Last() )
 	{
 		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pDocSh, *aCellRanges.First() ) );
-		return new ScVbaRange( xContext, xRange );
+		// #FIXME need proper (WorkSheet) parent
+		return new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRange );
 	}
 	uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pDocSh, aCellRanges ) );
  	
-	return new ScVbaRange( xContext, xRanges );
+	// #FIXME need proper (WorkSheet) parent
+	return new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRanges );
 	
 }
 
 uno::Reference< vba::XCollection >
-lcl_setupBorders( const uno::Reference<uno::XComponentContext>& xContext,  uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
+lcl_setupBorders( const uno::Reference< excel::XRange >& xParentRange, const uno::Reference<uno::XComponentContext>& xContext,  uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
 {
+	uno::Reference< vba::XHelperInterface > xParent( xParentRange, uno::UNO_QUERY_THROW ); 
 	ScDocument* pDoc = getDocumentFromRange(xRange);
 	if ( !pDoc )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
- 	uno::Reference< vba::XCollection > borders( new ScVbaBorders( xContext, xRange, aPalette ) );
+ 	uno::Reference< vba::XCollection > borders( new ScVbaBorders( xParent, xContext, xRange, aPalette ) );
 	return borders;
 }
 
-ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
-: mxRange( xRange ),
-                m_xContext(xContext),
+
+ScVbaRange::ScVbaRange( uno::Sequence< uno::Any> const & args,
+    uno::Reference< uno::XComponentContext> const & xContext ) : ScVbaRange_BASE( uno::Reference< vba::XHelperInterface >(), xContext )
+{
+	uno::Reference< vba::XHelperInterface > xParent;
+	comphelper::unwrapArgs( args, xParent, mxRange ); 
+	mxParent = xParent;
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, mxRange ) );
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex );
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< vba::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext ), mxRange( xRange ),
                 mbIsRows( bIsRows ),
                 mbIsColumns( bIsColumns )
 {
@@ -963,36 +1001,38 @@ ScVbaRange::ScVbaRange( const uno::Refer
 	if  ( !xRange.is() )
 		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "range is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
 
-	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( m_xContext, xRange ) );
-	m_Areas = new ScVbaRangeAreas( m_xContext, xIndex );
-	
-	m_Borders = lcl_setupBorders( m_xContext, mxRange );
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( mxContext, xRange ) );
+	m_Areas = new ScVbaRangeAreas( mxContext, xIndex );
 
 }
 
-ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
-:m_xContext(xContext), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
+ScVbaRange::ScVbaRange( const uno::Reference< vba::XHelperInterface >& xParent, const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
+: ScVbaRange_BASE( xParent, xContext ), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
 
 {
 	uno::Reference< container::XIndexAccess >  xIndex( mxRanges, uno::UNO_QUERY_THROW );
-	m_Areas	 = new ScVbaRangeAreas( m_xContext, xIndex );
+	m_Areas	 = new ScVbaRangeAreas( mxContext, xIndex );
 
-	// Some methods functions seem to operate on the first range defined
-	// but I don't want to enable the line below right now, I'd prefer the 
-	// Selection stuff to be non functional and enable it method by method
-	//m_xRange.set( mxRanges->getByIndex( 0 ); 
-	uno::Reference< table::XCellRange > xRange( mxRanges->getByIndex(0), uno::UNO_QUERY_THROW );
-	m_Borders = lcl_setupBorders( m_xContext, xRange );
 }
 
 ScVbaRange::~ScVbaRange()
 {
 }
 
+uno::Reference< vba::XCollection >& ScVbaRange::getBorders()
+{
+	if ( !m_Borders.is() )
+	{
+		uno::Reference< table::XCellRange > xRange( mxRanges->getByIndex(0), uno::UNO_QUERY_THROW );
+		m_Borders = lcl_setupBorders( this, mxContext, xRange );
+	}
+	return m_Borders;
+}
+
 uno::Reference< script::XTypeConverter >
 ScVbaRange::getTypeConverter() throw (uno::RuntimeException)
 {
-	static uno::Reference< script::XTypeConverter > xTypeConv( m_xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), m_xContext ), uno::UNO_QUERY_THROW );
+	static uno::Reference< script::XTypeConverter > xTypeConv( mxContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), mxContext ), uno::UNO_QUERY_THROW );
 	return xTypeConv;
 }
 
@@ -1125,7 +1165,7 @@ ScVbaRange::ClearContents( sal_Int32 nFl
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
 			if ( pRange )
 				pRange->ClearContents( nFlags );	
@@ -1171,7 +1211,7 @@ ScVbaRange::setFormulaValue( const uno::
 		aVisitor.visit( valueProcessor );
 		return;
 	}	
-	CellFormulaValueSetter formulaValueSetter( rFormula, getDocumentFromRange( mxRange ), eConv );
+	CellFormulaValueSetter formulaValueSetter( rFormula, getScDocument(), eConv );
 	setValue( rFormula, formulaValueSetter );
 }
 
@@ -1187,7 +1227,7 @@ ScVbaRange::getFormulaValue( ScAddress::
 		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
 		return xRange->getFormula();
 	}
-	CellFormulaValueGetter valueGetter( getDocumentFromRange( mxRange ), eConv );
+	CellFormulaValueGetter valueGetter( getScDocument(), eConv );
 	return getValue( valueGetter );
 		
 }
@@ -1281,7 +1321,7 @@ ScVbaRange::HasFormula() throw (uno::Run
 		uno::Any aResult = aNULL();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			// if the HasFormula for any area is different to another
 			// return null
 			if ( index > 1 )
@@ -1321,7 +1361,7 @@ ScVbaRange::fillSeries( sheet::FillDirec
 		uno::Reference< vba::XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
 		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			ScVbaRange* pThisRange = dynamic_cast< ScVbaRange* >( xRange.get() );
 			pThisRange->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
 				
@@ -1406,12 +1446,11 @@ ScVbaRange::Offset( const ::uno::Any &nR
 	if ( aCellRanges.Count() > 1 ) // Multi-Area
 	{
 		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
-		
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges ) );
+		return new ScVbaRange( getParent(), mxContext, xRanges );
 	}
 	// normal range
 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
-	return new ScVbaRange( m_xContext, xRange  );
+	return new ScVbaRange( getParent(), mxContext, xRange  );
 }
 
 uno::Reference< excel::XRange >
@@ -1432,7 +1471,7 @@ ScVbaRange::CurrentRegion() throw (uno::
 		helper.getSheetCellCursor();
 	xSheetCellCursor->collapseToCurrentRegion();
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
-	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
 }
 
 uno::Reference< excel::XRange >
@@ -1452,7 +1491,7 @@ ScVbaRange::CurrentArray() throw (uno::R
 		helper.getSheetCellCursor();
 	xSheetCellCursor->collapseToCurrentArray();
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
-	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+	return RangeHelper::createRangeFromRange( mxContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
 }
 
 uno::Any
@@ -1530,7 +1569,7 @@ ScVbaRange::Address(  const uno::Any& Ro
                 uno::Any aExternalCopy = External;
 		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			if ( index > 1 )
 			{
 				sAddress += rtl::OUString( ',' );
@@ -1603,7 +1642,7 @@ ScVbaRange::Font() throw (uno::RuntimeEx
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );	
-	return uno::Reference< excel::XFont >( new ScVbaFont( aPalette, xProps, getCurrentDataSet() ) );
+	return  new ScVbaFont( this, mxContext, aPalette, xProps, getCurrentDataSet() );
 }
                                                                                                                              
 uno::Reference< excel::XRange >
@@ -1626,7 +1665,8 @@ ScVbaRange::Cells( const uno::Any &nRowI
 	table::CellRangeAddress thisRangeAddress =  thisRange.getCellRangeAddressable()->getRangeAddress();
 	uno::Reference< table::XCellRange > xSheetRange = thisRange.getCellRangeFromSheet();
 	if( !bIsIndex && !bIsColumnIndex ) // .Cells
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange ) );
+		// #FIXE needs proper parent ( Worksheet )
+		return uno::Reference< excel::XRange >( new ScVbaRange( uno::Reference< vba::XHelperInterface >(), mxContext, mxRange ) );
 
 	sal_Int32 nIndex = --nRow;
 	if( bIsIndex && !bIsColumnIndex ) // .Cells(n)
@@ -1644,8 +1684,7 @@ ScVbaRange::Cells( const uno::Any &nRowI
 		--nColumn;
 	nRow = nRow + thisRangeAddress.StartRow;
 	nColumn =  nColumn + thisRangeAddress.StartColumn;	
-
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) ) );
+	return new ScVbaRange( getParent(), mxContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) );
 }
 
 void
@@ -1731,97 +1770,92 @@ ScVbaRange::Activate() throw (uno::Runti
 uno::Reference< excel::XRange >
 ScVbaRange::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	// #TODO code within the test below "if ( m_Areas.... " can be removed
-	// Test is performed only because m_xRange is NOT set to be
-	// the first range in m_Areas ( to force failure while
-	// the implementations for each method are being updated )
-	if ( m_Areas->getCount() > 1 )
-	{
-		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
-		return xRange->Rows( aIndex );
-	}
-	
+	SCROW nStartRow = 0;
+	SCROW nEndRow = 0;
+
 	sal_Int32 nValue;
 	rtl::OUString sAddress;
-	if( aIndex.hasValue() )
+
+	if ( aIndex.hasValue() )
 	{
-		uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxRange, uno::UNO_QUERY );
-		table::CellRangeAddress aAddress = xAddressable->getRangeAddress();
+		ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+		ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+
+		ScRange aRange = *aCellRanges.First();
 		if( aIndex >>= nValue )
 		{
-			aAddress.StartRow = --nValue;
-			aAddress.EndRow = nValue;
+			aRange.aStart.SetRow( aRange.aStart.Row() + --nValue );
+			aRange.aEnd.SetRow( aRange.aStart.Row() );
 		}
-	
+		
 		else if ( aIndex >>= sAddress ) 
 		{
-				ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
-			ScRange aRange;
-			aRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
-			aAddress.StartRow = aRange.aStart.Row();
-			aAddress.EndRow = aRange.aEnd.Row();
+			ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
+			ScRange tmpRange;
+			tmpRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartRow = tmpRange.aStart.Row();
+			nEndRow = tmpRange.aEnd.Row();
+
+			aRange.aStart.SetRow( aRange.aStart.Row() + nStartRow );
+			aRange.aEnd.SetRow( aRange.aStart.Row() + ( nEndRow  - nStartRow ));
 		}
 		else
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
-
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange->getCellRangeByPosition(
-						aAddress.StartColumn, aAddress.StartRow,
-						aAddress.EndColumn, aAddress.EndRow ), true ) 	); 	
-	}
-	// Questionable return, I'm just copying the invalid Any::value path
-	// above. Would seem to me that this is an internal error and 
-	// warrants an exception thrown
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, true ) );
+		
+		if ( aRange.aStart.Row() < 0 || aRange.aEnd.Row() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+		// return a normal range ( even for multi-selection
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+		return new ScVbaRange( getParent(), mxContext, xRange  );
+	}
+	// Rows() - no params
+	return new ScVbaRange(  getParent(), mxContext, mxRange, true );
 }	
 
 uno::Reference< excel::XRange >
-ScVbaRange::Columns( const uno::Any& aIndex ) throw (uno::RuntimeException)
+ScVbaRange::Columns(const uno::Any& aIndex ) throw (uno::RuntimeException)
 {
-	// #TODO code within the test below "if ( m_Areas.... " can be removed
-	// Test is performed only because m_xRange is NOT set to be
-	// the first range in m_Areas ( to force failure while
-	// the implementations for each method are being updated )
-	if ( m_Areas->getCount() > 1 )
-	{
-		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
-		return xRange->Columns( aIndex );
-	}
+	SCCOL nStartCol = 0;
+	SCCOL nEndCol = 0;
+
+	sal_Int32 nValue;
+	rtl::OUString sAddress;
+
 	if ( aIndex.hasValue() )
 	{
-		uno::Reference< excel::XRange > xRange;
-		sal_Int32 nValue;
-		rtl::OUString sAddress;
-		RangeHelper thisRange( mxRange );
-		uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
-		uno::Reference< table::XCellRange > xRanges = thisRange.getCellRangeFromSheet();		
-		table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
-		uno::Reference< table::XCellRange > xReferrer = xRanges->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, MAXCOL, thisRangeAddress.EndRow );
-	
-		if ( aIndex >>= nValue )
-		{
-			--nValue;
-			// col value can expand outside this range
-			// rows however cannot
+		ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+		ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
 
-			thisRangeAddress.StartColumn = nValue;	
-			thisRangeAddress.EndColumn = nValue;	
+		ScRange aRange = *aCellRanges.First();
+		if( aIndex >>= nValue )
+		{
+			aRange.aStart.SetCol( aRange.aStart.Col() + --nValue );
+			aRange.aEnd.SetCol( aRange.aStart.Col() );
 		}
-		else if ( aIndex >>= sAddress )
+		
+		else if ( aIndex >>= sAddress ) 
 		{
 			ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
-			ScRange aRange;
-			aRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
-			thisRangeAddress.StartColumn = aRange.aStart.Col();
-			thisRangeAddress.EndColumn = aRange.aEnd.Col();
+			ScRange tmpRange;
+			tmpRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			nStartCol = tmpRange.aStart.Col();
+			nEndCol = tmpRange.aEnd.Col();
+
+			aRange.aStart.SetCol( aRange.aStart.Col() + nStartCol );
+			aRange.aEnd.SetCol( aRange.aStart.Col() + ( nEndCol  - nStartCol ));
 		}
 		else
 			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xReferrer->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, thisRangeAddress.EndColumn, thisRangeAddress.EndRow ), false, true ) );
+		
+		if ( aRange.aStart.Col() < 0 || aRange.aEnd.Col() < 0 )
+			throw uno::RuntimeException( rtl::OUString::createFromAscii("Internal failure, illegal param"), uno::Reference< uno::XInterface >() );
+		// return a normal range ( even for multi-selection
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), aRange ) );
+		return new ScVbaRange( getParent(), mxContext, xRange  );
 	}
-	// otherwise return this object ( e.g for columns property with no
-	// params
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, false, true ) );
-}
+	// Columns() - no params
+	return new ScVbaRange(  getParent(), mxContext, mxRange, true );
+}	
 
 void
 ScVbaRange::setMergeCells( sal_Bool bIsMerged ) throw (uno::RuntimeException)
@@ -1899,7 +1933,7 @@ ScVbaRange::setNumberFormat( const uno::
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setNumberFormat( aFormat );	
 		}
 		return;
@@ -1918,7 +1952,7 @@ ScVbaRange::getNumberFormat() throw (uno
 		uno::Any aResult = aNULL();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			// if the numberformat of one area is different to another
 			// return null
 			if ( index > 1 )
@@ -1954,11 +1988,11 @@ ScVbaRange::Resize( const uno::Any &RowS
 	xCursor->collapseToSize( nColumnSize, nRowSize );
 	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xCursor, ::uno::UNO_QUERY_THROW );
 	uno::Reference< table::XCellRange > xRange( xSheetRange->getSpreadsheet(), ::uno::UNO_QUERY_THROW );
-	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext,xRange->getCellRangeByPosition(
+	return new ScVbaRange( getParent(), mxContext,xRange->getCellRangeByPosition(
 										xCellRangeAddressable->getRangeAddress().StartColumn,
 										xCellRangeAddressable->getRangeAddress().StartRow,
 										xCellRangeAddressable->getRangeAddress().EndColumn,
-										xCellRangeAddressable->getRangeAddress().EndRow ) ) );
+										xCellRangeAddressable->getRangeAddress().EndRow ) );
 }
                                                                                                                              
 void
@@ -1970,7 +2004,7 @@ ScVbaRange::setWrapText( const uno::Any&
 		uno::Any aResult;
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setWrapText( aIsWrapped );	
 		}
 		return;
@@ -1989,8 +2023,8 @@ ScVbaRange::getWrapText() throw (uno::Ru
 		uno::Any aResult;
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
-			if ( index > 1 )
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
+				if ( index > 1 )
 				if ( aResult != xRange->getWrapText() )
 					return aNULL();
 			aResult = xRange->getWrapText(); 
@@ -2012,7 +2046,7 @@ ScVbaRange::getWrapText() throw (uno::Ru
 uno::Reference< excel::XInterior > ScVbaRange::Interior( ) throw (uno::RuntimeException)
 {
 	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
-        return uno::Reference<excel::XInterior> (new ScVbaInterior ( m_xContext, xProps, getDocumentFromRange( mxRange ) ));
+        return new ScVbaInterior ( this, mxContext, xProps, getScDocument() );
 }                                                                                                                             
 uno::Reference< excel::XRange >
 ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2 ) throw (uno::RuntimeException)
@@ -2051,7 +2085,7 @@ ScVbaRange::Range( const uno::Any &Cell1
 		Cell1 >>= sName;
 		RangeHelper referRange( xReferrer );		
 		table::CellRangeAddress referAddress = referRange.getCellRangeAddressable()->getRangeAddress();
-		return getRangeForName( m_xContext, sName, getDocShellFromRange( mxRange ), referAddress );
+		return getRangeForName( mxContext, sName, getScDocShell(), referAddress );
  
 	}
 	else
@@ -2105,11 +2139,11 @@ ScVbaRange::Range( const uno::Any &Cell1
 		{
 			ScRange aNew( (SCCOL)nStartX, (SCROW)nStartY, parentAddress.aStart.Tab(),
 						  (SCCOL)nEndX, (SCROW)nEndY, parentAddress.aEnd.Tab() );
-			xCellRange = new ScCellRangeObj( getDocShellFromRange( mxRange ), aNew );
+			xCellRange = new ScCellRangeObj( getScDocShell(), aNew );
 		}
 	}
 		
-	return uno::Reference< excel::XRange > ( new ScVbaRange( m_xContext, xCellRange )  );
+	return new ScVbaRange( getParent(), mxContext, xCellRange );
 
 }
 
@@ -2139,8 +2173,7 @@ getPasteFlags (sal_Int32 Paste)
 		nFlags = IDF_FORMULA;break;
         case excel::XlPasteType::xlPasteFormulasAndNumberFormats : 
         case excel::XlPasteType::xlPasteValues: 
-		// FOR_UPSTREAM_BUILD
-		//nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
+		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
 		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING ); break;
         case excel::XlPasteType::xlPasteValuesAndNumberFormats:
 		nFlags = IDF_VALUE | IDF_ATTRIB; break;
@@ -2226,10 +2259,10 @@ ScVbaRange::getEntireColumnOrRow( bool b
 	{
 		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
 		
-		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges, !bColumn, bColumn ) );
+		return new ScVbaRange( getParent(), mxContext, xRanges, !bColumn, bColumn );
 	}
 	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
-	return new ScVbaRange( m_xContext, xRange, !bColumn, bColumn  );
+	return new ScVbaRange( getParent(), mxContext, xRange, !bColumn, bColumn  );
 }
 
 uno::Reference< excel::XRange > SAL_CALL 
@@ -2247,7 +2280,8 @@ ScVbaRange::getEntireColumn() throw (uno
 uno::Reference< excel::XComment > SAL_CALL 
 ScVbaRange::AddComment( const uno::Any& Text ) throw (uno::RuntimeException)
 {
-	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
 	// if you don't pass a valid text or if there is already a comment
 	// associated with the range then return NULL
 	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength() 
@@ -2261,7 +2295,7 @@ ScVbaRange::getComment() throw (uno::Run
 {
 	// intentional behavior to return a null object if no
 	// comment defined
-	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( this, mxContext, mxRange ) );
 	if ( !xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
 		return NULL;
 	return xComment;
@@ -2287,7 +2321,7 @@ ScVbaRange::getHidden() throw (uno::Runt
 	// first area
 	if ( m_Areas->getCount() > 1 )
 	{
-		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)) ), uno::UNO_QUERY_THROW );
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)), uno::Any() ), uno::UNO_QUERY_THROW );
 		return xRange->getHidden();	
 	}
 	bool bIsVisible = false;
@@ -2312,7 +2346,7 @@ ScVbaRange::setHidden( const uno::Any& _
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->setHidden( _hidden );	
 		}
 		return;
@@ -2340,7 +2374,7 @@ ScVbaRange::Replace( const ::rtl::OUStri
 	{
 		for ( sal_Int32 index = 1; index <= m_Areas->getCount(); ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->Replace( What, Replacement,  LookAt, SearchOrder, MatchCase, MatchByte, SearchFormat, ReplaceFormat );
 		}
 		return sal_True; // seems to return true always ( or at least I haven't found the trick of 
@@ -2514,17 +2548,16 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	sal_Int16 nDataOption2 = excel::XlSortDataOption::xlSortNormal;;
 	sal_Int16 nDataOption3 = excel::XlSortDataOption::xlSortNormal;
 
-	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	ScDocument* pDoc = getScDocument();
 	if ( !pDoc )
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	RangeHelper thisRange( mxRange );
 	table::CellRangeAddress thisRangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
-	//SCTAB nTab = thisRangeAddress.Sheet;
+	SCTAB nTab = thisRangeAddress.Sheet;
 
 	ScSortParam aSortParam;
-	// FOR_UPSTREAM_BUILD
-	//pDoc->GetSortParam( aSortParam, nTab );
+	pDoc->GetSortParam( aSortParam, nTab );
 
 	if ( DataOption1.hasValue() )
 		DataOption1 >>= nDataOption1;
@@ -2578,16 +2611,13 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	if ( nOrientation == excel::XlSortOrientation::xlSortRows )
 		bIsSortColumns = sal_True;
 
-	// FOR_UPSTREAM_BUILD
-	//sal_Int16 nHeader = aSortParam.nCompatHeader;
-	sal_Int16 nHeader = 0;
+	sal_Int16 nHeader = aSortParam.nCompatHeader;
 	sal_Bool bContainsHeader = sal_False;
 
 	if ( Header.hasValue() )
 	{
 		nHeader = ::comphelper::getINT16( Header );
-		// FOR_UPSTREAM_BUILD
-		//aSortParam.nCompatHeader = nHeader;
+		aSortParam.nCompatHeader = nHeader;
 	}			
 
 	if ( nHeader == excel::XlYesNoGuess::xlGuess )
@@ -2599,8 +2629,7 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 		else
 			nHeader =  excel::XlYesNoGuess::xlNo; 
 		// save set param as default
-		// FOR_UPSTREAM_BUILD
-		//aSortParam.nCompatHeader = nHeader;
+		aSortParam.nCompatHeader = nHeader;
 	}
 
 	if ( nHeader == excel::XlYesNoGuess::xlYes )
@@ -2689,8 +2718,7 @@ ScVbaRange::Sort( const uno::Any& Key1, 
 	nIndex = 	findSortPropertyIndex( sortDescriptor, CONTS_HEADER );
 	sortDescriptor[ nIndex ].Value <<= bContainsHeader;
 
-	// FOR_UPSTREAM_BUILD
-	//pDoc->SetSortParam( aSortParam, nTab );
+	pDoc->SetSortParam( aSortParam, nTab );
 	xSort->sort( sortDescriptor );
 
 	// #FIXME #TODO
@@ -2719,7 +2747,7 @@ ScVbaRange::End( ::sal_Int32 Direction )
 	// Save ActiveCell pos ( to restore later )
 	uno::Any aDft;
 	rtl::OUString sActiveCell =	ScVbaGlobals::getGlobalsImpl(
-                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// position current cell upper left of this range
 	Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
@@ -2761,17 +2789,17 @@ ScVbaRange::End( ::sal_Int32 Direction )
 
 	// result is the ActiveCell		
 	rtl::OUString sMoved =	ScVbaGlobals::getGlobalsImpl(
-                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+                       mxContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
 
 	// restore old ActiveCell		
 	uno::Any aVoid;
 	uno::Reference< excel::XRange > xOldActiveCell( ScVbaGlobals::getGlobalsImpl(
-		m_xContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
+		mxContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
 	xOldActiveCell->Select();
 
 	uno::Reference< excel::XRange > resultCell;
 	resultCell.set( ScVbaGlobals::getGlobalsImpl(
-		m_xContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
+		mxContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
 
 	// return result
 	
@@ -2798,7 +2826,7 @@ ScVbaRange::characters( const uno::Any& 
 		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
 
 	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
-	return uno::Reference< excel::XCharacters >( new ScVbaCharacters( m_xContext, aPalette, xSimple, Start, Length ) );
+	return  new ScVbaCharacters( this, mxContext, aPalette, xSimple, Start, Length );
 }
 
  void SAL_CALL 
@@ -2810,7 +2838,7 @@ ScVbaRange::Delete( const uno::Any& Shif
 		sal_Int32 nItems = m_Areas->getCount();
 		for ( sal_Int32 index=1; index <= nItems; ++index )
 		{
-			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 			xRange->Delete( Shift );	
 		}
 		return;
@@ -2859,7 +2887,7 @@ ScVbaRange::hasElements() throw (uno::Ru
 uno::Reference< container::XEnumeration > SAL_CALL 
 ScVbaRange::createEnumeration() throw (uno::RuntimeException)
 {
-	return new CellsEnumeration( m_xContext, mxRange );
+	return new CellsEnumeration( mxContext, mxRange );
 }
 
 ::rtl::OUString SAL_CALL 
@@ -2883,7 +2911,7 @@ getDeviceFromDoc( const uno::Reference< 
 double 
 ScVbaRange::getCalcColWidth( const table::CellRangeAddress& rAddress) throw (uno::RuntimeException)
 {
-	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	ScDocument* pDoc = getScDocument();
 	USHORT nWidth = pDoc->GetOriginalWidth( static_cast< SCCOL >( rAddress.StartColumn ), static_cast< SCTAB >( rAddress.Sheet ) );
 	double nPoints = lcl_TwipsToPoints( nWidth );
 	nPoints = lcl_Round2DecPlaces( nPoints );
@@ -2930,7 +2958,7 @@ uno::Any SAL_CALL 
 ScVbaRange::getColumnWidth() throw (uno::RuntimeException)
 {
 	double nColWidth = 	0;
-	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	ScDocShell* pShell = getScDocShell();
 	if ( pShell )
 	{
 		RangeHelper thisRange( mxRange );
@@ -2951,7 +2979,7 @@ ScVbaRange::setColumnWidth( const uno::A
 	double nColWidth = 0;
 	_columnwidth >>= nColWidth;
 	nColWidth = lcl_Round2DecPlaces( nColWidth );
-        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        ScDocShell* pDocShell = getScDocShell();
         if ( pDocShell )
         {
                 uno::Reference< frame::XModel > xModel = pDocShell->GetModel();
@@ -2995,7 +3023,7 @@ ScVbaRange::Areas( const uno::Any& item)
 {
 	if ( !item.hasValue() )
 		return uno::makeAny( m_Areas );
-	return m_Areas->Item( item );	
+	return m_Areas->Item( item, uno::Any() );	
 }
 
 uno::Reference< excel::XRange >
@@ -3003,7 +3031,7 @@ ScVbaRange::getArea( sal_Int32 nIndex ) 
 {
 	if ( !m_Areas.is() )
 		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("No areas available")), uno::Reference< uno::XInterface >() );
-	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ) ), uno::UNO_QUERY_THROW );
+	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ), uno::Any() ), uno::UNO_QUERY_THROW );
 	return xRange;
 }
 
@@ -3011,16 +3039,16 @@ uno::Any
 ScVbaRange::Borders( const uno::Any& item ) throw( css::uno::RuntimeException )
 {
 	if ( !item.hasValue() )
-		return uno::makeAny( m_Borders );
-	return m_Borders->Item( item );
+		return uno::makeAny( getBorders() );
+	return getBorders()->Item( item, uno::Any() );
 }
 
 uno::Any SAL_CALL
 ScVbaRange::BorderAround( const css::uno::Any& LineStyle, const css::uno::Any& Weight,
                 const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException)
 {
-    sal_Int32 nCount = m_Borders->getCount();
-    uno::Reference< excel::XBorders > xBorders( m_Borders, uno::UNO_QUERY_THROW);
+    sal_Int32 nCount = getBorders()->getCount();
+
     for( sal_Int32 i = 0; i < nCount; i++ )
     {
         const sal_Int32 nLineType = supportedIndexTable[i];
@@ -3031,7 +3059,7 @@ ScVbaRange::BorderAround( const css::uno
             case excel::XlBordersIndex::xlEdgeBottom:
             case excel::XlBordersIndex::xlEdgeRight:
             {
-                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ) ), uno::UNO_QUERY_THROW );
+                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ), uno::Any() ), uno::UNO_QUERY_THROW );
                 if( LineStyle.hasValue() )
                 {
                     xBorder->setLineStyle( LineStyle );
@@ -3177,7 +3205,8 @@ ScVbaRange::getWorksheet() throw (uno::R
 {
 	ScDocShell* pDocShell =  getDocShellFromRange(mxRange);
 	RangeHelper* rHelper = new RangeHelper(mxRange);
-        return new ScVbaWorksheet(m_xContext,rHelper->getSpreadSheet(),pDocShell->GetModel());
+	// parent should be Thisworkbook
+        return new ScVbaWorksheet( uno::Reference< vba::XHelperInterface >(), mxContext,rHelper->getSpreadSheet(),pDocShell->GetModel());
 }
 
 ScCellRangesBase*
@@ -3241,14 +3270,15 @@ ScVbaRange::ApplicationRange( const uno:
 			uno::Reference< table::XCellRange > xRange = xReferrer->getReferredCells();
 			if ( xRange.is() )
 			{
-				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( xContext, xRange );
+				// #FIXME need proper (WorkSheet) parent
+				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xRange );
 				return xVbRange;
 			}
 		}
 	}
 	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY );
 	uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
-	ScVbaRange* pRange = new ScVbaRange( xContext, xSheetRange );
+	ScVbaRange* pRange = new ScVbaRange( uno::Reference< vba::XHelperInterface >(), xContext, xSheetRange );
 	uno::Reference< excel::XRange > xVbSheetRange( pRange );
 	return pRange->Range( Cell1, Cell2, true ); 
 }
@@ -3603,7 +3633,7 @@ css::uno::Reference< excel::XValidation 
 ScVbaRange::getValidation() throw (css::uno::RuntimeException)
 {
 	if ( !m_xValidation.is() )	
-		m_xValidation = new ScVbaValidation( m_xContext, mxRange );
+		m_xValidation = new ScVbaValidation( this, mxContext, mxRange );
 	return m_xValidation;
 }
 
@@ -3617,7 +3647,7 @@ ScVbaRange::PrintOut( const uno::Any& Fr
 	uno::Reference< sheet::XPrintAreas > xPrintAreas;
 	for ( sal_Int32 index=1; index <= nItems; ++index )
 	{
-		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index), uno::Any() ), uno::UNO_QUERY_THROW );
 
 		RangeHelper thisRange( xRange->getCellRange() );
 		table::CellRangeAddress rangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
@@ -3716,7 +3746,7 @@ ScVbaRange::AutoFill(  const uno::Refere
 	FillCmd eCmd = FILL_AUTO;
 	FillDateCmd eDateCmd = FILL_DAY;	
 
-	//double fEndValue =  MAXDOUBLE;
+	double fEndValue =  MAXDOUBLE;
 
 	if ( Type.hasValue() )
 	{
@@ -3761,8 +3791,65 @@ ScVbaRange::AutoFill(  const uno::Refere
 		}	
 	}
 	ScDocFunc aFunc(*pDocSh);
-	// FOR_UPSTREAM_BUILD
-	/*aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd,
-								nCount, fStep, fEndValue, TRUE, TRUE );
-	*/
+		aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd,
+									nCount, fStep, fEndValue, TRUE, TRUE );
+}
+#include <comphelper/anytostring.hxx>
+sal_Bool SAL_CALL
+ScVbaRange::GoalSeek( const uno::Any& Goal, const uno::Reference< excel::XRange >& ChangingCell ) throw (uno::RuntimeException)
+{
+	ScDocShell* pDocShell = getScDocShell();
+	sal_Bool bRes = sal_True;
+	ScVbaRange* pRange = static_cast< ScVbaRange* >( ChangingCell.get() );
+	if ( pDocShell && pRange )
+	{
+		uno::Reference< sheet::XGoalSeek > xGoalSeek(  pDocShell->GetModel(), uno::UNO_QUERY_THROW );
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		RangeHelper changingCellRange( pRange->mxRange );
+		table::CellRangeAddress changingCellAddr = changingCellRange.getCellRangeAddressable()->getRangeAddress();
+		rtl::OUString sGoal = getAnyAsString( Goal );
+		table::CellAddress thisCell( thisAddress.Sheet, thisAddress.StartColumn, thisAddress.StartRow );
+		table::CellAddress changingCell( changingCellAddr.Sheet, changingCellAddr.StartColumn, changingCellAddr.StartRow );
+		sheet::GoalResult res = xGoalSeek->seekGoal( thisCell, changingCell, sGoal );
+		ChangingCell->setValue( uno::makeAny( res.Result ) );
+		
+		// openoffice behaves differently, result is 0 if the divergence is too great
+                // but... if it detects 0 is the value it requires then it will use that
+		// e.g. divergence & result both = 0.0 does NOT mean there is an error
+		if ( ( res.Divergence != 0.0 ) && ( res.Result == 0.0 ) )
+			bRes = sal_False;
+	}
+	else
+		bRes = sal_False;
+	return bRes;
+}
+
+rtl::OUString& 
+ScVbaRange::getServiceImplName()
+{
+	static rtl::OUString sImplName( RTL_CONSTASCII_USTRINGPARAM("ScVbaRange") );
+	return sImplName;
+}
+
+uno::Sequence< rtl::OUString > 
+ScVbaRange::getServiceNames()
+{
+	static uno::Sequence< rtl::OUString > aServiceNames;
+	if ( aServiceNames.getLength() == 0 )
+	{
+		aServiceNames.realloc( 1 );
+		aServiceNames[ 0 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Range" ) );
+	}
+	return aServiceNames;
+}
+
+namespace range
+{
+namespace sdecl = comphelper::service_decl;
+sdecl::vba_service_class_<ScVbaRange, sdecl::with_args<true> > serviceImpl;
+extern sdecl::ServiceDecl const serviceDecl(
+    serviceImpl,
+    "SvVbaRange",
+    "org.openoffice.excel.Range" );
 }
