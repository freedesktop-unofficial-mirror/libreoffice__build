Patch from: Dirk Mueller <mueller@kde.org> with kind thanks.

diff -dub binutils-2.14/bfd/elf-strtab.c binutils-2.14.new/bfd/elf-strtab.c
--- binutils-2.14/bfd/elf-strtab.c	2002-11-30 09:39:37.000000000 +0100
+++ binutils-2.14.new/bfd/elf-strtab.c	2003-08-28 02:42:20.000000000 +0200
@@ -59,8 +59,9 @@
 
 static struct bfd_hash_entry *elf_strtab_hash_newfunc
   PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
-static int cmplengthentry PARAMS ((const PTR, const PTR));
-static int last4_eq PARAMS ((const PTR, const PTR));
+static int strrevcmp PARAMS ((const PTR, const PTR));
+static int is_suffix PARAMS ((const struct elf_strtab_hash_entry *,
+			      const struct elf_strtab_hash_entry *));
 
 /* Routine to create an entry in a section merge hashtab.  */
 
@@ -274,44 +275,39 @@
   return TRUE;
 }
 
-/* Compare two elf_strtab_hash_entry structures.  This is called via qsort.  */
 
-static int
-cmplengthentry (a, b)
+static int strrevcmp(a, b)
      const PTR a;
      const PTR b;
 {
   struct elf_strtab_hash_entry * A = *(struct elf_strtab_hash_entry **) a;
   struct elf_strtab_hash_entry * B = *(struct elf_strtab_hash_entry **) b;
 
-  if (A->len < B->len)
-    return 1;
-  else if (A->len > B->len)
-    return -1;
+  const unsigned char *s = A->root.string + A->len - 1;
+  const unsigned char *t = B->root.string + B->len - 1;
 
-  return memcmp (A->root.string, B->root.string, A->len);
+  int l = A->len < B->len ? A->len : B->len;
+  while (l) {
+      if (*s != *t)
+	  return (int)*s - (int)*t;
+      s--;
+      t--;
+      l--;
+  }
+      return A->len - B->len;
 }
 
-static int
-last4_eq (a, b)
-     const PTR a;
-     const PTR b;
+static int is_suffix(A, B)
+    const struct elf_strtab_hash_entry *A;
+    const struct elf_strtab_hash_entry *B;
 {
-  struct elf_strtab_hash_entry * A = (struct elf_strtab_hash_entry *) a;
-  struct elf_strtab_hash_entry * B = (struct elf_strtab_hash_entry *) b;
-
-  if (memcmp (A->root.string + A->len - 5, B->root.string + B->len - 5, 4)
-      != 0)
-    /* This was a hashtable collision.  */
-    return 0;
-
   if (A->len <= B->len)
     /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
        not to be equal by the hash table.  */
     return 0;
 
   return memcmp (A->root.string + (A->len - B->len),
-		 B->root.string, B->len - 5) == 0;
+		 B->root.string, B->len - 1) == 0;
 }
 
 /* This function assigns final string table offsets for used strings,
@@ -322,9 +318,7 @@
      struct elf_strtab_hash *tab;
 {
   struct elf_strtab_hash_entry **array, **a, **end, *e;
-  htab_t last4tab = NULL;
   bfd_size_type size, amt;
-  struct elf_strtab_hash_entry *last[256], **last_ptr[256];
 
   /* GCC 2.91.66 (egcs-1.1.2) on i386 miscompiles this function when i is
      a 64-bit bfd_size_type: a 64-bit target or --enable-64-bit-bfd.
@@ -332,16 +326,13 @@
      cycles.  */
   size_t i;
 
-  /* Now sort the strings by length, longest first.  */
+  /* Now sort the strings */
   array = NULL;
   amt = tab->size * sizeof (struct elf_strtab_hash_entry *);
   array = (struct elf_strtab_hash_entry **) bfd_malloc (amt);
   if (array == NULL)
     goto alloc_failure;
 
-  memset (last, 0, sizeof (last));
-  for (i = 0; i < 256; ++i)
-    last_ptr[i] = &last[i];
   for (i = 1, a = array; i < tab->size; ++i)
     if (tab->array[i]->refcount)
       *a++ = tab->array[i];
@@ -350,80 +341,33 @@
 
   size = a - array;
 
-  qsort (array, size, sizeof (struct elf_strtab_hash_entry *), cmplengthentry);
-
-  last4tab = htab_create_alloc (size * 4, NULL, last4_eq, NULL, calloc, free);
-  if (last4tab == NULL)
-    goto alloc_failure;
+  qsort (array, size, sizeof (struct elf_strtab_hash_entry *), strrevcmp);
 
-  /* Now insert the strings into hash tables (strings with last 4 characters
-     and strings with last character equal), look for longer strings which
-     we're suffix of.  */
+  /* now loop over the sorted array and merge suffixes */
   for (a = array, end = array + size; a < end; a++)
     {
-      register hashval_t hash;
-      unsigned int c;
-      unsigned int j;
-      const unsigned char *s;
-      PTR *p;
-
       e = *a;
-      if (e->len > 4)
-	{
-	  s = e->root.string + e->len - 1;
-	  hash = 0;
-	  for (j = 0; j < 4; j++)
-	    {
-	      c = *--s;
-	      hash += c + (c << 17);
-	      hash ^= hash >> 2;
-	    }
-	  p = htab_find_slot_with_hash (last4tab, e, hash, INSERT);
-	  if (p == NULL)
-	    goto alloc_failure;
-	  if (*p)
-	    {
-	      struct elf_strtab_hash_entry *ent;
-
-	      ent = (struct elf_strtab_hash_entry *) *p;
-	      e->u.suffix = ent;
-	      e->len = 0;
+      if (e->len <= 1)
 	      continue;
-	    }
-	  else
-	    *p = (PTR) e;
-	}
-      else
 	{
-	  struct elf_strtab_hash_entry *tem;
-
-	  c = e->root.string[e->len - 2] & 0xff;
-
-	  for (tem = last[c]; tem; tem = tem->u.next)
-	    if (tem->len > e->len
-		&& memcmp (tem->root.string + (tem->len - e->len),
-			   e->root.string, e->len - 1) == 0)
+	  struct elf_strtab_hash_entry **b = a+1;
+	  int found = 0;
+	  while (b < end) {
+	      struct elf_strtab_hash_entry *cmp = *b;
+	      if (!is_suffix(cmp, e))
 	      break;
-	  if (tem)
-	    {
-	      e->u.suffix = tem;
+	      e->u.suffix = cmp;
+	      found = 1;
+	      ++b;
+	  }
+	  if (found)
 	      e->len = 0;
-	      continue;
 	    }
 	}
 
-      c = e->root.string[e->len - 2] & 0xff;
-      /* Put longest strings first.  */
-      *last_ptr[c] = e;
-      last_ptr[c] = &e->u.next;
-      e->u.next = NULL;
-    }
-
 alloc_failure:
   if (array)
     free (array);
-  if (last4tab)
-    htab_delete (last4tab);
 
   /* Now assign positions to the strings we want to keep.  */
   size = 1;
diff -dub binutils-2.14/bfd/elflink.h binutils-2.14.new/bfd/elflink.h
--- binutils-2.14/bfd/elflink.h	2003-06-02 22:35:21.000000000 +0200
+++ binutils-2.14.new/bfd/elflink.h	2003-08-28 01:58:41.000000000 +0200
@@ -2380,13 +2380,51 @@
      assembler code, handling it correctly would be very time
      consuming, and other ELF linkers don't handle general aliasing
      either.  */
+  {
+#define HASH(h) (((h->root.u.def.value >> 3) ^ \
+    (h->root.u.def.section->target_index<<10))%(4*extsymcount))
+     struct hashentry {
+	  struct elf_link_hash_entry *h;
+	  struct hashentry *next;
+      };
+      struct hashentry *array;
+      struct elf_link_hash_entry **hpp;
+      struct elf_link_hash_entry **hppend;
+
+      array = (struct hashentry *) malloc(extsymcount*4*sizeof(struct hashentry));
+      memset(array, 0, extsymcount*4*sizeof(struct hashentry));
+
+      hpp = elf_sym_hashes (abfd);
+      hppend = hpp + extsymcount;
+      for (; hpp < hppend; hpp++)
+	{
+	    unsigned int hash;
+	  struct elf_link_hash_entry *h = *hpp;
+
+	  if (!h || h->root.type != bfd_link_hash_defined)
+	      continue;
+
+	  hash = HASH(h);
+
+	  if (!array[hash].h) {
+	      array[hash].h = h;
+	  } else {
+	      struct hashentry *p = array + hash;
+	      while (p->next)
+		  p = p->next;
+	      p->next = (struct hashentry *) malloc(sizeof(struct hashentry));
+	      p->next->h = h;
+	      p->next->next = 0;
+	  }
+	}
+
   while (weaks != NULL)
     {
       struct elf_link_hash_entry *hlook;
       asection *slook;
       bfd_vma vlook;
-      struct elf_link_hash_entry **hpp;
-      struct elf_link_hash_entry **hppend;
+	  unsigned int hash;
+	  struct hashentry *entry;
 
       hlook = weaks;
       weaks = hlook->weakdef;
@@ -2396,18 +2434,15 @@
 		  || hlook->root.type == bfd_link_hash_defweak
 		  || hlook->root.type == bfd_link_hash_common
 		  || hlook->root.type == bfd_link_hash_indirect);
+
+	  hash = HASH(hlook);
       slook = hlook->root.u.def.section;
       vlook = hlook->root.u.def.value;
 
-      hpp = elf_sym_hashes (abfd);
-      hppend = hpp + extsymcount;
-      for (; hpp < hppend; hpp++)
-	{
-	  struct elf_link_hash_entry *h;
-
-	  h = *hpp;
-	  if (h != NULL && h != hlook
-	      && h->root.type == bfd_link_hash_defined
+	  entry = array + hash;
+	  while (entry && entry->h) {
+	      struct elf_link_hash_entry *h = entry->h;
+	      if (h != hlook
 	      && h->root.u.def.section == slook
 	      && h->root.u.def.value == vlook)
 	    {
@@ -2434,11 +2469,27 @@
 		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
 		    goto error_return;
 		}
+
 	      break;
 	    }
+	      entry = entry->next;
+	  }
+      }
+      {
+	  unsigned int i;
+	  for (i = 0; i < 4*extsymcount; ++i) {
+	      struct hashentry *h = array[i].next;
+	      while (h) {
+		  struct hashentry *n = h->next;
+		  free(h);
+		  h = n;
+	      }
+	  }
+	  free(array);
 	}
     }
 
+
   /* If this object is the same format as the output object, and it is
      not a shared library, then let the backend look through the
      relocs.
diff -dub binutils-2.14/bfd/merge.c binutils-2.14.new/bfd/merge.c
--- binutils-2.14/bfd/merge.c	2002-11-30 09:39:40.000000000 +0100
+++ binutils-2.14.new/bfd/merge.c	2003-08-28 02:42:32.000000000 +0200
@@ -108,12 +108,9 @@
 	   struct sec_merge_sec_info *));
 static bfd_boolean sec_merge_emit
   PARAMS ((bfd *, struct sec_merge_hash_entry *));
-static int cmplengthentry
-  PARAMS ((const PTR, const PTR));
-static int last4_eq
-  PARAMS ((const PTR, const PTR));
-static int last_eq
-  PARAMS ((const PTR, const PTR));
+static int strrevcmp PARAMS ((const PTR, const PTR));
+static int is_suffix PARAMS ((const struct sec_merge_hash_entry *,
+			      const struct sec_merge_hash_entry *));
 static bfd_boolean record_section
   PARAMS ((struct sec_merge_info *, struct sec_merge_sec_info *));
 static void merge_strings
@@ -457,84 +454,28 @@
   return FALSE;
 }
 
-/* Compare two sec_merge_hash_entry structures.  This is called via qsort.  */
-
-static int
-cmplengthentry (a, b)
+static int strrevcmp(a, b)
      const PTR a;
      const PTR b;
 {
   struct sec_merge_hash_entry * A = *(struct sec_merge_hash_entry **) a;
   struct sec_merge_hash_entry * B = *(struct sec_merge_hash_entry **) b;
 
-  if (A->len < B->len)
-    return 1;
-  else if (A->len > B->len)
-    return -1;
-
-  return memcmp (A->root.string, B->root.string, A->len);
-}
-
-static int
-last4_eq (a, b)
-     const PTR a;
-     const PTR b;
-{
-  struct sec_merge_hash_entry * A = (struct sec_merge_hash_entry *) a;
-  struct sec_merge_hash_entry * B = (struct sec_merge_hash_entry *) b;
-
-  if (memcmp (A->root.string + A->len - 5 * A->u.entsize,
-	      B->root.string + B->len - 5 * A->u.entsize,
-	      4 * A->u.entsize) != 0)
-    /* This was a hashtable collision.  */
-    return 0;
-
-  if (A->len <= B->len)
-    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
-       not to be equal by the hash table.  */
-    return 0;
-
-  if (A->alignment < B->alignment
-      || ((A->len - B->len) & (B->alignment - 1)))
-    /* The suffix is not sufficiently aligned.  */
-    return 0;
+  const unsigned char *s = A->root.string + A->len - A->u.entsize;
+  const unsigned char *t = B->root.string + B->len - B->u.entsize;
 
-  return memcmp (A->root.string + (A->len - B->len),
-		 B->root.string, B->len - 5 * A->u.entsize) == 0;
+  int l = A->len < B->len ? A->len : B->len;
+  l -= (A->u.entsize - 1);
+  while (l) {
+      if (*s != *t)
+	  return (int)*s - (int)*t;
+      s--;
+      t--;
+      l--;
+  }
+      return A->len - B->len;
 }
 
-static int
-last_eq (a, b)
-     const PTR a;
-     const PTR b;
-{
-  struct sec_merge_hash_entry * A = (struct sec_merge_hash_entry *) a;
-  struct sec_merge_hash_entry * B = (struct sec_merge_hash_entry *) b;
-
-  if (B->len >= 5 * A->u.entsize)
-    /* Longer strings are just pushed into the hash table,
-       they'll be used when looking up for very short strings.  */
-    return 0;
-
-  if (memcmp (A->root.string + A->len - 2 * A->u.entsize,
-	      B->root.string + B->len - 2 * A->u.entsize,
-	      A->u.entsize) != 0)
-    /* This was a hashtable collision.  */
-    return 0;
-
-  if (A->len <= B->len)
-    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
-       not to be equal by the hash table.  */
-    return 0;
-
-  if (A->alignment < B->alignment
-      || ((A->len - B->len) & (B->alignment - 1)))
-    /* The suffix is not sufficiently aligned.  */
-    return 0;
-
-  return memcmp (A->root.string + (A->len - B->len),
-		 B->root.string, B->len - 2 * A->u.entsize) == 0;
-}
 
 /* Record one section into the hash table.  */
 static bfd_boolean
@@ -620,6 +561,19 @@
   return FALSE;
 }
 
+static int is_suffix(A, B)
+    const struct sec_merge_hash_entry *A;
+    const struct sec_merge_hash_entry *B;
+{
+    if (A->len <= B->len)
+	/* B cannot be a suffix of A unless A is equal to B, which is guaranteed
+	   not to be equal by the hash table.  */
+	return 0;
+
+  return memcmp (A->root.string + (A->len - B->len),
+		 B->root.string, B->len - 1 * A->u.entsize) == 0;
+}
+
 /* This is a helper function for _bfd_merge_sections.  It attempts to
    merge strings matching suffixes of longer strings.  */
 static void
@@ -628,10 +582,9 @@
 {
   struct sec_merge_hash_entry **array, **a, **end, *e;
   struct sec_merge_sec_info *secinfo;
-  htab_t lasttab = NULL, last4tab = NULL;
   bfd_size_type size, amt;
 
-  /* Now sort the strings by length, longest first.  */
+  /* Now sort the strings */
   array = NULL;
   amt = sinfo->htab->size * sizeof (struct sec_merge_hash_entry *);
   array = (struct sec_merge_hash_entry **) bfd_malloc (amt);
@@ -644,86 +597,45 @@
 
   sinfo->htab->size = a - array;
 
-  qsort (array, (size_t) sinfo->htab->size,
-	 sizeof (struct sec_merge_hash_entry *), cmplengthentry);
+  for (a = array, end = array + sinfo->htab->size; a < end; a++)
+    {
+      e = *a;
+      e->u.entsize = sinfo->htab->entsize;
+    }
 
-  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
-				NULL, last4_eq, NULL, calloc, free);
-  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
-			       NULL, last_eq, NULL, calloc, free);
-  if (lasttab == NULL || last4tab == NULL)
-    goto alloc_failure;
+  qsort (array, (size_t) sinfo->htab->size,
+	 sizeof (struct sec_merge_hash_entry *), strrevcmp);
 
-  /* Now insert the strings into hash tables (strings with last 4 characters
-     and strings with last character equal), look for longer strings which
-     we're suffix of.  */
+  /* now loop over the sorted array and merge suffixes */
   for (a = array, end = array + sinfo->htab->size; a < end; a++)
     {
-      register hashval_t hash;
-      unsigned int c;
-      unsigned int i;
-      const unsigned char *s;
-      PTR *p;
-
       e = *a;
-      e->u.entsize = sinfo->htab->entsize;
       if (e->len <= e->u.entsize)
-	break;
-      if (e->len > 4 * e->u.entsize)
-	{
-	  s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
-	  hash = 0;
-	  for (i = 0; i < 4 * e->u.entsize; i++)
+	  continue;
 	    {
-	      c = *--s;
-	      hash += c + (c << 17);
-	      hash ^= hash >> 2;
-	    }
-	  p = htab_find_slot_with_hash (last4tab, e, hash, INSERT);
-	  if (p == NULL)
-	    goto alloc_failure;
-	  if (*p)
+	  bfd_boolean found = FALSE;
+	  struct sec_merge_hash_entry **b = a+1;
+	  while (b < end) {
+	      struct sec_merge_hash_entry *cmp = *b;
+	      if (!is_suffix(cmp, e))
+		  break;
+	      if (e->alignment >= cmp->alignment
+		  && !((e->len - cmp->len) & (cmp->alignment - 1)))
+		  /* The suffix is sufficiently aligned.  */
 	    {
-	      struct sec_merge_hash_entry *ent;
-
-	      ent = (struct sec_merge_hash_entry *) *p;
-	      e->u.suffix = ent;
-	      e->alignment = 0;
-	      continue;
-	    }
-	  else
-	    *p = (PTR) e;
+		  e->u.suffix = cmp;
+		  found = TRUE;
 	}
-      s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
-      hash = 0;
-      for (i = 0; i < e->u.entsize; i++)
-	{
-	  c = *--s;
-	  hash += c + (c << 17);
-	  hash ^= hash >> 2;
+	      ++b;
 	}
-      p = htab_find_slot_with_hash (lasttab, e, hash, INSERT);
-      if (p == NULL)
-	goto alloc_failure;
-      if (*p)
-	{
-	  struct sec_merge_hash_entry *ent;
-
-	  ent = (struct sec_merge_hash_entry *) *p;
-	  e->u.suffix = ent;
+	  if (found)
 	  e->alignment = 0;
 	}
-      else
-	*p = (PTR) e;
     }
 
 alloc_failure:
   if (array)
     free (array);
-  if (lasttab)
-    htab_delete (lasttab);
-  if (last4tab)
-    htab_delete (last4tab);
 
   /* Now assign positions to the strings we want to keep.  */
   size = 0;
diff -dub binutils-2.14/ld/ld.h binutils-2.14.new/ld/ld.h
--- binutils-2.14/ld/ld.h	2002-12-23 11:44:59.000000000 +0100
+++ binutils-2.14.new/ld/ld.h	2003-08-28 12:02:15.000000000 +0200
@@ -71,6 +71,7 @@
   const char *name;
   struct name_list *exclude_name_list;
   bfd_boolean sorted;
+  bfd_boolean wildcard_p;
 };
 
 struct wildcard_list {
diff -dub binutils-2.14/ld/ldgram.y binutils-2.14.new/ld/ldgram.y
--- binutils-2.14/ld/ldgram.y	2003-04-24 19:15:25.000000000 +0200
+++ binutils-2.14.new/ld/ldgram.y	2003-08-28 12:27:26.000000000 +0200
@@ -411,24 +411,28 @@
 			  $$.name = $1;
 			  $$.sorted = FALSE;
 			  $$.exclude_name_list = NULL;
+			  $$.wildcard_p = wildcardp($1);
 			}
 	| 	EXCLUDE_FILE '(' exclude_name_list ')' wildcard_name
 			{
 			  $$.name = $5;
 			  $$.sorted = FALSE;
 			  $$.exclude_name_list = $3;
+			  $$.wildcard_p = wildcardp($5);
 			}
 	|	SORT '(' wildcard_name ')'
 			{
 			  $$.name = $3;
 			  $$.sorted = TRUE;
 			  $$.exclude_name_list = NULL;
+			  $$.wildcard_p = wildcardp($3);
 			}
 	|	SORT '(' EXCLUDE_FILE '(' exclude_name_list ')' wildcard_name ')'
 			{
 			  $$.name = $7;
 			  $$.sorted = TRUE;
 			  $$.exclude_name_list = $5;
+			  $$.wildcard_p = wildcardp($7);
 			}
 	;
 
@@ -479,6 +483,7 @@
 			  tmp.name = $1;
 			  tmp.exclude_name_list = NULL;
 			  tmp.sorted = FALSE;
+			  tmp.wildcard_p = wildcardp($1);
 			  lang_add_wild (&tmp, NULL, ldgram_had_keep);
 			}
         |	'[' file_NAME_list ']'
diff -dub binutils-2.14/ld/ldlang.c binutils-2.14.new/ld/ldlang.c
--- binutils-2.14/ld/ldlang.c	2003-05-03 18:07:00.000000000 +0200
+++ binutils-2.14.new/ld/ldlang.c	2003-08-28 13:57:20.000000000 +0200
@@ -86,8 +86,6 @@
   PARAMS ((void));
 static void already_linked_table_free
   PARAMS ((void));
-static bfd_boolean wildcardp
-  PARAMS ((const char *));
 static lang_statement_union_type *wild_sort
   PARAMS ((lang_wild_statement_type *, struct wildcard_list *,
 	   lang_input_statement_type *, asection *));
@@ -277,7 +275,7 @@
   struct unique_sections *unam;
 
   for (unam = unique_section_list; unam; unam = unam->next)
-    if (wildcardp (unam->name)
+    if (wildcardp(unam->name)
 	? fnmatch (unam->name, secnam, 0) == 0
 	: strcmp (unam->name, secnam) == 0)
       {
@@ -320,7 +318,7 @@
 	       list_tmp;
 	       list_tmp = list_tmp->next)
 	    {
-	      if (wildcardp (list_tmp->name))
+	      if (wildcardp(list_tmp->name))
 		skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
 	      else
 		skip = strcmp (list_tmp->name, file->filename) == 0;
@@ -331,7 +329,7 @@
 		  && file->the_bfd->my_archive != NULL
 		  && file->the_bfd->my_archive->filename != NULL)
 		{
-		  if (wildcardp (list_tmp->name))
+		  if (wildcardp(list_tmp->name))
 		    skip = fnmatch (list_tmp->name,
 				    file->the_bfd->my_archive->filename,
 				    0) == 0;
@@ -348,7 +346,7 @@
 	    {
 	      const char *sname = bfd_get_section_name (file->the_bfd, s);
 
-	      if (wildcardp (sec->spec.name))
+	      if (sec->spec.wildcard_p)
 		skip = fnmatch (sec->spec.name, sname, 0) != 0;
 	      else
 		skip = strcmp (sec->spec.name, sname) != 0;
@@ -1154,7 +1152,7 @@
    be enough to cause the pattern to be treated as a wildcard.
    That lets us handle DOS filenames more naturally.  */
 
-static bfd_boolean
+bfd_boolean
 wildcardp (pattern)
      const char *pattern;
 {
@@ -4465,9 +4463,10 @@
 
   if (filespec != NULL && filespec->name != NULL)
     {
-      if (strcmp (filespec->name, "*") == 0)
+	if (strcmp (filespec->name, "*") == 0) {
+	    filespec->wildcard_p = FALSE;
 	filespec->name = NULL;
-      else if (! wildcardp (filespec->name))
+      } else if (!filespec->wildcard_p)
 	lang_has_input_file = TRUE;
     }
 
diff -dub binutils-2.14/ld/ldlang.h binutils-2.14.new/ld/ldlang.h
--- binutils-2.14/ld/ldlang.h	2003-03-03 21:00:35.000000000 +0100
+++ binutils-2.14.new/ld/ldlang.h	2003-08-28 12:27:39.000000000 +0200
@@ -407,6 +407,8 @@
   PARAMS ((const char *));
 extern void lang_add_wild
   PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
+extern bfd_boolean wildcardp
+  PARAMS ((const char *));
 extern void lang_add_map
   PARAMS ((const char *));
 extern void lang_add_fill
Common subdirectories: binutils-2.14/ld/ldscripts and binutils-2.14.new/ld/ldscripts
diff -dub binutils-2.14/ld/mri.c binutils-2.14.new/ld/mri.c
--- binutils-2.14/ld/mri.c	2003-01-02 04:53:53.000000000 +0100
+++ binutils-2.14.new/ld/mri.c	2003-08-28 12:27:53.000000000 +0200
@@ -244,6 +244,7 @@
 	  tmp->spec.name = p->name;
 	  tmp->spec.exclude_name_list = NULL;
 	  tmp->spec.sorted = FALSE;
+	  tmp->spec.wildcard_p = wildcardp(p->name);
 	  lang_add_wild (NULL, tmp, FALSE);
 
 	  /* If there is an alias for this section, add it too.  */
@@ -255,6 +256,7 @@
 		tmp->spec.name = aptr->name;
 		tmp->spec.exclude_name_list = NULL;
 		tmp->spec.sorted = FALSE;
+		tmp->spec.wildcard_p = wildcardp(aptr->name);
 		lang_add_wild (NULL, tmp, FALSE);
 	      }
 
