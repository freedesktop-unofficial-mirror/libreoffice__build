unchanged:
--- vcl/source/control/spinbtn.cxx	8 May 2002 16:01:30 -0000	1.3
+++ vcl/source/control/spinbtn.cxx	3 Mar 2004 15:32:07 -0000
@@ -315,3 +315,55 @@ void SpinButton::StateChanged( StateChan
         Invalidate();
     Control::StateChanged( nType );
 }
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinButton::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------

unchanged:
--- vcl/inc/spin.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/spin.hxx	3 Mar 2004 15:32:07 -0000
@@ -90,6 +90,7 @@ private:
     BOOL            mbHorz        : 1;
     Link            maUpHdlLink;
     Link            maDownHdlLink;
+    Rectangle*      ImplFindPartRect( const Point& rPt );
 
 #ifdef _SV_SPIN_CXX
     void            ImplInit( Window* pParent, WinBits nStyle );
@@ -111,6 +112,7 @@ public:
     virtual void    MouseMove( const MouseEvent& rMEvt );
     virtual void    KeyInput( const KeyEvent& rKEvt );
     virtual void    StateChanged( StateChangedType nStateChange );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     void            SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
     const Link&     GetUpHdl() const   { return maUpHdlLink;   }
unchanged:
--- vcl/inc/spinfld.hxx	3 May 2002 13:04:10 -0000	1.3
+++ vcl/inc/spinfld.hxx	3 Mar 2004 15:32:07 -0000
@@ -117,6 +117,7 @@ protected:
 	void			EndDropDown();
 
     virtual void  FillLayoutData() const;
+    Rectangle *     ImplFindPartRect( const Point& rPt );
 public:
 					SpinField( Window* pParent, WinBits nWinStyle = 0 );
 					SpinField( Window* pParent, const ResId& rResId );
@@ -137,6 +138,7 @@ public:
 	virtual void	Resize();
 	virtual void	StateChanged( StateChangedType nType );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
 	void			SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
 	const Link& 	GetUpHdl() const { return maUpHdlLink; }

unchanged:
--- vcl/source/control/spinfld.cxx	12 Sep 2002 08:35:13 -0000	1.10
+++ vcl/source/control/spinfld.cxx	3 Mar 2004 15:32:07 -0000
@@ -82,6 +82,112 @@
 
 // =======================================================================
 
+void ImplGetSpinbuttonValue( Window *pWin, const Rectangle& rUpperRect,
+                            const Rectangle& rLowerRect,
+                            BOOL bUpperIn, BOOL bLowerIn,
+                            BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz,
+                            SpinbuttonValue& rValue )
+{
+    // convert spinbutton data to a SpinbuttonValue structure for native painting
+
+    rValue.maUpperRect = rUpperRect;
+    rValue.maLowerRect = rLowerRect;
+
+    // convert rectangles to screen coordinates
+    Point aPt = pWin->OutputToScreenPixel( rValue.maUpperRect.TopLeft() );
+    rValue.maUpperRect.SetPos( aPt );
+    aPt = pWin->OutputToScreenPixel( rValue.maLowerRect.TopLeft() );
+    rValue.maLowerRect.SetPos( aPt );
+
+    ControlState nState = CTRL_STATE_ENABLED;
+    if ( bUpperIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bUpperEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    if( pWin->IsMouseOver() && rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnUpperState = nState;
+
+    nState = CTRL_STATE_ENABLED;
+    if ( bLowerIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bLowerEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    // for overlapping spins: highlight only one
+    if( pWin->IsMouseOver() && rLowerRect.IsInside( pWin->GetPointerPosPixel() ) &&
+                              !rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnLowerState = nState;
+
+    rValue.mnUpperPart = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+    rValue.mnLowerPart = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+}
+
+
+BOOL ImplDrawNativeSpinfield( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        if( pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnUpperPart) && 
+            pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnLowerPart) )
+        {
+            // only paint the embedded spin buttons, all buttons are painted at once
+            bNativeOK = pWin->DrawNativeControl( CTRL_SPINBOX, PART_ALL_BUTTONS, Region(), ControlState(),
+                        aControlValue, rtl::OUString() );
+        }
+        else
+        {
+            // paint the spinbox as a whole, use borderwindow to have proper clipping
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // to not overwrite everything, set the button region as clipregion to the border window
+            Rectangle aClipRect( rSpinbuttonValue.maLowerRect );
+            aClipRect.Union( rSpinbuttonValue.maUpperRect );
+
+            // convert from screen space to borderwin space
+            aClipRect.SetPos( pBorder->ScreenToOutputPixel(aClipRect.TopLeft()) );
+
+            Region oldRgn( pBorder->GetClipRegion() );
+            pBorder->SetClipRegion( Region( aClipRect ) );
+
+            Point aPt;
+            Size aSize( pBorder->GetOutputSizePixel() );    // the size of the border window, i.e., the whole control
+            Region aRgn( Rectangle( aPt, aSize ) );
+            bNativeOK = pBorder->DrawNativeControl( CTRL_SPINBOX, PART_ENTIRE_CONTROL, aRgn, ControlState(),
+                        aControlValue, rtl::OUString() );
+
+            pBorder->SetClipRegion( oldRgn );
+        }
+    }
+    return bNativeOK;
+}
+
+BOOL ImplDrawNativeSpinbuttons( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBUTTONS, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        // only paint the standalone spin buttons, all buttons are painted at once
+        bNativeOK = pWin->DrawNativeControl( CTRL_SPINBUTTONS, PART_ALL_BUTTONS, Region(), ControlState(),
+                    aControlValue, rtl::OUString() );
+    }
+    return bNativeOK;
+}
+
+
 void ImplDrawSpinButton( OutputDevice* pOutDev,
 						 const Rectangle& rUpperRect,
 						 const Rectangle& rLowerRect,
@@ -98,6 +204,7 @@ void ImplDrawSpinButton( OutputDevice* p
 	const StyleSettings& rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
 	if ( rStyleSettings.GetOptions() & STYLE_OPTION_SPINARROW )
 	{
+        // arrows are only use in OS/2 look
 		if ( bHorz )
 		{
 			eType1 = SYMBOL_ARROW_LEFT;
@@ -127,12 +234,55 @@ void ImplDrawSpinButton( OutputDevice* p
 	USHORT nTempStyle = nStyle;
 	if ( bUpperIn )
 		nTempStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
+
+    BOOL bNativeOK = FALSE;
+	Rectangle aUpRect;
+
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+    {
+        Window *pWin = (Window*) pOutDev;
+
+        // are we drawing standalone spin buttons or members of a spinfield ?
+        ControlType aControl = CTRL_SPINBUTTONS;
+        switch( pWin->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                aControl = CTRL_SPINBOX;
+                break;
+            default:
+                aControl = CTRL_SPINBUTTONS;
+                break;
+        }
+
+        SpinbuttonValue aValue;
+        ImplGetSpinbuttonValue( pWin, rUpperRect, rLowerRect,
+						        bUpperIn, bLowerIn, bUpperEnabled, bLowerEnabled,
+                                bHorz, aValue );
+
+        if( aControl == CTRL_SPINBOX )
+            bNativeOK = ImplDrawNativeSpinfield( pWin, aValue );
+        else if( aControl == CTRL_SPINBUTTONS )
+            bNativeOK = ImplDrawNativeSpinbuttons( pWin, aValue );
+    }
+
+    if( !bNativeOK )
+        aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
 
 	// Unteren/rechten Button malen
 	if ( bLowerIn )
 		nStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
+	Rectangle aLowRect;
+    if( !bNativeOK )
+	    aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
 
 	// Zusaetzliche Default-Kante wollen wir auch ausnutzen
 	aUpRect.Left()--;
@@ -177,11 +327,13 @@ void ImplDrawSpinButton( OutputDevice* p
 	nTempStyle = nSymStyle;
 	if ( !bUpperEnabled )
 		nTempStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
+    if( !bNativeOK )
+	    aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
 
 	if ( !bLowerEnabled )
 		nSymStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
+    if( !bNativeOK )
+        aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
 }
 
 // =======================================================================
@@ -209,8 +361,21 @@ void SpinField::ImplInit( Window* pParen
 	if ( nWinStyle & (WB_SPIN|WB_DROPDOWN) )
 	{
 		mbSpin = TRUE;
-		mpEdit = new Edit( this, WB_NOBORDER );
-        mpEdit->EnableRTL( FALSE );
+		
+		// Some themes want external spin buttons, therefore the main
+		// spinfield should not overdraw the border between its encapsulated
+		// edit field and the spin buttons
+		if ( (nWinStyle & WB_SPIN) &&
+		    IsNativeControlSupported(CTRL_SPINBOX, HAS_BACKGROUND_TEXTURE) ) 
+		{
+			SetBackground();
+			mpEdit = new Edit( this, WB_NOBORDER );
+			mpEdit->SetBackground();
+		}
+		else
+			mpEdit = new Edit( this, WB_NOBORDER );
+
+		mpEdit->EnableRTL( FALSE );
 		mpEdit->SetPosPixel( Point() );
 		mpEdit->Show();
 		SetSubEdit( mpEdit );
@@ -518,9 +683,9 @@ void SpinField::Paint( const Rectangle& 
 {
 	if ( mbSpin )
 	{
-		BOOL bEnable = IsEnabled();
-		ImplDrawSpinButton( this, maUpperRect, maLowerRect,
-							mbUpperIn, mbLowerIn, bEnable, bEnable );
+		BOOL	bEnable = IsEnabled();
+        ImplDrawSpinButton( this, maUpperRect, maLowerRect,
+		                    mbUpperIn, mbLowerIn, bEnable, bEnable );
 	}
 
 	if ( GetStyle() & WB_DROPDOWN )
@@ -547,11 +712,13 @@ void SpinField::Paint( const Rectangle& 
 
 void SpinField::ImplCalcButtonAreas( OutputDevice* pDev, const Size& rOutSz, Rectangle& rDDArea, Rectangle& rSpinUpArea, Rectangle& rSpinDownArea )
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+	const StyleSettings& rStyleSettings = pDev->GetSettings().GetStyleSettings();
 
 	Size aSize = rOutSz;
 	Size aDropDownSize;
 
+    DBG_ASSERT( !(GetStyle() & WB_DROPDOWN), "SpinField::ImplCalcButtonAreas(): SpinField with drop down not supported on all (native) platforms !" );
+
 	if ( GetStyle() & WB_DROPDOWN )
 	{
 		long nW = rStyleSettings.GetScrollBarSize();
@@ -568,13 +735,56 @@ void SpinField::ImplCalcButtonAreas( Out
 	if ( GetStyle() & WB_SPIN )
 	{
 		long nBottom1 = aSize.Height()/2;
+		long nBottom2 = aSize.Height()-1;
 		long nTop2 = nBottom1;
+		long nTop1 = 0;
 		if ( !(aSize.Height() & 0x01) )
 			nBottom1--;
 
-		aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
-		rSpinUpArea = Rectangle( aSize.Width(), 0, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
-		rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), aSize.Height()-1 );
+        BOOL bNativeRegionOK = FALSE;
+        Region aContentUp, aContentDown;
+
+		if ( (pDev->GetOutDevType() == OUTDEV_WINDOW) && 
+            IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+        {
+            Window *pWin = (Window*) pDev;
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // get the system's spin button size
+		    ImplControlValue aControlValue;
+		    Region aBound;
+		    Point aPoint;
+
+            // use the full extent of the control
+		    Region aArea( Rectangle( aPoint, pBorder->GetOutputSizePixel() ) );
+
+		    bNativeRegionOK = 
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_UP,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentUp) &&
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_DOWN,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentDown);
+
+            if( bNativeRegionOK )
+            {
+                // convert back from border space to local coordinates
+                aPoint = pBorder->ScreenToOutputPixel( pWin->OutputToScreenPixel( aPoint ) );
+                aContentUp.Move(-aPoint.X(), -aPoint.Y());
+                aContentDown.Move(-aPoint.X(), -aPoint.Y());
+            }
+        }
+
+        if( bNativeRegionOK )
+        {
+		    rSpinUpArea = aContentUp.GetBoundRect();
+		    rSpinDownArea = aContentDown.GetBoundRect();
+        }
+        else
+        {
+		    aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
+
+		    rSpinUpArea = Rectangle( aSize.Width(), nTop1, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
+		    rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), nBottom2 );
+        }
 	}
 	else
 	{
@@ -589,14 +799,13 @@ void SpinField::Resize()
 {
 	if ( mbSpin )
 	{
-        Control::Resize();
+		Control::Resize();
 		Size aSize = GetOutputSizePixel();
 
 		if ( GetStyle() & (WB_SPIN|WB_DROPDOWN) )
 		{
 			ImplCalcButtonAreas( this, aSize, maDropDownRect, maUpperRect, maLowerRect );
-			aSize.Width() -= maDropDownRect.GetWidth();
-			aSize.Width() -= maUpperRect.GetWidth();
+			aSize.Width() = maUpperRect.Left();
 		}
 
 		mpEdit->SetSizePixel( aSize );
@@ -678,6 +887,56 @@ void SpinField::DataChanged( const DataC
 		Resize();
 		Invalidate();
 	}
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinField::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinField::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Edit::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
