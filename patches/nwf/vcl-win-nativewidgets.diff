unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/win/inc/salnativewidgets.h	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_H
+#define _SV_NATIVEWIDGETS_H
+
+
+#ifdef __cplusplus
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+
+/* SalControlHandleData:
+ * 
+ *   Holds platform specific theming data.
+ */
+
+class SalControlHandleData
+{
+	public:
+		SalControlHandleData( void );
+		~SalControlHandleData( void );
+
+	public:
+        // nothing needed on Win32
+};
+
+
+#endif	/* __cplusplus */
+
+#endif
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/win/source/gdi/salnativewidgets-luna.cxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,996 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#ifndef _SV_SVSYS_H
+#include <svsys.h>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#include "uxtheme.h"
+#include "tmschema.h"
+
+#include <map>
+#include <string>
+
+using namespace rtl;
+using namespace std;
+
+typedef map< wstring, HTHEME > ThemeMap;
+static ThemeMap aThemeMap;
+
+
+/****************************************************
+ wrap visual styles API to avoid linking against it
+ it is not available on all Windows platforms
+*****************************************************/
+
+class VisualStylesAPI
+{
+private:
+    typedef HTHEME  (WINAPI * OpenThemeData_Proc_T) ( HWND hwnd, LPCWSTR pszClassList );
+    typedef HRESULT (WINAPI * CloseThemeData_Proc_T) ( HTHEME hTheme );
+    typedef HRESULT (WINAPI * GetThemeBackgroundContentRect_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    typedef HRESULT (WINAPI * DrawThemeBackground_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    typedef HRESULT (WINAPI * DrawThemeText_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    typedef HRESULT (WINAPI * GetThemePartSize_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+
+    OpenThemeData_Proc_T                    lpfnOpenThemeData;
+    CloseThemeData_Proc_T                   lpfnCloseThemeData;
+    GetThemeBackgroundContentRect_Proc_T    lpfnGetThemeBackgroundContentRect;
+    DrawThemeBackground_Proc_T              lpfnDrawThemeBackground;
+    DrawThemeText_Proc_T                    lpfnDrawThemeText;
+    GetThemePartSize_Proc_T                 lpfnGetThemePartSize;
+
+    HMODULE mhModule;
+
+public:
+    VisualStylesAPI();
+    ~VisualStylesAPI();
+    BOOL IsAvailable()  { return (mhModule != NULL); }
+
+    HTHEME OpenThemeData( HWND hwnd, LPCWSTR pszClassList );
+    HRESULT CloseThemeData( HTHEME hTheme );
+    HRESULT GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    HRESULT DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    HRESULT DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    HRESULT GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+};
+
+static VisualStylesAPI vsAPI;
+
+VisualStylesAPI::VisualStylesAPI()
+{
+    mhModule = LoadLibraryA("uxtheme.dll");
+
+    lpfnOpenThemeData = (OpenThemeData_Proc_T) GetProcAddress( mhModule, "OpenThemeData" );
+    lpfnCloseThemeData = (CloseThemeData_Proc_T) GetProcAddress( mhModule, "CloseThemeData" );
+    lpfnGetThemeBackgroundContentRect = (GetThemeBackgroundContentRect_Proc_T) GetProcAddress( mhModule, "GetThemeBackgroundContentRect" );
+    lpfnDrawThemeBackground = (DrawThemeBackground_Proc_T) GetProcAddress( mhModule, "DrawThemeBackground" );
+    lpfnDrawThemeText = (DrawThemeText_Proc_T) GetProcAddress( mhModule, "DrawThemeText" );
+    lpfnGetThemePartSize = (GetThemePartSize_Proc_T) GetProcAddress( mhModule, "GetThemePartSize" );
+}
+VisualStylesAPI::~VisualStylesAPI()
+{
+    if( mhModule )
+        FreeLibrary( mhModule );
+}
+HTHEME VisualStylesAPI::OpenThemeData( HWND hwnd, LPCWSTR pszClassList )
+{
+    if(lpfnOpenThemeData)
+        return (*lpfnOpenThemeData) (hwnd, pszClassList);
+    else
+        return NULL;
+}
+
+HRESULT VisualStylesAPI::CloseThemeData( HTHEME hTheme )
+{
+    if(lpfnCloseThemeData)
+        return (*lpfnCloseThemeData) (hTheme);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect )
+{
+    if(lpfnGetThemeBackgroundContentRect)
+        return (*lpfnGetThemeBackgroundContentRect) ( hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect );
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect )
+{
+    if(lpfnDrawThemeBackground)
+        return (*lpfnDrawThemeBackground) (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect )
+{
+    if(lpfnDrawThemeText)
+        return (*lpfnDrawThemeText) (hTheme, hdc, iPartId, iStateId, pszText, iCharCount, dwTextFlags, dwTextFlags2, pRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz )
+{
+    if(lpfnGetThemePartSize)
+        return (*lpfnGetThemePartSize) (hTheme, hdc, iPartId, iStateId, prc, eSize, psz);
+    else
+        return S_FALSE;
+}
+
+
+/*********************************************************
+ * Initialize XP theming and local stuff                         
+ *********************************************************/
+void VCLInitNativeWidgets( void )
+{
+}
+
+
+/*********************************************************
+ * Release theming handles
+ *********************************************************/
+void VCLDeinitNativeWidgets( void )
+{
+    ThemeMap::iterator iter = aThemeMap.begin();
+    while( iter != aThemeMap.end() )
+    {
+        vsAPI.CloseThemeData(iter->second);
+        iter++;
+    }
+    aThemeMap.clear();
+}
+
+static HTHEME getThemeHandle( HWND hWnd, LPCWSTR name )
+{
+    if( GetSalData()->mbThemeChanged )
+    {
+        // throw away invalid theme handles
+        VCLDeinitNativeWidgets();
+        GetSalData()->mbThemeChanged = FALSE;
+    }
+
+    ThemeMap::iterator iter;
+    if( (iter = aThemeMap.find( name )) != aThemeMap.end() )
+        return iter->second;
+    // theme not found -> add it to map
+    HTHEME hTheme = vsAPI.OpenThemeData( hWnd, name );
+    if( hTheme != NULL )
+        aThemeMap[name] = hTheme;
+    return hTheme;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    HTHEME hTheme = NULL;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            if( nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT )
+                return FALSE;   // no background painting needed
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_ALL_BUTTONS || 
+                nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN || 
+                nPart == PART_BUTTON_LEFT|| nPart == PART_BUTTON_RIGHT )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_ALL_BUTTONS )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+                //return TRUE;
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+            break;
+    }
+
+    return (hTheme != NULL);
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL SalGraphics::HitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside,
+                              const OutputDevice*)
+{
+    return FALSE;
+}
+
+BOOL ImplDrawTheme( HTHEME hTheme, HDC hDC, int iPart, int iState, RECT rc, const OUString& aStr)
+{
+    HRESULT hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+
+    if( aStr.getLength() )
+    {
+        RECT rcContent;
+        hr = vsAPI.GetThemeBackgroundContentRect( hTheme, hDC, iPart, iState, &rc, &rcContent);
+        hr = vsAPI.DrawThemeText( hTheme, hDC, iPart, iState,
+            aStr.getStr(), -1,
+            DT_CENTER | DT_VCENTER | DT_SINGLELINE,
+            0, &rcContent);
+    }
+    return (hr == S_OK);
+}
+
+
+// Helper functions
+// ----
+
+void ImplConvertSpinbuttonValues( int nControlPart, const ControlState& rState, const Rectangle& rRect, 
+                                 int* pLunaPart, int *pLunaState, RECT *pRect )
+{
+    if( nControlPart == PART_BUTTON_DOWN )
+    {
+        *pLunaPart = SPNP_DOWN;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNS_HOT;
+        else
+            *pLunaState = DNS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_UP )
+    {
+        *pLunaPart = SPNP_UP;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPS_HOT;
+        else
+            *pLunaState = UPS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_RIGHT )
+    {
+        *pLunaPart = SPNP_UPHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNHZS_HOT;
+        else
+            *pLunaState = DNHZS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_LEFT )
+    {
+        *pLunaPart = SPNP_DOWNHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPHZS_HOT;
+        else
+            *pLunaState = UPHZS_NORMAL;
+    }
+
+    pRect->left   = rRect.Left();
+    pRect->right  = rRect.Right()+1;
+    pRect->top    = rRect.Top();
+    pRect->bottom = rRect.Bottom()+1;
+}
+
+// ----
+
+BOOL ImplDrawNativeControl(	HDC hDC, HTHEME hTheme, RECT rc,
+                            ControlType nType,
+							ControlPart nPart,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    // a listbox dropdown is actually a combobox dropdown
+    if( nType == CTRL_LISTBOX )
+        if( nPart == PART_BUTTON_DOWN )
+            nType = CTRL_COMBOBOX;
+
+    // draw entire combobox as a large edit box
+    if( nType == CTRL_COMBOBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    // draw entire spinbox as a large edit box
+    if( nType == CTRL_SPINBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    int iPart(0), iState(0);
+    if( nType == CTRL_SCROLLBAR )
+    {
+        HRESULT hr;
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_UPPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_UPDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_UPHOT;
+            else
+                iState = ABS_UPNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_DOWNPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_DOWNDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_DOWNHOT;
+            else
+                iState = ABS_DOWNNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_LEFTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_LEFTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_LEFTHOT;
+            else
+                iState = ABS_LEFTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_RIGHTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_RIGHTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_RIGHTHOT;
+            else
+                iState = ABS_RIGHTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_THUMB_HORZ || nPart == PART_THUMB_VERT )
+        {
+            iPart = (nPart == PART_THUMB_HORZ) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+
+            SIZE sz;
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_MIN, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_TRUE, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_DRAW, &sz);
+
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            // paint gripper on thumb if enough space
+            if( ( (nPart == PART_THUMB_VERT) && (rc.bottom-rc.top > 12) ) ||
+                ( (nPart == PART_THUMB_HORZ) && (rc.right-rc.left > 12) ) )
+            {
+                iPart = (nPart == PART_THUMB_HORZ) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+                iState = 0;
+                vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            }
+            return (hr == S_OK);
+        }
+        if( nPart == PART_TRACK_HORZ_LEFT || nPart == PART_TRACK_HORZ_RIGHT || nPart == PART_TRACK_VERT_UPPER || nPart == PART_TRACK_VERT_LOWER )
+        {
+            switch( nPart )
+            {
+                case PART_TRACK_HORZ_LEFT:  iPart = SBP_UPPERTRACKHORZ; break;
+                case PART_TRACK_HORZ_RIGHT: iPart = SBP_LOWERTRACKHORZ; break;
+                case PART_TRACK_VERT_UPPER: iPart = SBP_UPPERTRACKVERT; break;
+                case PART_TRACK_VERT_LOWER: iPart = SBP_LOWERTRACKVERT; break;
+            }
+
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+    }
+    if( nType == CTRL_SPINBUTTONS && nPart == PART_ALL_BUTTONS )
+    {
+        SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            BOOL bOk = FALSE;
+
+            RECT rect;
+            ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+            bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+            if( bOk )
+            {
+                ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+            }
+
+            return bOk;
+        }
+    }
+    if( nType == CTRL_SPINBOX )
+    {
+        // decrease spinbutton rects a little
+        //rc.right--;
+        //rc.bottom--;
+        if( nPart == PART_ALL_BUTTONS )
+        {
+            SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+            if( pValue )
+            {
+                BOOL bOk = FALSE;
+
+                RECT rect;
+                ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+                if( bOk )
+                {
+                    ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                    bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+                }
+
+                return bOk;
+            }
+        }
+
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SPNP_DOWN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNS_HOT;
+            else
+                iState = DNS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SPNP_UP;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPS_HOT;
+            else
+                iState = UPS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SPNP_DOWNHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNHZS_HOT;
+            else
+                iState = DNHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SPNP_UPHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPHZS_HOT;
+            else
+                iState = UPHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT || nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN )
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    if( nType == CTRL_COMBOBOX )
+    {
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = CP_DROPDOWNBUTTON;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = CBXS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = CBXS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = CBXS_HOT;
+            else
+                iState = CBXS_NORMAL;
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+    if( nType == CTRL_PUSHBUTTON )
+    {
+        iPart = BP_PUSHBUTTON;
+        if( nState & CTRL_STATE_PRESSED )
+            iState = PBS_PRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = PBS_DISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = PBS_HOT;
+        else if( nState & CTRL_STATE_DEFAULT )
+            iState = PBS_DEFAULTED;
+        //else if( nState & CTRL_STATE_FOCUSED )
+        //    iState = PBS_DEFAULTED;    // may need to draw focus rect 
+        else
+            iState = PBS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_RADIOBUTTON )
+    {
+        iPart = BP_RADIOBUTTON;
+        BOOL bChecked = ( aValue.getTristateVal() == BUTTONVALUE_ON );
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = bChecked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = bChecked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = bChecked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
+        else
+            iState = bChecked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_CHECKBOX )
+    {
+        iPart = BP_CHECKBOX;
+        ButtonValue v = aValue.getTristateVal();
+
+        iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDNORMAL : 
+                ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDNORMAL : CBS_MIXEDNORMAL );
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDDISABLED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDDISABLED : CBS_MIXEDDISABLED );
+        if( nState & CTRL_STATE_PRESSED )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDPRESSED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDPRESSED : CBS_MIXEDPRESSED );
+        if( nState & CTRL_STATE_ROLLOVER )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDHOT : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDHOT : CBS_MIXEDHOT );
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        SIZE sz;
+        THEMESIZE eSize = TS_DRAW; // TS_MIN, TS_TRUE, TS_DRAW
+        vsAPI.GetThemePartSize( hTheme, hDC, iPart, iState, &rc, eSize, &sz);
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_EDITBOX )
+    {
+        iPart = EP_EDITTEXT;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = ETS_DISABLED;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = ETS_FOCUSED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = ETS_HOT;
+        else
+            iState = ETS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_LISTBOX )
+    {
+        if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+        {
+            iPart = LVP_EMPTYTEXT; // ??? no idea which part to choose here
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+
+    if( nType == CTRL_TAB_PANE )
+    {
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_FIXEDBORDER )
+    {
+        /*
+        iPart = BP_GROUPBOX;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = GBS_DISABLED;
+        else
+            iState = GBS_NORMAL;
+            */
+        // The fixed border is only used around the tools->options tabpage where
+        // TABP_PANE fits best
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_BODY )
+    {
+        iPart = TABP_BODY;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        iPart = TABP_TABITEMLEFTEDGE;
+        rc.bottom--;
+
+        TabitemValue *pValue = (TabitemValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            if( pValue->isBothAligned() )
+            {
+                iPart = TABP_TABITEMLEFTEDGE;
+                rc.right--;
+            }
+            else if( pValue->isLeftAligned() )
+                iPart = TABP_TABITEMLEFTEDGE;
+            else if( pValue->isRightAligned() )
+                iPart = TABP_TABITEMRIGHTEDGE;
+            else iPart = TABP_TABITEM;
+        }
+ 
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = TILES_DISABLED;
+        else if( nState & CTRL_STATE_SELECTED )
+        {
+            iState = TILES_SELECTED;
+            // increase the selected tab
+            rc.left-=2;
+            if( pValue && !pValue->isBothAligned() )
+            {
+                if( pValue->isLeftAligned() || pValue->isNotAligned() )
+                    rc.right+=2;
+                if( pValue->isRightAligned() )
+                    rc.right+=1;
+            }
+            rc.top-=2;
+            rc.bottom+=2;
+        }
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = TILES_HOT;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = TILES_FOCUSED;    // may need to draw focus rect 
+        else
+            iState = TILES_NORMAL;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    return false;
+}
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption,
+                            const OutputDevice*)
+{
+    BOOL bOk = false;
+    HTHEME hTheme;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+    }
+
+    if( !hTheme )
+        return false;
+
+	Rectangle buttonRect = rControlRegion.GetBoundRect();
+    RECT rc;
+    rc.left   = buttonRect.Left();
+    rc.right  = buttonRect.Right()+1;
+    rc.top    = buttonRect.Top();
+    rc.bottom = buttonRect.Bottom()+1;
+
+    HDC hDC = GetDC( maGraphicsData.mhWnd );
+
+    // set default text alignment
+    int ta = SetTextAlign( hDC, TA_LEFT|TA_TOP|TA_NOUPDATECP );
+
+    OUString aCaptionStr( aCaption.replace('~', '&') ); // translate mnemonics
+    bOk = ImplDrawNativeControl(hDC, hTheme, rc,
+                            nType, nPart, nState, aValue,
+							rControlHandle, aCaptionStr );
+
+    // restore alignment
+    SetTextAlign( hDC, ta );
+   
+    ReleaseDC( maGraphicsData.mhWnd, hDC );
+
+    //GdiFlush();
+
+	return bOk;
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+                                const OutputDevice*)
+{
+	return( false );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the true bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::GetNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion,
+                                const OutputDevice*)
+{
+    BOOL bRet = FALSE;
+    /*
+    if( nType == CTRL_PUSHBUTTON && nPart == PART_ENTIRE_CONTROL )
+    {
+        if( nState & CTRL_STATE_DEFAULT )
+        {
+            // make default button bigger
+            rNativeContentRegion = rControlRegion;
+            Rectangle aBoundRect = rControlRegion.GetBoundRect();
+            aBoundRect.Top() -= 5;
+            aBoundRect.Bottom() += 5;
+            aBoundRect.Left() -= 8;
+            aBoundRect.Right() += 8;
+            rNativeBoundingRegion = Region( aBoundRect );
+            bRet = TRUE;
+        }
+    }
+*/
+	return( bRet );
+}
+
+
+/************************************************************************/
+/* SalControlHandleData stuff */
+/************************************************************************/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+
+void SalControlHandle::ThemeChanged( void )
+{
+}
