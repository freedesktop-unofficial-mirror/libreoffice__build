unchanged:
--- vcl/inc/window.h	9 Jan 2004 18:13:41 -0000	1.11.136.1
+++ vcl/inc/window.h	3 Mar 2004 15:32:07 -0000
@@ -113,6 +113,7 @@ struct ImplWinData
     Rectangle*          mpFocusRect;
     Rectangle*          mpTrackRect;
     USHORT              mnTrackFlags;
+    BOOL                mbMouseOver;    // tracks mouse over for native widget paint effect
 };
 
 // -------------------
@@ -155,6 +156,8 @@ struct ImplFrameData
     ULONG               mnMouseMoveId;      // MoveId for PostUserLink
     long                mnLastMouseX;       // last x mouse position
     long                mnLastMouseY;       // last y mouse position
+    long                mnBeforeLastMouseX; // last but one x mouse position
+    long                mnBeforeLastMouseY; // last but one y mouse position
     long                mnFirstMouseX;      // first x mouse position by mousebuttondown
     long                mnFirstMouseY;      // first y mouse position by mousebuttondown
     long                mnLastMouseWinX;    // last x mouse position, rel. to pMouseMoveWin
unchanged:
--- vcl/inc/window.hxx	26 Jan 2004 17:20:36 -0000	1.47.112.1
+++ vcl/inc/window.hxx	3 Mar 2004 15:32:07 -0000
@@ -91,6 +91,18 @@
 #include <event.hxx>
 #endif
 
+#ifndef _SV_REGION_HXX
+#include <region.hxx>
+#endif
+
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
@@ -131,6 +143,7 @@ class AccessObjectRef;
 class RmFrameWindow;
 class VCLXWindow;
 struct ImplAccessibleInfos;
+class SalControlHandle;
 
 namespace com {
 namespace sun {
@@ -375,7 +388,7 @@ private:
     void*               mpDummy1;
     void*               mpDummy2;
     void*               mpDummy3;
-    void*               mpDummy4;
+    SalControlHandle*   mpSalControlHandle;
     ImplDelData*        mpFirstDel;
     void*               mpUserData;
     Cursor*             mpCursor;
@@ -422,7 +435,22 @@ private:
     USHORT              mnActivateMode;
     USHORT              mnDlgCtrlFlags;
     USHORT              mnLockCount;
-    USHORT              mnDummy3;
+    BOOL                mbEnableNativeWidget:1,
+                        mbDummy1:1,
+                        mbDummy2:1,
+                        mbDummy3:1,
+                        mbDummy4:1,
+                        mbDummy5:1,
+                        mbDummy6:1,
+                        mbDummy7:1,
+                        mbDummy8:1,
+                        mbDummy9:1,
+                        mbDummy10:1,
+                        mbDummy11:1,
+                        mbDummy12:1,
+                        mbDummy13:1,
+                        mbDummy14:1,
+                        mbDummy15:1;
     USHORT              mnIsTopWindow;
     BOOL                mbFrame:1,
                         mbBorderWin:1,
@@ -594,6 +622,8 @@ public:
     void                SetDialogControlFlags( USHORT nFlags ) { mnDlgCtrlFlags = nFlags; }
     USHORT              GetDialogControlFlags() const { return mnDlgCtrlFlags; }
 
+    BOOL                IsMouseOver();
+
     ULONG               GetCurrentModButtons();
 
     void                SetInputContext( const InputContext& rInputContext );
@@ -753,6 +783,7 @@ public:
     BOOL                IsChildPointerOverwrite() const { return mbChildPtrOverwrite; }
     void                SetPointerPosPixel( const Point& rPos );
     Point               GetPointerPosPixel();
+    Point               GetLastPointerPosPixel();
     void                ShowPointer( BOOL bVisible );
     BOOL                IsPointerVisible() const { return !mbNoPtrVisible; }
     void                EnterWait();
@@ -900,6 +931,52 @@ public:
     // Clipboard/Selection interfaces
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetClipboard();
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetSelection();
+
+    //-------------------------------------
+    //  Native Widget Rendering functions
+    //-------------------------------------
+
+    // form controls will never use native widgets
+    void    EnableNativeWidget( BOOL bEnable = TRUE ) { mbEnableNativeWidget = bEnable; }
+    BOOL    IsNativeWidgetEnabled() const { return mbEnableNativeWidget; }
+
+    // These all just call through to the private mpFrame functions of the same name.
+
+    // Query the platform layer for control support
+    BOOL					IsNativeControlSupported( ControlType nType, ControlPart nPart );
+
+    // Query the native control to determine if it was acted upon
+    BOOL				HitTestNativeControl( ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  const Point& aPos,
+									  BOOL& rIsInside );
+
+    // Request rendering of a particular control and/or part
+    BOOL				DrawNativeControl(    ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  ControlState nState,
+									  const ImplControlValue& aValue,
+									  rtl::OUString aCaption );
+
+     // Request rendering of a caption string for a control
+    BOOL				DrawNativeControlText(     ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption );
+
+    // Query the native control's actual drawing region (including adornment)
+    BOOL				GetNativeControlRegion(  ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption,
+										  Region &rNativeBoundingRegion,
+										  Region &rNativeContentRegion );
 };
 
 inline void Window::SetPosPixel( const Point& rNewPos )
unchanged:
--- vcl/inc/window.imp	28 May 2003 12:30:26 -0000	1.16
+++ vcl/inc/window.imp	3 Mar 2004 15:32:07 -0000
@@ -268,3 +268,4 @@ public:
     void				ImplStartDnd();
 
     static void			ImplInitAppFontData( Window* pWindow );
+    void                ImplInitSalControlHandle();
unchanged:
--- vcl/inc/wintypes.hxx	11 Apr 2003 17:27:04 -0000	1.14
+++ vcl/inc/wintypes.hxx	3 Mar 2004 15:32:07 -0000
@@ -154,7 +154,8 @@ typedef USHORT WindowType;
 #define WINDOW_TREELISTBOX	        (WINDOW_FIRST + 0x4d)
 #define WINDOW_HELPTEXTWINDOW		(WINDOW_FIRST + 0x4e)
 #define WINDOW_INTROWINDOW		    (WINDOW_FIRST + 0x4f)
-#define WINDOW_LAST 				(WINDOW_INTROWINDOW)
+#define WINDOW_LISTBOXWINDOW        (WINDOW_FIRST + 0x50)
+#define WINDOW_LAST 				(WINDOW_LISTBOXWINDOW)
 
 
 // ---------------

unchanged:
--- vcl/source/window/makefile.mk	27 Mar 2003 17:58:22 -0000	1.10
+++ vcl/source/window/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -103,6 +103,7 @@ SLOFILES=	$(SLO)$/accel.obj		\
 			$(SLO)$/toolbox2.obj	\
 			$(SLO)$/window.obj		\
 			$(SLO)$/window2.obj 	\
+			$(SLO)$/window3.obj		\
 			$(SLO)$/winproc.obj 	\
 			$(SLO)$/wrkwin.obj		\
 			$(SLO)$/introwin.obj	\
unchanged:
--- vcl/source/window/window.cxx	5 Feb 2004 16:45:54 -0000	1.176.46.6
+++ vcl/source/window/window.cxx	3 Mar 2004 15:32:07 -0000
@@ -80,6 +80,9 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
 #endif
 
 #include <unohelp.hxx>
@@ -188,7 +191,6 @@
 #include <com/sun/star/accessibility/AccessibleRole.hpp>
 #endif
 
-
 #ifdef REMOTE_APPSERVER
 #include "rmwindow.hxx"
 #include "xevthdl.hxx"
@@ -584,6 +586,7 @@ void Window::ImplInitData( WindowType nT
     mpControlFont       = NULL;         // font propertie
     mpVCLXWindow        = NULL;
     mpAccessibleInfos   = NULL;
+    mpSalControlHandle  = NULL;
     maControlForeground = Color( COL_TRANSPARENT );     // kein Foreground gesetzt
     maControlBackground = Color( COL_TRANSPARENT );     // kein Background gesetzt
     mnLeftBorder        = 0;            // left border
@@ -675,6 +678,7 @@ void Window::ImplInitData( WindowType nT
     mbSuppressAccessibilityEvents = FALSE; // TRUE: do not send any accessibility events
     mbEnableRTL         = TRUE;         // TRUE: this outdev will be mirrored if RTL window layout (UI mirroring) is globally active
     mbDrawSelectionBackground = FALSE;  // TRUE: draws transparent window background to indicate (toolbox) selection
+    mbEnableNativeWidget = TRUE;        // TRUE: try to draw this control with native theme API
 #ifdef REMOTE_APPSERVER
     mpRmEvents          = NULL;
 
@@ -830,6 +834,8 @@ void Window::ImplInit( Window* pParent, 
         mpFrameData->mnMouseMoveId      = 0;
         mpFrameData->mnLastMouseX       = -1;
         mpFrameData->mnLastMouseY       = -1;
+        mpFrameData->mnBeforeLastMouseX = -1;
+        mpFrameData->mnBeforeLastMouseY = -1;
         mpFrameData->mnFirstMouseX      = -1;
         mpFrameData->mnFirstMouseY      = -1;
         mpFrameData->mnLastMouseWinX    = -1;
@@ -1329,6 +1335,7 @@ ImplWinData* Window::ImplGetWinData() co
         mpWinData->mpFocusRect      = NULL;
         mpWinData->mpTrackRect      = NULL;
         mpWinData->mnTrackFlags     = 0;
+        mpWinData->mbMouseOver      = FALSE;
     }
 
     return mpWinData;
@@ -4611,6 +4618,10 @@ Window::~Window()
         delete mpWinData;
     }
 
+    // Native widget support
+    delete mpSalControlHandle;
+    mpSalControlHandle = NULL;
+
     // Overlap-Window-Daten loeschen
     if ( mpOverlapData )
     {
@@ -7337,6 +7348,23 @@ Point Window::GetPointerPosPixel()
 
 // -----------------------------------------------------------------------
 
+Point Window::GetLastPointerPosPixel()
+{
+    DBG_CHKTHIS( Window, ImplDbgCheckWindow );
+
+    Point aPos( mpFrameData->mnBeforeLastMouseX, mpFrameData->mnBeforeLastMouseY );
+#ifndef REMOTE_APPSERVER
+    if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
+    {
+        // --- RTL --- (re-mirror mouse pos at this window)
+        ImplReMirror( aPos );
+    }
+#endif 
+    return ImplFrameToOutput( aPos );
+}
+
+// -----------------------------------------------------------------------
+
 void Window::ShowPointer( BOOL bVisible )
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
@@ -7356,6 +7384,13 @@ void Window::ShowPointer( BOOL bVisible 
 ULONG Window::GetCurrentModButtons()
 {
     return mpFrame ? mpFrame->GetCurrentModButtons() : 0;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::IsMouseOver()
+{
+    return ImplGetWinData()->mbMouseOver;
 }
 
 // -----------------------------------------------------------------------
unchanged:
--- vcl/source/window/winproc.cxx	15 Jan 2004 12:50:42 -0000	1.80.46.2
+++ vcl/source/window/winproc.cxx	3 Mar 2004 15:32:07 -0000
@@ -445,6 +445,8 @@ long ImplHandleMouseEvent( Window* pWind
     }
 
     // update frame data
+    pWindow->mpFrameData->mnBeforeLastMouseX = pWindow->mpFrameData->mnLastMouseX;
+    pWindow->mpFrameData->mnBeforeLastMouseY = pWindow->mpFrameData->mnLastMouseY;
     pWindow->mpFrameData->mnLastMouseX = nX;
     pWindow->mpFrameData->mnLastMouseY = nY;
     pWindow->mpFrameData->mnMouseCode  = nCode;
@@ -685,6 +687,7 @@ long ImplHandleMouseEvent( Window* pWind
                 ImplDelData aDelData;
                 ImplDelData aDelData2;
                 pWindow->mpFrameData->mbInMouseMove = TRUE;
+                pMouseMoveWin->ImplGetWinData()->mbMouseOver = FALSE;
                 pMouseMoveWin->ImplAddDel( &aDelData );
                 // Durch MouseLeave kann auch dieses Fenster zerstoert
                 // werden
@@ -716,6 +719,8 @@ long ImplHandleMouseEvent( Window* pWind
             nMode |= MOUSE_ENTERWINDOW;
         }
         pWindow->mpFrameData->mpMouseMoveWin = pChild;
+        if( pChild )
+            pChild->ImplGetWinData()->mbMouseOver = TRUE;
 
         // MouseLeave
         if ( !pChild )

diff -u vcl/source/window/window3.cxx vcl/source/window/window3.cxx
--- vcl/source/window/window3.cxx	2004-03-03 15:32:34.000000000 +0100
+++ vcl/source/window/window3.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -0,0 +1,264 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define _SV_WINDOW_CXX
+
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
+
+#ifndef _SV_WINDOW_HXX
+#include <window.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+using namespace rtl;
+
+// -----------------------------------------------------------------------
+// These functions are mainly passthrough functions that allow access to
+// the SalFrame behind a Window object for native widget rendering purposes.
+// -----------------------------------------------------------------------
+
+void Window::ImplInitSalControlHandle()
+{
+    // create SalControlHandle on demand
+    // not needed for ordinary windows
+    if( !mpSalControlHandle )
+        mpSalControlHandle = new SalControlHandle;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    return( mpGraphics->IsNativeControlSupported(nType, nPart) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::HitTestNativeControl( ControlType nType,
+                              ControlPart nPart,
+                              const Region& rControlRegion,
+                              const Point& aPos,
+                              BOOL& rIsInside )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->HitTestNativeControl(nType, nPart, rControlRegion, aPos, *mpSalControlHandle, rIsInside, this ) );
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControl( ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if( rControlRegion.IsEmpty() )
+        return TRUE;
+
+    if( !IsInPaint() && IsPaintTransparent() )
+    {
+        // only required if called directly (ie, we're not in Paint() ):
+        // force redraw (Paint()) for transparent controls
+        // to trigger a repaint of the background
+        Region aClipRgn( GetClipRegion() );
+            aClipRgn.Intersect( rControlRegion );
+        Invalidate( aClipRgn, INVALIDATE_UPDATE );
+        return TRUE;
+    }
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return TRUE;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    return( mpGraphics->DrawNativeControl(nType, nPart, screenRegion, nState, aValue, *mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControlText(ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return false;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return true;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    return( mpGraphics->DrawNativeControlText(nType, nPart, screenRegion, nState, aValue, *mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::GetNativeControlRegion(  ControlType nType,
+                                ControlPart nPart,
+                                const Region& rControlRegion,
+                                ControlState nState,
+                                const ImplControlValue& aValue,
+                                OUString aCaption,
+                                Region &rNativeBoundingRegion,
+                                Region &rNativeContentRegion )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->GetNativeControlRegion(nType, nPart, rControlRegion, nState, aValue,
+                                *mpSalControlHandle, aCaption, rNativeBoundingRegion,
+                                rNativeContentRegion, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+SalControlHandle::SalControlHandle()
+{
+}
+
+
+// -----------------------------------------------------------------------
+
+SalControlHandle::~SalControlHandle()
+{
+}


unchanged:
--- vcl/source/window/brdwin.cxx	9 Jan 2004 18:13:54 -0000	1.9.82.1
+++ vcl/source/window/brdwin.cxx	3 Mar 2004 15:32:07 -0000
@@ -101,10 +101,12 @@
 #ifndef _SV_HELP_HXX
 #include <help.hxx>
 #endif
+#ifndef _SV_EDIT_HXX
+#include <edit.hxx>
+#endif
 #ifndef _SV_BRDWIN_HXX
 #include <brdwin.hxx>
 #endif
-
 #include <tools/debug.hxx>
 
 #include <rvp.hxx>
@@ -1066,6 +1068,112 @@ void ImplSmallBorderWindowView::DrawWind
 	USHORT nBorderStyle = mpBorderWindow->GetBorderStyle();
 	if ( nBorderStyle & WINDOW_BORDER_NOBORDER )
 		return;
+
+    BOOL bNativeOK = FALSE;
+    // for native widget drawing we must find out what
+    // control this border belongs to
+    Window *pWin = NULL, *pCtrl = NULL;
+    if( mpOutDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) mpOutDev;
+
+    ControlType aCtrlType = 0;
+    ControlPart aCtrlPart = PART_ENTIRE_CONTROL;
+
+    if( pWin && (pCtrl = mpBorderWindow->GetWindow( WINDOW_CLIENT )) != NULL )
+    {
+        switch( pCtrl->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                if( pCtrl->GetStyle() & WB_SPIN )
+                    aCtrlType = CTRL_SPINBOX;
+                else
+                    aCtrlType = CTRL_EDITBOX;
+                break;
+
+            case WINDOW_LISTBOX:
+            case WINDOW_MULTILISTBOX:
+            case WINDOW_TREELISTBOX:
+                aCtrlType = CTRL_LISTBOX;
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                else
+                    aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_LISTBOXWINDOW:
+                aCtrlType = CTRL_LISTBOX;
+                aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_COMBOBOX:
+            case WINDOW_PATTERNBOX:			
+            case WINDOW_NUMERICBOX:			
+            case WINDOW_METRICBOX:			
+            case WINDOW_CURRENCYBOX:
+            case WINDOW_DATEBOX:		
+            case WINDOW_TIMEBOX:			
+            case WINDOW_LONGCURRENCYBOX:
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                {
+                    aCtrlType = CTRL_COMBOBOX;
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                }
+                else
+                {
+                    aCtrlType = CTRL_LISTBOX;
+                    aCtrlPart = PART_WINDOW;
+                }
+                break;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    if ( aCtrlType && pWin->IsNativeControlSupported(aCtrlType, aCtrlPart) )
+    {
+        ImplControlValue aControlValue;
+        ControlState     nState = CTRL_STATE_ENABLED;
+
+        if ( !pWin->IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( pWin->HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        BOOL bMouseOver = FALSE;
+        Window *pCtrlChild = pCtrl->GetWindow( WINDOW_FIRSTCHILD );
+        while( pCtrlChild && !(bMouseOver = pCtrlChild->IsMouseOver()) )
+            pCtrlChild = pCtrlChild->GetWindow( WINDOW_NEXT );
+    	
+        if( bMouseOver )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        Point aPoint;
+        Region aCtrlRegion( Rectangle( aPoint, Size( mnWidth, mnHeight ) ) );
+        bNativeOK = pWin->DrawNativeControl( aCtrlType, aCtrlPart, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
+
+        // if the native theme draws the spinbuttons in one call, make sure the proper settings
+        // are passed, this might force a redraw though.... (TODO: improve)
+        if ( (aCtrlType == CTRL_SPINBOX) && !pWin->IsNativeControlSupported( CTRL_SPINBOX, PART_BUTTON_UP ) )
+        {
+            Edit *pEdit = ((Edit*) pCtrl)->GetSubEdit();
+            if ( pEdit )
+                pCtrl->Paint( Rectangle() );  // make sure the buttons are also drawn as they might overwrite the border
+        }
+    }
+
+    if( bNativeOK )
+        return;
 
 	if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
 	{
