unchanged:
--- vcl/inc/button.hxx	17 Apr 2003 17:55:12 -0000	1.8
+++ vcl/inc/button.hxx	3 Mar 2004 15:32:06 -0000
@@ -78,6 +78,10 @@
 #include <bitmap.hxx>
 #endif
 
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 class UserDrawEvent;
 
 // ----------
@@ -180,6 +184,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
     virtual void    UserDraw( const UserDrawEvent& rUDEvt );
 
     virtual void    Toggle();
@@ -376,6 +381,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();
 
@@ -465,7 +471,8 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();

 
--- vcl/source/control/button.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/button.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -102,6 +102,9 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGET_HXX
+#include <salnativewidgets.hxx>
+#endif
 
 #ifndef _SV_RC_H
 #include <rc.h>
@@ -287,27 +290,48 @@
 {
     const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
-    if ( bFont )
-    {
-        Font aFont = rStyleSettings.GetPushButtonFont();
-        if ( IsControlFont() )
-            aFont.Merge( GetControlFont() );
-        SetZoomedPointFont( aFont );
-    }
+        if ( bFont )
+        {
+            Font aFont = rStyleSettings.GetPushButtonFont();
+            if ( IsControlFont() )
+                aFont.Merge( GetControlFont() );
+            SetZoomedPointFont( aFont );
+        }
 
-    if ( bForeground || bFont )
+        if ( bForeground || bFont )
+        {
+            Color aColor;
+            if ( IsControlForeground() )
+                aColor = GetControlForeground();
+            else
+                aColor = rStyleSettings.GetButtonTextColor();
+            SetTextColor( aColor );
+            SetTextFillColor();
+        }
+
+        if ( bBackground )
     {
-        Color aColor;
-        if ( IsControlForeground() )
-            aColor = GetControlForeground();
+        Window* pParent = GetParent();
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL ) )
+        {
+            EnableChildTransparentMode( TRUE );
+            SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+            SetPaintTransparent( TRUE );
+            SetBackground();
+    }
         else
-            aColor = rStyleSettings.GetButtonTextColor();
-        SetTextColor( aColor );
-        SetTextFillColor();
+        {
+            EnableChildTransparentMode( FALSE );
+            SetParentClipMode( 0 );
+            SetPaintTransparent( FALSE );
+
+            if ( IsControlBackground() )
+                SetBackground( GetControlBackground() );
+            else
+                SetBackground( pParent->GetBackground() );
+        }
     }
-
-    if ( bBackground )
-        SetBackground();
 }
 
 // -----------------------------------------------------------------------
@@ -848,20 +872,99 @@
     Rectangle               aRect( aPoint, aOutSz );
     Rectangle               aInRect = aRect;
     Rectangle               aTextRect;
+    BOOL                    bNativeOK = FALSE;
 
     // adjust style if button should be rendered 'pressed'
     if ( mbPressed )
         nButtonStyle |= BUTTON_DRAW_PRESSED;
 
-    // draw PushButtonFrame, aInRect has content size afterwards
-    if( ! bLayout )
-        ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+    // TODO: move this to Window class or make it a member !!!
+    ControlType aCtrlType = 0;
+    switch( GetParent()->GetType() )
+    {
+        case WINDOW_LISTBOX:
+        case WINDOW_MULTILISTBOX:
+        case WINDOW_TREELISTBOX:
+            aCtrlType = CTRL_LISTBOX;
+            break;
+
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            aCtrlType = CTRL_COMBOBOX;
+            break;
+        default:
+            break;
+    }
+
+    BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+    if( bDropDown && (aCtrlType == CTRL_COMBOBOX || aCtrlType == CTRL_LISTBOX ) )
+    {
+        if( IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) )
+        {
+            if( !IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+                // skip painting if the button was already drawn by the theme
+                bNativeOK = TRUE;
+            else
+            {
+                // let the theme draw it, note we then need support
+                // for CTRL_LISTBOX/PART_BUTTON_DOWN and CTRL_COMBOBOX/PART_BUTTON_DOWN
+
+                ImplControlValue    aControlValue;
+                Region              aCtrlRegion( aInRect );
+                ControlState        nState = 0;
+
+                if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+                if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+                if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+                if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+                if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
 
-    // draw content
-    ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+                if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+                    nState |= CTRL_STATE_ROLLOVER;
 
-    if( ! bLayout )
+                bNativeOK = DrawNativeControl( aCtrlType, PART_BUTTON_DOWN, aCtrlRegion, nState,
+                                                aControlValue, rtl::OUString() );
+            }
+        }
+    }
+
+    if( bNativeOK )
+        return;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
     {
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aInRect );
+        ControlState	 nState = 0;
+
+        if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED ) nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     				aControlValue, rtl::OUString()/*PushButton::GetText()*/ );
+
+        // draw frame into invisible window to have aInRect modified correctly
+        // but do not shift the inner rect for pressed buttons (ie remove BUTTON_DRAW_PRESSED)
+        // this assumes the theme has enough visual cues to signalize the button was pressed
+        Window aWin( this );
+        ImplDrawPushButtonFrame( &aWin, aInRect, nButtonStyle & ~BUTTON_DRAW_PRESSED );
+
+        // draw content using the same aInRect as non-native VCL would do
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
         maFocusRect = aTextRect;
         if( !maFocusRect.IsEmpty() )
         {
@@ -870,21 +973,97 @@
             maFocusRect.Right()++;
             maFocusRect.Bottom()++;
             if ( HasFocus() )
-            {
                 ShowFocus( maFocusRect );
-            }
         }
     }
+
+    if ( bNativeOK == FALSE )
+    {
+        // draw PushButtonFrame, aInRect has content size afterwards
+        if( ! bLayout )
+            ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+
+        // draw content
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
+        if( ! bLayout )
+        {
+            maFocusRect = aTextRect;
+            if( !maFocusRect.IsEmpty() )
+            {
+                maFocusRect.Left()--;
+                maFocusRect.Top()--;
+                maFocusRect.Right()++;
+                maFocusRect.Bottom()++;
+                if ( HasFocus() )
+                {
+                    ShowFocus( maFocusRect );
+                }
+            }
+        } 
+    }
 }
 
 // -----------------------------------------------------------------------
 
 void PushButton::ImplSetDefButton( BOOL bSet )
 {
+    Size aSize( GetSizePixel() );
+    Point aPos( GetPosPixel() );
+    int dLeft(0), dRight(0), dTop(0), dBottom(0);
+    BOOL bSetPos = FALSE;
+
+    if ( (IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        Region aBoundingRgn, aContentRgn;
+        Rectangle aCtrlRect( 0, 0, 80, 20 ); // use a constant size to avoid accumulating
+                                             // will not work if the theme has dynamic adornment sizes
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aCtrlRect );
+        ControlState	 nState = CTRL_STATE_DEFAULT|CTRL_STATE_ENABLED;
+
+        // get native size of a 'default' button
+        // and adjust the VCL button if more space for adornment is required
+        if( GetNativeControlRegion( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion,
+                                nState, aControlValue, rtl::OUString(),
+								aBoundingRgn, aContentRgn ) )
+        {
+            Rectangle aCont(aContentRgn.GetBoundRect());
+            Rectangle aBound(aBoundingRgn.GetBoundRect());
+
+            dLeft = aCont.Left() - aBound.Left();
+            dTop = aCont.Top() - aBound.Top();
+            dRight = aBound.Right() - aCont.Right();
+            dBottom = aBound.Bottom() - aCont.Bottom();
+            bSetPos = dLeft || dTop || dRight || dBottom;
+        }
+    }
+
     if ( bSet )
+    {
+        if( !(mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from non-default to default
+            aPos.Move(-dLeft, -dTop);
+            aSize.Width() += dLeft + dRight;
+            aSize.Height() += dTop + dBottom;
+        }
         mnButtonState |= BUTTON_DRAW_DEFAULT;
+    }
     else
+    {
+        if( (mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from default to non-default
+            aPos.Move(dLeft, dTop);
+            aSize.Width() -= dLeft + dRight;
+            aSize.Height() -= dTop + dBottom;
+        }
         mnButtonState &= ~BUTTON_DRAW_DEFAULT;
+    }
+    if( bSetPos )
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+
     Invalidate();
 }
 
@@ -1076,6 +1255,8 @@
     Rectangle   aTextRect;
     Font        aFont = GetDrawPixelFont( pDev );
 
+	return;
+
     pDev->Push();
     pDev->SetMapMode();
     pDev->SetFont( aFont );
@@ -1186,6 +1367,79 @@
 
 // -----------------------------------------------------------------------
 
+long PushButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+
+            // TODO: move this to Window class or make it a member !!!
+            ControlType aCtrlType = 0;
+            switch( GetParent()->GetType() )
+            {
+                case WINDOW_LISTBOX:
+                case WINDOW_MULTILISTBOX:
+                case WINDOW_TREELISTBOX:
+                    aCtrlType = CTRL_LISTBOX;
+                    break;
+
+                case WINDOW_COMBOBOX:
+                case WINDOW_PATTERNBOX:			
+                case WINDOW_NUMERICBOX:			
+                case WINDOW_METRICBOX:			
+                case WINDOW_CURRENCYBOX:
+                case WINDOW_DATEBOX:		
+                case WINDOW_TIMEBOX:			
+                case WINDOW_LONGCURRENCYBOX:
+                    aCtrlType = CTRL_COMBOBOX;
+                    break;
+                default:
+                    break;
+            }
+
+            BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+            if( bDropDown && IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) && 
+                   !IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+            {
+                Window *pBorder = GetParent()->GetWindow( WINDOW_BORDER );
+                if(aCtrlType == CTRL_COMBOBOX)
+                {
+                    // only paint the button part to avoid flickering of the combobox text
+                    Point aPt;
+                    Rectangle aClipRect( aPt, GetOutputSizePixel() );
+                    aClipRect.SetPos(pBorder->ScreenToOutputPixel(OutputToScreenPixel(aClipRect.TopLeft())));
+                    Region oldRgn( pBorder->GetClipRegion() );
+                    pBorder->SetClipRegion(Region( aClipRect ));
+                    pBorder->Paint( Rectangle() );
+                    pBorder->SetClipRegion( oldRgn );
+                }
+                else
+                {
+                    pBorder->Invalidate( INVALIDATE_NOERASE );
+                    pBorder->Update();
+                }
+            }
+            else if( IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                Region aRgn( GetActiveClipRegion() );
+                SetClipRegion();
+                Paint( Rectangle() );
+                SetClipRegion( aRgn );
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void PushButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_PUSHBUTTON_TOGGLE );
@@ -1635,7 +1889,8 @@
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -1669,7 +1924,31 @@
 void RadioButton::ImplDrawRadioButtonState()
 {
     USHORT nStyle = 0;
+    BOOL   bNativeOK = FALSE;
+
+    // no native drawing for image radio buttons
+    if ( !maImage && (bNativeOK=IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		    aControlValue( mbChecked ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Rectangle					aCtrlRect( maStateRect.TopLeft(), maStateRect.GetSize() );
+        Region						aCtrlRegion( aCtrlRect );
+        ControlState				nState = 0;
+
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
 
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue,rtl::OUString() );
+
+    }
+
+if ( bNativeOK == FALSE )
+{
     // kein Image-RadioButton
     if ( !maImage )
     {
@@ -1762,6 +2041,7 @@
             ShowFocus( maFocusRect );
     }
 }
+}
 
 // -----------------------------------------------------------------------
 
@@ -1812,6 +2092,7 @@
             rFocusRect = rMouseRect;
             rFocusRect.Left()--;
             rFocusRect.Right()++;
+            //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
             rMouseRect.Left()   = rPos.X();
             rStateRect.Left()   = rPos.X();
@@ -1910,10 +2191,11 @@
     aImageSize.Width()  = CalcZoom( aImageSize.Width() );
     aImageSize.Height() = CalcZoom( aImageSize.Height() );
 
+    // Draw control text
     ImplDraw( this, 0, Point(), GetOutputSizePixel(),
               aImageSize, IMPL_SEP_BUTTON_IMAGE, maStateRect, maMouseRect, maFocusRect, bLayout );
 
-    if( !bLayout )
+    if( !bLayout || (IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)==TRUE) )
     {
         if ( !maImage )
         {
@@ -2352,6 +2634,39 @@
 
 // -----------------------------------------------------------------------
 
+long RadioButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                     pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+
+                    Region aRgn( GetActiveClipRegion() );
+                    SetClipRegion( maStateRect );
+                    Paint( maStateRect );
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void RadioButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_RADIOBUTTON_TOGGLE );
@@ -2611,7 +2926,8 @@
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported( CTRL_CHECKBOX, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -2651,18 +2967,46 @@
 
 void CheckBox::ImplDrawCheckBoxState()
 {
-    USHORT nStyle = mnButtonState;
-    if ( !IsEnabled() )
-        nStyle |= BUTTON_DRAW_DISABLED;
-    if ( meState == STATE_DONTKNOW )
-        nStyle |= BUTTON_DRAW_DONTKNOW;
-    else if ( meState == STATE_CHECK )
-        nStyle |= BUTTON_DRAW_CHECKED;
-    Image aImage = GetCheckImage( GetSettings(), nStyle );
-    if ( IsZoom() )
-        DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
-    else
-        DrawImage( maStateRect.TopLeft(), aImage );
+    bool	bNativeOK = TRUE;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue    aControlValue( meState == STATE_CHECK ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Region              aCtrlRegion( maStateRect );
+        ControlState        nState = 0;
+
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( meState == STATE_CHECK )
+            aControlValue.setTristateVal( BUTTONVALUE_ON );
+        else if ( meState == STATE_DONTKNOW )					
+            aControlValue.setTristateVal( BUTTONVALUE_MIXED );
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_CHECKBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+
+    if ( bNativeOK == FALSE )
+    {
+        USHORT nStyle = mnButtonState;
+        if ( !IsEnabled() )
+            nStyle |= BUTTON_DRAW_DISABLED;
+        if ( meState == STATE_DONTKNOW )
+            nStyle |= BUTTON_DRAW_DONTKNOW;
+        else if ( meState == STATE_CHECK )
+            nStyle |= BUTTON_DRAW_CHECKED;
+        Image aImage = GetCheckImage( GetSettings(), nStyle );
+        if ( IsZoom() )
+            DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
+        else
+            DrawImage( maStateRect.TopLeft(), aImage );
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -2711,11 +3055,11 @@
         rFocusRect = rMouseRect;
         rFocusRect.Left()--;
         rFocusRect.Right()++;
+        //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
+        rStateRect.Left()   = rPos.X();
+        rStateRect.Top()    = rMouseRect.Top();
         rMouseRect.Left()   = rPos.X();
-        // add 1 so that checkboxes with and without text are aligned
-        rStateRect.Left()   = rPos.X()+1;
-        rStateRect.Top()    = rMouseRect.Top()+1;
 
         long nTextHeight = GetTextHeight();
         if ( nTextHeight > rImageSize.Height() )
@@ -2730,17 +3074,22 @@
         if ( nWinStyle & WB_CENTER )
             rStateRect.Left() = rPos.X()+((rSize.Width()-rImageSize.Width())/2);
         else if ( nWinStyle & WB_RIGHT )
-            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width()-1;
+            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width();
         else
-            rStateRect.Left() = rPos.X()+1;
+            rStateRect.Left() = rPos.X();
         if ( nWinStyle & WB_VCENTER )
             rStateRect.Top() = rPos.Y()+((rSize.Height()-rImageSize.Height())/2);
         else if ( nWinStyle & WB_BOTTOM )
-            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height()-1;
+            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height();
         else
-            rStateRect.Top() = rPos.Y()+1;
+            rStateRect.Top() = rPos.Y();
         rStateRect.Right()  = rStateRect.Left()+rImageSize.Width()-1;
         rStateRect.Bottom() = rStateRect.Top()+rImageSize.Height()-1;
+        // provide space for focusrect
+        // note: this assumes that the control's size was adjusted
+        // accordingly in Get/LoseFocus, so the onscreen position won't change
+        if( HasFocus() )
+            rStateRect.Move( 1, 1 );    
         rMouseRect          = rStateRect;
 
         rFocusRect          = rStateRect;
@@ -3044,7 +3393,21 @@
 
 void CheckBox::GetFocus()
 {
-    ShowFocus( maFocusRect );
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // increase button size to have space for focus rect
+        // checkboxes without text will draw focusrect around the check
+        // See CheckBox::ImplDraw()
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(-1,-1);
+        aSize.Height() += 2;
+        aSize.Width() += 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
+    else
+        ShowFocus( maFocusRect );
     SetInputContext( InputContext( GetFont() ) );
     Button::GetFocus();
 }
@@ -3061,6 +3424,19 @@
 
     HideFocus();
     Button::LoseFocus();
+
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // decrease button size again (see GetFocus())
+        // checkboxes without text will draw focusrect around the check
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(1,1);
+        aSize.Height() -= 2;
+        aSize.Width() -= 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -3136,0 +3513,33 @@
+
+long CheckBox::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                    pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+
+                    Region aRgn( GetActiveClipRegion() );
+                    SetClipRegion( maStateRect );
+                    Paint( maStateRect );
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
