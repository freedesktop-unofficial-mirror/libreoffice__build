diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.cxx	2005-06-28 11:18:28.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx	2005-06-30 17:10:54.000000000 +0200
@@ -91,14 +91,11 @@
    OTHER DEALINGS IN THE SOFTWARE.
    ----------------------------------------------------------------------- */
 
-#include <typelib/typedescription.hxx>
-#include <rtl/ustring.hxx>
+#include <abi.hxx>
 
-namespace x86_64
-{
+#include <rtl/ustring.hxx>
 
-#define MAX_GPR_REGS 6
-#define MAX_SSE_REGS 8
+using namespace x86_64;
 
 typedef struct
 {
@@ -237,21 +234,24 @@ classify_argument( typelib_TypeDescripti
         case typelib_TypeClass_STRUCT:
         case typelib_TypeClass_EXCEPTION:
             {
-                if ( !pTypeRef->pType->bComplete )
-                    typelib_typedescription_complete( &(pTypeRef->pType) );
+                typelib_TypeDescription * pTypeDescr = 0;
+                TYPELIB_DANGER_GET( &pTypeDescr, pTypeRef );
 
                 const int UNITS_PER_WORD = 8;
-                int words = ( pTypeRef->pType->nSize + UNITS_PER_WORD - 1 ) / UNITS_PER_WORD;
+                int words = ( pTypeDescr->nSize + UNITS_PER_WORD - 1 ) / UNITS_PER_WORD;
                 enum x86_64_reg_class subclasses[MAX_CLASSES];
 
                 /* If the struct is larger than 16 bytes, pass it on the stack.  */
-                if ( pTypeRef->pType->nSize > 16 )
+                if ( pTypeDescr->nSize > 16 )
+                {
+                    TYPELIB_DANGER_RELEASE( pTypeDescr );
                     return 0;
+                }
 
                 for ( int i = 0; i < words; i++ )
                     classes[i] = X86_64_NO_CLASS;
 
-                const typelib_CompoundTypeDescription *pStruct = reinterpret_cast<const typelib_CompoundTypeDescription*>( pTypeRef->pType );
+                const typelib_CompoundTypeDescription *pStruct = reinterpret_cast<const typelib_CompoundTypeDescription*>( pTypeDescr );
 
                 /* Merge the fields of structure.  */
                 for ( sal_Int32 nMember = 0; nMember < pStruct->nMembers; ++nMember )
@@ -261,7 +261,10 @@ classify_argument( typelib_TypeDescripti
                     int num = classify_argument( pTypeInStruct, subclasses, rByteOffset );
 
                     if ( num == 0 )
+                    {
+                        TYPELIB_DANGER_RELEASE( pTypeDescr );
                         return 0;
+                    }
 
                     for ( int i = 0; i < num; i++ )
                     {
@@ -273,6 +276,8 @@ classify_argument( typelib_TypeDescripti
                         rByteOffset = pStruct->pMemberOffsets[ nMember ];
                 }
 
+                TYPELIB_DANGER_RELEASE( pTypeDescr );
+
                 /* Final merger cleanup.  */
                 for ( int i = 0; i < words; i++ )
                 {
@@ -304,56 +309,79 @@ classify_argument( typelib_TypeDescripti
     return 0; /* Never reached.  */
 }
 
-#if 0
 /* Examine the argument and return set number of register required in each
    class.  Return 0 iff parameter should be passed in memory.  */
-static int
-examine_argument( const pTypelib_TypeDescription *pType, int in_return, int *int_nregs, int *sse_nregs )
+bool x86_64::examine_argument( typelib_TypeDescriptionReference *pTypeRef, bool bInReturn, int &nUsedGPR, int &nUsedSSE )
 {
     enum x86_64_reg_class classes[MAX_CLASSES];
     int offset = 0;
     int n;
 
-    n = classify_argument( pType, classes, &offset );
+    n = classify_argument( pTypeRef, classes, offset );
 
-    if (n == 0)
-        return 0;
+    if ( n == 0 )
+        return false;
 
-    *int_nregs = 0;
-    *sse_nregs = 0;
-    for (n--; n>=0; n--)
-        switch (classes[n])
+    nUsedGPR = 0;
+    nUsedSSE = 0;
+    for ( n--; n >= 0; n-- )
+        switch ( classes[n] )
         {
             case X86_64_INTEGER_CLASS:
             case X86_64_INTEGERSI_CLASS:
-                (*int_nregs)++;
+                nUsedGPR++;
                 break;
             case X86_64_SSE_CLASS:
             case X86_64_SSESF_CLASS:
             case X86_64_SSEDF_CLASS:
-                (*sse_nregs)++;
+                nUsedSSE++;
                 break;
             case X86_64_NO_CLASS:
             case X86_64_SSEUP_CLASS:
                 break;
             case X86_64_X87_CLASS:
             case X86_64_X87UP_CLASS:
-                if (!in_return)
-                    return 0;
+                if ( !bInReturn )
+                    return false;
                 break;
             default:
-                abort ();
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "Unhandled case: classes[n] == %d\n", classes[n] );
+#endif
+            OSL_ASSERT(0);
         }
-    return 1;
+    return true;
+}
+
+bool x86_64::return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef )
+{
+    int g, s;
+
+    return examine_argument( pTypeRef, true, g, s ) == 0;
 }
-#endif
 
-bool returnInHiddenParam( typelib_TypeDescriptionReference *pTypeRef )
+void x86_64::fill_struct( typelib_TypeDescriptionReference *pTypeRef, void * const *pGPR, void * const *pSSE, void *pStruct )
 {
     enum x86_64_reg_class classes[MAX_CLASSES];
-    int i = 0;
+    int offset = 0;
+    int n;
+
+    n = classify_argument( pTypeRef, classes, offset );
 
-    return classify_argument( pTypeRef, classes, i ) == 0;
+    sal_uInt64 *pStructAlign = reinterpret_cast<sal_uInt64 *>( pStruct );
+    for ( n--; n >= 0; n-- )
+        switch ( classes[n] )
+        {
+            case X86_64_INTEGER_CLASS:
+            case X86_64_INTEGERSI_CLASS:
+                *pStructAlign++ = *reinterpret_cast<sal_uInt64 *>( *pGPR++ );
+                break;
+            case X86_64_SSE_CLASS:
+            case X86_64_SSESF_CLASS:
+            case X86_64_SSEDF_CLASS:
+                *pStructAlign++ = *reinterpret_cast<sal_uInt64 *>( *pSSE++ );
+                break;
+        }
 }
 
 #if 0
@@ -804,5 +832,3 @@ ffi_closure_UNIX64_inner(ffi_closure *cl
 }
 
 #endif
-
-} // namespace x86_64
Files bridges.orig/source/cpp_uno/gcc3_linux_x86-64/.abi.cxx.swp and bridges/source/cpp_uno/gcc3_linux_x86-64/.abi.cxx.swp differ
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.hxx bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.hxx	2005-06-28 11:18:28.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx	2005-06-30 17:09:05.000000000 +0200
@@ -66,16 +66,35 @@
 // Application Binary Interface, AMD64 Architecture Processor Supplement
 // (http://www.x86-64.org/documentation/abi-0.95.pdf)
 
+#include <typelib/typedescription.hxx>
+
 namespace x86_64
 {
 
-/** Does a function that returns this type use a hidden parameter or registers?
+/* 6 general purpose registers are used for parameter passing */
+const sal_uInt32 MAX_GPR_REGS = 6;
+
+/* 8 SSE registers are used for parameter passing */
+const sal_uInt32 MAX_SSE_REGS = 8;
+
+/* Count number of required registers.
+
+ Examine the argument and return set number of register required in each
+ class.
+ 
+ Return false iff parameter should be passed in memory.
+*/
+bool examine_argument( typelib_TypeDescriptionReference *pTypeRef, bool bInReturn, int &nUsedGPR, int &nUsedSSE );
+
+/** Does function that returns this type use a hidden parameter, or registers?
 
  The value can be returned either in a hidden 1st parameter (which is a
  pointer to a structure allocated by the caller), or in registers (rax, rdx
  for the integers, xmm0, xmm1 for the floating point numbers).
 */
-bool returnInHiddenParam( typelib_TypeDescriptionReference *pTypeRef );
+bool return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef );
+
+void fill_struct( typelib_TypeDescriptionReference *pTypeRef, void * const *pGPR, void * const *pSSE, void *pStruct );
 
 } // namespace x86_64
 
Files bridges.orig/source/cpp_uno/gcc3_linux_x86-64/.abi.hxx.swp and bridges/source/cpp_uno/gcc3_linux_x86-64/.abi.hxx.swp differ
Files bridges.orig/source/cpp_uno/gcc3_linux_x86-64/.call.s.swp and bridges/source/cpp_uno/gcc3_linux_x86-64/.call.s.swp differ
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	2005-06-28 11:18:28.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	2005-06-30 17:13:33.000000000 +0200
@@ -86,13 +86,20 @@ using namespace ::com::sun::star::uno;
 namespace
 {
 
-// 6 integral parameters are passed in registers
-const sal_uInt32 GPR_COUNT = 6;
-
-// 8 floating point parameters are passed in SSE registers
-const sal_uInt32 FPR_COUNT = 8;
-
 //==================================================================================================
+
+// Perform the UNO call
+//
+// We must convert the paramaters stored in gpreg, fpreg and ovrflw to UNO
+// arguments and call pThis->getUnoI()->pDispatcher.
+//
+// gpreg:  [ret *], this, [gpr params]
+// fpreg:  [fpr params]
+// ovrflw: [gpr or fpr params (properly aligned)]
+//
+// [ret *] is present when we are returning a structure bigger than 16 bytes
+// Simple types are returned in rax, rdx (int), or xmm0, xmm1 (fp).
+// Similarly structures <= 16 bytes are in rax, rdx, xmm0, xmm1 as necessary.
 static typelib_TypeClass cpp2uno_call(
 	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
 	const typelib_TypeDescription * pMemberTypeDescr,
@@ -103,12 +110,7 @@ static typelib_TypeClass cpp2uno_call(
 {
 	int nr_gpr = 0; //number of gpr registers used 
 	int nr_fpr = 0; //number of fpr regsiters used
-	void ** pCppStack; //temporary stack pointer
        
-	// gpreg:  [ret *], this, [gpr params]
-	// fpreg:  [fpr params]
-	// ovrflw: [gpr or fpr params (properly aligned)]
-	
 	// return
 	typelib_TypeDescription * pReturnTypeDescr = 0;
 	if (pReturnTypeRef)
@@ -119,19 +121,19 @@ static typelib_TypeClass cpp2uno_call(
 	
 	if ( pReturnTypeDescr )
 	{
-		if ( x86_64::returnInHiddenParam( pReturnTypeRef ) )
+		if ( x86_64::return_in_hidden_param( pReturnTypeRef ) )
 		{
-			pCppReturn = *(void **)gpreg;
-			gpreg++;
+			pCppReturn = *gpreg++;
 			nr_gpr++;
 			
-			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
-						  ? alloca( pReturnTypeDescr->nSize )
-						  : pCppReturn); // direct way
+			pUnoReturn = ( bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						   ? alloca( pReturnTypeDescr->nSize )
+						   : pCppReturn ); // direct way
 		}
 		else
 			pUnoReturn = pRegisterReturn; // direct way for simple types
 	}
+
 	// pop this
 	gpreg++; 
 	nr_gpr++;
@@ -145,7 +147,7 @@ static typelib_TypeClass cpp2uno_call(
 	// type descriptions for reconversions
 	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
 	
-	sal_Int32 nTempIndizes   = 0;
+	sal_Int32 nTempIndizes = 0;
 
 	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
 	{
@@ -153,59 +155,69 @@ static typelib_TypeClass cpp2uno_call(
 		typelib_TypeDescription * pParamTypeDescr = 0;
 		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
 
-		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) // value
+		int nUsedGPR = 0;
+		int nUsedSSE = 0;
+		bool bFitsRegisters = x86_64::examine_argument( rParam.pTypeRef, false, nUsedGPR, nUsedSSE );
+		if ( !rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ) ) // value
 		{
-			if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT
-				|| pParamTypeDescr->eTypeClass == typelib_TypeClass_DOUBLE)
+			// Simple types must fit exactly one register on x86_64
+			OSL_ASSERT( bFitsRegisters && ( ( nUsedSSE == 1 && nUsedGPR == 0 ) || ( nUsedSSE == 0 && nUsedGPR == 1 ) ) );
+
+			if ( nUsedSSE == 1 )
 			{
-			   if (nr_fpr < FPR_COUNT)
-			   {
-				   pCppArgs[nPos] = fpreg;
-				   pUnoArgs[nPos] = fpreg;
-				   nr_fpr++;
-				   fpreg++;
-			   }
-			   else
-			   {
-				   pCppArgs[nPos] = ovrflw;
-				   pUnoArgs[nPos] = ovrflw;
-				   ovrflw++;
-			   }
+				if ( nr_fpr < x86_64::MAX_SSE_REGS )
+				{
+					pCppArgs[nPos] = pUnoArgs[nPos] = fpreg++;
+					nr_fpr++;
+				}
+				else
+					pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw++;
 			}
-			else
+			else if ( nUsedGPR == 1 )
 			{
-				if (nr_gpr < GPR_COUNT)
+				if ( nr_gpr < x86_64::MAX_GPR_REGS )
 				{
-					pCppArgs[nPos] = gpreg;
-					pUnoArgs[nPos] = gpreg;
+					pCppArgs[nPos] = pUnoArgs[nPos] = gpreg++;
 					nr_gpr++;
-					gpreg++;
 				}
 				else
-				{
-					pCppArgs[nPos] = ovrflw;
-					pUnoArgs[nPos] = ovrflw;
-					ovrflw++;
-				}
+					pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw++;
 			}
+
 			// no longer needed
 			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 		}
-		else // ptr to complex value | ref
+		else // struct <= 16 bytes || ptr to complex value || ref
 		{
-			if (nr_gpr < GPR_COUNT)
+			void *pCppStack;
+			char pTmpStruct[16];
+
+			if ( bFitsRegisters && !rParam.bOut &&
+				 ( pParamTypeDescr->eTypeClass == typelib_TypeClass_STRUCT ||
+				   pParamTypeDescr->eTypeClass == typelib_TypeClass_EXCEPTION ) )
+			{
+				if ( ( nr_gpr + nUsedGPR <= x86_64::MAX_GPR_REGS ) && ( nr_fpr + nUsedSSE <= x86_64::MAX_SSE_REGS ) )
+				{
+					x86_64::fill_struct( rParam.pTypeRef, gpreg, fpreg, pTmpStruct );
+#if OSL_DEBUG_LEVEL > 1
+					fprintf( stderr, "nUsedGPR == %d, nUsedSSE == %d, pTmpStruct[0] == 0x%x, pTmpStruct[1] == 0x%x, **gpreg == 0x%lx\n",
+							nUsedGPR, nUsedSSE, pTmpStruct[0], pTmpStruct[1], *(sal_uInt64*)*gpreg );
+#endif
+
+					pCppArgs[nPos] = pCppStack = reinterpret_cast<void *>( pTmpStruct );
+					gpreg += nUsedGPR;
+					fpreg += nUsedSSE;
+				}
+				else
+					pCppArgs[nPos] = pCppStack = *ovrflw++;
+			}
+			else if ( nr_gpr < x86_64::MAX_GPR_REGS )
 			{ 
-				pCppArgs[nPos] = *(void **)gpreg;
-				pCppStack = gpreg;
+				pCppArgs[nPos] = pCppStack = *gpreg++;
 				nr_gpr++;
-				gpreg++;
 			}
 			else
-			{
-				pCppArgs[nPos] = *(void **)ovrflw;
-				pCppStack = ovrflw;
-				ovrflw++;
-			}
+				pCppArgs[nPos] = pCppStack = *ovrflw++;
 
 			if (! rParam.bIn) // is pure out
 			{
@@ -215,11 +227,10 @@ static typelib_TypeClass cpp2uno_call(
 				// will be released at reconversion
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
-			// is in/inout
-			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+			else if ( bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ) ) // is in/inout
 			{
 				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
-										*(void **)pCppStack, pParamTypeDescr,
+										pCppStack, pParamTypeDescr,
 										pThis->getBridge()->getCpp2Uno() );
 				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
 				// will be released at reconversion
@@ -227,7 +238,7 @@ static typelib_TypeClass cpp2uno_call(
 			}
 			else // direct way
 			{
-				pUnoArgs[nPos] = *(void **)pCppStack;
+				pUnoArgs[nPos] = pCppStack;
 				// no longer needed
 				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 			}
@@ -242,7 +253,7 @@ static typelib_TypeClass cpp2uno_call(
 	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
 	
 	// in case an exception occured...
-	if (pUnoExc)
+	if ( pUnoExc )
 	{
 		// destruct temporary in/inout params
 		for ( ; nTempIndizes--; )
@@ -268,7 +279,7 @@ static typelib_TypeClass cpp2uno_call(
 			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
 			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
 			
-			if (pParams[nIndex].bOut) // inout/out
+			if ( pParams[nIndex].bOut ) // inout/out
 			{
 				// convert and assign
 				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
@@ -281,9 +292,9 @@ static typelib_TypeClass cpp2uno_call(
 			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 		}
 		// return
-		if (pCppReturn) // has complex return
+		if ( pCppReturn ) // has complex return
 		{
-			if (pUnoReturn != pCppReturn) // needs reconversion
+			if ( pUnoReturn != pCppReturn ) // needs reconversion
 			{
 				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
 										pThis->getBridge()->getUno2Cpp() );
@@ -293,7 +304,7 @@ static typelib_TypeClass cpp2uno_call(
 			// complex return ptr is set to return reg
 			*(void **)pRegisterReturn = pCppReturn;
 		}
-		if (pReturnTypeDescr)
+		if ( pReturnTypeDescr )
 		{
 			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
 			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
@@ -345,14 +356,14 @@ extern "C" typelib_TypeClass cpp_vtable_
 	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
 
 	typelib_TypeClass eRet;
-	switch (aMemberDescr.get()->eTypeClass)
+	switch ( aMemberDescr.get()->eTypeClass )
 	{
 		case typelib_TypeClass_INTERFACE_ATTRIBUTE:
 		{
 			typelib_TypeDescriptionReference *pAttrTypeRef = 
 				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( aMemberDescr.get() )->pAttributeTypeRef;
 
-			if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+			if ( pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex )
 			{
 				// is GET method
 				eRet = cpp2uno_call( pCppI, aMemberDescr.get(), pAttrTypeRef,
@@ -400,7 +411,7 @@ extern "C" typelib_TypeClass cpp_vtable_
 							  pCppI->getOid().pData,
 							  reinterpret_cast<typelib_InterfaceTypeDescription *>( pTD ) );
 
-						if (pInterface)
+						if ( pInterface )
 						{
 							::uno_any_construct( reinterpret_cast<uno_Any *>( gpreg[0] ),
 												 &pInterface, pTD, cpp_acquire );
@@ -408,7 +419,7 @@ extern "C" typelib_TypeClass cpp_vtable_
 							pInterface->release();
 							TYPELIB_DANGER_RELEASE( pTD );
 
-							*(void **)pRegisterReturn = gpreg[0];
+							reinterpret_cast<void **>( pRegisterReturn )[0] = gpreg[0];
 							eRet = typelib_TypeClass_ANY;
 							break;
 						}
@@ -520,7 +531,7 @@ unsigned char * bridges::cpp_uno::shared
 			// get method
 			*slots++ = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
-								x86_64::returnInHiddenParam( pAttrTD->pAttributeTypeRef ) );
+								x86_64::return_in_hidden_param( pAttrTD->pAttributeTypeRef ) );
 
 			if ( ! pAttrTD->bReadOnly )
 			{
@@ -536,7 +547,7 @@ unsigned char * bridges::cpp_uno::shared
 			
 			*slots++ = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
-								x86_64::returnInHiddenParam( pMethodTD->pReturnTypeRef ) );
+								x86_64::return_in_hidden_param( pMethodTD->pReturnTypeRef ) );
 		}
 		else
 			OSL_ASSERT( false );
Files bridges.orig/source/cpp_uno/gcc3_linux_x86-64/.cpp2uno.cxx.swp and bridges/source/cpp_uno/gcc3_linux_x86-64/.cpp2uno.cxx.swp differ
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	2005-06-28 11:18:28.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	2005-06-28 19:11:13.000000000 +0200
@@ -279,40 +279,53 @@ static void callVirtualMethod(void * pTh
     asm("" ::
         "x" (d0), "x" (d1), "x" (d2), "x" (d3),
         "x" (d4), "x" (d5), "x" (d6), "x" (d7));
-    
+
     // Get pointer to method
     sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
     pMethod += 8 * nVtableIndex;
     pMethod = *((sal_uInt64 *)pMethod);
 
+	union ReturnValue {
+		struct {
+			sal_uInt64 rax;
+			sal_uInt64 rdx;
+		} i;
+		struct {
+			double xmm0;
+			double xmm1;
+		} f;
+	};
+
+	typedef ReturnValue (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
+
 	// Perform the call
-	sal_uInt64 nRet = ( (sal_uInt64 (*)(...) ) pMethod )(a0, a1, a2, a3, a4, a5);
-	
+	ReturnValue aRet = ( ( FunctionCall ) pMethod )( a0, a1, a2, a3, a4, a5 );
+
 	switch (eReturnType)
 	{
 	case typelib_TypeClass_HYPER:
 	case typelib_TypeClass_UNSIGNED_HYPER:
-		*reinterpret_cast<sal_uInt64 *>( pRegisterReturn ) = nRet;
+		*reinterpret_cast<sal_uInt64 *>( pRegisterReturn ) = aRet.i.rax;
 		break;
 	case typelib_TypeClass_LONG:
 	case typelib_TypeClass_UNSIGNED_LONG:
 	case typelib_TypeClass_ENUM:
-		*reinterpret_cast<sal_uInt32 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt32*>( &nRet );
+		*reinterpret_cast<sal_uInt32 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt32*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_CHAR:
 	case typelib_TypeClass_SHORT:
 	case typelib_TypeClass_UNSIGNED_SHORT:
-		*reinterpret_cast<sal_uInt16 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt16*>( &nRet );
+		*reinterpret_cast<sal_uInt16 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt16*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_BOOLEAN:
 	case typelib_TypeClass_BYTE:
-		*reinterpret_cast<sal_uInt8 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt8*>( &nRet );
+		*reinterpret_cast<sal_uInt8 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt8*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_FLOAT:
-		*reinterpret_cast<float *>( pRegisterReturn ) = *reinterpret_cast<float*>( &nRet );
+		*reinterpret_cast<float *>( pRegisterReturn ) = *reinterpret_cast<float*>( &aRet.f.xmm0 );
 		break;
 	case typelib_TypeClass_DOUBLE:
-		*reinterpret_cast<double *>( pRegisterReturn ) = *reinterpret_cast<double*>( &nRet );
+		*reinterpret_cast<double *>( pRegisterReturn ) = *reinterpret_cast<double*>( &aRet.f.xmm0 );
 		break;
 	}
 }
