--- tools/source/rc/resmgr.cxx	2004-12-10 15:37:46.000000000 +0100
+++ tools/source/rc/resmgr.cxx	2005-01-07 18:31:17.092148310 +0100
@@ -193,8 +193,8 @@ static List & GetResMgrList()
 
 struct ImpContent
 {
-    ULONG   nTypeAndId;
-    ULONG   nOffset;
+    sal_uInt32   nTypeAndId;
+    sal_uInt32   nOffset;
 };
 
 struct ImpContentLessCompare : public ::std::binary_function< ImpContent, ImpContent, bool>
@@ -205,13 +205,13 @@ struct ImpContentLessCompare : public ::
 	}
 };
 
-struct ImpContentMixLessCompare : public ::std::binary_function< ImpContent, ULONG, bool>
+struct ImpContentMixLessCompare : public ::std::binary_function< ImpContent, sal_uInt32, bool>
 {
-	inline bool operator() (const ImpContent& lhs, const ULONG& rhs) const 
+	inline bool operator() (const ImpContent& lhs, const sal_uInt32& rhs) const 
 	{
 		return lhs.nTypeAndId < rhs;
 	}
-	inline bool operator() (const ULONG& lhs, const ImpContent& rhs) const 
+	inline bool operator() (const sal_uInt32& lhs, const ImpContent& rhs) const 
 	{
 		return lhs < rhs.nTypeAndId;
 	}
@@ -246,9 +246,9 @@ struct ImpContentMixLessCompare : public
 //static int __LOADONCALLAPI Search( const void * nTypeAndId, const void * pSecond )
 //#endif
 //{
-//    if( (ULONG)nTypeAndId > (((ImpContent *)pSecond)->nTypeAndId) )
+//    if( (sal_uInt32)nTypeAndId > (((ImpContent *)pSecond)->nTypeAndId) )
 //        return( 1 );
-//    else if( (ULONG)nTypeAndId < (((ImpContent *)pSecond)->nTypeAndId) )
+//    else if( (sal_uInt32)nTypeAndId < (((ImpContent *)pSecond)->nTypeAndId) )
 //        return( -1 );
 //    else
 //        return( 0 );
@@ -269,15 +269,15 @@ SvStream * InternalResMgr::GetBitmapStre
     // Anfang der Strings suchen
 	ImpContent * pFind = ::std::lower_bound(pContent,
 											pContent + nEntries,
-											((ULONG(RT_SYS_BITMAP) << 16) | nId),
+											((sal_uInt32(RT_SYS_BITMAP) << 16) | nId),
 											ImpContentMixLessCompare());
-	if ( (pFind != (pContent + nEntries)) && (pFind->nTypeAndId == ((ULONG(RT_SYS_BITMAP) << 16) | nId)) )
+	if ( (pFind != (pContent + nEntries)) && (pFind->nTypeAndId == ((sal_uInt32(RT_SYS_BITMAP) << 16) | nId)) )
 	{
 		pStm->Seek( pFind->nOffset );
         return pStm;
 	}
 //    ImpContent * pFind = (ImpContent *)
-//        bsearch( (void *)((ULONG(RT_SYS_BITMAP) << 16) | nId), pContent, nEntries,
+//        bsearch( (void *)((sal_uInt32(RT_SYS_BITMAP) << 16) | nId), pContent, nEntries,
 //                sizeof( ImpContent ), Search );
 
 //    if ( pFind )
@@ -420,9 +420,9 @@ InternalResMgr::~InternalResMgr()
             aLine.Append( ByteString( aFileName, RTL_TEXTENCODING_UTF8 ) );
             aStm.WriteLine( aLine );
 
-            for( ULONG i = 0; i < pResUseDump->Count(); ++i )
+            for( sal_uInt32 i = 0; i < pResUseDump->Count(); ++i )
             {
-                ULONG nKeyId = pResUseDump->GetObjectKey( i );
+                sal_uInt32 nKeyId = pResUseDump->GetObjectKey( i );
                 aLine.Assign( "Type/Id: " );
                 aLine.Append( ByteString::CreateFromInt32( (nKeyId >> 16) & 0xFFFF ) );
                 aLine.Append( '/' );
@@ -489,15 +489,15 @@ BOOL InternalResMgr::Create()
             if ( pLogFile )
             {
                 pResUseDump = new Table();
-                for( ULONG i = 0; i < nEntries; ++i )
+                for( sal_uInt32 i = 0; i < nEntries; ++i )
                     pResUseDump->Insert( pContent[i].nTypeAndId, NULL );
             }
 #endif
             // swap the content to the right endian
             pContent[0].nTypeAndId = ResMgr::GetLong( &pContent[0].nTypeAndId );
             pContent[0].nOffset = ResMgr::GetLong( &pContent[0].nOffset );
-			ULONG nCount = nEntries - 1;
-            for( ULONG i = 0,j=1; i < nCount; ++i,++j )
+			sal_uInt32 nCount = nEntries - 1;
+            for( sal_uInt32 i = 0,j=1; i < nCount; ++i,++j )
             {
                 // swap the content to the right endian
                 pContent[j].nTypeAndId = ResMgr::GetLong( &pContent[j].nTypeAndId );
@@ -582,13 +582,13 @@ void InternalResMgr::FreeInternalResMgr(
 BOOL InternalResMgr::IsGlobalAvailable( RESOURCE_TYPE nRT, USHORT nId ) const
 {
     // Anfang der Strings suchen
-	ULONG nValue = ((ULONG(nRT) << 16) | nId);
+	sal_uInt32 nValue = ((sal_uInt32(nRT) << 16) | nId);
 	ImpContent * pFind = ::std::lower_bound(pContent,
 											pContent + nEntries,
 											nValue,
 											ImpContentMixLessCompare());
 //    ImpContent * pFind = (ImpContent *)
-//        bsearch( (void *)((ULONG(nRT) << 16) | nId), pContent, nEntries,
+//        bsearch( (void *)((sal_uInt32(nRT) << 16) | nId), pContent, nEntries,
 //                sizeof( ImpContent ), Search );
     return (pFind != (pContent + nEntries)) && (pFind->nTypeAndId == nValue);
 }
@@ -600,17 +600,17 @@ void* InternalResMgr::LoadGlobalRes( RES
 {
 #ifdef DBG_UTIL
     if( pResUseDump )
-        pResUseDump->Remove( (ULONG(nRT) << 16) | nId );
+        pResUseDump->Remove( (sal_uInt32(nRT) << 16) | nId );
 #endif
     // Anfang der Strings suchen
-	ULONG nValue = ((ULONG(nRT) << 16) | nId);
+	sal_uInt32 nValue = ((sal_uInt32(nRT) << 16) | nId);
 	ImpContent* pEnd = (pContent + nEntries);
 	ImpContent* pFind = ::std::lower_bound(	pContent,
 											pEnd,
 											nValue,
 											ImpContentMixLessCompare());
 //    ImpContent * pFind = (ImpContent *)
-//        bsearch( (void *)((ULONG(nRT) << 16) | nId), pContent, nEntries,
+//        bsearch( (void *)((sal_uInt32(nRT) << 16) | nId), pContent, nEntries,
 //                sizeof( ImpContent ), Search );
     if( pFind && (pFind != pEnd) && (pFind->nTypeAndId == nValue) )
 	{
