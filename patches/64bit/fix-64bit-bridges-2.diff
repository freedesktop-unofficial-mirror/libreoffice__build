diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.cxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx	2005-05-31 15:41:10.000000000 +0200
@@ -0,0 +1,808 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Novell, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@suse.cz>
+ *
+ *
+ ************************************************************************/
+
+// This is an implementation of the x86-64 ABI as described in System V
+// Application Binary Interface, AMD64 Architecture Processor Supplement
+// (http://www.x86-64.org/documentation/abi-0.95.pdf)
+//
+// The code in this file is a modification of src/x86/ffi64.c from libffi
+// (http://sources.redhat.com/libffi/) which is under the following license:
+
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2002  Bo Thorsen <bo@suse.de>
+   
+   x86-64 Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <typelib/typedescription.hxx>
+#include <rtl/ustring.hxx>
+
+namespace x86_64
+{
+
+#define MAX_GPR_REGS 6
+#define MAX_SSE_REGS 8
+
+typedef struct
+{
+    /* Registers for argument passing.  */
+    long gpr[MAX_GPR_REGS];
+    __int128_t sse[MAX_SSE_REGS];
+
+    /* Stack space for arguments.  */
+    char argspace[0];
+} stackLayout;
+
+/* Register class used for passing given 64bit part of the argument.
+   These represent classes as documented by the PS ABI, with the exception
+   of SSESF, SSEDF classes, that are basically SSE class, just gcc will
+   use SF or DFmode move instead of DImode to avoid reformating penalties.
+
+   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
+   whenever possible (upper half does contain padding).
+ */
+enum x86_64_reg_class
+{
+    X86_64_NO_CLASS,
+    X86_64_INTEGER_CLASS,
+    X86_64_INTEGERSI_CLASS,
+    X86_64_SSE_CLASS,
+    X86_64_SSESF_CLASS,
+    X86_64_SSEDF_CLASS,
+    X86_64_SSEUP_CLASS,
+    X86_64_X87_CLASS,
+    X86_64_X87UP_CLASS,
+    X86_64_MEMORY_CLASS
+};
+
+#define MAX_CLASSES 4
+
+#define ALIGN(v, a) (((((size_t) (v))-1) | ((a)-1))+1)
+
+/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal
+   of this code is to classify each 8bytes of incoming argument by the register
+   class and assign registers accordingly.  */
+
+/* Return the union class of CLASS1 and CLASS2.
+   See the x86-64 PS ABI for details.  */
+
+static enum x86_64_reg_class
+merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)
+{
+    /* Rule #1: If both classes are equal, this is the resulting class.  */
+    if (class1 == class2)
+        return class1;
+
+    /* Rule #2: If one of the classes is NO_CLASS, the resulting class is
+       the other class.  */
+    if (class1 == X86_64_NO_CLASS)
+        return class2;
+    if (class2 == X86_64_NO_CLASS)
+        return class1;
+
+    /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
+    if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)
+        return X86_64_MEMORY_CLASS;
+
+    /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
+    if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)
+            || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))
+        return X86_64_INTEGERSI_CLASS;
+    if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS
+            || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)
+        return X86_64_INTEGER_CLASS;
+
+    /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
+    if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS
+            || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)
+        return X86_64_MEMORY_CLASS;
+
+    /* Rule #6: Otherwise class SSE is used.  */
+    return X86_64_SSE_CLASS;
+}
+
+/* Classify the argument of type TYPE and mode MODE.
+   CLASSES will be filled by the register class used to pass each word
+   of the operand.  The number of words is returned.  In case the parameter
+   should be passed in memory, 0 is returned. As a special case for zero
+   sized containers, classes[0] will be NO_CLASS and 1 is returned.
+
+   See the x86-64 PS ABI for details.
+*/
+static int
+classify_argument( typelib_TypeDescriptionReference *pTypeRef, enum x86_64_reg_class classes[], int &rByteOffset )
+{
+    /* First, align to the right place.  */
+    rByteOffset = ALIGN( rByteOffset, pTypeRef->pType->nAlignment );
+
+    switch ( pTypeRef->eTypeClass )
+    {
+        case typelib_TypeClass_VOID:
+            classes[0] = X86_64_NO_CLASS;
+            return 1;
+        case typelib_TypeClass_CHAR:
+        case typelib_TypeClass_BOOLEAN:
+        case typelib_TypeClass_BYTE:
+        case typelib_TypeClass_SHORT:
+        case typelib_TypeClass_UNSIGNED_SHORT:
+        case typelib_TypeClass_LONG:
+        case typelib_TypeClass_UNSIGNED_LONG:
+        case typelib_TypeClass_HYPER:
+        case typelib_TypeClass_UNSIGNED_HYPER:
+        case typelib_TypeClass_ENUM:
+            if ( ( rByteOffset % 8 + pTypeRef->pType->nSize ) <= 4 )
+                classes[0] = X86_64_INTEGERSI_CLASS;
+            else
+                classes[0] = X86_64_INTEGER_CLASS;
+            return 1;
+        case typelib_TypeClass_FLOAT:
+            if ( ( rByteOffset % 8 ) == 0 )
+                classes[0] = X86_64_SSESF_CLASS;
+            else
+                classes[0] = X86_64_SSE_CLASS;
+            return 1;
+        case typelib_TypeClass_DOUBLE:
+            classes[0] = X86_64_SSEDF_CLASS;
+            return 1;
+        /*case LONGDOUBLE:
+            classes[0] = X86_64_X87_CLASS;
+            classes[1] = X86_64_X87UP_CLASS;
+            return 2;*/
+        case typelib_TypeClass_STRING:
+        case typelib_TypeClass_TYPE:
+        case typelib_TypeClass_ANY:
+        case typelib_TypeClass_TYPEDEF:
+        case typelib_TypeClass_UNION:
+        case typelib_TypeClass_SEQUENCE:
+        case typelib_TypeClass_ARRAY:
+        case typelib_TypeClass_INTERFACE:
+            return 0;
+        case typelib_TypeClass_STRUCT:
+        case typelib_TypeClass_EXCEPTION:
+            {
+                if ( !pTypeRef->pType->bComplete )
+                    typelib_typedescription_complete( &(pTypeRef->pType) );
+
+                const int UNITS_PER_WORD = 8;
+                int words = ( pTypeRef->pType->nSize + UNITS_PER_WORD - 1 ) / UNITS_PER_WORD;
+                enum x86_64_reg_class subclasses[MAX_CLASSES];
+
+                /* If the struct is larger than 16 bytes, pass it on the stack.  */
+                if ( pTypeRef->pType->nSize > 16 )
+                    return 0;
+
+                for ( int i = 0; i < words; i++ )
+                    classes[i] = X86_64_NO_CLASS;
+
+                const typelib_CompoundTypeDescription *pStruct = reinterpret_cast<const typelib_CompoundTypeDescription*>( pTypeRef->pType );
+
+                /* Merge the fields of structure.  */
+                for ( sal_Int32 nMember = 0; nMember < pStruct->nMembers; ++nMember )
+                {
+                    typelib_TypeDescriptionReference *pTypeInStruct = pStruct->ppTypeRefs[ nMember ];
+
+                    int num = classify_argument( pTypeInStruct, subclasses, rByteOffset );
+
+                    if ( num == 0 )
+                        return 0;
+
+                    for ( int i = 0; i < num; i++ )
+                    {
+                        int pos = rByteOffset / 8;
+                        classes[i + pos] = merge_classes( subclasses[i], classes[i + pos] );
+                    }
+
+                    if ( pTypeInStruct->eTypeClass != typelib_TypeClass_STRUCT )
+                        rByteOffset = pStruct->pMemberOffsets[ nMember ];
+                }
+
+                /* Final merger cleanup.  */
+                for ( int i = 0; i < words; i++ )
+                {
+                    /* If one class is MEMORY, everything should be passed in
+                       memory.  */
+                    if ( classes[i] == X86_64_MEMORY_CLASS )
+                        return 0;
+
+                    /* The X86_64_SSEUP_CLASS should be always preceded by
+                       X86_64_SSE_CLASS.  */
+                    if ( classes[i] == X86_64_SSEUP_CLASS
+                            && ( i == 0 || classes[i - 1] != X86_64_SSE_CLASS ) )
+                        classes[i] = X86_64_SSE_CLASS;
+
+                    /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */
+                    if ( classes[i] == X86_64_X87UP_CLASS
+                            && ( i == 0 || classes[i - 1] != X86_64_X87_CLASS ) )
+                        classes[i] = X86_64_SSE_CLASS;
+                }
+                return words;
+            }
+
+        default:
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "Unhandled case: pType->eTypeClass == %d\n", pTypeRef->eTypeClass );
+#endif
+            OSL_ASSERT(0);
+    }
+    return 0; /* Never reached.  */
+}
+
+#if 0
+/* Examine the argument and return set number of register required in each
+   class.  Return 0 iff parameter should be passed in memory.  */
+static int
+examine_argument( const pTypelib_TypeDescription *pType, int in_return, int *int_nregs, int *sse_nregs )
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int offset = 0;
+    int n;
+
+    n = classify_argument( pType, classes, &offset );
+
+    if (n == 0)
+        return 0;
+
+    *int_nregs = 0;
+    *sse_nregs = 0;
+    for (n--; n>=0; n--)
+        switch (classes[n])
+        {
+            case X86_64_INTEGER_CLASS:
+            case X86_64_INTEGERSI_CLASS:
+                (*int_nregs)++;
+                break;
+            case X86_64_SSE_CLASS:
+            case X86_64_SSESF_CLASS:
+            case X86_64_SSEDF_CLASS:
+                (*sse_nregs)++;
+                break;
+            case X86_64_NO_CLASS:
+            case X86_64_SSEUP_CLASS:
+                break;
+            case X86_64_X87_CLASS:
+            case X86_64_X87UP_CLASS:
+                if (!in_return)
+                    return 0;
+                break;
+            default:
+                abort ();
+        }
+    return 1;
+}
+#endif
+
+bool returnInHiddenParam( typelib_TypeDescriptionReference *pTypeRef )
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int i = 0;
+
+    return classify_argument( pTypeRef, classes, i ) == 0;
+}
+
+#if 0
+
+/* Functions to load floats and double to an SSE register placeholder.  */
+extern void float2sse (float, __int128_t *);
+extern void double2sse (double, __int128_t *);
+extern void floatfloat2sse (void *, __int128_t *);
+
+/* Functions to put the floats and doubles back.  */
+extern float sse2float (__int128_t *);
+extern double sse2double (__int128_t *);
+extern void sse2floatfloat(__int128_t *, void *);
+
+/*@-exportheader@*/
+void
+ffi_prep_args (stackLayout *stack, extended_cif *ecif)
+/*@=exportheader@*/
+{
+  int gprcount, ssecount, i, g, s;
+  void **p_argv;
+  void *argp = &stack->argspace;
+  ffi_type **p_arg;
+
+  /* First check if the return value should be passed in memory. If so,
+     pass the pointer as the first argument.  */
+  gprcount = ssecount = 0;
+  if (ecif->cif->rtype->type != FFI_TYPE_VOID 
+      && examine_argument (ecif->cif->rtype, 1, &g, &s) == 0)
+    (void *)stack->gpr[gprcount++] = ecif->rvalue;
+
+  for (i=ecif->cif->nargs, p_arg=ecif->cif->arg_types, p_argv = ecif->avalue;
+       i!=0; i--, p_arg++, p_argv++)
+    {
+      int in_register = 0;
+
+      switch ((*p_arg)->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  if (gprcount < MAX_GPR_REGS)
+	    {
+	      stack->gpr[gprcount] = 0;
+	      stack->gpr[gprcount++] = *(long long *)(*p_argv);
+	      in_register = 1;
+	    }
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  if (ssecount < MAX_SSE_REGS)
+	    {
+	      float2sse (*(float *)(*p_argv), &stack->sse[ssecount++]);
+	      in_register = 1;
+	    }
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (ssecount < MAX_SSE_REGS)
+	    {
+	      double2sse (*(double *)(*p_argv), &stack->sse[ssecount++]);
+	      in_register = 1;
+	    }
+	  break;
+	}
+
+      if (in_register)
+	continue;
+
+      /* Either all places in registers where filled, or this is a
+	 type that potentially goes into a memory slot.  */
+      if (examine_argument (*p_arg, 0, &g, &s) == 0
+	  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)
+	{
+	  /* Pass this argument in memory.  */
+	  argp = (void *)ALIGN(argp, (*p_arg)->alignment);
+	  memcpy (argp, *p_argv, (*p_arg)->size);
+	  argp += (*p_arg)->size;
+	}
+      else
+	{
+	  /* All easy cases are eliminated. Now fire the big guns.  */
+
+	  enum x86_64_reg_class classes[MAX_CLASSES];
+	  int offset = 0, j, num;
+	  void *a;
+
+	  num = classify_argument (*p_arg, classes, &offset);
+	  for (j=0, a=*p_argv; j<num; j++, a+=8)
+	    {
+	      switch (classes[j])
+		{
+		case X86_64_INTEGER_CLASS:
+		case X86_64_INTEGERSI_CLASS:
+		  stack->gpr[gprcount++] = *(long long *)a;
+		  break;
+		case X86_64_SSE_CLASS:
+		  floatfloat2sse (a, &stack->sse[ssecount++]);
+		  break;
+		case X86_64_SSESF_CLASS:
+		  float2sse (*(float *)a, &stack->sse[ssecount++]);
+		  break;
+		case X86_64_SSEDF_CLASS:
+		  double2sse (*(double *)a, &stack->sse[ssecount++]);
+		  break;
+		default:
+		  abort();
+		}
+	    }
+	}
+    }
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  int gprcount, ssecount, i, g, s;
+
+  gprcount = ssecount = 0;
+
+  /* Reset the byte count. We handle this size estimation here.  */
+  cif->bytes = 0;
+
+  /* If the return value should be passed in memory, pass the pointer
+     as the first argument. The actual memory isn't allocated here.  */
+  if (cif->rtype->type != FFI_TYPE_VOID 
+      && examine_argument (cif->rtype, 1, &g, &s) == 0)
+    gprcount = 1;
+
+  /* Go over all arguments and determine the way they should be passed.
+     If it's in a register and there is space for it, let that be so. If
+     not, add it's size to the stack byte count.  */
+  for (i=0; i<cif->nargs; i++)
+    {
+      if (examine_argument (cif->arg_types[i], 0, &g, &s) == 0
+	  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)
+	{
+	  /* This is passed in memory. First align to the basic type.  */
+	  cif->bytes = ALIGN(cif->bytes, cif->arg_types[i]->alignment);
+
+	  /* Stack arguments are *always* at least 8 byte aligned.  */
+	  cif->bytes = ALIGN(cif->bytes, 8);
+
+	  /* Now add the size of this argument.  */
+	  cif->bytes += cif->arg_types[i]->size;
+	}
+      else
+	{
+	  gprcount += g;
+	  ssecount += s;
+	}
+    }
+
+  /* Set the flag for the closures return.  */
+    switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_LONGDOUBLE:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_UINT64:
+      cif->flags = FFI_TYPE_SINT64;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+typedef struct
+{
+  long gpr[2];
+  __int128_t sse[2];
+  long double st0;
+} return_value;
+
+//#endif
+
+void
+ffi_fill_return_value (return_value *rv, extended_cif *ecif)
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int i = 0, num;
+    long *gpr = rv->gpr;
+    __int128_t *sse = rv->sse;
+    signed char sc;
+    signed short ss;
+
+    /* This is needed because of the way x86-64 handles signed short
+       integers.  */
+    switch (ecif->cif->rtype->type)
+    {
+        case FFI_TYPE_SINT8:
+            sc = *(signed char *)gpr;
+            *(long long *)ecif->rvalue = (long long)sc;
+            return;
+        case FFI_TYPE_SINT16:
+            ss = *(signed short *)gpr;
+            *(long long *)ecif->rvalue = (long long)ss;
+            return;
+        default:
+            /* Just continue.  */
+            ;
+    }
+
+    num = classify_argument (ecif->cif->rtype, classes, &i);
+
+    if (num == 0)
+        /* Return in memory.  */
+        ecif->rvalue = (void *) rv->gpr[0];
+    else if (num == 2 && classes[0] == X86_64_X87_CLASS &&
+            classes[1] == X86_64_X87UP_CLASS)
+        /* This is a long double (this is easiest to handle this way instead
+           of an eightbyte at a time as in the loop below.  */
+        *((long double *)ecif->rvalue) = rv->st0;
+    else
+    {
+        void *a;
+
+        for (i=0, a=ecif->rvalue; i<num; i++, a+=8)
+        {
+            switch (classes[i])
+            {
+                case X86_64_INTEGER_CLASS:
+                case X86_64_INTEGERSI_CLASS:
+                    *(long long *)a = *gpr;
+                    gpr++;
+                    break;
+                case X86_64_SSE_CLASS:
+                    sse2floatfloat (sse++, a);
+                    break;
+                case X86_64_SSESF_CLASS:
+                    *(float *)a = sse2float (sse++);
+                    break;
+                case X86_64_SSEDF_CLASS:
+                    *(double *)a = sse2double (sse++);
+                    break;
+                default:
+                    abort();
+            }
+        }
+    }
+}
+
+//#if 0
+
+/*@-declundef@*/
+/*@-exportheader@*/
+extern void ffi_call_UNIX64(void (*)(stackLayout *, extended_cif *),
+			    void (*) (return_value *, extended_cif *),
+			    /*@out@*/ extended_cif *, 
+			    unsigned, /*@out@*/ unsigned *, void (*fn)());
+/*@=declundef@*/
+/*@=exportheader@*/
+
+void ffi_call(/*@dependent@*/ ffi_cif *cif, 
+	      void (*fn)(), 
+	      /*@out@*/ void *rvalue, 
+	      /*@dependent@*/ void **avalue)
+{
+  extended_cif ecif;
+  int dummy;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if ((rvalue == NULL) && 
+      (examine_argument (cif->rtype, 1, &dummy, &dummy) == 0))
+    {
+      /*@-sysunrecog@*/
+      ecif.rvalue = alloca(cif->rtype->size);
+      /*@=sysunrecog@*/
+    }
+  else
+    ecif.rvalue = rvalue;
+    
+  /* Stack must always be 16byte aligned. Make it so.  */
+  cif->bytes = ALIGN(cif->bytes, 16);
+  
+  switch (cif->abi) 
+    {
+    case FFI_SYSV:
+      /* Calling 32bit code from 64bit is not possible  */
+      FFI_ASSERT(0);
+      break;
+
+    case FFI_UNIX64:
+      /*@-usedef@*/
+      ffi_call_UNIX64 (ffi_prep_args, ffi_fill_return_value, &ecif,
+		       cif->bytes, ecif.rvalue, fn);
+      /*@=usedef@*/
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+extern void ffi_closure_UNIX64(void);
+
+ffi_status
+ffi_prep_closure (ffi_closure* closure,
+		  ffi_cif* cif,
+		  void (*fun)(ffi_cif*, void*, void**, void*),
+		  void *user_data)
+{
+  volatile unsigned short *tramp;
+
+  /* FFI_ASSERT (cif->abi == FFI_OSF);  */
+
+  tramp = (volatile unsigned short *) &closure->tramp[0];
+  tramp[0] = 0xbb49;		/* mov <code>, %r11	*/
+  tramp[5] = 0xba49;		/* mov <data>, %r10	*/
+  tramp[10] = 0xff49;		/* jmp *%r11	*/
+  tramp[11] = 0x00e3;
+  *(void * volatile *) &tramp[1] = ffi_closure_UNIX64;
+  *(void * volatile *) &tramp[6] = closure;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+int
+ffi_closure_UNIX64_inner(ffi_closure *closure, va_list l, void *rp)
+{
+  ffi_cif *cif;
+  void **avalue;
+  ffi_type **arg_types;
+  long i, avn, argn;
+
+  cif = closure->cif;
+  avalue = alloca(cif->nargs * sizeof(void *));
+
+  argn = 0;
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+  
+  /* Grab the addresses of the arguments from the stack frame.  */
+  while (i < avn)
+    {
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  {
+	    if (l->gp_offset > 48-8)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->gp_offset;
+		l->gp_offset += 8;
+	      }
+	  }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  /* FIXME  */
+	  FFI_ASSERT(0);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  {
+	    if (l->fp_offset > 176-16)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->fp_offset;
+		l->fp_offset += 16;
+	      }
+	  }
+#if DEBUG_FFI
+	  fprintf (stderr, "double arg %d = %g\n", i, *(double *)avalue[i]);
+#endif
+	  break;
+	  
+	case FFI_TYPE_FLOAT:
+	  {
+	    if (l->fp_offset > 176-16)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->fp_offset;
+		l->fp_offset += 16;
+	      }
+	  }
+#if DEBUG_FFI
+	  fprintf (stderr, "float arg %d = %g\n", i, *(float *)avalue[i]);
+#endif
+	  break;
+	  
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      argn += ALIGN(arg_types[i]->size, SIZEOF_ARG) / SIZEOF_ARG;
+      i++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rp, avalue, closure->user_data);
+
+  /* FIXME: Structs not supported.  */
+  FFI_ASSERT(cif->rtype->type != FFI_TYPE_STRUCT);
+
+  /* Tell ffi_closure_UNIX64 how to perform return type promotions.  */
+
+  return cif->rtype->type;
+}
+
+#endif
+
+} // namespace x86_64
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.hxx bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/abi.hxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx	2005-05-31 14:51:03.000000000 +0200
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Novell, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@suse.cz>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
+#define _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
+
+// This is an implementation of the x86-64 ABI as described in System V
+// Application Binary Interface, AMD64 Architecture Processor Supplement
+// (http://www.x86-64.org/documentation/abi-0.95.pdf)
+
+namespace x86_64
+{
+
+/** Does a function that returns this type use a hidden parameter or registers?
+
+ The value can be returned either in a hidden 1st parameter (which is a
+ pointer to a structure allocated by the caller), or in registers (rax, rdx
+ for the integers, xmm0, xmm1 for the floating point numbers).
+*/
+bool returnInHiddenParam( typelib_TypeDescriptionReference *pTypeRef );
+
+} // namespace x86_64
+
+#endif // _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/call.s bridges/source/cpp_uno/gcc3_linux_x86-64/call.s
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/call.s	2005-05-20 18:25:52.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/call.s	2005-05-31 15:09:58.000000000 +0200
@@ -10,7 +10,7 @@ privateSnippetExecutor:
 .LCFI1:
 	subq	$160, %rsp
 .LCFI2:
-	movq	%r11, -152(%rbp)		# Save (nVtableOffset << 32) + nFunctionIndex
+	movq	%r10, -152(%rbp)		# Save (nVtableOffset << 32) + nFunctionIndex
 
 	movq	%rdi, -112(%rbp)		# Save GP registers
 	movq	%rsi, -104(%rbp)
@@ -37,9 +37,9 @@ privateSnippetExecutor:
 	
 	call	cpp_vtable_call
 
-	cmp	$10, %rax			# typelib_TypeClass_FLOAT
+	cmp	$10, %rax					# typelib_TypeClass_FLOAT
 	je	.Lfloat
-	cmp	$11, %rax			# typelib_TypeClass_DOUBLE
+	cmp	$11, %rax					# typelib_TypeClass_DOUBLE
 	je	.Lfloat
 
 	movq	-144(%rbp), %rax		# Return value (int case)
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	2005-05-20 18:25:52.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	2005-06-03 11:33:00.000000000 +0200
@@ -76,6 +76,7 @@
 #include "bridges/cpp_uno/shared/types.hxx"
 #include "bridges/cpp_uno/shared/vtablefactory.hxx"
 
+#include "abi.hxx"
 #include "share.hxx"
 
 using namespace ::osl;
@@ -116,13 +117,9 @@ static typelib_TypeClass cpp2uno_call(
 	void * pUnoReturn = 0;
 	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
 	
-	if (pReturnTypeDescr)
+	if ( pReturnTypeDescr )
 	{
-		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
-		{
-			pUnoReturn = pRegisterReturn; // direct way for simple types
-		}
-		else // complex return via ptr (pCppReturn)
+		if ( x86_64::returnInHiddenParam( pReturnTypeRef ) )
 		{
 			pCppReturn = *(void **)gpreg;
 			gpreg++;
@@ -132,6 +129,8 @@ static typelib_TypeClass cpp2uno_call(
 						  ? alloca( pReturnTypeDescr->nSize )
 						  : pCppReturn); // direct way
 		}
+		else
+			pUnoReturn = pRegisterReturn; // direct way for simple types
 	}
 	// pop this
 	gpreg++; 
@@ -322,9 +321,10 @@ extern "C" typelib_TypeClass cpp_vtable_
 		pThis = gpreg[1];
 	}
 	else
+	{
 		pThis = gpreg[0];
-    
-	pThis = static_cast< char * >( pThis ) - nVtableOffset;
+	}
+	pThis = static_cast<char *>( pThis ) - nVtableOffset;
 
 	bridges::cpp_uno::shared::CppInterfaceProxy * pCppI =
 		bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy( pThis );
@@ -332,107 +332,110 @@ extern "C" typelib_TypeClass cpp_vtable_
 	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
 
 	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
-	if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	if ( nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex )
 	{
-		throw RuntimeException(
-            OUString::createFromAscii("illegal vtable index!"),
-            (XInterface *)pCppI );
+		throw RuntimeException( OUString::createFromAscii("illegal vtable index!"),
+								reinterpret_cast<XInterface *>( pCppI ) );
 	}
-	
+
 	// determine called method
-	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
 	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
 	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!\n" );
 
 	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
-    
+
 	typelib_TypeClass eRet;
 	switch (aMemberDescr.get()->eTypeClass)
 	{
-	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
-	{
-		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+		case typelib_TypeClass_INTERFACE_ATTRIBUTE:
 		{
-			// is GET method
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
-				0, 0, // no params
-				gpreg, fpreg, ovrflw, pRegisterReturn );
+			typelib_TypeDescriptionReference *pAttrTypeRef = 
+				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( aMemberDescr.get() )->pAttributeTypeRef;
+
+			if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+			{
+				// is GET method
+				eRet = cpp2uno_call( pCppI, aMemberDescr.get(), pAttrTypeRef,
+						0, 0, // no params
+						gpreg, fpreg, ovrflw, pRegisterReturn );
+			}
+			else
+			{
+				// is SET method
+				typelib_MethodParameter aParam;
+				aParam.pTypeRef = pAttrTypeRef;
+				aParam.bIn		= sal_True;
+				aParam.bOut		= sal_False;
+
+				eRet = cpp2uno_call( pCppI, aMemberDescr.get(),
+						0, // indicates void return
+						1, &aParam,
+						gpreg, fpreg, ovrflw, pRegisterReturn );
+			}
+			break;
 		}
-		else
+		case typelib_TypeClass_INTERFACE_METHOD:
 		{
-			// is SET method
-			typelib_MethodParameter aParam;
-			aParam.pTypeRef =
-				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
-			aParam.bIn		= sal_True;
-			aParam.bOut		= sal_False;
-			
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				0, // indicates void return
-				1, &aParam,
-				gpreg, fpreg, ovrflw, pRegisterReturn );
+			// is METHOD
+			switch ( nFunctionIndex )
+			{
+				case 1: // acquire()
+					pCppI->acquireProxy(); // non virtual call!
+					eRet = typelib_TypeClass_VOID;
+					break;
+				case 2: // release()
+					pCppI->releaseProxy(); // non virtual call!
+					eRet = typelib_TypeClass_VOID;
+					break;
+				case 0: // queryInterface() opt
+				{
+					typelib_TypeDescription * pTD = 0;
+					TYPELIB_DANGER_GET( &pTD, reinterpret_cast<Type *>( gpreg[2] )->getTypeLibType() );
+					if ( pTD )
+					{
+						XInterface * pInterface = 0;
+						(*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)
+							( pCppI->getBridge()->getCppEnv(),
+							  (void **)&pInterface,
+							  pCppI->getOid().pData,
+							  reinterpret_cast<typelib_InterfaceTypeDescription *>( pTD ) );
+
+						if (pInterface)
+						{
+							::uno_any_construct( reinterpret_cast<uno_Any *>( gpreg[0] ),
+												 &pInterface, pTD, cpp_acquire );
+
+							pInterface->release();
+							TYPELIB_DANGER_RELEASE( pTD );
+
+							*(void **)pRegisterReturn = gpreg[0];
+							eRet = typelib_TypeClass_ANY;
+							break;
+						}
+						TYPELIB_DANGER_RELEASE( pTD );
+					}
+				} // else perform queryInterface()
+				default:
+				{
+					typelib_InterfaceMethodTypeDescription *pMethodTD =
+						reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( aMemberDescr.get() );
+
+					eRet = cpp2uno_call( pCppI, aMemberDescr.get(),
+										 pMethodTD->pReturnTypeRef,
+										 pMethodTD->nParams,
+										 pMethodTD->pParams,
+										 gpreg, fpreg, ovrflw, pRegisterReturn );
+				}
+			}
+			break;
 		}
-		break;
-	}
-	case typelib_TypeClass_INTERFACE_METHOD:
-	{
-		// is METHOD
-		switch (nFunctionIndex)
+		default:
 		{
-		case 1: // acquire()
-			pCppI->acquireProxy(); // non virtual call!
+			throw RuntimeException( OUString::createFromAscii("no member description found!"),
+									reinterpret_cast<XInterface *>( pCppI ) );
+			// is here for dummy
 			eRet = typelib_TypeClass_VOID;
-			break;
-		case 2: // release()
-			pCppI->releaseProxy(); // non virtual call!
-			eRet = typelib_TypeClass_VOID;
-			break;
-		case 0: // queryInterface() opt
-		{
-			typelib_TypeDescription * pTD = 0;
-			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
-			if (pTD)
-			{
-                XInterface * pInterface = 0;
-                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
-                    pCppI->getBridge()->getCppEnv(),
-                    (void **)&pInterface, pCppI->getOid().pData, (typelib_InterfaceTypeDescription *)pTD );
-			
-                if (pInterface)
-                {
-                    ::uno_any_construct(
-                        reinterpret_cast< uno_Any * >( gpreg[0] ),
-                        &pInterface, pTD, cpp_acquire );
-                    pInterface->release();
-                    TYPELIB_DANGER_RELEASE( pTD );
-                    *(void **)pRegisterReturn = gpreg[0];
-                    eRet = typelib_TypeClass_ANY;
-                    break;
-                }
-                TYPELIB_DANGER_RELEASE( pTD );
-            }
-		} // else perform queryInterface()
-		default:
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
-				gpreg, fpreg, ovrflw, pRegisterReturn );
 		}
-		break;
-	}
-	default:
-	{
-		throw RuntimeException(
-            OUString::createFromAscii("no member description found!"),
-            (XInterface *)pCppI );
-		// is here for dummy
-		eRet = typelib_TypeClass_VOID;
-	}
 	}
 
 	return eRet;
@@ -441,9 +444,10 @@ extern "C" typelib_TypeClass cpp_vtable_
 //==================================================================================================
 extern "C" void privateSnippetExecutor( ... );
 
-const int codeSnippetSize = 23;
+const int codeSnippetSize = 24;
 
-// Generate a piece of code that jumps to privateSnippetExecutor().
+// Generate a trampoline that redirects method calls to
+// privateSnippetExecutor().
 //
 // privateSnippetExecutor() saves all the registers that are used for
 // parameter passing on x86_64, and calls the cpp_vtable_call().
@@ -454,33 +458,23 @@ const int codeSnippetSize = 23;
 // unwinding info.
 unsigned char * codeSnippet( unsigned char * code,
         sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
-        bool simple_ret_type ) SAL_THROW( () )
+        bool bHasHiddenParam ) SAL_THROW( () )
 {
 	sal_uInt64 nOffsetAndIndex = ( ( (sal_uInt64) nVtableOffset ) << 32 ) | ( (sal_uInt64) nFunctionIndex );
 
-	if ( ! simple_ret_type )
+	if ( bHasHiddenParam )
 		nOffsetAndIndex |= 0x80000000;
 
-	unsigned char * p = code;
+	// movq $<nOffsetAndIndex>, %r10
+	*reinterpret_cast<sal_uInt16 *>( code ) = 0xba49;
+	*reinterpret_cast<sal_uInt64 *>( code + 2 ) = nOffsetAndIndex;
+
+	// movq $<address of the privateSnippetExecutor>, %r11
+	*reinterpret_cast<sal_uInt16 *>( code + 10 ) = 0xbb49;
+	*reinterpret_cast<sal_uInt64 *>( code + 12 ) = reinterpret_cast<sal_uInt64>( privateSnippetExecutor );
 
-	// movq $<nOffsetAndIndex>, %r11
-	*p++ = 0x49;
-	*p++ = 0xbb;
-	*reinterpret_cast< sal_uInt64 * >( p ) = nOffsetAndIndex;
-	p += sizeof( sal_uInt64 );
-
-	// movq $<address of the privateSnippetExecutor>, %r10
-	*p++ = 0x49;
-	*p++ = 0xba;
-	*reinterpret_cast< sal_uInt64 * >( p ) = reinterpret_cast< sal_uInt64 >( privateSnippetExecutor );
-	p += sizeof( sal_uInt64 );
-
-	// jmpq *%r10
-	*p++ = 0x49;
-	*p++ = 0xff;
-	*p++ = 0xe2;
-
-	OSL_ASSERT( p - code <= codeSnippetSize );
+	// jmpq *%r11
+	*reinterpret_cast<sal_uInt32 *>( code + 20 ) = 0x00e3ff49;
 
 	return code + codeSnippetSize;
 }
@@ -488,21 +482,24 @@ unsigned char * codeSnippet( unsigned ch
 //==================================================================================================
 void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable( char * block )
 {
-	return reinterpret_cast< void ** >(block) + 2;
+	return reinterpret_cast<void **>( block ) + 2;
 }
 
 //==================================================================================================
 char * bridges::cpp_uno::shared::VtableFactory::createBlock(
 	sal_Int32 slotCount, void *** slots)
 {
-	char * block = new char[ (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize ];
-	*slots = mapBlockToVtable(block);
+	char * block = new char[ ( slotCount + 2 ) * sizeof( void * ) + slotCount * codeSnippetSize ];
+	
+	*slots = mapBlockToVtable( block );
 	(*slots)[-2] = 0;
 	(*slots)[-1] = 0;
+
 	return block;
 }
 
 //==================================================================================================
+
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
 	void ** slots, unsigned char * code,
 	typelib_InterfaceTypeDescription const * type, sal_Int32 nFunctionOffset,
@@ -511,31 +508,38 @@ unsigned char * bridges::cpp_uno::shared
 	for ( sal_Int32 nPos = 0; nPos < type->nMembers; ++nPos )
 	{
 		typelib_TypeDescription * pTD = 0;
+
 		TYPELIB_DANGER_GET( &pTD, type->ppMembers[ nPos ] );
 		OSL_ASSERT( pTD );
-		if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
+
+		if ( typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass )
 		{
-			bool simple_ret = bridges::cpp_uno::shared::isSimpleType(
-					((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
+			typelib_InterfaceAttributeTypeDescription *pAttrTD =
+				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( pTD );
+
 			// get method
 			*slots++ = code;
-			code = codeSnippet( code, nFunctionOffset++, nVtableOffset, simple_ret );
-			if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
+								x86_64::returnInHiddenParam( pAttrTD->pAttributeTypeRef ) );
+
+			if ( ! pAttrTD->bReadOnly )
 			{
 				// set method
 				*slots++ = code;
-				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, true );
+				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, false );
 			}
 		}
-		else if (typelib_TypeClass_INTERFACE_METHOD == pTD->eTypeClass)
+		else if ( typelib_TypeClass_INTERFACE_METHOD == pTD->eTypeClass )
 		{
-			bool simple_ret = bridges::cpp_uno::shared::isSimpleType(
-					((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
+			typelib_InterfaceMethodTypeDescription *pMethodTD =
+				reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( pTD );
+			
 			*slots++ = code;
-			code = codeSnippet( code, nFunctionOffset++, nVtableOffset, simple_ret );
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
+								x86_64::returnInHiddenParam( pMethodTD->pReturnTypeRef ) );
 		}
 		else
-			OSL_ASSERT(false);
+			OSL_ASSERT( false );
 
 		TYPELIB_DANGER_RELEASE( pTD );
 	}
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/makefile.mk bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	2005-05-20 18:25:52.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	2005-05-31 10:00:53.000000000 +0200
@@ -89,6 +89,7 @@ NOOPTFILES= \
 CFLAGSNOOPT=-O0
 
 SLOFILES= \
+	$(SLO)$/abi.obj			\
 	$(SLO)$/except.obj		\
 	$(SLO)$/cpp2uno.obj		\
 	$(SLO)$/uno2cpp.obj		\
diff -purN bridges.orig/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx
--- bridges.orig/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	2005-05-25 14:42:54.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	2005-05-31 18:46:12.000000000 +0200
@@ -136,7 +136,7 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
 		{
 		case 'D': // Double
 			if (nr_fpr < FPR_COUNT)
-				pFPR[nr_fpr++] = (double)*pSV++;
+				pFPR[nr_fpr++] = *reinterpret_cast<double *>( pSV++ );
 			else
 				*pDS++ = *pSV++;
 			break;
@@ -146,13 +146,9 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
                 // The value in %xmm register is already prepared to
                 // be retrieved as a float. Therefore, we pass the
                 // value verbatim, as a double without conversion.
-				pFPR[nr_fpr++] = *((double *)pSV);
+				pFPR[nr_fpr++] = *reinterpret_cast<double *>( pSV++ );
 			else
-			{
-				*((float *)pDS) = *((float *)pSV);
-				pDS++;
-			}
-			pSV++;
+				*pDS++ = *reinterpret_cast<double *>( pSV++ );
 			break;
 
 		case 'H': // 64-bit Word
@@ -164,26 +160,23 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
 
 		case 'I': // 32-bit Word
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt32 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt32 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt32 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV++ );
 			break;
 
 		case 'S': // 16-bit Word
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt16 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt16 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt16 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV++ );
 			break;
 
 		case 'B': // Byte
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt8 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt8 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt8 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV++ );
 			break;
 
 		default: // Default, assume 64-bit values
@@ -207,6 +200,8 @@ static void callVirtualMethod(void * pTh
 	// Stack, if used, must be 16-bytes aligned
 	if (nr_stack)
 		nr_stack = (nr_stack + 1) & ~1;
+	
+	bool bReturnsSimpleType = bridges::cpp_uno::shared::isSimpleType( eReturnType );
 
 #if OSL_DEBUG_LEVEL > 1
 	// Let's figure out what is really going on here
@@ -270,11 +265,16 @@ static void callVirtualMethod(void * pTh
         ARG_GPR(3);
         ARG_GPR(2);
         ARG_GPR(1);
-    case 1: a0 = (sal_uInt64) pThis;
+        ARG_GPR(0);
     case 0:;
 #undef ARG_GPR
     }
 
+	if ( bReturnsSimpleType )
+		a0 = (sal_uInt64) pThis;
+	else
+		a1 = (sal_uInt64) pThis;
+
     // Ensure that assignments to SSE registers won't be optimized away
     asm("" ::
         "x" (d0), "x" (d1), "x" (d2), "x" (d3),
@@ -285,46 +285,34 @@ static void callVirtualMethod(void * pTh
     pMethod += 8 * nVtableIndex;
     pMethod = *((sal_uInt64 *)pMethod);
 
-	union ReturnValue {
-		struct {
-			sal_uInt64 a0;
-			sal_uInt64 a1;
-		} i;
-		struct {
-			double d0;
-			double d1;
-		} f;
-	};
-	
-	ReturnValue retval = ((ReturnValue (*)(sal_uInt64, sal_uInt64, sal_uInt64,
-										   sal_uInt64, sal_uInt64, sal_uInt64))
-						  pMethod)(a0, a1, a2, a3, a4, a5);
+	// Perform the call
+	sal_uInt64 nRet = ( (sal_uInt64 (*)(...) ) pMethod )(a0, a1, a2, a3, a4, a5);
 	
 	switch (eReturnType)
 	{
 	case typelib_TypeClass_HYPER:
 	case typelib_TypeClass_UNSIGNED_HYPER:
-		*((sal_uInt64 *)pRegisterReturn) = retval.i.a0;
+		*reinterpret_cast<sal_uInt64 *>( pRegisterReturn ) = nRet;
 		break;
 	case typelib_TypeClass_LONG:
 	case typelib_TypeClass_UNSIGNED_LONG:
 	case typelib_TypeClass_ENUM:
-		*((sal_uInt32 *)pRegisterReturn) = (sal_uInt32)retval.i.a0;
+		*reinterpret_cast<sal_uInt32 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt32*>( &nRet );
 		break;
 	case typelib_TypeClass_CHAR:
 	case typelib_TypeClass_SHORT:
 	case typelib_TypeClass_UNSIGNED_SHORT:
-		*((sal_uInt16 *)pRegisterReturn) = (sal_uInt16)retval.i.a0;
+		*reinterpret_cast<sal_uInt16 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt16*>( &nRet );
 		break;
 	case typelib_TypeClass_BOOLEAN:
 	case typelib_TypeClass_BYTE:
-		*((sal_uInt8 *)pRegisterReturn) = (sal_uInt8)retval.i.a0;
+		*reinterpret_cast<sal_uInt8 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt8*>( &nRet );
 		break;
 	case typelib_TypeClass_FLOAT:
-		*((float *)pRegisterReturn) = (float)retval.f.d0;
+		*reinterpret_cast<float *>( pRegisterReturn ) = *reinterpret_cast<float*>( &nRet );
 		break;
 	case typelib_TypeClass_DOUBLE:
-		*((double *)pRegisterReturn) = retval.f.d0;
+		*reinterpret_cast<double *>( pRegisterReturn ) = *reinterpret_cast<double*>( &nRet );
 		break;
 	}
 }
@@ -343,7 +331,7 @@ static void cpp_call(
   	char * pCppStackStart	= pCppStack;
 
 	// We need to know parameter types for callVirtualMethod() so generate a signature string
-	char * pParamType		= (char *)__builtin_alloca( nParams + 2 );
+	char * pParamType		= (char *)__builtin_alloca( nParams + 3 );
 	char * pPT				= pParamType;
 
 	// Return
@@ -363,7 +351,7 @@ static void cpp_call(
 		{
 			// complex return via ptr
 			pCppReturn = *(void **)pCppStack = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
-												? alloca( pReturnTypeDescr->nSize )
+												? __builtin_alloca( pReturnTypeDescr->nSize )
 												: pUnoReturn); // direct way
 			*pPT++ = 'H';
 			pCppStack += sizeof(void *);
@@ -371,7 +359,8 @@ static void cpp_call(
 	}
 
 	// Push "this" pointer
-	*(void **)pCppStack = pThis->getCppI();
+	void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
+	*(void **)pCppStack = pAdjustedThisPtr;
 	*pPT++ = 'H';
 	pCppStack += sizeof(void *);
 
@@ -481,7 +470,7 @@ static void cpp_call(
 	{
 		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 7), "UNALIGNED STACK !!! (Please DO panic)" );
 		callVirtualMethod(
-			pThis->getCppI(), aVtableSlot.index,
+			pAdjustedThisPtr, aVtableSlot.index,
 			pCppReturn, pReturnTypeDescr->eTypeClass, pParamType,
 			(sal_uInt64 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_uInt64) );
 		// NO exception occured...
