--- binfilter/bf_sc/source/filter/excel/sc_biffdump.cxx	2005-09-07 19:22:51.000000000 +0200
+++ binfilter/bf_sc/source/filter/excel/sc_biffdump.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -6310,7 +6310,7 @@ SvStream& operator>>( SvStream& rStrm, X
 SvStream& operator<<( SvStream& rStrm, const XclGuid& rGuid )
 {
     ByteString aOut;
-    __AddPureHex( aOut, SVBT32ToLong( rGuid.mpData ) );
+    __AddPureHex( aOut, SVBT32ToUInt32( rGuid.mpData ) );
     aOut.Append( '-' );
     __AddPureHex( aOut, SVBT16ToShort( rGuid.mpData + 4 ) );
     aOut.Append( '-' );
--- binfilter/bf_sc/source/filter/excel/sc_xistream.cxx	2005-09-07 19:32:52.000000000 +0200
+++ binfilter/bf_sc/source/filter/excel/sc_xistream.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -519,7 +519,7 @@ void XclImpStream::ReadAtom( sal_Int32& 
     {
         SVBT32 pBuffer;
         mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        rnValue = static_cast< sal_Int32 >( SVBT32ToLong( pBuffer ) );
+        rnValue = static_cast< sal_Int32 >( SVBT32ToUInt32( pBuffer ) );
     }
     else
 #endif
@@ -534,7 +534,7 @@ void XclImpStream::ReadAtom( sal_uInt32&
     {
         SVBT32 pBuffer;
         mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        rnValue = SVBT32ToLong( pBuffer );
+        rnValue = SVBT32ToUInt32( pBuffer );
     }
     else
 #endif
@@ -549,7 +549,7 @@ void XclImpStream::ReadAtom( float& rfVa
     {
         SVBT32 pBuffer;
         mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        sal_uInt32 nValue = SVBT32ToLong( pBuffer );
+        sal_uInt32 nValue = SVBT32ToUInt32( pBuffer );
         memcpy( &rfValue, &nValue, 4 );
     }
     else
--- binfilter/bf_sc/source/filter/excel/sc_xltools.cxx	2005-09-07 19:34:20.000000000 +0200
+++ binfilter/bf_sc/source/filter/excel/sc_xltools.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -94,7 +94,7 @@ XclGuid::XclGuid(
         sal_uInt8 nData45, sal_uInt8 nData46, sal_uInt8 nData47, sal_uInt8 nData48 )
 {
     // convert to little endian -> makes streaming easy
-    LongToSVBT32( nData1, mpData );
+    UInt32ToSVBT32( nData1, mpData );
     ShortToSVBT16( nData2, mpData + 4 );
     ShortToSVBT16( nData3, mpData + 6 );
     mpData[  8 ] = nData41;
@@ -152,7 +152,7 @@ double XclTools::GetDoubleFromRK( sal_In
         // create a Little-Endian buffer
         SVBT64 pBuffer;
         pBuffer[ 0 ] = pBuffer[ 1 ] = pBuffer[ 2 ] = pBuffer[ 3 ] = 0;
-        LongToSVBT32( nRKValue & EXC_RK_VALUEMASK, pBuffer + 4 );
+        UInt32ToSVBT32( nRKValue & EXC_RK_VALUEMASK, pBuffer + 4 );
         // create the double from buffer
         fVal = SVBT64ToDouble( pBuffer );
     }
--- binfilter/bf_sc/source/filter/inc/xl_comp.hxx	2005-09-07 19:59:47.000000000 +0200
+++ binfilter/bf_sc/source/filter/inc/xl_comp.hxx	2006-03-28 19:33:35.000000000 +0200
@@ -170,14 +170,14 @@ inline void SToken::Set( const UINT16 nI
 inline void SToken::Set( const UINT16 nIndex, const UINT32 nVal )
 {
 	DBG_ASSERT( nIndex < nMaxTokenLen - 3, "-SToken::Set(): Index zu gross!" );
-	LongToSVBT32( nVal , &Data[ nIndex ] );
+	UInt32ToSVBT32( nVal , &Data[ nIndex ] );
 }
 
 
 inline void SToken::Set( const UINT16 nIndex, const INT32 nVal )
 {
 	DBG_ASSERT( nIndex < nMaxTokenLen - 3, "-SToken::Set(): Index zu gross!" );
-	LongToSVBT32( *( ( UINT32* ) &nVal ), &Data[ nIndex ] );
+	UInt32ToSVBT32( *( ( UINT32* ) &nVal ), &Data[ nIndex ] );
 }
 
 
--- binfilter/bf_sw/source/filter/ww1/sw_w1class.cxx	2005-09-09 05:27:56.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww1/sw_w1class.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -427,10 +427,10 @@ Ww1Picture::Ww1Picture(SvStream& rStream
 	SVBT32 lcb;
 	if (rStream.Seek(ulFilePos) == (ULONG)ulFilePos)
 		if (rStream.Read(&lcb, sizeof(lcb)) == (ULONG)sizeof(lcb))
-			if (sizeof(int)>=4 || SVBT32ToLong(lcb) < 0x8000) //~ mdt: 64K & 16bit
-				if ((pPic = (W1_PIC*)(new BYTE[SVBT32ToLong(lcb)])) != NULL)
+			if (sizeof(int)>=4 || SVBT32ToUInt32(lcb) < 0x8000) //~ mdt: 64K & 16bit
+				if ((pPic = (W1_PIC*)(new BYTE[SVBT32ToUInt32(lcb)])) != NULL)
 					if (rStream.Seek(ulFilePos) == (ULONG)ulFilePos)
-						if (rStream.Read(pPic, SVBT32ToLong(lcb)) == (ULONG)SVBT32ToLong(lcb))
+						if (rStream.Read(pPic, SVBT32ToUInt32(lcb)) == (ULONG)SVBT32ToUInt32(lcb))
 						{
 							DBG_ASSERT(pPic->cbHeaderGet()==sizeof(*pPic)-sizeof(pPic->rgb), "Ww1Picture");
 							bOK = TRUE;
@@ -792,7 +792,7 @@ ULONG Ww1Plc::Where(USHORT nIndex)
 	ULONG ulRet = 0xffffffff;
 	DBG_ASSERT(nIndex <= iMac, "index out of bounds");
 	if (iMac && nIndex <= iMac)
-		ulRet = SVBT32ToLong(p + sizeof(SVBT32) * nIndex);
+		ulRet = SVBT32ToUInt32(p + sizeof(SVBT32) * nIndex);
 	return ulRet;
 }
 
@@ -982,7 +982,7 @@ ULONG Ww1Fkp::Where(USHORT nIndex)
 	ULONG lRet = 0xffffffff;
 	DBG_ASSERT(nIndex<=Count(), "index out of bounds");
 	if (nIndex<=Count())
-		lRet = SVBT32ToLong(aFkp+nIndex*sizeof(SVBT32));
+		lRet = SVBT32ToUInt32(aFkp+nIndex*sizeof(SVBT32));
 	return lRet;
 }
 
--- binfilter/bf_sw/source/filter/ww1/sw_w1filter.cxx	2005-09-09 05:28:08.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww1/sw_w1filter.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -1301,7 +1301,7 @@ void Ww1Sep::Start(Ww1Shell& rOut, Ww1Ma
 	// diese methode ist bei den meisten start/stop methoden der
 	// memberklassen des managers identisch.
 		BYTE* p = GetData();
-		Ww1SprmSep aSprm(rFib, SVBT32ToLong(p+2));
+		Ww1SprmSep aSprm(rFib, SVBT32ToUInt32(p+2));
 		aSprm.Start(rOut, rMan);
 		aSprm.Stop(rOut, rMan);
 		(*this)++;
@@ -2077,7 +2077,7 @@ void Ww1Picture::WriteBmp(SvStream& rOut
 	SVBT16 tmpShort;
 	SVBT8 tmpByte;
 #define wLong(n) \
-	LongToSVBT32(n, tmpLong); \
+	UInt32ToSVBT32(n, tmpLong); \
 	if ((rOut.Write(tmpLong, sizeof(SVBT32))) != sizeof(SVBT32)) goto error;
 #define wShort(n) \
 	ShortToSVBT16(n, tmpShort); \
--- binfilter/bf_sw/source/filter/ww1/w1struct.hxx	2005-09-09 05:29:19.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww1/w1struct.hxx	2006-03-28 19:33:35.000000000 +0200
@@ -91,45 +91,45 @@ struct W1_FIB //////////////////////////
 	SVBT16 u2[5];// 0xe reserved
 	SVBT32 fcMin;// 0x18 file offset of first character of text
 	ULONG fcMinGet() {
-		return SVBT32ToLong(fcMin); }
+		return SVBT32ToUInt32(fcMin); }
 	SVBT32 fcMac;// 0x1c file offset of last character of text + 1
 	ULONG fcMacGet() {
-		return SVBT32ToLong(fcMac); }
+		return SVBT32ToUInt32(fcMac); }
 	SVBT32 cbMac;// 0x20 file offset of last byte written to file + 1.
 	ULONG cbMacGet() {
-		return SVBT32ToLong(cbMac); }
+		return SVBT32ToUInt32(cbMac); }
 	SVBT32 u4[4];// 0x24 reserved
 	SVBT32 ccpText;// 0x34 length of main document text stream
 	ULONG ccpTextGet() {
-		return SVBT32ToLong(ccpText); }
+		return SVBT32ToUInt32(ccpText); }
 	SVBT32 ccpFtn;// 0x38 length of footnote subdocument text stream
 	ULONG ccpFtnGet() {
-		return SVBT32ToLong(ccpFtn); }
+		return SVBT32ToUInt32(ccpFtn); }
 	SVBT32 ccpHdd;// 0x3c length of header subdocument text stream
 	ULONG ccpHddGet() {
-		return SVBT32ToLong(ccpHdd); }
+		return SVBT32ToUInt32(ccpHdd); }
 	SVBT32 ccpMcr;// 0x40 length of macro subdocument text stream
 	ULONG ccpMcrGet() {
-		return SVBT32ToLong(ccpMcr); }
+		return SVBT32ToUInt32(ccpMcr); }
 	SVBT32 ccpAtn;// 0x44 length of annotation subdocument text stream
 	ULONG ccpAtnGet() {
-		return SVBT32ToLong(ccpAtn); }
+		return SVBT32ToUInt32(ccpAtn); }
 	SVBT32 cp5[4];// 0x48
 	SVBT32 fcStshfOrig;// 0x58 file offset of original allocation for STSH in file
 	ULONG fcStshfOrigGet() {
-		return SVBT32ToLong(fcStshfOrig); }
+		return SVBT32ToUInt32(fcStshfOrig); }
 	SVBT16 cbStshfOrig;// 0x5c count of bytes of original STSH allocation
 	USHORT cbStshfOrigGet() {
 		return SVBT16ToShort(cbStshfOrig); }
 	SVBT32 fcStshf;// 0x5e file offset of STSH in file.
 	ULONG fcStshfGet() {
-		return SVBT32ToLong(fcStshf); }
+		return SVBT32ToUInt32(fcStshf); }
 	SVBT16 cbStshf;// 0x62 count of bytes of current STSH allocation
 	USHORT cbStshfGet() {
 		return SVBT16ToShort(cbStshf); }
 	SVBT32 fcPlcffndRef;// 0x64 file offset of footnote reference PLC.
 	ULONG fcPlcffndRefGet() {
-		return SVBT32ToLong(fcPlcffndRef); }
+		return SVBT32ToUInt32(fcPlcffndRef); }
 	SVBT16 cbPlcffndRef;// 0x68 count of bytes of footnote reference PLC
 	USHORT cbPlcffndRefGet() {
 		return SVBT16ToShort(cbPlcffndRef); }
@@ -137,7 +137,7 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcffndTxt;// 0x6a file offset of footnote text PLC.
 	ULONG fcPlcffndTxtGet() {
-		return SVBT32ToLong(fcPlcffndTxt); }
+		return SVBT32ToUInt32(fcPlcffndTxt); }
 	SVBT16 cbPlcffndTxt;// 0x6e count of bytes of footnote text PLC.
 	USHORT cbPlcffndTxtGet() {
 		return SVBT16ToShort(cbPlcffndTxt); }
@@ -145,28 +145,28 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcfandRef;// 0x70 file offset of annotation reference PLC.
 	ULONG fcPlcfandRefGet() {
-		return SVBT32ToLong(fcPlcfandRef); }
+		return SVBT32ToUInt32(fcPlcfandRef); }
 	SVBT16 cbPlcfandRef;// 0x74 count of bytes of annotation reference PLC.
 	USHORT cbPlcfandRefGet() {
 		return SVBT16ToShort(cbPlcfandRef); }
 
 	SVBT32 fcPlcfandTxt;// 0x76 file offset of annotation text PLC.
 	ULONG fcPlcfandTxtGet() {
-		return SVBT32ToLong(fcPlcfandTxt); }
+		return SVBT32ToUInt32(fcPlcfandTxt); }
 	SVBT16 cbPlcfandTxt;// 0x7a count of bytes of the annotation text PLC
 	USHORT cbPlcfandTxtGet() {
 		return SVBT16ToShort(cbPlcfandTxt); }
 
 	SVBT32 fcPlcfsed;// 8x7c file offset of section descriptor PLC.
 	ULONG fcPlcfsedGet() {
-		return SVBT32ToLong(fcPlcfsed); }
+		return SVBT32ToUInt32(fcPlcfsed); }
 	SVBT16 cbPlcfsed;// 0x80 count of bytes of section descriptor PLC.
 	USHORT cbPlcfsedGet() {
 		return SVBT16ToShort(cbPlcfsed); }
 
 	SVBT32 fcPlcfpgd;// 0x82 file offset of paragraph descriptor PLC
 	ULONG fcPlcfpgdGet() {
-		return SVBT32ToLong(fcPlcfpgd); }
+		return SVBT32ToUInt32(fcPlcfpgd); }
 	SVBT16 cbPlcfpgd;// 0x86 count of bytes of paragraph descriptor PLC.
 	USHORT cbPlcfpgdGet() {
 		return SVBT16ToShort(cbPlcfpgd); }
@@ -175,7 +175,7 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcfphe;// 0x88 file offset of PLC of paragraph heights.
 	ULONG fcPlcfpheGet() {
-		return SVBT32ToLong(fcPlcfphe); }
+		return SVBT32ToUInt32(fcPlcfphe); }
 	SVBT16 cbPlcfphe;// 0x8c count of bytes of paragraph height PLC.
 	USHORT cbPlcfpheGet() {
 		return SVBT16ToShort(cbPlcfphe); }
@@ -183,7 +183,7 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcSttbfglsy;// 0x8e file offset of glossary string table.
 	ULONG fcSttbfglsyGet() {
-		return SVBT32ToLong(fcSttbfglsy); }
+		return SVBT32ToUInt32(fcSttbfglsy); }
 	SVBT16 cbSttbfglsy;// 0x92 count of bytes of glossary string table.
 	USHORT cbSttbfglsyGet() {
 		return SVBT16ToShort(cbSttbfglsy); }
@@ -192,7 +192,7 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcfglsy;// 0x94 file offset of glossary PLC.
 	ULONG fcPlcfglsyGet() {
-		return SVBT32ToLong(fcPlcfglsy); }
+		return SVBT32ToUInt32(fcPlcfglsy); }
 	SVBT16 cbPlcfglsy;// 0x98 count of bytes of glossary PLC.
 	USHORT cbPlcfglsyGet() {
 		return SVBT16ToShort(cbPlcfglsy); }
@@ -201,7 +201,7 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcfhdd;// 0x9a byte offset of header PLC.
 	ULONG fcPlcfhddGet() {
-		return SVBT32ToLong(fcPlcfhdd); }
+		return SVBT32ToUInt32(fcPlcfhdd); }
 	SVBT16 cbPlcfhdd;// 0x9e count of bytes of header PLC.
 	USHORT cbPlcfhddGet() {
 		return SVBT16ToShort(cbPlcfhdd); }
@@ -209,126 +209,126 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcPlcfbteChpx;// 0xa0 file offset of character property bin table.PLC.
 	ULONG fcPlcfbteChpxGet() {
-		return SVBT32ToLong(fcPlcfbteChpx); }
+		return SVBT32ToUInt32(fcPlcfbteChpx); }
 	SVBT16 cbPlcfbteChpx;// 0xa4 count of bytes of character property bin table PLC.
 	USHORT cbPlcfbteChpxGet() {
 		return SVBT16ToShort(cbPlcfbteChpx); }
 
 	SVBT32 fcPlcfbtePapx;// 0xa6 file offset of paragraph property bin table.PLC.
 	ULONG fcPlcfbtePapxGet() {
-		return SVBT32ToLong(fcPlcfbtePapx); }
+		return SVBT32ToUInt32(fcPlcfbtePapx); }
 	SVBT16 cbPlcfbtePapx;// 0xaa count of bytes of paragraph property bin table PLC.
 	USHORT cbPlcfbtePapxGet() {
 		return SVBT16ToShort(cbPlcfbtePapx); }
 
 	SVBT32 fcPlcfsea;// 0xac file offset of PLC reserved for private use. The SEA is 6 bytes long.
 	ULONG fcPlcfseaGet() {
-		return SVBT32ToLong(fcPlcfsea); }
+		return SVBT32ToUInt32(fcPlcfsea); }
 	SVBT16 cbPlcfsea;// 0xb0	count of bytes of private use PLC.
 	USHORT cbPlcfseaGet() {
 		return SVBT16ToShort(cbPlcfsea); }
 
 	SVBT32 fcSttbfffn;// 0xb2	file offset of font information STTBF. See the FFN file structure definition.
 	ULONG fcSttbfffnGet() {
-		return SVBT32ToLong(fcSttbfffn); }
+		return SVBT32ToUInt32(fcSttbfffn); }
 	SVBT16 cbSttbfffn;// 0xb6	count of bytes in sttbfffn.
 	USHORT cbSttbfffnGet() {
 		return SVBT16ToShort(cbSttbfffn); }
 
 	SVBT32 fcPlcffldMom;// 0xb8	offset in doc stream to the PLC of field positions in the main document.
 	ULONG fcPlcffldMomGet() {
-		return SVBT32ToLong(fcPlcffldMom); }
+		return SVBT32ToUInt32(fcPlcffldMom); }
 	SVBT16 cbPlcffldMom;// 0xbc
 	USHORT cbPlcffldMomGet() {
 		return SVBT16ToShort(cbPlcffldMom); }
 
 	SVBT32 fcPlcffldHdr;// 0xbe	offset in doc stream to the PLC of field positions in the header subdocument.
 	ULONG fcPlcffldHdrGet() {
-		return SVBT32ToLong(fcPlcffldHdr); }
+		return SVBT32ToUInt32(fcPlcffldHdr); }
 	SVBT16 cbPlcffldHdr;// 0xc2
 	USHORT cbPlcffldHdrGet() {
 		return SVBT16ToShort(cbPlcffldHdr); }
 
 	SVBT32 fcPlcffldFtn;// 0xc4	offset in doc stream to the PLC of field positions in the footnote subdocument.
 	ULONG fcPlcffldFtnGet() {
-		return SVBT32ToLong(fcPlcffldFtn); }
+		return SVBT32ToUInt32(fcPlcffldFtn); }
 	SVBT16 cbPlcffldFtn;// 0xc8
 	USHORT cbPlcffldFtnGet() {
 		return SVBT16ToShort(cbPlcffldFtn); }
 
 	SVBT32 fcPlcffldAtn;// 0xca	offset in doc stream to the PLC of field positions in the annotation subdocument.
 	ULONG fcPlcffldAtnGet() {
-		return SVBT32ToLong(fcPlcffldAtn); }
+		return SVBT32ToUInt32(fcPlcffldAtn); }
 	SVBT16 cbPlcffldAtn;// 0xce
 	USHORT cbPlcffldAtnGet() {
 		return SVBT16ToShort(cbPlcffldAtn); }
 
 	SVBT32 fcPlcffldMcr;// 0xd0	offset in doc stream to the PLC of field positions in the macro subdocument.
 	ULONG fcPlcffldMcrGet() {
-		return SVBT32ToLong(fcPlcffldMcr); }
+		return SVBT32ToUInt32(fcPlcffldMcr); }
 	SVBT16 cbPlcffldMcr;// 0xd4
 	USHORT cbPlcffldMcrGet() {
 		return SVBT16ToShort(cbPlcffldMcr); }
 
 	SVBT32 fcSttbfbkmk;// 0xd6 offset in document stream of the STTBF that records bookmark names in the main document
 	ULONG fcSttbfbkmkGet() {
-		return SVBT32ToLong(fcSttbfbkmk); }
+		return SVBT32ToUInt32(fcSttbfbkmk); }
 	SVBT16 cbSttbfbkmk;// 0xda
 	USHORT cbSttbfbkmkGet() {
 		return SVBT16ToShort(cbSttbfbkmk); }
 
 	SVBT32 fcPlcfbkf;// 0xdc offset in document stream of the PLCF that records the beginning CP offsets of bookmarks in the main document. See BKF
 	ULONG fcPlcfbkfGet() {
-		return SVBT32ToLong(fcPlcfbkf); }
+		return SVBT32ToUInt32(fcPlcfbkf); }
 	SVBT16 cbPlcfbkf;// 0xe0
 	USHORT cbPlcfbkfGet() {
 		return SVBT16ToShort(cbPlcfbkf); }
 
 	SVBT32 fcPlcfbkl;// 0xe2 offset in document stream of the PLCF that records the ending CP offsets of bookmarks recorded in the main document. See the BKL structure definition.
 	ULONG fcPlcfbklGet() {
-		return SVBT32ToLong(fcPlcfbkl); }
+		return SVBT32ToUInt32(fcPlcfbkl); }
 	SVBT16 cbPlcfbkl;// 0xe6 SVBT16
 	USHORT cbPlcfbklGet() {
 		return SVBT16ToShort(cbPlcfbkl); }
 
 	SVBT32 fcCmds;// 0xe8 FC
 	ULONG fcCmdsGet() {
-		return SVBT32ToLong(fcCmds); }
+		return SVBT32ToUInt32(fcCmds); }
 	SVBT16 cbCmds;// 0xec
 	USHORT cbCmdsGet() {
 		return SVBT16ToShort(cbCmds); }
 
 	SVBT32 fcPlcmcr;// 0xee FC
 	ULONG fcPlcmcrGet() {
-		return SVBT32ToLong(fcPlcmcr); }
+		return SVBT32ToUInt32(fcPlcmcr); }
 	SVBT16 cbPlcmcr;// 0xf2
 	USHORT cbPlcmcrGet() {
 		return SVBT16ToShort(cbPlcmcr); }
 
 	SVBT32 fcSttbfmcr;// 0xf4 FC
 	ULONG fcSttbfmcrGet() {
-		return SVBT32ToLong(fcSttbfmcr); }
+		return SVBT32ToUInt32(fcSttbfmcr); }
 	SVBT16 cbSttbfmcr;// 0xf8
 	USHORT cbSttbfmcrGet() {
 		return SVBT16ToShort(cbSttbfmcr); }
 
 	SVBT32 fcPrEnv;// 0xfa
 	ULONG fcPrEnvGet() {
-		return SVBT32ToLong(fcPrEnv); }
+		return SVBT32ToUInt32(fcPrEnv); }
 	SVBT16 cbPrEnv;// 0xfe
 	USHORT cbPrEnvGet() {
 		return SVBT16ToShort(cbPrEnv); }
 
 	SVBT32 fcWss;// 0x100 file offset of Window Save State data structure. See WSS.
 	ULONG fcWssGet() {
-		return SVBT32ToLong(fcWss); }
+		return SVBT32ToUInt32(fcWss); }
 	SVBT16 cbWss;// 0x100 count of bytes of WSS. ==0 if unable to store the window state.
 	USHORT cbWssGet() {
 		return SVBT16ToShort(cbWss); }
 
 	SVBT32 fcDop;// 0x106 file offset of document property data structure.
 	ULONG fcDopGet() {
-		return SVBT32ToLong(fcDop); }
+		return SVBT32ToUInt32(fcDop); }
 	SVBT16 cbDop;// 0x10a count of bytes of document properties.
 	USHORT cbDopGet() {
 		return SVBT16ToShort(cbDop); }
@@ -336,21 +336,21 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcSttbfAssoc;// 0x10c offset to STTBF of associated strings. See STTBFASSOC.
 	ULONG fcSttbfAssocGet() {
-		return SVBT32ToLong(fcSttbfAssoc); }
+		return SVBT32ToUInt32(fcSttbfAssoc); }
 	SVBT16 cbSttbfAssoc;// 0x110
 	USHORT cbSttbfAssocGet() {
 		return SVBT16ToShort(cbSttbfAssoc); }
 
 	SVBT32 fcClx;// 0x112 file offset of beginning of information for complex files.
 	ULONG fcClxGet() {
-		return SVBT32ToLong(fcClx); }
+		return SVBT32ToUInt32(fcClx); }
 	SVBT16 cbClx;// 0x116 count of bytes of complex file information. 0 if file is non-complex.
 	USHORT cbClxGet() {
 		return SVBT16ToShort(cbClx); }
 
 	SVBT32 fcPlcfpgdFtn;// 0x118 file offset of page descriptor PLC for footnote subdocument.
 	ULONG fcPlcfpgdFtnGet() {
-		return SVBT32ToLong(fcPlcfpgdFtn); }
+		return SVBT32ToUInt32(fcPlcfpgdFtn); }
 	SVBT16 cbPlcfpgdFtn;// 0x11C count of bytes of page descriptor PLC for footnote subdocument.
 	USHORT cbPlcfpgdFtnGet() {
 		return SVBT16ToShort(cbPlcfpgdFtn); }
@@ -358,25 +358,25 @@ struct W1_FIB //////////////////////////
 
 	SVBT32 fcSpare1;// 0x11e file offset of the name of the original file.
 	ULONG fcSpare1Get() {
-		return SVBT32ToLong(fcSpare1); }
+		return SVBT32ToUInt32(fcSpare1); }
 	SVBT16 cbSpare1;// 0x122 count of bytes of the name of the original file.
 	USHORT cbSpare1Get() {
 		return SVBT16ToShort(cbSpare1); }
 	SVBT32 fcSpare2;// 0x124 file offset of the name of the original file.
 	ULONG fcSpare2Get() {
-		return SVBT32ToLong(fcSpare2); }
+		return SVBT32ToUInt32(fcSpare2); }
 	SVBT16 cbSpare2;// 0x128 count of bytes of the name of the original file.
 	USHORT cbSpare2Get() {
 		return SVBT16ToShort(cbSpare2); }
 	SVBT32 fcSpare3;// 0x12a file offset of the name of the original file.
 	ULONG fcSpare3Get() {
-		return SVBT32ToLong(fcSpare3); }
+		return SVBT32ToUInt32(fcSpare3); }
 	SVBT16 cbSpare3;// 0x12e count of bytes of the name of the original file.
 	USHORT cbSpare3Get() {
 		return SVBT16ToShort(cbSpare3); }
 	SVBT32 fcSpare4;// 0x130 file offset of the name of the original file.
 	ULONG fcSpare4Get() {
-		return SVBT32ToLong(fcSpare4); }
+		return SVBT32ToUInt32(fcSpare4); }
 	SVBT16 cbSpare4;// 0x134 count of bytes of the name of the original file.
 	USHORT cbSpare4Get() {
 		return SVBT16ToShort(cbSpare4); }
@@ -491,25 +491,25 @@ struct W1_DOP //////////////////////////
 	SVBT16	rgwSpare[2];// reserved
 	SVBT32	dttmCreated;// DTTM date and time document was created
 	ULONG dttmCreatedGet() {
-		return SVBT32ToLong(dttmCreated); }
+		return SVBT32ToUInt32(dttmCreated); }
 	SVBT32	dttmRevised;// DTTM date and time document was last revised
 	ULONG dttmRevisedGet() {
-		return SVBT32ToLong(dttmRevised); }
+		return SVBT32ToUInt32(dttmRevised); }
 	SVBT32	dttmLastPrint;// DTTM date and time document was last printed
 	ULONG dttmLastPrintGet() {
-		return SVBT32ToLong(dttmLastPrint); }
+		return SVBT32ToUInt32(dttmLastPrint); }
 	SVBT16	nRevision;// number of times document has been revised since its creation
 	USHORT nRevisionGet() {
 		return SVBT16ToShort(nRevision); }
 	SVBT32	tmEdited;// time document was last edited
 	ULONG tmEditedGet() {
-		return SVBT32ToLong(tmEdited); }
+		return SVBT32ToUInt32(tmEdited); }
 	SVBT32	cWords;// count of words tallied by last Word Count execution
 	ULONG cWordsGet() {
-		return SVBT32ToLong(cWords); }
+		return SVBT32ToUInt32(cWords); }
 	SVBT32	cCh;// count of characters tallied by last Word Count execution
 	ULONG cChGet() {
-		return SVBT32ToLong(cCh); }
+		return SVBT32ToUInt32(cCh); }
 	SVBT16	cPg;// count of pages tallied by last Word Count execution
 	USHORT cPgGet() {
 		return SVBT16ToShort(cPg); }
@@ -590,7 +590,7 @@ struct W1_CHP //////////////////////////
 	// SVBT16 kul: 3;// Underline code: 0=none, 1=single, 2=by word, 3=double, 4=dotted
 	// SVBT16 fSysVanish: 1;// used internally
 
-	ULONG fcPicGet() 		{ return SVBT32ToLong(fcPic); }
+	ULONG fcPicGet() 		{ return SVBT32ToUInt32(fcPic); }
 	USHORT fnPicGet() 		{ return SVBT8ToByte(fnPic); }
 	USHORT hpsLargeChpGet() { return SVBT16ToShort(hpsLargeChp); }
 
@@ -735,7 +735,7 @@ struct W1_PIC //////////////////////////
 {
 	SVBT32 lcb;// 0x0 number of bytes in the PIC structure plus size of following picture data which may be a Window's metafile, a bitmap, or the filename of a TIFF file.
 	ULONG lcbGet() {
-		return SVBT32ToLong(lcb); }
+		return SVBT32ToUInt32(lcb); }
 	SVBT16 cbHeader;// 0x4 number of bytes in the PIC (to allow for future expansion).
 	USHORT cbHeaderGet() {
 		return SVBT16ToShort(cbHeader); }
--- binfilter/bf_sw/source/filter/ww8/dump/sw_dump8a.cxx	2005-09-09 05:36:41.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/dump/sw_dump8a.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -87,7 +87,7 @@ BOOL WW8ReadINT32( SvStream& rStrm, INT3
 	  SVBT32 nData;
       BOOL bOk = TRUE;
       if( 4 == rStrm.Read( &nData, 4 ) )
-              rTarget = SVBT32ToLong( nData );
+              rTarget = SVBT32ToUInt32( nData );
       else
               bOk = FALSE;
       return bOk;
@@ -1506,12 +1506,12 @@ static void DumpPLCF( long nPos, long nL
 				if( 8 == pWwFib->nVersion )
 				{
 					nId = SVBT16ToShort( ((WW8_ATRD*)pData)->ibst );
-					nBkmkId = SVBT32ToLong( ((WW8_ATRD*)pData)->ITagBkmk );
+					nBkmkId = SVBT32ToUInt32( ((WW8_ATRD*)pData)->ITagBkmk );
 				}
 				else
 				{
 					nId = SVBT16ToShort( ((WW67_ATRD*)pData )->ibst );
-					nBkmkId = SVBT32ToLong( ((WW67_ATRD*)pData )->ITagBkmk );
+					nBkmkId = SVBT32ToUInt32( ((WW67_ATRD*)pData )->ITagBkmk );
 				}
 
 				*pOut << "\", AutorId: " << hex << nId
--- binfilter/bf_sw/source/filter/ww8/dump/sw_ww8scan.cxx	2005-09-09 05:37:44.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/dump/sw_ww8scan.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -805,7 +805,7 @@ inline short Get_Short( BYTE *& p )
 
 inline ULONG Get_ULong( BYTE *& p )
 {
-    ULONG n = SVBT32ToLong( *(SVBT32*)p );
+    ULONG n = SVBT32ToUInt32( *(SVBT32*)p );
     p += 4;
     return n;
 }
@@ -1148,7 +1148,7 @@ WW8_FC WW8PLCFx_PCD::AktPieceStartCp2Fc(
 		nCp = nCpEnd - 1;
 
 	bool bIsUnicode = false;
-	WW8_FC nFC = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+	WW8_FC nFC = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 	if( !bVer67 )
 		nFC = WW8PLCFx_PCD::TransformPieceAddress( nFC, bIsUnicode );
 
@@ -1177,7 +1177,7 @@ WW8_CP WW8PLCFx_PCD::AktPieceStartFc2Cp(
 		return LONG_MAX;
 	}
 	bool bIsUnicode = false;
-	INT32 nFcStart  = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+	INT32 nFcStart  = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 	if( !bVer67 )
 		nFcStart = WW8PLCFx_PCD::TransformPieceAddress( nFcStart, bIsUnicode );
 
@@ -1466,7 +1466,7 @@ WW8_CP WW8ScannerBase::WW8Fc2Cp( WW8_FC 
 				ASSERT( !this, "PLCFpcd-WW8Fc2Cp() ging schief" );
 				break;
 			}
-			INT32 nFcStart  = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+			INT32 nFcStart  = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 			if( 8 <= pWw8Fib->nVersion )
 				nFcStart = WW8PLCFx_PCD::TransformPieceAddress( nFcStart,
 																bIsUnicode );
@@ -1547,7 +1547,7 @@ WW8_FC WW8ScannerBase::WW8Cp2Fc(WW8_CP n
 		if( pNextPieceCp )
 			*pNextPieceCp = nCpEnd;
 
-		WW8_FC nRet = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+		WW8_FC nRet = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 		if (8 > pWw8Fib->nVersion)
 			*pIsUnicode = false;
 		else
@@ -2465,7 +2465,7 @@ WW8PLCFx_Fc_FKP::WW8Fkp::WW8Fkp(BYTE nFi
                     {
                         UINT32 nCurr = pDataSt->Tell();
 
-                        UINT32 nPos = SVBT32ToLong(aEntry.mpData + 2);
+                        UINT32 nPos = SVBT32ToUInt32(aEntry.mpData + 2);
                         pDataSt->Seek(nPos);
                         *pDataSt >> aEntry.mnLen;
                         aEntry.mpData = new sal_uInt8[aEntry.mnLen];
@@ -3110,7 +3110,7 @@ void WW8PLCFx_Cp_FKP::GetSprms(WW8PLCFxD
 				void* pData;
 				pPieceIter->Get(nCpStart, nCpEnd, pData);
 
-				WW8_FC nLimitFC = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+				WW8_FC nLimitFC = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 				WW8_FC nBeginLimitFC = nLimitFC;
 				if( 8 <= GetVersion() )
 				{
@@ -3161,7 +3161,7 @@ void WW8PLCFx_Cp_FKP::GetSprms(WW8PLCFxD
 								break;
 							}
 							bIsUnicode = false;
-							INT32 nFcStart=SVBT32ToLong(((WW8_PCD*)pData)->fc);
+							INT32 nFcStart=SVBT32ToUInt32(((WW8_PCD*)pData)->fc);
 
 							if( 8 <= GetVersion() )
 							{
@@ -3287,7 +3287,7 @@ void WW8PLCFx_SEPX::GetSprms(WW8PLCFxDes
 	}
 	else
 	{
-		long nPo =  SVBT32ToLong( (BYTE*)pData+2 );
+		long nPo =  SVBT32ToUInt32( (BYTE*)pData+2 );
 		if (nPo == -1L)
 		{
 			p->nStartPos = p->nEndPos = LONG_MAX;		// Sepx empty
--- binfilter/bf_sw/source/filter/ww8/dump/ww8struc.hxx	2005-09-09 05:38:38.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/dump/ww8struc.hxx	2006-03-28 19:33:35.000000000 +0200
@@ -58,9 +58,9 @@ inline USHORT Get_UShort( BYTE *& p )
 	{ USHORT n = SVBT16ToShort( *(SVBT16*)p );	p += 2; return n; }
 
 inline long Get_Long( BYTE *& p )
-	{ long n = SVBT32ToLong( *(SVBT32*)p );		p += 4; return n; }
+	{ long n = SVBT32ToUInt32( *(SVBT32*)p );		p += 4; return n; }
 inline ULONG Get_ULong( BYTE *& p )
-	{ ULONG n = SVBT32ToLong( *(SVBT32*)p );		p += 4; return n; }
+	{ ULONG n = SVBT32ToUInt32( *(SVBT32*)p );		p += 4; return n; }
 
 inline void Set_UInt8( BYTE *& p, UINT8 n )
 	{ ByteToSVBT8( n, *(SVBT8*)p );  p+= 1; }
@@ -69,7 +69,7 @@ inline void Set_UInt16( BYTE *& p, UINT1
 	{ ShortToSVBT16( n, *(SVBT16*)p );  p+= 2; }
 
 inline void Set_UInt32( BYTE *& p, UINT32 n )
-	{ LongToSVBT32( n, *(SVBT32*)p );  p+= 4; }
+	{ UInt32ToSVBT32( n, *(SVBT32*)p );  p+= 4; }
 
 
 #if defined  OSL_BIGENDIAN || __ALIGNMENT4 > 2 || defined UNX
--- binfilter/bf_sw/source/filter/ww8/sw_wrtw8sty.cxx	2005-09-09 05:30:47.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_wrtw8sty.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -870,7 +870,7 @@ void WW8_WrPlc0::Write( SvStream& rStrm 
 	for( USHORT i = 0; i < nLen; ++i )
 	{
 		SVBT32 nP;
-		LongToSVBT32( aPos[i], nP );
+		UInt32ToSVBT32( aPos[i], nP );
 		rStrm.Write( nP, 4 );
 	}
 }
@@ -1568,7 +1568,7 @@ void WW8_WrPlcSepx::WritePlcSed( SwWW8Wr
 	{
 		UINT32 nP = aCps[i];
 		SVBT32 nPos;
-		LongToSVBT32( nP, nPos );
+		UInt32ToSVBT32( nP, nPos );
 		rWrt.pTableStrm->Write( nPos, 4 );
 	}
 
@@ -1578,7 +1578,7 @@ void WW8_WrPlcSepx::WritePlcSed( SwWW8Wr
 	for( i = 0; i < aSects.Count(); i++ )
 	{
 		WW8_PdAttrDesc* pA = pAttrs + i;
-		LongToSVBT32( pA->nSepxFcPos, aSed.fcSepx );	// Sepx-Pos
+		UInt32ToSVBT32( pA->nSepxFcPos, aSed.fcSepx );	// Sepx-Pos
 		rWrt.pTableStrm->Write( &aSed, sizeof( aSed ) );
 	}
 	rWrt.pFib->fcPlcfsed = nFcStart;
--- binfilter/bf_sw/source/filter/ww8/sw_wrtww8.cxx	2005-09-09 05:31:01.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_wrtww8.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -766,7 +766,7 @@ void WW8_WrMagicTable::Append( WW8_CP nC
     */
     if ((!Count()) || (Prev() != nCp))
     {
-        LongToSVBT32(nData,nLittle);
+        UInt32ToSVBT32(nData,nLittle);
         WW8_WrPlc1::Append(nCp, nLittle);
     }
 }
@@ -1108,7 +1108,7 @@ void WW8_WrFkp::Write( SvStream& rStrm, 
 			continue;
 
 		SVBT32 nPos;				// Signatur gefunden
-		LongToSVBT32( rGrf.GetFPos(), nPos );	// FilePos der Grafik
+		UInt32ToSVBT32( rGrf.GetFPos(), nPos );	// FilePos der Grafik
 		memcpy( p, nPos, 4 );		// Patche FilePos ueber Signatur
 	}
 	rStrm.Write( pFkp, 512 );
@@ -1164,14 +1164,14 @@ WW8_FC WW8_WrFkp::GetStartFc() const
 // umgedreht, d.h. zum Herausholen der Anfangs- und Endpositionen muss
 // zurueckgedreht werden.
 	if( bCombined )
-		return SVBT32ToLong( pFkp );		// 0. Element
+		return SVBT32ToUInt32( pFkp );		// 0. Element
 	return ((INT32*)pFkp)[0];
 }
 
 WW8_FC WW8_WrFkp::GetEndFc() const
 {
 	if( bCombined )
-		return SVBT32ToLong( &(pFkp[nIMax*4]) );	// nIMax-tes SVBT32-Element
+		return SVBT32ToUInt32( &(pFkp[nIMax*4]) );	// nIMax-tes SVBT32-Element
 	return ((INT32*)pFkp)[nIMax];
 }
 
@@ -1578,7 +1578,7 @@ void SwWW8Writer::InsUInt16(ww::bytes &r
 void SwWW8Writer::InsUInt32(ww::bytes &rO, sal_uInt32 n)
 {
 	SVBT32 nL;
-	LongToSVBT32( n, nL );
+	UInt32ToSVBT32( n, nL );
 	rO.push_back(nL[0]);
 	rO.push_back(nL[1]);
 	rO.push_back(nL[2]);
@@ -1618,7 +1618,7 @@ void SwWW8Writer::InsUInt16( WW8Bytes& r
 void SwWW8Writer::InsUInt32( WW8Bytes& rO, UINT32 n )
 {
 	SVBT32 nL;
-	LongToSVBT32( n, nL );
+	UInt32ToSVBT32( n, nL );
 	rO.Insert( nL, 4, rO.Count() );
 }
 
--- binfilter/bf_sw/source/filter/ww8/sw_wrtww8gr.cxx	2005-09-09 05:31:15.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_wrtww8gr.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -773,7 +773,7 @@ void SwWW8WrGrf::WriteGraphicNode(SvStre
 	UINT32 nPos2 = rStrm.Tell();					// Ende merken
 	rStrm.Seek( nPos );
 	SVBT32 nLen;
-	LongToSVBT32( nPos2 - nPos, nLen );				// Grafik-Laenge ausrechnen
+	UInt32ToSVBT32( nPos2 - nPos, nLen );				// Grafik-Laenge ausrechnen
 	rStrm.Write( nLen, 4 );							// im Header einpatchen
 	rStrm.Seek( nPos2 );							// Pos wiederherstellen
 }
--- binfilter/bf_sw/source/filter/ww8/sw_ww8glsy.cxx	2005-09-09 05:31:47.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8glsy.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -312,7 +312,7 @@ UINT32 WW8GlossaryFib::FindGlossaryFibOf
 	long start,ende;
 	void *pData;
 	aPlc.Get(start,ende,pData);
-	UINT32 nPo = SVBT32ToLong((BYTE *)pData+2);
+	UINT32 nPo = SVBT32ToUInt32((BYTE *)pData+2);
 	//*pOut << hex << "Offset of last SEPX is " << nPo << endl;
 
 	UINT16 nLen;
@@ -345,14 +345,14 @@ UINT32 WW8GlossaryFib::FindGlossaryFibOf
 
 	xcPLCF.Get(start,ende,pData);
 
-	nPo = SVBT32ToLong((BYTE *)pData);
+	nPo = SVBT32ToUInt32((BYTE *)pData);
 	//*pOut << hex << "Offset of last CHPX is " << (nPo+1) *512<< endl;
 	if (((nPo+1)*512) > nEndLastPage) nEndLastPage = (nPo+1)*512;
 
 	WW8PLCF xpPLCF( &rTableStrm, rFib.fcPlcfbtePapx,
 			rFib.lcbPlcfbtePapx, (8 > rFib.nVersion) ? 2 : 4);
 	xpPLCF.Get(start,ende,pData);
-	nPo = SVBT32ToLong((BYTE *)pData);
+	nPo = SVBT32ToUInt32((BYTE *)pData);
 	//*pOut << hex << "Offset of last PAPX is " << nPo *512 << endl;
 	if (((nPo+1)*512) > nEndLastPage) nEndLastPage = (nPo+1)*512;
 
--- binfilter/bf_sw/source/filter/ww8/sw_ww8graf.cxx	2005-09-09 05:32:01.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8graf.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -1524,13 +1524,13 @@ void SwWW8ImplReader::ReadGrafLayer1( WW
 		return;
 	}
 	WW8_FDOA* pF = (WW8_FDOA*)pF0;
-	if( !SVBT32ToLong( pF->fc ) )
+	if( !SVBT32ToUInt32( pF->fc ) )
 	{
 		ASSERT( !this, "+Wo ist die Grafik (3) ?" );
 		return;
 	}
 	WW8_DO aDo;
-	pStrm->Seek( SVBT32ToLong( pF->fc ) );           		// Lese Draw-Header
+	pStrm->Seek( SVBT32ToUInt32( pF->fc ) );           		// Lese Draw-Header
 	pStrm->Read( &aDo, sizeof( WW8_DO ) );
 
 	short nLeft = SVBT16ToShort( aDo.cb ) - sizeof( WW8_DO );
--- binfilter/bf_sw/source/filter/ww8/sw_ww8graf2.cxx	2005-09-09 05:32:14.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8graf2.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -833,7 +833,7 @@ SwFrmFmt* SwWW8ImplReader::ImportGraf(Sd
 
 void WW8PicShadowToReal( WW8_PIC_SHADOW * pPicS, WW8_PIC * pPic )
 {
-	pPic->lcb = SVBT32ToLong( pPicS->lcb );
+	pPic->lcb = SVBT32ToUInt32( pPicS->lcb );
 	pPic->cbHeader = SVBT16ToShort( pPicS->cbHeader );
 	pPic->MFP.mm = SVBT16ToShort( pPicS->MFP.mm );
 	pPic->MFP.xExt = SVBT16ToShort( pPicS->MFP.xExt );
@@ -874,11 +874,11 @@ void WW8FSPAShadowToReal( WW8_FSPA_SHADO
 	//long nTxbx; //count of textboxes in shape (undo doc only)
 
 
-	pFSPA->nSpId		= SVBT32ToLong( pFSPAS->nSpId );
-	pFSPA->nXaLeft		= SVBT32ToLong( pFSPAS->nXaLeft );
-	pFSPA->nYaTop		= SVBT32ToLong( pFSPAS->nYaTop );
-	pFSPA->nXaRight		= SVBT32ToLong( pFSPAS->nXaRight );
-	pFSPA->nYaBottom	= SVBT32ToLong( pFSPAS->nYaBottom );
+	pFSPA->nSpId		= SVBT32ToUInt32( pFSPAS->nSpId );
+	pFSPA->nXaLeft		= SVBT32ToUInt32( pFSPAS->nXaLeft );
+	pFSPA->nYaTop		= SVBT32ToUInt32( pFSPAS->nYaTop );
+	pFSPA->nXaRight		= SVBT32ToUInt32( pFSPAS->nXaRight );
+	pFSPA->nYaBottom	= SVBT32ToUInt32( pFSPAS->nYaBottom );
 
 	USHORT nBits		= SVBT16ToShort( pFSPAS->aBits1 );
 
@@ -890,7 +890,7 @@ void WW8FSPAShadowToReal( WW8_FSPA_SHADO
 	pFSPA->bRcaSimple	= 0 !=	( nBits & 0x2000 );
 	pFSPA->bBelowText	= 0 !=	( nBits & 0x4000 );
 	pFSPA->bAnchorLock	= 0 !=	( nBits & 0x8000 );
-	pFSPA->nTxbx = SVBT32ToLong( pFSPAS->nTxbx );
+	pFSPA->nTxbx = SVBT32ToUInt32( pFSPAS->nTxbx );
 }
 #endif // defined __WW8_NEEDS_COPY
 
--- binfilter/bf_sw/source/filter/ww8/sw_ww8par.cxx	2005-09-09 05:32:29.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8par.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -3340,7 +3340,7 @@ BOOL SwMSDffManager::GetOLEStorageName(l
 
 						if( 0x6A03 == nId && 0 < nLen )
 						{
-                            nPictureId = SVBT32ToLong(pSprm +
+                            nPictureId = SVBT32ToUInt32(pSprm +
                                 aSprmParser.DistanceToData(nId));
 							bRet = true;
 						}
--- binfilter/bf_sw/source/filter/ww8/sw_ww8par4.cxx	2005-09-09 05:33:16.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8par4.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -828,7 +828,7 @@ void SwWW8ImplReader::Read_CRevisionMark
 		{
 			if (const WW8AuthorInfo* pAuthor = pAuthorInfos->GetObject(nPos))
 			{
-                UINT32 nWWDate = pSprmCDttmRMark ? SVBT32ToLong(pSprmCDttmRMark): 0;
+                UINT32 nWWDate = pSprmCDttmRMark ? SVBT32ToUInt32(pSprmCDttmRMark): 0;
 #if 0
                 ASSERT(nWWDate, "Date is 0, this will cause trouble!");
 #endif
--- binfilter/bf_sw/source/filter/ww8/sw_ww8par6.cxx	2005-09-09 05:33:47.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8par6.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -1069,7 +1069,7 @@ void wwSectionManager::CreateSep(const l
         aNewSection.maSep.clm = ReadULSprm( pSep, 0x5032, 0 );
         aNewSection.maSep.dyaLinePitch = ReadULSprm(pSep, 0x9031, 360);
 	    if (const BYTE* pS = pSep->HasSprm(0x7030))
-            aNewSection.maSep.dxtCharSpace = SVBT32ToLong(pS);
+            aNewSection.maSep.dxtCharSpace = SVBT32ToUInt32(pS);
 
 		//sprmSPgbProp
 		sal_uInt16 pgbProp = ReadSprm( pSep, 0x522F, 0 );
@@ -2637,7 +2637,7 @@ void SwWW8ImplReader::Read_PicLoc(USHORT
 	}
 	else
 	{
-		nPicLocFc = SVBT32ToLong( pData );
+		nPicLocFc = SVBT32ToUInt32( pData );
 		bSpec = true;
 
 		if( bObj && nPicLocFc && bEmbeddObj )
@@ -3182,7 +3182,7 @@ void SwWW8ImplReader::Read_TxtForeColor(
 		pCtrlStck->SetAttr( *pPaM->GetPoint(), RES_CHRATR_COLOR );
 	else
 	{
-		Color aColor(wwUtility::BGRToRGB(SVBT32ToLong(pData)));
+		Color aColor(wwUtility::BGRToRGB(SVBT32ToUInt32(pData)));
 		NewAttr(SvxColorItem(aColor));
 		if (pAktColl && pStyles)
 			pStyles->bTxtColChanged = true;
@@ -4471,10 +4471,10 @@ void SwWW8ImplReader::Read_ParaBackColor
 sal_uInt32 SwWW8ImplReader::ExtractColour(const BYTE* &rpData, bool bVer67)
 {
     ASSERT(bVer67 == false, "Impossible");
-    //ASSERT(SVBT32ToLong(rpData) == 0xFF000000, "Unknown 1 not 0xff000000");
-    sal_uInt32 nFore = wwUtility::BGRToRGB(SVBT32ToLong(rpData));
+    //ASSERT(SVBT32ToUInt32(rpData) == 0xFF000000, "Unknown 1 not 0xff000000");
+    sal_uInt32 nFore = wwUtility::BGRToRGB(SVBT32ToUInt32(rpData));
     rpData+=4;
-    sal_uInt32 nBack = wwUtility::BGRToRGB(SVBT32ToLong(rpData));
+    sal_uInt32 nBack = wwUtility::BGRToRGB(SVBT32ToUInt32(rpData));
     rpData+=4;
     sal_uInt16 nIndex = SVBT16ToShort(rpData);
     rpData+=2;
--- binfilter/bf_sw/source/filter/ww8/sw_ww8scan.cxx	2005-09-09 05:34:03.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/sw_ww8scan.cxx	2006-03-28 19:33:35.000000000 +0200
@@ -806,7 +806,7 @@ inline short Get_Short( BYTE *& p )
 
 inline ULONG Get_ULong( BYTE *& p )
 {
-    ULONG n = SVBT32ToLong( *(SVBT32*)p );
+    ULONG n = SVBT32ToUInt32( *(SVBT32*)p );
     p += 4;
     return n;
 }
@@ -1149,7 +1149,7 @@ WW8_FC WW8PLCFx_PCD::AktPieceStartCp2Fc(
 		nCp = nCpEnd - 1;
 
 	bool bIsUnicode = false;
-	WW8_FC nFC = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+	WW8_FC nFC = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 	if( !bVer67 )
 		nFC = WW8PLCFx_PCD::TransformPieceAddress( nFC, bIsUnicode );
 
@@ -1178,7 +1178,7 @@ WW8_CP WW8PLCFx_PCD::AktPieceStartFc2Cp(
 		return LONG_MAX;
 	}
 	bool bIsUnicode = false;
-	INT32 nFcStart  = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+	INT32 nFcStart  = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 	if( !bVer67 )
 		nFcStart = WW8PLCFx_PCD::TransformPieceAddress( nFcStart, bIsUnicode );
 
@@ -1467,7 +1467,7 @@ WW8_CP WW8ScannerBase::WW8Fc2Cp( WW8_FC 
 				ASSERT( !this, "PLCFpcd-WW8Fc2Cp() ging schief" );
 				break;
 			}
-			INT32 nFcStart  = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+			INT32 nFcStart  = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 			if( 8 <= pWw8Fib->nVersion )
 				nFcStart = WW8PLCFx_PCD::TransformPieceAddress( nFcStart,
 																bIsUnicode );
@@ -1548,7 +1548,7 @@ WW8_FC WW8ScannerBase::WW8Cp2Fc(WW8_CP n
 		if( pNextPieceCp )
 			*pNextPieceCp = nCpEnd;
 
-		WW8_FC nRet = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+		WW8_FC nRet = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 		if (8 > pWw8Fib->nVersion)
 			*pIsUnicode = false;
 		else
@@ -2466,7 +2466,7 @@ WW8PLCFx_Fc_FKP::WW8Fkp::WW8Fkp(BYTE nFi
                     {
                         UINT32 nCurr = pDataSt->Tell();
 
-                        UINT32 nPos = SVBT32ToLong(aEntry.mpData + 2);
+                        UINT32 nPos = SVBT32ToUInt32(aEntry.mpData + 2);
                         pDataSt->Seek(nPos);
                         *pDataSt >> aEntry.mnLen;
                         aEntry.mpData = new sal_uInt8[aEntry.mnLen];
@@ -3111,7 +3111,7 @@ void WW8PLCFx_Cp_FKP::GetSprms(WW8PLCFxD
 				void* pData;
 				pPieceIter->Get(nCpStart, nCpEnd, pData);
 
-				WW8_FC nLimitFC = SVBT32ToLong( ((WW8_PCD*)pData)->fc );
+				WW8_FC nLimitFC = SVBT32ToUInt32( ((WW8_PCD*)pData)->fc );
 				WW8_FC nBeginLimitFC = nLimitFC;
 				if( 8 <= GetVersion() )
 				{
@@ -3162,7 +3162,7 @@ void WW8PLCFx_Cp_FKP::GetSprms(WW8PLCFxD
 								break;
 							}
 							bIsUnicode = false;
-							INT32 nFcStart=SVBT32ToLong(((WW8_PCD*)pData)->fc);
+							INT32 nFcStart=SVBT32ToUInt32(((WW8_PCD*)pData)->fc);
 
 							if( 8 <= GetVersion() )
 							{
@@ -3288,7 +3288,7 @@ void WW8PLCFx_SEPX::GetSprms(WW8PLCFxDes
 	}
 	else
 	{
-		long nPo =  SVBT32ToLong( (BYTE*)pData+2 );
+		long nPo =  SVBT32ToUInt32( (BYTE*)pData+2 );
 		if (nPo == -1L)
 		{
 			p->nStartPos = p->nEndPos = LONG_MAX;		// Sepx empty
--- binfilter/bf_sw/source/filter/ww8/ww8struc.hxx	2005-09-09 05:35:42.000000000 +0200
+++ binfilter/bf_sw/source/filter/ww8/ww8struc.hxx	2006-03-28 19:33:35.000000000 +0200
@@ -74,7 +74,7 @@ inline void Set_UInt16( BYTE *& p, UINT1
 
 inline void Set_UInt32( BYTE *& p, UINT32 n )
 { 
-    LongToSVBT32( n, *(SVBT32*)p );  
+    UInt32ToSVBT32( n, *(SVBT32*)p );  
     p+= 4; 
 }
 
