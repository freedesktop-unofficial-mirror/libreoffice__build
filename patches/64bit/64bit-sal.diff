Index: sal/cpprt/operators_new_delete.cxx
===================================================================
RCS file: /cvs/porting/sal/cpprt/operators_new_delete.cxx,v
retrieving revision 1.3
retrieving revision 1.3.206.1
diff -u -p -r1.3 -r1.3.206.1
--- sal/cpprt/operators_new_delete.cxx	15 Apr 2003 17:40:45 -0000	1.3
+++ sal/cpprt/operators_new_delete.cxx	25 Aug 2004 16:46:45 -0000	1.3.206.1
@@ -180,7 +180,7 @@ static void* allocate (
 	n = rTraits.size (n);
 	for (;;)
 	{
-		void * p = rtl_allocateMemory (sal_uInt32(n));
+		void * p = rtl_allocateMemory (sal_Size(n));
 		if (p != 0)
 			return rTraits.init (p);
 
Index: sal/inc/sal/types.h
===================================================================
RCS file: /cvs/porting/sal/inc/sal/types.h,v
retrieving revision 1.24
retrieving revision 1.23.4.5
diff -u -p -r1.24 -r1.23.4.5
--- sal/inc/sal/types.h	23 Aug 2004 09:43:33 -0000	1.24
+++ sal/inc/sal/types.h	18 Oct 2004 16:28:28 -0000	1.23.4.5
@@ -121,7 +121,15 @@ typedef unsigned char       sal_uInt8;
 	#define SAL_CONST_INT64(x)       x##i64
 	#define SAL_CONST_UINT64(x)      x##ui64
 #elif defined(__SUNPRO_CC) || defined(__SUNPRO_C) || defined (__GNUC__) || defined(__hpux) || defined (sgi)
-	#if SAL_TYPES_SIZEOFLONGLONG == 8
+	#if SAL_TYPES_SIZEOFLONG == 8
+		typedef signed long int         sal_Int64;
+		typedef unsigned long int       sal_uInt64;
+
+
+		/*  The following are macros that will add the 64 bit constant suffix. */
+		#define SAL_CONST_INT64(x)       x##l
+		#define SAL_CONST_UINT64(x)      x##ul
+	#elif SAL_TYPES_SIZEOFLONGLONG == 8
 		typedef signed long long    sal_Int64;
 		typedef unsigned long long  sal_uInt64;
 
@@ -129,14 +137,6 @@ typedef unsigned char       sal_uInt8;
 		#define SAL_CONST_INT64(x)       x##ll
 		#define SAL_CONST_UINT64(x)      x##ull
 
-	#elif SAL_TYPES_SIZEOFLONG == 8
-		typedef signed long         sal_Int64;
-		typedef unsigned long       sal_uInt64;
-
-
-		/*  The following are macros that will add the 64 bit constant suffix. */
-		#define SAL_CONST_INT64(x)       x##l
-		#define SAL_CONST_UINT64(x)      x##ul
 	#else
 		#error "Could not find 64-bit type, add support for your architecture"
 	#endif
@@ -158,16 +158,37 @@ typedef unsigned char            sal_uCh
 typedef void *                   sal_Handle;
 
 /* sal_Size should currently be the native width of the platform */
-#if SAL_TYPES_SIZEOFLONG == 4
+#if SAL_TYPES_SIZEOFPOINTER == 4
 	typedef sal_uInt32          sal_Size;
 	typedef sal_Int32           sal_sSize;
-#elif SAL_TYPES_SIZEOFLONG == 8
+#elif SAL_TYPES_SIZEOFPOINTER == 8
 	typedef sal_uInt64          sal_Size;
 	typedef sal_Int64           sal_sSize;
 #else
-	#error "Please make sure SAL_TYPES_SIZEOFLONG is defined for your architecture/compiler"
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
 #endif
   
+/* sal_PtrDiff holds the result of a pointer subtraction */
+#if SAL_TYPES_SIZEOFPOINTER == 4
+    typedef sal_Int32           sal_PtrDiff;
+#elif SAL_TYPES_SIZEOFPOINTER == 8
+	typedef sal_Int64           sal_PtrDiff;
+#else
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
+#endif
+
+/* sal_IntPtr, sal_uIntPtr are integer types designed to hold pointers so that any valid
+ * pointer to void can be converted to this type and back to a pointer to void and the 
+ * result will compare to the original pointer */
+#if SAL_TYPES_SIZEOFPOINTER == 4
+	typedef sal_Int32           sal_IntPtr;
+	typedef sal_uInt32          sal_uIntPtr;
+#elif SAL_TYPES_SIZEOFPOINTER == 8
+	typedef sal_Int64           sal_IntPtr;
+	typedef sal_uInt64          sal_uIntPtr;
+#else
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
+#endif
 
 /********************************************************************************/
 /* Useful defines
@@ -190,7 +211,15 @@ typedef void *                   sal_Han
 #define SAL_MIN_INT64         ((sal_Int64)  (SAL_CONST_INT64(-0x7FFFFFFFFFFFFFFF) - 1))
 #define SAL_MAX_INT64         ((sal_Int64)  SAL_CONST_INT64(0x7FFFFFFFFFFFFFFF))
 #define SAL_MAX_UINT64        ((sal_uInt64) SAL_CONST_UINT64(0xFFFFFFFFFFFFFFFF))
-  
+
+#if SAL_TYPES_SIZEOFLONG == 4
+#define SAL_MAX_SSIZE		SAL_MAX_INT32
+#define SAL_MAX_SIZE		SAL_MAX_UINT32
+#elif SAL_TYPES_SIZEOFLONG == 8
+#define SAL_MAX_SSIZE		SAL_MAX_INT64
+#define SAL_MAX_SIZE		SAL_MAX_UINT64
+#endif
+
 #if defined(SAL_W32) || defined(SAL_OS2) || defined(SAL_UNX)
 #   define SAL_MAX_ENUM 0x7fffffff
 #elif defined(SAL_W16)
Index: sal/osl/unx/backtrace.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/backtrace.c,v
retrieving revision 1.6
retrieving revision 1.6.62.1
diff -u -p -r1.6 -r1.6.62.1
--- sal/osl/unx/backtrace.c	4 Feb 2004 13:48:44 -0000	1.6
+++ sal/osl/unx/backtrace.c	25 Aug 2004 18:46:23 -0000	1.6.62.1
@@ -74,11 +74,19 @@
 #define FRAME_PTR_OFFSET 1
 #define FRAME_OFFSET 0
 
+#if defined(__sparcv9)
+#define STACK_BIAS 0x7ff
+#else
+#define STACK_BIAS 0
+#endif
+
 #elif defined( INTEL )
 
 #define FRAME_PTR_OFFSET 3
 #define FRAME_OFFSET 1
 
+#define STACK_BIAS 0
+
 #else
 
 #error Unknown Solaris target platform. 
@@ -88,27 +96,32 @@
 
 int backtrace( void **buffer, int max_frames )
 {
-	struct frame *fp;
-	jmp_buf ctx;
-	int i;
+	jmp_buf        ctx;
+    long           fpval;
+	struct frame * fp;
+	int            i;
 
 	/* flush register windows */
 #ifdef SPARC
 	asm("ta 3");
 #endif
+
 	/* get stack- and framepointer */
 	setjmp(ctx);
-	fp = (struct frame*)(((size_t*)(ctx))[FRAME_PTR_OFFSET]);
-	for ( i=0; (i<FRAME_OFFSET) && (fp!=0); i++)
-		fp = fp->fr_savfp;
+	fpval = ((long*)(ctx))[FRAME_PTR_OFFSET];
+
+	fp = (struct frame*)((char*)(fpval) + STACK_BIAS);
+	for ( i=0; (i < FRAME_OFFSET) && (fp != 0); i++)
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 
 	/* iterate through backtrace */
-	for (i=0; fp && fp->fr_savpc && i<max_frames; i++)
+	for (i = 0; fp && fp->fr_savpc && i < max_frames; i++)
 	{
 		/* store frame */
-		*(buffer++) = (void *)fp->fr_savpc;
+		*(buffer++) = (void *)(fp->fr_savpc);
+
 		/* next frame */
-		fp=fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 	}
 	return i;
 }
Index: sal/osl/unx/diagnose.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/diagnose.c,v
retrieving revision 1.13
retrieving revision 1.12.202.2
diff -u -p -r1.13 -r1.12.202.2
--- sal/osl/unx/diagnose.c	25 Jun 2004 18:36:24 -0000	1.13
+++ sal/osl/unx/diagnose.c	18 Oct 2004 16:31:47 -0000	1.12.202.2
@@ -186,32 +186,43 @@ static void osl_diagnose_backtrace_Impl 
 #define FRAME_PTR_OFFSET 1
 #define FRAME_OFFSET 0
 
+#if defined(__sparcv9)
+#define STACK_BIAS 0x7ff
+#else
+#define STACK_BIAS 0
+#endif
+
 #elif defined(INTEL)
 
 #define FRAME_PTR_OFFSET 3
 #define FRAME_OFFSET 1
 
+#define STACK_BIAS 0
+
 #endif /* (SPARC || INTEL) */
 
 static void osl_diagnose_backtrace_Impl (oslDebugMessageFunc f)
 {
-	struct frame * fp;
 	jmp_buf        ctx;
+	long           fpval;
+	struct frame * fp;
 	int            i;
 
 #if defined(SPARC)
 	asm("ta 3");
 #endif /* SPARC */
+
 	setjmp (ctx);
-	fp = (struct frame*)(((size_t*)(ctx))[FRAME_PTR_OFFSET]);
+	fpval = ((long*)(ctx))[FRAME_PTR_OFFSET];
 
+	fp = (struct frame*)((char*)(fpval) + STACK_BIAS);
 	for (i = 0; (i < FRAME_OFFSET) && (fp != 0); i++)
-		fp = fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 
 	for (i = 0; fp && fp->fr_savpc; i++)
 	{
 		osl_diagnose_frame_Impl (f, i, (void*)(fp->fr_savpc));
-		fp = fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 	}
 }
 
Index: sal/osl/unx/makefile.mk
===================================================================
RCS file: /cvs/porting/sal/osl/unx/makefile.mk,v
retrieving revision 1.25
retrieving revision 1.25.62.1
diff -u -p -r1.25 -r1.25.62.1
--- sal/osl/unx/makefile.mk	4 Feb 2004 15:30:47 -0000	1.25
+++ sal/osl/unx/makefile.mk	18 Aug 2004 13:19:07 -0000	1.25.62.1
@@ -150,7 +150,7 @@ APP1STDLIBS+=-lC
 
 .INCLUDE :  target.mk
 
-.IF "$(OS)$(CPU)"=="SOLARISS" || "$(OS)$(CPU)"=="NETBSDS" || "$(OS)$(CPU)"=="LINUXS"
+.IF "$(OS)$(CPU)"=="SOLARISS" || "$(OS)$(CPU)"=="SOLARISS64B" || "$(OS)$(CPU)"=="NETBSDS" || "$(OS)$(CPU)"=="LINUXS" 
 
 $(SLO)$/interlck.obj: $(SLO)$/interlck.o
 	 touch $(SLO)$/interlck.obj
Index: sal/osl/unx/util.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/util.c,v
retrieving revision 1.8
retrieving revision 1.6.62.2
diff -u -p -r1.8 -r1.6.62.2
--- sal/osl/unx/util.c	8 Sep 2004 16:44:30 -0000	1.8
+++ sal/osl/unx/util.c	18 Oct 2004 16:30:55 -0000	1.6.62.2
Index: sal/osl/unx/asm/interlck_sparc.s
===================================================================
RCS file: /cvs/porting/sal/osl/unx/asm/interlck_sparc.s,v
retrieving revision 1.5
retrieving revision 1.3.196.2
diff -u -p -r1.5 -r1.3.196.2
--- sal/osl/unx/asm/interlck_sparc.s	9 Sep 2004 11:45:50 -0000	1.5
+++ sal/osl/unx/asm/interlck_sparc.s	18 Oct 2004 16:32:13 -0000	1.3.196.2
Index: sal/rtl/source/macro.hxx
===================================================================
RCS file: /cvs/porting/sal/rtl/source/macro.hxx,v
retrieving revision 1.3
retrieving revision 1.3.12.1
diff -u -p -r1.3 -r1.3.12.1
--- sal/rtl/source/macro.hxx	11 Jun 2004 11:56:30 -0000	1.3
+++ sal/rtl/source/macro.hxx	1 Jul 2004 16:08:04 -0000	1.3.12.1
@@ -96,6 +96,8 @@ this is inserted for the case that the p
 #define THIS_ARCH "SPARC"
 #elif defined IRIX
 #define THIS_ARCH "MIPS"
+#elif defined X86_64
+#define THIS_ARCH "X86_64"
 #endif
 
 #if ! defined THIS_ARCH
Index: sal/textenc/convertsinglebytetobmpunicode.cxx
===================================================================
RCS file: /cvs/porting/sal/textenc/convertsinglebytetobmpunicode.cxx,v
retrieving revision 1.2
retrieving revision 1.2.4.1
diff -u -p -r1.2 -r1.2.4.1
--- sal/textenc/convertsinglebytetobmpunicode.cxx	17 Jun 2004 11:41:43 -0000	1.2
+++ sal/textenc/convertsinglebytetobmpunicode.cxx	1 Jul 2004 16:08:04 -0000	1.2.4.1
@@ -164,7 +164,8 @@ sal_Size rtl_textenc_convertBmpUnicodeTo
         }
         // Linearly searching through the ranges if probably fastest, assuming
         // that most converted characters belong to the ASCII subset:
-        for (std::size_t i = 0; i < entries; ++i) {
+	sal_Size i;
+        for (i = 0; i < entries; ++i) {
             if (c < ranges[i].unicode) {
                 break;
             } else if (c <= ranges[i].unicode + ranges[i].range) {
Index: sal/workben/makefile.mk
===================================================================
RCS file: /cvs/porting/sal/workben/makefile.mk,v
retrieving revision 1.12
retrieving revision 1.12.172.1
diff -u -p -r1.12 -r1.12.172.1
--- sal/workben/makefile.mk	12 Jun 2003 09:47:35 -0000	1.12
+++ sal/workben/makefile.mk	25 Aug 2004 16:34:21 -0000	1.12.172.1
@@ -66,29 +66,25 @@ PRJNAME=sal
 TARGET=workben
 LIBTARGET=NO
 TARGETTYPE=CUI
+NO_DEFAULT_STL=TRUE
 ENABLE_EXCEPTIONS=TRUE
 
-TESTAPP=test_osl_getVolInfo
-#TESTAPP=test_osl_joinProcess
-#TESTAPP=getlocaleinfotest
+#TESTAPP=test_osl_getVolInfo
 #TESTAPP=test_osl_joinProcess
 #TESTAPP=getlocaleinfotest
 #TESTAPP=salstattest
 #TESTAPP=saldyntest
 
+TESTAPP=t_alloc
 #TESTAPP=t_cipher
 #TESTAPP=t_digest
 #TESTAPP=t_random
-#TESTAPP=t_layer
-#TESTAPP=t_tls
-#TESTAPP=t_zip
 
 #TESTAPP=testfile
 #TESTAPP=testpipe
 #TESTAPP=testpip2
 #TESTAPP=testproc
 #TESTAPP=tgetpwnam
-#TESTAPP=salstattest
 
 # --- Settings -----------------------------------------------------
 
@@ -96,6 +92,9 @@ TESTAPP=test_osl_getVolInfo
 
 # --- Files --------------------------------------------------------
 
+#
+# test_osl_getVolInfo.
+#
 .IF "$(TESTAPP)" == "test_osl_getVolInfo"    
 
 SHL1OBJS=$(SLO)$/t_osl_getVolInfo.obj
@@ -111,14 +110,19 @@ SHL1STDLIBS+=$(SOLARLIBDIR)$/cppunit.lib
 SHL1STDLIBS=$(LB)$/libsal.so
 SHL1STDLIBS+=$(SOLARLIBDIR)$/libcppunit$(DLLPOSTFIX).a
 .ENDIF
-	
+
 SHL1IMPLIB=i$(SHL1TARGET) 
 SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 DEF1NAME=$(SHL1TARGET) 
 DEF1EXPORTFILE=export.exp
-.ENDIF
 
+.ENDIF # test_osl_getVolInfo
+
+#
+# test_osl_joinProcess.
+#
 .IF "$(TESTAPP)" == "test_osl_joinProcess"    
+
 OBJFILES=$(OBJ)$/t_ojp_exe.obj 
 APP1TARGET=ojpx
 APP1OBJS=$(OBJFILES)
@@ -140,13 +144,17 @@ SHL1STDLIBS+=$(SOLARLIBDIR)$/cppunit.lib
 SHL1STDLIBS=$(LB)$/libsal.so
 SHL1STDLIBS+=$(SOLARLIBDIR)$/libcppunit$(DLLPOSTFIX).a
 .ENDIF
-	
+
 SHL1IMPLIB=i$(SHL1TARGET) 
 SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 DEF1NAME=$(SHL1TARGET) 
 DEF1EXPORTFILE=export.exp
-.ENDIF
 
+.ENDIF # test_osl_joinProcess
+
+#
+# getlocaleinfotest.
+#
 .IF "$(TESTAPP)" == "getlocaleinfotest"
 
 	OBJFILES=$(OBJ)$/getlocaleinfotest.obj
@@ -163,8 +171,11 @@ DEF1EXPORTFILE=export.exp
 
 	APP1DEPN=$(LB)$/isal.lib
 
-.ENDIF
+.ENDIF # getlocaleinfotest
 
+#
+# salstattest.
+#
 .IF "$(TESTAPP)" == "salstattest"
 
 	CFLAGS+= -DUSE_SAL_STATIC
@@ -184,6 +195,9 @@ DEF1EXPORTFILE=export.exp
 
 .ENDIF # salstattest
 
+#
+# saldyntest.
+#
 .IF "$(TESTAPP)" == "saldyntest"
 
 	OBJFILES=	$(OBJ)$/saldyntest.obj
@@ -202,6 +216,25 @@ DEF1EXPORTFILE=export.exp
 .ENDIF # salstattest
 
 #
+# t_alloc.
+#
+.IF "$(TESTAPP)" == "t_alloc"
+
+CFILES=		t_alloc.c
+OBJFILES=	$(OBJ)$/t_alloc.obj
+
+APP1TARGET=	t_alloc
+APP1OBJS=	$(OBJFILES)
+APP1OBJS+=	$(SLO)$/alloc.o $(SLO)$/diagnose.o
+APP1STDLIBS=
+APP1DEPN=
+
+APP1LIBSALCPPRT=$(0)
+STDLIBCUIMT+=-lc -ldl
+
+.ENDIF # t_alloc
+
+#
 # t_cipher
 #
 .IF "$(TESTAPP)" == "t_cipher"
@@ -247,75 +280,6 @@ APP3DEPN=	$(SLB)$/sal.lib
 .ENDIF # t_random
 
 #
-# t_layer.
-#
-.IF "$(TESTAPP)" == "t_layer"
-
-CFILES=		t_layer.c
-OBJFILES=	$(OBJ)$/t_layer.obj
-
-APP4TARGET=	t_layer
-APP4OBJS=	$(OBJFILES)
-APP4STDLIBS=$(SALLIB)
-APP4DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_layer
-
-#
-# t_tls.
-#
-.IF "$(TESTAPP)" == "t_tls"
-
-CFILES=		t_tls.c
-OBJFILES=	$(OBJ)$/t_tls.obj
-
-.IF "$(SALTLSLIB)" == ""
-
-.IF "$(GUI)" == "UNX"
-SALTLSLIB=		-lsaltls2
-.ENDIF # unx
-
-.IF "$(GUI)" == "WNT"
-SALTLSLIB=		isaltls.lib
-.ENDIF # wnt
-
-.ENDIF # saltlslib
-
-APP5TARGET=	t_tls
-APP5OBJS=	$(OBJFILES)
-APP5STDLIBS=$(SALTLSLIB) $(SALLIB)
-APP5DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_tls
-
-#
-# t_zip.
-#
-.IF "$(TESTAPP)" == "t_zip"
-
-CFILES=		t_zip.c
-OBJFILES=	$(OBJ)$/t_zip.obj
-
-.IF "$(SALZIPLIB)" == ""
-
-.IF "$(GUI)" == "UNX"
-SALZIPLIB=	-lsalzip2
-.ENDIF # unx
-
-.IF "$(GUI)" == "WNT"
-SALZIPLIB=	isalzip.lib
-.ENDIF # wnt
-
-.ENDIF # salziplib
-
-APP6TARGET=	t_zip
-APP6OBJS=	$(OBJFILES)
-APP6STDLIBS=$(SALZIPLIB) $(SALLIB)
-APP6DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_zip
-
-#
 # testfile
 #
 .IF "$(TESTAPP)" == "testfile"
@@ -338,10 +302,10 @@ APP1DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testpipe.cxx
 OBJFILES=	$(OBJ)$/testpipe.obj
 
-APP2TARGET= testpipe
-APP2OBJS=   $(OBJFILES)
-APP2STDLIBS=$(SALLIB)
-APP2DEPN=	$(SLB)$/sal.lib
+APP1TARGET= testpipe
+APP1OBJS=   $(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testpipe
 
@@ -353,10 +317,10 @@ APP2DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testpip2.cxx
 OBJFILES=	$(OBJ)$/testpip2.obj
 
-APP3TARGET=	testpip2
-APP3OBJS=	$(OBJFILES)
-APP3STDLIBS=$(SALLIB)
-APP3DEPN=	$(SLB)$/sal.lib
+APP1TARGET=	testpip2
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testpip2
 
@@ -368,10 +332,10 @@ APP3DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testproc.cxx
 OBJFILES=	$(OBJ)$/testproc.obj
 
-APP4TARGET= testproc
-APP4OBJS=	$(OBJFILES)
-APP4STDLIBS=$(SALLIB)
-APP4DEPN=	$(SLB)$/sal.lib
+APP1TARGET= testproc
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testproc
 
@@ -384,10 +348,10 @@ APP4DEPN=	$(SLB)$/sal.lib
 CXXFILES=	tgetpwnam.cxx
 OBJFILES=	$(OBJ)$/tgetpwnam.obj
 
-APP5TARGET= tgetpwnam
-APP5OBJS=	$(OBJFILES)
-APP5STDLIBS=$(SALLIB)
-APP5DEPN=	$(SLB)$/sal.lib
+APP1TARGET= tgetpwnam
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # (sco | netbsd | freebsd)
 .ENDIF # tgetpwname
Index: sal/workben/t_alloc.c
===================================================================
RCS file: sal/workben/t_alloc.c
diff -N sal/workben/t_alloc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sal/workben/t_alloc.c	25 Aug 2004 16:34:21 -0000	1.2.4.1
@@ -0,0 +1,508 @@
+/*************************************************************************
+ *
+ *  $RCSfile: t_alloc.c,v $
+ *
+ *  $Revision: 1.2.4.1 $
+ *
+ *  last change: $Author: mhu $ $Date: 2004/08/25 16:34:21 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Matthias Huetsch <matthias.huetsch@sun.com>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SAL_TYPES_H_
+#include <sal/types.h>
+#endif
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+
+#ifndef _RTL_ALLOC_H_
+#include <rtl/alloc.h>
+#endif
+
+#ifndef INCLUDED_STDLIB_H
+#include <stdlib.h>
+#define INCLUDED_STDLIB_H
+#endif
+
+#ifndef INCLUDED_STDIO_H
+#include <stdio.h>
+#define INCLUDED_STDIO_H
+#endif
+
+/*============================================================================
+ *
+ * Pseudo Random Number Generator.
+ *
+ *==========================================================================*/
+struct __random_generator_st
+{
+	sal_Int16 m_nX;
+	sal_Int16 m_nY;
+	sal_Int16 m_nZ;
+};
+
+struct __random_parameter_st
+{
+	sal_Int32 m_nA; /* lower bound */
+	sal_Int32 m_nB; /* upper bound */
+};
+
+/*
+ * __random_update.
+ */
+#define __random_update(x, y, z) \
+{ \
+	(x) = 170 * ((x) % 178) - 63 * ((x) / 178); \
+	if ((x) < 0) (x) += 30328L; \
+	\
+	(y) = 171 * ((y) % 177) -  2 * ((y) / 177); \
+	if ((y) < 0) (y) += 30269L; \
+	\
+	(z) = 172 * ((z) % 176) - 35 * ((z) / 176); \
+	if ((z) < 0) (z) += 30307L; \
+}
+
+/*
+ * __random_generate.
+ */
+static double __random_generate (struct __random_generator_st * state)
+{
+	register double random;
+
+	__random_update (state->m_nX, state->m_nY, state->m_nZ);
+	random = (((double)(state->m_nX) / 30328.0) +
+			  ((double)(state->m_nY) / 30269.0) +
+			  ((double)(state->m_nZ) / 30307.0)   );
+
+	random -= ((double)((sal_uInt32)(random)));
+	return (random);
+}
+
+/*
+ * __random.
+ */
+static struct __random_generator_st g_random =
+{
+	1, 1, 1
+};
+
+static double __random (struct __random_parameter_st * params)
+{
+	register double random;
+
+	random  = __random_generate (&(g_random));
+	if (params)
+	{
+		random *= (double)(params->m_nB - params->m_nA);
+		random += (double)(params->m_nA);
+	}
+	return (random);
+}
+
+/*============================================================================
+ *
+ * __memory_info_st.
+ *
+ *==========================================================================*/
+
+typedef struct __memory_info_st memory_type;
+struct __memory_info_st
+{
+	sal_Int32     m_ttl;
+
+	memory_type * m_flink;
+	memory_type * m_blink;
+};
+
+#define queue_start(entry) \
+{ \
+	(entry)->m_flink = (entry); \
+	(entry)->m_blink = (entry); \
+}
+
+#define queue_remove(entry) \
+{ \
+	(entry)->m_blink->m_flink = (entry)->m_flink; \
+	(entry)->m_flink->m_blink = (entry)->m_blink; \
+	queue_start(entry); \
+}
+
+#define queue_insert_head(head, entry) \
+{ \
+	(entry)->m_blink = (head); \
+	(entry)->m_flink = (head)->m_flink; \
+	(head)->m_flink = (entry); \
+	(entry)->m_flink->m_blink = (entry); \
+}
+
+#define queue_insert_tail(head, entry) \
+{ \
+	(entry)->m_flink = (head); \
+	(entry)->m_blink = (head)->m_blink; \
+	(head)->m_blink = (entry); \
+	(entry)->m_blink->m_flink = (entry); \
+}
+
+/*============================================================================
+ *
+ * __memory_global_st.
+ *
+ *==========================================================================*/
+struct __memory_global_st
+{
+	memory_type                  m_queue_head;
+	struct __random_parameter_st m_param_size;
+	struct __random_parameter_st m_param_ttl;
+};
+
+static struct __memory_global_st g_memory =
+{
+	{ 0, &(g_memory.m_queue_head), &(g_memory.m_queue_head) },
+	{ sizeof(memory_type), 2000 },
+	{ 1, 10 }
+};
+
+/*============================================================================
+ *
+ * __memory_tests.
+ *
+ *==========================================================================*/
+struct __memory_allocator_st
+{
+	/* 'malloc()' */
+	void * (SAL_CALL * m_create)(size_t);
+
+	/* 'realloc()' */
+	void * (SAL_CALL * m_resize)(void *, size_t);
+
+	/* 'free()' */
+	void (SAL_CALL * m_delete)(void *);
+};
+
+static void __memory_test_random (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry, *memory;
+	sal_uInt32   n;
+
+	n = (sal_uInt32)(__random (&(g_memory.m_param_size)));
+	memory = (allocator->m_create)(n);
+	if (memory)
+	{
+		sal_Int32 k;
+
+		k = (sal_Int32)(__random (&(g_memory.m_param_ttl)));
+		memory->m_ttl = k;
+
+		head = &(g_memory.m_queue_head);
+		for (entry = head->m_flink; entry != head; entry = entry->m_flink)
+		{
+			if (entry->m_ttl >= k)
+				break;
+		}
+		queue_insert_tail (entry, memory);
+	}
+
+	head = &(g_memory.m_queue_head);
+	for (entry = head->m_flink; entry != head; entry = entry->m_flink)
+	{
+		entry->m_ttl -= 1;
+	}
+
+	head = &(g_memory.m_queue_head);
+	while (((entry = head->m_flink) != head) && (entry->m_ttl <= 0))
+	{
+		queue_remove (entry);
+		(allocator->m_delete)(entry);
+	}
+}
+
+static void __memory_test_grow (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry, *memory;
+	sal_Int32    n = 10240;
+
+	head = &(g_memory.m_queue_head);
+	if ((entry = head->m_flink) != head)
+	{
+		n = entry->m_ttl + 1024;
+	}
+
+	memory = (allocator->m_create)(sizeof(memory_type));
+	if (memory != 0)
+	{
+		memory->m_ttl = sizeof(memory_type);
+		queue_insert_tail (head, memory);
+	}
+
+	if (allocator->m_resize)
+	{
+		memory = 0;
+		if (entry != head)
+		{
+			queue_remove (entry);
+			memory = entry;
+		}
+
+		memory = (allocator->m_resize)(memory, n);
+		if (memory != 0)
+		{
+			memory->m_ttl = n;
+			queue_insert_head (head, memory);
+		}
+	}
+	else
+	{
+		memory = (allocator->m_create)(n);
+		if (memory != 0)
+		{
+			memory->m_ttl = n;
+			queue_insert_head (head, memory);
+		}
+		if (entry != head)
+		{
+			queue_remove (entry);
+			(allocator->m_delete)(entry);
+		}
+	}
+}
+
+static void __memory_test_cleanup (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry;
+
+	head = &(g_memory.m_queue_head);
+	while ((entry = head->m_flink) != head)
+	{
+		queue_remove (entry);
+		(allocator->m_delete)(entry);
+	}
+}
+
+/*============================================================================
+ *
+ * heap.
+ *
+ *==========================================================================*/
+#ifdef HAVE_HEAP_H
+#include "heap.h"
+
+struct __heap_info_st
+{
+	union
+	{
+		heap_type m_heap;
+		char      m_data[0x10000];
+	} m_union;
+
+	int m_magic;
+};
+
+static struct __heap_info_st g_heap =
+{
+	{ HEAP_INITIALIZER },
+	0
+};
+
+static void * __heap_alloc (size_t n)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	return heap_alloc (&(g_heap.m_union.m_heap), n);
+}
+
+static void * __heap_realloc (void * p, size_t n)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	return heap_realloc (&(g_heap.m_union.m_heap), p, n);
+}
+
+static void __heap_free (void * p)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	heap_free (&(g_heap.m_union.m_heap), p);
+}
+
+static struct __memory_allocator_st g_heap_allocator =
+{
+	__heap_alloc,
+	__heap_realloc,
+	__heap_free
+};
+
+#endif /* HAVE_HEAP_H */
+
+/*============================================================================
+ *
+ * main.
+ *
+ *==========================================================================*/
+static struct __memory_allocator_st g_rtl_allocator =
+{
+	rtl_allocateMemory,
+	rtl_reallocateMemory,
+	rtl_freeMemory
+};
+
+static struct __memory_allocator_st g_std_allocator =
+{
+	malloc,
+	realloc,
+	free
+};
+
+enum __memory_options
+{
+	OPTION_TEST_RANDOM = 0x01,
+	OPTION_TEST_GROW   = 0x02
+};
+
+static void usage (void)
+{
+	printf ("Usage:\tt_alloc [-a <rtl|std>] [-n <num>]\n");
+
+	printf ("\nOptions:\n");
+	printf ("-a\tallocator  [default: rtl]\n");
+	printf ("-n\titerations [default: 10000]\n");
+	printf ("-h\thelp\n");
+
+	exit (0);
+}
+
+int SAL_CALL main (int argc, char **argv)
+{
+	struct __memory_allocator_st * allocator = &g_rtl_allocator;
+	int options = OPTION_TEST_RANDOM;
+	int i, n = 10000;
+
+	/* parse options */
+	for (i = 1; i < argc; i++)
+	{
+		const char *opt = argv[i]; char c;
+		switch (opt[0])
+		{
+			case '-':
+				switch (opt[1])
+				{
+					case 'a':
+						opt = argv[++i]; c = opt ? opt[0] : 0;
+						switch (c)
+						{
+							case 'r':
+								allocator = &g_rtl_allocator;
+								break;
+							case 's':
+								allocator = &g_std_allocator;
+								break;
+							default:
+								usage();
+								break;
+						}
+						break;
+
+					case 'n':
+						opt = argv[++i]; c = opt ? opt[0] : 0;
+						if (('0' <= c) && (c <= '9'))
+							n = atoi(opt);
+						else
+							usage();
+						break;
+
+					case 'h':
+					default:
+						usage();
+						break;
+				}
+				break;
+
+			default:
+				usage();
+				break;
+		}
+	}
+
+	/* execute options */
+	if (options & OPTION_TEST_RANDOM)
+	{
+		/* allocate/deallocate w/ random distribution */
+		for (i = n; i > 0; i--)
+			__memory_test_random (allocator);
+
+		/* free still allocated memory */
+		__memory_test_cleanup (allocator);
+	}
+	if (options & OPTION_TEST_GROW)
+	{
+		/* allocate w/ growing distribution */
+		for (i = n; i > 0; i--)
+			__memory_test_grow (allocator);
+
+		/* free still allocated memory */
+		__memory_test_cleanup (allocator);
+	}
+
+	/* finished */
+	return 0;
+}
Index: sal/workben/t_layer.c
===================================================================
RCS file: sal/workben/t_layer.c
diff -N sal/workben/t_layer.c
--- sal/workben/t_layer.c	15 Apr 2003 17:49:37 -0000	1.4
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,353 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile: t_layer.c,v $
- *
- *  $Revision: 1.4 $
- *
- *  last change: $Author: vg $ $Date: 2003/04/15 17:49:37 $
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-#ifndef _SAL_TYPES_H_
-#include <sal/types.h>
-#endif
-#ifndef _RTL_ALLOC_H_
-#include <rtl/alloc.h>
-#endif
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-#ifndef _OSL_INTERLCK_H_
-#include <osl/interlck.h>
-#endif
-#ifndef _OSL_ISOCKET_H_
-#include <osl/isocket.h>
-#endif
-
-/*========================================================================
- *
- * osl/debug.c
- *
- *======================================================================*/
-/*
- * __osl_debug_create.
- */
-static oslSocketResult SAL_CALL __osl_debug_create (
-	oslSocketDescriptor *socket,
-	oslAddrFamily        family,
-	oslSocketType        type,
-	oslProtocol          protocol)
-{
-	oslSocketResult result;
-
-	if (!(socket->m_lower))
-	{
-		oslSocketDescriptor *lower;
-		lower = osl_socket_createSocketLayer (osl_socket_getSocketMethods());
-		osl_socket_pushSocketLayer (socket, lower);
-	}
-
-	result = (socket->m_lower->m_methods->m_create)(
-		socket->m_lower, family, type, protocol);
-	if (!(result == osl_Socket_Ok))
-		return (result);
-
-	if (!(socket->m_private))
-	{
-		/* ... */
-	}
-	return (osl_Socket_Ok);
-}
-
-/*
- * __osl_debug_delete.
- */
-static void SAL_CALL __osl_debug_delete (oslSocketDescriptor *socket)
-{
-	if (socket->m_private)
-	{
-		/* ... */
-	}
-	if (socket->m_lower)
-	{
-		(socket->m_lower->m_methods->m_delete)(socket->m_lower);
-		osl_socket_deleteSocketLayer (socket->m_lower);
-	}
-}
-
-/*
- * __osl_debug_getOption.
- */
-static oslSocketResult SAL_CALL __osl_debug_getOption (
-	oslSocketDescriptor  *socket,
-	oslSocketOptionLevel  level,
-	oslSocketOption       option,
-	void                 *buffer,
-	sal_uInt32            length)
-{
-	if (level == osl_Socket_LevelSocketLayer)
-	{
-		/* ... */
-		return (osl_Socket_Ok);
-	}
-
-	return (socket->m_lower->m_methods->m_getoption)(
-		socket->m_lower, level, option, buffer, length);
-}
-
-/*
- * __osl_debug_setOption.
- */
-static oslSocketResult SAL_CALL __osl_debug_setOption (
-	oslSocketDescriptor  *socket,
-	oslSocketOptionLevel  level,
-	oslSocketOption       option,
-	const void           *buffer,
-	sal_uInt32            length)
-{
-	if (level == osl_Socket_LevelSocketLayer)
-	{
-		/* ... */
-		return (osl_Socket_Ok);
-	}
-
-	return (socket->m_lower->m_methods->m_setoption)(
-		socket->m_lower, level, option, buffer, length);
-}
-
-/*
- * __osl_debug_accept.
- */
-static oslSocketDescriptor* SAL_CALL __osl_debug_accept (
-	oslSocketDescriptor *socket, oslSocketAddr *fromaddr)
-{
-	oslSocketDescriptor *lower;
-	lower = (socket->m_lower->m_methods->m_accept)(socket->m_lower, fromaddr);
-	if (lower)
-	{
-		oslSocketDescriptor *upper;
-		upper = osl_socket_createSocketLayer (socket->m_methods);
-		osl_socket_pushSocketLayer (upper, lower);
-		return (upper);
-	}
-	return ((oslSocketDescriptor*)NULL);
-}
-
-/*
- * __osl_debug_connect.
- */
-static oslSocketResult SAL_CALL __osl_debug_connect (
-	oslSocketDescriptor *socket, oslSocketAddr addr)
-{
-	return (socket->m_lower->m_methods->m_connect)(socket->m_lower, addr);
-}
-
-/*
- * __osl_debug_close.
- */
-static void SAL_CALL __osl_debug_close (oslSocketDescriptor *socket)
-{
-	(socket->m_lower->m_methods->m_close)(socket->m_lower);
-}
-
-/*
- * __osl_shutdown.
- */
-static void SAL_CALL __osl_debug_shutdown (
-	oslSocketDescriptor *socket, oslSocketDirection direction)
-{
-	(socket->m_lower->m_methods->m_shutdown)(socket->m_lower, direction);
-}
-
-/*
- * __osl_debug_methods.
- */
-static oslSocketMethods __osl_debug_methods =
-{
-	NULL /* initialized on demand */
-};
-
-/*
- * osl_debug_getSocketMethods.
- */
-const oslSocketMethods* SAL_CALL osl_debug_getSocketMethods (void)
-{
-	static oslInterlockedCount nonce = 0;
-	if (osl_incrementInterlockedCount (&nonce) == 1)
-	{
-		const oslSocketMethods *methods = osl_socket_getDefaultSocketMethods();
-		__osl_debug_methods = *methods;
-
-		__osl_debug_methods.m_create    = __osl_debug_create;
-		__osl_debug_methods.m_delete    = __osl_debug_delete;
-
-		__osl_debug_methods.m_getoption = __osl_debug_getOption;
-		__osl_debug_methods.m_setoption = __osl_debug_setOption;
-
-		__osl_debug_methods.m_accept    = __osl_debug_accept;
-		__osl_debug_methods.m_connect   = __osl_debug_connect;
-		__osl_debug_methods.m_close     = __osl_debug_close;
-
-		__osl_debug_methods.m_shutdown  = __osl_debug_shutdown;
-
-		osl_incrementInterlockedCount (&nonce);
-	}
-
-	osl_decrementInterlockedCount (&nonce);
-	return (&__osl_debug_methods);
-}
-
-/*========================================================================
- *
- * osl/socket.c (physical, bottom layer).
- *
- *======================================================================*/
-#if 0  /* NYI */
-
-static oslSocketResult SAL_CALL __osl_socket_create (
-	oslSocketDescriptor *socket,
-	oslAddrFamily        family,
-	oslSocketType        type,
-	oslProtocol          protocol)
-{
-#if OSL_DEBUG_LEVEL > 1
-	const oslSocketMethods *debug = osl_debug_getSocketMethods();
-	if (!(socket->m_upper || socket->m_upper->m_methods == debug))
-	{
-		oslSocketDescriptor *upper;
-
-		upper = osl_socket_createSocketLayer (debug);
-		osl_socket_pushSocketLayer (upper, socket);
-
-		return (upper->m_methods->m_create)(upper, family, type, protocol);
-	}
-#endif /* OSL_DEBUG_LEVEL */
-	if (!(socket->m_private))
-	{
-		/* ... */
-		socket->m_private = osl_createSocket (family, type, protocol);
-	}
-	return (osl_Socket_Ok);
-}
-
-#endif /* NYI */
-
-/*========================================================================
- *
- * main.
- *
- *======================================================================*/
-int SAL_CALL main (int argc, char **argv)
-{
-	oslSocketDescriptor *socket;
-
-	socket = osl_socket_createSocketLayer (osl_debug_getSocketMethods());
-	if (socket)
-	{
-		oslSocketDescriptor *connection;
-		oslSocketResult      result;
-		oslSocketAddr        addr, from;
-		sal_Int32            option = 1;
-
-		result = osl_socket_create (
-			socket,
-			osl_Socket_FamilyInet,
-			osl_Socket_TypeStream,
-			osl_Socket_ProtocolIp);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		result = osl_socket_setOption (
-			socket,
-			osl_Socket_LevelSocket,
-			osl_Socket_OptionReuseAddr,
-			&option, sizeof(option));
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		addr = osl_createEmptySocketAddr (osl_Socket_FamilyInet);
-		osl_setInetPortOfSocketAddr (addr, 7777);
-
-		result = osl_socket_bind (socket, addr);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		result = osl_socket_listen (socket, 1);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		connection = osl_socket_accept (socket, &from);
-		if (connection)
-		{
-			sal_Char         buffer[1024];
-			sal_Int32        k, n = sizeof(buffer);
-			oslSocketMsgFlag flag = osl_Socket_MsgNormal;
-
-			while ((k = osl_socket_recv (connection, buffer, n, flag)) > 0)
-			{
-				if (osl_socket_send (connection, buffer, k, flag) < 0)
-					break;
-			}
-
-			osl_socket_close (connection);
-			osl_socket_delete (connection);
-
-			osl_socket_deleteSocketLayer (connection);
-		}
-
-		osl_socket_close (socket);
-		osl_socket_delete (socket);
-
-		osl_socket_deleteSocketLayer (socket);
-	}
-
-	return 0;
-}
-
Index: sal/workben/t_ojp_exe.cxx
===================================================================
RCS file: sal/workben/t_ojp_exe.cxx
diff -N sal/workben/t_ojp_exe.cxx
--- sal/workben/t_ojp_exe.cxx	26 Mar 2003 16:47:25 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,86 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile: t_ojp_exe.cxx,v $
- *
- *  $Revision: 1.2 $
- *
- *  last change: $Author: hr $ $Date: 2003/03/26 16:47:25 $
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-
-#ifdef WNT
-#	define WIN32_LEAN_AND_MEAN
-#	include <windows.h>
-#else
-#	include <unistd.h>
-#endif
-
-#include <stdio.h>
-
-int main(int argc, char* argv[])
-{
-    printf("osl process test executable started:\n");
-	
-#ifdef WNT	
-    Sleep(5000);
-#else
-	sleep(5);
-#endif
-
-    printf("osl process test executable ended:\n");
-
-    return (0);
-}
-
Index: sal/workben/t_tls.c
===================================================================
RCS file: sal/workben/t_tls.c
diff -N sal/workben/t_tls.c
--- sal/workben/t_tls.c	26 Mar 2003 16:47:27 -0000	1.3
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,301 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile: t_tls.c,v $
- *
- *  $Revision: 1.3 $
- *
- *  last change: $Author: hr $ $Date: 2003/03/26 16:47:27 $
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-#ifndef _SAL_TYPES_H_
-#include <sal/types.h>
-#endif
-#ifndef _RTL_ALLOC_H_
-#include <rtl/alloc.h>
-#endif
-#ifndef _RTL_USTRING_H_
-#include <rtl/ustring.h>
-#endif
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-#ifndef _OSL_FILE_H_
-#include <osl/file.h>
-#endif
-#ifndef _OSL_INTERLCK_H_
-#include <osl/interlck.h>
-#endif
-#ifndef _OSL_ISOCKET_H_
-#include <osl/isocket.h>
-#endif
-
-#ifndef _OSL_TLS_H_
-#include <osl/tls.h>
-#endif
-
-#include <string.h>
-#include <stdio.h>
-
-/*========================================================================
- *
- * Internals.
- *
- *======================================================================*/
-void SAL_CALL __rtl_sequence_release (sal_Sequence *value)
-{
-	if (value)
-	{
-		if (osl_decrementInterlockedCount (&(value->nRefCount)) == 0)
-			rtl_freeMemory (value);
-	}
-}
-
-void SAL_CALL __rtl_sequence_new (sal_Sequence **value, sal_Int32 length)
-{
-	if (value)
-	{
-		__rtl_sequence_release (*value);
-
-		*value = (sal_Sequence*)rtl_allocateMemory (
-			SAL_SEQUENCE_HEADER_SIZE + length);
-
-		(*value)->nRefCount = 1;
-		(*value)->nElements = 0;
-	}
-}
-
-void load_sequence (sal_Sequence **ppSequence, const sal_Char *name)
-{
-	oslFileError  result;
-	rtl_uString  *pName, *pPath;
-
-	if (ppSequence)
-	{
-		__rtl_sequence_release (*ppSequence);
-		*ppSequence = NULL;
-	}
-
-	pName = NULL;
-	rtl_uString_newFromAscii (&pName, name);
-
-	pPath = NULL;
-	result = osl_searchNormalizedPath (pName, NULL, &pPath);
-	if (result == osl_File_E_None)
-	{
-		oslFileHandle hFile;
-
-		result = osl_openFile (pPath, &hFile, osl_File_OpenFlag_Read);
-		if (result == osl_File_E_None)
-		{
-			sal_uInt64 nSize = 0, nRead = 0;
-
-			osl_setFilePos (hFile, osl_Pos_End, 0);
-			osl_getFilePos (hFile, &nSize);
-			osl_setFilePos (hFile, osl_Pos_Absolut, 0);
-
-			__rtl_sequence_new (ppSequence, (sal_Int32)nSize);
-
-			osl_readFile (hFile, (*ppSequence)->elements, nSize, &nRead);
-			(*ppSequence)->nElements = (sal_Int32)nRead;
-		}
-		osl_closeFile (hFile);
-
-		rtl_uString_release (pPath);
-	}
-
-	rtl_uString_release (pName);
-}
-
-/*========================================================================
- *
- * main.
- *
- *======================================================================*/
-int SAL_CALL main (int argc, char **argv)
-{
-	static const sal_Char p[] = "GET / HTTP/1.0\015\012\015\012";
-	oslSocketDescriptor  *socket;
-
-
-	socket = osl_socket_createSocketLayer (osl_tls_getSocketMethods());
-	if (socket)
-	{
-		oslSocketAddr     target;
-		oslSocketResult   result;
-		oslSocketMsgFlag  flag   = osl_Socket_MsgNormal;
-		rtl_uString      *dotted = NULL;
-
-
-		rtl_uString_newFromAscii (&dotted, argv[1]);
-		target = osl_createInetSocketAddr (dotted, 443);
-		rtl_uString_release (dotted);
-
-		result = osl_socket_create (
-			socket,
-			osl_Socket_FamilyInet,
-			osl_Socket_TypeStream,
-			osl_Socket_ProtocolIp);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		result = osl_socket_connect (socket, target);
-		osl_destroySocketAddr (target);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		result = osl_socket_connect_handshake (socket, target);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		if (osl_socket_send (socket, p, strlen(p), flag) > 0)
-		{
-			sal_Char  buffer[1024];
-			sal_Int32 k, n = sizeof(buffer);
-
-			while ((k = osl_socket_recv (socket, buffer, n, flag)) > 0)
-				fwrite (buffer, 1, k, stdout);
-		}
-
-		osl_socket_shutdown (socket, osl_Socket_DirReadWrite);
-		osl_socket_close (socket);
-	
-		osl_socket_delete (socket);
-		osl_socket_deleteSocketLayer (socket);
-	}
-
-
-	socket = osl_socket_createSocketLayer (osl_tls_getSocketMethods());
-	if (socket)
-	{
-		oslSocketDescriptor *connection;
-		oslSocketResult      result;
-		oslSocketAddr        addr, from;
-		sal_Int32            option = 1;
-		sal_Sequence        *data = NULL;
-
-
-		result = osl_socket_create (
-			socket,
-			osl_Socket_FamilyInet,
-			osl_Socket_TypeStream,
-			osl_Socket_ProtocolIp);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		result = osl_socket_setOption (
-			socket,
-			osl_Socket_LevelSocket,
-			osl_Socket_OptionReuseAddr,
-			&option, sizeof(option));
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		addr = osl_createEmptySocketAddr (osl_Socket_FamilyInet);
-		osl_setInetPortOfSocketAddr (addr, 7777);
-
-		result = osl_socket_bind (socket, addr);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		load_sequence (&data, "s_cert.der");
-		if (data && data->nElements)
-		{
-			result = osl_socket_setOption (
-				socket,
-				osl_Socket_LevelTLS,
-				osl_Socket_OptionCertificate,
-				data->elements, data->nElements);
-			OSL_ASSERT(result == osl_Socket_Ok);
-		}
-
-		load_sequence (&data, "s_pkey.der");
-		if (data && data->nElements)
-		{
-			result = osl_socket_setOption (
-				socket,
-				osl_Socket_LevelTLS,
-				osl_Socket_OptionPrivateKey,
-				data->elements, data->nElements);
-			OSL_ASSERT(result == osl_Socket_Ok);
-		}
-		__rtl_sequence_release (data);
-
-		result = osl_socket_listen (socket, 1);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		connection = osl_socket_accept (socket, &from);
-		if (connection)
-		{
-			sal_Char  buffer[1024];
-			sal_Int32 k, n = sizeof(buffer);
-			oslSocketMsgFlag flag = osl_Socket_MsgNormal;
-
-			result = osl_socket_accept_handshake (connection, from);
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			while ((k = osl_socket_recv (connection, buffer, n, flag)) > 0)
-			{
-				if (osl_socket_send (connection, buffer, k, flag) < 0)
-					break;
-			}
-
-			osl_socket_close (connection);
-
-			osl_socket_delete (connection);
-			osl_socket_deleteSocketLayer (connection);
-		}
-
-		osl_socket_delete (socket);
-		osl_socket_deleteSocketLayer (socket);
-	}
-
-	return 0;
-}
-
Index: sal/workben/t_zip.c
===================================================================
RCS file: sal/workben/t_zip.c
diff -N sal/workben/t_zip.c
--- sal/workben/t_zip.c	26 Mar 2003 16:47:27 -0000	1.3
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,223 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile: t_zip.c,v $
- *
- *  $Revision: 1.3 $
- *
- *  last change: $Author: hr $ $Date: 2003/03/26 16:47:27 $
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-#ifndef _SAL_TYPES_H_
-#include <sal/types.h>
-#endif
-#ifndef _RTL_USTRING_H_
-#include <rtl/ustring.h>
-#endif
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-#ifndef _OSL_THREAD_H_
-#include <osl/thread.h>
-#endif
-#ifndef _OSL_ZSOCKET_H_
-#include <osl/zsocket.h>
-#endif
-
-#include <stdio.h>
-
-/*========================================================================
- *
- * internals.
- *
- *======================================================================*/
-void SAL_CALL clientSocketReader (void *pData)
-{
-	oslSocketDescriptor *socket;
-
-	socket = (oslSocketDescriptor*)pData;
-	if (socket)
-	{
-		sal_Char         buffer[128];
-		sal_Int32        k, n = sizeof(buffer);
-		oslSocketMsgFlag flag = osl_Socket_MsgNormal;
-
-		while ((k = osl_socket_recv (socket, buffer, n, flag)) > 0)
-		{
-			fwrite (buffer, 1, k, stdout);
-			fflush (stdout);
-		}
-	}
-}
-
-/*========================================================================
- *
- * main.
- *
- *======================================================================*/
-int SAL_CALL main (int argc, char **argv)
-{
-	oslSocketDescriptor *socket;
-
-	socket = osl_socket_createSocketLayer (osl_zlib_getSocketMethods());
-	if (socket)
-	{
-		oslSocketAddr   addr = 0;
-		oslSocketResult result;
-
-		result = osl_socket_create (
-			socket,
-			osl_Socket_FamilyInet,
-			osl_Socket_TypeStream,
-			osl_Socket_ProtocolIp);
-		OSL_ASSERT(result == osl_Socket_Ok);
-
-		if (argc > 1)
-		{
-			rtl_uString *host = 0;
-
-			rtl_uString_newFromAscii (&host, argv[1]);
-			addr = osl_resolveHostname (host);
-			rtl_uString_release (host);
-		}
-
-		if (addr)
-		{
-			sal_Char         buffer[128];
-			sal_Int32        k, n = sizeof(buffer);
-			oslSocketMsgFlag flag = osl_Socket_MsgNormal;
-			oslThread        reader;
-
-			osl_setInetPortOfSocketAddr (addr, 7777);
-
-			result = osl_socket_connect (socket, addr);
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			result = osl_socket_connect_handshake (socket, addr);
-			osl_destroySocketAddr (addr);
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			reader = osl_createSuspendedThread (clientSocketReader, socket);
-			OSL_ASSERT(reader);
-			osl_resumeThread (reader);
-
-			while ((k = fread (buffer, 1, n, stdin)) > 0)
-			{
-				if (osl_socket_send (socket, buffer, k, flag) < 0)
-					break;
-			}
-
-			osl_socket_shutdown (socket, osl_Socket_DirReadWrite);
-			osl_socket_close (socket);
-
-			osl_joinWithThread (reader);
-			osl_destroyThread (reader);
-		}
-		else
-		{
-			oslSocketDescriptor *connection;
-			oslSocketAddr        from   = 0;
-			sal_Int32            option = 1;
-
-			addr = osl_createEmptySocketAddr (osl_Socket_FamilyInet);
-			osl_setInetPortOfSocketAddr (addr, 7777);
-
-			result = osl_socket_setOption (
-				socket,
-				osl_Socket_LevelSocket,
-				osl_Socket_OptionReuseAddr,
-				&option, sizeof(option));
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			result = osl_socket_bind (socket, addr);
-			osl_destroySocketAddr (addr);
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			result = osl_socket_listen (socket, 1);
-			OSL_ASSERT(result == osl_Socket_Ok);
-
-			connection = osl_socket_accept (socket, &from);
-			if (connection)
-			{
-				sal_Char         buffer[64];
-				sal_Int32        k, n = sizeof(buffer);
-				oslSocketMsgFlag flag = osl_Socket_MsgNormal;
-
-				result = osl_socket_accept_handshake (connection, from);
-				osl_destroySocketAddr (from);
-				OSL_ASSERT(result == osl_Socket_Ok);
-
-				while ((k = osl_socket_recv (connection, buffer, n, flag)) > 0)
-				{
-					if (osl_socket_send (connection, buffer, k, flag) < 0)
-						break;
-				}
-
-				osl_socket_close (connection);
-
-				osl_socket_delete (connection);
-				osl_socket_deleteSocketLayer (connection);
-			}
-
-			osl_socket_close (socket);
-		}
-
-		osl_socket_delete (socket);
-		osl_socket_deleteSocketLayer (socket);
-	}
-
-	return 0;
-}
-
Index: sal/workben/test.cxx
===================================================================
RCS file: sal/workben/test.cxx
diff -N sal/workben/test.cxx
--- sal/workben/test.cxx	1 Feb 2001 12:31:41 -0000	1.2
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,97 +0,0 @@
-/*************************************************************************
- *
- *  $RCSfile: test.cxx,v $
- *
- *  $Revision: 1.2 $
- *
- *  last change: $Author: mfe $ $Date: 2001/02/01 12:31:41 $
- *
- *  The Contents of this file are made available subject to the terms of
- *  either of the following licenses
- *
- *         - GNU Lesser General Public License Version 2.1
- *         - Sun Industry Standards Source License Version 1.1
- *
- *  Sun Microsystems Inc., October, 2000
- *
- *  GNU Lesser General Public License Version 2.1
- *  =============================================
- *  Copyright 2000 by Sun Microsystems, Inc.
- *  901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License version 2.1, as published by the Free Software Foundation.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA  02111-1307  USA
- *
- *
- *  Sun Industry Standards Source License Version 1.1
- *  =================================================
- *  The contents of this file are subject to the Sun Industry Standards
- *  Source License Version 1.1 (the "License"); You may not use this file
- *  except in compliance with the License. You may obtain a copy of the
- *  License at http://www.openoffice.org/license.html.
- *
- *  Software provided under this License is provided on an "AS IS" basis,
- *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
- *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
- *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
- *  See the License for the specific provisions governing your rights and
- *  obligations concerning the Software.
- *
- *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
- *
- *  Copyright: 2000 by Sun Microsystems, Inc.
- *
- *  All Rights Reserved.
- *
- *  Contributor(s): _______________________________________
- *
- *
- ************************************************************************/
-
-#include <stdio.h>
-
-#if (defined UNX) || (defined OS2)
-int main( int argc, char * argv[] )
-#else
-int _cdecl main( int argc, char * argv[] )
-#endif
-{
-	void test_int64();
-	test_int64();
-
-	void test_profile(void);
-	test_profile();
-
-	void test_OString();
-	test_OString();
-
-/*  	void test_OWString(); */
-/*  	test_OWString(); */
-
-/*  	void test_OStringBuffer(); */
-/*  	test_OStringBuffer(); */
-
-/*  	void test_OWStringBuffer(); */
-/*  	test_OWStringBuffer(); */
-	
-/*  	void test_OString2OWStringAndViceVersa(); */
-/*  	test_OString2OWStringAndViceVersa(); */
-
-	void test_uuid();
-	test_uuid();
-
-	return(0);
-}
-
-
