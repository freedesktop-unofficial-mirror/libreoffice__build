? sal/unxlngx4.pro
? sal/rtl/source/guard.c
Index: sal/cpprt/operators_new_delete.cxx
===================================================================
RCS file: /cvs/porting/sal/cpprt/operators_new_delete.cxx,v
retrieving revision 1.3
retrieving revision 1.3.206.1
diff -u -p -u -r1.3 -r1.3.206.1
--- sal/cpprt/operators_new_delete.cxx	15 Apr 2003 17:40:45 -0000	1.3
+++ sal/cpprt/operators_new_delete.cxx	25 Aug 2004 16:46:45 -0000	1.3.206.1
@@ -180,7 +180,7 @@ static void* allocate (
 	n = rTraits.size (n);
 	for (;;)
 	{
-		void * p = rtl_allocateMemory (sal_uInt32(n));
+		void * p = rtl_allocateMemory (sal_Size(n));
 		if (p != 0)
 			return rTraits.init (p);
 
Index: sal/inc/sal/types.h
===================================================================
RCS file: /cvs/porting/sal/inc/sal/types.h,v
retrieving revision 1.24
retrieving revision 1.23.4.5
diff -u -p -u -r1.24 -r1.23.4.5
--- sal/inc/sal/types.h	23 Aug 2004 09:43:33 -0000	1.24
+++ sal/inc/sal/types.h	18 Oct 2004 16:28:28 -0000	1.23.4.5
@@ -121,7 +121,15 @@ typedef unsigned char       sal_uInt8;
 	#define SAL_CONST_INT64(x)       x##i64
 	#define SAL_CONST_UINT64(x)      x##ui64
 #elif defined(__SUNPRO_CC) || defined(__SUNPRO_C) || defined (__GNUC__) || defined(__hpux) || defined (sgi)
-	#if SAL_TYPES_SIZEOFLONGLONG == 8
+	#if SAL_TYPES_SIZEOFLONG == 8
+		typedef signed long int         sal_Int64;
+		typedef unsigned long int       sal_uInt64;
+
+
+		/*  The following are macros that will add the 64 bit constant suffix. */
+		#define SAL_CONST_INT64(x)       x##l
+		#define SAL_CONST_UINT64(x)      x##ul
+	#elif SAL_TYPES_SIZEOFLONGLONG == 8
 		typedef signed long long    sal_Int64;
 		typedef unsigned long long  sal_uInt64;
 
@@ -129,14 +137,6 @@ typedef unsigned char       sal_uInt8;
 		#define SAL_CONST_INT64(x)       x##ll
 		#define SAL_CONST_UINT64(x)      x##ull
 
-	#elif SAL_TYPES_SIZEOFLONG == 8
-		typedef signed long         sal_Int64;
-		typedef unsigned long       sal_uInt64;
-
-
-		/*  The following are macros that will add the 64 bit constant suffix. */
-		#define SAL_CONST_INT64(x)       x##l
-		#define SAL_CONST_UINT64(x)      x##ul
 	#else
 		#error "Could not find 64-bit type, add support for your architecture"
 	#endif
@@ -158,16 +158,37 @@ typedef unsigned char            sal_uCh
 typedef void *                   sal_Handle;
 
 /* sal_Size should currently be the native width of the platform */
-#if SAL_TYPES_SIZEOFLONG == 4
+#if SAL_TYPES_SIZEOFPOINTER == 4
 	typedef sal_uInt32          sal_Size;
 	typedef sal_Int32           sal_sSize;
-#elif SAL_TYPES_SIZEOFLONG == 8
+#elif SAL_TYPES_SIZEOFPOINTER == 8
 	typedef sal_uInt64          sal_Size;
 	typedef sal_Int64           sal_sSize;
 #else
-	#error "Please make sure SAL_TYPES_SIZEOFLONG is defined for your architecture/compiler"
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
 #endif
   
+/* sal_PtrDiff holds the result of a pointer subtraction */
+#if SAL_TYPES_SIZEOFPOINTER == 4
+    typedef sal_Int32           sal_PtrDiff;
+#elif SAL_TYPES_SIZEOFPOINTER == 8
+	typedef sal_Int64           sal_PtrDiff;
+#else
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
+#endif
+
+/* sal_IntPtr, sal_uIntPtr are integer types designed to hold pointers so that any valid
+ * pointer to void can be converted to this type and back to a pointer to void and the 
+ * result will compare to the original pointer */
+#if SAL_TYPES_SIZEOFPOINTER == 4
+	typedef sal_Int32           sal_IntPtr;
+	typedef sal_uInt32          sal_uIntPtr;
+#elif SAL_TYPES_SIZEOFPOINTER == 8
+	typedef sal_Int64           sal_IntPtr;
+	typedef sal_uInt64          sal_uIntPtr;
+#else
+	#error "Please make sure SAL_TYPES_SIZEOFPOINTER is defined for your architecture/compiler"
+#endif
 
 /********************************************************************************/
 /* Useful defines
@@ -190,7 +211,15 @@ typedef void *                   sal_Han
 #define SAL_MIN_INT64         ((sal_Int64)  (SAL_CONST_INT64(-0x7FFFFFFFFFFFFFFF) - 1))
 #define SAL_MAX_INT64         ((sal_Int64)  SAL_CONST_INT64(0x7FFFFFFFFFFFFFFF))
 #define SAL_MAX_UINT64        ((sal_uInt64) SAL_CONST_UINT64(0xFFFFFFFFFFFFFFFF))
-  
+
+#if SAL_TYPES_SIZEOFLONG == 4
+#define SAL_MAX_SSIZE		SAL_MAX_INT32
+#define SAL_MAX_SIZE		SAL_MAX_UINT32
+#elif SAL_TYPES_SIZEOFLONG == 8
+#define SAL_MAX_SSIZE		SAL_MAX_INT64
+#define SAL_MAX_SIZE		SAL_MAX_UINT64
+#endif
+
 #if defined(SAL_W32) || defined(SAL_OS2) || defined(SAL_UNX)
 #   define SAL_MAX_ENUM 0x7fffffff
 #elif defined(SAL_W16)
Index: sal/osl/unx/backtrace.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/backtrace.c,v
retrieving revision 1.6
retrieving revision 1.6.62.1
diff -u -p -u -r1.6 -r1.6.62.1
--- sal/osl/unx/backtrace.c	4 Feb 2004 13:48:44 -0000	1.6
+++ sal/osl/unx/backtrace.c	25 Aug 2004 18:46:23 -0000	1.6.62.1
@@ -74,11 +74,19 @@
 #define FRAME_PTR_OFFSET 1
 #define FRAME_OFFSET 0
 
+#if defined(__sparcv9)
+#define STACK_BIAS 0x7ff
+#else
+#define STACK_BIAS 0
+#endif
+
 #elif defined( INTEL )
 
 #define FRAME_PTR_OFFSET 3
 #define FRAME_OFFSET 1
 
+#define STACK_BIAS 0
+
 #else
 
 #error Unknown Solaris target platform. 
@@ -88,27 +96,32 @@
 
 int backtrace( void **buffer, int max_frames )
 {
-	struct frame *fp;
-	jmp_buf ctx;
-	int i;
+	jmp_buf        ctx;
+    long           fpval;
+	struct frame * fp;
+	int            i;
 
 	/* flush register windows */
 #ifdef SPARC
 	asm("ta 3");
 #endif
+
 	/* get stack- and framepointer */
 	setjmp(ctx);
-	fp = (struct frame*)(((size_t*)(ctx))[FRAME_PTR_OFFSET]);
-	for ( i=0; (i<FRAME_OFFSET) && (fp!=0); i++)
-		fp = fp->fr_savfp;
+	fpval = ((long*)(ctx))[FRAME_PTR_OFFSET];
+
+	fp = (struct frame*)((char*)(fpval) + STACK_BIAS);
+	for ( i=0; (i < FRAME_OFFSET) && (fp != 0); i++)
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 
 	/* iterate through backtrace */
-	for (i=0; fp && fp->fr_savpc && i<max_frames; i++)
+	for (i = 0; fp && fp->fr_savpc && i < max_frames; i++)
 	{
 		/* store frame */
-		*(buffer++) = (void *)fp->fr_savpc;
+		*(buffer++) = (void *)(fp->fr_savpc);
+
 		/* next frame */
-		fp=fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 	}
 	return i;
 }
Index: sal/osl/unx/diagnose.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/diagnose.c,v
retrieving revision 1.13
retrieving revision 1.12.202.2
diff -u -p -u -r1.13 -r1.12.202.2
--- sal/osl/unx/diagnose.c	25 Jun 2004 18:36:24 -0000	1.13
+++ sal/osl/unx/diagnose.c	18 Oct 2004 16:31:47 -0000	1.12.202.2
@@ -186,32 +186,43 @@ static void osl_diagnose_backtrace_Impl 
 #define FRAME_PTR_OFFSET 1
 #define FRAME_OFFSET 0
 
+#if defined(__sparcv9)
+#define STACK_BIAS 0x7ff
+#else
+#define STACK_BIAS 0
+#endif
+
 #elif defined(INTEL)
 
 #define FRAME_PTR_OFFSET 3
 #define FRAME_OFFSET 1
 
+#define STACK_BIAS 0
+
 #endif /* (SPARC || INTEL) */
 
 static void osl_diagnose_backtrace_Impl (oslDebugMessageFunc f)
 {
-	struct frame * fp;
 	jmp_buf        ctx;
+	long           fpval;
+	struct frame * fp;
 	int            i;
 
 #if defined(SPARC)
 	asm("ta 3");
 #endif /* SPARC */
+
 	setjmp (ctx);
-	fp = (struct frame*)(((size_t*)(ctx))[FRAME_PTR_OFFSET]);
+	fpval = ((long*)(ctx))[FRAME_PTR_OFFSET];
 
+	fp = (struct frame*)((char*)(fpval) + STACK_BIAS);
 	for (i = 0; (i < FRAME_OFFSET) && (fp != 0); i++)
-		fp = fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 
 	for (i = 0; fp && fp->fr_savpc; i++)
 	{
 		osl_diagnose_frame_Impl (f, i, (void*)(fp->fr_savpc));
-		fp = fp->fr_savfp;
+		fp = (struct frame*)((char*)(fp->fr_savfp) + STACK_BIAS);
 	}
 }
 
Index: sal/osl/unx/makefile.mk
===================================================================
RCS file: /cvs/porting/sal/osl/unx/makefile.mk,v
retrieving revision 1.25
retrieving revision 1.25.62.1
diff -u -p -u -r1.25 -r1.25.62.1
--- sal/osl/unx/makefile.mk	4 Feb 2004 15:30:47 -0000	1.25
+++ sal/osl/unx/makefile.mk	18 Aug 2004 13:19:07 -0000	1.25.62.1
@@ -150,7 +150,7 @@ APP1STDLIBS+=-lC
 
 .INCLUDE :  target.mk
 
-.IF "$(OS)$(CPU)"=="SOLARISS" || "$(OS)$(CPU)"=="NETBSDS" || "$(OS)$(CPU)"=="LINUXS"
+.IF "$(OS)$(CPU)"=="SOLARISS" || "$(OS)$(CPU)"=="SOLARISS64B" || "$(OS)$(CPU)"=="NETBSDS" || "$(OS)$(CPU)"=="LINUXS" 
 
 $(SLO)$/interlck.obj: $(SLO)$/interlck.o
 	 touch $(SLO)$/interlck.obj
Index: sal/osl/unx/util.c
===================================================================
RCS file: /cvs/porting/sal/osl/unx/util.c,v
retrieving revision 1.8
retrieving revision 1.6.62.2
diff -u -p -u -r1.8 -r1.6.62.2
--- sal/osl/unx/util.c	8 Sep 2004 16:44:30 -0000	1.8
+++ sal/osl/unx/util.c	18 Oct 2004 16:30:55 -0000	1.6.62.2
Index: sal/osl/unx/asm/interlck_sparc.s
===================================================================
RCS file: /cvs/porting/sal/osl/unx/asm/interlck_sparc.s,v
retrieving revision 1.5
retrieving revision 1.3.196.2
diff -u -p -u -r1.5 -r1.3.196.2
--- sal/osl/unx/asm/interlck_sparc.s	9 Sep 2004 11:45:50 -0000	1.5
+++ sal/osl/unx/asm/interlck_sparc.s	18 Oct 2004 16:32:13 -0000	1.3.196.2
Index: sal/rtl/source/macro.hxx
===================================================================
RCS file: /cvs/porting/sal/rtl/source/macro.hxx,v
retrieving revision 1.3
retrieving revision 1.3.12.1
diff -u -p -u -r1.3 -r1.3.12.1
--- sal/rtl/source/macro.hxx	11 Jun 2004 11:56:30 -0000	1.3
+++ sal/rtl/source/macro.hxx	1 Jul 2004 16:08:04 -0000	1.3.12.1
@@ -96,6 +96,8 @@ this is inserted for the case that the p
 #define THIS_ARCH "SPARC"
 #elif defined IRIX
 #define THIS_ARCH "MIPS"
+#elif defined X86_64
+#define THIS_ARCH "X86_64"
 #endif
 
 #if ! defined THIS_ARCH
Index: sal/textenc/convertsinglebytetobmpunicode.cxx
===================================================================
RCS file: /cvs/porting/sal/textenc/convertsinglebytetobmpunicode.cxx,v
retrieving revision 1.2
retrieving revision 1.2.4.1
diff -u -p -u -r1.2 -r1.2.4.1
--- sal/textenc/convertsinglebytetobmpunicode.cxx	17 Jun 2004 11:41:43 -0000	1.2
+++ sal/textenc/convertsinglebytetobmpunicode.cxx	1 Jul 2004 16:08:04 -0000	1.2.4.1
@@ -164,7 +164,8 @@ sal_Size rtl_textenc_convertBmpUnicodeTo
         }
         // Linearly searching through the ranges if probably fastest, assuming
         // that most converted characters belong to the ASCII subset:
-        for (std::size_t i = 0; i < entries; ++i) {
+	sal_Size i;
+        for (i = 0; i < entries; ++i) {
             if (c < ranges[i].unicode) {
                 break;
             } else if (c <= ranges[i].unicode + ranges[i].range) {
Index: sal/workben/makefile.mk
===================================================================
RCS file: /cvs/porting/sal/workben/makefile.mk,v
retrieving revision 1.12
retrieving revision 1.12.172.1
diff -u -p -u -r1.12 -r1.12.172.1
--- sal/workben/makefile.mk	12 Jun 2003 09:47:35 -0000	1.12
+++ sal/workben/makefile.mk	25 Aug 2004 16:34:21 -0000	1.12.172.1
@@ -66,29 +66,25 @@ PRJNAME=sal
 TARGET=workben
 LIBTARGET=NO
 TARGETTYPE=CUI
+NO_DEFAULT_STL=TRUE
 ENABLE_EXCEPTIONS=TRUE
 
-TESTAPP=test_osl_getVolInfo
-#TESTAPP=test_osl_joinProcess
-#TESTAPP=getlocaleinfotest
+#TESTAPP=test_osl_getVolInfo
 #TESTAPP=test_osl_joinProcess
 #TESTAPP=getlocaleinfotest
 #TESTAPP=salstattest
 #TESTAPP=saldyntest
 
+TESTAPP=t_alloc
 #TESTAPP=t_cipher
 #TESTAPP=t_digest
 #TESTAPP=t_random
-#TESTAPP=t_layer
-#TESTAPP=t_tls
-#TESTAPP=t_zip
 
 #TESTAPP=testfile
 #TESTAPP=testpipe
 #TESTAPP=testpip2
 #TESTAPP=testproc
 #TESTAPP=tgetpwnam
-#TESTAPP=salstattest
 
 # --- Settings -----------------------------------------------------
 
@@ -96,6 +92,9 @@ TESTAPP=test_osl_getVolInfo
 
 # --- Files --------------------------------------------------------
 
+#
+# test_osl_getVolInfo.
+#
 .IF "$(TESTAPP)" == "test_osl_getVolInfo"    
 
 SHL1OBJS=$(SLO)$/t_osl_getVolInfo.obj
@@ -111,14 +110,19 @@ SHL1STDLIBS+=$(SOLARLIBDIR)$/cppunit.lib
 SHL1STDLIBS=$(LB)$/libsal.so
 SHL1STDLIBS+=$(SOLARLIBDIR)$/libcppunit$(DLLPOSTFIX).a
 .ENDIF
-	
+
 SHL1IMPLIB=i$(SHL1TARGET) 
 SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 DEF1NAME=$(SHL1TARGET) 
 DEF1EXPORTFILE=export.exp
-.ENDIF
 
+.ENDIF # test_osl_getVolInfo
+
+#
+# test_osl_joinProcess.
+#
 .IF "$(TESTAPP)" == "test_osl_joinProcess"    
+
 OBJFILES=$(OBJ)$/t_ojp_exe.obj 
 APP1TARGET=ojpx
 APP1OBJS=$(OBJFILES)
@@ -140,13 +144,17 @@ SHL1STDLIBS+=$(SOLARLIBDIR)$/cppunit.lib
 SHL1STDLIBS=$(LB)$/libsal.so
 SHL1STDLIBS+=$(SOLARLIBDIR)$/libcppunit$(DLLPOSTFIX).a
 .ENDIF
-	
+
 SHL1IMPLIB=i$(SHL1TARGET) 
 SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 DEF1NAME=$(SHL1TARGET) 
 DEF1EXPORTFILE=export.exp
-.ENDIF
 
+.ENDIF # test_osl_joinProcess
+
+#
+# getlocaleinfotest.
+#
 .IF "$(TESTAPP)" == "getlocaleinfotest"
 
 	OBJFILES=$(OBJ)$/getlocaleinfotest.obj
@@ -163,8 +171,11 @@ DEF1EXPORTFILE=export.exp
 
 	APP1DEPN=$(LB)$/isal.lib
 
-.ENDIF
+.ENDIF # getlocaleinfotest
 
+#
+# salstattest.
+#
 .IF "$(TESTAPP)" == "salstattest"
 
 	CFLAGS+= -DUSE_SAL_STATIC
@@ -184,6 +195,9 @@ DEF1EXPORTFILE=export.exp
 
 .ENDIF # salstattest
 
+#
+# saldyntest.
+#
 .IF "$(TESTAPP)" == "saldyntest"
 
 	OBJFILES=	$(OBJ)$/saldyntest.obj
@@ -202,6 +216,25 @@ DEF1EXPORTFILE=export.exp
 .ENDIF # salstattest
 
 #
+# t_alloc.
+#
+.IF "$(TESTAPP)" == "t_alloc"
+
+CFILES=		t_alloc.c
+OBJFILES=	$(OBJ)$/t_alloc.obj
+
+APP1TARGET=	t_alloc
+APP1OBJS=	$(OBJFILES)
+APP1OBJS+=	$(SLO)$/alloc.o $(SLO)$/diagnose.o
+APP1STDLIBS=
+APP1DEPN=
+
+APP1LIBSALCPPRT=$(0)
+STDLIBCUIMT+=-lc -ldl
+
+.ENDIF # t_alloc
+
+#
 # t_cipher
 #
 .IF "$(TESTAPP)" == "t_cipher"
@@ -247,75 +280,6 @@ APP3DEPN=	$(SLB)$/sal.lib
 .ENDIF # t_random
 
 #
-# t_layer.
-#
-.IF "$(TESTAPP)" == "t_layer"
-
-CFILES=		t_layer.c
-OBJFILES=	$(OBJ)$/t_layer.obj
-
-APP4TARGET=	t_layer
-APP4OBJS=	$(OBJFILES)
-APP4STDLIBS=$(SALLIB)
-APP4DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_layer
-
-#
-# t_tls.
-#
-.IF "$(TESTAPP)" == "t_tls"
-
-CFILES=		t_tls.c
-OBJFILES=	$(OBJ)$/t_tls.obj
-
-.IF "$(SALTLSLIB)" == ""
-
-.IF "$(GUI)" == "UNX"
-SALTLSLIB=		-lsaltls2
-.ENDIF # unx
-
-.IF "$(GUI)" == "WNT"
-SALTLSLIB=		isaltls.lib
-.ENDIF # wnt
-
-.ENDIF # saltlslib
-
-APP5TARGET=	t_tls
-APP5OBJS=	$(OBJFILES)
-APP5STDLIBS=$(SALTLSLIB) $(SALLIB)
-APP5DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_tls
-
-#
-# t_zip.
-#
-.IF "$(TESTAPP)" == "t_zip"
-
-CFILES=		t_zip.c
-OBJFILES=	$(OBJ)$/t_zip.obj
-
-.IF "$(SALZIPLIB)" == ""
-
-.IF "$(GUI)" == "UNX"
-SALZIPLIB=	-lsalzip2
-.ENDIF # unx
-
-.IF "$(GUI)" == "WNT"
-SALZIPLIB=	isalzip.lib
-.ENDIF # wnt
-
-.ENDIF # salziplib
-
-APP6TARGET=	t_zip
-APP6OBJS=	$(OBJFILES)
-APP6STDLIBS=$(SALZIPLIB) $(SALLIB)
-APP6DEPN=	$(SLB)$/sal.lib
-
-.ENDIF # t_zip
-
-#
 # testfile
 #
 .IF "$(TESTAPP)" == "testfile"
@@ -338,10 +302,10 @@ APP1DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testpipe.cxx
 OBJFILES=	$(OBJ)$/testpipe.obj
 
-APP2TARGET= testpipe
-APP2OBJS=   $(OBJFILES)
-APP2STDLIBS=$(SALLIB)
-APP2DEPN=	$(SLB)$/sal.lib
+APP1TARGET= testpipe
+APP1OBJS=   $(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testpipe
 
@@ -353,10 +317,10 @@ APP2DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testpip2.cxx
 OBJFILES=	$(OBJ)$/testpip2.obj
 
-APP3TARGET=	testpip2
-APP3OBJS=	$(OBJFILES)
-APP3STDLIBS=$(SALLIB)
-APP3DEPN=	$(SLB)$/sal.lib
+APP1TARGET=	testpip2
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testpip2
 
@@ -368,10 +332,10 @@ APP3DEPN=	$(SLB)$/sal.lib
 CXXFILES=	testproc.cxx
 OBJFILES=	$(OBJ)$/testproc.obj
 
-APP4TARGET= testproc
-APP4OBJS=	$(OBJFILES)
-APP4STDLIBS=$(SALLIB)
-APP4DEPN=	$(SLB)$/sal.lib
+APP1TARGET= testproc
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # testproc
 
@@ -384,10 +348,10 @@ APP4DEPN=	$(SLB)$/sal.lib
 CXXFILES=	tgetpwnam.cxx
 OBJFILES=	$(OBJ)$/tgetpwnam.obj
 
-APP5TARGET= tgetpwnam
-APP5OBJS=	$(OBJFILES)
-APP5STDLIBS=$(SALLIB)
-APP5DEPN=	$(SLB)$/sal.lib
+APP1TARGET= tgetpwnam
+APP1OBJS=	$(OBJFILES)
+APP1STDLIBS=$(SALLIB)
+APP1DEPN=	$(SLB)$/sal.lib
 
 .ENDIF # (sco | netbsd | freebsd)
 .ENDIF # tgetpwname
Index: sal/workben/t_alloc.c
===================================================================
RCS file: sal/workben/t_alloc.c
diff -N sal/workben/t_alloc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sal/workben/t_alloc.c	25 Aug 2004 16:34:21 -0000	1.2.4.1
@@ -0,0 +1,508 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Matthias Huetsch <matthias.huetsch@sun.com>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SAL_TYPES_H_
+#include <sal/types.h>
+#endif
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+
+#ifndef _RTL_ALLOC_H_
+#include <rtl/alloc.h>
+#endif
+
+#ifndef INCLUDED_STDLIB_H
+#include <stdlib.h>
+#define INCLUDED_STDLIB_H
+#endif
+
+#ifndef INCLUDED_STDIO_H
+#include <stdio.h>
+#define INCLUDED_STDIO_H
+#endif
+
+/*============================================================================
+ *
+ * Pseudo Random Number Generator.
+ *
+ *==========================================================================*/
+struct __random_generator_st
+{
+	sal_Int16 m_nX;
+	sal_Int16 m_nY;
+	sal_Int16 m_nZ;
+};
+
+struct __random_parameter_st
+{
+	sal_Int32 m_nA; /* lower bound */
+	sal_Int32 m_nB; /* upper bound */
+};
+
+/*
+ * __random_update.
+ */
+#define __random_update(x, y, z) \
+{ \
+	(x) = 170 * ((x) % 178) - 63 * ((x) / 178); \
+	if ((x) < 0) (x) += 30328L; \
+	\
+	(y) = 171 * ((y) % 177) -  2 * ((y) / 177); \
+	if ((y) < 0) (y) += 30269L; \
+	\
+	(z) = 172 * ((z) % 176) - 35 * ((z) / 176); \
+	if ((z) < 0) (z) += 30307L; \
+}
+
+/*
+ * __random_generate.
+ */
+static double __random_generate (struct __random_generator_st * state)
+{
+	register double random;
+
+	__random_update (state->m_nX, state->m_nY, state->m_nZ);
+	random = (((double)(state->m_nX) / 30328.0) +
+			  ((double)(state->m_nY) / 30269.0) +
+			  ((double)(state->m_nZ) / 30307.0)   );
+
+	random -= ((double)((sal_uInt32)(random)));
+	return (random);
+}
+
+/*
+ * __random.
+ */
+static struct __random_generator_st g_random =
+{
+	1, 1, 1
+};
+
+static double __random (struct __random_parameter_st * params)
+{
+	register double random;
+
+	random  = __random_generate (&(g_random));
+	if (params)
+	{
+		random *= (double)(params->m_nB - params->m_nA);
+		random += (double)(params->m_nA);
+	}
+	return (random);
+}
+
+/*============================================================================
+ *
+ * __memory_info_st.
+ *
+ *==========================================================================*/
+
+typedef struct __memory_info_st memory_type;
+struct __memory_info_st
+{
+	sal_Int32     m_ttl;
+
+	memory_type * m_flink;
+	memory_type * m_blink;
+};
+
+#define queue_start(entry) \
+{ \
+	(entry)->m_flink = (entry); \
+	(entry)->m_blink = (entry); \
+}
+
+#define queue_remove(entry) \
+{ \
+	(entry)->m_blink->m_flink = (entry)->m_flink; \
+	(entry)->m_flink->m_blink = (entry)->m_blink; \
+	queue_start(entry); \
+}
+
+#define queue_insert_head(head, entry) \
+{ \
+	(entry)->m_blink = (head); \
+	(entry)->m_flink = (head)->m_flink; \
+	(head)->m_flink = (entry); \
+	(entry)->m_flink->m_blink = (entry); \
+}
+
+#define queue_insert_tail(head, entry) \
+{ \
+	(entry)->m_flink = (head); \
+	(entry)->m_blink = (head)->m_blink; \
+	(head)->m_blink = (entry); \
+	(entry)->m_blink->m_flink = (entry); \
+}
+
+/*============================================================================
+ *
+ * __memory_global_st.
+ *
+ *==========================================================================*/
+struct __memory_global_st
+{
+	memory_type                  m_queue_head;
+	struct __random_parameter_st m_param_size;
+	struct __random_parameter_st m_param_ttl;
+};
+
+static struct __memory_global_st g_memory =
+{
+	{ 0, &(g_memory.m_queue_head), &(g_memory.m_queue_head) },
+	{ sizeof(memory_type), 2000 },
+	{ 1, 10 }
+};
+
+/*============================================================================
+ *
+ * __memory_tests.
+ *
+ *==========================================================================*/
+struct __memory_allocator_st
+{
+	/* 'malloc()' */
+	void * (SAL_CALL * m_create)(size_t);
+
+	/* 'realloc()' */
+	void * (SAL_CALL * m_resize)(void *, size_t);
+
+	/* 'free()' */
+	void (SAL_CALL * m_delete)(void *);
+};
+
+static void __memory_test_random (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry, *memory;
+	sal_uInt32   n;
+
+	n = (sal_uInt32)(__random (&(g_memory.m_param_size)));
+	memory = (allocator->m_create)(n);
+	if (memory)
+	{
+		sal_Int32 k;
+
+		k = (sal_Int32)(__random (&(g_memory.m_param_ttl)));
+		memory->m_ttl = k;
+
+		head = &(g_memory.m_queue_head);
+		for (entry = head->m_flink; entry != head; entry = entry->m_flink)
+		{
+			if (entry->m_ttl >= k)
+				break;
+		}
+		queue_insert_tail (entry, memory);
+	}
+
+	head = &(g_memory.m_queue_head);
+	for (entry = head->m_flink; entry != head; entry = entry->m_flink)
+	{
+		entry->m_ttl -= 1;
+	}
+
+	head = &(g_memory.m_queue_head);
+	while (((entry = head->m_flink) != head) && (entry->m_ttl <= 0))
+	{
+		queue_remove (entry);
+		(allocator->m_delete)(entry);
+	}
+}
+
+static void __memory_test_grow (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry, *memory;
+	sal_Int32    n = 10240;
+
+	head = &(g_memory.m_queue_head);
+	if ((entry = head->m_flink) != head)
+	{
+		n = entry->m_ttl + 1024;
+	}
+
+	memory = (allocator->m_create)(sizeof(memory_type));
+	if (memory != 0)
+	{
+		memory->m_ttl = sizeof(memory_type);
+		queue_insert_tail (head, memory);
+	}
+
+	if (allocator->m_resize)
+	{
+		memory = 0;
+		if (entry != head)
+		{
+			queue_remove (entry);
+			memory = entry;
+		}
+
+		memory = (allocator->m_resize)(memory, n);
+		if (memory != 0)
+		{
+			memory->m_ttl = n;
+			queue_insert_head (head, memory);
+		}
+	}
+	else
+	{
+		memory = (allocator->m_create)(n);
+		if (memory != 0)
+		{
+			memory->m_ttl = n;
+			queue_insert_head (head, memory);
+		}
+		if (entry != head)
+		{
+			queue_remove (entry);
+			(allocator->m_delete)(entry);
+		}
+	}
+}
+
+static void __memory_test_cleanup (struct __memory_allocator_st * allocator)
+{
+	memory_type *head, *entry;
+
+	head = &(g_memory.m_queue_head);
+	while ((entry = head->m_flink) != head)
+	{
+		queue_remove (entry);
+		(allocator->m_delete)(entry);
+	}
+}
+
+/*============================================================================
+ *
+ * heap.
+ *
+ *==========================================================================*/
+#ifdef HAVE_HEAP_H
+#include "heap.h"
+
+struct __heap_info_st
+{
+	union
+	{
+		heap_type m_heap;
+		char      m_data[0x10000];
+	} m_union;
+
+	int m_magic;
+};
+
+static struct __heap_info_st g_heap =
+{
+	{ HEAP_INITIALIZER },
+	0
+};
+
+static void * __heap_alloc (size_t n)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	return heap_alloc (&(g_heap.m_union.m_heap), n);
+}
+
+static void * __heap_realloc (void * p, size_t n)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	return heap_realloc (&(g_heap.m_union.m_heap), p, n);
+}
+
+static void __heap_free (void * p)
+{
+	if (g_heap.m_magic == 0)
+	{
+		heap_init (&(g_heap.m_union.m_heap), sizeof(g_heap.m_union));
+		g_heap.m_magic = 1;
+	}
+	heap_free (&(g_heap.m_union.m_heap), p);
+}
+
+static struct __memory_allocator_st g_heap_allocator =
+{
+	__heap_alloc,
+	__heap_realloc,
+	__heap_free
+};
+
+#endif /* HAVE_HEAP_H */
+
+/*============================================================================
+ *
+ * main.
+ *
+ *==========================================================================*/
+static struct __memory_allocator_st g_rtl_allocator =
+{
+	rtl_allocateMemory,
+	rtl_reallocateMemory,
+	rtl_freeMemory
+};
+
+static struct __memory_allocator_st g_std_allocator =
+{
+	malloc,
+	realloc,
+	free
+};
+
+enum __memory_options
+{
+	OPTION_TEST_RANDOM = 0x01,
+	OPTION_TEST_GROW   = 0x02
+};
+
+static void usage (void)
+{
+	printf ("Usage:\tt_alloc [-a <rtl|std>] [-n <num>]\n");
+
+	printf ("\nOptions:\n");
+	printf ("-a\tallocator  [default: rtl]\n");
+	printf ("-n\titerations [default: 10000]\n");
+	printf ("-h\thelp\n");
+
+	exit (0);
+}
+
+int SAL_CALL main (int argc, char **argv)
+{
+	struct __memory_allocator_st * allocator = &g_rtl_allocator;
+	int options = OPTION_TEST_RANDOM;
+	int i, n = 10000;
+
+	/* parse options */
+	for (i = 1; i < argc; i++)
+	{
+		const char *opt = argv[i]; char c;
+		switch (opt[0])
+		{
+			case '-':
+				switch (opt[1])
+				{
+					case 'a':
+						opt = argv[++i]; c = opt ? opt[0] : 0;
+						switch (c)
+						{
+							case 'r':
+								allocator = &g_rtl_allocator;
+								break;
+							case 's':
+								allocator = &g_std_allocator;
+								break;
+							default:
+								usage();
+								break;
+						}
+						break;
+
+					case 'n':
+						opt = argv[++i]; c = opt ? opt[0] : 0;
+						if (('0' <= c) && (c <= '9'))
+							n = atoi(opt);
+						else
+							usage();
+						break;
+
+					case 'h':
+					default:
+						usage();
+						break;
+				}
+				break;
+
+			default:
+				usage();
+				break;
+		}
+	}
+
+	/* execute options */
+	if (options & OPTION_TEST_RANDOM)
+	{
+		/* allocate/deallocate w/ random distribution */
+		for (i = n; i > 0; i--)
+			__memory_test_random (allocator);
+
+		/* free still allocated memory */
+		__memory_test_cleanup (allocator);
+	}
+	if (options & OPTION_TEST_GROW)
+	{
+		/* allocate w/ growing distribution */
+		for (i = n; i > 0; i--)
+			__memory_test_grow (allocator);
+
+		/* free still allocated memory */
+		__memory_test_cleanup (allocator);
+	}
+
+	/* finished */
+	return 0;
+}
