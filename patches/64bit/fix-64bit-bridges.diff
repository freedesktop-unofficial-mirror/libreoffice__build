--- /dev/null	2004-10-02 05:17:35.000000000 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/call.s	2005-05-06 13:30:19.863433917 +0200
@@ -0,0 +1,94 @@
+	.text
+	.align 2
+.globl privateSnippetExecutor
+	.type	privateSnippetExecutor, @function
+privateSnippetExecutor:
+.LFB3:
+	pushq	%rbp
+.LCFI0:
+	movq	%rsp, %rbp
+.LCFI1:
+	subq	$160, %rsp
+.LCFI2:
+	movq	%r11, -152(%rbp)		# Save (nVtableOffset << 32) + nFunctionIndex
+
+	movq	%rdi, -112(%rbp)		# Save GP registers
+	movq	%rsi, -104(%rbp)
+	movq	%rdx, -96(%rbp)
+	movq	%rcx, -88(%rbp)
+	movq	%r8 , -80(%rbp)
+	movq	%r9 , -72(%rbp)
+	
+	movsd	%xmm0, -64(%rbp)		# Save FP registers
+	movsd	%xmm1, -56(%rbp)
+	movsd	%xmm2, -48(%rbp)
+	movsd	%xmm3, -40(%rbp)
+	movsd	%xmm4, -32(%rbp)
+	movsd	%xmm5, -24(%rbp)
+	movsd	%xmm6, -16(%rbp)
+	movsd	%xmm7, -8(%rbp)
+
+	leaq	-144(%rbp), %r9			# 6th param: sal_uInt64 * pRegisterReturn
+	leaq	16(%rbp), %r8			# 5rd param: void ** ovrflw
+	leaq	-64(%rbp), %rcx			# 4th param: void ** fpreg
+	leaq	-112(%rbp), %rdx		# 3rd param: void ** gpreg
+	movl	-148(%rbp), %esi		# 2nd param: sal_int32 nVtableOffset
+	movl	-152(%rbp), %edi		# 1st param: sal_int32 nFunctionIndex
+	
+	call	cpp_vtable_call
+
+	cmp	$10, %rax			# typelib_TypeClass_FLOAT
+	je	.Lfloat
+	cmp	$11, %rax			# typelib_TypeClass_DOUBLE
+	je	.Lfloat
+
+	movq	-144(%rbp), %rax		# Return value (int case)
+	jmp	.Lfinish
+.Lfloat:
+	movlpd	-144(%rbp), %xmm0		# Return value (float/double case)
+
+.Lfinish:
+	leave
+	ret
+.LFE3:
+	.size	privateSnippetExecutor, .-privateSnippetExecutor
+	.section	.eh_frame,"a",@progbits
+.Lframe1:
+	.long	.LECIE1-.LSCIE1
+.LSCIE1:
+	.long	0x0
+	.byte	0x1
+	.string	"zP"
+	.uleb128 0x1
+	.sleb128 -8
+	.byte	0x10
+	.uleb128 0x9
+	.byte	0x0
+	.quad	__gxx_personality_v0
+	.byte	0xc
+	.uleb128 0x7
+	.uleb128 0x8
+	.byte	0x90
+	.uleb128 0x1
+	.align 8
+.LECIE1:
+.LSFDE1:
+	.long	.LEFDE1-.LASFDE1
+.LASFDE1:
+	.long	.LASFDE1-.Lframe1
+	.quad	.LFB3
+	.quad	.LFE3-.LFB3
+	.uleb128 0x0
+	.byte	0x4
+	.long	.LCFI0-.LFB3
+	.byte	0xe
+	.uleb128 0x10
+	.byte	0x86
+	.uleb128 0x2
+	.byte	0x4
+	.long	.LCFI1-.LCFI0
+	.byte	0xd
+	.uleb128 0x6
+	.align 8
+.LEFDE1:
+	.section	.note.GNU-stack,"",@progbits
--- bridges/prj/build.lst	1 Mar 2005 12:11:09 -0000	1.32
+++ bridges/prj/build.lst	6 May 2005 11:53:59 -0000
@@ -8,7 +8,7 @@ br	bridges\source\remote\context			nmake
 br	bridges\source\cpp_uno\msvc_win32_intel	nmake	-	w	br_msci br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_intel	nmake	-	u	br_gcc3li br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_freebsd_intel	nmake	-	u	br_gcc3fi br_cppuno_shared br_unotypes NULL
-br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcclp3 br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared NULL
--- bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	9 Mar 2004 12:10:55 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	6 May 2005 11:53:59 -0000
@@ -66,11 +66,15 @@
 #include <rtl/alloc.h>
 #include <osl/mutex.hxx>
 
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <uno/data.h>
 #include <typelib/typedescription.hxx>
 
-#include <bridges/cpp_uno/bridge.hxx>
-#include <bridges/cpp_uno/type_misc.hxx>
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
 
 #include "share.hxx"
 
@@ -78,9 +82,6 @@ using namespace ::osl;
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 
-namespace CPPU_CURRENT_NAMESPACE
-{
-
 // 6 integral parameters are passed in registers
 const sal_uInt32 GPR_COUNT = 6;
 
@@ -88,11 +92,8 @@ const sal_uInt32 GPR_COUNT = 6;
 const sal_uInt32 FPR_COUNT = 8;
 
 //==================================================================================================
-rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
-
-//==================================================================================================
 static typelib_TypeClass cpp2uno_call(
-	cppu_cppInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
 	const typelib_TypeDescription * pMemberTypeDescr,
 	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
 	sal_Int32 nParams, typelib_MethodParameter * pParams,
@@ -117,7 +118,7 @@ static typelib_TypeClass cpp2uno_call(
 	
 	if (pReturnTypeDescr)
 	{
-		if (cppu_isSimpleType( pReturnTypeDescr ))
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
 		{
 			pUnoReturn = pRegisterReturn; // direct way for simple types
 		}
@@ -127,7 +128,7 @@ static typelib_TypeClass cpp2uno_call(
 			gpreg++;
 			nr_gpr++;
 			
-			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
+			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
 						  ? alloca( pReturnTypeDescr->nSize )
 						  : pCppReturn); // direct way
 		}
@@ -153,7 +154,7 @@ static typelib_TypeClass cpp2uno_call(
 		typelib_TypeDescription * pParamTypeDescr = 0;
 		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
 
-		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) // value
 		{
 			if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT
 				|| pParamTypeDescr->eTypeClass == typelib_TypeClass_DOUBLE)
@@ -216,11 +217,11 @@ static typelib_TypeClass cpp2uno_call(
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
 			// is in/inout
-			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
 			{
 				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
 										*(void **)pCppStack, pParamTypeDescr,
-										&pThis->pBridge->aCpp2Uno );
+										pThis->getBridge()->getCpp2Uno() );
 				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
 				// will be released at reconversion
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
@@ -239,7 +240,7 @@ static typelib_TypeClass cpp2uno_call(
 	uno_Any * pUnoExc = &aUnoExc;
 
 	// invoke uno dispatch call
-	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
 	
 	// in case an exception occured...
 	if (pUnoExc)
@@ -256,7 +257,7 @@ static typelib_TypeClass cpp2uno_call(
 		if (pReturnTypeDescr)
 			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
 		
-		raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); // has to destruct the any
 		// is here for dummy
 		return typelib_TypeClass_VOID;
 	}
@@ -273,7 +274,7 @@ static typelib_TypeClass cpp2uno_call(
 				// convert and assign
 				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
 				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
-										&pThis->pBridge->aUno2Cpp );
+										pThis->getBridge()->getUno2Cpp() );
 			}
 			// destroy temp uno param
 			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
@@ -286,7 +287,7 @@ static typelib_TypeClass cpp2uno_call(
 			if (pUnoReturn != pCppReturn) // needs reconversion
 			{
 				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
-										&pThis->pBridge->aUno2Cpp );
+										pThis->getBridge()->getUno2Cpp() );
 				// destroy temp uno return
 				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
 			}
@@ -306,31 +307,32 @@ static typelib_TypeClass cpp2uno_call(
 
 
 //==================================================================================================
-static typelib_TypeClass cpp_mediate(
-	sal_Int32 nVtableCall,
+extern "C" typelib_TypeClass cpp_vtable_call(
+	sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
 	void ** gpreg, void ** fpreg, void ** ovrflw,
 	sal_uInt64 * pRegisterReturn /* space for register return */ )
 {
 	// gpreg:  [ret *], this, [other gpr params]
 	// fpreg:  [fpr params]
 	// ovrflw: [gpr or fpr params (properly aligned)]
-
-	// _this_ ptr is patched cppu_XInterfaceProxy object
-	cppu_cppInterfaceProxy * pCppI = NULL;
-	if( nVtableCall & 0x80000000 )
+	void * pThis;
+	if ( nFunctionIndex & 0x80000000 )
 	{
-		nVtableCall &= 0x7fffffff;
-		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg +1);
+		nFunctionIndex &= 0x7fffffff;
+		pThis = gpreg[1];
 	}
 	else
-    {
-		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg);
-    }
+		pThis = gpreg[0];
     
-	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
-	
-	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
-	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	pThis = static_cast< char * >( pThis ) - nVtableOffset;
+
+	bridges::cpp_uno::shared::CppInterfaceProxy * pCppI =
+		bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy( pThis );
+
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
+	if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
 	{
 		throw RuntimeException(
             OUString::createFromAscii("illegal vtable index!"),
@@ -338,8 +340,8 @@ static typelib_TypeClass cpp_mediate(
 	}
 	
 	// determine called method
-	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
-	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
 	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!\n" );
 
 	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
@@ -349,7 +351,7 @@ static typelib_TypeClass cpp_mediate(
 	{
 	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
 	{
-		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
 		{
 			// is GET method
 			eRet = cpp2uno_call(
@@ -378,7 +380,7 @@ static typelib_TypeClass cpp_mediate(
 	case typelib_TypeClass_INTERFACE_METHOD:
 	{
 		// is METHOD
-		switch (nVtableCall)
+		switch (nFunctionIndex)
 		{
 		case 1: // acquire()
 			pCppI->acquireProxy(); // non virtual call!
@@ -395,9 +397,9 @@ static typelib_TypeClass cpp_mediate(
 			if (pTD)
 			{
                 XInterface * pInterface = 0;
-                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
-                    pCppI->pBridge->pCppEnv,
-                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
+                    pCppI->getBridge()->getCppEnv(),
+                    (void **)&pInterface, pCppI->getOid().pData, (typelib_InterfaceTypeDescription *)pTD );
 			
                 if (pInterface)
                 {
@@ -437,246 +439,111 @@ static typelib_TypeClass cpp_mediate(
 }
 
 //==================================================================================================
-/**
- * is called on incoming vtable calls
- * (called by asm snippets)
- */
-static void cpp_vtable_call(sal_uInt32 nTableEntry,
-							void** ovrflw, void** gpregptr, void** fpregptr)
-{
-	sal_uInt64    gpreg[GPR_COUNT];
-	double        fpreg[FPR_COUNT];
-	
-	memcpy( gpreg, gpregptr, sizeof(gpreg) );
-	memcpy( fpreg, fpregptr, sizeof(fpreg) );
-	
-	volatile sal_uInt64 nRegReturn[3];
-	
-#ifdef DEBUG
-	fprintf(stderr, "cpp_vtable_call(%08x,...)\n", nTableEntry);
-#endif
+extern "C" void privateSnippetExecutor( ... );
 
-	sal_Bool bComplex = nTableEntry & 0x80000000 ? sal_True : sal_False;
+const int codeSnippetSize = 23;
 
-	typelib_TypeClass aType = 
-		cpp_mediate( nTableEntry, (void**)gpreg, (void**)fpreg, ovrflw, (sal_uInt64 *)nRegReturn );
-    
-	switch( aType )
-	{
-	case typelib_TypeClass_FLOAT:
-		// The value in %xmm register is already prepared to
-		// be retrieved as a float. Therefore, we pass the
-		// value verbatim, as a double without conversion.
-		__asm__( "movsd %0, %%xmm0" : : "m" (*((double *)nRegReturn)) );
-		break;
-		
-	case typelib_TypeClass_DOUBLE:
-		__asm__( "movsd %0, %%xmm0" : : "m" (*((double *)nRegReturn)) );
-		break;
-	
-	default:
-		__asm__( "movq %0, %%rax" : : "m" (*nRegReturn));
-		break;
-	}
+// Generate a piece of code that jumps to privateSnippetExecutor().
+//
+// privateSnippetExecutor() saves all the registers that are used for
+// parameter passing on x86_64, and calls the cpp_vtable_call().
+// When it returns, privateSnippetExecutor() sets the return value.
+//
+// Note: The code snippet we build here must not create a stack frame,
+// otherwise the UNO exceptions stop working thanks to non-existing
+// unwinding info.
+unsigned char * codeSnippet( unsigned char * code,
+        sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
+        bool simple_ret_type ) SAL_THROW( () )
+{
+	sal_uInt64 nOffsetAndIndex = ( ( (sal_uInt64) nVtableOffset ) << 32 ) | ( (sal_uInt64) nFunctionIndex );
+
+	if ( ! simple_ret_type )
+		nOffsetAndIndex |= 0x80000000;
+
+	unsigned char * p = code;
+
+	// movq $<nOffsetAndIndex>, %r11
+	*p++ = 0x49;
+	*p++ = 0xbb;
+	*reinterpret_cast< sal_uInt64 * >( p ) = nOffsetAndIndex;
+	p += sizeof( sal_uInt64 );
+
+	// movq $<address of the privateSnippetExecutor>, %r10
+	*p++ = 0x49;
+	*p++ = 0xba;
+	*reinterpret_cast< sal_uInt64 * >( p ) = reinterpret_cast< sal_uInt64 >( privateSnippetExecutor );
+	p += sizeof( sal_uInt64 );
+
+	// jmpq *%r10
+	*p++ = 0x49;
+	*p++ = 0xff;
+	*p++ = 0xe2;
 
-	__asm__ __volatile__ ("" : : : "rax", "xmm0");
-}
+	OSL_ASSERT( p - code <= codeSnippetSize );
 
+	return code + codeSnippetSize;
+}
 
 //==================================================================================================
-class MediateClassData
-{
-    typedef ::std::hash_map< OUString, void *, OUStringHash > t_classdata_map;
-	t_classdata_map m_map;
-	Mutex m_mutex;
-    
-public:
-	void const * get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () );
-    
-	inline MediateClassData() SAL_THROW( () )
-        {}
-	~MediateClassData() SAL_THROW( () );
-};
-//__________________________________________________________________________________________________
-MediateClassData::~MediateClassData() SAL_THROW( () )
+void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable( char * block )
 {
-	OSL_TRACE( "> calling ~MediateClassData(): freeing mediate vtables." );
-	
-	for ( t_classdata_map::const_iterator iPos( m_map.begin() ); iPos != m_map.end(); ++iPos )
-	{
-		::rtl_freeMemory( iPos->second );
-	}
+	return reinterpret_cast< void ** >(block) + 2;
 }
-//--------------------------------------------------------------------------------------------------
-/* Code to generate. Note: if you change it, make sure patch offsets
-   for nTableEntry and cpp_vtable_call() are updated too.  */
-const char code_snippet_template[] = {
-	// # make room for gpregs (48), fpregs (64)
-	0x55,								// push   %rbp
-	0x48, 0x89, 0xe5,					// mov    %rsp,%rbp
-	0x48, 0x83, 0xec, 0x70,				// sub    $112,%rsp
-	// # save GP registers
-	0x48, 0x89, 0x7d, 0x90,				// mov    %rdi,-112(%rbp)
-	0x48, 0x89, 0x75, 0x98,				// mov    %rsi,-104(%rbp)
-	0x48, 0x89, 0x55, 0xa0,				// mov    %rdx, -96(%rbp)
-	0x48, 0x89, 0x4d, 0xa8,				// mov    %rcx, -88(%rbp)
-	0x4c, 0x89, 0x45, 0xb0,				// mov    %r8 , -80(%rbp)
-	0x4c, 0x89, 0x4d, 0xb8,				// mov    %r9 , -72(%rbp)
-	0x48, 0x8d, 0x55, 0x90,				// lea    -112(%rbp),%rdx
-	// # save FP registers
-	0xf2, 0x0f, 0x11, 0x45, 0xc0,		// movsd  %xmm0,-64(%rbp)
-	0xf2, 0x0f, 0x11, 0x4d, 0xc8,		// movsd  %xmm1,-56(%rbp)
-	0xf2, 0x0f, 0x11, 0x55, 0xd0,		// movsd  %xmm2,-48(%rbp)
-	0xf2, 0x0f, 0x11, 0x5d, 0xd8,		// movsd  %xmm3,-40(%rbp)
-	0xf2, 0x0f, 0x11, 0x65, 0xe0,		// movsd  %xmm4,-32(%rbp)
-	0xf2, 0x0f, 0x11, 0x6d, 0xe8,		// movsd  %xmm5,-24(%rbp)
-	0xf2, 0x0f, 0x11, 0x75, 0xf0,		// movsd  %xmm6,-16(%rbp)
-	0xf2, 0x0f, 0x11, 0x7d, 0xf8,		// movsd  %xmm7, -8(%rbp)
-	0x48, 0x8d, 0x4d, 0xc0,				// lea    -64(%rbp),%rcx
-	// # perform the call and cleanup to cpp_vtable_call()
-	0xbf, 0x00, 0x00, 0x00, 0x00,		// mov    $0,%edi
-	0x48, 0x8d, 0x75, 0x10,				// lea    16(%rbp),%rsi
-	0x48, 0xb8, 0, 0, 0, 0,	0, 0, 0, 0,	// mov    $0,%rax
-	0xff, 0xd0,							// call   *%rax
-	0xc9,								// leave
-	0xc3								// ret
-};
 
-static inline void codeSnippet( char * code, sal_uInt32 vtable_pos, bool simple_ret_type ) SAL_THROW( () )
-{
-    if (! simple_ret_type)
-        vtable_pos |= 0x80000000;
-
-	const int code_snippet_template_size = sizeof(code_snippet_template);
-	memcpy(code, code_snippet_template, code_snippet_template_size);
-
-	// Patch nTableEntryValue
-	sal_uInt32 *mid_p  = (sal_uInt32 *)(code + code_snippet_template_size - 22);
-	*mid_p = vtable_pos;
-
-	// Patch call to cpp_vtable_call()
-	sal_uInt64 *call_p  = (sal_uInt64 *)(code + code_snippet_template_size - 12);
-	*call_p = (sal_uInt64)cpp_vtable_call;
-}
-//__________________________________________________________________________________________________
-void const * MediateClassData::get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () )
+//==================================================================================================
+char * bridges::cpp_uno::shared::VtableFactory::createBlock(
+	sal_Int32 slotCount, void *** slots)
 {
-    void * buffer;
-    const int nSnippetSize = sizeof(code_snippet_template);
-
-    // avoiding locked counts
-    OUString const & unoName = *(OUString const *)&((typelib_TypeDescription *)pTD)->pTypeName;
-    {
-	MutexGuard aGuard( m_mutex );
-	t_classdata_map::const_iterator iFind( m_map.find( unoName ) );
-	if (iFind == m_map.end())
-    {
-        // create new vtable
-        sal_Int32 nSlots = pTD->nMapFunctionIndexToMemberIndex;
-        buffer = ::rtl_allocateMemory( ((2+ nSlots) * sizeof (void *)) + (nSlots *nSnippetSize) );
-        
-        ::std::pair< t_classdata_map::iterator, bool > insertion(
-            m_map.insert( t_classdata_map::value_type( unoName, buffer ) ) );
-        OSL_ENSURE( insertion.second, "### inserting new vtable buffer failed?!\n\n" );
-        
-        void ** slots = (void **)buffer;
-        *slots++ = 0;
-        *slots++ = 0; // rtti
-        char * code = (char *)(slots + nSlots);
-        
-        sal_uInt32 vtable_pos = 0;
-        sal_Int32 nAllMembers = pTD->nAllMembers;
-        typelib_TypeDescriptionReference ** ppAllMembers = pTD->ppAllMembers;
-        for ( sal_Int32 nPos = 0; nPos < nAllMembers; ++nPos )
-        {
-            typelib_TypeDescription * pTD = 0;
-            TYPELIB_DANGER_GET( &pTD, ppAllMembers[ nPos ] );
-            OSL_ASSERT( pTD );
-            if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
-            {
-                bool simple_ret = cppu_isSimpleType(
-                    ((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
-                // get method
-                *slots = code;
-                codeSnippet( code, vtable_pos++, simple_ret );
-                code += nSnippetSize;
-                slots++;
-                if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
-                {
-                    // set method
-                    *slots = code;
-                    codeSnippet( code, vtable_pos++, true );
-                    code += nSnippetSize;
-                    slots++;
-                }
-            }
-            else
-            {
-                bool simple_ret = cppu_isSimpleType(
-                    ((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
-                *slots = code;
-                codeSnippet( code, vtable_pos++, simple_ret );
-                code += nSnippetSize;
-                slots++;
-            }
-            TYPELIB_DANGER_RELEASE( pTD );
-        }
-        OSL_ASSERT( vtable_pos == nSlots );
-    }
-    else
-    {
-        buffer = iFind->second;
-    }
-    }
-    
-    return ((void **)buffer +2);
+	char * block = new char[ (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize ];
+	*slots = mapBlockToVtable(block);
+	(*slots)[-2] = 0;
+	(*slots)[-1] = 0;
+	return block;
 }
 
 //==================================================================================================
-void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
-	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
-{
-	static MediateClassData * s_pMediateClassData = 0;
-	if (! s_pMediateClassData)
-	{
-		MutexGuard aGuard( Mutex::getGlobalMutex() );
-		if (! s_pMediateClassData)
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+	void ** slots, unsigned char * code,
+	typelib_InterfaceTypeDescription const * type, sal_Int32 nFunctionOffset,
+	sal_Int32 functionCount, sal_Int32 nVtableOffset )
+{
+	for ( sal_Int32 nPos = 0; nPos < type->nMembers; ++nPos )
+	{
+		typelib_TypeDescription * pTD = 0;
+		TYPELIB_DANGER_GET( &pTD, type->ppMembers[ nPos ] );
+		OSL_ASSERT( pTD );
+		if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
+		{
+			bool simple_ret = bridges::cpp_uno::shared::isSimpleType(
+					((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
+			// get method
+			*slots++ = code;
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset, simple_ret );
+			if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
+			{
+				// set method
+				*slots++ = code;
+				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, true );
+			}
+		}
+		else if (typelib_TypeClass_INTERFACE_METHOD == pTD->eTypeClass)
 		{
-#ifdef LEAK_STATIC_DATA
-			s_pMediateClassData = new MediateClassData();
-#else
-			static MediateClassData s_aMediateClassData;
-			s_pMediateClassData = &s_aMediateClassData;
-#endif
+			bool simple_ret = bridges::cpp_uno::shared::isSimpleType(
+					((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
+			*slots++ = code;
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset, simple_ret );
 		}
-	}
-	*(void const **)pCppI = s_pMediateClassData->get_vtable( pTypeDescr );
-}
+		else
+			OSL_ASSERT(false);
 
+		TYPELIB_DANGER_RELEASE( pTD );
+	}
+	return code;
 }
 
-extern "C"
-{
-//##################################################################################################
-sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
-	SAL_THROW_EXTERN_C()
-{
-	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload(
-        &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
-}
-//##################################################################################################
-void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
-	SAL_THROW_EXTERN_C()
-{
-	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment(
-        pCppEnv );
-}
-//##################################################################################################
-void SAL_CALL uno_ext_getMapping(
-	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
-	SAL_THROW_EXTERN_C()
+//==================================================================================================
+void bridges::cpp_uno::shared::VtableFactory::flushCode(
+	unsigned char const *, unsigned char const * )
 {
-	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping(
-        ppMapping, pFrom, pTo );
 }
-}
--- bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2005-05-06 14:15:34.285289884 +0200
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2004-06-04 04:59:59.000000000 +0200
@@ -69,7 +69,8 @@
 #include <osl/diagnose.h>
 #include <osl/mutex.hxx>
 
-#include <bridges/cpp_uno/bridge.hxx>
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <typelib/typedescription.hxx>
 #include <uno/any2.h>
 
@@ -269,11 +270,16 @@ void raiseException( uno_Any * pUnoExc, 
 	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
     OSL_ASSERT( pTypeDescr );
     if (! pTypeDescr)
-        terminate();
-    
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("cannot get typedescription for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
+    }
+
 	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
 	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
-	
+
 	// destruct uno exception
 	::uno_any_destruct( pUnoExc, 0 );
     // avoiding locked counts
@@ -295,29 +301,59 @@ void raiseException( uno_Any * pUnoExc, 
     TYPELIB_DANGER_RELEASE( pTypeDescr );
     OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
     if (! rtti)
-        terminate();
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no rtti for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
     }
-    
+    }
+
 	__cxa_throw( pCppExc, rtti, deleteException );
 }
 
 //==================================================================================================
 void fillUnoException( __cxa_exception * header, uno_Any * pUnoExc, uno_Mapping * pCpp2Uno )
 {
-    OSL_ENSURE( header, "### no exception header!!!" );
     if (! header)
-        terminate();
-    
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no exception header!") ),
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+        return;
+    }
+
 	typelib_TypeDescription * pExcTypeDescr = 0;
     OUString unoName( toUNOname( header->exceptionType->name() ) );
-	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
-    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
-    if (! pExcTypeDescr)
-        terminate();
-    
-    // construct uno exception any
-    uno_any_constructAndConvert( pUnoExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
-    typelib_typedescription_release( pExcTypeDescr );
+#if OSL_DEBUG_LEVEL > 1
+    OString cstr_unoName( OUStringToOString( unoName, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> c++ exception occured: %s\n", cstr_unoName.getStr() );
+#endif
+	typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    if (0 == pExcTypeDescr)
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("exception type not found: ") ) + unoName,
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+    }
+    else
+    {
+        // construct uno exception any
+        uno_any_constructAndConvert( pUnoExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+        typelib_typedescription_release( pExcTypeDescr );
+    }
 }
 
 }
--- bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	9 Mar 2004 12:11:14 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	6 May 2005 11:53:59 -0000
@@ -91,7 +91,8 @@ CFLAGSNOOPT=-O0
 SLOFILES= \
 	$(SLO)$/except.obj		\
 	$(SLO)$/cpp2uno.obj		\
-	$(SLO)$/uno2cpp.obj
+	$(SLO)$/uno2cpp.obj		\
+	$(SLO)$/call.obj
 
 SHL1TARGET= $(TARGET)
 
@@ -99,10 +100,8 @@ SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 SHL1IMPLIB=i$(TARGET)
 SHL1VERSIONMAP=..$/..$/bridge_exports.map
 
-SHL1OBJS= \
-	$(SLO)$/except.obj		\
-	$(SLO)$/cpp2uno.obj		\
-	$(SLO)$/uno2cpp.obj
+SHL1OBJS = $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
 
 SHL1STDLIBS= \
 	$(CPPULIB)			\
@@ -114,3 +113,6 @@ SHL1STDLIBS= \
 
 .INCLUDE :  target.mk
 
+$(SLO)$/%.obj: %.s
+    $(CC) -c -o $(SLO)$/$(@:b).o $<
+    touch $@
--- bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	9 Mar 2004 12:11:38 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	6 May 2005 11:53:59 -0000
@@ -63,18 +63,20 @@
 #include <stdlib.h>
 #include <rtl/alloc.h>
 
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <uno/data.h>
-#include <bridges/cpp_uno/bridge.hxx>
-#include <bridges/cpp_uno/type_misc.hxx>
+
+#include <bridges/cpp_uno/shared/bridge.hxx>
+#include <bridges/cpp_uno/shared/types.hxx>
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
 
 #include "share.hxx"
 
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 
-namespace CPPU_CURRENT_NAMESPACE
-{
-
 void dummy_can_throw_anything( char const * );
 
 // 6 integral parameters are passed in registers
@@ -203,7 +208,7 @@ static void callVirtualMethod(void * pTh
 	if (nr_stack)
 		nr_stack = (nr_stack + 1) & ~1;
 
-#if 1
+#if OSL_DEBUG_LEVEL > 1
 	// Let's figure out what is really going on here
 	fprintf(stderr,"callVirtualMethod() parameters string is %s\n", pPT);
 	{
@@ -327,8 +332,8 @@ static void callVirtualMethod(void * pTh
 
 //================================================================================================== 
 static void cpp_call(
-	cppu_unoInterfaceProxy * pThis,
-	sal_Int32 nVtableCall,
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::VtableSlot aVtableSlot,
 	typelib_TypeDescriptionReference * pReturnTypeRef,
 	sal_Int32 nParams, typelib_MethodParameter * pParams,
 	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
@@ -350,14 +355,14 @@ static void cpp_call(
 	
 	if (pReturnTypeDescr)
 	{
-		if (cppu_isSimpleType( pReturnTypeDescr ))
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
 		{
 			pCppReturn = pUnoReturn; // direct way for simple types
 		}
 		else
 		{
 			// complex return via ptr
-			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
+			pCppReturn = *(void **)pCppStack = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
 												? alloca( pReturnTypeDescr->nSize )
 												: pUnoReturn); // direct way
 			*pPT++ = 'H';
@@ -366,7 +371,7 @@ static void cpp_call(
 	}
 
 	// Push "this" pointer
-	*(void **)pCppStack = pThis->pCppI;
+	*(void **)pCppStack = pThis->getCppI();
 	*pPT++ = 'H';
 	pCppStack += sizeof(void *);
 
@@ -386,10 +391,10 @@ static void cpp_call(
 		typelib_TypeDescription * pParamTypeDescr = 0;
 		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
 		
-		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
 		{
 			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
-									&pThis->pBridge->aUno2Cpp );
+									pThis->getBridge()->getUno2Cpp() );
 			
 			switch (pParamTypeDescr->eTypeClass)
 			{
@@ -446,11 +451,11 @@ static void cpp_call(
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
 			// is in/inout
-			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
 			{
 				uno_copyAndConvertData(
 					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
-					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+					pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
 				
 				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
 				// will be released at reconversion
@@ -476,7 +481,7 @@ static void cpp_call(
 	{
 		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 7), "UNALIGNED STACK !!! (Please DO panic)" );
 		callVirtualMethod(
-			pThis->pCppI, nVtableCall,
+			pThis->getCppI(), aVtableSlot.index,
 			pCppReturn, pReturnTypeDescr->eTypeClass, pParamType,
 			(sal_uInt64 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_uInt64) );
 		// NO exception occured...
@@ -494,13 +499,13 @@ static void cpp_call(
 				{
 					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
 					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
-											&pThis->pBridge->aCpp2Uno );
+											pThis->getBridge()->getCpp2Uno() );
 				}
 			}
 			else // pure out
 			{
 				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
-										&pThis->pBridge->aCpp2Uno );
+										pThis->getBridge()->getCpp2Uno() );
 			}
 			// destroy temp cpp param => cpp: every param was constructed
 			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
@@ -511,14 +516,14 @@ static void cpp_call(
 		if (pCppReturn && pUnoReturn != pCppReturn)
 		{
 			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
-									&pThis->pBridge->aCpp2Uno );
+									pThis->getBridge()->getCpp2Uno() );
 			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
 		}
 	}
  	catch (...)
  	{
   		// fill uno exception
-		fillUnoException( __cxa_get_globals()->caughtExceptions, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+		fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
         
 		// temporary params
 		for ( ; nTempIndizes--; )
@@ -536,12 +541,13 @@ static void cpp_call(
 
 
 //==================================================================================================
-void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+void bridges::cpp_uno::shared::UnoInterfaceProxy::dispatch(
 	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
-	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) SAL_THROW(())
 {
 	// is my surrogate
-	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis
+		= static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy * >(pUnoI);
 	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
 	
 	switch (pMemberDescr->eTypeClass)
@@ -552,14 +558,17 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
 		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
 		
-		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
-		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		VtableSlot aVtableSlot(
+				getVtableSlot(
+					reinterpret_cast<
+					typelib_InterfaceAttributeTypeDescription const * >(
+						pMemberDescr)));
 		
 		if (pReturn)
 		{
 			// dependent dispatch
 			cpp_call(
-				pThis, nVtableCall,
+				pThis, aVtableSlot,
 				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
 				0, 0, // no params
 				pReturn, pArgs, ppException );
@@ -579,8 +588,9 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
 			
 			// dependent dispatch
+			aVtableSlot.index += 1; // get, then set method
 			cpp_call(
-				pThis, nVtableCall +1, // get, then set method
+				pThis, aVtableSlot, // get, then set method
 				pReturnTypeRef,
 				1, &aParam,
 				pReturn, pArgs, ppException );
@@ -596,10 +606,13 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
 		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
 		
-		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
-		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		VtableSlot aVtableSlot(
+				getVtableSlot(
+					reinterpret_cast<
+					typelib_InterfaceMethodTypeDescription const * >(
+						pMemberDescr)));
 		
-		switch (nVtableCall)
+		switch (aVtableSlot.index)
 		{
 			// standard calls
 		case 1: // acquire uno interface
@@ -617,8 +630,8 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 			if (pTD)
 			{
                 uno_Interface * pInterface = 0;
-                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
-                    pThis->pBridge->pUnoEnv,
+                (*pThis->getBridge()->getUnoEnv()->getRegisteredInterface)(
+                    pThis->getBridge()->getUnoEnv(),
                     (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
 			
                 if (pInterface)
@@ -637,7 +650,7 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		default:
 			// dependent dispatch
 			cpp_call(
-				pThis, nVtableCall,
+				pThis, aVtableSlot,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
@@ -657,6 +670,3 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 	}
 	}
 }
-
-}
-
