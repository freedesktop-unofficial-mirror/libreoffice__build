Index: solenv/inc/unxlngx6.mk
===================================================================
RCS file: /cvs/tools/solenv/inc/unxlngx6.mk,v
retrieving revision 1.5
retrieving revision 1.5.76.1
diff -u -p -u -p -r1.5 -r1.5.76.1
--- solenv/inc/unxlngx6.mk	20 Jan 2006 10:51:42 -0000	1.5
+++ solenv/inc/unxlngx6.mk	6 Mar 2006 11:47:01 -0000	1.5.76.1
@@ -120,7 +120,7 @@ CFLAGSDEBUG=-g
 CFLAGSDBGUTIL=
 # Compiler flags for enabling optimizations
 .IF "$(PRODUCT)"!=""
-CFLAGSOPT=-Os -fno-strict-aliasing		# optimizing for products
+CFLAGSOPT=-O2 -fno-strict-aliasing		# optimizing for products
 CFLAGSOPT+=-Wuninitialized				# not supported without optimization
 .ELSE 	# "$(PRODUCT)"!=""
 CFLAGSOPT=   							# no optimizing for non products
Index: bridges/prj/build.lst
===================================================================
RCS file: /cvs/udk/bridges/prj/build.lst,v
retrieving revision 1.33
retrieving revision 1.33.8.1
diff -u -p -u -p -r1.33 -r1.33.8.1
--- bridges/prj/build.lst	3 Feb 2006 17:34:46 -0000	1.33
+++ bridges/prj/build.lst	6 Mar 2006 11:13:50 -0000	1.33.8.1
@@ -8,7 +8,7 @@ br	bridges\source\remote\context			nmake
 br	bridges\source\cpp_uno\msvc_win32_intel	nmake	-	w	br_msci br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_intel	nmake	-	u	br_gcc3li br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_freebsd_intel	nmake	-	u	br_gcc3fi br_cppuno_shared br_unotypes NULL
-br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcclp3 br_cppuno_shared br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared NULL
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx
diff -N bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.cxx	6 Mar 2006 13:47:57 -0000	1.1.2.3
@@ -0,0 +1,808 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// This is an implementation of the x86-64 ABI as described in 'System V
+// Application Binary Interface, AMD64 Architecture Processor Supplement'
+// (http://www.x86-64.org/documentation/abi-0.95.pdf)
+//
+// The code in this file is a modification of src/x86/ffi64.c from libffi
+// (http://sources.redhat.com/libffi/) which is under the following license:
+
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2002  Bo Thorsen <bo@suse.de>
+   
+   x86-64 Foreign Function Interface 
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <abi.hxx>
+
+#include <rtl/ustring.hxx>
+
+using namespace x86_64;
+
+typedef struct
+{
+    /* Registers for argument passing.  */
+    long gpr[MAX_GPR_REGS];
+    __int128_t sse[MAX_SSE_REGS];
+
+    /* Stack space for arguments.  */
+    char argspace[0];
+} stackLayout;
+
+/* Register class used for passing given 64bit part of the argument.
+   These represent classes as documented by the PS ABI, with the exception
+   of SSESF, SSEDF classes, that are basically SSE class, just gcc will
+   use SF or DFmode move instead of DImode to avoid reformating penalties.
+
+   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
+   whenever possible (upper half does contain padding).
+ */
+enum x86_64_reg_class
+{
+    X86_64_NO_CLASS,
+    X86_64_INTEGER_CLASS,
+    X86_64_INTEGERSI_CLASS,
+    X86_64_SSE_CLASS,
+    X86_64_SSESF_CLASS,
+    X86_64_SSEDF_CLASS,
+    X86_64_SSEUP_CLASS,
+    X86_64_X87_CLASS,
+    X86_64_X87UP_CLASS,
+    X86_64_MEMORY_CLASS
+};
+
+#define MAX_CLASSES 4
+
+#define ALIGN(v, a) (((((size_t) (v))-1) | ((a)-1))+1)
+
+/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal
+   of this code is to classify each 8bytes of incoming argument by the register
+   class and assign registers accordingly.  */
+
+/* Return the union class of CLASS1 and CLASS2.
+   See the x86-64 PS ABI for details.  */
+
+static enum x86_64_reg_class
+merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)
+{
+    /* Rule #1: If both classes are equal, this is the resulting class.  */
+    if (class1 == class2)
+        return class1;
+
+    /* Rule #2: If one of the classes is NO_CLASS, the resulting class is
+       the other class.  */
+    if (class1 == X86_64_NO_CLASS)
+        return class2;
+    if (class2 == X86_64_NO_CLASS)
+        return class1;
+
+    /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
+    if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)
+        return X86_64_MEMORY_CLASS;
+
+    /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
+    if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)
+            || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))
+        return X86_64_INTEGERSI_CLASS;
+    if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS
+            || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)
+        return X86_64_INTEGER_CLASS;
+
+    /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
+    if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS
+            || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)
+        return X86_64_MEMORY_CLASS;
+
+    /* Rule #6: Otherwise class SSE is used.  */
+    return X86_64_SSE_CLASS;
+}
+
+/* Classify the argument of type TYPE and mode MODE.
+   CLASSES will be filled by the register class used to pass each word
+   of the operand.  The number of words is returned.  In case the parameter
+   should be passed in memory, 0 is returned. As a special case for zero
+   sized containers, classes[0] will be NO_CLASS and 1 is returned.
+
+   See the x86-64 PS ABI for details.
+*/
+static int
+classify_argument( typelib_TypeDescriptionReference *pTypeRef, enum x86_64_reg_class classes[], int &rByteOffset )
+{
+    /* First, align to the right place.  */
+    rByteOffset = ALIGN( rByteOffset, pTypeRef->pType->nAlignment );
+
+    switch ( pTypeRef->eTypeClass )
+    {
+        case typelib_TypeClass_VOID:
+            classes[0] = X86_64_NO_CLASS;
+            return 1;
+        case typelib_TypeClass_CHAR:
+        case typelib_TypeClass_BOOLEAN:
+        case typelib_TypeClass_BYTE:
+        case typelib_TypeClass_SHORT:
+        case typelib_TypeClass_UNSIGNED_SHORT:
+        case typelib_TypeClass_LONG:
+        case typelib_TypeClass_UNSIGNED_LONG:
+        case typelib_TypeClass_HYPER:
+        case typelib_TypeClass_UNSIGNED_HYPER:
+        case typelib_TypeClass_ENUM:
+            if ( ( rByteOffset % 8 + pTypeRef->pType->nSize ) <= 4 )
+                classes[0] = X86_64_INTEGERSI_CLASS;
+            else
+                classes[0] = X86_64_INTEGER_CLASS;
+            return 1;
+        case typelib_TypeClass_FLOAT:
+            if ( ( rByteOffset % 8 ) == 0 )
+                classes[0] = X86_64_SSESF_CLASS;
+            else
+                classes[0] = X86_64_SSE_CLASS;
+            return 1;
+        case typelib_TypeClass_DOUBLE:
+            classes[0] = X86_64_SSEDF_CLASS;
+            return 1;
+        /*case LONGDOUBLE:
+            classes[0] = X86_64_X87_CLASS;
+            classes[1] = X86_64_X87UP_CLASS;
+            return 2;*/
+        case typelib_TypeClass_STRING:
+        case typelib_TypeClass_TYPE:
+        case typelib_TypeClass_ANY:
+        case typelib_TypeClass_TYPEDEF:
+        case typelib_TypeClass_UNION:
+        case typelib_TypeClass_SEQUENCE:
+        case typelib_TypeClass_ARRAY:
+        case typelib_TypeClass_INTERFACE:
+            return 0;
+        case typelib_TypeClass_STRUCT:
+        case typelib_TypeClass_EXCEPTION:
+            {
+                typelib_TypeDescription * pTypeDescr = 0;
+                TYPELIB_DANGER_GET( &pTypeDescr, pTypeRef );
+
+                const int UNITS_PER_WORD = 8;
+                int words = ( pTypeDescr->nSize + UNITS_PER_WORD - 1 ) / UNITS_PER_WORD;
+                enum x86_64_reg_class subclasses[MAX_CLASSES];
+
+                /* If the struct is larger than 16 bytes, pass it on the stack.  */
+                if ( pTypeDescr->nSize > 16 )
+                {
+                    TYPELIB_DANGER_RELEASE( pTypeDescr );
+                    return 0;
+                }
+
+                for ( int i = 0; i < words; i++ )
+                    classes[i] = X86_64_NO_CLASS;
+
+                const typelib_CompoundTypeDescription *pStruct = reinterpret_cast<const typelib_CompoundTypeDescription*>( pTypeDescr );
+
+                /* Merge the fields of structure.  */
+                for ( sal_Int32 nMember = 0; nMember < pStruct->nMembers; ++nMember )
+                {
+                    typelib_TypeDescriptionReference *pTypeInStruct = pStruct->ppTypeRefs[ nMember ];
+
+                    int num = classify_argument( pTypeInStruct, subclasses, rByteOffset );
+
+                    if ( num == 0 )
+                    {
+                        TYPELIB_DANGER_RELEASE( pTypeDescr );
+                        return 0;
+                    }
+
+                    for ( int i = 0; i < num; i++ )
+                    {
+                        int pos = rByteOffset / 8;
+                        classes[i + pos] = merge_classes( subclasses[i], classes[i + pos] );
+                    }
+
+                    if ( pTypeInStruct->eTypeClass != typelib_TypeClass_STRUCT )
+                        rByteOffset = pStruct->pMemberOffsets[ nMember ];
+                }
+
+                TYPELIB_DANGER_RELEASE( pTypeDescr );
+
+                /* Final merger cleanup.  */
+                for ( int i = 0; i < words; i++ )
+                {
+                    /* If one class is MEMORY, everything should be passed in
+                       memory.  */
+                    if ( classes[i] == X86_64_MEMORY_CLASS )
+                        return 0;
+
+                    /* The X86_64_SSEUP_CLASS should be always preceded by
+                       X86_64_SSE_CLASS.  */
+                    if ( classes[i] == X86_64_SSEUP_CLASS
+                            && ( i == 0 || classes[i - 1] != X86_64_SSE_CLASS ) )
+                        classes[i] = X86_64_SSE_CLASS;
+
+                    /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */
+                    if ( classes[i] == X86_64_X87UP_CLASS
+                            && ( i == 0 || classes[i - 1] != X86_64_X87_CLASS ) )
+                        classes[i] = X86_64_SSE_CLASS;
+                }
+                return words;
+            }
+
+        default:
+#if OSL_DEBUG_LEVEL > 1
+            OSL_TRACE( "Unhandled case: pType->eTypeClass == %d\n", pTypeRef->eTypeClass );
+#endif
+            OSL_ASSERT(0);
+    }
+    return 0; /* Never reached.  */
+}
+
+/* Examine the argument and return set number of register required in each
+   class.  Return 0 iff parameter should be passed in memory.  */
+bool x86_64::examine_argument( typelib_TypeDescriptionReference *pTypeRef, bool bInReturn, int &nUsedGPR, int &nUsedSSE )
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int offset = 0;
+    int n;
+
+    n = classify_argument( pTypeRef, classes, offset );
+
+    if ( n == 0 )
+        return false;
+
+    nUsedGPR = 0;
+    nUsedSSE = 0;
+    for ( n--; n >= 0; n-- )
+        switch ( classes[n] )
+        {
+            case X86_64_INTEGER_CLASS:
+            case X86_64_INTEGERSI_CLASS:
+                nUsedGPR++;
+                break;
+            case X86_64_SSE_CLASS:
+            case X86_64_SSESF_CLASS:
+            case X86_64_SSEDF_CLASS:
+                nUsedSSE++;
+                break;
+            case X86_64_NO_CLASS:
+            case X86_64_SSEUP_CLASS:
+                break;
+            case X86_64_X87_CLASS:
+            case X86_64_X87UP_CLASS:
+                if ( !bInReturn )
+                    return false;
+                break;
+            default:
+#if OSL_DEBUG_LEVEL > 1
+            OSL_TRACE( "Unhandled case: classes[n] == %d\n", classes[n] );
+#endif
+            OSL_ASSERT(0);
+        }
+    return true;
+}
+
+bool x86_64::return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef )
+{
+    int g, s;
+
+    return examine_argument( pTypeRef, true, g, s ) == 0;
+}
+
+void x86_64::fill_struct( typelib_TypeDescriptionReference *pTypeRef, void * const *pGPR, void * const *pSSE, void *pStruct )
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int offset = 0;
+    int n;
+
+    n = classify_argument( pTypeRef, classes, offset );
+
+    sal_uInt64 *pStructAlign = reinterpret_cast<sal_uInt64 *>( pStruct );
+    for ( n--; n >= 0; n-- )
+        switch ( classes[n] )
+        {
+            case X86_64_INTEGER_CLASS:
+            case X86_64_INTEGERSI_CLASS:
+                *pStructAlign++ = *reinterpret_cast<sal_uInt64 *>( *pGPR++ );
+                break;
+            case X86_64_SSE_CLASS:
+            case X86_64_SSESF_CLASS:
+            case X86_64_SSEDF_CLASS:
+                *pStructAlign++ = *reinterpret_cast<sal_uInt64 *>( *pSSE++ );
+                break;
+        }
+}
+
+#if 0
+
+/* Functions to load floats and double to an SSE register placeholder.  */
+extern void float2sse (float, __int128_t *);
+extern void double2sse (double, __int128_t *);
+extern void floatfloat2sse (void *, __int128_t *);
+
+/* Functions to put the floats and doubles back.  */
+extern float sse2float (__int128_t *);
+extern double sse2double (__int128_t *);
+extern void sse2floatfloat(__int128_t *, void *);
+
+/*@-exportheader@*/
+void
+ffi_prep_args (stackLayout *stack, extended_cif *ecif)
+/*@=exportheader@*/
+{
+  int gprcount, ssecount, i, g, s;
+  void **p_argv;
+  void *argp = &stack->argspace;
+  ffi_type **p_arg;
+
+  /* First check if the return value should be passed in memory. If so,
+     pass the pointer as the first argument.  */
+  gprcount = ssecount = 0;
+  if (ecif->cif->rtype->type != FFI_TYPE_VOID 
+      && examine_argument (ecif->cif->rtype, 1, &g, &s) == 0)
+    (void *)stack->gpr[gprcount++] = ecif->rvalue;
+
+  for (i=ecif->cif->nargs, p_arg=ecif->cif->arg_types, p_argv = ecif->avalue;
+       i!=0; i--, p_arg++, p_argv++)
+    {
+      int in_register = 0;
+
+      switch ((*p_arg)->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  if (gprcount < MAX_GPR_REGS)
+	    {
+	      stack->gpr[gprcount] = 0;
+	      stack->gpr[gprcount++] = *(long long *)(*p_argv);
+	      in_register = 1;
+	    }
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  if (ssecount < MAX_SSE_REGS)
+	    {
+	      float2sse (*(float *)(*p_argv), &stack->sse[ssecount++]);
+	      in_register = 1;
+	    }
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  if (ssecount < MAX_SSE_REGS)
+	    {
+	      double2sse (*(double *)(*p_argv), &stack->sse[ssecount++]);
+	      in_register = 1;
+	    }
+	  break;
+	}
+
+      if (in_register)
+	continue;
+
+      /* Either all places in registers where filled, or this is a
+	 type that potentially goes into a memory slot.  */
+      if (examine_argument (*p_arg, 0, &g, &s) == 0
+	  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)
+	{
+	  /* Pass this argument in memory.  */
+	  argp = (void *)ALIGN(argp, (*p_arg)->alignment);
+	  memcpy (argp, *p_argv, (*p_arg)->size);
+	  argp += (*p_arg)->size;
+	}
+      else
+	{
+	  /* All easy cases are eliminated. Now fire the big guns.  */
+
+	  enum x86_64_reg_class classes[MAX_CLASSES];
+	  int offset = 0, j, num;
+	  void *a;
+
+	  num = classify_argument (*p_arg, classes, &offset);
+	  for (j=0, a=*p_argv; j<num; j++, a+=8)
+	    {
+	      switch (classes[j])
+		{
+		case X86_64_INTEGER_CLASS:
+		case X86_64_INTEGERSI_CLASS:
+		  stack->gpr[gprcount++] = *(long long *)a;
+		  break;
+		case X86_64_SSE_CLASS:
+		  floatfloat2sse (a, &stack->sse[ssecount++]);
+		  break;
+		case X86_64_SSESF_CLASS:
+		  float2sse (*(float *)a, &stack->sse[ssecount++]);
+		  break;
+		case X86_64_SSEDF_CLASS:
+		  double2sse (*(double *)a, &stack->sse[ssecount++]);
+		  break;
+		default:
+		  abort();
+		}
+	    }
+	}
+    }
+}
+
+/* Perform machine dependent cif processing.  */
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  int gprcount, ssecount, i, g, s;
+
+  gprcount = ssecount = 0;
+
+  /* Reset the byte count. We handle this size estimation here.  */
+  cif->bytes = 0;
+
+  /* If the return value should be passed in memory, pass the pointer
+     as the first argument. The actual memory isn't allocated here.  */
+  if (cif->rtype->type != FFI_TYPE_VOID 
+      && examine_argument (cif->rtype, 1, &g, &s) == 0)
+    gprcount = 1;
+
+  /* Go over all arguments and determine the way they should be passed.
+     If it's in a register and there is space for it, let that be so. If
+     not, add it's size to the stack byte count.  */
+  for (i=0; i<cif->nargs; i++)
+    {
+      if (examine_argument (cif->arg_types[i], 0, &g, &s) == 0
+	  || gprcount + g > MAX_GPR_REGS || ssecount + s > MAX_SSE_REGS)
+	{
+	  /* This is passed in memory. First align to the basic type.  */
+	  cif->bytes = ALIGN(cif->bytes, cif->arg_types[i]->alignment);
+
+	  /* Stack arguments are *always* at least 8 byte aligned.  */
+	  cif->bytes = ALIGN(cif->bytes, 8);
+
+	  /* Now add the size of this argument.  */
+	  cif->bytes += cif->arg_types[i]->size;
+	}
+      else
+	{
+	  gprcount += g;
+	  ssecount += s;
+	}
+    }
+
+  /* Set the flag for the closures return.  */
+    switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_STRUCT:
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+    case FFI_TYPE_LONGDOUBLE:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_UINT64:
+      cif->flags = FFI_TYPE_SINT64;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  return FFI_OK;
+}
+
+typedef struct
+{
+  long gpr[2];
+  __int128_t sse[2];
+  long double st0;
+} return_value;
+
+//#endif
+
+void
+ffi_fill_return_value (return_value *rv, extended_cif *ecif)
+{
+    enum x86_64_reg_class classes[MAX_CLASSES];
+    int i = 0, num;
+    long *gpr = rv->gpr;
+    __int128_t *sse = rv->sse;
+    signed char sc;
+    signed short ss;
+
+    /* This is needed because of the way x86-64 handles signed short
+       integers.  */
+    switch (ecif->cif->rtype->type)
+    {
+        case FFI_TYPE_SINT8:
+            sc = *(signed char *)gpr;
+            *(long long *)ecif->rvalue = (long long)sc;
+            return;
+        case FFI_TYPE_SINT16:
+            ss = *(signed short *)gpr;
+            *(long long *)ecif->rvalue = (long long)ss;
+            return;
+        default:
+            /* Just continue.  */
+            ;
+    }
+
+    num = classify_argument (ecif->cif->rtype, classes, &i);
+
+    if (num == 0)
+        /* Return in memory.  */
+        ecif->rvalue = (void *) rv->gpr[0];
+    else if (num == 2 && classes[0] == X86_64_X87_CLASS &&
+            classes[1] == X86_64_X87UP_CLASS)
+        /* This is a long double (this is easiest to handle this way instead
+           of an eightbyte at a time as in the loop below.  */
+        *((long double *)ecif->rvalue) = rv->st0;
+    else
+    {
+        void *a;
+
+        for (i=0, a=ecif->rvalue; i<num; i++, a+=8)
+        {
+            switch (classes[i])
+            {
+                case X86_64_INTEGER_CLASS:
+                case X86_64_INTEGERSI_CLASS:
+                    *(long long *)a = *gpr;
+                    gpr++;
+                    break;
+                case X86_64_SSE_CLASS:
+                    sse2floatfloat (sse++, a);
+                    break;
+                case X86_64_SSESF_CLASS:
+                    *(float *)a = sse2float (sse++);
+                    break;
+                case X86_64_SSEDF_CLASS:
+                    *(double *)a = sse2double (sse++);
+                    break;
+                default:
+                    abort();
+            }
+        }
+    }
+}
+
+//#if 0
+
+/*@-declundef@*/
+/*@-exportheader@*/
+extern void ffi_call_UNIX64(void (*)(stackLayout *, extended_cif *),
+			    void (*) (return_value *, extended_cif *),
+			    /*@out@*/ extended_cif *, 
+			    unsigned, /*@out@*/ unsigned *, void (*fn)());
+/*@=declundef@*/
+/*@=exportheader@*/
+
+void ffi_call(/*@dependent@*/ ffi_cif *cif, 
+	      void (*fn)(), 
+	      /*@out@*/ void *rvalue, 
+	      /*@dependent@*/ void **avalue)
+{
+  extended_cif ecif;
+  int dummy;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return	*/
+  /* value address then we need to make one		        */
+
+  if ((rvalue == NULL) && 
+      (examine_argument (cif->rtype, 1, &dummy, &dummy) == 0))
+    {
+      /*@-sysunrecog@*/
+      ecif.rvalue = alloca(cif->rtype->size);
+      /*@=sysunrecog@*/
+    }
+  else
+    ecif.rvalue = rvalue;
+    
+  /* Stack must always be 16byte aligned. Make it so.  */
+  cif->bytes = ALIGN(cif->bytes, 16);
+  
+  switch (cif->abi) 
+    {
+    case FFI_SYSV:
+      /* Calling 32bit code from 64bit is not possible  */
+      FFI_ASSERT(0);
+      break;
+
+    case FFI_UNIX64:
+      /*@-usedef@*/
+      ffi_call_UNIX64 (ffi_prep_args, ffi_fill_return_value, &ecif,
+		       cif->bytes, ecif.rvalue, fn);
+      /*@=usedef@*/
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+extern void ffi_closure_UNIX64(void);
+
+ffi_status
+ffi_prep_closure (ffi_closure* closure,
+		  ffi_cif* cif,
+		  void (*fun)(ffi_cif*, void*, void**, void*),
+		  void *user_data)
+{
+  volatile unsigned short *tramp;
+
+  /* FFI_ASSERT (cif->abi == FFI_OSF);  */
+
+  tramp = (volatile unsigned short *) &closure->tramp[0];
+  tramp[0] = 0xbb49;		/* mov <code>, %r11	*/
+  tramp[5] = 0xba49;		/* mov <data>, %r10	*/
+  tramp[10] = 0xff49;		/* jmp *%r11	*/
+  tramp[11] = 0x00e3;
+  *(void * volatile *) &tramp[1] = ffi_closure_UNIX64;
+  *(void * volatile *) &tramp[6] = closure;
+
+  closure->cif = cif;
+  closure->fun = fun;
+  closure->user_data = user_data;
+
+  return FFI_OK;
+}
+
+int
+ffi_closure_UNIX64_inner(ffi_closure *closure, va_list l, void *rp)
+{
+  ffi_cif *cif;
+  void **avalue;
+  ffi_type **arg_types;
+  long i, avn, argn;
+
+  cif = closure->cif;
+  avalue = alloca(cif->nargs * sizeof(void *));
+
+  argn = 0;
+
+  i = 0;
+  avn = cif->nargs;
+  arg_types = cif->arg_types;
+  
+  /* Grab the addresses of the arguments from the stack frame.  */
+  while (i < avn)
+    {
+      switch (arg_types[i]->type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_POINTER:
+	  {
+	    if (l->gp_offset > 48-8)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->gp_offset;
+		l->gp_offset += 8;
+	      }
+	  }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  /* FIXME  */
+	  FFI_ASSERT(0);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  {
+	    if (l->fp_offset > 176-16)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->fp_offset;
+		l->fp_offset += 16;
+	      }
+	  }
+#if DEBUG_FFI
+	  fprintf (stderr, "double arg %d = %g\n", i, *(double *)avalue[i]);
+#endif
+	  break;
+	  
+	case FFI_TYPE_FLOAT:
+	  {
+	    if (l->fp_offset > 176-16)
+	      {
+		avalue[i] = l->overflow_arg_area;
+		l->overflow_arg_area = (char *)l->overflow_arg_area + 8;
+	      }
+	    else
+	      {
+		avalue[i] = (char *)l->reg_save_area + l->fp_offset;
+		l->fp_offset += 16;
+	      }
+	  }
+#if DEBUG_FFI
+	  fprintf (stderr, "float arg %d = %g\n", i, *(float *)avalue[i]);
+#endif
+	  break;
+	  
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      argn += ALIGN(arg_types[i]->size, SIZEOF_ARG) / SIZEOF_ARG;
+      i++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rp, avalue, closure->user_data);
+
+  /* FIXME: Structs not supported.  */
+  FFI_ASSERT(cif->rtype->type != FFI_TYPE_STRUCT);
+
+  /* Tell ffi_closure_UNIX64 how to perform return type promotions.  */
+
+  return cif->rtype->type;
+}
+
+#endif
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx
diff -N bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/abi.hxx	6 Mar 2006 11:27:36 -0000	1.1.2.2
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
+#define _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
+
+// This is an implementation of the x86-64 ABI as described in 'System V
+// Application Binary Interface, AMD64 Architecture Processor Supplement'
+// (http://www.x86-64.org/documentation/abi-0.95.pdf)
+
+#include <typelib/typedescription.hxx>
+
+namespace x86_64
+{
+
+/* 6 general purpose registers are used for parameter passing */
+const sal_uInt32 MAX_GPR_REGS = 6;
+
+/* 8 SSE registers are used for parameter passing */
+const sal_uInt32 MAX_SSE_REGS = 8;
+
+/* Count number of required registers.
+
+ Examine the argument and return set number of register required in each
+ class.
+ 
+ Return false iff parameter should be passed in memory.
+*/
+bool examine_argument( typelib_TypeDescriptionReference *pTypeRef, bool bInReturn, int &nUsedGPR, int &nUsedSSE );
+
+/** Does function that returns this type use a hidden parameter, or registers?
+
+ The value can be returned either in a hidden 1st parameter (which is a
+ pointer to a structure allocated by the caller), or in registers (rax, rdx
+ for the integers, xmm0, xmm1 for the floating point numbers).
+*/
+bool return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef );
+
+void fill_struct( typelib_TypeDescriptionReference *pTypeRef, void * const *pGPR, void * const *pSSE, void *pStruct );
+
+} // namespace x86_64
+
+#endif // _BRIDGES_CPP_UNO_X86_64_ABI_HXX_
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/call.s
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_x86-64/call.s
diff -N bridges/source/cpp_uno/gcc3_linux_x86-64/call.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/call.s	6 Mar 2006 11:18:56 -0000	1.1.2.2
@@ -0,0 +1,94 @@
+	.text
+	.align 2
+.globl privateSnippetExecutor
+	.type	privateSnippetExecutor, @function
+privateSnippetExecutor:
+.LFB3:
+	pushq	%rbp
+.LCFI0:
+	movq	%rsp, %rbp
+.LCFI1:
+	subq	$160, %rsp
+.LCFI2:
+	movq	%r10, -152(%rbp)		# Save (nVtableOffset << 32) + nFunctionIndex
+
+	movq	%rdi, -112(%rbp)		# Save GP registers
+	movq	%rsi, -104(%rbp)
+	movq	%rdx, -96(%rbp)
+	movq	%rcx, -88(%rbp)
+	movq	%r8 , -80(%rbp)
+	movq	%r9 , -72(%rbp)
+	
+	movsd	%xmm0, -64(%rbp)		# Save FP registers
+	movsd	%xmm1, -56(%rbp)
+	movsd	%xmm2, -48(%rbp)
+	movsd	%xmm3, -40(%rbp)
+	movsd	%xmm4, -32(%rbp)
+	movsd	%xmm5, -24(%rbp)
+	movsd	%xmm6, -16(%rbp)
+	movsd	%xmm7, -8(%rbp)
+
+	leaq	-144(%rbp), %r9			# 6th param: sal_uInt64 * pRegisterReturn
+	leaq	16(%rbp), %r8			# 5rd param: void ** ovrflw
+	leaq	-64(%rbp), %rcx			# 4th param: void ** fpreg
+	leaq	-112(%rbp), %rdx		# 3rd param: void ** gpreg
+	movl	-148(%rbp), %esi		# 2nd param: sal_int32 nVtableOffset
+	movl	-152(%rbp), %edi		# 1st param: sal_int32 nFunctionIndex
+	
+	call	cpp_vtable_call
+
+	cmp	$10, %rax					# typelib_TypeClass_FLOAT
+	je	.Lfloat
+	cmp	$11, %rax					# typelib_TypeClass_DOUBLE
+	je	.Lfloat
+
+	movq	-144(%rbp), %rax		# Return value (int case)
+	jmp	.Lfinish
+.Lfloat:
+	movlpd	-144(%rbp), %xmm0		# Return value (float/double case)
+
+.Lfinish:
+	leave
+	ret
+.LFE3:
+	.size	privateSnippetExecutor, .-privateSnippetExecutor
+	.section	.eh_frame,"a",@progbits
+.Lframe1:
+	.long	.LECIE1-.LSCIE1
+.LSCIE1:
+	.long	0x0
+	.byte	0x1
+	.string	"zP"
+	.uleb128 0x1
+	.sleb128 -8
+	.byte	0x10
+	.uleb128 0x9
+	.byte	0x0
+	.quad	__gxx_personality_v0
+	.byte	0xc
+	.uleb128 0x7
+	.uleb128 0x8
+	.byte	0x90
+	.uleb128 0x1
+	.align 8
+.LECIE1:
+.LSFDE1:
+	.long	.LEFDE1-.LASFDE1
+.LASFDE1:
+	.long	.LASFDE1-.Lframe1
+	.quad	.LFB3
+	.quad	.LFE3-.LFB3
+	.uleb128 0x0
+	.byte	0x4
+	.long	.LCFI0-.LFB3
+	.byte	0xe
+	.uleb128 0x10
+	.byte	0x86
+	.uleb128 0x2
+	.byte	0x4
+	.long	.LCFI1-.LCFI0
+	.byte	0xd
+	.uleb128 0x6
+	.align 8
+.LEFDE1:
+	.section	.note.GNU-stack,"",@progbits
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.32.3
diff -u -p -u -p -r1.3 -r1.3.32.3
--- bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	7 Sep 2005 22:26:18 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	6 Mar 2006 11:27:36 -0000	1.3.32.3
@@ -40,33 +40,39 @@
 #include <rtl/alloc.h>
 #include <osl/mutex.hxx>
 
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <uno/data.h>
 #include <typelib/typedescription.hxx>
 
-#include <bridges/cpp_uno/bridge.hxx>
-#include <bridges/cpp_uno/type_misc.hxx>
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
 
+#include "abi.hxx"
 #include "share.hxx"
 
 using namespace ::osl;
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 
-namespace CPPU_CURRENT_NAMESPACE
-{
-
-// 6 integral parameters are passed in registers
-const sal_uInt32 GPR_COUNT = 6;
-
-// 8 floating point parameters are passed in SSE registers
-const sal_uInt32 FPR_COUNT = 8;
-
 //==================================================================================================
-rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
 
-//==================================================================================================
+// Perform the UNO call
+//
+// We must convert the paramaters stored in gpreg, fpreg and ovrflw to UNO
+// arguments and call pThis->getUnoI()->pDispatcher.
+//
+// gpreg:  [ret *], this, [gpr params]
+// fpreg:  [fpr params]
+// ovrflw: [gpr or fpr params (properly aligned)]
+//
+// [ret *] is present when we are returning a structure bigger than 16 bytes
+// Simple types are returned in rax, rdx (int), or xmm0, xmm1 (fp).
+// Similarly structures <= 16 bytes are in rax, rdx, xmm0, xmm1 as necessary.
 static typelib_TypeClass cpp2uno_call(
-	cppu_cppInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
 	const typelib_TypeDescription * pMemberTypeDescr,
 	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
 	sal_Int32 nParams, typelib_MethodParameter * pParams,
@@ -75,12 +81,7 @@ static typelib_TypeClass cpp2uno_call(
 {
 	int nr_gpr = 0; //number of gpr registers used 
 	int nr_fpr = 0; //number of fpr regsiters used
-	void ** pCppStack; //temporary stack pointer
        
-	// gpreg:  [ret *], this, [gpr params]
-	// fpreg:  [fpr params]
-	// ovrflw: [gpr or fpr params (properly aligned)]
-	
 	// return
 	typelib_TypeDescription * pReturnTypeDescr = 0;
 	if (pReturnTypeRef)
@@ -89,23 +90,21 @@ static typelib_TypeClass cpp2uno_call(
 	void * pUnoReturn = 0;
 	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
 	
-	if (pReturnTypeDescr)
+	if ( pReturnTypeDescr )
 	{
-		if (cppu_isSimpleType( pReturnTypeDescr ))
+		if ( x86_64::return_in_hidden_param( pReturnTypeRef ) )
 		{
-			pUnoReturn = pRegisterReturn; // direct way for simple types
-		}
-		else // complex return via ptr (pCppReturn)
-		{
-			pCppReturn = *(void **)gpreg;
-			gpreg++;
+			pCppReturn = *gpreg++;
 			nr_gpr++;
 			
-			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
-						  ? alloca( pReturnTypeDescr->nSize )
-						  : pCppReturn); // direct way
+			pUnoReturn = ( bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						   ? alloca( pReturnTypeDescr->nSize )
+						   : pCppReturn ); // direct way
 		}
+		else
+			pUnoReturn = pRegisterReturn; // direct way for simple types
 	}
+
 	// pop this
 	gpreg++; 
 	nr_gpr++;
@@ -119,7 +118,7 @@ static typelib_TypeClass cpp2uno_call(
 	// type descriptions for reconversions
 	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
 	
-	sal_Int32 nTempIndizes   = 0;
+	sal_Int32 nTempIndizes = 0;
 
 	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
 	{
@@ -127,59 +126,69 @@ static typelib_TypeClass cpp2uno_call(
 		typelib_TypeDescription * pParamTypeDescr = 0;
 		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
 
-		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		int nUsedGPR = 0;
+		int nUsedSSE = 0;
+		bool bFitsRegisters = x86_64::examine_argument( rParam.pTypeRef, false, nUsedGPR, nUsedSSE );
+		if ( !rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ) ) // value
 		{
-			if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT
-				|| pParamTypeDescr->eTypeClass == typelib_TypeClass_DOUBLE)
+			// Simple types must fit exactly one register on x86_64
+			OSL_ASSERT( bFitsRegisters && ( ( nUsedSSE == 1 && nUsedGPR == 0 ) || ( nUsedSSE == 0 && nUsedGPR == 1 ) ) );
+
+			if ( nUsedSSE == 1 )
 			{
-			   if (nr_fpr < FPR_COUNT)
-			   {
-				   pCppArgs[nPos] = fpreg;
-				   pUnoArgs[nPos] = fpreg;
-				   nr_fpr++;
-				   fpreg++;
-			   }
-			   else
-			   {
-				   pCppArgs[nPos] = ovrflw;
-				   pUnoArgs[nPos] = ovrflw;
-				   ovrflw++;
-			   }
+				if ( nr_fpr < x86_64::MAX_SSE_REGS )
+				{
+					pCppArgs[nPos] = pUnoArgs[nPos] = fpreg++;
+					nr_fpr++;
+				}
+				else
+					pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw++;
 			}
-			else
+			else if ( nUsedGPR == 1 )
 			{
-				if (nr_gpr < GPR_COUNT)
+				if ( nr_gpr < x86_64::MAX_GPR_REGS )
 				{
-					pCppArgs[nPos] = gpreg;
-					pUnoArgs[nPos] = gpreg;
+					pCppArgs[nPos] = pUnoArgs[nPos] = gpreg++;
 					nr_gpr++;
-					gpreg++;
 				}
 				else
-				{
-					pCppArgs[nPos] = ovrflw;
-					pUnoArgs[nPos] = ovrflw;
-					ovrflw++;
-				}
+					pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw++;
 			}
+
 			// no longer needed
 			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 		}
-		else // ptr to complex value | ref
+		else // struct <= 16 bytes || ptr to complex value || ref
 		{
-			if (nr_gpr < GPR_COUNT)
+			void *pCppStack;
+			char pTmpStruct[16];
+
+			if ( bFitsRegisters && !rParam.bOut &&
+				 ( pParamTypeDescr->eTypeClass == typelib_TypeClass_STRUCT ||
+				   pParamTypeDescr->eTypeClass == typelib_TypeClass_EXCEPTION ) )
+			{
+				if ( ( nr_gpr + nUsedGPR <= x86_64::MAX_GPR_REGS ) && ( nr_fpr + nUsedSSE <= x86_64::MAX_SSE_REGS ) )
+				{
+					x86_64::fill_struct( rParam.pTypeRef, gpreg, fpreg, pTmpStruct );
+#if OSL_DEBUG_LEVEL > 1
+					fprintf( stderr, "nUsedGPR == %d, nUsedSSE == %d, pTmpStruct[0] == 0x%x, pTmpStruct[1] == 0x%x, **gpreg == 0x%lx\n",
+							nUsedGPR, nUsedSSE, pTmpStruct[0], pTmpStruct[1], *(sal_uInt64*)*gpreg );
+#endif
+
+					pCppArgs[nPos] = pCppStack = reinterpret_cast<void *>( pTmpStruct );
+					gpreg += nUsedGPR;
+					fpreg += nUsedSSE;
+				}
+				else
+					pCppArgs[nPos] = pCppStack = *ovrflw++;
+			}
+			else if ( nr_gpr < x86_64::MAX_GPR_REGS )
 			{ 
-				pCppArgs[nPos] = *(void **)gpreg;
-				pCppStack = gpreg;
+				pCppArgs[nPos] = pCppStack = *gpreg++;
 				nr_gpr++;
-				gpreg++;
 			}
 			else
-			{
-				pCppArgs[nPos] = *(void **)ovrflw;
-				pCppStack = ovrflw;
-				ovrflw++;
-			}
+				pCppArgs[nPos] = pCppStack = *ovrflw++;
 
 			if (! rParam.bIn) // is pure out
 			{
@@ -189,19 +198,18 @@ static typelib_TypeClass cpp2uno_call(
 				// will be released at reconversion
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
-			// is in/inout
-			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			else if ( bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ) ) // is in/inout
 			{
 				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
-										*(void **)pCppStack, pParamTypeDescr,
-										&pThis->pBridge->aCpp2Uno );
+										pCppStack, pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
 				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
 				// will be released at reconversion
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
 			else // direct way
 			{
-				pUnoArgs[nPos] = *(void **)pCppStack;
+				pUnoArgs[nPos] = pCppStack;
 				// no longer needed
 				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 			}
@@ -213,10 +221,10 @@ static typelib_TypeClass cpp2uno_call(
 	uno_Any * pUnoExc = &aUnoExc;
 
 	// invoke uno dispatch call
-	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
 	
 	// in case an exception occured...
-	if (pUnoExc)
+	if ( pUnoExc )
 	{
 		// destruct temporary in/inout params
 		for ( ; nTempIndizes--; )
@@ -230,7 +238,7 @@ static typelib_TypeClass cpp2uno_call(
 		if (pReturnTypeDescr)
 			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
 		
-		raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); // has to destruct the any
 		// is here for dummy
 		return typelib_TypeClass_VOID;
 	}
@@ -242,12 +250,12 @@ static typelib_TypeClass cpp2uno_call(
 			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
 			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
 			
-			if (pParams[nIndex].bOut) // inout/out
+			if ( pParams[nIndex].bOut ) // inout/out
 			{
 				// convert and assign
 				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
 				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
-										&pThis->pBridge->aUno2Cpp );
+										pThis->getBridge()->getUno2Cpp() );
 			}
 			// destroy temp uno param
 			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
@@ -255,19 +263,19 @@ static typelib_TypeClass cpp2uno_call(
 			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
 		}
 		// return
-		if (pCppReturn) // has complex return
+		if ( pCppReturn ) // has complex return
 		{
-			if (pUnoReturn != pCppReturn) // needs reconversion
+			if ( pUnoReturn != pCppReturn ) // needs reconversion
 			{
 				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
-										&pThis->pBridge->aUno2Cpp );
+										pThis->getBridge()->getUno2Cpp() );
 				// destroy temp uno return
 				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
 			}
 			// complex return ptr is set to return reg
 			*(void **)pRegisterReturn = pCppReturn;
 		}
-		if (pReturnTypeDescr)
+		if ( pReturnTypeDescr )
 		{
 			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
 			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
@@ -280,377 +288,248 @@ static typelib_TypeClass cpp2uno_call(
 
 
 //==================================================================================================
-static typelib_TypeClass cpp_mediate(
-	sal_Int32 nVtableCall,
+extern "C" typelib_TypeClass cpp_vtable_call(
+	sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
 	void ** gpreg, void ** fpreg, void ** ovrflw,
 	sal_uInt64 * pRegisterReturn /* space for register return */ )
 {
 	// gpreg:  [ret *], this, [other gpr params]
 	// fpreg:  [fpr params]
 	// ovrflw: [gpr or fpr params (properly aligned)]
-
-	// _this_ ptr is patched cppu_XInterfaceProxy object
-	cppu_cppInterfaceProxy * pCppI = NULL;
-	if( nVtableCall & 0x80000000 )
+	void * pThis;
+	if ( nFunctionIndex & 0x80000000 )
 	{
-		nVtableCall &= 0x7fffffff;
-		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg +1);
+		nFunctionIndex &= 0x7fffffff;
+		pThis = gpreg[1];
 	}
 	else
-    {
-		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg);
-    }
-    
-	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
-	
-	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
-	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
 	{
-		throw RuntimeException(
-            OUString::createFromAscii("illegal vtable index!"),
-            (XInterface *)pCppI );
+		pThis = gpreg[0];
 	}
-	
+	pThis = static_cast<char *>( pThis ) - nVtableOffset;
+
+	bridges::cpp_uno::shared::CppInterfaceProxy * pCppI =
+		bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy( pThis );
+
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
+	if ( nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex )
+	{
+		throw RuntimeException( OUString::createFromAscii("illegal vtable index!"),
+								reinterpret_cast<XInterface *>( pCppI ) );
+	}
+
 	// determine called method
-	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!\n" );
-	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
 	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!\n" );
 
 	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
-    
+
 	typelib_TypeClass eRet;
-	switch (aMemberDescr.get()->eTypeClass)
-	{
-	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	switch ( aMemberDescr.get()->eTypeClass )
 	{
-		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		case typelib_TypeClass_INTERFACE_ATTRIBUTE:
 		{
-			// is GET method
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
-				0, 0, // no params
-				gpreg, fpreg, ovrflw, pRegisterReturn );
+			typelib_TypeDescriptionReference *pAttrTypeRef = 
+				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( aMemberDescr.get() )->pAttributeTypeRef;
+
+			if ( pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex )
+			{
+				// is GET method
+				eRet = cpp2uno_call( pCppI, aMemberDescr.get(), pAttrTypeRef,
+						0, 0, // no params
+						gpreg, fpreg, ovrflw, pRegisterReturn );
+			}
+			else
+			{
+				// is SET method
+				typelib_MethodParameter aParam;
+				aParam.pTypeRef = pAttrTypeRef;
+				aParam.bIn		= sal_True;
+				aParam.bOut		= sal_False;
+
+				eRet = cpp2uno_call( pCppI, aMemberDescr.get(),
+						0, // indicates void return
+						1, &aParam,
+						gpreg, fpreg, ovrflw, pRegisterReturn );
+			}
+			break;
 		}
-		else
+		case typelib_TypeClass_INTERFACE_METHOD:
 		{
-			// is SET method
-			typelib_MethodParameter aParam;
-			aParam.pTypeRef =
-				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
-			aParam.bIn		= sal_True;
-			aParam.bOut		= sal_False;
-			
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				0, // indicates void return
-				1, &aParam,
-				gpreg, fpreg, ovrflw, pRegisterReturn );
+			// is METHOD
+			switch ( nFunctionIndex )
+			{
+				case 1: // acquire()
+					pCppI->acquireProxy(); // non virtual call!
+					eRet = typelib_TypeClass_VOID;
+					break;
+				case 2: // release()
+					pCppI->releaseProxy(); // non virtual call!
+					eRet = typelib_TypeClass_VOID;
+					break;
+				case 0: // queryInterface() opt
+				{
+					typelib_TypeDescription * pTD = 0;
+					TYPELIB_DANGER_GET( &pTD, reinterpret_cast<Type *>( gpreg[2] )->getTypeLibType() );
+					if ( pTD )
+					{
+						XInterface * pInterface = 0;
+						(*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)
+							( pCppI->getBridge()->getCppEnv(),
+							  (void **)&pInterface,
+							  pCppI->getOid().pData,
+							  reinterpret_cast<typelib_InterfaceTypeDescription *>( pTD ) );
+
+						if ( pInterface )
+						{
+							::uno_any_construct( reinterpret_cast<uno_Any *>( gpreg[0] ),
+												 &pInterface, pTD, cpp_acquire );
+
+							pInterface->release();
+							TYPELIB_DANGER_RELEASE( pTD );
+
+							reinterpret_cast<void **>( pRegisterReturn )[0] = gpreg[0];
+							eRet = typelib_TypeClass_ANY;
+							break;
+						}
+						TYPELIB_DANGER_RELEASE( pTD );
+					}
+				} // else perform queryInterface()
+				default:
+				{
+					typelib_InterfaceMethodTypeDescription *pMethodTD =
+						reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( aMemberDescr.get() );
+
+					eRet = cpp2uno_call( pCppI, aMemberDescr.get(),
+										 pMethodTD->pReturnTypeRef,
+										 pMethodTD->nParams,
+										 pMethodTD->pParams,
+										 gpreg, fpreg, ovrflw, pRegisterReturn );
+				}
+			}
+			break;
 		}
-		break;
-	}
-	case typelib_TypeClass_INTERFACE_METHOD:
-	{
-		// is METHOD
-		switch (nVtableCall)
+		default:
 		{
-		case 1: // acquire()
-			pCppI->acquireProxy(); // non virtual call!
-			eRet = typelib_TypeClass_VOID;
-			break;
-		case 2: // release()
-			pCppI->releaseProxy(); // non virtual call!
+			throw RuntimeException( OUString::createFromAscii("no member description found!"),
+									reinterpret_cast<XInterface *>( pCppI ) );
+			// is here for dummy
 			eRet = typelib_TypeClass_VOID;
-			break;
-		case 0: // queryInterface() opt
-		{
-			typelib_TypeDescription * pTD = 0;
-			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
-			if (pTD)
-			{
-                XInterface * pInterface = 0;
-                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
-                    pCppI->pBridge->pCppEnv,
-                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
-			
-                if (pInterface)
-                {
-                    ::uno_any_construct(
-                        reinterpret_cast< uno_Any * >( gpreg[0] ),
-                        &pInterface, pTD, cpp_acquire );
-                    pInterface->release();
-                    TYPELIB_DANGER_RELEASE( pTD );
-                    *(void **)pRegisterReturn = gpreg[0];
-                    eRet = typelib_TypeClass_ANY;
-                    break;
-                }
-                TYPELIB_DANGER_RELEASE( pTD );
-            }
-		} // else perform queryInterface()
-		default:
-			eRet = cpp2uno_call(
-				pCppI, aMemberDescr.get(),
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
-				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
-				gpreg, fpreg, ovrflw, pRegisterReturn );
 		}
-		break;
-	}
-	default:
-	{
-		throw RuntimeException(
-            OUString::createFromAscii("no member description found!"),
-            (XInterface *)pCppI );
-		// is here for dummy
-		eRet = typelib_TypeClass_VOID;
-	}
 	}
 
 	return eRet;
 }
 
 //==================================================================================================
-/**
- * is called on incoming vtable calls
- * (called by asm snippets)
- */
-static void cpp_vtable_call(sal_uInt32 nTableEntry,
-							void** ovrflw, void** gpregptr, void** fpregptr)
-{
-	sal_uInt64    gpreg[GPR_COUNT];
-	double        fpreg[FPR_COUNT];
-	
-	memcpy( gpreg, gpregptr, sizeof(gpreg) );
-	memcpy( fpreg, fpregptr, sizeof(fpreg) );
-	
-	volatile sal_uInt64 nRegReturn[3];
-	
-#ifdef DEBUG
-	fprintf(stderr, "cpp_vtable_call(%08x,...)\n", nTableEntry);
-#endif
+extern "C" void privateSnippetExecutor( ... );
 
-	sal_Bool bComplex = nTableEntry & 0x80000000 ? sal_True : sal_False;
+const int codeSnippetSize = 24;
 
-	typelib_TypeClass aType = 
-		cpp_mediate( nTableEntry, (void**)gpreg, (void**)fpreg, ovrflw, (sal_uInt64 *)nRegReturn );
-    
-	switch( aType )
-	{
-	case typelib_TypeClass_FLOAT:
-		// The value in %xmm register is already prepared to
-		// be retrieved as a float. Therefore, we pass the
-		// value verbatim, as a double without conversion.
-		__asm__( "movsd %0, %%xmm0" : : "m" (*((double *)nRegReturn)) );
-		break;
-		
-	case typelib_TypeClass_DOUBLE:
-		__asm__( "movsd %0, %%xmm0" : : "m" (*((double *)nRegReturn)) );
-		break;
-	
-	default:
-		__asm__( "movq %0, %%rax" : : "m" (*nRegReturn));
-		break;
-	}
+// Generate a trampoline that redirects method calls to
+// privateSnippetExecutor().
+//
+// privateSnippetExecutor() saves all the registers that are used for
+// parameter passing on x86_64, and calls the cpp_vtable_call().
+// When it returns, privateSnippetExecutor() sets the return value.
+//
+// Note: The code snippet we build here must not create a stack frame,
+// otherwise the UNO exceptions stop working thanks to non-existing
+// unwinding info.
+unsigned char * codeSnippet( unsigned char * code,
+        sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
+        bool bHasHiddenParam ) SAL_THROW( () )
+{
+	sal_uInt64 nOffsetAndIndex = ( ( (sal_uInt64) nVtableOffset ) << 32 ) | ( (sal_uInt64) nFunctionIndex );
+
+	if ( bHasHiddenParam )
+		nOffsetAndIndex |= 0x80000000;
+
+	// movq $<nOffsetAndIndex>, %r10
+	*reinterpret_cast<sal_uInt16 *>( code ) = 0xba49;
+	*reinterpret_cast<sal_uInt64 *>( code + 2 ) = nOffsetAndIndex;
+
+	// movq $<address of the privateSnippetExecutor>, %r11
+	*reinterpret_cast<sal_uInt16 *>( code + 10 ) = 0xbb49;
+	*reinterpret_cast<sal_uInt64 *>( code + 12 ) = reinterpret_cast<sal_uInt64>( privateSnippetExecutor );
 
-	__asm__ __volatile__ ("" : : : "rax", "xmm0");
-}
+	// jmpq *%r11
+	*reinterpret_cast<sal_uInt32 *>( code + 20 ) = 0x00e3ff49;
 
+	return code + codeSnippetSize;
+}
 
 //==================================================================================================
-class MediateClassData
+void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable( char * block )
 {
-    typedef ::std::hash_map< OUString, void *, OUStringHash > t_classdata_map;
-	t_classdata_map m_map;
-	Mutex m_mutex;
-    
-public:
-	void const * get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () );
-    
-	inline MediateClassData() SAL_THROW( () )
-        {}
-	~MediateClassData() SAL_THROW( () );
-};
-//__________________________________________________________________________________________________
-MediateClassData::~MediateClassData() SAL_THROW( () )
-{
-	OSL_TRACE( "> calling ~MediateClassData(): freeing mediate vtables." );
-	
-	for ( t_classdata_map::const_iterator iPos( m_map.begin() ); iPos != m_map.end(); ++iPos )
-	{
-		::rtl_freeMemory( iPos->second );
-	}
+	return reinterpret_cast<void **>( block ) + 2;
 }
-//--------------------------------------------------------------------------------------------------
-/* Code to generate. Note: if you change it, make sure patch offsets
-   for nTableEntry and cpp_vtable_call() are updated too.  */
-const char code_snippet_template[] = {
-	// # make room for gpregs (48), fpregs (64)
-	0x55,								// push   %rbp
-	0x48, 0x89, 0xe5,					// mov    %rsp,%rbp
-	0x48, 0x83, 0xec, 0x70,				// sub    $112,%rsp
-	// # save GP registers
-	0x48, 0x89, 0x7d, 0x90,				// mov    %rdi,-112(%rbp)
-	0x48, 0x89, 0x75, 0x98,				// mov    %rsi,-104(%rbp)
-	0x48, 0x89, 0x55, 0xa0,				// mov    %rdx, -96(%rbp)
-	0x48, 0x89, 0x4d, 0xa8,				// mov    %rcx, -88(%rbp)
-	0x4c, 0x89, 0x45, 0xb0,				// mov    %r8 , -80(%rbp)
-	0x4c, 0x89, 0x4d, 0xb8,				// mov    %r9 , -72(%rbp)
-	0x48, 0x8d, 0x55, 0x90,				// lea    -112(%rbp),%rdx
-	// # save FP registers
-	0xf2, 0x0f, 0x11, 0x45, 0xc0,		// movsd  %xmm0,-64(%rbp)
-	0xf2, 0x0f, 0x11, 0x4d, 0xc8,		// movsd  %xmm1,-56(%rbp)
-	0xf2, 0x0f, 0x11, 0x55, 0xd0,		// movsd  %xmm2,-48(%rbp)
-	0xf2, 0x0f, 0x11, 0x5d, 0xd8,		// movsd  %xmm3,-40(%rbp)
-	0xf2, 0x0f, 0x11, 0x65, 0xe0,		// movsd  %xmm4,-32(%rbp)
-	0xf2, 0x0f, 0x11, 0x6d, 0xe8,		// movsd  %xmm5,-24(%rbp)
-	0xf2, 0x0f, 0x11, 0x75, 0xf0,		// movsd  %xmm6,-16(%rbp)
-	0xf2, 0x0f, 0x11, 0x7d, 0xf8,		// movsd  %xmm7, -8(%rbp)
-	0x48, 0x8d, 0x4d, 0xc0,				// lea    -64(%rbp),%rcx
-	// # perform the call and cleanup to cpp_vtable_call()
-	0xbf, 0x00, 0x00, 0x00, 0x00,		// mov    $0,%edi
-	0x48, 0x8d, 0x75, 0x10,				// lea    16(%rbp),%rsi
-	0x48, 0xb8, 0, 0, 0, 0,	0, 0, 0, 0,	// mov    $0,%rax
-	0xff, 0xd0,							// call   *%rax
-	0xc9,								// leave
-	0xc3								// ret
-};
-
-static inline void codeSnippet( char * code, sal_uInt32 vtable_pos, bool simple_ret_type ) SAL_THROW( () )
-{
-    if (! simple_ret_type)
-        vtable_pos |= 0x80000000;
-
-	const int code_snippet_template_size = sizeof(code_snippet_template);
-	memcpy(code, code_snippet_template, code_snippet_template_size);
 
-	// Patch nTableEntryValue
-	sal_uInt32 *mid_p  = (sal_uInt32 *)(code + code_snippet_template_size - 22);
-	*mid_p = vtable_pos;
-
-	// Patch call to cpp_vtable_call()
-	sal_uInt64 *call_p  = (sal_uInt64 *)(code + code_snippet_template_size - 12);
-	*call_p = (sal_uInt64)cpp_vtable_call;
-}
-//__________________________________________________________________________________________________
-void const * MediateClassData::get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () )
+//==================================================================================================
+char * bridges::cpp_uno::shared::VtableFactory::createBlock(
+	sal_Int32 slotCount, void *** slots)
 {
-    void * buffer;
-    const int nSnippetSize = sizeof(code_snippet_template);
+	char * block = new char[ ( slotCount + 2 ) * sizeof( void * ) + slotCount * codeSnippetSize ];
+	
+	*slots = mapBlockToVtable( block );
+	(*slots)[-2] = 0;
+	(*slots)[-1] = 0;
 
-    // avoiding locked counts
-    OUString const & unoName = *(OUString const *)&((typelib_TypeDescription *)pTD)->pTypeName;
-    {
-	MutexGuard aGuard( m_mutex );
-	t_classdata_map::const_iterator iFind( m_map.find( unoName ) );
-	if (iFind == m_map.end())
-    {
-        // create new vtable
-        sal_Int32 nSlots = pTD->nMapFunctionIndexToMemberIndex;
-        buffer = ::rtl_allocateMemory( ((2+ nSlots) * sizeof (void *)) + (nSlots *nSnippetSize) );
-        
-        ::std::pair< t_classdata_map::iterator, bool > insertion(
-            m_map.insert( t_classdata_map::value_type( unoName, buffer ) ) );
-        OSL_ENSURE( insertion.second, "### inserting new vtable buffer failed?!\n\n" );
-        
-        void ** slots = (void **)buffer;
-        *slots++ = 0;
-        *slots++ = 0; // rtti
-        char * code = (char *)(slots + nSlots);
-        
-        sal_uInt32 vtable_pos = 0;
-        sal_Int32 nAllMembers = pTD->nAllMembers;
-        typelib_TypeDescriptionReference ** ppAllMembers = pTD->ppAllMembers;
-        for ( sal_Int32 nPos = 0; nPos < nAllMembers; ++nPos )
-        {
-            typelib_TypeDescription * pTD = 0;
-            TYPELIB_DANGER_GET( &pTD, ppAllMembers[ nPos ] );
-            OSL_ASSERT( pTD );
-            if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
-            {
-                bool simple_ret = cppu_isSimpleType(
-                    ((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
-                // get method
-                *slots = code;
-                codeSnippet( code, vtable_pos++, simple_ret );
-                code += nSnippetSize;
-                slots++;
-                if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
-                {
-                    // set method
-                    *slots = code;
-                    codeSnippet( code, vtable_pos++, true );
-                    code += nSnippetSize;
-                    slots++;
-                }
-            }
-            else
-            {
-                bool simple_ret = cppu_isSimpleType(
-                    ((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
-                *slots = code;
-                codeSnippet( code, vtable_pos++, simple_ret );
-                code += nSnippetSize;
-                slots++;
-            }
-            TYPELIB_DANGER_RELEASE( pTD );
-        }
-        OSL_ASSERT( vtable_pos == nSlots );
-    }
-    else
-    {
-        buffer = iFind->second;
-    }
-    }
-    
-    return ((void **)buffer +2);
+	return block;
 }
 
 //==================================================================================================
-void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
-	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
+
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+	void ** slots, unsigned char * code,
+	typelib_InterfaceTypeDescription const * type, sal_Int32 nFunctionOffset,
+	sal_Int32 functionCount, sal_Int32 nVtableOffset )
 {
-	static MediateClassData * s_pMediateClassData = 0;
-	if (! s_pMediateClassData)
+	for ( sal_Int32 nPos = 0; nPos < type->nMembers; ++nPos )
 	{
-		MutexGuard aGuard( Mutex::getGlobalMutex() );
-		if (! s_pMediateClassData)
+		typelib_TypeDescription * pTD = 0;
+
+		TYPELIB_DANGER_GET( &pTD, type->ppMembers[ nPos ] );
+		OSL_ASSERT( pTD );
+
+		if ( typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass )
 		{
-#ifdef LEAK_STATIC_DATA
-			s_pMediateClassData = new MediateClassData();
-#else
-			static MediateClassData s_aMediateClassData;
-			s_pMediateClassData = &s_aMediateClassData;
-#endif
+			typelib_InterfaceAttributeTypeDescription *pAttrTD =
+				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( pTD );
+
+			// get method
+			*slots++ = code;
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
+								x86_64::return_in_hidden_param( pAttrTD->pAttributeTypeRef ) );
+
+			if ( ! pAttrTD->bReadOnly )
+			{
+				// set method
+				*slots++ = code;
+				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, false );
+			}
 		}
-	}
-	*(void const **)pCppI = s_pMediateClassData->get_vtable( pTypeDescr );
-}
+		else if ( typelib_TypeClass_INTERFACE_METHOD == pTD->eTypeClass )
+		{
+			typelib_InterfaceMethodTypeDescription *pMethodTD =
+				reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( pTD );
+			
+			*slots++ = code;
+			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
+								x86_64::return_in_hidden_param( pMethodTD->pReturnTypeRef ) );
+		}
+		else
+			OSL_ASSERT( false );
 
+		TYPELIB_DANGER_RELEASE( pTD );
+	}
+	return code;
 }
 
-extern "C"
-{
-//##################################################################################################
-sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
-	SAL_THROW_EXTERN_C()
-{
-	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload(
-        &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
-}
-//##################################################################################################
-void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
-	SAL_THROW_EXTERN_C()
-{
-	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment(
-        pCppEnv );
-}
-//##################################################################################################
-void SAL_CALL uno_ext_getMapping(
-	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
-	SAL_THROW_EXTERN_C()
+//==================================================================================================
+void bridges::cpp_uno::shared::VtableFactory::flushCode(
+	unsigned char const *, unsigned char const * )
 {
-	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping(
-        ppMapping, pFrom, pTo );
-}
 }
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx,v
retrieving revision 1.3
retrieving revision 1.3.32.2
diff -u -p -u -p -r1.3 -r1.3.32.2
--- bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	7 Sep 2005 22:26:31 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	6 Mar 2006 11:13:50 -0000	1.3.32.2
@@ -43,7 +43,8 @@
 #include <osl/diagnose.h>
 #include <osl/mutex.hxx>
 
-#include <bridges/cpp_uno/bridge.hxx>
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <typelib/typedescription.hxx>
 #include <uno/any2.h>
 
@@ -67,7 +68,7 @@ void dummy_can_throw_anything( char cons
 //==================================================================================================
 static OUString toUNOname( char const * p ) SAL_THROW( () )
 {
-#ifdef DEBUG
+#if OSL_DEBUG_LEVEL > 1
     char const * start = p;
 #endif
     
@@ -92,7 +93,7 @@ static OUString toUNOname( char const * 
             buf.append( (sal_Unicode)'.' );
     }
     
-#ifdef DEBUG
+#if OSL_DEBUG_LEVEL > 1
     OUString ret( buf.makeStringAndClear() );
     OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
     fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
@@ -174,7 +175,7 @@ type_info * RTTI::getRTTI( typelib_Compo
                 // symbol and rtti-name is nearly identical,
                 // the symbol is prefixed with _ZTI
                 char const * rttiName = symName.getStr() +4;
-#ifdef DEBUG
+#if OSL_DEBUG_LEVEL > 1
                 fprintf( stderr,"generated rtti for %s\n", rttiName );
 #endif
                 if (pTypeDescr->pBaseTypeDescription)
@@ -227,6 +228,13 @@ static void deleteException( void * pExc
 //==================================================================================================
 void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
 {
+#if OSL_DEBUG_LEVEL > 1
+    OString cstr(
+        OUStringToOString(
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> uno exception occured: %s\n", cstr.getStr() );
+#endif
     void * pCppExc;
     type_info * rtti;
 
@@ -236,11 +244,16 @@ void raiseException( uno_Any * pUnoExc, 
 	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
     OSL_ASSERT( pTypeDescr );
     if (! pTypeDescr)
-        terminate();
-    
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("cannot get typedescription for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
+    }
+
 	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
 	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
-	
+
 	// destruct uno exception
 	::uno_any_destruct( pUnoExc, 0 );
     // avoiding locked counts
@@ -262,29 +275,59 @@ void raiseException( uno_Any * pUnoExc, 
     TYPELIB_DANGER_RELEASE( pTypeDescr );
     OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
     if (! rtti)
-        terminate();
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no rtti for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
     }
-    
+    }
+
 	__cxa_throw( pCppExc, rtti, deleteException );
 }
 
 //==================================================================================================
-void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+void fillUnoException( __cxa_exception * header, uno_Any * pUnoExc, uno_Mapping * pCpp2Uno )
 {
-    OSL_ENSURE( header, "### no exception header!!!" );
     if (! header)
-        terminate();
-    
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no exception header!") ),
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+        return;
+    }
+
 	typelib_TypeDescription * pExcTypeDescr = 0;
     OUString unoName( toUNOname( header->exceptionType->name() ) );
-	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
-    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
-    if (! pExcTypeDescr)
-        terminate();
-    
-    // construct uno exception any
-    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
-    ::typelib_typedescription_release( pExcTypeDescr );
+#if OSL_DEBUG_LEVEL > 1
+    OString cstr_unoName( OUStringToOString( unoName, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> c++ exception occured: %s\n", cstr_unoName.getStr() );
+#endif
+	typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    if (0 == pExcTypeDescr)
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("exception type not found: ") ) + unoName,
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+    }
+    else
+    {
+        // construct uno exception any
+        uno_any_constructAndConvert( pUnoExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+        typelib_typedescription_release( pExcTypeDescr );
+    }
 }
 
 }
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk,v
retrieving revision 1.3
retrieving revision 1.3.32.2
diff -u -p -u -p -r1.3 -r1.3.32.2
--- bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	7 Sep 2005 22:26:46 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/makefile.mk	6 Mar 2006 11:18:56 -0000	1.3.32.2
@@ -62,9 +62,11 @@ NOOPTFILES= \
 CFLAGSNOOPT=-O0
 
 SLOFILES= \
+	$(SLO)$/abi.obj			\
 	$(SLO)$/except.obj		\
 	$(SLO)$/cpp2uno.obj		\
-	$(SLO)$/uno2cpp.obj
+	$(SLO)$/uno2cpp.obj		\
+	$(SLO)$/call.obj
 
 SHL1TARGET= $(TARGET)
 
@@ -72,10 +74,8 @@ SHL1DEF=$(MISC)$/$(SHL1TARGET).def
 SHL1IMPLIB=i$(TARGET)
 SHL1VERSIONMAP=..$/..$/bridge_exports.map
 
-SHL1OBJS= \
-	$(SLO)$/except.obj		\
-	$(SLO)$/cpp2uno.obj		\
-	$(SLO)$/uno2cpp.obj
+SHL1OBJS = $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
 
 SHL1STDLIBS= \
 	$(CPPULIB)			\
@@ -87,3 +87,6 @@ SHL1STDLIBS= \
 
 .INCLUDE :  target.mk
 
+$(SLO)$/%.obj: %.s
+    $(CC) -c -o $(SLO)$/$(@:b).o $<
+    touch $@
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/share.hxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/share.hxx,v
retrieving revision 1.3
retrieving revision 1.3.32.1
diff -u -p -u -p -r1.3 -r1.3.32.1
--- bridges/source/cpp_uno/gcc3_linux_x86-64/share.hxx	7 Sep 2005 22:26:59 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/share.hxx	6 Mar 2006 11:08:58 -0000	1.3.32.1
@@ -33,6 +33,8 @@
  *
  ************************************************************************/
 
+#include "uno/mapping.h"
+
 #include <typeinfo>
 #include <exception>
 #include <cstddef>
@@ -40,6 +42,8 @@
 namespace CPPU_CURRENT_NAMESPACE
 {
 
+void dummy_can_throw_anything( char const * );
+
 // ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
 
 struct _Unwind_Exception
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx,v
retrieving revision 1.3
retrieving revision 1.3.32.3
diff -u -p -u -p -r1.3 -r1.3.32.3
--- bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	7 Sep 2005 22:27:19 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/uno2cpp.cxx	6 Mar 2006 11:27:37 -0000	1.3.32.3
@@ -37,18 +37,20 @@
 #include <stdlib.h>
 #include <rtl/alloc.h>
 
+#include <com/sun/star/uno/genfunc.hxx>
+#include "com/sun/star/uno/RuntimeException.hpp"
 #include <uno/data.h>
-#include <bridges/cpp_uno/bridge.hxx>
-#include <bridges/cpp_uno/type_misc.hxx>
+
+#include <bridges/cpp_uno/shared/bridge.hxx>
+#include <bridges/cpp_uno/shared/types.hxx>
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
 
 #include "share.hxx"
 
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 
-namespace CPPU_CURRENT_NAMESPACE
-{
-
 void dummy_can_throw_anything( char const * );
 
 // 6 integral parameters are passed in registers
@@ -105,7 +107,7 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
 		{
 		case 'D': // Double
 			if (nr_fpr < FPR_COUNT)
-				pFPR[nr_fpr++] = (double)*pSV++;
+				pFPR[nr_fpr++] = *reinterpret_cast<double *>( pSV++ );
 			else
 				*pDS++ = *pSV++;
 			break;
@@ -115,13 +117,9 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
                 // The value in %xmm register is already prepared to
                 // be retrieved as a float. Therefore, we pass the
                 // value verbatim, as a double without conversion.
-				pFPR[nr_fpr++] = *((double *)pSV);
+				pFPR[nr_fpr++] = *reinterpret_cast<double *>( pSV++ );
 			else
-			{
-				*((float *)pDS) = *((float *)pSV);
-				pDS++;
-			}
-			pSV++;
+				*pDS++ = *reinterpret_cast<double *>( pSV++ );
 			break;
 
 		case 'H': // 64-bit Word
@@ -133,26 +131,23 @@ invoke_copy_to_stack(sal_uInt64 * pDS,  
 
 		case 'I': // 32-bit Word
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt32 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt32 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt32 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV++ );
 			break;
 
 		case 'S': // 16-bit Word
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt16 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt16 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt16 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV++ );
 			break;
 
 		case 'B': // Byte
 			if (nr_gpr < GPR_COUNT)
-				pGPR[nr_gpr++] = *((sal_uInt8 *)pSV);
+				pGPR[nr_gpr++] = *reinterpret_cast<sal_uInt8 *>( pSV++ );
 			else
-				*pDS++ = *((sal_uInt8 *)pSV);
-			pSV++;
+				*pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV++ );
 			break;
 
 		default: // Default, assume 64-bit values
@@ -176,8 +171,10 @@ static void callVirtualMethod(void * pTh
 	// Stack, if used, must be 16-bytes aligned
 	if (nr_stack)
 		nr_stack = (nr_stack + 1) & ~1;
+	
+	bool bReturnsSimpleType = bridges::cpp_uno::shared::isSimpleType( eReturnType );
 
-#if 1
+#if OSL_DEBUG_LEVEL > 1
 	// Let's figure out what is really going on here
 	fprintf(stderr,"callVirtualMethod() parameters string is %s\n", pPT);
 	{
@@ -239,16 +236,21 @@ static void callVirtualMethod(void * pTh
         ARG_GPR(3);
         ARG_GPR(2);
         ARG_GPR(1);
-    case 1: a0 = (sal_uInt64) pThis;
+        ARG_GPR(0);
     case 0:;
 #undef ARG_GPR
     }
 
+	if ( bReturnsSimpleType )
+		a0 = (sal_uInt64) pThis;
+	else
+		a1 = (sal_uInt64) pThis;
+
     // Ensure that assignments to SSE registers won't be optimized away
     asm("" ::
         "x" (d0), "x" (d1), "x" (d2), "x" (d3),
         "x" (d4), "x" (d5), "x" (d6), "x" (d7));
-    
+
     // Get pointer to method
     sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
     pMethod += 8 * nVtableIndex;
@@ -256,44 +258,45 @@ static void callVirtualMethod(void * pTh
 
 	union ReturnValue {
 		struct {
-			sal_uInt64 a0;
-			sal_uInt64 a1;
+			sal_uInt64 rax;
+			sal_uInt64 rdx;
 		} i;
 		struct {
-			double d0;
-			double d1;
+			double xmm0;
+			double xmm1;
 		} f;
 	};
-	
-	ReturnValue retval = ((ReturnValue (*)(sal_uInt64, sal_uInt64, sal_uInt64,
-										   sal_uInt64, sal_uInt64, sal_uInt64))
-						  pMethod)(a0, a1, a2, a3, a4, a5);
-	
+
+	typedef ReturnValue (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
+
+	// Perform the call
+	ReturnValue aRet = ( ( FunctionCall ) pMethod )( a0, a1, a2, a3, a4, a5 );
+
 	switch (eReturnType)
 	{
 	case typelib_TypeClass_HYPER:
 	case typelib_TypeClass_UNSIGNED_HYPER:
-		*((sal_uInt64 *)pRegisterReturn) = retval.i.a0;
+		*reinterpret_cast<sal_uInt64 *>( pRegisterReturn ) = aRet.i.rax;
 		break;
 	case typelib_TypeClass_LONG:
 	case typelib_TypeClass_UNSIGNED_LONG:
 	case typelib_TypeClass_ENUM:
-		*((sal_uInt32 *)pRegisterReturn) = (sal_uInt32)retval.i.a0;
+		*reinterpret_cast<sal_uInt32 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt32*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_CHAR:
 	case typelib_TypeClass_SHORT:
 	case typelib_TypeClass_UNSIGNED_SHORT:
-		*((sal_uInt16 *)pRegisterReturn) = (sal_uInt16)retval.i.a0;
+		*reinterpret_cast<sal_uInt16 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt16*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_BOOLEAN:
 	case typelib_TypeClass_BYTE:
-		*((sal_uInt8 *)pRegisterReturn) = (sal_uInt8)retval.i.a0;
+		*reinterpret_cast<sal_uInt8 *>( pRegisterReturn ) = *reinterpret_cast<sal_uInt8*>( &aRet.i.rax );
 		break;
 	case typelib_TypeClass_FLOAT:
-		*((float *)pRegisterReturn) = (float)retval.f.d0;
+		*reinterpret_cast<float *>( pRegisterReturn ) = *reinterpret_cast<float*>( &aRet.f.xmm0 );
 		break;
 	case typelib_TypeClass_DOUBLE:
-		*((double *)pRegisterReturn) = retval.f.d0;
+		*reinterpret_cast<double *>( pRegisterReturn ) = *reinterpret_cast<double*>( &aRet.f.xmm0 );
 		break;
 	}
 }
@@ -301,8 +304,8 @@ static void callVirtualMethod(void * pTh
 
 //================================================================================================== 
 static void cpp_call(
-	cppu_unoInterfaceProxy * pThis,
-	sal_Int32 nVtableCall,
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::VtableSlot aVtableSlot,
 	typelib_TypeDescriptionReference * pReturnTypeRef,
 	sal_Int32 nParams, typelib_MethodParameter * pParams,
 	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
@@ -312,7 +315,7 @@ static void cpp_call(
   	char * pCppStackStart	= pCppStack;
 
 	// We need to know parameter types for callVirtualMethod() so generate a signature string
-	char * pParamType		= (char *)__builtin_alloca( nParams + 2 );
+	char * pParamType		= (char *)__builtin_alloca( nParams + 3 );
 	char * pPT				= pParamType;
 
 	// Return
@@ -324,15 +327,15 @@ static void cpp_call(
 	
 	if (pReturnTypeDescr)
 	{
-		if (cppu_isSimpleType( pReturnTypeDescr ))
+		if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
 		{
 			pCppReturn = pUnoReturn; // direct way for simple types
 		}
 		else
 		{
 			// complex return via ptr
-			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
-												? alloca( pReturnTypeDescr->nSize )
+			pCppReturn = *(void **)pCppStack = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+												? __builtin_alloca( pReturnTypeDescr->nSize )
 												: pUnoReturn); // direct way
 			*pPT++ = 'H';
 			pCppStack += sizeof(void *);
@@ -340,7 +343,8 @@ static void cpp_call(
 	}
 
 	// Push "this" pointer
-	*(void **)pCppStack = pThis->pCppI;
+	void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
+	*(void **)pCppStack = pAdjustedThisPtr;
 	*pPT++ = 'H';
 	pCppStack += sizeof(void *);
 
@@ -360,10 +364,10 @@ static void cpp_call(
 		typelib_TypeDescription * pParamTypeDescr = 0;
 		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
 		
-		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
 		{
 			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
-									&pThis->pBridge->aUno2Cpp );
+									pThis->getBridge()->getUno2Cpp() );
 			
 			switch (pParamTypeDescr->eTypeClass)
 			{
@@ -420,11 +424,11 @@ static void cpp_call(
 				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
 			}
 			// is in/inout
-			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
 			{
 				uno_copyAndConvertData(
 					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
-					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+					pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
 				
 				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
 				// will be released at reconversion
@@ -450,7 +454,7 @@ static void cpp_call(
 	{
 		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 7), "UNALIGNED STACK !!! (Please DO panic)" );
 		callVirtualMethod(
-			pThis->pCppI, nVtableCall,
+			pAdjustedThisPtr, aVtableSlot.index,
 			pCppReturn, pReturnTypeDescr->eTypeClass, pParamType,
 			(sal_uInt64 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_uInt64) );
 		// NO exception occured...
@@ -468,13 +472,13 @@ static void cpp_call(
 				{
 					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
 					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
-											&pThis->pBridge->aCpp2Uno );
+											pThis->getBridge()->getCpp2Uno() );
 				}
 			}
 			else // pure out
 			{
 				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
-										&pThis->pBridge->aCpp2Uno );
+										pThis->getBridge()->getCpp2Uno() );
 			}
 			// destroy temp cpp param => cpp: every param was constructed
 			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
@@ -485,14 +489,14 @@ static void cpp_call(
 		if (pCppReturn && pUnoReturn != pCppReturn)
 		{
 			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
-									&pThis->pBridge->aCpp2Uno );
+									pThis->getBridge()->getCpp2Uno() );
 			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
 		}
 	}
  	catch (...)
  	{
   		// fill uno exception
-		fillUnoException( __cxa_get_globals()->caughtExceptions, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+		fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
         
 		// temporary params
 		for ( ; nTempIndizes--; )
@@ -510,12 +514,13 @@ static void cpp_call(
 
 
 //==================================================================================================
-void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+void bridges::cpp_uno::shared::UnoInterfaceProxy::dispatch(
 	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
-	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) SAL_THROW(())
 {
 	// is my surrogate
-	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis
+		= static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy * >(pUnoI);
 	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
 	
 	switch (pMemberDescr->eTypeClass)
@@ -526,14 +531,17 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
 		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
 		
-		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
-		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		VtableSlot aVtableSlot(
+				getVtableSlot(
+					reinterpret_cast<
+					typelib_InterfaceAttributeTypeDescription const * >(
+						pMemberDescr)));
 		
 		if (pReturn)
 		{
 			// dependent dispatch
 			cpp_call(
-				pThis, nVtableCall,
+				pThis, aVtableSlot,
 				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
 				0, 0, // no params
 				pReturn, pArgs, ppException );
@@ -553,8 +561,9 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
 			
 			// dependent dispatch
+			aVtableSlot.index += 1; // get, then set method
 			cpp_call(
-				pThis, nVtableCall +1, // get, then set method
+				pThis, aVtableSlot, // get, then set method
 				pReturnTypeRef,
 				1, &aParam,
 				pReturn, pArgs, ppException );
@@ -570,10 +579,13 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
 		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
 		
-		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
-		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		VtableSlot aVtableSlot(
+				getVtableSlot(
+					reinterpret_cast<
+					typelib_InterfaceMethodTypeDescription const * >(
+						pMemberDescr)));
 		
-		switch (nVtableCall)
+		switch (aVtableSlot.index)
 		{
 			// standard calls
 		case 1: // acquire uno interface
@@ -591,8 +603,8 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 			if (pTD)
 			{
                 uno_Interface * pInterface = 0;
-                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
-                    pThis->pBridge->pUnoEnv,
+                (*pThis->getBridge()->getUnoEnv()->getRegisteredInterface)(
+                    pThis->getBridge()->getUnoEnv(),
                     (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
 			
                 if (pInterface)
@@ -611,7 +623,7 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 		default:
 			// dependent dispatch
 			cpp_call(
-				pThis, nVtableCall,
+				pThis, aVtableSlot,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
 				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
@@ -631,6 +643,3 @@ void SAL_CALL cppu_unoInterfaceProxy_dis
 	}
 	}
 }
-
-}
-
