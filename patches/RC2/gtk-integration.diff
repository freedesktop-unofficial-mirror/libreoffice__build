Index: vcl/unx/inc/saldisp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/saldisp.hxx,v
retrieving revision 1.16
diff -u -p -u -r1.16 saldisp.hxx
--- vcl/unx/inc/saldisp.hxx	11 Apr 2003 17:31:38 -0000	1.16
+++ vcl/unx/inc/saldisp.hxx	26 Jun 2003 14:47:00 -0000
@@ -340,7 +340,7 @@ class SalDisplay
     
     SalSystemData  *mpSalSystemData;
     // the one to get create and destroy notify events
-    
+
     Display		   *pDisp_;				// X Display
     Screen		   *pScreen_;			// XDefaultScreenOfDisplay
     int				nScreen_;			// XDefaultScreen
@@ -417,7 +417,9 @@ public:
 										Colormap aColMap = None);
     
     ~SalDisplay();
-    
+
+    void                       *GetGdkDisplay();
+    void                        DispatchXEvent( SalXEvent &rEvent );
     void			Init( Colormap hXColmap, const XVisualInfo* pXVI );
     
     BOOL			IsEvent();
Index: vcl/unx/source/app/saldisp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saldisp.cxx,v
retrieving revision 1.42
diff -u -p -u -r1.42 saldisp.cxx
--- vcl/unx/source/app/saldisp.cxx	12 Jun 2003 10:25:45 -0000	1.42
+++ vcl/unx/source/app/saldisp.cxx	27 Jun 2003 17:24:47 -0000
@@ -233,6 +233,14 @@ extern "C" { int gethostname(char*,int);
 #include <X11/extensions/Xinerama.h>
 #endif
 #endif
+
+#define USE_GDK_EVENT_LOOP
+
+#ifdef USE_GDK_EVENT_LOOP
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+#endif
+
 #include <postx.h>
 
 #include <salunx.h>
@@ -706,6 +714,49 @@ BOOL SalDisplay::BestVisual( Display    
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
+#ifdef USE_GDK_EVENT_LOOP
+
+extern "C" {
+    static GdkFilterReturn
+    sal_gdk_filter_func (GdkXEvent *sys_event,
+			 GdkEvent  *event,
+			 gpointer   data)
+    {
+	XEvent *xevent = (XEvent *)sys_event;
+	SalDisplay *pDisplay = (SalDisplay *) data;
+	GdkDisplay *pGdkDisplay = (GdkDisplay *) pDisplay->GetGdkDisplay();
+
+	fprintf (stderr, "event type 0x%2x: ", xevent->type);
+	if (pDisplay->GetDisplay() != xevent->xany.display)
+            fprintf( stderr, "another display (%p): ", xevent->xany.display);
+
+	if (pDisplay->GetDisplay() != xevent->xany.display &&
+	    gdk_window_lookup_for_display (pGdkDisplay, xevent->xany.window)) {
+	    fprintf( stderr, "GDK: Event on '%ld'\n", xevent->xany.window );
+	    return GDK_FILTER_CONTINUE;
+
+	} else {
+	    SalXEvent aEvent;
+	    aEvent.event_ = *xevent;
+
+            fprintf( stderr, "VCL: Event on '%ld'\n", xevent->xany.window );
+
+	    SalYieldMutex* pSalInstYieldMutex	=
+		    GetSalData()->pFirstInstance_->maInstData.mpSalYieldMutex;
+	    ::vos::OGuard aGuard( *pSalInstYieldMutex );
+
+	    pDisplay->DispatchXEvent( aEvent );
+
+	    if (pDisplay->GetDisplay() != xevent->xany.display)
+		    return GDK_FILTER_CONTINUE;
+	    else
+		    return GDK_FILTER_REMOVE;
+	}
+    }
+}
+
+#endif /* USE_GDK_EVENT_LOOP */
+
 SalDisplay::SalDisplay( Display *display, Visual *pVisual, Colormap aColMap ) : 
 		pDisp_( display ),
 		mpFallbackFactory ( NULL ),
@@ -727,6 +778,8 @@ SalDisplay::SalDisplay( Display *display
 #endif
     nScreen_  = DefaultScreen( pDisp_ );
 
+	gdk_window_add_filter( NULL, sal_gdk_filter_func, this );
+
 	if (!aColMap)
 		aColMap = DefaultColormap( display, nScreen_ );
     if( !IsDisplay() && !aColMap)
@@ -791,6 +844,13 @@ SalDisplay::~SalDisplay( )
 
 		delete mpInputMethod;
 		delete mpKbdExtension;
+
+#ifdef USE_GDK_EVENT_LOOP
+	fprintf( stderr, "Remove filter on %p\n", this);
+	gdk_window_remove_filter( NULL, sal_gdk_filter_func, this );
+	g_object_unref( GetGdkDisplay() );
+#endif /* USE_GDK_EVENT_LOOP */
+
         XCloseDisplay( pDisp_ );
     }
 
@@ -807,6 +867,12 @@ SalDisplay::~SalDisplay( )
         pSalData->SetCurDisp( NULL );
 }
 
+void *
+SalDisplay::GetGdkDisplay()
+{
+	return (void *) gdk_x11_lookup_xdisplay( pDisp_ );
+}
+
 static int DisplayHasEvent( int fd, SalDisplay *pDisplay  )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
@@ -819,6 +885,7 @@ static int DisplayHasEvent( int fd, SalD
   ::vos::OGuard aGuard( *pSalInstYieldMutex );
   return pDisplay->IsEvent();
 }
+#ifdef USE_GDK_EVENT_LOOP
 static int DisplayQueue( int fd, SalDisplay *pDisplay )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
@@ -829,6 +896,12 @@ static int DisplayQueue( int fd, SalDisp
   return XEventsQueued( pDisplay->GetDisplay(),
                         QueuedAfterReading );
 }
+#else
+static int DisplayQueue( int fd, SalDisplay *pDisplay )
+{
+  return FALSE;
+}
+#endif /* USE_GDK_EVENT_LOOP */
 static int DisplayYield( int fd, SalDisplay *pDisplay )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
@@ -840,6 +913,7 @@ static int DisplayYield( int fd, SalDisp
   return TRUE;
 }
 
+
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 void SalDisplay::Init( Colormap hXColmap, const XVisualInfo* pXVI )
 {
@@ -2505,77 +2579,89 @@ BOOL SalDisplay::IsEvent()
     if( pEventQueue_ )
         return TRUE;
 
+#ifndef USE_GDK_EVENT_LOOP
     if( XEventsQueued( pDisp_, QueuedAlready ) )
         return TRUE;
 
     XFlush( pDisp_ );
+#endif
     return FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalDisplay::Yield( BOOL bWait )
+void SalDisplay::DispatchXEvent( SalXEvent &rEvent )
 {
-    SalXEvent aEvent;
-    while( !nStateOfYield_ )
-    {
-        if( pEventQueue_ )
-        {
-            nStateOfYield_ = 5;
-            if( osl_acquireMutex( hEventGuard_ ) )
-            {
-                nStateOfYield_ = 6;
+    nStateOfYield_ = 0;
 
-                SalXEvent *pEvent = pEventQueue_;
+    BOOL bIgnoreXErrors = pXLib_->GetIgnoreXErrors();
 
-                pEventQueue_    = pEventQueue_->pNext_;
+    rEvent.pNext_   = pDispatchStack_;
+    pDispatchStack_ = &rEvent;
 
-                osl_releaseMutex( hEventGuard_ );
+    Dispatch( &rEvent.event_ );
 
-                aEvent.event_   = pEvent->event_;
+    pDispatchStack_ = rEvent.pNext_;
 
-                delete pEvent;
+#ifdef DBG_UTIL
+    if( pXLib_->WasXError() )
+    {
+	XFlush( pDisp_ );
+	PrintEvent( "SalDisplay::Yield (WasXError)", &rEvent.event_ );
+    }
+#endif
 
-                break;
-            }
-            else
-                DBG_ASSERT( 1, "SalDisplay::Yield !acquireMutex\n" );
-        }
+    pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
+}
 
-        nStateOfYield_ = 1;
+void SalDisplay::Yield( BOOL bWait )
+{
+    SalXEvent aEvent;
+    
+    while( !nStateOfYield_ )
+    {
+       if( pEventQueue_ )
+       {
+	   nStateOfYield_ = 5;
+	   if( osl_acquireMutex( hEventGuard_ ) )
+	   {
+	       nStateOfYield_ = 6;
+	       SalXEvent *pEvent = pEventQueue_;
+	       pEventQueue_    = pEventQueue_->pNext_;
 
-		SalData *pSalData		= GetSalData();
-		SalYieldMutex* pSalInstYieldMutex	=
-			pSalData->pFirstInstance_->maInstData.mpSalYieldMutex;
-		
-		DBG_ASSERT( pSalInstYieldMutex->GetThreadId() ==
-				   NAMESPACE_VOS(OThread)::getCurrentIdentifier(),
-					"will crash soon since solar mutex not locked in SalDisplay::Yield" );
-		
-		// note: alternate input is dispatched by XtAppNextEvent
-		XNextEvent( pDisp_, &aEvent.event_ );		
-	}
+	       osl_releaseMutex( hEventGuard_ );
 
-    nStateOfYield_ = 0;
+	       aEvent.event_   = pEvent->event_;
 
-    BOOL bIgnoreXErrors = pXLib_->GetIgnoreXErrors();
+	       delete pEvent;
 
-    aEvent.pNext_   = pDispatchStack_;
-    pDispatchStack_ = &aEvent;
+	       break;
+	   }
+	   else
+	       DBG_ASSERT( 1, "SalDisplay::Yield !acquireMutex\n" );
+       }
 
-    Dispatch( &aEvent.event_ );
+       nStateOfYield_ = 1;
 
-    pDispatchStack_ = aEvent.pNext_;
+       SalData *pSalData = GetSalData();
 
-#ifdef DBG_UTIL
-    if( pXLib_->WasXError() )
-    {
-        XFlush( pDisp_ );
-        PrintEvent( "SalDisplay::Yield (WasXError)", &aEvent.event_ );
+       SalYieldMutex* pSalInstYieldMutex =
+	       pSalData->pFirstInstance_->maInstData.mpSalYieldMutex;
+		
+       DBG_ASSERT( pSalInstYieldMutex->GetThreadId() ==
+		   NAMESPACE_VOS(OThread)::getCurrentIdentifier(),
+		   "will crash soon since solar mutex not locked in SalDisplay::Yield" );
+
+#ifdef USE_GDK_EVENT_LOOP
+       nStateOfYield_ = 0;
+       return; // Handled later by gdk.
+#else
+       // note: alternate input is dispatched by XtAppNextEvent
+       XNextEvent( pDisp_, &aEvent.event_ );
+#endif /* USE_GDK_EVENT_LOOP */
     }
-#endif
 
-    pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
+    DispatchXEvent( aEvent );
 }
 
 long SalDisplay::Dispatch( XEvent *pEvent )
Index: vcl/unx/source/app/saldata.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saldata.cxx,v
retrieving revision 1.25
diff -u -p -u -r1.25 saldata.cxx
--- vcl/unx/source/app/saldata.cxx	10 Jun 2003 09:09:13 -0000	1.25
+++ vcl/unx/source/app/saldata.cxx	27 Jun 2003 17:24:48 -0000
@@ -98,6 +98,9 @@
 
 #include <prex.h>
 
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+
 // [ed] 6/15/02 There's a conflicting definition of INT8 within the Xmd.h header
 // and the solar.h OOo header.  So, wrap the X11 header with a bogus #define
 // to use the OOo definition of the symbol for INT8.
@@ -147,6 +150,8 @@
 #include "i18n_xkb.hxx"
 #endif
 
+#include <glib.h>
+
 // -=-= <signal.h> -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #ifndef UNX
 #ifndef SIGBUS
@@ -530,9 +535,11 @@ void SalXLib::Init( int *pArgc, char *pp
 	 *  o  $DISPLAY environment variable
 	 *  o  defualt display
 	 */
-	
+	GdkDisplay *pGdkDisp = NULL;
 	Display *pDisp = NULL;
 
+	gtk_init_check (NULL, NULL);
+
 	// is there a -display command line parameter?
 	vos::OExtCommandLine aCommandLine;
 	sal_uInt32 nParams = aCommandLine.getCommandArgCount();
@@ -546,14 +553,14 @@ void SalXLib::Init( int *pArgc, char *pp
 			aCommandLine.getCommandArg(i+1, aParam);
 			aDisplay = rtl::OUStringToOString(
 				   aParam, osl_getThreadTextEncoding());
-			if ((pDisp = XOpenDisplay(aDisplay.getStr()))!=NULL)
+			if ((pGdkDisp = gdk_display_open(aDisplay.getStr()))!=NULL)
 			{
 				/*
-			 	* if a -display switch was used, we need
-			 	* to set the environment accoringly since 
-			 	* the clipboard build another connection 
-			 	* to the xserver using $DISPLAY
-			 	*/
+				 * if a -display switch was used, we need
+				 * to set the environment accoringly since 
+				 * the clipboard build another connection 
+				 * to the xserver using $DISPLAY
+				 */
 				const char envpre[] = "DISPLAY=";
 				char *envstr = new char[sizeof(envpre)+aDisplay.getLength()];
 				sprintf(envstr, "DISPLAY=%s", aDisplay.getStr());
@@ -563,15 +570,24 @@ void SalXLib::Init( int *pArgc, char *pp
 		}
 	}
 
-	if (!pDisp && !aDisplay.getLength()) 
+	if (!pGdkDisp && !aDisplay.getLength()) 
 	{
 		// Open $DISPLAY or default...
 		char *pDisplay = getenv("DISPLAY");
 		if (pDisplay != NULL)
 			aDisplay = rtl::OString(pDisplay);
-		pDisp  = XOpenDisplay(pDisplay);
+		pGdkDisp = gdk_display_open(pDisplay);
 	}
 
+	pDisp = gdk_x11_display_get_xdisplay(pGdkDisp);
+
+	fprintf( stderr, "Open display %p (%p): '%s'\n", this, pGdkDisp,
+		 DisplayString( pDisp ) );
+
+	GtkWidget *a = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	gtk_container_add (GTK_CONTAINER (a), gtk_button_new_with_label ("Foo"));
+	gtk_widget_show_all (a);
+
 	if ( !pDisp )
 	{
 	    rtl::OUString aProgramFileURL = pSalData->GetCommandLineParam(0);
@@ -806,6 +822,7 @@ void SalXLib::Yield( BOOL bWait )
 {
     // check for timeouts here if you want to make screenshots
     static char* p_prioritize_timer = getenv ("SAL_HIGHPRIORITY_REPAINT");
+
     if (p_prioritize_timer != NULL)
         CheckTimeout();
 
@@ -870,6 +887,7 @@ void SalXLib::Yield( BOOL bWait )
 			osl_yieldThread();
 		nFound = select( nFDs, &ReadFDS, NULL, &ExceptionFDS, pTimeout );
 	}
+
 	if( nFound < 0 ) // error
 	{
 #ifdef DBG_UTIL
@@ -887,6 +905,9 @@ void SalXLib::Yield( BOOL bWait )
     if (p_prioritize_timer == NULL)
         CheckTimeout();
 
+	while (g_main_context_pending (g_main_context_default ()))
+		g_main_context_iteration (g_main_context_default (), FALSE);
+
 	// handle wakeup events.
 	if ((nFound > 0) && (FD_ISSET(pTimeoutFDS_[0], &ReadFDS)))
 	{
@@ -941,6 +962,7 @@ void SalXLib::Yield( BOOL bWait )
 			}
 		}
 	}
+
 	nStateOfYield_ = 0;
 }
 
Index: vcl/unx/source/app/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/makefile.mk,v
retrieving revision 1.9
diff -u -p -u -r1.9 makefile.mk
--- vcl/unx/source/app/makefile.mk	13 Dec 2002 13:27:30 -0000	1.9
+++ vcl/unx/source/app/makefile.mk	27 Jun 2003 17:25:23 -0000
@@ -111,6 +111,8 @@ SLOFILES=\
 			$(SLO)$/keysymnames.obj		\
 			$(SLO)$/wmadaptor.obj
 
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
 .IF "$(OS)$(CPU)" == "SOLARISS"
 .IF "$(COM)"!="GCC"
 SLOFILES+=$(SLO)$/getfpsols.obj
Index: vcl/util/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.mk,v
retrieving revision 1.45
diff -u -p -u -r1.45 makefile.mk
--- vcl/util/makefile.mk	10 Jun 2003 14:31:36 -0000	1.45
+++ vcl/util/makefile.mk	27 Jun 2003 17:25:29 -0000
@@ -305,8 +305,12 @@ SHL1STDLIBS += -lXext -lSM -lICE -lX11
 .ENDIF          # "$(OS)"=="SOLARIS"
 .ENDIF          # "$(GUIBASE)"=="unx"
 
+.IF "$(GUIBASE)"=="unx"
+SHL1STDLIBS += `pkg-config --libs libgnomecups-1.0`
+.ENDIF
+
 .IF "$(OS)"=="LINUX" || "$(OS)"=="SOLARIS" || "$(OS)"=="FREEBSD"
-SHL1STDLIBS += -laudio
+SHL1STDLIBS += -laudio `pkg-config --libs gtk+-2.0`
 .IF "$(OS)"=="SOLARIS"
 # needed by libaudio.a
 SHL1STDLIBS += -ldl -lnsl -lsocket
