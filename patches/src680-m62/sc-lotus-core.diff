Index: sc/source/filter/inc/decl.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/decl.h,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.646.1
diff -u -p -u -r1.1.1.1 -r1.1.1.1.646.1
--- sc/source/filter/inc/decl.h	18 Sep 2000 16:45:12 -0000	1.1.1.1
+++ sc/source/filter/inc/decl.h	29 Sep 2004 16:43:41 -0000	1.1.1.1.646.1
@@ -68,7 +68,7 @@
 #include <tools/string.hxx>
 #endif
 
-enum WKTYP { eWK_UNKNOWN = -2, eWK_1 = 0, eWK_2, eWK3, eWK4, eWK_Error };
+enum WKTYP { eWK_UNKNOWN = -2, eWK_1 = 0, eWK_2, eWK3, eWK4, eWK_Error, eWK123 };
 typedef void ( BEARBFKT )( void );
 typedef sal_Char STRING16[ 16 ];
 typedef sal_Char STRING14[ 14 ];
Index: sc/source/filter/inc/formel.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/formel.hxx,v
retrieving revision 1.5
retrieving revision 1.5.166.1
diff -u -p -u -r1.5 -r1.5.166.1
--- sc/source/filter/inc/formel.hxx	4 Jun 2004 10:54:20 -0000	1.5
+++ sc/source/filter/inc/formel.hxx	29 Sep 2004 16:43:41 -0000	1.5.166.1
@@ -284,6 +284,7 @@ protected:
 	inline void			Read( UINT16& nUINT16 );
 	inline void			Read( INT16& nINT16 );
 	inline void			Read( double& fDouble );
+        inline void                     Read( UINT32& nUINT32 );
 
 						LotusConverterBase( SvStream& rStr, UINT16 nNewBuffer );
 	virtual				~LotusConverterBase();
@@ -332,6 +333,12 @@ inline void LotusConverterBase::Read( do
 {
 	aIn >> fDouble;
 	nBytesLeft -= 8;
+}
+
+inline void LotusConverterBase::Read( UINT32& nUINT32 )
+{
+	aIn >> nUINT32;
+	nBytesLeft -= 4;
 }
 
 #endif
Index: sc/source/filter/inc/lotform.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/lotform.hxx,v
retrieving revision 1.2
retrieving revision 1.2.638.1
diff -u -p -u -r1.2 -r1.2.638.1
--- sc/source/filter/inc/lotform.hxx	6 Feb 2001 16:19:42 -0000	1.2
+++ sc/source/filter/inc/lotform.hxx	29 Sep 2004 16:43:41 -0000	1.2.638.1
@@ -119,12 +119,13 @@ private:
 	// ---------------------------------------------------------------
 	static FUNC_TYPE	IndexToType( BYTE );
 	static DefTokenId	IndexToToken( BYTE );
-	static FUNC_TYPE	IndexToTypeWK3( BYTE );
-	static DefTokenId	IndexToTokenWK3( BYTE );
+	static FUNC_TYPE	IndexToTypeWK123( BYTE );
+	static DefTokenId	IndexToTokenWK123( BYTE );
 	void				DoFunc( DefTokenId eOc, BYTE nAnz, const sal_Char* pExtName );
 	void				LotusRelToScRel( UINT16 nCol, UINT16 nRow,
 							SingleRefData& rSRD );
 	BOOL				bWK3;		// alternative Codeumsetzung statt fuer < WK1
+        BOOL                            bWK123;         // alternative for 123
 	// -------------------------------------------------------------------
 	void				ReadSRD( SingleRefData& rSRD, BYTE nFlags );
 	inline void			ReadCRD( ComplRefData& rCRD, BYTE nFlags );
@@ -137,7 +138,7 @@ private:
 	void				NegToken( TokenId& rParam );
 						// ACHTUNG: wie ~, nur wird '-(<rParam>)' gebildet
 public:
-						LotusToSc( SvStream& aStr, CharSet eSrc );
+						LotusToSc( SvStream& aStr, CharSet eSrc, BOOL b );
 	virtual ConvErr		Convert( const ScTokenArray*& rpErg, INT32& nRest,
 									const FORMULA_TYPE eFT = FT_CellFormula );
 
@@ -158,7 +159,7 @@ inline void LotusToSc::ReadCRD( ComplRef
 
 inline void LotusToSc::SetWK3( void )
 {
-	bWK3 = TRUE;
+        bWK3 = TRUE;
 }
 
 
Index: sc/source/filter/inc/op.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/op.h,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.646.2
diff -u -p -u -r1.1.1.1 -r1.1.1.1.646.2
--- sc/source/filter/inc/op.h	18 Sep 2000 16:45:13 -0000	1.1.1.1
+++ sc/source/filter/inc/op.h	1 Oct 2004 16:38:04 -0000	1.1.1.1.646.2
@@ -63,6 +63,7 @@
 #define _OP_H
 
 #include <tools/solar.h>
+#include <patattr.hxx>
 
 // OP-Code-Funktionen
 class SvStream;
@@ -86,6 +87,17 @@ void OP_Margins( SvStream &aStream, USHO
 void OP_HiddenCols( SvStream &aStream, USHORT nLaenge );
 void OP_Window1( SvStream &aStream, USHORT nLaenge );
 void OP_Blank( SvStream &aStream, USHORT nLaenge );
+// Lotus 123 bits.
+void OP_BOF123( SvStream &aStream, USHORT nLaenge );
+void OP_EOF123( SvStream &aStream, USHORT nLaenge );  
+void OP_Number123( SvStream &aStream, USHORT nLaenge );
+void OP_Label123( SvStream &aStream, USHORT nLaenge );
+void OP_Formula123( SvStream &aStream, USHORT nLaenge );
+void OP_IEEENumber123(SvStream& r, UINT16 n);
+void OP_Note123(SvStream &aStream, USHORT nLaenge);
+void OP_CreatePattern123(SvStream &aStream, USHORT nLaenge);
+void OP_HorAlign123(BYTE nAlignPattern, SfxItemSet& rPattern /*  const ScPatternAttr& rPattern*/  );
+void OP_VerAlign123(BYTE nAlignPattern, SfxItemSet& rPattern /*  const ScPatternAttr& rPattern*/  );
+void OP_ApplyPatternArea123(SvStream& r);
 
 #endif
-
Index: sc/source/filter/inc/optab.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/optab.h,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.646.2
diff -u -p -u -r1.1.1.1 -r1.1.1.1.646.2
--- sc/source/filter/inc/optab.h	18 Sep 2000 16:45:13 -0000	1.1.1.1
+++ sc/source/filter/inc/optab.h	1 Oct 2004 16:38:04 -0000	1.1.1.1.646.2
@@ -65,6 +65,22 @@
 typedef void ( *OPCODE_FKT )( SvStream &aStream, USHORT nLaenge );
 
 #define FKT_LIMIT	101
+
+#define FKT_LIMIT123	101
+
+#define LOTUS_EOF	0x01
+
+#define LOTUS_FILEPASSWD 0x4b
+
+#define LOTUS_PATTERN	0x284
+
+#define LOTUS_FORMAT_INDEX 0x800
+
+#define LOTUS_FORMAT_INFO 0x801
+
+#define ROW_FORMAT_MARKER 0x106
+
+#define COL_FORMAT_MARKER 0x107
 
 #endif
 
Index: sc/source/filter/inc/tool.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/tool.h,v
retrieving revision 1.2
retrieving revision 1.2.166.1
diff -u -p -u -r1.2 -r1.2.166.1
--- sc/source/filter/inc/tool.h	4 Jun 2004 10:57:49 -0000	1.2
+++ sc/source/filter/inc/tool.h	29 Sep 2004 16:43:42 -0000	1.2.166.1
@@ -80,6 +80,8 @@ void		InitPage( void );
 String		DosToSystem( sal_Char *pSource );
 
 double		SnumToDouble( INT16 nVal );
+
+double          Snum32ToDouble( UINT32 nValue );
 
 typedef UINT16 StampTyp;
 
Index: sc/source/filter/lotus/filter.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/filter.cxx,v
retrieving revision 1.3
retrieving revision 1.3.486.2
diff -u -p -u -r1.3 -r1.3.486.2
--- sc/source/filter/lotus/filter.cxx	15 Apr 2003 17:26:38 -0000	1.3
+++ sc/source/filter/lotus/filter.cxx	1 Oct 2004 16:38:05 -0000	1.3.486.2
@@ -71,6 +71,7 @@
 
 #include <tools/solar.h>
 #include <string.h>
+#include <stl/map>
 
 #include "filter.hxx"
 #include "document.hxx"
@@ -88,6 +89,7 @@
 #include "fprogressbar.hxx"
 #endif
 
+#include "op.h"
 
 // Konstanten ------------------------------------------------------------
 const UINT16		nBOF = 0x0000;
@@ -116,95 +118,101 @@ extern sal_Char*	pDummy1;		// -> memory.
 
 extern OPCODE_FKT	pOpFkt[ FKT_LIMIT ];
 									// -> optab.cxx, Tabelle moeglicher Opcodes
+extern OPCODE_FKT	pOpFkt123[ FKT_LIMIT123 ];
+									// -> optab.cxx, Table of possible Opcodes
 
 extern long			nDateiLaenge;	// -> datei.cpp, ...der gerade offenen Datei
 
 LOTUS_ROOT*			pLotusRoot = NULL;
 
 
-WKTYP				ScanVersion( SvStream& aStream );
+std::map<UINT16, ScPatternAttr> aLotusPatternPool;
 
-
-extern FltError		ScImportLotus123old( SvStream&, ScDocument*, CharSet eSrc );
-
-
-
-FltError ScImportLotus123old( SvStream& aStream, ScDocument* pDocument, CharSet eSrc )
+static FltError
+generate_Opcodes( SvStream& aStream, ScDocument* pDoc,
+				  ScfStreamProgressBar& aPrgrsBar, WKTYP eTyp )
 {
-	aStream.Seek( 0UL );
-
-	// Zeiger auf Dokument global machen
-	pDoc = pDocument;
-
-	bEOF = FALSE;
-
-	eCharVon = eSrc;
-
-	// Speicher besorgen
-	if( !MemNew() )
-		return eERR_NOMEM;
-
-	InitPage(); // Seitenformat initialisieren (nur Tab 0!)
-
-	// Progressbar starten
-    ScfStreamProgressBar aPrgrsBar( aStream, pDocument->GetDocumentShell() );
-
-	// Datei-Typ ermitteln
-	eTyp = ScanVersion( aStream );
+	OPCODE_FKT *pOps;
+	int         nOps;
 
-	switch( eTyp )  // auswaehlen der Tabelle
+	switch(eTyp)
 	{
-		case eWK_1:
-		case eWK_2:		break;
-		case eWK3:		return eERR_NI;
-		case eWK_Error:	return eERR_FORMAT;
-		default:		return eERR_UNKN_WK;
-	}
-
-	// Init von Lotus Root-Daten -> Ctor LotusImport
-
-	// Aufdroeseln der Opcodes
-
-	while( !bEOF )
+	    case eWK_1:
+	    case eWK_2:
+		pOps = pOpFkt;
+		nOps = FKT_LIMIT;
+		break;
+	    case eWK123:
+		pOps = pOpFkt123;
+		nOps = FKT_LIMIT123;
+		break;
+	    case eWK3:		return eERR_NI;
+	    case eWK_Error:	return eERR_FORMAT;
+	    default:		return eERR_UNKN_WK;
+ 	}
+	aStream.Seek( 0UL );
+	while( !bEOF && !aStream.IsEof() )
 	{
-		UINT16			nOpcode, nLaenge;
-
-		// ein Lotus-Record einlesen
-		aStream >> nOpcode >> nLaenge;
-
-		aPrgrsBar.Progress();
-
-
-		if( aStream.IsEof() )
-			bEOF = TRUE;
-		else if( nOpcode == 75 )
-			return eERR_FILEPASSWD;
-		else if( nOpcode < FKT_LIMIT )
-			( pOpFkt[ nOpcode ] )( aStream, nLaenge );
-		else
-			aStream.SeekRel( nLaenge );
+	    UINT16 nOpcode, nLength;
+	    
+	    aStream >> nOpcode >> nLength;
+#ifdef DEBUG
+	    fprintf( stderr, "nOpcode=%x nLength=%x\n", nOpcode, nLength);
+#endif
+	    aPrgrsBar.Progress();
+	    if( nOpcode == LOTUS_EOF )
+		bEOF = TRUE;
+
+	    else if( nOpcode == LOTUS_FILEPASSWD ) 
+		return eERR_FILEPASSWD;
+		
+	    else if( nOpcode < nOps )
+		pOps[ nOpcode ] ( aStream, nLength );
+
+	    else if( eTyp == eWK123 &&
+		     nOpcode == LOTUS_PATTERN ) 
+            {
+		// This is really ugly - needs re-factoring ...
+		aStream.SeekRel(nLength);
+		aStream >> nOpcode >> nLength;
+		if ( nOpcode == 0x29a)
+		{
+		    aStream.SeekRel(nLength);
+		    aStream >> nOpcode >> nLength;
+		    if ( nOpcode == 0x804 )
+		    {
+			aStream.SeekRel(nLength);
+			OP_ApplyPatternArea123(aStream);
+		    }
+		    else
+			aStream.SeekRel(nLength);
+		}
+		else 
+		    aStream.SeekRel(nLength);
+	    }
+	    else
+		aStream.SeekRel( nLength );
 	}
 
 	MemDelete();
 
 	pDoc->CalcAfterLoad();
-
+    
 	return eERR_OK;
 }
 
-
 WKTYP ScanVersion( SvStream& aStream )
 {
 	// PREC:    pWKDatei:   Zeiger auf offene Datei
 	// POST:    return:     Typ der Datei
-	UINT16			nOpcode, nVersNr, nRecLaenge;
+	UINT16			nOpcode, nVersNr, nRecLen;
 
 	// erstes Byte muss wegen BOF zwingend 0 sein!
 	aStream >> nOpcode;
 	if( nOpcode != nBOF )
 		return eWK_UNKNOWN;
 
-	aStream >> nRecLaenge >> nVersNr;
+	aStream >> nRecLen >> nVersNr;
 
 	if( aStream.IsEof() )
 		return eWK_Error;
@@ -212,14 +220,14 @@ WKTYP ScanVersion( SvStream& aStream )
 	switch( nVersNr )
 	{
 		case 0x0404:
-			if( nRecLaenge == 2 )
+			if( nRecLen == 2 )
 				return eWK_1;
 			else
 				return eWK_UNKNOWN;
 			break;
 
 		case 0x0406:
-			if( nRecLaenge == 2 )
+			if( nRecLen == 2 )
 				return eWK_2;
 			else
 				return eWK_UNKNOWN;
@@ -228,17 +236,55 @@ WKTYP ScanVersion( SvStream& aStream )
 		case 0x1000:
 			aStream >> nVersNr;
 			if( aStream.IsEof() ) return eWK_Error;
-			if( nVersNr == 0x0004 && nRecLaenge == 26 )
+			if( nVersNr == 0x0004 && nRecLen == 26 )
 			{	// 4 Bytes von 26 gelesen->22 ueberlesen
 				aStream.Read( pDummy1, 22 );
 				return eWK3;
 			}
 			break;
+		case 0x1003:
+			if( nRecLen == 0x1a )
+				return eWK123;
+			else
+				return eWK_UNKNOWN;
+			break;	
+		case 0x1005:
+			if( nRecLen == 0x1a )
+				return eWK123;
+			else
+				return eWK_UNKNOWN;
+			break;       
 	}
 
 	return eWK_UNKNOWN;
 }
 
+FltError ScImportLotus123old( SvStream& aStream, ScDocument* pDocument, CharSet eSrc )
+{
+	aStream.Seek( 0UL );
+
+	// Zeiger auf Dokument global machen
+	pDoc = pDocument;
+
+	bEOF = FALSE;
+
+	eCharVon = eSrc;
+
+	// Speicher besorgen
+	if( !MemNew() )
+		return eERR_NOMEM;
 
+	InitPage(); // Seitenformat initialisieren (nur Tab 0!)
+
+        // Progressbar starten
+	ScfStreamProgressBar aPrgrsBar( aStream, pDocument->GetDocumentShell() );
+
+	// Datei-Typ ermitteln
+	eTyp = ScanVersion( aStream );
+
+	aLotusPatternPool.clear();
+	        	
+	return generate_Opcodes( aStream, pDoc, aPrgrsBar, eTyp );
+}
 
 
Index: sc/source/filter/lotus/lotform.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/lotform.cxx,v
retrieving revision 1.8
retrieving revision 1.8.166.2
diff -u -p -u -r1.8 -r1.8.166.2
--- sc/source/filter/lotus/lotform.cxx	4 Jun 2004 11:03:03 -0000	1.8
+++ sc/source/filter/lotus/lotform.cxx	2 Nov 2004 12:41:23 -0000	1.8.166.2
@@ -75,6 +75,7 @@
 #include "root.hxx"
 #include "ftools.hxx"
 #include "tool.h"
+#include <math.h>
 
 extern WKTYP				eTyp;
 
@@ -82,7 +83,7 @@ static const sal_Char*		GetAddInName( co
 
 static DefTokenId			lcl_KnownAddIn( const ByteString& sTest );
 
-
+//extern double decipher_Number123( UINT32 nValue );
 
 
 void LotusToSc::DoFunc( DefTokenId eOc, BYTE nAnz, const sal_Char* pExtString )
@@ -264,12 +265,13 @@ void LotusToSc::LotusRelToScRel( UINT16 
 			nCol |= 0xFF00;
 		else
 			nCol &= 0x00FF;
-		rSRD.nRelCol = ( INT16 ) nCol;
+        // #i36252# first cast unsigned 16-bit to signed 16-bit, and then to SCsCOL
+        rSRD.nRelCol = static_cast< SCsCOL >( static_cast< sal_Int16 >( nCol ) );
 		}
 	else
 	{
 		rSRD.SetColRel( FALSE );
-		rSRD.nCol = nCol & 0x00FF;
+        rSRD.nCol = static_cast< SCsCOL >( nCol & 0x00FF );
 	}
 
 	// Row-Bemachung
@@ -322,9 +324,10 @@ void LotusToSc::LotusRelToScRel( UINT16 
 		}
 
 	if( rSRD.IsRowRel() )
-		rSRD.nRelRow = static_cast<SCROW>(nRow);
+        // #i36252# first cast unsigned 16-bit to signed 16-bit, and then to SCsROW
+        rSRD.nRelRow = static_cast< SCsROW >( static_cast< sal_Int16 >( nRow ) );
 	else
-		rSRD.nRow = static_cast<SCROW>(nRow);
+        rSRD.nRow = static_cast< SCsROW >( nRow );
 
 	if( rSRD.IsRowRel() || rSRD.IsColRel() )
 		rSRD.CalcAbsIfRel( aEingPos );
@@ -340,16 +343,16 @@ void LotusToSc::ReadSRD( SingleRefData& 
 	Read( nTab );
 	Read( nCol );
 
-	BOOL b3D = ( static_cast<SCTAB>(nTab) != aEingPos.Tab() );
+    BOOL b3D = ( static_cast< SCTAB >( nTab ) != aEingPos.Tab() );
 
 	rSRD.SetColRel( ( nRelBit & 0x01 ) != 0 );
-	rSRD.nCol = static_cast<SCCOL>(nCol);
+    rSRD.nCol = static_cast< SCsCOL >( nCol );
 
 	rSRD.SetRowRel( ( nRelBit & 0x02 ) != 0 );
-	rSRD.nRow = static_cast<SCROW>(nRow);
+    rSRD.nRow = static_cast< SCsROW >( nRow );
 
 	rSRD.SetTabRel( ( ( nRelBit & 0x04) != 0 ) || !b3D );
-	rSRD.nTab = static_cast<SCTAB>(nTab);
+    rSRD.nTab = static_cast< SCsTAB >( nTab );
 
 	rSRD.SetFlag3D( b3D );
 
@@ -394,11 +397,12 @@ void LotusToSc::Reset( ScAddress aEingPo
 	}
 
 
-LotusToSc::LotusToSc( SvStream &rStream, CharSet e ) :
+LotusToSc::LotusToSc( SvStream &rStream, CharSet e, BOOL b ) :
 	LotusConverterBase( rStream, 128 )
 	{
 	eSrcChar = e;
 	bWK3 = FALSE;
+	bWK123 = b;
 	}
 
 
@@ -434,9 +438,14 @@ ConvErr LotusToSc::Convert( const ScToke
 	FuncType2*			pIndexToToken;
 
 	if( bWK3 )
-	{	// fuer > WK3
-		pIndexToType = IndexToTypeWK3;
-		pIndexToToken = IndexToTokenWK3;
+	{	// for > WK3
+		pIndexToType = IndexToTypeWK123;
+		pIndexToToken = IndexToTokenWK123;
+	}
+	else if( bWK123 )
+	{
+		pIndexToType = IndexToTypeWK123;
+		pIndexToToken = IndexToTokenWK123;
 	}
 	else
 	{
@@ -471,7 +480,7 @@ ConvErr LotusToSc::Convert( const ScToke
 		switch( eType )
 		{
 			case FT_Return:
-				if( bWK3 )
+				if( bWK3 || bWK123 )
 					nBytesLeft = 0;	// wird ab WK3 nicht benutzt
 
 				rRest = nBytesLeft;
@@ -482,7 +491,7 @@ ConvErr LotusToSc::Convert( const ScToke
 			case FT_FuncFix2:	DoFunc( eOc, 2, pExtName ); break;
 			case FT_FuncFix3:	DoFunc( eOc, 3, pExtName ); break;
 			case FT_FuncFix4:	DoFunc( eOc, 4, pExtName ); break;
-			case FT_FuncVar:
+		        case FT_FuncVar:
 				Read( nAnz );
 				DoFunc( eOc, nAnz, pExtName );
 				break;
@@ -647,16 +656,31 @@ ConvErr LotusToSc::Convert( const ScToke
 			}
 				break;
 			case FT_Const10Float:
-                aStack << aPool.Store( ScfTools::ReadLongDouble( aIn ) );
-				break;
+			        if ( bWK123 )
+			        {
+			                double fValue;
+			                Read( fValue );
+			                aStack << aPool.Store( fValue );
+			        }
+			        else aStack << aPool.Store( ScfTools::ReadLongDouble( aIn ) );
+			        break;
 			case FT_Snum:
+			        if ( bWK123 )
 				{
-				INT16 nVal;
-				Read( nVal );
-				aStack << aPool.Store( SnumToDouble( nVal ) );
+				         UINT32   nValue;
+
+				         Read( nValue );
+					 double  fValue = Snum32ToDouble( nValue );
+					 aStack << aPool.Store( fValue );
+				}
+				else
+				{
+				        INT16 nVal;
+				        Read( nVal );
+				        aStack << aPool.Store( SnumToDouble( nVal ) );
 				}
 				break;
-			default:
+		    	default:
 				DBG_ERROR( "*LotusToSc::Convert(): unbekannter enum!" );
 		}
 	}
@@ -1206,16 +1230,16 @@ DefTokenId LotusToSc::IndexToToken( BYTE
 }
 
 
-FUNC_TYPE LotusToSc::IndexToTypeWK3( BYTE nIndex )
+FUNC_TYPE LotusToSc::IndexToTypeWK123( BYTE nIndex )
 {
 	static const FUNC_TYPE pType[ 256 ] =
 	{						// Code Bezeichnung
-		FT_Const10Float,	//    0 8-Byte-IEEE-Float
+		FT_Const10Float,	//    0 8-Byte-IEEE-Long-Number
 		FT_Cref,			//    1 Cell Reference
 		FT_Rref,			//    2 Area Reference
 		FT_Return,			//    3 return
 		FT_Braces,			//    4 Klammer
-		FT_Snum,			//    5 2-Byte-Short-Num
+		FT_Snum,			//    5 Short-Number
 		FT_ConstString,		//    6 ASCII-String
 		FT_Nrref,			//    7 Named range reference
 		FT_Absnref,			//    8 Absolut named range
@@ -1471,16 +1495,16 @@ FUNC_TYPE LotusToSc::IndexToTypeWK3( BYT
 }
 
 
-DefTokenId LotusToSc::IndexToTokenWK3( BYTE nIndex )
+DefTokenId LotusToSc::IndexToTokenWK123( BYTE nIndex )
 {
 	static const DefTokenId pToken[ 256 ] =
 	{						// Code Bezeichnung
-		ocPush,				//    0 8-Byte-IEEE-Float
+		ocPush,				//    0 8-Byte-IEEE-Long-Numbers
 		ocPush,				//    1 Variable
 		ocPush,				//    2 Bereich
 		ocPush,				//    3 return
 		ocPush,				//    4 Klammer
-		ocPush,				//    5 2-Byte-Integer
+		ocPush,				//    5 Numbers
 		ocPush,				//    6 ASCII-String
 		ocPush,				//    7 Named range reference
 		ocPush,				//    8 Absolut named range
Index: sc/source/filter/lotus/lotimpop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/lotimpop.cxx,v
retrieving revision 1.7
retrieving revision 1.7.166.1
diff -u -p -u -r1.7 -r1.7.166.1
--- sc/source/filter/lotus/lotimpop.cxx	4 Jun 2004 11:03:24 -0000	1.7
+++ sc/source/filter/lotus/lotimpop.cxx	29 Sep 2004 16:43:43 -0000	1.7.166.1
@@ -97,7 +97,7 @@ static NAMESPACE_VOS( OMutex )		aLotImpS
 ImportLotus::ImportLotus( SvStream& aStream, ScDocument* pDoc, CharSet eQ ) :
     ImportTyp( pDoc, eQ ),
 	pIn( &aStream ),
-	aConv( *pIn, eQ )
+	aConv( *pIn, eQ, FALSE )
 {
 	pExtOpt = NULL;
 
Index: sc/source/filter/lotus/lotus.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/lotus.cxx,v
retrieving revision 1.4
retrieving revision 1.4.630.1
diff -u -p -u -r1.4 -r1.4.630.1
--- sc/source/filter/lotus/lotus.cxx	26 Jul 2001 19:19:12 -0000	1.4
+++ sc/source/filter/lotus/lotus.cxx	1 Oct 2004 16:38:05 -0000	1.4.630.1
@@ -85,7 +85,7 @@ extern FltError ScImportLotus123old( SvS
 
 FltError ScImportLotus123( SfxMedium& rMedium, ScDocument* pDocument, CharSet eSrc )
 {
-	ScFilterOptions aFilterOpt;
+        ScFilterOptions aFilterOpt;
 	BOOL bWithWK3 = aFilterOpt.GetWK3Flag();
 
 	SvStream*			pStream = rMedium.GetInStream();
Index: sc/source/filter/lotus/op.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/op.cxx,v
retrieving revision 1.8
retrieving revision 1.8.166.3
diff -u -p -u -r1.8 -r1.8.166.3
--- sc/source/filter/lotus/op.cxx	4 Jun 2004 11:03:55 -0000	1.8
+++ sc/source/filter/lotus/op.cxx	7 Oct 2004 16:53:11 -0000	1.8.166.3
@@ -71,16 +71,26 @@
 #include <rtl/math.hxx>
 #include <stdio.h>
 #include <string.h>
+#include <math.h>
 #include <ctype.h>
 #if defined( MAC ) || defined( ICC )
 #include <stdlib.h>
 #endif
 
+#include "scitems.hxx"
+#include "patattr.hxx"
+#include "docpool.hxx"
+#include <svx/algitem.hxx>
+#include <svx/postitem.hxx>
+#include <svx/udlnitem.hxx>
+#include <svx/wghtitem.hxx>
+
 #include "cell.hxx"
 #include "rangenam.hxx"
 #include "document.hxx"
 
 #include "op.h"
+#include "optab.h"
 #include "tool.h"
 #include "math.h"
 #include "decl.h"
@@ -105,8 +115,7 @@ extern BYTE*		pFormelBuffer;	// -> memor
 
 static UINT16		nDefWidth = ( UINT16 ) ( TWIPS_PER_CHAR * 10 );
 
-
-
+extern std::map<UINT16, ScPatternAttr> aLotusPatternPool;
 
 void NI( SvStream& r, UINT16 n )
 {
@@ -152,7 +161,7 @@ void OP_Number( SvStream& r, UINT16 n )
 
 	r >> nFormat >> nCol >> nRow >> fValue;
 
-    fValue = ::rtl::math::round( fValue, 15 );
+	fValue = ::rtl::math::round( fValue, 15 );
 	ScValueCell*	pZelle = new ScValueCell( fValue );
 	pDoc->PutCell( static_cast<SCCOL> (nCol), static_cast<SCROW> (nRow), nTab, pZelle, ( BOOL ) TRUE );
 
@@ -165,23 +174,22 @@ void OP_Label( SvStream& r, UINT16 n )
 	BYTE			nFormat;
 	UINT16			nCol, nRow;
 	SCTAB			nTab = 0;
-	sal_Char		pText[ 256 ];
 
 	r >> nFormat >> nCol >> nRow;
 	n -= 5;
 
-	r.Read( pText, n );
-	pText[ n + 1 ] = 0;   // zur Sicherheit Nullterminator anhaengen
-	// der Mega-Hack: bei Text wird HART Text als Format eingebrannt!!!!!!!
+ 	sal_Char* pText = new sal_Char[n + 1];
+  	r.Read( pText, n );
+ 	pText[n] = 0;
+
 	nFormat &= 0x80;    // Bit 7 belassen
 	nFormat |= 0x75;    // protected egal, special-text gesetzt
 
-	// Sonderzeichenanpassung
-	DosToSystem( pText );
-
 	PutFormString( static_cast<SCCOL> (nCol), static_cast<SCROW> (nRow), nTab, pText );
 
 	SetFormat( static_cast<SCCOL> (nCol), static_cast<SCROW> (nRow), nTab, nFormat, nDezStd );
+
+	delete [] pText;
 }
 
 
@@ -215,7 +223,7 @@ void OP_Formula( SvStream& r, UINT16 n )
 	INT32				nBytesLeft = nFormulaSize;
 	ScAddress			aAddress( static_cast<SCCOL> (nCol), static_cast<SCROW> (nRow), nTab );
 
-	LotusToSc			aConv( r, pLotusRoot->eCharsetQ );
+	LotusToSc			aConv( r, pLotusRoot->eCharsetQ, FALSE );
 	aConv.Reset( aAddress );
 	aConv.Convert( pErg, nBytesLeft );
 
@@ -276,8 +284,6 @@ void OP_NamedRange( SvStream& r, UINT16 
 	else
 		strcpy( pAnsi, cPuffer );           // #100211# - checked
 
-	DosToSystem( pAnsi );
-
 	String				aTmp( pAnsi, pLotusRoot->eCharsetQ );
 
     ScfTools::ConvertToScDefinedName( aTmp );
@@ -289,7 +295,7 @@ void OP_NamedRange( SvStream& r, UINT16 
 void OP_SymphNamedRange( SvStream& r, UINT16 n )
 {
 	// POST:    waren Koordinaten ungueltig, wird nicht gespeichert
-	UINT16				nColSt, nRowSt, nColEnd, nRowEnd, nN = 0;
+	UINT16				nColSt, nRowSt, nColEnd, nRowEnd;
 	BYTE				nType;
 	sal_Char*			pName;
 	sal_Char			cPuffer[ 32 ];
@@ -315,8 +321,6 @@ void OP_SymphNamedRange( SvStream& r, UI
 	else
 		strcpy( pAnsi, cPuffer );           // #100211# - checked
 
-	DosToSystem( pAnsi );
-
 	String		aTmp( pAnsi, pLotusRoot->eCharsetQ );
     ScfTools::ConvertToScDefinedName( aTmp );
 
@@ -394,4 +398,275 @@ void OP_Blank( SvStream& r, UINT16 n )
 	SetFormat( static_cast<SCCOL> (nCol), static_cast<SCROW> (nRow), 0, nFormat, nDezFloat );
 }
 
+void OP_BOF123( SvStream& r, UINT16 n )
+{
+	r.SeekRel( 26 );
+}
+
+
+void OP_EOF123( SvStream& r, UINT16 n )
+{
+	bEOF = TRUE;
+}
+
+void OP_Label123( SvStream& r, UINT16 n )
+{
+	BYTE      nTab, nCol;
+	UINT16    nRow;
+	r >> nRow >> nTab >> nCol;
+	n -= 4;
 
+	sal_Char* pText = new sal_Char[n + 1];
+	r.Read( pText, n );
+	pText[ n ] = 0;
+
+	PutFormString( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), static_cast<SCTAB>(nTab), pText );
+
+	delete []pText;
+}
+
+void OP_Number123( SvStream& r, UINT16 n )
+{
+	BYTE    nCol,nTab;
+	UINT16  nRow;
+	UINT32   nValue;
+
+	r >> nRow >> nTab >> nCol >> nValue;
+	double fValue = Snum32ToDouble( nValue );
+
+	ScValueCell *pCell = new ScValueCell( fValue );
+	pDoc->PutCell( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), static_cast<SCTAB>(nTab), pCell, (BOOL) TRUE );
+}
+
+void OP_Formula123( SvStream& r, UINT16 n )
+{
+    BYTE nCol,nTab;
+    UINT16 nRow;
+
+    r >> nRow >> nTab >> nCol;
+    r.SeekRel( 8 );    // Result- jump over
+
+    const ScTokenArray*	pErg;
+    INT32				nBytesLeft = n - 12;
+    ScAddress			aAddress( nCol, nRow, nTab );
+
+    LotusToSc			aConv( r, pLotusRoot->eCharsetQ, TRUE );
+    aConv.Reset( aAddress );
+    aConv.Convert( pErg, nBytesLeft );
+
+    ScFormulaCell*		pCell = new ScFormulaCell( pLotusRoot->pDoc, aAddress, pErg );
+
+    pCell->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
+
+    pDoc->PutCell( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), static_cast<SCTAB>(nTab), pCell, (BOOL) TRUE );
+}
+
+void OP_IEEENumber123( SvStream& r, UINT16 n)
+{
+    BYTE nCol,nTab;
+    UINT16 nRow;
+    double dValue;
+
+    r >> nRow >> nTab >> nCol >> dValue;
+
+    ScValueCell *pCell = new ScValueCell(dValue);
+    pDoc->PutCell( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), static_cast<SCTAB>(nTab), pCell, (BOOL) TRUE );
+}
+
+void OP_Note123( SvStream& r, UINT16 n)
+{
+    BYTE      nTab, nCol;
+    UINT16    nRow;
+    r >> nRow >> nTab >> nCol;
+    n -= 4;
+
+    sal_Char* pText = new sal_Char[n + 1];
+    r.Read( pText, n );
+    pText[ n ] = 0;
+
+    String aTmp(pText,pLotusRoot->eCharsetQ);
+    ScPostIt *pNote = new ScPostIt(aTmp, pLotusRoot->pDoc);
+
+    pDoc->SetNote( static_cast<SCCOL>(nCol), static_cast<SCROW>(nRow), static_cast<SCTAB>(nTab), *pNote ) ;
+
+    delete [] pText;
+}
+
+void OP_HorAlign123( BYTE nAlignPattern, SfxItemSet& rPatternItemSet )
+{
+//      pre:  Pattern is stored in the last 3 bites of the 21st byte
+//      post: Appropriate Horizontal Alignement is set in rPattern according to the bit pattern.
+//
+//      LEFT:001, RIGHT:010, CENTER:011, JUSTIFY:110,
+//      LEFT-Text/RIGHT-NUMBER:100, DEFAULT:000
+
+	nAlignPattern = ( nAlignPattern & 0x07);
+
+	switch (nAlignPattern)
+ 	{
+		case 1:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_LEFT ) );
+			break;
+	  	case 2:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_RIGHT ) );
+            break;
+		case 3:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_CENTER ) );
+            break;
+  		case 4:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_STANDARD ) );
+            break;
+		case 6:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_BLOCK ) );
+            break;
+  		default:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_STANDARD ) );
+            break;
+  	}
+}
+
+void OP_VerAlign123( BYTE nAlignPattern,SfxItemSet& rPatternItemSet  )
+{
+//      pre:  Pattern is stored in the last 3 bites of the 22nd byte
+//      post: Appropriate Verticle Alignement is set in rPattern according to the bit pattern.
+//
+//      TOP:001, MIDDLE:010, DOWN:100, DEFAULT:000
+
+	nAlignPattern = ( nAlignPattern & 0x07);
+
+    switch (nAlignPattern)
+    {
+        case 0:
+            rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_STANDARD) );
+            break;
+        case 1:
+            rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_TOP) );
+            break;
+        case 2:
+            rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_CENTER) );
+            break;
+        case 4:
+            rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_BOTTOM) );
+            break;
+        default:
+            rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_STANDARD) );
+            break;
+    }
+}
+
+void OP_CreatePattern123( SvStream& r, UINT16 n)
+{
+    UINT16 nCode,nPatternId;
+
+    ScPatternAttr aPattern(pDoc->GetPool());
+    SfxItemSet& rItemSet = aPattern.GetItemSet();
+
+    r >> nCode;
+    n = n - 2;
+
+    if ( nCode == 0x0fd2 )
+    {
+        r >> nPatternId;
+
+        BYTE Hor_Align, Ver_Align, temp;
+        BOOL bIsBold,bIsUnderLine,bIsItalics;
+
+        r.SeekRel(12);
+
+        // Read 17th Byte
+        r >> temp;
+
+        bIsBold = (temp & 0x01);
+        bIsItalics = (temp & 0x02);
+        bIsUnderLine = (temp & 0x04);
+
+        if ( bIsBold )
+            rItemSet.Put( SvxWeightItem(WEIGHT_BOLD,ATTR_FONT_WEIGHT) );
+        if ( bIsItalics )
+            rItemSet.Put( SvxPostureItem(ITALIC_NORMAL, ATTR_FONT_POSTURE ) );
+        if ( bIsUnderLine )
+            rItemSet.Put( SvxUnderlineItem( UNDERLINE_SINGLE, ATTR_FONT_UNDERLINE ) );
+
+        r.SeekRel(3);
+
+        // Read 21st Byte
+        r >> Hor_Align;
+        OP_HorAlign123( Hor_Align, rItemSet );
+
+        r >> Ver_Align;
+        OP_VerAlign123( Ver_Align, rItemSet );
+
+        aLotusPatternPool.insert( std::map<UINT16, ScPatternAttr>::value_type( nPatternId, aPattern ) );
+        n = n - 20;
+    }
+    r.SeekRel(n);
+}
+
+void OP_ApplyPatternArea123( SvStream& rStream )
+{
+    UINT16 nOpcode, nLength;
+    UINT16 nCol = 0, nColCount = 0, nRow = 0, nRowCount = 0, nTab = 0, nData, nTabCount = 0, nLevel = 0;
+
+    do
+    {
+        rStream >> nOpcode >> nLength;
+        switch ( nOpcode )
+        {
+            case ROW_FORMAT_MARKER:
+                nLevel++;
+                break;
+            case COL_FORMAT_MARKER:
+                nLevel--;
+                if( nLevel == 1 )
+                {
+                    nTab = nTab + nTabCount;
+                    nCol = 0; nColCount = 0;
+                    nRow = 0; nRowCount = 0;
+                }
+                break;
+            case LOTUS_FORMAT_INDEX:
+                if( nLength == 2 )
+                {
+                    rStream >> nData;
+                    if( nLevel == 1 )
+                        nTabCount = nData;
+                    else if( nLevel == 2 )
+                    {
+                        nCol = nCol + nColCount;
+                        nColCount = nData;
+                        if ( nCol > 0xff ) // 256 is the max col size supported by 123
+                            nCol = 0;
+                    }
+                    else if( nLevel == 3 )
+                    {
+                        nRow = nRow + nRowCount;
+                        nRowCount = nData;
+                        if ( nRow > 0x1fff ) // 8192 is the max row size supported by 123
+                            nRow = 0;
+                    }
+                }
+                else
+                    rStream.SeekRel(nLength);
+                break;
+            case LOTUS_FORMAT_INFO:
+                if( nLength == 2 )
+                {
+                    rStream >> nData;
+                    for( int i = 0; i < nTabCount; i++)
+                    {
+                        std::map<UINT16, ScPatternAttr>::iterator loc = aLotusPatternPool.find( nData );
+                        pDoc->ApplyPatternAreaTab( nCol, nRow, nCol +  nColCount - 1, nRow + nRowCount - 1, nTab + i, loc->second );
+                    }
+                }
+                else
+                    rStream.SeekRel(nLength);
+                break;
+            default:
+                rStream.SeekRel(nLength);
+                break;
+        }
+    }
+    while( nLevel && !rStream.IsEof() );
+
+    aLotusPatternPool.clear();
+}
Index: sc/source/filter/lotus/optab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/optab.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.1.1.1.646.2
diff -u -p -u -r1.1.1.1 -r1.1.1.1.646.2
--- sc/source/filter/lotus/optab.cxx	18 Sep 2000 16:45:14 -0000	1.1.1.1
+++ sc/source/filter/lotus/optab.cxx	1 Oct 2004 16:38:06 -0000	1.1.1.1.646.2
@@ -176,3 +176,108 @@ OPCODE_FKT pOpFkt[ FKT_LIMIT ] =
 };
 
 
+OPCODE_FKT pOpFkt123[ FKT_LIMIT123 ] =
+{						//  Code
+	OP_BOF123,				//    0
+	OP_EOF123,				//    1
+	NI,					//    2
+	NI,					//    3
+	NI,					//    4
+	NI,					//    5
+	NI,					//    6
+	NI,			//    7
+	NI,		//    8
+	NI,					//    9
+	NI,					//   10
+	NI,		//   11
+	NI,			//   12
+	NI,			//   13
+	NI,			//   14
+	NI,			//   15
+	NI,			//   16
+	NI,					//   17
+	NI,					//   18
+	NI,					//   19
+	NI,					//   20
+	NI,					//   21
+	OP_Label123,				//   22
+	NI,					//   23
+	NI,					//   24
+	NI,					//   25
+	NI,					//   26
+	OP_CreatePattern123,			//   27
+	NI,					//   28
+	NI,					//   29
+	NI,					//   30
+	NI,					//   31
+	NI,					//   32
+	NI,					//   33
+	NI,					//   34
+	NI,					//   35
+	NI,					//   36
+	OP_Number123,  			        //   37
+	OP_Note123,			//   38
+	OP_IEEENumber123,					//   39
+	OP_Formula123,			//   40
+	NI,					//   41
+	NI,					//   42
+	NI,					//   43
+	NI,					//   44
+	NI,					//   45
+	NI,					//   46
+	NI,					//   47
+	NI,					//   48
+	NI,					//   49
+	NI,					//   50
+	NI,					//   51
+	NI,					//   52
+	NI,					//   53
+	NI,					//   54
+	NI,					//   55
+	NI,					//   56
+	NI,					//   57
+	NI,					//   58
+	NI,					//   59
+	NI,					//   60
+	NI,					//   61
+	NI,					//   62
+	NI,					//   63
+	NI,					//   64
+	NI,					//   65
+	NI,					//   66
+	NI,					//   67
+	NI,					//   68
+	NI,					//   69
+	NI,					//   70
+	NI,	//   71
+	NI,					//   72
+	NI,					//   73
+	NI,					//   74
+	NI,					//   75
+	NI,					//   76
+	NI,					//   77
+	NI,					//   78
+	NI,					//   79
+	NI,					//   80
+	NI,					//   81
+	NI,					//   82
+	NI,					//   83
+	NI,					//   84
+	NI,					//   85
+	NI,					//   86
+	NI,					//   87
+	NI,					//   88
+	NI,					//   89
+	NI,					//   90
+	NI,					//   91
+	NI,					//   92
+	NI,					//   93
+	NI,					//   94
+	NI,					//   95
+	NI,					//   96
+	NI,					//   97
+	NI,					//   98
+	NI,					//   99
+	NI		//  100
+};
+	
Index: sc/source/filter/lotus/tool.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/tool.cxx,v
retrieving revision 1.7
retrieving revision 1.7.166.1
diff -u -p -u -r1.7 -r1.7.166.1
--- sc/source/filter/lotus/tool.cxx	4 Jun 2004 11:04:10 -0000	1.7
+++ sc/source/filter/lotus/tool.cxx	29 Sep 2004 16:43:43 -0000	1.7.166.1
@@ -72,6 +72,7 @@
 #include <svtools/zforlist.hxx>
 #include <tools/solar.h>
 
+#include <math.h>
 #include "cell.hxx"
 #include "rangenam.hxx"
 #include "compiler.hxx"
@@ -219,16 +220,6 @@ void InitPage( void )
 }
 
 
-
-
-String DosToSystem( sal_Char* p )
-{	// Umwandlung vom internen in externen Zeichensatz
-	return String( p, pLotusRoot->eCharsetQ );
-}
-
-
-
-
 double SnumToDouble( INT16 nVal )
 {
 	const double pFacts[ 8 ] = {
@@ -254,7 +245,23 @@ double SnumToDouble( INT16 nVal )
 	return fVal;
 }
 
+double Snum32ToDouble( UINT32 nValue )
+{
+	double  fValue;
+
+	fValue = nValue >> 6;
+	if (nValue & 0x0f)
+	{
+	    if (nValue & 0x00000010)
+                fValue /= pow(10, (nValue & 0x0f));
+	    else
+		fValue *= pow(10, (nValue & 0x0f));	
+	}
 
+	if ((nValue & 0x00000020))
+		fValue = -fValue;
+	return fValue;
+}
 
 
 FormCache::FormCache( ScDocument* pDoc, BYTE nNewDefaultFormat )
Index: sc/source/ui/app/scdll.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/app/scdll.cxx,v
retrieving revision 1.26
retrieving revision 1.22.20.3
diff -u -p -u -r1.26 -r1.22.20.3
--- sc/source/ui/app/scdll.cxx	12 Oct 2004 17:57:04 -0000	1.26
+++ sc/source/ui/app/scdll.cxx	19 Oct 2004 11:52:00 -0000	1.22.20.3
@@ -177,35 +177,6 @@
 
 //------------------------------------------------------------------
 
-//	Filter-Namen (wie in docsh.cxx)
-
-static const sal_Char __FAR_DATA pFilterSc50[]		= "StarCalc 5.0";
-static const sal_Char __FAR_DATA pFilterSc50Temp[]	= "StarCalc 5.0 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterSc40[]		= "StarCalc 4.0";
-static const sal_Char __FAR_DATA pFilterSc40Temp[]	= "StarCalc 4.0 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterSc30[]		= "StarCalc 3.0";
-static const sal_Char __FAR_DATA pFilterSc30Temp[]	= "StarCalc 3.0 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterSc10[]		= "StarCalc 1.0";
-static const sal_Char __FAR_DATA pFilterXML[]		= "StarOffice XML (Calc)";
-static const sal_Char __FAR_DATA pFilterAscii[]		= "Text - txt - csv (StarCalc)";
-static const sal_Char __FAR_DATA pFilterLotus[]		= "Lotus";
-static const sal_Char __FAR_DATA pFilterExcel4[]	= "MS Excel 4.0";
-static const sal_Char __FAR_DATA pFilterEx4Temp[]	= "MS Excel 4.0 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterExcel5[]	= "MS Excel 5.0/95";
-static const sal_Char __FAR_DATA pFilterEx5Temp[]	= "MS Excel 5.0/95 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterExcel95[]	= "MS Excel 95";
-static const sal_Char __FAR_DATA pFilterEx95Temp[]	= "MS Excel 95 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterExcel97[]	= "MS Excel 97";
-static const sal_Char __FAR_DATA pFilterEx97Temp[]	= "MS Excel 97 Vorlage/Template";
-static const sal_Char __FAR_DATA pFilterDBase[]		= "dBase";
-static const sal_Char __FAR_DATA pFilterDif[]		= "DIF";
-static const sal_Char __FAR_DATA pFilterSylk[]		= "SYLK";
-static const sal_Char __FAR_DATA pFilterHtml[]		= "HTML (StarCalc)";
-static const sal_Char __FAR_DATA pFilterHtmlWeb[]	= "calc_HTML_WebQuery";
-static const sal_Char __FAR_DATA pFilterRtf[]		= "Rich Text Format (StarCalc)";
-
-//------------------------------------------------------------------
-
 //	filter detection can't use ScFilterOptions (in sc-dll),
 //	so access to wk3 flag must be implemented here again
 
@@ -496,439 +467,5 @@ void ScDLL::FillStatusBar(StatusBar &rSt
 
 #undef TEXT_WIDTH
 
-BOOL lcl_MayBeAscii( SvStream& rStream )
-{
-	//	ASCII is considered possible if there are no null bytes
-
-	rStream.Seek(STREAM_SEEK_TO_BEGIN);
-
-	BOOL bNullFound = FALSE;
-	BYTE aBuffer[ 4097 ];
-	const BYTE* p = aBuffer;
-	ULONG nBytesRead = rStream.Read( aBuffer, 4096 );
-
-	if ( nBytesRead >= 2 &&
-			( ( aBuffer[0] == 0xff && aBuffer[1] == 0xfe ) ||
-			  ( aBuffer[0] == 0xfe && aBuffer[1] == 0xff ) ) )
-	{
-		//	unicode file may contain null bytes
-		return TRUE;
-	}
-
-	while( nBytesRead-- )
-		if( !*p++ )
-		{
-			bNullFound = TRUE;
-			break;
-		}
-
-	return !bNullFound;
-}
-
-BOOL lcl_MayBeDBase( SvStream& rStream )
-{
-	//	for dBase, look for the 0d character at the end of the header
-
-	rStream.Seek(STREAM_SEEK_TO_END);
-	ULONG nSize = rStream.Tell();
-
-	// length of header starts at 8
-
-	if ( nSize < 10 )
-		return FALSE;
-	rStream.Seek(8);
-	USHORT nHeaderLen;
-	rStream >> nHeaderLen;
-
-	if ( nHeaderLen < 32 || nSize < nHeaderLen )
-		return FALSE;
-
-	// last byte of header must be 0d
-
-	rStream.Seek( nHeaderLen - 1 );
-	BYTE nEndFlag;
-	rStream >> nEndFlag;
-
-	return ( nEndFlag == 0x0d );
-}
-
-BOOL lcl_IsAnyXMLFilter( const SfxFilter* pFilter )
-{
-	if ( !pFilter )
-		return FALSE;
-
-	//	TRUE for XML file or template
-	//	(template filter has no internal name -> allow configuration key names)
-
-	String aName = pFilter->GetFilterName();
-	return aName.EqualsAscii(pFilterXML) ||
-		   aName.EqualsAscii("calc_StarOffice_XML_Calc") ||
-		   aName.EqualsAscii("calc_StarOffice_XML_Calc_Template");
-}
-#if 0
-ULONG __EXPORT ScDLL::DetectFilter( SfxMedium& rMedium, const SfxFilter** ppFilter,
-									SfxFilterFlags nMust, SfxFilterFlags nDont )
-{
-	//	#59915# laut MBA darf hier nur ERRCODE_NONE, ERRCODE_ABORT und ERRCODE_FORCEQUIET
-	//	zurueckgegeben werden...
-
-	if ( SVSTREAM_OK != rMedium.GetError() )
-		return ERRCODE_ABORT;	// ERRCODE_IO_GENERAL
-
-	//	Formate, die sicher erkannt werden:
-
-	SotStorage* pStorage = rMedium.GetStorage();
-	if ( pStorage )
-	{
-		String		aStreamName;
-
-		// Erkennung ueber contained streams
-		// Excel-5 / StarCalc 3.0
-
-		aStreamName = String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Workbook"));
-		BOOL bExcel97Stream = ( pStorage->IsContained( aStreamName ) && pStorage->IsStream( aStreamName ) );
-
-		aStreamName = String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Book"));
-		BOOL bExcel5Stream = ( pStorage->IsContained( aStreamName ) && pStorage->IsStream( aStreamName ) );
-
-		if ( bExcel97Stream )
-		{
-			String aOldName;
-			if ( *ppFilter ) aOldName = (*ppFilter)->GetFilterName();
-			if ( aOldName.EqualsAscii(pFilterEx97Temp) )
-			{
-				//	Excel 97 template selected -> keep selection
-			}
-			else if ( bExcel5Stream &&
-						( aOldName.EqualsAscii(pFilterExcel5) || aOldName.EqualsAscii(pFilterEx5Temp) ||
-						  aOldName.EqualsAscii(pFilterExcel95) || aOldName.EqualsAscii(pFilterEx95Temp) ) )
-			{
-				//	dual format file and Excel 5 selected -> keep selection
-			}
-			else
-			{
-				//	else use Excel 97 filter
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-									  String::CreateFromAscii(pFilterExcel97) );
-			}
-			return ERRCODE_NONE;
-		}
-		if ( bExcel5Stream )
-		{
-			String aOldName;
-			if ( *ppFilter ) aOldName = (*ppFilter)->GetFilterName();
-			if ( aOldName.EqualsAscii(pFilterExcel95) || aOldName.EqualsAscii(pFilterEx95Temp) ||
-					aOldName.EqualsAscii(pFilterEx5Temp) )
-			{
-				//	Excel 95 oder Vorlage (5 oder 95) eingestellt -> auch gut
-			}
-            else if ( aOldName.EqualsAscii(pFilterEx97Temp) )
-            {
-                // #101923# auto detection has found template -> return Excel5 template
-                *ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-                                        String::CreateFromAscii(pFilterEx5Temp) );
-            }
-			else
-			{
-				//	sonst wird als Excel 5-Datei erkannt
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-										String::CreateFromAscii(pFilterExcel5) );
-			}
-			return ERRCODE_NONE;
-		}
-
-		aStreamName = String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM(STRING_SCSTREAM));
-		if ( pStorage->IsContained( aStreamName ) && pStorage->IsStream( aStreamName ) )
-		{
-			//	Unterscheidung 3.0 / 4.0 / 5.0 ueber Clipboard-Id
-			ULONG nStorFmt = pStorage->GetFormat();
-			if ( nStorFmt == SOT_FORMATSTR_ID_STARCALC_30 )
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-											String::CreateFromAscii(pFilterSc30) );
-			else if ( nStorFmt == SOT_FORMATSTR_ID_STARCALC_40 )
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-											String::CreateFromAscii(pFilterSc40) );
-			else
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-											String::CreateFromAscii(pFilterSc50) );
-			return ERRCODE_NONE;
-		}
-
-		//	XML package file: Stream "Content.xml" or "content.xml"
-		aStreamName = String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("content.xml"));
-		String aOldXML = String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Content.xml"));
-		if ( ( pStorage->IsContained( aStreamName ) && pStorage->IsStream( aStreamName ) ) ||
-			 ( pStorage->IsContained( aOldXML ) && pStorage->IsStream( aOldXML ) ) )
-		{
-			//	#85794# don't accept other applications' xml formats,
-			//	recognized by clipboard id
-			ULONG nStorageFormat = pStorage->GetFormat();
-			if ( nStorageFormat == 0 || nStorageFormat == SOT_FORMATSTR_ID_STARCALC_60 )
-			{
-				//	if XML template is set, don't modify
-				if (!lcl_IsAnyXMLFilter(*ppFilter))
-					*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-													  String::CreateFromAscii(pFilterXML) );
-				return ERRCODE_NONE;
-			}
-		}
-	}
-	else 	// no storage
-	{
-		SvStream &rStr = *rMedium.GetInStream();
-		if ( &rStr == NULL )
-			return ERRCODE_ABORT;	// ERRCODE_IO_GENERAL
-
-		// Tabelle mit Suchmustern
-		// Bedeutung der Sequenzen
-		// 0x00??: genau Byte 0x?? muss an dieser Stelle stehen
-		// 0x0100: ein Byte ueberlesen (don't care)
-		// 0x02nn: ein Byte aus 0xnn Alternativen folgt
-		// 0x8000: Erkennung abgeschlossen
-		//
-
-#define M_DC		0x0100
-#define M_ALT(ANZ)	0x0200+ANZ
-#define M_ENDE		0x8000
-
-		const UINT16 pLotus[] = 		// Lotus 1/1A/2
-			{ 0x0000, 0x0000, 0x0002, 0x0000,
-			  M_ALT(2), 0x0004, 0x0006,
-			  0x0004, M_ENDE };
-
-		const UINT16 pExcel1[] =		// Excel Biff/3/4 Tabellen
-			{ 0x0009,
-			  M_ALT(2), 0x0002, 0x0004,
-			  0x0006, 0x0000, M_DC, M_DC, 0x0010, 0x0000,
-			  M_DC, M_DC, M_ENDE };
-
-		const UINT16 pExcel2[] =		// Excel Biff3/4 Workbooks
-			{ 0x0009,
-			  M_ALT(2), 0x0002, 0x0004,
-			  0x0006, 0x0000, M_DC, M_DC, 0x0000, 0x0001,
-			  M_DC, M_DC, M_ENDE };
-
-		const UINT16 pExcel3[] =		// Excel Biff2 Tabellen
-			{ 0x0009, 0x0000, 0x0004, 0x0000,
-			  M_DC, M_DC, 0x0010, 0x0000, M_ENDE };
-
-		const UINT16 pSc10[] =			// StarCalc 1.0 Dokumente
-			{ 'B', 'l', 'a', 'i', 's', 'e', '-', 'T', 'a', 'b', 'e', 'l', 'l',
-			  'e', 0x000A, 0x000D, 0x0000,    // Sc10CopyRight[16]
-			  M_DC, M_DC, M_DC, M_DC, M_DC, M_DC, M_DC, M_DC, M_DC, M_DC, M_DC,
-			  M_DC, M_DC, 					// Sc10CopyRight[29]
-			  M_ALT(2), 0x0065, 0x0066,		// Versionsnummer 101 oder 102
-			  0x0000,
-			  M_ENDE };
-
-		const UINT16 pLotus2[] =		// Lotus >3
-			{ 0x0000, 0x0000, 0x001A, 0x0000,	// Rec# + Len (26)
-			  M_ALT(2), 0x0000, 0x0002,			// File Revision Code
-			  0x0010,
-			  0x0004, 0x0000,					// File Revision Subcode
-			  M_ENDE };
-
-		const UINT16 pDIF1[] =			// DIF mit CR-LF
-			{
-			'T', 'A', 'B', 'L', 'E',
-			M_DC, M_DC,
-			'0', ',', '1',
-			M_DC, M_DC,
-			'\"',
-			M_ENDE };
-
-		const UINT16 pDIF2[] =			// DIF mit CR oder LF
-			{
-			'T', 'A', 'B', 'L', 'E',
-			M_DC,
-			'0', ',', '1',
-			M_DC,
-			'\"',
-			M_ENDE };
-
-		const UINT16 pSylk[] =			// Sylk
-			{
-			'I', 'D', ';', 'P',
-			M_ENDE };
-
-#ifdef SINIX
-		const UINT16 nAnzMuster = 9;	// sollte fuer indiz. Zugriff stimmen...
-		UINT16 *ppMuster[ nAnzMuster ];			// Arrays mit Suchmustern
-		ppMuster[ 0 ] = pLotus;
-		ppMuster[ 1 ] = pExcel1;
-		ppMuster[ 2 ] = pExcel2;
-		ppMuster[ 3 ] = pExcel3;
-		ppMuster[ 4 ] = pSc10;
-		ppMuster[ 5 ] = pDIF1;
-		ppMuster[ 6 ] = pDIF2;
-		ppMuster[ 7 ] = pSylk;
-		ppMuster[ 8 ] = pLotus2;				// Lotus immer ganz hinten wegen Ini-Eintrag
-#else
-		const UINT16 *ppMuster[] =		// Arrays mit Suchmustern
-			{
-			pLotus,
-			pExcel1,
-			pExcel2,
-			pExcel3,
-			pSc10,
-			pDIF1,
-			pDIF2,
-			pSylk,
-			pLotus2
-			};
-		const UINT16 nAnzMuster = sizeof(ppMuster) / sizeof(ppMuster[0]);
-#endif
-
-		const sal_Char* pFilterName[ nAnzMuster ] = 	// zugehoerige Filter
-			{
-			pFilterLotus,
-			pFilterExcel4,
-			pFilterExcel4,
-			pFilterExcel4,
-			pFilterSc10,
-			pFilterDif,
-			pFilterDif,
-			pFilterSylk,
-			pFilterLotus
-			};
-
-		const UINT16 nByteMask = 0xFF;
-
-		// suchen Sie jetzt!
-		// ... realisiert ueber 'Mustererkennung'
-
-		BYTE			nAkt;
-		BOOL			bSync;			// Datei und Muster stimmen ueberein
-		USHORT			nFilter;		// Zaehler ueber alle Filter
-		const UINT16	*pSearch;		// aktuelles Musterwort
-		UINT16			nFilterLimit = nAnzMuster;
-
-		// nur solange, bis es etwas Globales gibt
-		// funzt nur, solange Eintraege fuer WK3 letzte Muster-Tabelle ist!
-		ScLibOptions aLibOpt;
-		if( !aLibOpt.GetWK3Flag() )
-			nFilterLimit--;
-
-		for ( nFilter = 0 ; nFilter < nFilterLimit ; nFilter++ )
-		{
-			rStr.Seek( 0 ); // am Anfang war alles Uebel...
-			rStr >> nAkt;
-			pSearch = ppMuster[ nFilter ];
-			bSync = TRUE;
-			while( !rStr.IsEof() && bSync )
-			{
-				register UINT16 nMuster = *pSearch;
-
-				if( nMuster < 0x0100 )
-				{ // 								direkter Byte-Vergleich
-					if( ( BYTE ) nMuster != nAkt )
-						bSync = FALSE;
-				}
-				else if( nMuster & M_DC )
-				{ // 											 don't care
-				}
-				else if( nMuster & M_ALT(0) )
-				{ // 									  alternative Bytes
-					BYTE nAnzAlt = ( BYTE ) nMuster;
-					bSync = FALSE;			// zunaechst unsynchron
-					while( nAnzAlt > 0 )
-					{
-						pSearch++;
-						if( ( BYTE ) *pSearch == nAkt )
-							bSync = TRUE;	// jetzt erst Synchronisierung
-						nAnzAlt--;
-					}
-				}
-				else if( nMuster & M_ENDE )
-				{ // 										Format detected
-					if ( pFilterName[nFilter] == pFilterExcel4 && *ppFilter &&
-							(*ppFilter)->GetFilterName().EqualsAscii(pFilterEx4Temp) )
-					{
-						//	Excel 4 erkannt, Excel 4 Vorlage eingestellt -> auch gut
-					}
-					else
-					{	// gefundenen Filter einstellen
-						*ppFilter = SFX_APP()->GetFilter(
-							ScDocShell::Factory(),
-							String::CreateFromAscii(pFilterName[ nFilter ]) );
-					}
-
-					return ERRCODE_NONE;
-				}
-				else
-				{ // 										 Tabellenfehler
-					DBG_ERROR( "-ScApplication::DetectFilter(): Fehler in Mustertabelle");
-				}
-
-				pSearch++;
-				rStr >> nAkt;
-			}
-		}
-
-        String aPresetFilterName;
-        if ( *ppFilter )
-            aPresetFilterName = (*ppFilter)->GetFilterName();
-
-        // ASCII cannot be recognized.
-        // #i3341# But if the Text/CSV filter was set (either by the user or
-        // file extension) it takes precedence over HTML and RTF and dBase
-        // detection. Otherwise something like, for example, "lala <SUP> gugu"
-        // would trigger HTML to be recognized.
-
-        if ( aPresetFilterName.EqualsAscii(pFilterAscii) && lcl_MayBeAscii( rStr ) )
-            return ERRCODE_NONE;
-
-        // get file header
-
-		rStr.Seek( 0 );
-		const int nTrySize = 80;
-		ByteString aHeader;
-		for ( int j = 0; j < nTrySize && !rStr.IsEof(); j++ )
-		{
-			sal_Char c;
-			rStr >> c;
-			aHeader += c;
-		}
-		aHeader += '\0';
-
-		// test for HTML
-
-		if ( HTMLParser::IsHTMLFormat( aHeader.GetBuffer() ) )
-		{
-			if ( aPresetFilterName.EqualsAscii(pFilterHtml) )
-			{
-				// old HTML filter is allowed, default is WebQuery filter
-			}
-			else
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-											  	String::CreateFromAscii(pFilterHtmlWeb) );
-			return ERRCODE_NONE;
-		}
-
-        // test for RTF
-
-		if ( aHeader.CompareTo( "{\\rtf", 5 ) == COMPARE_EQUAL )
-		{
-			*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-											  String::CreateFromAscii(pFilterRtf) );
-			return ERRCODE_NONE;
-		}
-
-        // #97832#; we don't have a flat xml filter
-/*		if ( aHeader.CompareTo( "<?xml", 5 ) == COMPARE_EQUAL )
-		{
-			//	if XML template is set, don't modify
-			if (!lcl_IsAnyXMLFilter(*ppFilter))
-				*ppFilter = SFX_APP()->GetFilter( ScDocShell::Factory(),
-												  String::CreateFromAscii(pFilterXML) );
-			return ERRCODE_NONE;
-		}*/
-
-        // dBase cannot safely be recognized - only test if the filter was set
-        if ( aPresetFilterName.EqualsAscii(pFilterDBase) && lcl_MayBeDBase( rStr ) )
-            return ERRCODE_NONE;
-	}
-
-	return ERRCODE_ABORT;		// war nix
-}
-#endif
+// DetectFilter functionality has moved - please update your bookmarks
+// see sc/source/ui/unoobj/scdetect.cxx, have a nice day.
Index: sc/source/ui/docshell/docsh.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docsh.cxx,v
retrieving revision 1.75
retrieving revision 1.73.26.2
diff -u -p -u -r1.75 -r1.73.26.2
--- sc/source/ui/docshell/docsh.cxx	11 Oct 2004 12:29:23 -0000	1.75
+++ sc/source/ui/docshell/docsh.cxx	19 Oct 2004 10:43:03 -0000	1.73.26.2
@@ -874,41 +874,38 @@ BOOL __EXPORT ScDocShell::ConvertFrom( S
 		}
 		else if (aFltName.EqualsAscii(pFilterLotus))
 		{
-//			SvStream* pStream = rMedium.GetInStream();
-//			if (pStream)
+			String sItStr;
+			SfxItemSet*	 pSet = rMedium.GetItemSet();
+			const SfxPoolItem* pItem;
+			if ( pSet && SFX_ITEM_SET ==
+				 pSet->GetItemState( SID_FILE_FILTEROPTIONS, TRUE, &pItem ) )
 			{
-				String sItStr;
-				SfxItemSet*	 pSet = rMedium.GetItemSet();
-				const SfxPoolItem* pItem;
-				if ( pSet && SFX_ITEM_SET ==
-					 pSet->GetItemState( SID_FILE_FILTEROPTIONS, TRUE, &pItem ) )
-				{
-					sItStr = ((const SfxStringItem*)pItem)->GetValue();
-				}
-
-				if (sItStr.Len() == 0)
-				{
-					//	default for lotus import (from API without options):
-					//	IBM_437 encoding
+				sItStr = ((const SfxStringItem*)pItem)->GetValue();
+			}
 
-					sItStr = ScGlobal::GetCharsetString( RTL_TEXTENCODING_IBM_437 );
-				}
+			if (sItStr.Len() == 0)
+			{
+				//	default for lotus import (from API without options):
+				//	IBM_437 encoding
+				sItStr = ScGlobal::GetCharsetString( RTL_TEXTENCODING_IBM_437 );
+			}
 
-				ScColumn::bDoubleAlloc = TRUE;
-				FltError eError = ScImportLotus123( rMedium, &aDocument,
-									ScGlobal::GetCharsetValue(sItStr));
-				ScColumn::bDoubleAlloc = FALSE;
-				if (eError != eERR_OK)
-				{
-					if (!GetError())
-						SetError(eError);
+			ScColumn::bDoubleAlloc = TRUE;
+			FltError eError = ScImportLotus123( rMedium, &aDocument,
+												ScGlobal::GetCharsetValue(sItStr));
+			ScColumn::bDoubleAlloc = FALSE;
+			if (eError != eERR_OK)
+			{
+				if (!GetError())
+					SetError(eError);
 
-					if( ( eError & ERRCODE_WARNING_MASK ) == ERRCODE_WARNING_MASK )
-						bRet = TRUE;
-				}
-				else
+				if( ( eError & ERRCODE_WARNING_MASK ) == ERRCODE_WARNING_MASK )
 					bRet = TRUE;
 			}
+			else
+				bRet = TRUE;
+			bSetColWidths = TRUE;
+			bSetRowHeights = TRUE;
 		}
 		else if ( aFltName.EqualsAscii(pFilterExcel4) || aFltName.EqualsAscii(pFilterExcel5) ||
 				   aFltName.EqualsAscii(pFilterExcel95) || aFltName.EqualsAscii(pFilterExcel97) ||
Index: sc/source/ui/pagedlg/areasdlg.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/pagedlg/areasdlg.cxx,v
retrieving revision 1.10
retrieving revision 1.10.166.1
diff -u -p -u -r1.10 -r1.10.166.1
--- sc/source/ui/pagedlg/areasdlg.cxx	4 Jun 2004 11:50:17 -0000	1.10
+++ sc/source/ui/pagedlg/areasdlg.cxx	30 Sep 2004 11:33:00 -0000	1.10.166.1
@@ -177,15 +177,7 @@ ScPrintAreasDlg::ScPrintAreasDlg( SfxBin
 ScPrintAreasDlg::~ScPrintAreasDlg()
 {
 	// Extra-Data an ListBox-Entries abraeumen
-
-#ifdef SINIX
-	ListBox* pLb[3];
-	pLb[0] = &aLbPrintArea;
-	pLb[1] = &aLbRepeatRow;
-	pLb[2] = &aLbRepeatCol;
-#else
 	ListBox* pLb[3] = { &aLbPrintArea, &aLbRepeatRow, &aLbRepeatCol };
-#endif
 
 	for ( USHORT i=0; i<3; i++ )
 	{
Index: sc/source/ui/unoobj/scdetect.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/scdetect.cxx,v
retrieving revision 1.5
retrieving revision 1.4.164.2
diff -u -p -u -r1.5 -r1.4.164.2
--- sc/source/ui/unoobj/scdetect.cxx	4 Oct 2004 20:21:15 -0000	1.5
+++ sc/source/ui/unoobj/scdetect.cxx	19 Oct 2004 10:40:58 -0000	1.4.164.2
@@ -192,7 +192,7 @@ static const sal_Char __FAR_DATA pFilter
 static const sal_Char __FAR_DATA pFilterRtf[]		= "Rich Text Format (StarCalc)";
 
 
-BOOL lcl_MayBeAscii( SvStream& rStream )
+static BOOL lcl_MayBeAscii( SvStream& rStream )
 {
 	//	ASCII is considered possible if there are no null bytes
 
@@ -221,7 +221,7 @@ BOOL lcl_MayBeAscii( SvStream& rStream )
 	return !bNullFound;
 }
 
-BOOL lcl_MayBeDBase( SvStream& rStream )
+static BOOL lcl_MayBeDBase( SvStream& rStream )
 {
 	//	for dBase, look for the 0d character at the end of the header
 
@@ -251,7 +251,7 @@ BOOL lcl_MayBeDBase( SvStream& rStream )
             ((nHeaderLen % 2 == 0) && nOneBefore == 0x0d && nEndFlag == 0x00) );
 }
 
-BOOL lcl_IsAnyXMLFilter( const SfxFilter* pFilter )
+static BOOL lcl_IsAnyXMLFilter( const SfxFilter* pFilter )
 {
 	if ( !pFilter )
 		return FALSE;
@@ -577,6 +577,12 @@ BOOL lcl_IsAnyXMLFilter( const SfxFilter
                             M_ALT(2), 0x0004, 0x0006,
                             0x0004, M_ENDE };
 
+			const UINT16 pLotusNew[] =			// Lotus > 97
+			    { 0x0000, 0x0000, M_DC, 0x0000,		// Rec# + Len (0x1a)
+			      M_ALT(3), 0x0003, 0x0004, 0x0005,		// File Revision Code
+			      0x0010, 0x0004, 0x0000, 0x0000,
+			      M_ENDE };
+
                         const UINT16 pExcel1[] =        // Excel Biff/3/4 Tabellen
                             { 0x0009,
                             M_ALT(2), 0x0002, 0x0004,
@@ -632,20 +638,7 @@ BOOL lcl_IsAnyXMLFilter( const SfxFilter
                             'I', 'D', ';', 'P',
                             M_ENDE };
 
-        #ifdef SINIX
-                        const UINT16 nAnzMuster = 9;    // sollte fuer indiz. Zugriff stimmen...
-                        UINT16 *ppMuster[ nAnzMuster ];         // Arrays mit Suchmustern
-                        ppMuster[ 0 ] = pLotus;
-                        ppMuster[ 1 ] = pExcel1;
-                        ppMuster[ 2 ] = pExcel2;
-                        ppMuster[ 3 ] = pExcel3;
-                        ppMuster[ 4 ] = pSc10;
-                        ppMuster[ 5 ] = pDIF1;
-                        ppMuster[ 6 ] = pDIF2;
-                        ppMuster[ 7 ] = pSylk;
-                        ppMuster[ 8 ] = pLotus2;                // Lotus immer ganz hinten wegen Ini-Eintrag
-        #else
-                        const UINT16 *ppMuster[] =      // Arrays mit Suchmustern
+                        const UINT16 *ppFilterPatterns[] =      // Arrays mit Suchmustern
                             {
                             pLotus,
                             pExcel1,
@@ -655,12 +648,12 @@ BOOL lcl_IsAnyXMLFilter( const SfxFilter
                             pDIF1,
                             pDIF2,
                             pSylk,
+                            pLotusNew,
                             pLotus2
                             };
-                        const UINT16 nAnzMuster = sizeof(ppMuster) / sizeof(ppMuster[0]);
-        #endif
+                        const UINT16 nFilterCount = sizeof(ppFilterPatterns) / sizeof(ppFilterPatterns[0]);
 
-                        const sal_Char* pFilterName[ nAnzMuster ] =     // zugehoerige Filter
+                        const sal_Char* pFilterName[ nFilterCount ] =     // zugehoerige Filter
                             {
                             pFilterLotus,
                             pFilterExcel4,
@@ -670,6 +663,7 @@ BOOL lcl_IsAnyXMLFilter( const SfxFilter
                             pFilterDif,
                             pFilterDif,
                             pFilterSylk,
+                            pFilterLotus,
                             pFilterLotus
                             };
 
@@ -682,19 +676,12 @@ BOOL lcl_IsAnyXMLFilter( const SfxFilter
                         BOOL            bSync;          // Datei und Muster stimmen ueberein
                         USHORT          nFilter;        // Zaehler ueber alle Filter
                         const UINT16    *pSearch;       // aktuelles Musterwort
-                        UINT16          nFilterLimit = nAnzMuster;
-
-                        // nur solange, bis es etwas Globales gibt
-                        // funzt nur, solange Eintraege fuer WK3 letzte Muster-Tabelle ist!
-        //!MBA              //ScLibOptions aLibOpt;
-                        //if( !aLibOpt.GetWK3Flag() )
-                        //  nFilterLimit--;
 
-                        for ( nFilter = 0 ; nFilter < nFilterLimit ; nFilter++ )
+                        for ( nFilter = 0 ; nFilter < nFilterCount ; nFilter++ )
                         {
                             rStr.Seek( 0 ); // am Anfang war alles Uebel...
                             rStr >> nAkt;
-                            pSearch = ppMuster[ nFilter ];
+                            pSearch = ppFilterPatterns[ nFilter ];
                             bSync = TRUE;
                             while( !rStr.IsEof() && bSync )
                             {
