--- sw/source/core/doc/doctxm.cxx	29 Jan 2008 08:37:38 -0000	1.48
+++ sw/source/core/doc/doctxm.cxx	18 Feb 2008 16:15:53 -0000	1.47.160.2
@@ -1868,10 +1868,14 @@ void SwTOXBaseSection::GenerateText( USH
 					}
 					else
 						nRightMargin = aNdRect.Width();
+                    //#i24363# tab stops relative to indent
+                    if( pDoc->get(IDocumentSettingAccess::TABS_RELATIVE_TO_INDENT) )
+                    {
                     //left margin of paragraph style
                     const SvxLRSpaceItem& rLRSpace = pTOXNd->GetTxtColl()->GetLRSpace();
                     nRightMargin -= rLRSpace.GetLeft();
                     nRightMargin -= rLRSpace.GetTxtFirstLineOfst();
+                    }
 
                     aTStops.Insert( SvxTabStop( nRightMargin, SVX_TAB_ADJUST_RIGHT,
 												cDfltDecimalChar,
--- sw/source/core/layout/frmtool.cxx	12 Feb 2008 16:10:03 -0000	1.101
+++ sw/source/core/layout/frmtool.cxx	18 Feb 2008 16:15:47 -0000	1.100.162.2
@@ -2061,6 +2061,14 @@ long SwBorderAttrs::CalcRight( const SwF
     else
         nRight += rLR.GetRight();
 
+    // --> OD 2008-01-21 #newlistlevelattrs#
+    // correction: retrieve left margin for numbering in R2L-layout
+    if ( pCaller->IsTxtFrm() && pCaller->IsRightToLeft() )
+    {
+        nRight += ((SwTxtFrm*)pCaller)->GetTxtNode()->GetLeftMarginWithNum();
+    }
+    // <--
+
     return nRight;
 }
 
@@ -2081,8 +2089,14 @@ long SwBorderAttrs::CalcLeft( const SwFr
     else
         nLeft += rLR.GetLeft();
 
-    if ( pCaller->IsTxtFrm() )
+    // --> OD 2008-01-21 #newlistlevelattrs#
+    // correction: do not retrieve left margin for numbering in R2L-layout
+//    if ( pCaller->IsTxtFrm() )
+    if ( pCaller->IsTxtFrm() && !pCaller->IsRightToLeft() )
+    // <--
+    {
         nLeft += ((SwTxtFrm*)pCaller)->GetTxtNode()->GetLeftMarginWithNum();
+    }
 
     return nLeft;
 }
--- sw/source/core/text/itrcrsr.cxx	22 Nov 2007 15:38:25 -0000	1.77
+++ sw/source/core/text/itrcrsr.cxx	13 Feb 2008 14:06:03 -0000	1.77.102.1
@@ -202,27 +202,26 @@ void SwTxtMargin::CtorInitTxtMargin( SwT
     const int nLMWithNum = pNode->GetLeftMarginWithNum( sal_True );
     if ( pFrm->IsRightToLeft() )
     {
+        // --> OD 2008-01-23 #newlistlevelattrs#
+        // this calculation is identical this the calculation for L2R layout - see below
         nLeft = pFrm->Frm().Left() +
                 pFrm->Prt().Left() +
                 nLMWithNum -
-                ( rSpace.GetTxtFirstLineOfst() < 0 ?
-                  rSpace.GetTxtFirstLineOfst() :
-                  0 );
+                pNode->GetLeftMarginWithNum( sal_False ) -
+                rSpace.GetLeft() +
+                rSpace.GetTxtLeft();
     }
     else
     {
         if ( !pNode->getIDocumentSettingAccess()->get(IDocumentSettingAccess::IGNORE_FIRST_LINE_INDENT_IN_NUMBERING) )
         {
-            // --> FME 2004-07-29 #i32267# Do not forget paragraph border
-            // I'm quite sure this can be optimized. But how?
-            // Not enough time to figure out.
+            // this calculation is identical this the calculation for R2L layout - see above
             nLeft = pFrm->Frm().Left() +
                     pFrm->Prt().Left() +
                     nLMWithNum -
                     pNode->GetLeftMarginWithNum( sal_False ) -
                     rSpace.GetLeft() +
                     rSpace.GetTxtLeft();
-            // <--
         }
         else
         {
--- sw/source/core/text/txttab.cxx	10 Jan 2008 12:30:04 -0000	1.28
+++ sw/source/core/text/txttab.cxx	13 Feb 2008 14:06:04 -0000	1.28.2.1
@@ -74,7 +74,6 @@
 const SvxTabStop *SwLineInfo::GetTabStop( const SwTwips nSearchPos,
                                          const SwTwips nRight ) const
 {
-	// Mit den KSHORTs aufpassen, falls nLinePos < nLeft
 	for( MSHORT i = 0; i < pRuler->Count(); ++i )
 	{
 		const SvxTabStop &rTabStop = pRuler->operator[](i);
@@ -118,14 +117,28 @@ SwTabPortion *SwTxtFormatter::NewTabPort
         // #i24363# tab stops relative to indent
         // nTabLeft: The absolute value, the tab stops are relative to: Tabs origin.
         //
-        const SwTwips nTmpIndent = pFrm->GetTxtNode()->getIDocumentSettingAccess()->get(IDocumentSettingAccess::TABS_RELATIVE_TO_INDENT) ?
-                                   pFrm->GetAttrSet()->GetLRSpace().GetTxtLeft() : 0;
-
-        const SwTwips nTabLeft = bRTL ?
-                                 pFrm->Frm().Right() - 
-                                 nTmpIndent :
-                                 pFrm->Frm().Left() + 
-                                 nTmpIndent;
+        // --> OD 2008-02-07 #newlistlevelattrs#
+//        const SwTwips nTmpIndent = pFrm->GetTxtNode()->getIDocumentSettingAccess()->get(IDocumentSettingAccess::TABS_RELATIVE_TO_INDENT) ?
+//                                   pFrm->GetAttrSet()->GetLRSpace().GetTxtLeft() : 0;
+//        const SwTwips nTabLeft = bRTL ?
+//                                 pFrm->Frm().Right() - nTmpIndent :
+//                                 pFrm->Frm().Left() + nTmpIndent;
+        SwTwips nTabLeft( 0 );
+        if ( pFrm->GetTxtNode()->getIDocumentSettingAccess()->get(IDocumentSettingAccess::TABS_RELATIVE_TO_INDENT) )
+        {
+            nTabLeft = Left();
+            if ( bRTL )
+            {
+                Point aPoint( nTabLeft, 0 );
+                pFrm->SwitchLTRtoRTL( aPoint );
+                nTabLeft = aPoint.X();
+            }
+        }
+        else
+        {
+            nTabLeft = bRTL ? pFrm->Frm().Right() : pFrm->Frm().Left();
+        }
+        // <--
                                    
         //
         // nLinePos: The absolute position, where we started the line formatting.
@@ -217,19 +230,42 @@ SwTabPortion *SwTxtFormatter::NewTabPort
 			cFill = 0;
 			eAdj = SVX_TAB_ADJUST_LEFT;
 		}
+        // --> OD 2008-02-07 #newlistlevelattrs#
 		long nForced = 0;
+        if ( !pFrm->GetTxtNode()->getIDocumentSettingAccess()->get(IDocumentSettingAccess::TABS_RELATIVE_TO_INDENT) )
+        {
+            if ( bRTL )
+            {
+                Point aPoint( Left(), 0 );
+                pFrm->SwitchLTRtoRTL( aPoint );
+                nForced = pFrm->Frm().Right() - aPoint.X();
+            }
+            else
+            {
+                nForced = Left() - pFrm->Frm().Left();
+            }
+        }
 		if( pCurr->HasForcedLeftMargin() )
 		{
 			SwLinePortion* pPor = pCurr->GetPortion();
 			while( pPor && !pPor->IsFlyPortion() )
 				pPor = pPor->GetPortion();
 			if( pPor )
-				nForced = pPor->Width();
+                nForced += pPor->Width();
 		}
        
-        if( nNextPos > 0 &&
-             (  bRTL && nTabLeft - nForced < nCurrentAbsPos ||
-               !bRTL && nTabLeft + nForced > nCurrentAbsPos ) )
+        // <--
+        // --> OD 2008-02-07 #newlistlevelattrs#
+        // In case that the proposed new tab stop position is the list tab stop
+        // position, do not force a tab stop at left margin.
+//        if( nNextPos > 0 &&
+//             (  bRTL && nTabLeft - nForced < nCurrentAbsPos ||
+//               !bRTL && nTabLeft + nForced > nCurrentAbsPos ) )
+        if ( 
+             ( ( bRTL && nCurrentAbsPos > nTabLeft - nForced ) ||
+               ( !bRTL && nCurrentAbsPos < nTabLeft + nForced ) ) &&
+             nNextPos > nForced )
+        // <--
 		{
 			eAdj = SVX_TAB_ADJUST_DEFAULT;
 			cFill = 0;
--- sw/source/core/unocore/unodraw.cxx	12 Nov 2007 16:26:46 -0000	1.78
+++ sw/source/core/unocore/unodraw.cxx	4 Feb 2008 11:32:04 -0000	1.78.104.2
@@ -55,9 +55,12 @@
 #ifndef _SVX_UNOPRNMS_HXX
 #include <svx/unoprnms.hxx>
 #endif
+#include <swunohelper.hxx>
 #ifndef _DOC_HXX //autogen
 #include <doc.hxx>
 #endif
+#include <fmtflcnt.hxx>
+#include <txtatr.hxx>
 #ifndef _SWDOCSH_HXX
 #include <docsh.hxx>
 #endif
@@ -658,6 +661,16 @@ void SwXDrawPage::add(const uno::Referen
             aExcept.Message = C2U("illegal object");
         throw aExcept;
     }
+
+    // --> OD, HB
+    if ( pSvxShape->GetSdrObject() )
+    {
+        if ( pSvxShape->GetSdrObject()->IsInserted() )
+        {
+            return;
+        }
+    }
+    // <--
 	GetSvxPage()->add(xShape);
 
 	uno::Reference< uno::XAggregation > 	xAgg = pShape->GetAggregationInterface();
@@ -1212,10 +1225,38 @@ void SwXShape::setPropertyValue(const rt
                         aValue >>= xRg;
                         if ( SwXTextRange::XTextRangeToSwPaM(*pInternalPam, xRg) )
                         {
+                            if(aAnchor.GetAnchorId() == FLY_IN_CNTNT)
+                            {
+                                //delete old SwFmtFlyCnt
+                                //With AnchorAsCharacter the current TxtAttribute has to be deleted.
+                                //Tbis removes the frame format too.
+                                //To prevent this the connection between format and attribute has to be broken before.
+                                const SwPosition *pPos = aAnchor.GetCntntAnchor();
+                                SwTxtNode *pTxtNode = pPos->nNode.GetNode().GetTxtNode();
+                                ASSERT( pTxtNode->HasHints(), "Missing FlyInCnt-Hint." );
+                                const xub_StrLen nIdx = pPos->nContent.GetIndex();
+                                SwTxtAttr * pHnt = pTxtNode->GetTxtAttr( nIdx, RES_TXTATR_FLYCNT );
+                                DBG_ASSERT( pHnt && pHnt->Which() == RES_TXTATR_FLYCNT,
+                                            "Missing FlyInCnt-Hint." );
+                                DBG_ASSERT( pHnt && pHnt->GetFlyCnt().GetFrmFmt() == pFmt,
+                                            "Wrong TxtFlyCnt-Hint." );
+                                ((SwFmtFlyCnt&)pHnt->GetFlyCnt()).SetFlyFmt();
+
+                                //The connection is removed now the attribute can be deleted.
+                                pTxtNode->Delete( RES_TXTATR_FLYCNT, nIdx, nIdx );
+                                //create a new one 
+                                SwTxtNode *pNd = pInternalPam->GetNode()->GetTxtNode();
+                                DBG_ASSERT( pNd, "Crsr steht nicht auf TxtNode." );
+                                pNd->InsertItem( SwFmtFlyCnt( pFmt ),
+                                                pInternalPam->GetPoint()->nContent.GetIndex(), 0 );
+                            }    
+                            else
+                            {
                             aAnchor.SetAnchor( pInternalPam->GetPoint() );
                             aSet.Put(aAnchor);
                             pFmt->SetAttr(aSet);
                         }
+                        }
                         else
                         {
                             throw uno::RuntimeException();
@@ -1254,6 +1295,77 @@ void SwXShape::setPropertyValue(const rt
                 else
 				{
 					aPropSet.setPropertyValue(*pMap, aValue, aSet);
+                    
+                    if(RES_ANCHOR == pMap->nWID && MID_ANCHOR_ANCHORTYPE == pMap->nMemberId)
+                    {
+                        bool bSetAttr = true;
+                        sal_Int32 eNewAnchor = SWUnoHelper::GetEnumAsInt32( aValue );
+
+                        //if old anchor was in_cntnt the related text attribute has to be removed
+                        const SwFmtAnchor& rOldAnchor = pFmt->GetAnchor();
+                        RndStdIds eOldAnchorId = rOldAnchor.GetAnchorId();
+                        SdrObject* pObj = pFmt->FindSdrObject();
+                        SwFrmFmt *pFlyFmt = FindFrmFmt( pObj );
+                        pFlyFmt->DelFrms();
+                        if( text::TextContentAnchorType_AS_CHARACTER != eNewAnchor && 
+                            FLY_IN_CNTNT == eOldAnchorId )
+                        {
+                            //With AnchorAsCharacter the current TxtAttribute has to be deleted.
+                            //Tbis removes the frame format too.
+                            //To prevent this the connection between format and attribute has to be broken before.
+                            const SwPosition *pPos = rOldAnchor.GetCntntAnchor();
+                            SwTxtNode *pTxtNode = pPos->nNode.GetNode().GetTxtNode();
+                            ASSERT( pTxtNode->HasHints(), "Missing FlyInCnt-Hint." );
+                            const xub_StrLen nIdx = pPos->nContent.GetIndex();
+                            SwTxtAttr * pHnt = pTxtNode->GetTxtAttr( nIdx, RES_TXTATR_FLYCNT );
+                            DBG_ASSERT( pHnt && pHnt->Which() == RES_TXTATR_FLYCNT,
+                                        "Missing FlyInCnt-Hint." );
+                            DBG_ASSERT( pHnt && pHnt->GetFlyCnt().GetFrmFmt() == pFlyFmt,
+                                        "Wrong TxtFlyCnt-Hint." );
+                            ((SwFmtFlyCnt&)pHnt->GetFlyCnt()).SetFlyFmt();
+
+                            //The connection is removed now the attribute can be deleted.
+                            pTxtNode->Delete( RES_TXTATR_FLYCNT, nIdx, nIdx );
+                        }
+                        else if( text::TextContentAnchorType_AT_PAGE != eNewAnchor &&
+                                FLY_PAGE == eOldAnchorId )
+                        {
+                            SwFmtAnchor aNewAnchor( dynamic_cast< const SwFmtAnchor& >( aSet.Get( RES_ANCHOR ) ) );
+                            //if the fly has been anchored at page then it needs to be connected 
+                            //to the content position
+                            SwPaM aPam(pDoc->GetNodes().GetEndOfContent());
+                            if( pDoc->GetRootFrm() )
+                            {
+                                SwCrsrMoveState aState( MV_SETONLYTEXT );
+                                Point aTmp( pObj->GetSnapRect().TopLeft() );
+                                pDoc->GetRootFrm()->GetCrsrOfst( aPam.GetPoint(), aTmp, &aState );
+                            }
+                            else 
+                            {
+                                //without access to the layout the last node of the body will be used as anchor position
+                                aPam.Move( fnMoveBackward, fnGoDoc );
+                            }
+                            //anchor position has to be inserted after the text attribute has been inserted
+                            aNewAnchor.SetAnchor( aPam.GetPoint() );
+                            aSet.Put( aNewAnchor );
+                            pFmt->SetAttr(aSet);
+                            bSetAttr = false;
+                            if( text::TextContentAnchorType_AS_CHARACTER == eNewAnchor && 
+                                FLY_IN_CNTNT != eOldAnchorId )
+                            {
+                                //the RES_TXTATR_FLYCNT needs to be added now
+                                SwTxtNode *pNd = aPam.GetNode()->GetTxtNode();
+                                DBG_ASSERT( pNd, "Crsr is not in a TxtNode." );
+                                pNd->InsertItem( SwFmtFlyCnt( pFlyFmt ),
+                                                aPam.GetPoint()->nContent.GetIndex(), 0 );
+                                //aPam.GetPoint()->nContent--;
+                                
+                            }    
+                        }
+                        if( bSetAttr )
+                            pFmt->SetAttr(aSet);
+                    }
+                    else    
 					pFmt->SetAttr(aSet);
 				}
 			}
--- sw/source/core/unocore/unotbl.cxx	10 Jan 2008 12:31:03 -0000	1.113
+++ sw/source/core/unocore/unotbl.cxx	22 Jan 2008 13:08:49 -0000	1.113.2.1
@@ -769,6 +769,9 @@ void lcl_SetTblSeparators(const uno::Any
 
 	pTable->GetTabCols( aOldCols, pBox, sal_False, bRow );
 	sal_uInt16 nOldCount = aOldCols.Count();
+    //there's no use in setting tab cols if there's only one column
+    if( !nOldCount )
+        return;
 
 	const uno::Sequence< text::TableColumnSeparator>* pSepSeq =
 				(uno::Sequence< text::TableColumnSeparator>*) rVal.getValue();
--- sw/source/core/unocore/unotext.cxx	10 Jan 2008 12:31:16 -0000	1.35
+++ sw/source/core/unocore/unotext.cxx	22 Jan 2008 13:10:53 -0000	1.35.2.1
@@ -1674,6 +1674,26 @@ uno::Reference< text::XTextContent > SwX
    if(SwXTextRange::XTextRangeToSwPaM(aStartPam, xStart) &&
         SwXTextRange::XTextRangeToSwPaM(*pEndPam, xEnd) )
     {
+        uno::Reference<lang::XUnoTunnel> xStartRangeTunnel( xStart, uno::UNO_QUERY);
+        SwXTextRange* pStartRange  = reinterpret_cast< SwXTextRange * >(
+                   sal::static_int_cast< sal_IntPtr >( xStartRangeTunnel->getSomething( SwXTextRange::getUnoTunnelId()) ));
+        uno::Reference<lang::XUnoTunnel> xEndRangeTunnel( xEnd, uno::UNO_QUERY);
+        SwXTextRange* pEndRange  = reinterpret_cast< SwXTextRange * >(
+                   sal::static_int_cast< sal_IntPtr >( xEndRangeTunnel->getSomething( SwXTextRange::getUnoTunnelId()) ));
+        //bokmarks have to be removed before the referenced text node is deleted in DelFullPara
+        if( pStartRange )
+        {
+            SwBookmark* pStartBookmark = pStartRange->GetBookmark();
+            if( pStartBookmark )
+                pDoc->deleteBookmark( pStartBookmark->GetName() );
+        }   
+        if( pEndRange )
+        {
+            SwBookmark* pEndBookmark = pEndRange->GetBookmark();
+            if( pEndBookmark )
+                pDoc->deleteBookmark( pEndBookmark->GetName() );
+        }   
+       
        pDoc->StartUndo( UNDO_START, NULL );
         bool bIllegalException = false;
         bool bRuntimeException = false;
@@ -1708,8 +1728,34 @@ uno::Reference< text::XTextContent > SwX
             for(sal_Int32 nProp = 0; nProp < rFrameProperties.getLength(); ++nProp)
                 pNewFrame->SwXFrame::setPropertyValue(pValues[nProp].Name, pValues[nProp].Value);
 
+            {//has to be in a block to remove the SwIndexes before DelFullPara is called    
             uno::Reference< text::XTextRange> xInsertTextRange = new SwXTextRange(aStartPam, this);
             pNewFrame->attach( xInsertTextRange );
+                pNewFrame->setName(pDoc->GetUniqueFrameName());
+            }
+            
+            if( !aStartPam.GetTxt().Len() )
+            {
+                
+                bool bMoved = false;
+                {//has to be in a block to remove the SwIndexes before DelFullPara is called    
+                    SwPaM aMovePam( *aStartPam.GetNode() );
+                    if( aMovePam.Move( fnMoveForward, fnGoCntnt ) )
+                    {
+                        //move the anchor to the next paragraph
+                        SwFmtAnchor aNewAnchor( pNewFrame->GetFrmFmt()->GetAnchor() );
+                        aNewAnchor.SetAnchor( aMovePam.Start() );
+                        pDoc->SetAttr( aNewAnchor, *pNewFrame->GetFrmFmt() );
+                    }
+                    bMoved = true;
+                }
+                if(bMoved)
+                {
+                    aStartPam.DeleteMark();
+//                    SwPaM aDelPam( *aStartPam.GetNode() );
+                    pDoc->DelFullPara(aStartPam/*aDelPam*/);
+                }
+            }
         }
         catch( lang::IllegalArgumentException& rIllegal )
         {
