cvs diff: Diffing automation
cvs diff: Diffing automation/inc
cvs diff: Diffing automation/inc/automation
cvs diff: Diffing automation/inc/pch
cvs diff: Diffing automation/packimages
cvs diff: Diffing automation/prj
cvs diff: Diffing automation/source
cvs diff: Diffing automation/source/app
cvs diff: Diffing automation/source/communi
cvs diff: Diffing automation/source/inc
cvs diff: Diffing automation/source/miniapp
cvs diff: Diffing automation/source/mozillaserver
cvs diff: Diffing automation/source/server
cvs diff: Diffing automation/source/simplecm
cvs diff: Diffing automation/source/testtool
Index: automation/source/testtool/objtest.cxx
===================================================================
RCS file: /cvs/util/automation/source/testtool/objtest.cxx,v
retrieving revision 1.36
retrieving revision 1.36.6.1
diff -u -u -p -b -w -B -r1.36 -r1.36.6.1
--- automation/source/testtool/objtest.cxx	26 Nov 2007 17:59:36 -0000	1.36
+++ automation/source/testtool/objtest.cxx	8 Jan 2008 08:25:51 -0000	1.36.6.1
@@ -542,6 +542,8 @@ void TestToolObj::LoadIniFile()				// La
     abGP.Append( "18" );  // Linux MIPS
 #elif defined LINUX && defined ARM
     abGP.Append( "19" );  // Linux ARM
+#elif defined LINUX && defined IA64
+    abGP.Append( "20" );  // Linux ia64
 #else
 #error ("unknown platform. please request an ID for your platform on qa/dev")
 #endif
cvs diff: Diffing automation/util
cvs diff: Diffing automation/util/defs
cvs diff: Diffing solenv
cvs diff: Diffing solenv/bin
cvs diff: Diffing solenv/bin/modules
cvs diff: Diffing solenv/bin/modules/PCVSLib
cvs diff: Diffing solenv/bin/modules/PCVSLib/lib
cvs diff: Diffing solenv/bin/modules/PCVSLib/lib/PCVSLib
cvs diff: Diffing solenv/bin/modules/PCVSLib/samples
cvs diff: Diffing solenv/bin/modules/PCVSLib/t
cvs diff: Diffing solenv/bin/modules/installer
cvs diff: Diffing solenv/bin/modules/installer/windows
cvs diff: Diffing solenv/bin/modules/packager
cvs diff: Diffing solenv/bin/modules/par2script
cvs diff: Diffing solenv/bin/modules/pre2par
cvs diff: Diffing solenv/config
cvs diff: Diffing solenv/inc
Index: solenv/inc/unx.mk
===================================================================
RCS file: /cvs/tools/solenv/inc/unx.mk,v
retrieving revision 1.35
retrieving revision 1.35.92.1
diff -u -u -p -b -w -B -r1.35 -r1.35.92.1
--- solenv/inc/unx.mk	2 Nov 2007 15:20:22 -0000	1.35
+++ solenv/inc/unx.mk	4 Jan 2008 18:52:35 -0000	1.35.92.1
@@ -131,6 +131,10 @@
 .INCLUDE : unxlngr.mk
 .ENDIF
 
+.IF "$(COM)$(OS)$(CPU)$(GLIBC)" == "GCCLINUXA2REDHAT60"
+.INCLUDE : unxlnga.mk
+.ENDIF
+
 .IF "$(COM)$(OS)$(CPU)" == "ACCHPUXR"
 .INCLUDE : unxhpxr.mk
 .ENDIF
Index: solenv/inc/unxlnga.mk
===================================================================
RCS file: solenv/inc/unxlnga.mk
diff -N solenv/inc/unxlnga.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ solenv/inc/unxlnga.mk	26 Feb 2008 16:23:14 -0000	1.1.2.2
@@ -0,0 +1,232 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+# mk file for unxlnga
+ASM=
+AFLAGS=
+
+SOLAR_JAVA*=
+JAVAFLAGSDEBUG=-g
+
+# filter for supressing verbose messages from linker
+#not needed at the moment
+#LINKOUTPUT_FILTER=" |& $(SOLARENV)$/bin$/msg_filter"
+
+# _PTHREADS is needed for the stl
+CDEFS+=$(PTHREAD_CFLAGS) -DGLIBC=2 -DIA64 -D_PTHREADS -D_REENTRANT -DNEW_SOLAR -D_USE_NAMESPACE=1 -DSTLPORT_VERSION=400
+
+# enable visibility define in "sal/types.h"
+.IF "$(HAVE_GCC_VISIBILITY_FEATURE)" == "TRUE"
+CDEFS += -DHAVE_GCC_VISIBILITY_FEATURE
+.ENDIF # "$(HAVE_GCC_VISIBILITY_FEATURE)" == "TRUE"
+
+# this is a platform with JAVA support
+.IF "$(SOLAR_JAVA)"!=""
+JAVADEF=-DSOLAR_JAVA
+.IF "$(debug)"==""
+JAVA_RUNTIME=-ljava
+.ELSE
+JAVA_RUNTIME=-ljava_g
+.ENDIF
+.ENDIF
+
+# architecture dependent flags for the C and C++ compiler that can be changed by
+# exporting the variable ARCH_FLAGS="..." in the shell, which is used to start build
+ARCH_FLAGS*=
+
+# name of C++ Compiler
+CXX*=g++
+# name of C Compiler
+CC*=gcc
+.IF "$(SYSBASE)"!=""
+CFLAGS_SYSBASE:=-isystem $(SYSBASE)$/usr$/include
+CXX+:=$(CFLAGS_SYSBASE)
+CC+:=$(CFLAGS_SYSBASE)
+.ENDIF          # "$(SYSBASE)"!=""
+CFLAGS+=-Wreturn-type -fmessage-length=0 -c
+# flags to enable build with symbols; required for crashdump feature
+.IF "$(ENABLE_SYMBOLS)"=="SMALL"
+CFLAGSENABLESYMBOLS=-g1
+.ELSE
+CFLAGSENABLESYMBOLS=-g # was temporarily commented out, reenabled before Beta
+
+.ENDIF
+.IF "$(HAVE_LD_HASH_STYLE)"  == "TRUE"
+LINKFLAGS += -Wl,--hash-style=both
+.ELSE
+LINKFLAGS += -Wl,-zdynsort
+.ENDIF
+
+# flags for the C++ Compiler
+CFLAGSCC= -pipe $(ARCH_FLAGS)
+# Flags for enabling exception handling
+CFLAGSEXCEPTIONS=-fexceptions -fno-enforce-eh-specs
+# Flags for disabling exception handling
+CFLAGS_NO_EXCEPTIONS=-fno-exceptions
+
+# -fpermissive should be removed as soon as possible
+CFLAGSCXX= -pipe $(ARCH_FLAGS)
+CFLAGSCXX+= -Wno-ctor-dtor-privacy
+CFLAGSCXX+= -fno-use-cxa-atexit
+PICSWITCH:=-fpic
+.IF "$(HAVE_GCC_VISIBILITY_FEATURE)" == "TRUE"
+CFLAGSCXX += -fvisibility-inlines-hidden
+.ENDIF # "$(HAVE_GCC_VISIBILITY_FEATURE)" == "TRUE"
+
+# Compiler flags for compiling static object in multi threaded environment with graphical user interface
+CFLAGSOBJGUIMT=
+# Compiler flags for compiling static object in multi threaded environment with character user interface
+CFLAGSOBJCUIMT=
+# Compiler flags for compiling shared object in multi threaded environment with graphical user interface
+CFLAGSSLOGUIMT=$(PICSWITCH)
+# Compiler flags for compiling shared object in multi threaded environment with character user interface
+CFLAGSSLOCUIMT=$(PICSWITCH)
+# Compiler flags for profiling
+CFLAGSPROF=
+# Compiler flags for debugging
+CFLAGSDEBUG=-g
+CFLAGSDBGUTIL=
+# Compiler flags for enabling optimizations
+.IF "$(PRODUCT)"!=""
+CFLAGSOPT=-O2 -fno-strict-aliasing		# optimizing for products
+CFLAGSOPT+=-Wuninitialized				# not supported without optimization
+.ELSE 	# "$(PRODUCT)"!=""
+CFLAGSOPT=   							# no optimizing for non products
+.ENDIF	# "$(PRODUCT)"!=""
+# Compiler flags for disabling optimizations
+CFLAGSNOOPT=-O0
+# Compiler flags for describing the output path
+CFLAGSOUTOBJ=-o
+
+# -Wshadow does not work for C with nested uses of pthread_cleanup_push:
+CFLAGSWARNCC=-Wall -Wextra -Wendif-labels
+CFLAGSWARNCXX=$(CFLAGSWARNCC) -Wshadow -Wno-ctor-dtor-privacy \
+    -Wno-non-virtual-dtor
+CFLAGSWALLCC=$(CFLAGSWARNCC)
+CFLAGSWALLCXX=$(CFLAGSWARNCXX)
+CFLAGSWERRCC=-Werror
+
+# Once all modules on this platform compile without warnings, set
+# COMPILER_WARN_ERRORS=TRUE here instead of setting MODULES_WITH_WARNINGS (see
+# settings.mk):
+
+MODULES_WITH_WARNINGS := \
+    extensions \
+    soldep \
+    slideshow \
+    svtools \
+    svx
+
+# switches for dynamic and static linking
+STATIC		= -Wl,-Bstatic
+DYNAMIC		= -Wl,-Bdynamic
+
+# name of linker
+LINK*=$(CXX)
+LINKC*=$(CC)
+
+# default linker flags
+LINKFLAGSDEFS*=-Wl,-z,defs
+LINKFLAGSRUNPATH_URELIB=-Wl,-rpath,\''$$ORIGIN'\'
+LINKFLAGSRUNPATH_UREBIN=-Wl,-rpath,\''$$ORIGIN/../lib:$$ORIGIN'\'
+    #TODO: drop $ORIGIN once no URE executable is also shipped in OOo
+LINKFLAGSRUNPATH_OOO=-Wl,-rpath,\''$$ORIGIN:$$ORIGIN/../ure-link/lib'\'
+LINKFLAGSRUNPATH_BRAND=-Wl,-rpath,\''$$ORIGIN:$$ORIGIN/../basis-link/program:$$ORIGIN/../basis-link/ure-link/lib'\'
+LINKFLAGSRUNPATH_OXT=
+LINKFLAGS=-Wl,-z,combreloc $(LINKFLAGSDEFS)
+
+# linker flags for linking applications
+LINKFLAGSAPPGUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+LINKFLAGSAPPCUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+
+# linker flags for linking shared libraries
+LINKFLAGSSHLGUI= -shared
+LINKFLAGSSHLCUI= -shared
+
+LINKFLAGSTACK=
+LINKFLAGSPROF=
+LINKFLAGSDEBUG=-g
+LINKFLAGSOPT=
+
+# linker flags for optimization (symbol hashtable)
+# for now, applied to symbol scoped libraries, only
+LINKFLAGSOPTIMIZE*=-Wl,-O1
+LINKVERSIONMAPFLAG=$(LINKFLAGSOPTIMIZE) -Wl,--version-script
+
+SONAME_SWITCH=-Wl,-h
+
+# Sequence of libs does matter !
+
+STDLIBCPP=-lstdc++
+
+# default objectfilenames to link
+STDOBJVCL=$(L)$/salmain.o
+STDOBJGUI=
+STDSLOGUI=
+STDOBJCUI=
+STDSLOCUI=
+
+# libraries for linking applications
+STDLIBGUIMT+=-lX11 -ldl -lpthread -lm
+STDLIBCUIMT+=-ldl -lpthread -lm
+# libraries for linking shared libraries
+STDSHLGUIMT+=-lX11 -lXext -ldl -lpthread -lm
+STDSHLCUIMT+=-ldl -lpthread -lm
+
+LIBSALCPPRT*=-Wl,--whole-archive -lsalcpprt -Wl,--no-whole-archive
+
+# name of library manager
+LIBMGR=ar
+LIBFLAGS=-r
+
+# tool for generating import libraries
+IMPLIB=
+IMPLIBFLAGS=
+
+MAPSYM=
+MAPSYMFLAGS=
+
+RC=irc
+RCFLAGS=-fo$@ $(RCFILES)
+RCLINK=
+RCLINKFLAGS=
+RCSETVERSION=
+
+# platform specific identifier for shared libs
+DLLPOSTFIX=la
+DLLPRE=lib
+DLLPOST=.so
+PCHPOST=.gch
+
cvs diff: Diffing solenv/inc/startup
cvs diff: Diffing solenv/inc/startup/AIX
cvs diff: Diffing solenv/inc/startup/FREEBSD
cvs diff: Diffing solenv/inc/startup/HPUX
cvs diff: Diffing solenv/inc/startup/IRIX
cvs diff: Diffing solenv/inc/startup/LINUX
cvs diff: Diffing solenv/inc/startup/MACOSX
cvs diff: Diffing solenv/inc/startup/NETBSD
cvs diff: Diffing solenv/inc/startup/SOLARIS
cvs diff: Diffing solenv/inc/startup/UNIX
cvs diff: Diffing solenv/inc/startup/wnt
cvs diff: Diffing solenv/prj
cvs diff: Diffing solenv/src
cvs diff: Diffing solenv/unxmacxp
cvs diff: Diffing solenv/unxmacxp/inc
cvs diff: Diffing tools
cvs diff: Diffing tools/bootstrp
cvs diff: Diffing tools/bootstrp/addexes
cvs diff: Diffing tools/bootstrp/addexes2
cvs diff: Diffing tools/inc
cvs diff: Diffing tools/inc/bootstrp
cvs diff: Diffing tools/inc/pch
cvs diff: Diffing tools/inc/tools
Index: tools/inc/tools/solar.h
===================================================================
RCS file: /cvs/util/tools/inc/tools/solar.h,v
retrieving revision 1.5
retrieving revision 1.5.44.2
diff -u -u -p -b -w -B -r1.5 -r1.5.44.2
--- tools/inc/tools/solar.h	2 Nov 2007 13:00:07 -0000	1.5
+++ tools/inc/tools/solar.h	21 Feb 2008 13:32:27 -0000	1.5.44.2
@@ -388,6 +388,12 @@ template<typename T> inline T Abs(T a) {
   #define __DLLEXTENSION "ls.so"
 #elif defined LINUX && defined __x86_64__
   #define __DLLEXTENSION "lx.so"
+#elif defined LINUX && defined MIPS
+  #define __DLLEXTENSION "lm.so"
+#elif defined LINUX && defined IA64
+  #define __DLLEXTENSION "la.so"
+#elif defined LINUX
+  #error unknown plattform
 #elif defined FREEBSD && defined X86
   #define __DLLEXTENSION "fi.so"
 #elif defined FREEBSD && defined X86_64
cvs diff: Diffing tools/prj
cvs diff: Diffing tools/source
cvs diff: Diffing tools/source/communi
cvs diff: Diffing tools/source/datetime
cvs diff: Diffing tools/source/debug
cvs diff: Diffing tools/source/fsys
cvs diff: Diffing tools/source/generic
cvs diff: Diffing tools/source/inet
cvs diff: Diffing tools/source/memtools
cvs diff: Diffing tools/source/misc
cvs diff: Diffing tools/source/rc
cvs diff: Diffing tools/source/ref
cvs diff: Diffing tools/source/solar
cvs diff: Diffing tools/source/stream
cvs diff: Diffing tools/source/string
cvs diff: Diffing tools/source/testtoolloader
cvs diff: Diffing tools/source/zcodec
cvs diff: Diffing tools/test
cvs diff: Diffing tools/unx
cvs diff: Diffing tools/unx/source
cvs diff: Diffing tools/unx/source/dll
cvs diff: Diffing tools/util
cvs diff: Diffing tools/util/defs
cvs diff: Diffing tools/win
cvs diff: Diffing tools/win/inc
cvs diff: Diffing tools/win/source
cvs diff: Diffing tools/win/source/dll
cvs diff: Diffing tools/win/source/fastfsys
cvs diff: Diffing tools/workben
cvs diff: Diffing bridges
cvs diff: Diffing bridges/inc
cvs diff: Diffing bridges/inc/bridges
cvs diff: Diffing bridges/inc/bridges/cpp_uno
cvs diff: Diffing bridges/inc/bridges/cpp_uno/shared
Index: bridges/inc/bridges/cpp_uno/shared/cppinterfaceproxy.hxx
===================================================================
RCS file: /cvs/udk/bridges/inc/bridges/cpp_uno/shared/cppinterfaceproxy.hxx,v
retrieving revision 1.4
retrieving revision 1.4.104.1
diff -u -u -p -b -w -B -r1.4 -r1.4.104.1
--- bridges/inc/bridges/cpp_uno/shared/cppinterfaceproxy.hxx	19 Jun 2006 23:38:14 -0000	1.4
+++ bridges/inc/bridges/cpp_uno/shared/cppinterfaceproxy.hxx	18 Feb 2008 10:40:36 -0000	1.4.104.1
@@ -42,6 +42,7 @@
 #include "typelib/typedescription.h"
 #include "uno/dispatcher.h"
 #include "uno/environment.h"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
 
 namespace com { namespace sun { namespace star { namespace uno {
     class XInterface;
@@ -102,7 +103,7 @@ private:
     typelib_InterfaceTypeDescription * pTypeDescr;
     rtl::OUString oid;
 
-    void ** vtables[1];
+    VtableFactory::Slot * vtables[1];
 
     friend void SAL_CALL freeCppInterfaceProxy(
         uno_ExtEnvironment * pEnv, void * pInterface);
Index: bridges/inc/bridges/cpp_uno/shared/vtablefactory.hxx
===================================================================
RCS file: /cvs/udk/bridges/inc/bridges/cpp_uno/shared/vtablefactory.hxx,v
retrieving revision 1.5
retrieving revision 1.5.116.1
diff -u -u -p -b -w -B -r1.5 -r1.5.116.1
--- bridges/inc/bridges/cpp_uno/shared/vtablefactory.hxx	2 May 2006 11:59:11 -0000	1.5
+++ bridges/inc/bridges/cpp_uno/shared/vtablefactory.hxx	18 Feb 2008 10:40:36 -0000	1.5.116.1
@@ -50,6 +50,12 @@ namespace bridges { namespace cpp_uno { 
  */
 class VtableFactory {
 public:
+    // This structure is not defined in the generic part, but instead has to be
+    // defined individually for each CPP--UNO bridge:
+    /** A vtable slot.
+     */
+    struct Slot;
+
     /** A raw vtable block.
      */
     struct Block {
@@ -99,7 +105,7 @@ public:
     // defined individually for each CPP--UNO bridge:
     /** Given a pointer to a block, turn it into a vtable pointer.
      */
-    static void ** mapBlockToVtable(void * block);
+    static Slot * mapBlockToVtable(void * block);
 
 private:
     class GuardedBlocks;
@@ -133,11 +139,10 @@ private:
     /** Initialize a raw vtable block.
 
         @param block  the start address of the raw vtable block
-        @return  a pointer to the first virtual function slot (minus any
-        platform-specific ones, like a pointer to a destructor) within the given
-        block
+        @param slotCount  the number of slots
+        @return  a pointer past the last vtable slot
      */
-    static void ** initializeBlock(void * block);
+    static Slot * initializeBlock(void * block, sal_Int32 slotCount);
 
     // This function is not defined in the generic part, but instead has to be
     // defined individually for each CPP--UNO bridge:
@@ -145,8 +150,10 @@ private:
         functions of a given interface type (and generate any necessary code
         snippets for them).
 
-        @param slots  points to the first vtable slot to be filled with the
-        first virtual function local to the given type
+        @param slots  on input, points past the vtable slot to be filled with
+        the last virtual function local to the given type; on output, points to
+        the vtable slot filled with the first virtual function local to the
+        given type
         @param code  points to the start of the area where code snippets can be
         generated
         @param type  the interface type description for which to generate vtable
@@ -162,7 +169,7 @@ private:
         @return  a pointer to the remaining code snippet area
      */
     static unsigned char * addLocalFunctions(
-        void ** slots, unsigned char * code,
+        Slot ** slots, unsigned char * code,
         typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
         sal_Int32 functionCount, sal_Int32 vtableOffset);
 
cvs diff: Diffing bridges/inc/bridges/remote
cvs diff: Diffing bridges/inc/pch
cvs diff: Diffing bridges/prj
Index: bridges/prj/build.lst
===================================================================
RCS file: /cvs/udk/bridges/prj/build.lst,v
retrieving revision 1.44
retrieving revision 1.44.8.1
diff -u -u -p -b -w -B -r1.44 -r1.44.8.1
--- bridges/prj/build.lst	26 Nov 2007 18:01:08 -0000	1.44
+++ bridges/prj/build.lst	4 Jan 2008 19:09:57 -0000	1.44.8.1
@@ -18,6 +18,7 @@ br	bridges\source\cpp_uno\gcc3_linux_mip
 br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared br_inc NULL
 br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gccl3r br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gccl3a br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_macosx_intel			nmake	-	u	br_gcc3macoxi br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\gcc3_macosx_powerpc			nmake	-	u	br_gcc3macoxp br_cppuno_shared br_unotypes br_inc NULL
 br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes br_cppuno_shared br_inc NULL
cvs diff: Diffing bridges/source
cvs diff: Diffing bridges/source/cpp_uno
cvs diff: Diffing bridges/source/cpp_uno/cc50_solaris_intel
Index: bridges/source/cpp_uno/cc50_solaris_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/cc50_solaris_intel/cpp2uno.cxx,v
retrieving revision 1.15
retrieving revision 1.15.82.1
diff -u -u -p -b -w -B -r1.15 -r1.15.82.1
--- bridges/source/cpp_uno/cc50_solaris_intel/cpp2uno.cxx	16 Sep 2006 15:43:28 -0000	1.15
+++ bridges/source/cpp_uno/cc50_solaris_intel/cpp2uno.cxx	18 Feb 2008 11:14:12 -0000	1.15.82.1
@@ -460,30 +460,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
-{
-    return static_cast< void ** >(block) + 1;
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block) {
+    return static_cast< Slot * >(block) + 1;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 3) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 3) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block) + 2;
-    slots[-3] = 0; // RTTI
-    slots[-2] = 0; // null
-    slots[-1] = 0; // destructor
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block) + 2;
+    slots[-3].fn = 0; // RTTI
+    slots[-2].fn = 0; // null
+    slots[-1].fn = 0; // destructor
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -491,7 +498,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
@@ -501,13 +508,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, 0);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
cvs diff: Diffing bridges/source/cpp_uno/cc50_solaris_sparc
Index: bridges/source/cpp_uno/cc50_solaris_sparc/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/cc50_solaris_sparc/cpp2uno.cxx,v
retrieving revision 1.23
retrieving revision 1.23.42.1
diff -u -u -p -b -w -B -r1.23 -r1.23.42.1
--- bridges/source/cpp_uno/cc50_solaris_sparc/cpp2uno.cxx	14 Mar 2007 08:25:27 -0000	1.23
+++ bridges/source/cpp_uno/cc50_solaris_sparc/cpp2uno.cxx	18 Feb 2008 11:14:13 -0000	1.23.42.1
@@ -456,30 +456,38 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 1;
+    return static_cast< Slot * >(block) + 1;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 3) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 3) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block) + 2;
-    slots[-3] = 0; // RTTI
-    slots[-2] = 0; // null
-    slots[-1] = 0; // destructor
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block) + 2;
+    slots[-3].fn = 0; // RTTI
+    slots[-2].fn = 0; // null
+    slots[-1].fn = 0; // destructor
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -487,7 +495,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -499,13 +507,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_freebsd_intel
Index: bridges/source/cpp_uno/gcc3_freebsd_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_freebsd_intel/cpp2uno.cxx,v
retrieving revision 1.10
retrieving revision 1.10.32.1
diff -u -u -p -b -w -B -r1.10 -r1.10.32.1
--- bridges/source/cpp_uno/gcc3_freebsd_intel/cpp2uno.cxx	5 Jul 2007 08:59:35 -0000	1.10
+++ bridges/source/cpp_uno/gcc3_freebsd_intel/cpp2uno.cxx	18 Feb 2008 10:47:02 -0000	1.10.32.1
@@ -421,29 +421,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /*functionCount*/, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -451,7 +459,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
@@ -461,7 +469,7 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(
                     code, functionOffset++, vtableOffset,
                     typelib_TypeClass_VOID);
@@ -469,7 +477,7 @@ unsigned char * bridges::cpp_uno::shared
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_freebsd_x86-64
Index: bridges/source/cpp_uno/gcc3_freebsd_x86-64/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_freebsd_x86-64/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.82.1
diff -u -u -p -b -w -B -r1.3 -r1.3.82.1
--- bridges/source/cpp_uno/gcc3_freebsd_x86-64/cpp2uno.cxx	16 Sep 2006 15:46:37 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_freebsd_x86-64/cpp2uno.cxx	18 Feb 2008 10:47:02 -0000	1.3.82.1
@@ -465,35 +465,42 @@ unsigned char * codeSnippet( unsigned ch
 }
 
 //==================================================================================================
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable( void * block )
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-	return static_cast<void **>( block ) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 //==================================================================================================
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return ( slotCount + 2 ) * sizeof( void * ) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
 //==================================================================================================
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock( void * block )
-{
-	void ** slots = mapBlockToVtable( block );
-	slots[-2] = 0;
-	slots[-1] = 0;
-
-	return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 //==================================================================================================
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-	void ** slots, unsigned char * code,
+	Slot ** slots, unsigned char * code,
 	typelib_InterfaceTypeDescription const * type, sal_Int32 nFunctionOffset,
 	sal_Int32 functionCount, sal_Int32 nVtableOffset )
 {
+	(*slots) -= functionCount;
+	Slot * s = *slots;
+
 	for ( sal_Int32 nPos = 0; nPos < type->nMembers; ++nPos )
 	{
 		typelib_TypeDescription * pTD = 0;
@@ -507,14 +514,14 @@ unsigned char * bridges::cpp_uno::shared
 				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( pTD );
 
 			// get method
-			*slots++ = code;
+			(s++)->fn = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
 								x86_64::return_in_hidden_param( pAttrTD->pAttributeTypeRef ) );
 
 			if ( ! pAttrTD->bReadOnly )
 			{
 				// set method
-				*slots++ = code;
+				(s++)->fn = code;
 				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, false );
 			}
 		}
@@ -523,7 +530,7 @@ unsigned char * bridges::cpp_uno::shared
 			typelib_InterfaceMethodTypeDescription *pMethodTD =
 				reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( pTD );
 			
-			*slots++ = code;
+			(s++)->fn = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
 								x86_64::return_in_hidden_param( pMethodTD->pReturnTypeRef ) );
 		}
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_arm
Index: bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.6.1
diff -u -u -p -b -w -B -r1.3 -r1.3.6.1
--- bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx	12 Dec 2007 15:34:25 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx	18 Feb 2008 10:40:36 -0000	1.3.6.1
@@ -447,29 +447,37 @@ namespace
     }
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /*functionCount*/, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i)
     {
         typelib_TypeDescription * member = 0;
@@ -479,7 +487,7 @@ unsigned char * bridges::cpp_uno::shared
         {
             case typelib_TypeClass_INTERFACE_ATTRIBUTE:
                 // Getter:
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(
                     code, functionOffset++, vtableOffset,
                     bridges::cpp_uno::shared::isSimpleType(
@@ -491,14 +499,14 @@ unsigned char * bridges::cpp_uno::shared
                     typelib_InterfaceAttributeTypeDescription * >(
                         member)->bReadOnly)
                 {
-                    *slots++ = code;
+                    (s++)->fn = code;
                     code = codeSnippet(
                         code, functionOffset++, vtableOffset, true);
                 }
                 break;
             case typelib_TypeClass_INTERFACE_METHOD:
             {
-                *slots++ = code;
+                (s++)->fn = code;
 
                 typelib_InterfaceMethodTypeDescription *pMethodTD = 
                     reinterpret_cast<
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_ia64
Index: bridges/source/cpp_uno/gcc3_linux_ia64/call.s
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/call.s
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/call.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/call.s	15 Feb 2008 17:36:55 -0000	1.1.2.2
@@ -0,0 +1,20 @@
+/* ia64 support code for OpenOffice C++/UNO bridging
+ *
+ * Caolan McNamara <caolanm@redhat.com>
+ */
+	.text
+	.align 16
+	.global privateSnippetExecutor#
+	.proc privateSnippetExecutor#
+privateSnippetExecutor:
+	adds r15 = 8, gp	/* r15 now points to real gp value*/
+	;;
+	ld8 r14 = [gp]		/* load nOffsetAndIndex into a handy register */
+	ld8 gp = [r15]		/* load real gp value into gp */
+	;;
+	/* store the address where large structs are "returned" into a handy register */
+	mov r15 = r8
+	;;
+	br cpp_vtable_call#	/* call cpp_vtable_call which'll suck out r14 */
+	;;
+	.endp privateSnippetExecutor#
Index: bridges/source/cpp_uno/gcc3_linux_ia64/cpp2uno.cxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/cpp2uno.cxx
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/cpp2uno.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/cpp2uno.cxx	18 Feb 2008 10:40:37 -0000	1.1.2.3
@@ -0,0 +1,692 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
+
+#include "share.hxx"
+#include <stdio.h>
+
+extern "C" { extern void (*privateSnippetExecutor)(); }
+
+using namespace ::com::sun::star::uno;
+
+namespace
+{
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams, long r8, 
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr, "as far as cpp2uno_call\n");
+#endif
+
+    int ng = 0; //number of gpr registers used 
+    int nf = 0; //number of fpr regsiters used
+       
+    // gpreg:  [ret *], this, [gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if ( ia64::return_in_hidden_param( pReturnTypeRef ) ) // complex return via ptr passed as hidden parameter reg (pCppReturn)
+		{
+			pCppReturn = *(void **)gpreg;
+			gpreg++;
+			ng++;
+			
+			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+		else if ( ia64::return_via_r8_buffer( pReturnTypeRef ) ) // complex return via ptr passed in r8 
+		{
+			pCppReturn = (void *)r8;
+			
+			pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+
+		else
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+	}
+	// pop this
+    gpreg++; 
+    ng++;
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes = 0;
+	bool bOverFlowUsed = false;
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+#ifdef CMC_DEBUG
+		fprintf(stderr, "arg %d of %d\n", nPos, nParams);
+#endif
+
+		//I think it is impossible to get UNO to pass structs as parameters by copy
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) 
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "simple\n");
+#endif
+
+			switch (pParamTypeDescr->eTypeClass)
+			{
+				case typelib_TypeClass_FLOAT:
+					if (nf < ia64::MAX_SSE_REGS && ng < ia64::MAX_GPR_REGS)
+					{
+                        float tmp = (float) (*((double *)fpreg));
+                        (*((float *) fpreg)) = tmp;
+						pCppArgs[nPos] = pUnoArgs[nPos] = fpreg++;
+						nf++;
+                        gpreg++;
+                        ng++;
+					}
+					else
+                    {
+						pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+					break;
+				case typelib_TypeClass_DOUBLE:
+					if (nf < ia64::MAX_SSE_REGS && ng < ia64::MAX_GPR_REGS)
+					{
+						pCppArgs[nPos] = pUnoArgs[nPos] = fpreg++;
+						nf++;
+                        gpreg++;
+                        ng++;
+					}
+					else
+                    {
+						pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+					break;
+                case typelib_TypeClass_BYTE:
+                case typelib_TypeClass_BOOLEAN:
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_SHORT:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+		        case typelib_TypeClass_ENUM:
+                case typelib_TypeClass_LONG:
+                case typelib_TypeClass_UNSIGNED_LONG:
+				default:
+					if (ng < ia64::MAX_GPR_REGS) 
+					{
+						pCppArgs[nPos] = pUnoArgs[nPos] = gpreg++;
+						ng++;
+					}
+					else
+                    {
+						pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
+                        bOverFlowUsed = true;
+                    }
+                    if (bOverFlowUsed) ovrflw++;
+					break;
+		        }
+
+		        // no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "complex, ng is %d\n", ng);
+#endif
+            void *pCppStack; //temporary stack pointer
+
+			if (ng < ia64::MAX_GPR_REGS)
+			{ 
+		        pCppArgs[nPos] = pCppStack = *gpreg++;
+			    ng++;
+			}
+			else
+            {
+			    pCppArgs[nPos] = pCppStack = *ovrflw;
+                bOverFlowUsed = true;
+            }
+            if (bOverFlowUsed) ovrflw++;
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										pCppStack, pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+	}
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "end of params\n");
+#endif
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); 
+                // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										pThis->getBridge()->getUno2Cpp() );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to return reg
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = ia64::return_via_r8_buffer(pReturnTypeRef) ? typelib_TypeClass_VOID : (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_uInt64 nOffsetAndIndex,
+        void ** gpreg, void ** fpreg, long sp, long r8, 
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+    OSL_ENSURE( sizeof(sal_Int64)==sizeof(void *), "### unexpected!" );
+
+    sal_Int32 nVtableOffset = (nOffsetAndIndex >> 32);
+    sal_Int32 nFunctionIndex = (nOffsetAndIndex & 0xFFFFFFFF);
+
+    void ** ovrflw = (void**)(sp);
+	
+    // gpreg:  [ret *], this, [other gpr params]
+    // fpreg:  [fpr params]
+    // ovrflw: [gpr or fpr params (properly aligned)]
+
+    void * pThis;
+    if (nFunctionIndex & 0x80000000 )
+    {
+	nFunctionIndex &= 0x7fffffff;
+	pThis = gpreg[1];
+#ifdef CMC_DEBUG
+	fprintf(stderr, "pThis is gpreg[1]\n");
+#endif
+    }
+    else
+    {
+	pThis = gpreg[0];
+#ifdef CMC_DEBUG
+	fprintf(stderr, "pThis is gpreg[0]\n");
+#endif
+    }
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "pThis is %p\n", pThis);
+#endif
+    
+    pThis = static_cast< char * >(pThis) - nVtableOffset;
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "pThis is now %p\n", pThis);
+#endif
+
+    bridges::cpp_uno::shared::CppInterfaceProxy * pCppI
+	    = bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
+			pThis);
+
+    typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
+
+#ifdef CMC_DEBUG
+    fprintf(stderr, "indexes are %d %d\n", nFunctionIndex, pTypeDescr->nMapFunctionIndexToMemberIndex);
+#endif
+	
+	OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pThis );
+	}
+	
+	// determine called method
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "members are %d %d\n", nMemberPos, pTypeDescr->nAllMembers);
+#endif
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				r8, gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				r8, gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nFunctionIndex)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
+                    pCppI->getBridge()->getCppEnv(),
+                    (void **)&pInterface, pCppI->getOid().pData, 
+                    (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( gpreg[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = gpreg[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+			}
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				r8, gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+#ifdef CMC_DEBUG
+	    fprintf(stderr, "screwed\n");
+#endif
+
+		throw RuntimeException(
+            rtl::OUString::createFromAscii("no member description found!"),
+            (XInterface *)pThis );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+#ifdef CMC_DEBUG
+        fprintf(stderr, "end of cpp_mediate\n");
+#endif
+    return eRet;
+}
+}
+
+extern "C" ia64::RegReturn cpp_vtable_call(
+    long in0, long in1, long in2, long in3, long in4, long in5, long in6, long in7,
+    long firstonstack
+    )
+{
+    register long r15 asm("r15");
+    long r8 = r15;
+
+    register long r14 asm("r14");
+    long nOffsetAndIndex = r14;
+
+    long sp = (long)&firstonstack;
+
+    sal_uInt64 gpreg[ia64::MAX_GPR_REGS];
+    gpreg[0] = in0;
+    gpreg[1] = in1;
+    gpreg[2] = in2;
+    gpreg[3] = in3;
+    gpreg[4] = in4;
+    gpreg[5] = in5;
+    gpreg[6] = in6;
+    gpreg[7] = in7;
+
+    double fpreg[ia64::MAX_SSE_REGS];
+    register double f8  asm("f8");  fpreg[0] =  f8;
+    register double f9  asm("f9");  fpreg[1] =  f9;
+    register double f10 asm("f10"); fpreg[2] = f10;
+    register double f11 asm("f11"); fpreg[3] = f11;
+    register double f12 asm("f12"); fpreg[4] = f12;
+    register double f13 asm("f13"); fpreg[5] = f13;
+    register double f14 asm("f14"); fpreg[6] = f14;
+    register double f15 asm("f15"); fpreg[7] = f15;
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "cpp_vtable_call called with %lx\n", nOffsetAndIndex);
+	fprintf(stderr, "adump is %lx %lx %lx %lx %lx %lx %lx %lx\n", in0, in1, in2, in3, in4, in5, in6, in7);
+	fprintf(stderr, "bdump is %f %f %f %f %f %f %f %f\n", f8, f9, f10, f11, f12, f13, f14, f15);
+#endif
+
+    volatile long nRegReturn[4] = { 0 };
+
+    typelib_TypeClass aType =
+        cpp_mediate( nOffsetAndIndex, (void**)gpreg, (void**)fpreg, sp, r8, (sal_Int64*)&nRegReturn[0]);
+
+    ia64::RegReturn ret;
+    switch( aType )
+    {
+        case typelib_TypeClass_VOID:
+            break;
+        case typelib_TypeClass_BOOLEAN:
+        case typelib_TypeClass_BYTE:
+        case typelib_TypeClass_CHAR:
+        case typelib_TypeClass_UNSIGNED_SHORT:
+        case typelib_TypeClass_SHORT:
+        case typelib_TypeClass_ENUM:
+        case typelib_TypeClass_UNSIGNED_LONG:
+        case typelib_TypeClass_LONG:
+        case typelib_TypeClass_UNSIGNED_HYPER:
+        case typelib_TypeClass_HYPER:
+            ret.r8 = nRegReturn[0];
+            break;
+        case typelib_TypeClass_FLOAT:
+            asm volatile("ldfs f8=%0" : : "m"((*((float*)&nRegReturn))) : "f8");
+            break;
+        case typelib_TypeClass_DOUBLE:
+            asm volatile("ldfd f8=%0" : : "m"((*((double*)&nRegReturn))) : "f8");
+            break;
+        case typelib_TypeClass_STRUCT:
+	case typelib_TypeClass_EXCEPTION:
+	{
+            ret.r8 = nRegReturn[0];
+            ret.r9 = nRegReturn[1];
+            ret.r10 = nRegReturn[2];
+            ret.r11 = nRegReturn[3];
+            break;
+	}
+        default:
+	    break;
+    }
+    return ret;
+}
+
+namespace
+{
+const int codeSnippetSize = 40;
+
+bridges::cpp_uno::shared::VtableFactory::Slot codeSnippet( unsigned char * code, sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset, 
+                              bool bHasHiddenParam )
+{
+#ifdef CMC_DEBUG
+    fprintf(stderr, "size is %d\n", codeSnippetSize);
+    fprintf(stderr,"in codeSnippet functionIndex is %x\n", nFunctionIndex);
+    fprintf(stderr,"in codeSnippet vtableOffset is %x\n", nVtableOffset);
+#endif
+
+    sal_uInt64 nOffsetAndIndex = ( ( (sal_uInt64) nVtableOffset ) << 32 ) | ( (sal_uInt64) nFunctionIndex );
+
+    if ( bHasHiddenParam )
+        nOffsetAndIndex |= 0x80000000;
+
+    long *raw = (long *)code;
+
+    bridges::cpp_uno::shared::VtableFactory::Slot* destination = (bridges::cpp_uno::shared::VtableFactory::Slot*)cpp_vtable_call;
+
+    raw[0] = (long)&privateSnippetExecutor;
+    raw[1] = (long)&raw[2];
+    raw[2] = nOffsetAndIndex;
+    raw[3] = destination->gp_value;
+
+    return *(bridges::cpp_uno::shared::VtableFactory::Slot*)(code);
+}
+}
+
+void bridges::cpp_uno::shared::VtableFactory::flushCode(unsigned char const *, unsigned char const *)
+{
+}
+
+bridges::cpp_uno::shared::VtableFactory::Slot * bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+{
+    return static_cast< Slot * >(block) + 2;
+}
+
+
+sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
+    sal_Int32 slotCount)
+{
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
+}
+
+bridges::cpp_uno::shared::VtableFactory::Slot* bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    Slot foo = {0,0};
+    slots[-2] = foo;
+    slots[-1] = foo;
+    return slots + slotCount;
+}
+
+unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
+    Slot ** in_slots, unsigned char * code,
+    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
+{
+    (*in_slots) -= functionCount;
+    Slot * slots = *in_slots;
+#ifdef CMC_DEBUG
+    fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
+    fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
+#endif
+
+    for (sal_Int32 i = 0; i < type->nMembers; ++i) {
+        typelib_TypeDescription * member = 0;
+        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
+        OSL_ASSERT(member != 0);
+        switch (member->eTypeClass) {
+        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+            // Getter:
+            *slots++ = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                ia64::return_in_hidden_param(
+                    reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription * >(
+                        member)->pAttributeTypeRef));
+            code += codeSnippetSize;
+
+
+            // Setter:
+            if (!reinterpret_cast<
+                typelib_InterfaceAttributeTypeDescription * >(
+                    member)->bReadOnly)
+            {
+                *slots++ = codeSnippet(code, functionOffset++, vtableOffset, false);
+            	code += codeSnippetSize;
+            }
+            break;
+
+        case typelib_TypeClass_INTERFACE_METHOD:
+            *slots++ = codeSnippet(
+                code, functionOffset++, vtableOffset,
+                ia64::return_in_hidden_param(
+                    reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription * >(
+                        member)->pReturnTypeRef));
+            code += codeSnippetSize;
+            break;
+
+        default:
+            OSL_ASSERT(false);
+            break;
+        }
+        TYPELIB_DANGER_RELEASE(member);
+    }
+    return code;
+}
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: bridges/source/cpp_uno/gcc3_linux_ia64/except.cxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/except.cxx
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/except.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/except.cxx	15 Feb 2008 17:36:56 -0000	1.1.2.2
@@ -0,0 +1,294 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#if OSL_DEBUG_LEVEL > 1
+    char const * start = p;
+#endif
+
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
+    if (iRttiFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iRttiFind->second;
+    }
+
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: bridges/source/cpp_uno/gcc3_linux_ia64/makefile.mk
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/makefile.mk
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/makefile.mk	4 Jan 2008 19:09:57 -0000	1.1.2.1
@@ -0,0 +1,91 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)" == "GCCLINUXAgcc3"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+# In case someone enabled the non-standard -fomit-frame-pointer which does not
+# work with the .cxx sources in this directory:
+CFLAGSCXX += -fno-omit-frame-pointer
+
+NOOPTFILES= \
+	$(SLO)$/uno2cpp.obj \
+	$(SLO)$/cpp2uno.obj
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj		\
+	$(SLO)$/call.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= $(SLOFILES)
+SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+$(SLO)$/%.obj: %.s
+    $(CC) -c -o $(SLO)$/$(@:b).o $< -fpic ; touch $@
Index: bridges/source/cpp_uno/gcc3_linux_ia64/share.hxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/share.hxx
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/share.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/share.hxx	18 Feb 2008 10:40:37 -0000	1.1.2.3
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "uno/mapping.h"
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+#include "bridges/cpp_uno/shared/vtablefactory.hxx"
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+  void dummy_can_throw_anything( char const * );
+
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
+
+namespace ia64
+{
+    enum ia64limits { MAX_GPR_REGS = 8, MAX_SSE_REGS = 8, MAX_REG_SLOTS = 8 };
+
+    bool return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef );
+    bool return_via_r8_buffer( typelib_TypeDescriptionReference *pTypeRef );
+
+    struct RegReturn
+    {
+        long r8;
+        long r9;
+        long r10;
+        long r11;
+    };
+}
+
+namespace bridges
+{
+    namespace cpp_uno
+    {
+        namespace shared
+        {
+            /*
+                http://www.swag.uwaterloo.ca/asx/ABI.html
+                On Itanium, function pointers are pairs: the function address followed
+                by the global pointer value that should be used when calling the
+                function (code address, gp value)
+            */
+            struct VtableFactory::Slot
+            {
+                sal_uInt64 code_address;
+                sal_uInt64 gp_value;
+            };
+        }
+    }
+}
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: bridges/source/cpp_uno/gcc3_linux_ia64/uno2cpp.cxx
===================================================================
RCS file: bridges/source/cpp_uno/gcc3_linux_ia64/uno2cpp.cxx
diff -N bridges/source/cpp_uno/gcc3_linux_ia64/uno2cpp.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ bridges/source/cpp_uno/gcc3_linux_ia64/uno2cpp.cxx	15 Feb 2008 19:22:43 -0000	1.1.2.3
@@ -0,0 +1,673 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_bridges.hxx"
+
+#include <malloc.h>
+
+#include <com/sun/star/uno/genfunc.hxx>
+#include <uno/data.h>
+
+#include "bridges/cpp_uno/shared/bridge.hxx"
+#include "bridges/cpp_uno/shared/types.hxx"
+#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
+#include "bridges/cpp_uno/shared/vtables.hxx"
+
+#include "share.hxx"
+
+#include <stdio.h>
+#include <string.h>
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+void MapReturn(const ia64::RegReturn &rRet, double dret, typelib_TypeDescription * pReturnTypeDescr, bool bSimpleReturn, sal_uInt64 *pRegisterReturn)
+{
+    switch (pReturnTypeDescr->eTypeClass)
+    {
+    case typelib_TypeClass_HYPER:
+    case typelib_TypeClass_UNSIGNED_HYPER:
+    case typelib_TypeClass_LONG:
+    case typelib_TypeClass_UNSIGNED_LONG:
+    case typelib_TypeClass_ENUM:
+            *pRegisterReturn = rRet.r8;
+            break;
+    case typelib_TypeClass_CHAR:
+    case typelib_TypeClass_SHORT:
+    case typelib_TypeClass_UNSIGNED_SHORT:
+            *pRegisterReturn = (unsigned short)rRet.r8;
+            break;
+    case typelib_TypeClass_BOOLEAN:
+    case typelib_TypeClass_BYTE:
+            *pRegisterReturn = (unsigned char)rRet.r8;
+            break;
+    case typelib_TypeClass_FLOAT:
+            *reinterpret_cast<float *>( pRegisterReturn ) = dret;
+	    break;
+    case typelib_TypeClass_DOUBLE:
+            *reinterpret_cast<double *>( pRegisterReturn ) = dret;
+            break;
+    case typelib_TypeClass_STRUCT:
+    case typelib_TypeClass_EXCEPTION:
+        {
+            sal_uInt32 nRetSize = pReturnTypeDescr->nSize;
+            if (bSimpleReturn && nRetSize <= 32 && nRetSize > 0)
+                memcpy(pRegisterReturn, (void*)&rRet, nRetSize);
+            break;
+        }
+    default:
+	break;
+    }
+}
+
+namespace ia64
+{ 
+    bool is_complex_struct( typelib_TypeDescriptionReference *pTypeRef )
+    {
+        if (pTypeRef->eTypeClass == typelib_TypeClass_STRUCT || pTypeRef->eTypeClass == typelib_TypeClass_EXCEPTION)
+	{
+            typelib_TypeDescription * pTypeDescr = 0;
+            TYPELIB_DANGER_GET( &pTypeDescr, pTypeRef );
+
+            bool bRet = bridges::cpp_uno::shared::relatesToInterfaceType( pTypeDescr );
+            TYPELIB_DANGER_RELEASE( pTypeDescr );
+
+            return bRet;
+       }
+       return false;
+    }
+
+    bool return_via_r8_buffer( typelib_TypeDescriptionReference *pTypeRef )
+    {
+        if (pTypeRef->eTypeClass == typelib_TypeClass_STRUCT || pTypeRef->eTypeClass == typelib_TypeClass_EXCEPTION)
+	{
+            if (is_complex_struct( pTypeRef )) return false;
+
+            typelib_TypeDescription * pTypeDescr = 0;
+            TYPELIB_DANGER_GET( &pTypeDescr, pTypeRef );
+
+            /* If the struct is larger than 32 bytes, then there is a buffer at r8 to stick the return value into  */
+            bool bRet = pTypeDescr->nSize > 32;
+            TYPELIB_DANGER_RELEASE( pTypeDescr );
+            return bRet;
+       }
+       return false;
+    }
+
+    bool return_in_hidden_param( typelib_TypeDescriptionReference *pTypeRef )
+    {
+        if (bridges::cpp_uno::shared::isSimpleType(pTypeRef))
+            return false;
+        else if (pTypeRef->eTypeClass == typelib_TypeClass_STRUCT || pTypeRef->eTypeClass == typelib_TypeClass_EXCEPTION)
+            return is_complex_struct( pTypeRef );
+        return true;
+    }
+
+
+}
+
+namespace
+{
+//==================================================================================================
+static void callVirtualMethod(void * pThis, sal_uInt32 nVtableIndex, 
+	void * pRegisterReturn, typelib_TypeDescription * pReturnTypeDescr, bool bSimpleReturn,
+        sal_uInt64 *pStack, sal_uInt32 nStack,
+        sal_uInt64 *pGPR, sal_uInt32 nGPR,
+        double *pFPR, sal_uInt32 nFPR)
+{
+    // Stack, if used, must be 16-bytes aligned
+    if ( nStack )
+        nStack = ( nStack + 1 ) & ~1;
+
+    // Should not happen, but...
+    if ( nFPR > ia64::MAX_SSE_REGS )
+        nFPR = ia64::MAX_SSE_REGS;
+    if ( nGPR > ia64::MAX_GPR_REGS )
+        nGPR = ia64::MAX_GPR_REGS;
+
+#ifdef CMC_DEBUG
+        // Let's figure out what is really going on here
+        {
+                fprintf( stderr, "= callVirtualMethod() =\nGPR's (%d): ", nGPR );
+                for ( unsigned int i = 0; i < nGPR; ++i )
+                        fprintf( stderr, "0x%lx, ", pGPR[i] );
+                fprintf( stderr, "\nFPR's (%d): ", nFPR );
+                for ( unsigned int i = 0; i < nFPR; ++i ) 
+                        fprintf( stderr, "0x%lx (%f), ", pFPR[i], pFPR[i] );
+                fprintf( stderr, "\nStack (%d): ", nStack );
+                for ( unsigned int i = 0; i < nStack; ++i )
+                        fprintf( stderr, "0x%lx, ", pStack[i] );
+                fprintf( stderr, "\n" );
+		fprintf( stderr, "pRegisterReturn is %p\n", pRegisterReturn);
+        }
+#endif
+
+    // Load parameters to stack, if necessary
+    sal_uInt64 *stack = (sal_uInt64 *) __builtin_alloca( nStack * 8 );
+    memcpy( stack, pStack, nStack * 8 );
+
+    // To get pointer to method
+    // a) get the address of the vtable
+    sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
+    // b) get the address from the vtable entry at offset, each entry is 16bytes,
+    // 8 for function pointer, and 8 for global pointer
+    pMethod += 16 * nVtableIndex;
+
+    typedef void (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
+    FunctionCall pFunc = (FunctionCall)pMethod;
+
+    switch (nFPR) //deliberate fall through
+    {
+        case 8:
+            asm volatile("ldfd f15=%0" : : "m"(pFPR[7]) : "f15");
+        case 7:
+            asm volatile("ldfd f14=%0" : : "m"(pFPR[6]) : "f14");
+        case 6:
+            asm volatile("ldfd f13=%0" : : "m"(pFPR[5]) : "f13");
+        case 5:
+            asm volatile("ldfd f12=%0" : : "m"(pFPR[4]) : "f12");
+        case 4:
+            asm volatile("ldfd f11=%0" : : "m"(pFPR[3]) : "f11");
+        case 3:
+            asm volatile("ldfd f10=%0" : : "m"(pFPR[2]) : "f10");
+        case 2:
+            asm volatile("ldfd f9=%0" : : "m"(pFPR[1]) : "f9");
+        case 1:
+            asm volatile("ldfd f8=%0" : : "m"(pFPR[0]) : "f8");
+        default:
+            break;
+    }
+
+    //stick the return area into r8 for big struct returning
+    asm volatile("ld8 r8=%0" : : "m"(pRegisterReturn) : "r8");
+
+    (*pFunc)(pGPR[0], pGPR[1], pGPR[2], pGPR[3], pGPR[4], pGPR[5], pGPR[6], pGPR[7]);
+
+    register double f8 asm("f8");
+    ia64::RegReturn ret;
+    {
+        register long r8 asm("r8"); ret.r8 = r8;
+        register long r9 asm("r9"); ret.r9 = r9;
+        register long r10 asm("r10"); ret.r10 = r10;
+        register long r11 asm("r11"); ret.r11 = r11;
+    }
+   
+    MapReturn(ret, f8, pReturnTypeDescr, bSimpleReturn, (sal_uInt64*)pRegisterReturn);
+}
+
+// Macros for easier insertion of values to registers or stack
+// pSV - pointer to the source
+// nr - order of the value [will be increased if stored to register]
+// pFPR, pGPR - pointer to the registers
+// pDS - pointer to the stack [will be increased if stored here]
+
+// The value in %xmm register is already prepared to be retrieved as a float,
+// thus we treat float and double the same
+#define INSERT_FLOAT( pSV, nfr, pFPR, ngr, pGPR, pDS, bOverflow ) \
+        if ( nfr < ia64::MAX_SSE_REGS && ngr < ia64::MAX_GPR_REGS ) \
+                pFPR[nfr++] = *reinterpret_cast<float *>( pSV ); \
+        if ( ngr < ia64::MAX_GPR_REGS ) \
+                pGPR[ngr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+        else \
+        	bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
+
+#define INSERT_DOUBLE( pSV, nfr, pFPR, ngr, pGPR, pDS, bOverflow ) \
+        if ( nfr < ia64::MAX_SSE_REGS && ngr < ia64::MAX_GPR_REGS ) \
+                pFPR[nfr++] = *reinterpret_cast<double *>( pSV ); \
+        if ( ngr < ia64::MAX_GPR_REGS ) \
+                pGPR[ngr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+        else \
+        	bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
+
+#define INSERT_INT64( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ia64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
+        else \
+		bOverFlow = true; \
+	if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV );
+
+#define INSERT_INT32( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ia64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
+
+#define INSERT_INT16( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ia64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt16 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV );
+
+#define INSERT_INT8( pSV, nr, pGPR, pDS, bOverflow ) \
+        if ( nr < ia64::MAX_GPR_REGS ) \
+                pGPR[nr++] = *reinterpret_cast<sal_uInt8 *>( pSV ); \
+        else \
+                bOverFlow = true; \
+        if (bOverFlow) \
+                *pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV );
+
+//================================================================================================== 
+static void cpp_call(
+	bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
+	bridges::cpp_uno::shared::VtableSlot  aVtableSlot,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	sal_uInt64 * pStack = (sal_uInt64 *)alloca( (nParams+3) * sizeof(sal_Int64) );
+  	sal_uInt64 * pStackStart = pStack;
+
+	sal_uInt64 pGPR[ia64::MAX_GPR_REGS];
+	sal_uInt32 nGPR = 0;
+
+	double pFPR[ia64::MAX_SSE_REGS];
+	sal_uInt32 nFPR = 0;
+	
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+
+        bool bOverFlow = false;
+
+	bool bSimpleReturn = true;
+	if (pReturnTypeDescr)
+	{
+#ifdef CMC_DEBUG
+		fprintf(stderr, "return type is %d\n", pReturnTypeDescr->eTypeClass);
+#endif
+		if ( ia64::return_in_hidden_param(pReturnTypeRef) || ia64::return_via_r8_buffer(pReturnTypeRef) )
+                        bSimpleReturn = false;
+
+                if ( bSimpleReturn )
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+#ifdef CMC_DEBUG
+			fprintf(stderr, "simple return\n");
+#endif
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
+			       ? alloca( pReturnTypeDescr->nSize ) : pUnoReturn);
+#ifdef CMC_DEBUG
+			fprintf(stderr, "pCppReturn/pUnoReturn is %lx/%lx", pCppReturn, pUnoReturn);
+#endif
+                        if (!ia64::return_via_r8_buffer(pReturnTypeRef))
+			    INSERT_INT64( &pCppReturn, nGPR, pGPR, pStack, bOverFlow );
+		}
+	}
+	// push "this" pointer
+        void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "this pointer is %p\n", pAdjustedThisPtr);
+#endif
+	INSERT_INT64( &pAdjustedThisPtr, nGPR, pGPR, pStack, bOverFlow );
+
+        // Args 
+        void ** pCppArgs = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+
+#ifdef CMC_DEBUG
+	fprintf(stderr, "n params is %d\n", nParams);
+#endif
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+#ifdef CMC_DEBUG
+		fprintf(stderr, "param %d is %d %d %d\n", nPos, rParam.bOut, bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ),
+			pParamTypeDescr->eTypeClass);
+#endif
+		
+		if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
+		{
+//			uno_copyAndConvertData( pCppArgs[nPos] = alloca( 8 ), pUnoArgs[nPos], pParamTypeDescr,
+			uno_copyAndConvertData( pCppArgs[nPos] = pStack, pUnoArgs[nPos], pParamTypeDescr,
+									pThis->getBridge()->getUno2Cpp() );
+		        switch (pParamTypeDescr->eTypeClass)
+                        {
+                        case typelib_TypeClass_HYPER:
+                        case typelib_TypeClass_UNSIGNED_HYPER:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "hyper is %lx\n", *(unsigned long*)(pCppArgs[nPos]));
+#endif
+                                INSERT_INT64( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_LONG:
+                        case typelib_TypeClass_UNSIGNED_LONG:
+                        case typelib_TypeClass_ENUM:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "long is %lx\n", *(unsigned int*)(pCppArgs[nPos]));
+#endif
+                                INSERT_INT32( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_SHORT:
+                        case typelib_TypeClass_CHAR:
+                        case typelib_TypeClass_UNSIGNED_SHORT:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "short is %x\n", *(unsigned short*)(pCppArgs[nPos]));
+#endif
+                                INSERT_INT16( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_BOOLEAN:
+                        case typelib_TypeClass_BYTE:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "byte is %x\n", *(unsigned char*)(pCppArgs[nPos]));
+#endif
+                                INSERT_INT8( pCppArgs[nPos], nGPR, pGPR, pStack, bOverFlow );
+                                break;
+                        case typelib_TypeClass_FLOAT:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "a float is %f\n", *(float*)(pCppArgs[nPos]));
+				fprintf(stderr, "b float is %f\n", *(double*)(pCppArgs[nPos]));
+#endif
+                                INSERT_FLOAT( pCppArgs[nPos], nFPR, pFPR, nGPR, pGPR, pStack, bOverFlow );
+				break;
+                        case typelib_TypeClass_DOUBLE:
+#ifdef CMC_DEBUG
+				fprintf(stderr, "double is %f\n", *(double*)(pCppArgs[nPos]));
+#endif
+                                INSERT_DOUBLE( pCppArgs[nPos], nFPR, pFPR, nGPR, pGPR, pStack, bOverFlow );
+                                break;
+			default:
+				break;
+                        }
+
+                        // no longer needed
+                        TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+	
+		}
+		else // ptr to complex value | ref
+		{
+#ifdef CMC_DEBUG
+			fprintf(stderr, "complex type again %d\n", rParam.bIn);
+#endif
+                        if (! rParam.bIn) // is pure out
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "complex size is %d\n", pParamTypeDescr->nSize );
+#endif
+                                // cpp out is constructed mem, uno out is not!
+                                uno_constructData(
+                                        pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                                        pParamTypeDescr ); 
+                                pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+                                // will be released at reconversion
+                                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+                        }
+                        // is in/inout
+                        else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "this one\n");
+#endif
+                                uno_copyAndConvertData(
+                                        pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+                                        pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
+
+                                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+                                // will be released at reconversion
+                                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+                        }
+                        else // direct way
+                        {
+#ifdef CMC_DEBUG
+				fprintf(stderr, "that one, passing %lx through\n", pUnoArgs[nPos]);
+#endif
+                                pCppArgs[nPos] = pUnoArgs[nPos];
+                                // no longer needed
+                                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+                        }
+                        INSERT_INT64( &(pCppArgs[nPos]), nGPR, pGPR, pStack, bOverFlow );
+		}
+	}
+  
+	try
+	{
+               callVirtualMethod(
+                        pAdjustedThisPtr, aVtableSlot.index,
+                        pCppReturn, pReturnTypeDescr, bSimpleReturn, 
+                        pStackStart, ( pStack - pStackStart ),
+                        pGPR, nGPR,
+                        pFPR, nFPR );
+		// NO exception occured...
+		*ppUnoExc = 0;
+
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											pThis->getBridge()->getCpp2Uno() );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										pThis->getBridge()->getCpp2Uno() );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									pThis->getBridge()->getCpp2Uno() );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+  		// fill uno exception
+		fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, 
+                                  *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
+        
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+}
+
+namespace bridges { namespace cpp_uno { namespace shared {
+
+void unoInterfaceProxyDispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException )
+{
+	// is my surrogate
+        bridges::cpp_uno::shared::UnoInterfaceProxy * pThis 
+            = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy *> (pUnoI);
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription const * >(
+                        pMemberDescr)));
+
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+                        aVtableSlot.index += 1; //get then set method
+			cpp_call(
+				pThis, aVtableSlot,
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+
+        VtableSlot aVtableSlot(
+            getVtableSlot(
+                reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription const * >(
+                        pMemberDescr)));
+		switch (aVtableSlot.index)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->getUnoEnv()->getRegisteredInterface)(
+                    pThis->pBridge->getUnoEnv(),
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, aVtableSlot,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+} } }
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_intel
Index: bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx,v
retrieving revision 1.12
retrieving revision 1.12.82.1
diff -u -u -p -b -w -B -r1.12 -r1.12.82.1
--- bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx	16 Sep 2006 15:47:26 -0000	1.12
+++ bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx	18 Feb 2008 10:40:37 -0000	1.12.82.1
@@ -421,29 +421,36 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
-{
-    return static_cast< void ** >(block) + 2;
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block) {
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /*functionCount*/, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -451,7 +458,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
@@ -461,7 +468,7 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(
                     code, functionOffset++, vtableOffset,
                     typelib_TypeClass_VOID);
@@ -469,7 +476,7 @@ unsigned char * bridges::cpp_uno::shared
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_mips
Index: bridges/source/cpp_uno/gcc3_linux_mips/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_mips/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.8.1
diff -u -u -p -b -w -B -r1.3 -r1.3.8.1
--- bridges/source/cpp_uno/gcc3_linux_mips/cpp2uno.cxx	22 Nov 2007 16:47:04 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_linux_mips/cpp2uno.cxx	18 Feb 2008 10:40:37 -0000	1.3.8.1
@@ -726,37 +726,38 @@ void bridges::cpp_uno::shared::VtableFac
   sysmips(FLUSH_CACHE,0,0,0);
 }
 
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
 
-
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-  return reinterpret_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-     slots[-2] = 0; //null
-     slots[-1] = 0; //destructor
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0; //null
+    slots[-1].fn = 0; //destructor
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-	void ** slots, unsigned char * code,
+	Slot ** slots, unsigned char * code,
 	typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-	sal_Int32
-#ifdef BRDEBUG
-       functionCount
-#endif
-    , sal_Int32 vtableOffset)
+	sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
-
+   (*slots) -= functionCount;
+    Slot * s = *slots;
 #ifdef BRDEBUG
    fprintf(stderr, "in addLocalFunctions functionOffset is %d\n",functionOffset);
    fprintf(stderr, "in addLocalFunctions vtableOffset is %d\n",vtableOffset);
@@ -771,7 +772,7 @@ unsigned char * bridges::cpp_uno::shared
 	switch (member->eTypeClass) {
 	  case typelib_TypeClass_INTERFACE_ATTRIBUTE:
 		// Getter:
-		*slots++ = code;
+		(s++)->fn = code;
 		code = codeSnippet(
 			code, functionOffset++, vtableOffset,
 			bridges::cpp_uno::shared::isSimpleType(
@@ -784,13 +785,13 @@ unsigned char * bridges::cpp_uno::shared
 			typelib_InterfaceAttributeTypeDescription * >(
 			  member)->bReadOnly)
 		{
-		  *slots++ = code;
+		  (s++)->fn = code;
 		  code = codeSnippet(code, functionOffset++, vtableOffset, true);
 		}
 		break;
 
 	  case typelib_TypeClass_INTERFACE_METHOD:
-		*slots++ = code;
+		(s++)->fn = code;
 		code = codeSnippet(
 			code, functionOffset++, vtableOffset,
 			bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_powerpc
Index: bridges/source/cpp_uno/gcc3_linux_powerpc/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_powerpc/cpp2uno.cxx,v
retrieving revision 1.10
retrieving revision 1.10.4.1
diff -u -u -p -b -w -B -r1.10 -r1.10.4.1
--- bridges/source/cpp_uno/gcc3_linux_powerpc/cpp2uno.cxx	4 Feb 2008 13:43:38 -0000	1.10
+++ bridges/source/cpp_uno/gcc3_linux_powerpc/cpp2uno.cxx	18 Feb 2008 10:40:37 -0000	1.10.4.1
@@ -660,32 +660,37 @@ void bridges::cpp_uno::shared::VtableFac
   __asm__ volatile ( "sync;" "isync;" : : : "memory");
 }
 
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
 
-
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
-
+     (*slots) -= functionCount;
+     Slot * s = *slots;
   // fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
   // fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
   // fflush(stderr);
@@ -697,7 +702,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -710,13 +715,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_powerpc64
Index: bridges/source/cpp_uno/gcc3_linux_powerpc64/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_powerpc64/cpp2uno.cxx,v
retrieving revision 1.2
retrieving revision 1.2.32.2
diff -u -u -p -b -w -B -r1.2 -r1.2.32.2
--- bridges/source/cpp_uno/gcc3_linux_powerpc64/cpp2uno.cxx	18 Jun 2007 16:34:57 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_powerpc64/cpp2uno.cxx	18 Feb 2008 10:40:37 -0000	1.2.32.2
@@ -135,7 +135,7 @@ static typelib_TypeClass cpp2uno_call(
 			{
 				case typelib_TypeClass_FLOAT:
 				case typelib_TypeClass_DOUBLE:
-					if (nf < 13)
+					if (nf < ppc64::MAX_SSE_REGS)
 					{
 						if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT)
 						{
@@ -154,7 +154,7 @@ static typelib_TypeClass cpp2uno_call(
 					break;
                 case typelib_TypeClass_BYTE:
                 case typelib_TypeClass_BOOLEAN:
-                    if (ng < 8)
+                    if (ng < ppc64::MAX_GPR_REGS)
 					{
                         pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-1));
                         ng++;
@@ -170,7 +170,7 @@ static typelib_TypeClass cpp2uno_call(
                 case typelib_TypeClass_CHAR:
                 case typelib_TypeClass_SHORT:
                 case typelib_TypeClass_UNSIGNED_SHORT:
-                    if (ng < 8)
+                    if (ng < ppc64::MAX_GPR_REGS)
 					{
                         pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-2));
                         ng++;
@@ -186,7 +186,7 @@ static typelib_TypeClass cpp2uno_call(
 		case typelib_TypeClass_ENUM:
                 case typelib_TypeClass_LONG:
                 case typelib_TypeClass_UNSIGNED_LONG:
-                    if (ng < 8)
+                    if (ng < ppc64::MAX_GPR_REGS)
 					{
                         pCppArgs[nPos] = pUnoArgs[nPos] = (((char *)gpreg) + (sizeof(void*)-4));
                         ng++;
@@ -200,7 +200,7 @@ static typelib_TypeClass cpp2uno_call(
                     if (bOverFlowUsed) ovrflw++;
                     break;
 				default:
-					if (ng < 8) 
+					if (ng < ppc64::MAX_GPR_REGS) 
 					{
 						pCppArgs[nPos] = pUnoArgs[nPos] = gpreg++;
 						ng++;
@@ -224,7 +224,7 @@ static typelib_TypeClass cpp2uno_call(
 #endif
             void *pCppStack; //temporary stack pointer
 
-			if (ng < 8)
+			if (ng < ppc64::MAX_GPR_REGS)
 			{ 
 		        pCppArgs[nPos] = pCppStack = *gpreg++;
 			    ng++;
@@ -521,8 +521,8 @@ extern "C" void privateSnippetExecutor( 
                 "mr     %0,    11\n\t"
                 : "=r" (nOffsetAndIndex) : );
 
-    sal_uInt64 gpreg[8];
-    double fpreg[13];
+    sal_uInt64 gpreg[ppc64::MAX_GPR_REGS];
+    double fpreg[ppc64::MAX_SSE_REGS];
 
     __asm__ __volatile__ (
         "std 3,   0(%0)\t\n"
@@ -645,31 +645,37 @@ void bridges::cpp_uno::shared::VtableFac
   __asm__ volatile ( "sync;" "isync;" : : : "memory");
 }
 
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
 
-
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code, 
+    Slot ** slots, unsigned char * code, 
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+     (*slots) -= functionCount;
+     Slot * s = *slots;
 #ifdef CMC_DEBUG
     fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
     fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
@@ -682,7 +688,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -695,13 +701,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
Index: bridges/source/cpp_uno/gcc3_linux_powerpc64/except.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_powerpc64/except.cxx,v
retrieving revision 1.2
retrieving revision 1.2.32.1
diff -u -u -p -b -w -B -r1.2 -r1.2.32.1
--- bridges/source/cpp_uno/gcc3_linux_powerpc64/except.cxx	18 Jun 2007 16:35:07 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_powerpc64/except.cxx	4 Jan 2008 19:09:58 -0000	1.2.32.1
@@ -141,8 +141,8 @@ type_info * RTTI::getRTTI( typelib_Compo
     OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
 
     MutexGuard guard( m_mutex );
-    t_rtti_map::const_iterator iFind( m_rttis.find( unoName ) );
-    if (iFind == m_rttis.end())
+    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
+    if (iRttiFind == m_rttis.end())
     {
         // RTTI symbol
         OStringBuffer buf( 64 );
@@ -206,7 +206,7 @@ type_info * RTTI::getRTTI( typelib_Compo
     }
     else
     {
-        rtti = iFind->second;
+        rtti = iRttiFind->second;
     }
 
     return rtti;
Index: bridges/source/cpp_uno/gcc3_linux_powerpc64/share.hxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_powerpc64/share.hxx,v
retrieving revision 1.2
retrieving revision 1.2.32.1
diff -u -u -p -b -w -B -r1.2 -r1.2.32.1
--- bridges/source/cpp_uno/gcc3_linux_powerpc64/share.hxx	18 Jun 2007 16:35:29 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_powerpc64/share.hxx	4 Jan 2008 19:09:58 -0000	1.2.32.1
@@ -97,3 +97,8 @@ void raiseException(
 void fillUnoException(
     __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
 }
+
+namespace ppc64
+{
+	enum ppclimits { MAX_GPR_REGS = 8, MAX_SSE_REGS = 13 };
+}
Index: bridges/source/cpp_uno/gcc3_linux_powerpc64/uno2cpp.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_powerpc64/uno2cpp.cxx,v
retrieving revision 1.2
retrieving revision 1.2.32.1
diff -u -u -p -b -w -B -r1.2 -r1.2.32.1
--- bridges/source/cpp_uno/gcc3_linux_powerpc64/uno2cpp.cxx	18 Jun 2007 16:35:40 -0000	1.2
+++ bridges/source/cpp_uno/gcc3_linux_powerpc64/uno2cpp.cxx	4 Jan 2008 19:09:58 -0000	1.2.32.1
@@ -55,11 +55,6 @@
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 
-namespace ppc64
-{
-	enum ppclimits { MAX_GPR_REGS = 8, MAX_SSE_REGS = 13 };
-}
-
 void MapReturn(long r3, double dret, typelib_TypeClass eTypeClass, void *pRegisterReturn)
 {
     switch (eTypeClass)
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_s390
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_sparc
Index: bridges/source/cpp_uno/gcc3_linux_sparc/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_sparc/cpp2uno.cxx,v
retrieving revision 1.12
retrieving revision 1.12.66.1
diff -u -u -p -b -w -B -r1.12 -r1.12.66.1
--- bridges/source/cpp_uno/gcc3_linux_sparc/cpp2uno.cxx	22 Nov 2006 11:07:20 -0000	1.12
+++ bridges/source/cpp_uno/gcc3_linux_sparc/cpp2uno.cxx	18 Feb 2008 10:40:38 -0000	1.12.66.1
@@ -493,29 +493,37 @@ unsigned char * codeSnippet(
 
 } //end of namespace
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-     slots[-2] = 0; //null
-     slots[-1] = 0; //destructor
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0; //null
+    slots[-1].fn = 0; //destructor
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /* functionCount */, sal_Int32 vTableOffset)
+    sal_Int32 functionCount, sal_Int32 vTableOffset)
 {
+	(*slots) -= functionCount;
+	Slot * s = *slots;
 	for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -523,7 +531,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vTableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -535,13 +543,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vTableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vTableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_linux_x86-64
Index: bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx,v
retrieving revision 1.7
retrieving revision 1.7.8.1
diff -u -u -p -b -w -B -r1.7 -r1.7.8.1
--- bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	13 Nov 2007 14:18:07 -0000	1.7
+++ bridges/source/cpp_uno/gcc3_linux_x86-64/cpp2uno.cxx	18 Feb 2008 10:40:38 -0000	1.7.8.1
@@ -465,35 +465,41 @@ unsigned char * codeSnippet( unsigned ch
 }
 
 //==================================================================================================
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable( void * block )
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-	return static_cast<void **>( block ) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 //==================================================================================================
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return ( slotCount + 2 ) * sizeof( void * ) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
 //==================================================================================================
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock( void * block )
-{
-	void ** slots = mapBlockToVtable( block );
-	slots[-2] = 0;
-	slots[-1] = 0;
-
-	return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 //==================================================================================================
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-	void ** slots, unsigned char * code,
+	Slot ** slots, unsigned char * code,
 	typelib_InterfaceTypeDescription const * type, sal_Int32 nFunctionOffset,
-	sal_Int32 /* functionCount */, sal_Int32 nVtableOffset )
+	sal_Int32 functionCount, sal_Int32 nVtableOffset )
 {
+	(*slots) -= functionCount;
+	Slot * s = *slots;
 	for ( sal_Int32 nPos = 0; nPos < type->nMembers; ++nPos )
 	{
 		typelib_TypeDescription * pTD = 0;
@@ -507,14 +513,14 @@ unsigned char * bridges::cpp_uno::shared
 				reinterpret_cast<typelib_InterfaceAttributeTypeDescription *>( pTD );
 
 			// get method
-			*slots++ = code;
+			(s++)->fn = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
 								x86_64::return_in_hidden_param( pAttrTD->pAttributeTypeRef ) );
 
 			if ( ! pAttrTD->bReadOnly )
 			{
 				// set method
-				*slots++ = code;
+				(s++)->fn = code;
 				code = codeSnippet( code, nFunctionOffset++, nVtableOffset, false );
 			}
 		}
@@ -523,7 +529,7 @@ unsigned char * bridges::cpp_uno::shared
 			typelib_InterfaceMethodTypeDescription *pMethodTD =
 				reinterpret_cast<typelib_InterfaceMethodTypeDescription *>( pTD );
 			
-			*slots++ = code;
+			(s++)->fn = code;
 			code = codeSnippet( code, nFunctionOffset++, nVtableOffset,
 								x86_64::return_in_hidden_param( pMethodTD->pReturnTypeRef ) );
 		}
cvs diff: Diffing bridges/source/cpp_uno/gcc3_macosx_intel
Index: bridges/source/cpp_uno/gcc3_macosx_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_macosx_intel/cpp2uno.cxx,v
retrieving revision 1.5
retrieving revision 1.5.82.1
diff -u -u -p -b -w -B -r1.5 -r1.5.82.1
--- bridges/source/cpp_uno/gcc3_macosx_intel/cpp2uno.cxx	16 Sep 2006 15:51:08 -0000	1.5
+++ bridges/source/cpp_uno/gcc3_macosx_intel/cpp2uno.cxx	18 Feb 2008 11:01:40 -0000	1.5.82.1
@@ -450,29 +450,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /*functionCount*/, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -480,7 +488,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
@@ -490,7 +498,7 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(
                     code, functionOffset++, vtableOffset,
                     0 /* indicates VOID */);
@@ -498,7 +506,7 @@ unsigned char * bridges::cpp_uno::shared
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_macosx_powerpc
Index: bridges/source/cpp_uno/gcc3_macosx_powerpc/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_macosx_powerpc/cpp2uno.cxx,v
retrieving revision 1.9
retrieving revision 1.9.54.1
diff -u -u -p -b -w -B -r1.9 -r1.9.54.1
--- bridges/source/cpp_uno/gcc3_macosx_powerpc/cpp2uno.cxx	18 Jan 2007 14:15:28 -0000	1.9
+++ bridges/source/cpp_uno/gcc3_macosx_powerpc/cpp2uno.cxx	18 Feb 2008 11:01:40 -0000	1.9.54.1
@@ -655,30 +655,37 @@ void bridges::cpp_uno::shared::VtableFac
   __asm__ volatile ( "sync;" "isync;" : : : "memory");
 }
 
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /* functionCount */, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
 
   // fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
   // fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
@@ -691,7 +698,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -704,13 +711,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_netbsd_intel
cvs diff: Diffing bridges/source/cpp_uno/gcc3_os2_intel
Index: bridges/source/cpp_uno/gcc3_os2_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_os2_intel/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.20.1
diff -u -u -p -b -w -B -r1.3 -r1.3.20.1
--- bridges/source/cpp_uno/gcc3_os2_intel/cpp2uno.cxx	25 Sep 2007 09:33:55 -0000	1.3
+++ bridges/source/cpp_uno/gcc3_os2_intel/cpp2uno.cxx	18 Feb 2008 11:07:00 -0000	1.3.20.1
@@ -453,29 +453,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -483,7 +491,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -495,13 +503,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_os2_intel/defs
cvs diff: Diffing bridges/source/cpp_uno/gcc3_solaris_intel
Index: bridges/source/cpp_uno/gcc3_solaris_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_solaris_intel/cpp2uno.cxx,v
retrieving revision 1.6
retrieving revision 1.6.82.1
diff -u -u -p -b -w -B -r1.6 -r1.6.82.1
--- bridges/source/cpp_uno/gcc3_solaris_intel/cpp2uno.cxx	16 Sep 2006 15:53:13 -0000	1.6
+++ bridges/source/cpp_uno/gcc3_solaris_intel/cpp2uno.cxx	18 Feb 2008 11:05:04 -0000	1.6.82.1
@@ -452,29 +452,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -482,7 +490,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -494,13 +502,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/gcc3_solaris_sparc
Index: bridges/source/cpp_uno/gcc3_solaris_sparc/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_solaris_sparc/cpp2uno.cxx,v
retrieving revision 1.6
retrieving revision 1.6.82.1
diff -u -u -p -b -w -B -r1.6 -r1.6.82.1
--- bridges/source/cpp_uno/gcc3_solaris_sparc/cpp2uno.cxx	16 Sep 2006 15:53:57 -0000	1.6
+++ bridges/source/cpp_uno/gcc3_solaris_sparc/cpp2uno.cxx	18 Feb 2008 11:05:04 -0000	1.6.82.1
@@ -491,29 +491,37 @@ unsigned char * codeSnippet(
 
 } //end of namespace
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0; //null
-    slots[-1] = 0; //destructor
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0; //null
+    slots[-1].fn = 0; //destructor
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vTableOffset)
 {
+	(*slots) -= functionCount;
+	Slot * s = *slots;
 	for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -521,7 +529,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vTableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
@@ -533,13 +541,13 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(code, functionOffset++, vTableOffset, true);
             }
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vTableOffset,
                 bridges::cpp_uno::shared::isSimpleType(
cvs diff: Diffing bridges/source/cpp_uno/mingw_intel
Index: bridges/source/cpp_uno/mingw_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/mingw_intel/cpp2uno.cxx,v
retrieving revision 1.3
retrieving revision 1.3.34.1
diff -u -u -p -b -w -B -r1.3 -r1.3.34.1
--- bridges/source/cpp_uno/mingw_intel/cpp2uno.cxx	25 May 2007 10:53:46 -0000	1.3
+++ bridges/source/cpp_uno/mingw_intel/cpp2uno.cxx	18 Feb 2008 11:16:17 -0000	1.3.34.1
@@ -422,29 +422,37 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 2;
+    return static_cast< Slot * >(block) + 2;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 2) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
-    void ** slots = mapBlockToVtable(block);
-    slots[-2] = 0;
-    slots[-1] = 0;
-    return slots;
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount)
+{
+    Slot * slots = mapBlockToVtable(block);
+    slots[-2].fn = 0;
+    slots[-1].fn = 0;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
-    sal_Int32 /*functionCount*/, sal_Int32 vtableOffset)
+    sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < type->nMembers; ++i) {
         typelib_TypeDescription * member = 0;
         TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
@@ -452,7 +460,7 @@ unsigned char * bridges::cpp_uno::shared
         switch (member->eTypeClass) {
         case typelib_TypeClass_INTERFACE_ATTRIBUTE:
             // Getter:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
@@ -462,7 +470,7 @@ unsigned char * bridges::cpp_uno::shared
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
-                *slots++ = code;
+                (s++)->fn = code;
                 code = codeSnippet(
                     code, functionOffset++, vtableOffset,
                     typelib_TypeClass_VOID);
@@ -470,7 +478,7 @@ unsigned char * bridges::cpp_uno::shared
             break;
 
         case typelib_TypeClass_INTERFACE_METHOD:
-            *slots++ = code;
+            (s++)->fn = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
                 reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
cvs diff: Diffing bridges/source/cpp_uno/msvc_win32_intel
Index: bridges/source/cpp_uno/msvc_win32_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/msvc_win32_intel/cpp2uno.cxx,v
retrieving revision 1.17
retrieving revision 1.17.82.1
diff -u -u -p -b -w -B -r1.17 -r1.17.82.1
--- bridges/source/cpp_uno/msvc_win32_intel/cpp2uno.cxx	16 Sep 2006 15:54:51 -0000	1.17
+++ bridges/source/cpp_uno/msvc_win32_intel/cpp2uno.cxx	18 Feb 2008 11:20:25 -0000	1.17.82.1
@@ -442,18 +442,23 @@ unsigned char * codeSnippet(
 
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
+struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
+
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
 {
-    return static_cast< void ** >(block) + 1;
+    return static_cast< Slot * >(block) + 1;
 }
 
 sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
     sal_Int32 slotCount)
 {
-    return (slotCount + 1) * sizeof (void *) + slotCount * codeSnippetSize;
+    return (slotCount + 1) * sizeof (Slot) + slotCount * codeSnippetSize;
 }
 
-void ** bridges::cpp_uno::shared::VtableFactory::initializeBlock(void * block) {
+bridges::cpp_uno::shared::VtableFactory::Slot *
+bridges::cpp_uno::shared::VtableFactory::initializeBlock(
+    void * block, sal_Int32 slotCount) {
 	struct Rtti {
 		sal_Int32 n0, n1, n2;
 		type_info * rtti;
@@ -466,18 +471,20 @@ void ** bridges::cpp_uno::shared::Vtable
     };
     static Rtti rtti;
 
-    void ** slots = mapBlockToVtable(block);
-    slots[-1] = &rtti;
-    return slots;
+    Slot * slots = mapBlockToVtable(block);
+    slots[-1].fn = &rtti;
+    return slots + slotCount;
 }
 
 unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
-    void ** slots, unsigned char * code,
+    Slot ** slots, unsigned char * code,
     typelib_InterfaceTypeDescription const *, sal_Int32 functionOffset,
     sal_Int32 functionCount, sal_Int32 vtableOffset)
 {
+    (*slots) -= functionCount;
+    Slot * s = *slots;
     for (sal_Int32 i = 0; i < functionCount; ++i) {
-        *slots++ = code;
+        (s++)->fn = code;
         code = codeSnippet(code, functionOffset++, vtableOffset);
     }
     return code;
cvs diff: Diffing bridges/source/cpp_uno/shared
Index: bridges/source/cpp_uno/shared/vtablefactory.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/shared/vtablefactory.cxx,v
retrieving revision 1.9
retrieving revision 1.9.22.2
diff -u -u -p -b -w -B -r1.9 -r1.9.22.2
--- bridges/source/cpp_uno/shared/vtablefactory.cxx	20 Sep 2007 15:30:12 -0000	1.9
+++ bridges/source/cpp_uno/shared/vtablefactory.cxx	18 Feb 2008 10:40:38 -0000	1.9.22.2
@@ -266,21 +266,19 @@ void VtableFactory::createVtables(
             throw std::bad_alloc();
         }
         try {
-            void ** slots = initializeBlock(block.start) + slotCount;
+            Slot * slots = initializeBlock(block.start, slotCount);
             unsigned char * codeBegin =
                 reinterpret_cast< unsigned char * >(slots);
             unsigned char * code = codeBegin;
-            sal_Int32 vtableOffset = blocks.size() * sizeof (void **);
+            sal_Int32 vtableOffset = blocks.size() * sizeof (Slot *);
             for (typelib_InterfaceTypeDescription const * type2 = type;
                  type2 != 0; type2 = type2->pBaseTypeDescription)
             {
-                sal_Int32 functionCount
-                    = bridges::cpp_uno::shared::getLocalFunctions(type2);
-                slots -= functionCount;
                 code = addLocalFunctions(
-                    slots, code, type2,
+                    &slots, code, type2,
                     baseOffset.getFunctionOffset(type2->aBase.pTypeName),
-                    functionCount, vtableOffset);
+                    bridges::cpp_uno::shared::getLocalFunctions(type2),
+                    vtableOffset);
             }
             flushCode(codeBegin, code);
             blocks.push_back(block);
cvs diff: Diffing bridges/source/jni_uno
cvs diff: Diffing bridges/source/jni_uno/java
cvs diff: Diffing bridges/source/jni_uno/java/com
cvs diff: Diffing bridges/source/jni_uno/java/com/sun
cvs diff: Diffing bridges/source/jni_uno/java/com/sun/star
cvs diff: Diffing bridges/source/jni_uno/java/com/sun/star/bridges
cvs diff: Diffing bridges/source/jni_uno/java/com/sun/star/bridges/jni_uno
cvs diff: Diffing bridges/source/remote
cvs diff: Diffing bridges/source/remote/context
cvs diff: Diffing bridges/source/remote/idl
cvs diff: Diffing bridges/source/remote/static
cvs diff: Diffing bridges/source/remote/urp
cvs diff: Diffing bridges/test
cvs diff: Diffing bridges/test/com
cvs diff: Diffing bridges/test/com/sun
cvs diff: Diffing bridges/test/com/sun/star
cvs diff: Diffing bridges/test/com/sun/star/lib
cvs diff: Diffing bridges/test/com/sun/star/lib/uno
cvs diff: Diffing bridges/test/com/sun/star/lib/uno/bridges
cvs diff: Diffing bridges/test/com/sun/star/lib/uno/bridges/java_remote
cvs diff: Diffing bridges/test/inter_libs_exc
cvs diff: Diffing bridges/test/java_uno
cvs diff: Diffing bridges/test/java_uno/acquire
cvs diff: Diffing bridges/test/java_uno/any
cvs diff: Diffing bridges/test/java_uno/equals
cvs diff: Diffing bridges/test/java_uno/nativethreadpool
cvs diff: Diffing bridges/test/performance
cvs diff: Diffing bridges/unotypes
cvs diff: Diffing config_office
Index: config_office/set_soenv.in
===================================================================
RCS file: /cvs/tools/config_office/set_soenv.in,v
retrieving revision 1.172
retrieving revision 1.168.8.2
diff -u -u -p -b -w -B -r1.172 -r1.168.8.2
--- config_office/set_soenv.in	4 Feb 2008 12:56:11 -0000	1.172
+++ config_office/set_soenv.in	14 Feb 2008 09:47:05 -0000	1.168.8.2
@@ -436,6 +436,18 @@ elsif ( $platform =~ m/linux-gnu/ ) 
       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."amd64".$ds."native_threads";
       $JREEXTRALIBDIR = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."amd64".$ds."xawt";
    }
+   elsif ($platform =~ m/^ia64/)
+   {  print "Setting Linux ia64 specific values... ";
+      $outfile        = "LinuxIA64Env.Set";
+      $CPU            = "A";
+      $CPUNAME        = "IA64";
+      $CVER           = "C341";
+      $OUTPATH        = "unxlnga";
+      $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ia64";
+      $JREEXTRALIBDIR = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ia64".$ds."xawt";
+      $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ia64".$ds."server";
+      $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ia64".$ds."native_threads";
+   }
    elsif ($platform =~ m/^sparc/)
  
    {  print "Setting Linux Sparc specific values... ";
cvs diff: Diffing config_office/guw
cvs diff: Diffing jvmfwk
cvs diff: Diffing jvmfwk/distributions
cvs diff: Diffing jvmfwk/distributions/OpenOfficeorg
cvs diff: Diffing jvmfwk/distributions/StarOffice
cvs diff: Diffing jvmfwk/inc
cvs diff: Diffing jvmfwk/inc/jvmfwk
cvs diff: Diffing jvmfwk/inc/pch
cvs diff: Diffing jvmfwk/plugins
cvs diff: Diffing jvmfwk/plugins/sunmajor
cvs diff: Diffing jvmfwk/plugins/sunmajor/javaenvsetup
cvs diff: Diffing jvmfwk/plugins/sunmajor/pluginlib
Index: jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx
===================================================================
RCS file: /cvs/udk/jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx,v
retrieving revision 1.9
retrieving revision 1.9.4.1
diff -u -u -p -b -w -B -r1.9 -r1.9.4.1
--- jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	26 Nov 2007 18:04:40 -0000	1.9
+++ jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	4 Jan 2008 19:05:43 -0000	1.9.4.1
@@ -67,6 +67,8 @@ namespace jfw_plugin
 #define JFW_PLUGIN_ARCH "amd64"
 #elif defined ARM
 #define JFW_PLUGIN_ARCH "arm"
+#elif defined IA64
+#define JFW_PLUGIN_ARCH "ia64"
 #else // SPARC, INTEL, POWERPC, MIPS, ARM
 #error unknown plattform
 #endif // SPARC, INTEL, POWERPC, MIPS, ARM
cvs diff: Diffing jvmfwk/prj
cvs diff: Diffing jvmfwk/source
cvs diff: Diffing sal
cvs diff: Diffing sal/cpprt
cvs diff: Diffing sal/inc
cvs diff: Diffing sal/inc/internal
cvs diff: Diffing sal/inc/osl
cvs diff: Diffing sal/inc/pch
cvs diff: Diffing sal/inc/rtl
cvs diff: Diffing sal/inc/sal
cvs diff: Diffing sal/inc/systools
cvs diff: Diffing sal/inc/systools/win32
cvs diff: Diffing sal/osl
cvs diff: Diffing sal/osl/all
cvs diff: Diffing sal/osl/os2
cvs diff: Diffing sal/osl/os2/helpers
cvs diff: Diffing sal/osl/unx
cvs diff: Diffing sal/osl/unx/asm
cvs diff: Diffing sal/osl/w32
cvs diff: Diffing sal/prj
cvs diff: Diffing sal/qa
cvs diff: Diffing sal/qa/ByteSequence
cvs diff: Diffing sal/qa/OStringBuffer
cvs diff: Diffing sal/qa/helper
cvs diff: Diffing sal/qa/helper/gcov
cvs diff: Diffing sal/qa/inc
cvs diff: Diffing sal/qa/osl
cvs diff: Diffing sal/qa/osl/condition
cvs diff: Diffing sal/qa/osl/file
cvs diff: Diffing sal/qa/osl/module
cvs diff: Diffing sal/qa/osl/mutex
cvs diff: Diffing sal/qa/osl/pipe
cvs diff: Diffing sal/qa/osl/process
cvs diff: Diffing sal/qa/osl/profile
cvs diff: Diffing sal/qa/osl/security
cvs diff: Diffing sal/qa/osl/semaphore
cvs diff: Diffing sal/qa/osl/socket
cvs diff: Diffing sal/qa/osl/thread
cvs diff: Diffing sal/qa/rtl
cvs diff: Diffing sal/qa/rtl/alloc
cvs diff: Diffing sal/qa/rtl/bootstrap
cvs diff: Diffing sal/qa/rtl/cipher
cvs diff: Diffing sal/qa/rtl/crc32
cvs diff: Diffing sal/qa/rtl/digest
cvs diff: Diffing sal/qa/rtl/doublelock
cvs diff: Diffing sal/qa/rtl/locale
cvs diff: Diffing sal/qa/rtl/logfile
cvs diff: Diffing sal/qa/rtl/math
cvs diff: Diffing sal/qa/rtl/ostring
cvs diff: Diffing sal/qa/rtl/oustring
cvs diff: Diffing sal/qa/rtl/oustringbuffer
cvs diff: Diffing sal/qa/rtl/process
cvs diff: Diffing sal/qa/rtl/random
cvs diff: Diffing sal/qa/rtl/strings
cvs diff: Diffing sal/qa/rtl/textenc
cvs diff: Diffing sal/qa/rtl/uri
cvs diff: Diffing sal/qa/rtl/uuid
cvs diff: Diffing sal/qa/rtl_strings
cvs diff: Diffing sal/qa/sal
cvs diff: Diffing sal/qa/systools
cvs diff: Diffing sal/qa/testHelperFunctions
cvs diff: Diffing sal/rtl
cvs diff: Diffing sal/rtl/source
Index: sal/rtl/source/macro.hxx
===================================================================
RCS file: /cvs/porting/sal/rtl/source/macro.hxx,v
retrieving revision 1.8
retrieving revision 1.8.20.1
diff -u -u -p -b -w -B -r1.8 -r1.8.20.1
--- sal/rtl/source/macro.hxx	26 Nov 2007 18:05:15 -0000	1.8
+++ sal/rtl/source/macro.hxx	4 Jan 2008 19:04:40 -0000	1.8.20.1
@@ -78,6 +78,8 @@ this is inserted for the case that the p
 #define THIS_ARCH "MIPS"
 #elif defined ARM
 #define THIS_ARCH "ARM"
+#elif defined IA64
+#define THIS_ARCH "IA64"
 #endif
 
 #if ! defined THIS_ARCH
cvs diff: Diffing sal/systools
cvs diff: Diffing sal/systools/win32
cvs diff: Diffing sal/systools/win32/delayload
cvs diff: Diffing sal/systools/win32/guistdio
cvs diff: Diffing sal/systools/win32/kill
cvs diff: Diffing sal/systools/win32/onlineupdate
cvs diff: Diffing sal/systools/win32/uwinapi
cvs diff: Diffing sal/test
cvs diff: Diffing sal/test/unloading
cvs diff: Diffing sal/textenc
cvs diff: Diffing sal/textenc/generate
cvs diff: Diffing sal/typesconfig
Index: sal/typesconfig/typesconfig.c
===================================================================
RCS file: /cvs/porting/sal/typesconfig/typesconfig.c,v
retrieving revision 1.4
retrieving revision 1.4.182.1
diff -u -u -p -b -w -B -r1.4 -r1.4.182.1
--- sal/typesconfig/typesconfig.c	24 Oct 2006 13:28:51 -0000	1.4
+++ sal/typesconfig/typesconfig.c	14 Feb 2008 09:28:39 -0000	1.4.182.1
@@ -214,6 +214,16 @@ int check( TestFunc func, Type eT, void*
 *************************************************************************/
 int GetAtAddress( Type eT, void* p )
 {
+#if defined(IA64) || defined(ARM32)
+  switch ( eT )
+  {
+  case t_char:		return *((char*)p);
+  case t_short:		if ((long)p % sizeof(short)) abort(); else return *((short*)p);
+  case t_int:		if ((long)p % sizeof(int)) abort(); else return *((int*)p);
+  case t_long:		if ((long)p % sizeof(long)) abort(); else return *((long*)p);
+  case t_double:	if ((long)p % sizeof(double)) abort(); else return *((double*)p);
+  }
+#else
   switch ( eT )
   {
   case t_char:		return *((char*)p);
@@ -222,6 +232,7 @@ int GetAtAddress( Type eT, void* p )
   case t_long:		return *((long*)p);
   case t_double:	return *((double*)p);
   }
+#endif
   abort();
 }
 
cvs diff: Diffing sal/util
cvs diff: Diffing sal/workben
cvs diff: Diffing sal/workben/clipboardwben
cvs diff: Diffing sal/workben/clipboardwben/testcopy
cvs diff: Diffing sal/workben/clipboardwben/testpaste
cvs diff: Diffing sal/workben/clipboardwben/testviewer
cvs diff: Diffing cppu
cvs diff: Diffing cppu/inc
cvs diff: Diffing cppu/inc/com
cvs diff: Diffing cppu/inc/com/sun
cvs diff: Diffing cppu/inc/com/sun/star
cvs diff: Diffing cppu/inc/com/sun/star/uno
cvs diff: Diffing cppu/inc/cppu
cvs diff: Diffing cppu/inc/cppu/helper
cvs diff: Diffing cppu/inc/cppu/helper/purpenv
cvs diff: Diffing cppu/inc/pch
cvs diff: Diffing cppu/inc/typelib
cvs diff: Diffing cppu/inc/uno
cvs diff: Diffing cppu/prj
cvs diff: Diffing cppu/qa
cvs diff: Diffing cppu/source
cvs diff: Diffing cppu/source/AffineBridge
cvs diff: Diffing cppu/source/UnsafeBridge
cvs diff: Diffing cppu/source/cppu
cvs diff: Diffing cppu/source/helper
cvs diff: Diffing cppu/source/helper/purpenv
cvs diff: Diffing cppu/source/threadpool
cvs diff: Diffing cppu/source/typelib
cvs diff: Diffing cppu/source/uno
cvs diff: Diffing cppu/test
Index: cppu/test/language_binding.idl
===================================================================
RCS file: /cvs/udk/cppu/test/language_binding.idl,v
retrieving revision 1.3
retrieving revision 1.3.130.1
diff -u -u -p -b -w -B -r1.3 -r1.3.130.1
--- cppu/test/language_binding.idl	8 Sep 2005 08:55:54 -0000	1.3
+++ cppu/test/language_binding.idl	16 Feb 2008 15:27:58 -0000	1.3.130.1
@@ -71,6 +71,49 @@ struct TestSimple
 	test::TestEnum			   Enum;
 };
 /**
+ * equal to max size returned in registers on x86_64
+ */
+struct SmallStruct
+{
+	hyper					   a;
+	hyper					   b;
+};
+/**
+ * equal to max size returned in registers on ia64
+ */
+struct MediumStruct
+{
+	hyper					   a;
+	hyper					   b;
+	hyper					   c;
+	hyper					   d;
+};
+/**
+ * bigger than max size returned in registers on ia64
+ */
+struct BigStruct
+{
+	hyper					   a;
+	hyper					   b;
+	hyper					   c;
+	hyper					   d;
+	hyper					   e;
+	hyper					   f;
+	hyper					   g;
+	hyper					   h;
+};
+/**
+ * all floats, ia64 claims to handle them specially
+ */
+struct AllFloats
+{
+	float					   a;
+	float					   b;
+	float					   c;
+	float					   d;
+};
+
+/**
  * complex c++ types
  */
 struct TestElement : test::TestSimple
@@ -131,6 +174,26 @@ interface XLBTestBase : com::sun::star::
 							  [out] sequence<test::TestElement > aSequence,
 							  [out] test::TestData aStruct );
 	
+	/**
+	 * register return test 1
+	 */
+	test::SmallStruct echoSmallStruct( [in] test::SmallStruct aStruct );
+
+	/**
+	 * register return test 2
+	 */
+	test::MediumStruct echoMediumStruct( [in] test::MediumStruct aStruct );
+
+	/**
+	 * register return test 3
+	 */
+	test::BigStruct echoBigStruct( [in] test::BigStruct aStruct );
+
+	/**
+	 * register return test 4
+	 */
+	test::AllFloats echoAllFloats( [in] test::AllFloats aStruct );
+	
 	[attribute] boolean					 Bool;
 	[attribute] byte					 Byte;
 	[attribute] char					 Char;
Index: cppu/test/test_di.cxx
===================================================================
RCS file: /cvs/udk/cppu/test/test_di.cxx,v
retrieving revision 1.19
retrieving revision 1.19.64.1
diff -u -u -p -b -w -B -r1.19 -r1.19.64.1
--- cppu/test/test_di.cxx	27 Oct 2006 12:16:06 -0000	1.19
+++ cppu/test/test_di.cxx	16 Feb 2008 15:27:58 -0000	1.19.64.1
@@ -42,6 +42,7 @@
 #include "precompiled_cppu.hxx"
 
 #include <stdio.h>
+#include <string.h>
 #include <rtl/ustring.hxx>
 #include <osl/diagnose.h>
 #include <osl/time.h>
@@ -237,6 +238,15 @@ public:
 											   test::TestData& rStruct )
 		throw(com::sun::star::uno::RuntimeException);
 	
+	virtual test::SmallStruct echoSmallStruct(const test::SmallStruct& rStruct) throw(com::sun::star::uno::RuntimeException)
+		{ return rStruct; }
+	virtual test::MediumStruct echoMediumStruct(const test::MediumStruct& rStruct) throw(com::sun::star::uno::RuntimeException)
+		{ return rStruct; }
+	virtual test::BigStruct echoBigStruct(const test::BigStruct& rStruct) throw(com::sun::star::uno::RuntimeException)
+		{ return rStruct; }
+	virtual test::AllFloats echoAllFloats(const test::AllFloats& rStruct) throw(com::sun::star::uno::RuntimeException)
+		{ return rStruct; }
+	
     virtual sal_Bool SAL_CALL getBool() throw(com::sun::star::uno::RuntimeException)
 		{ return _aData.Bool; }
     virtual sal_Int8 SAL_CALL getByte() throw(com::sun::star::uno::RuntimeException)
@@ -493,7 +503,27 @@ static sal_Bool performTest(
 		aRet.Sequence = xLBT->getSequence();
 		aRet2 = xLBT->getStruct();
 		
-		return (equals( aData, aRet ) && equals( aData, aRet2 ));
+	        OSL_ASSERT( equals( aData, aRet ) && equals( aData, aRet2 ) );
+		}
+		{
+			test::SmallStruct aIn(1, 2);
+			test::SmallStruct aOut = xLBT->echoSmallStruct(aIn);
+			OSL_ASSERT( memcmp(&aIn, &aOut, sizeof(test::SmallStruct)) == 0 );
+		}
+		{
+			test::MediumStruct aIn(1, 2, 3, 4);
+			test::MediumStruct aOut = xLBT->echoMediumStruct(aIn);
+			OSL_ASSERT( memcmp(&aIn, &aOut, sizeof(test::MediumStruct)) == 0 );
+		}
+		{
+			test::BigStruct aIn(1, 2, 3, 4, 5, 6, 7, 8);
+			test::BigStruct aOut = xLBT->echoBigStruct(aIn);
+			OSL_ASSERT( memcmp(&aIn, &aOut, sizeof(test::BigStruct)) == 0 );
+		}
+		{
+			test::AllFloats aIn(1.1, 2.2, 3.3, 4.4);
+			test::AllFloats aOut = xLBT->echoAllFloats(aIn);
+			return( memcmp(&aIn, &aOut, sizeof(test::AllFloats)) == 0 );
 		}
 	}
 	return sal_False;
Index: cppu/test/testcppu.cxx
===================================================================
RCS file: /cvs/udk/cppu/test/testcppu.cxx,v
retrieving revision 1.34
retrieving revision 1.34.56.1
diff -u -u -p -b -w -B -r1.34 -r1.34.56.1
--- cppu/test/testcppu.cxx	1 Dec 2006 17:27:07 -0000	1.34
+++ cppu/test/testcppu.cxx	16 Feb 2008 15:27:58 -0000	1.34.56.1
@@ -80,6 +80,7 @@
 #include <com/sun/star/beans/PropertyValue.hpp>
 #include <test/XSimpleInterface.hpp>
 #include <test/XLanguageBindingTest.hpp>
+#include <com/sun/star/registry/XSimpleRegistry.hpp>
 
 using namespace test;
 using namespace rtl;
cvs diff: Diffing cppu/test/AffineBridge
cvs diff: Diffing cppu/test/AntiEnvGuard
cvs diff: Diffing cppu/test/EnvDcp
cvs diff: Diffing cppu/test/EnvGuard
cvs diff: Diffing cppu/test/EnvStack
cvs diff: Diffing cppu/test/EnvStack_tester
cvs diff: Diffing cppu/test/FreeReference
cvs diff: Diffing cppu/test/Map
cvs diff: Diffing cppu/test/ObjectFactory
cvs diff: Diffing cppu/test/Shield
cvs diff: Diffing cppu/test/UnsafeBridge
cvs diff: Diffing cppu/test/alignment
cvs diff: Diffing cppu/test/cascade_mapping
cvs diff: Diffing cppu/test/env_substs
cvs diff: Diffing cppu/test/env_tester
cvs diff: Diffing cppu/test/mapping_tester
cvs diff: Diffing cppu/test/purpenvhelper
cvs diff: Diffing cppu/test/purpose_envs
cvs diff: Diffing cppu/util
