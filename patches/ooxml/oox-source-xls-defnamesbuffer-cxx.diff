--- /dev/null	
+++ oox/source/xls/defnamesbuffer.cxx	
@@ -0,0 +1,429 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: defnamesbuffer.cxx,v $
+ *
+ *  $Revision: 1.1.2.5 $
+ *
+ *  last change: $Author: dr $ $Date: 2007/07/10 15:57:16 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "oox/xls/defnamesbuffer.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <com/sun/star/sheet/XNamedRanges.hpp>
+#include <com/sun/star/sheet/XFormulaTokens.hpp>
+#include <com/sun/star/sheet/XPrintAreas.hpp>
+#include <com/sun/star/sheet/NamedRangeFlag.hpp>
+#include "tokens.hxx"
+#include "oox/core/attributelist.hxx"
+#include "oox/core/wrappedpropertyset.hxx"
+#include "oox/xls/biffinputstream.hxx"
+#include "oox/xls/formulaparser.hxx"
+#include "oox/xls/addressconverter.hxx"
+
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::container::XNameAccess;
+using ::com::sun::star::table::CellAddress;
+using ::com::sun::star::table::CellRangeAddress;
+using ::com::sun::star::sheet::XNamedRanges;
+using ::com::sun::star::sheet::XPrintAreas;
+using ::oox::core::AttributeList;
+using ::oox::core::ContainerHelper;
+using ::oox::core::WrappedPropertySet;
+
+namespace oox {
+namespace xls {
+
+// ============================================================================
+
+OoxDefinedNameData::OoxDefinedNameData() :
+    mnSheet( -1 ),
+    mbMacro( false ),
+    mbFunction( false ),
+    mbVBName( false ),
+    mbHidden( false )
+{
+}
+
+// ============================================================================
+
+namespace {
+
+const sal_Char* const spcLegacyPrefix = "Excel_BuiltIn_";
+const sal_Char* const spcFinalPrefix = "Excel Built-in ";
+const sal_Char* const spcOoxPrefix = "_xlnm.";
+
+const sal_Char* const sppcBaseNames[] =
+{
+    "Consolidate_Area", /* OOX */
+    "Auto_Open",
+    "Auto_Close",
+    "Extract",          /* OOX */
+    "Database",         /* OOX */
+    "Criteria",         /* OOX */
+    "Print_Area",       /* OOX */
+    "Print_Titles",     /* OOX */
+    "Recorder",
+    "Data_Form",
+    "Auto_Activate",
+    "Auto_Deactivate",
+    "Sheet_Title",      /* OOX */
+    "_FilterDatabase"   /* OOX */
+};
+
+OUString lclGetBaseName( sal_Unicode cBuiltinId )
+{
+    OSL_ENSURE( (0 <= cBuiltinId) && (cBuiltinId < STATIC_TABLE_SIZE( sppcBaseNames )), "lclGetBaseName - unknown builtin name" );
+    OUStringBuffer aBuffer;
+    if( cBuiltinId < STATIC_TABLE_SIZE( sppcBaseNames ) )
+        aBuffer.appendAscii( sppcBaseNames[ cBuiltinId ] );
+    else
+        aBuffer.append( static_cast< sal_Int32 >( cBuiltinId ) );
+    return aBuffer.makeStringAndClear();
+}
+
+OUString lclGetFinalName( sal_Unicode cBuiltinId )
+{
+    return OUStringBuffer().appendAscii( spcFinalPrefix ).append( lclGetBaseName( cBuiltinId ) ).makeStringAndClear();
+}
+
+sal_Unicode lclGetBuiltinIdFromOox( const OUString& rOoxName )
+{
+    OUString aPrefix = OUString::createFromAscii( spcOoxPrefix );
+    sal_Int32 nPrefixLen = aPrefix.getLength();
+    if( rOoxName.matchIgnoreAsciiCase( aPrefix ) )
+    {
+        for( sal_Unicode cBuiltinId = 0; cBuiltinId < STATIC_TABLE_SIZE( sppcBaseNames ); ++cBuiltinId )
+        {
+            OUString aBaseName = lclGetBaseName( cBuiltinId );
+            sal_Int32 nBaseNameLen = aBaseName.getLength();
+            if( (rOoxName.getLength() == nPrefixLen + nBaseNameLen) && rOoxName.matchIgnoreAsciiCase( aBaseName, nPrefixLen ) )
+                return cBuiltinId;
+        }
+    }
+    return BIFF_BUILTIN_UNKNOWN;
+}
+
+} // namespace
+
+// ----------------------------------------------------------------------------
+
+DefinedName::DefinedName( const GlobalDataHelper& rGlobalData ) :
+    GlobalDataHelper( rGlobalData ),
+    mnApiIndex( -1 ),
+    mcBuiltinId( BIFF_BUILTIN_UNKNOWN ),
+    mpStrm( 0 ),
+    mnRecHandle( -1 ),
+    mnRecPos( 0 ),
+    mnFmlaSize( 0 )
+{
+}
+
+void DefinedName::importDefinedName( const AttributeList& rAttribs )
+{
+    maOoxData.maName = rAttribs.getString( XML_name );
+    maOoxData.mnSheet = rAttribs.getInteger( XML_localSheetId, -1 );
+    maOoxData.mbMacro = rAttribs.getBool( XML_xlm, false );
+    maOoxData.mbFunction = maOoxData.mbMacro && rAttribs.getBool( XML_function, false );
+    maOoxData.mbVBName = maOoxData.mbMacro && rAttribs.getBool( XML_vbProcedure, false );
+    maOoxData.mbHidden = rAttribs.getBool( XML_hidden, false );
+    mcBuiltinId = lclGetBuiltinIdFromOox( maOoxData.maName );
+}
+
+void DefinedName::setFormula( const OUString& rFormula )
+{
+    maOoxData.maFormula = rFormula;
+}
+
+void DefinedName::importName( BiffInputStream& rStrm )
+{
+    BiffType eBiff = getBiff();
+    sal_uInt16 nFlags = 0, nRefId = BIFF_NAME_GLOBAL, nTab = BIFF_NAME_GLOBAL;
+    sal_uInt8 nNameLen = 0, nShortCut = 0;
+
+    switch( eBiff )
+    {
+        case BIFF2:
+        {
+            sal_uInt8 nFlagsBiff2;
+            rStrm >> nFlagsBiff2;
+            rStrm.ignore( 1 );
+            rStrm >> nShortCut >> nNameLen;
+            mnFmlaSize = rStrm.readuInt8();
+            setFlag( nFlags, BIFF_NAME_FUNC, getFlag( nFlagsBiff2, BIFF_NAME2_FUNC ) );
+            maOoxData.maName = rStrm.readRawByteString( nNameLen, getTextEncoding() );
+        }
+        break;
+        case BIFF3:
+        case BIFF4:
+            rStrm >> nFlags >> nShortCut >> nNameLen >> mnFmlaSize;
+            maOoxData.maName = rStrm.readRawByteString( nNameLen, getTextEncoding() );
+        break;
+        case BIFF5:
+            rStrm >> nFlags >> nShortCut >> nNameLen >> mnFmlaSize >> nRefId >> nTab;
+            rStrm.ignore( 4 );
+            maOoxData.maName = rStrm.readRawByteString( nNameLen, getTextEncoding() );
+        break;
+        case BIFF8:
+            rStrm >> nFlags >> nShortCut >> nNameLen >> mnFmlaSize >> nRefId >> nTab;
+            rStrm.ignore( 4 );
+            maOoxData.maName = rStrm.readUniString( nNameLen );
+        break;
+        case BIFF_UNKNOWN: break;
+    }
+
+    // macro function/command
+    maOoxData.mbMacro = getFlag( nFlags, BIFF_NAME_MACRO );
+    maOoxData.mbFunction = maOoxData.mbMacro && getFlag( nFlags, BIFF_NAME_FUNC );
+    maOoxData.mbVBName = maOoxData.mbMacro && getFlag( nFlags, BIFF_NAME_VBNAME );
+
+    // get builtin name index from name
+    if( getFlag( nFlags, BIFF_NAME_BUILTIN ) )
+    {
+        OSL_ENSURE( maOoxData.maName.getLength() == 1, "DefinedName::importName - wrong builtin name" );
+        if( maOoxData.maName.getLength() > 0 )
+        {
+            mcBuiltinId = maOoxData.maName[ 0 ];
+            if( mcBuiltinId == '?' )      // the NUL character is imported as '?'
+                mcBuiltinId = BIFF_BUILTIN_CONSOLIDATEAREA;
+        }
+    }
+    else if( (eBiff == BIFF5) && maOoxData.maName.equalsIgnoreAsciiCase( lclGetBaseName( BIFF_BUILTIN_FILTERDATABASE ) ) )
+    {
+        // special case for BIFF5 filter range - name appears as plain text without built-in flag
+        mcBuiltinId = BIFF_BUILTIN_FILTERDATABASE;
+    }
+
+    // get sheet index for local names
+    // #i44019# nTab may be invalid in BIFF5 //! TODO: resolve nRefId to sheet index
+    sal_Int32 nUsedTab = (eBiff == BIFF8) ? nTab : nRefId;
+    maOoxData.mnSheet = (nUsedTab == BIFF_NAME_GLOBAL) ? -1 : (nUsedTab - 1);
+
+    // store record position to be able to import token array later
+    mpStrm = &rStrm;
+    mnRecHandle = rStrm.getRecHandle();
+    mnRecPos = rStrm.getRecPos();
+}
+
+void DefinedName::createNameObject()
+{
+    // do not create hidden names and names for (macro) functions
+    if( maOoxData.mbHidden || maOoxData.mbFunction )
+        return;
+
+    // convert original name to final Calc name
+    if( maOoxData.mbVBName )
+        maFinalName = maOoxData.maName;
+    else if( isBuiltinName() )
+        maFinalName = lclGetFinalName( mcBuiltinId );
+    else
+        maFinalName = maOoxData.maName;         //! TODO convert to valid name
+
+    // append sheet index for local names
+    if( !isGlobalName() )
+        maFinalName = OUStringBuffer( maFinalName ).append( sal_Unicode( ' ' ) ).append( maOoxData.mnSheet + 1 ).makeStringAndClear();
+
+    // find an unused name
+    WrappedPropertySet aDocProp( getDocument() );
+    Reference< XNamedRanges > xNamedRanges;
+    aDocProp.getProperty( xNamedRanges, CREATE_OUSTRING( "NamedRanges" ) );
+    Reference< XNameAccess > xNameAccess( xNamedRanges, UNO_QUERY );
+    if( xNameAccess.is() )
+        maFinalName = ContainerHelper::getUnusedName( xNameAccess, maFinalName );
+
+    // create and insert the name
+    if( xNamedRanges.is() && (maFinalName.getLength() > 0) )
+    {
+        sal_Int32 nNameType = 0;
+        using namespace ::com::sun::star::sheet::NamedRangeFlag;
+        if( !isGlobalName() ) switch( mcBuiltinId )
+        {
+            case BIFF_BUILTIN_CRITERIA:     nNameType = FILTER_CRITERIA;            break;
+            case BIFF_BUILTIN_PRINTAREA:    nNameType = PRINT_AREA;                 break;
+            case BIFF_BUILTIN_PRINTTITLES:  nNameType = COLUMN_HEADER | ROW_HEADER; break;
+        }
+
+        try
+        {
+            xNamedRanges->addNewByName( maFinalName, OUString(), CellAddress( 0, 0, 0 ), nNameType );
+            mxTokens.set( xNamedRanges->getByName( maFinalName ), UNO_QUERY_THROW );
+            WrappedPropertySet aPropSet( mxTokens );
+            if( !aPropSet.getProperty( mnApiIndex, CREATE_OUSTRING( "TokenIndex" ) ) )
+                mnApiIndex = -1;
+        }
+        catch( Exception& )
+        {
+            OSL_ENSURE( false, "DefinedName::createNameObject - cannot create defined name" );
+        }
+    }
+}
+
+void DefinedName::convertFormula()
+{
+    if( mxTokens.is() )
+    {
+        // convert and set formula of the defined name
+        NameFormulaContext aContext( mxTokens );
+        switch( getFilterType() )
+        {
+            case FILTER_OOX:
+                getFormulaParser().importFormula( aContext, maOoxData.maFormula );
+            break;
+            case FILTER_BIFF:
+            {
+                OSL_ENSURE( mpStrm, "DefinedName::convertFormula - missing BIFF stream" );
+                sal_Int64 nCurrRecHandle = mpStrm->getRecHandle();
+                if( mpStrm->startRecordByHandle( mnRecHandle ) )
+                {
+                    mpStrm->seek( mnRecPos );
+                    getFormulaParser().importFormula( aContext, *mpStrm, mnFmlaSize );
+                }
+                mpStrm->startRecordByHandle( nCurrRecHandle );
+            }
+            break;
+            case FILTER_UNKNOWN: break;
+        }
+
+        // set builtin names (print ranges, repeated titles, filter ranges)
+        if( !isGlobalName() ) switch( mcBuiltinId )
+        {
+            case BIFF_BUILTIN_PRINTAREA:
+            {
+                Reference< XPrintAreas > xPrintAreas( getSheet( maOoxData.mnSheet ), UNO_QUERY );
+                Sequence< CellRangeAddress > aPrintRanges =
+                    getFormulaParser().convertToCellRangeList( mxTokens->getTokens(), maOoxData.mnSheet );
+                if( xPrintAreas.is() && aPrintRanges.hasElements() )
+                    xPrintAreas->setPrintAreas( aPrintRanges );
+            }
+            break;
+            case BIFF_BUILTIN_PRINTTITLES:
+            {
+                Reference< XPrintAreas > xPrintAreas( getSheet( maOoxData.mnSheet ), UNO_QUERY );
+                Sequence< CellRangeAddress > aTitleRanges =
+                    getFormulaParser().convertToCellRangeList( mxTokens->getTokens(), maOoxData.mnSheet );
+                if( xPrintAreas.is() && aTitleRanges.hasElements() )
+                {
+                    bool bHasRowTitles = false;
+                    bool bHasColTitles = false;
+                    const CellAddress& rMaxPos = getAddressConverter().getMaxAddress();
+                    const CellRangeAddress* pTitleRange = aTitleRanges.getConstArray();
+                    const CellRangeAddress* pTitleRangeEnd = pTitleRange + aTitleRanges.getLength();
+                    for( ; (pTitleRange != pTitleRangeEnd) && (!bHasRowTitles || !bHasColTitles); ++pTitleRange )
+                    {
+                        bool bFullRow = (pTitleRange->StartColumn == 0) && (pTitleRange->EndColumn >= rMaxPos.Column);
+                        bool bFullCol = (pTitleRange->StartRow == 0) && (pTitleRange->EndRow >= rMaxPos.Row);
+                        if( !bHasRowTitles && bFullRow && !bFullCol )
+                        {
+                            xPrintAreas->setTitleRows( *pTitleRange );
+                            xPrintAreas->setPrintTitleRows( sal_True );
+                            bHasRowTitles = true;
+                        }
+                        else if( !bHasColTitles && bFullCol && !bFullRow )
+                        {
+                            xPrintAreas->setTitleColumns( *pTitleRange );
+                            xPrintAreas->setPrintTitleColumns( sal_True );
+                            bHasColTitles = true;
+                        }
+                    }
+                }
+            }
+            break;
+        }
+    }
+}
+
+// ============================================================================
+
+DefinedNamesBuffer::DefinedNamesBuffer( const GlobalDataHelper& rGlobalData ) :
+    GlobalDataHelper( rGlobalData )
+{
+}
+
+DefinedNameRef DefinedNamesBuffer::importDefinedName( const AttributeList& rAttribs )
+{
+    DefinedNameRef xDefName = createDefinedName();
+    xDefName->importDefinedName( rAttribs );
+    return xDefName;
+}
+
+void DefinedNamesBuffer::importName( BiffInputStream& rStrm )
+{
+    DefinedNameRef xDefName = createDefinedName();
+    xDefName->importName( rStrm );
+}
+
+void DefinedNamesBuffer::finalizeImport()
+{
+    /*  First insert all names without formula definition into the document. */
+    maDefNames.forEachMem( &DefinedName::createNameObject );
+    /*  Now convert all name formulas, so that the formula parser can find all
+        names in case of circular dependencies. */
+    maDefNames.forEachMem( &DefinedName::convertFormula );
+}
+
+DefinedNameRef DefinedNamesBuffer::getByBiffIndex( sal_uInt16 nIndex ) const
+{
+    OSL_ENSURE( nIndex > 0, "DefinedNamesBuffer::getByBiffIndex - invalid name index" );
+    return maDefNames.get( static_cast< sal_Int32 >( nIndex ) - 1 );
+}
+
+DefinedNameRef DefinedNamesBuffer::getByOoxName( const OUString& rOoxName, sal_Int32 nSheet ) const
+{
+    DefinedNameRef xGlobalName;   // a found global name
+    DefinedNameRef xLocalName;    // a found local name
+    for( DefNameVec::const_iterator aIt = maDefNames.begin(), aEnd = maDefNames.end(); (aIt != aEnd) && !xLocalName; ++aIt )
+    {
+        DefinedNameRef xCurrName = *aIt;
+        if( xCurrName->getOoxName() == rOoxName )
+        {
+            if( xCurrName->getSheetIndex() == nSheet )
+                xLocalName = xCurrName;
+            else if( xCurrName->isGlobalName() )
+                xGlobalName = xCurrName;
+        }
+    }
+    return xLocalName.get() ? xLocalName : xGlobalName;
+}
+
+DefinedNameRef DefinedNamesBuffer::createDefinedName()
+{
+    DefinedNameRef xDefName( new DefinedName( getGlobalData() ) );
+    maDefNames.push_back( xDefName );
+    return xDefName;
+}
+
+// ============================================================================
+
+} // namespace xls
+} // namespace oox
+
