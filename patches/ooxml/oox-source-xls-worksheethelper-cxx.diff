--- /dev/null	
+++ oox/source/xls/worksheethelper.cxx	
@@ -0,0 +1,750 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: worksheethelper.cxx,v $
+ *
+ *  $Revision: 1.1.2.24 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/07/10 15:01:36 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "oox/xls/worksheethelper.hxx"
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/util/XMergeable.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/sheet/XFormulaTokens.hpp>
+#include <com/sun/star/sheet/XSheetOutline.hpp>
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/style/XStyle.hpp>
+#include "oox/core/containerhelper.hxx"
+#include "oox/core/wrappedpropertyset.hxx"
+#include "oox/xls/globaldatahelper.hxx"
+#include "oox/xls/addressconverter.hxx"
+#include "oox/xls/unitconverter.hxx"
+#include "oox/xls/stylesbuffer.hxx"
+#include "oox/xls/formulaparser.hxx"
+#include "oox/xls/pagestyle.hxx"
+#include "oox/xls/viewsettings.hxx"
+
+using ::rtl::OUString;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::lang::XMultiServiceFactory;
+using ::com::sun::star::container::XIndexAccess;
+using ::com::sun::star::container::XNamed;
+using ::com::sun::star::container::XNameAccess;
+using ::com::sun::star::container::XNameContainer;
+using ::com::sun::star::util::XMergeable;
+using ::com::sun::star::table::CellAddress;
+using ::com::sun::star::table::CellRangeAddress;
+using ::com::sun::star::table::XColumnRowRange;
+using ::com::sun::star::table::XTableColumns;
+using ::com::sun::star::table::XTableRows;
+using ::com::sun::star::table::XCell;
+using ::com::sun::star::table::XCellRange;
+using ::com::sun::star::sheet::XSpreadsheet;
+using ::com::sun::star::sheet::XCellAddressable;
+using ::com::sun::star::sheet::XCellRangeAddressable;
+using ::com::sun::star::sheet::XFormulaTokens;
+using ::com::sun::star::sheet::XSheetOutline;
+using ::com::sun::star::style::XStyleFamiliesSupplier;
+using ::com::sun::star::style::XStyle;
+using ::oox::core::WrappedPropertySet;
+using ::oox::core::ContainerHelper;
+
+namespace oox {
+namespace xls {
+
+// ============================================================================
+
+OoxColumnData::OoxColumnData() :
+    mnFirstCol( -1 ),
+    mnLastCol( -1 ),
+    mfWidth( 0.0 ),
+    mnXfId( -1 ),
+    mnLevel( 0 ),
+    mbHidden( false ),
+    mbCollapsed( false )
+{
+}
+
+// ----------------------------------------------------------------------------
+
+OoxRowData::OoxRowData() :
+    mnRow( -1 ),
+    mfHeight( 0.0 ),
+    mnXfId( -1 ),
+    mnLevel( 0 ),
+    mbFormatted( false ),
+    mbHidden( false ),
+    mbCollapsed( false )
+{
+}
+
+// ----------------------------------------------------------------------------
+
+OoxPageBreakData::OoxPageBreakData() :
+    mnColRow( 0 ),
+    mbManual( false )
+{
+}
+
+// ============================================================================
+// ============================================================================
+
+struct WorksheetHelperImpl
+{
+    typedef ::std::map< ::rtl::OUString, sal_uInt8 >    ErrorCodeMap;
+    typedef ::std::map< sal_Int32, OoxColumnData >      OoxColumnDataMap;
+    typedef ::std::map< sal_Int32, OoxRowData >         OoxRowDataMap;
+    typedef ::std::vector< sal_Int32 >                  OutlineLevelVec;
+
+    const GlobalDataHelper& mrGlobalData;   /// Reference to global data helper.
+    const OUString      maTrueFormula;      /// Replacement formula for TRUE boolean cells.
+    const OUString      maFalseFormula;     /// Replacement formula for FALSE boolean cells.
+    const OUString      maWidthProp;        /// Property name for column width.
+    const OUString      maHeightProp;       /// Property name for row height.
+    const OUString      maVisibleProp;      /// Property name for column/row visibility.
+    const OUString      maPageBreakProp;    /// Property name of a page break.
+    const CellAddress&  mrMaxApiPos;        /// Reference to maximum Calc cell address from address converter.
+    ErrorCodeMap        maErrorCodes;       /// Maps error code strings to BIFF error constants.
+    OoxColumnData       maDefColData;       /// Default column formatting.
+    OoxColumnDataMap    maColDatas;         /// Column data sorted by first column index.
+    OoxRowData          maDefRowData;       /// Default row formatting.
+    OoxRowDataMap       maRowDatas;         /// Row data sorted by row index.
+    PageStyle           maPageStyle;        /// Page style object for this sheet.
+    const WorksheetType meSheetType;        /// Type of thes sheet.
+    Reference< XSpreadsheet > mxSheet;      /// Reference to the current sheet.
+    const sal_Int16     mnSheet;            /// Index of the current sheet.
+    bool                mbHasDefWidth;      /// True = default column width is set from defaultColWidth attribute.
+    bool                mbSummaryRight;     /// True = column outline summary symbol right of group.
+    bool                mbSummaryBelow;     /// True = row outline summary symbol below group.
+
+    explicit            WorksheetHelperImpl(
+                            const GlobalDataHelper& rGlobalData,
+                            WorksheetType eSheetType,
+                            const Reference< XSpreadsheet >& rxSheet,
+                            sal_Int16 nSheet );
+
+    /** Returns the XCell interface for the passed cell address. */
+    Reference< XCell >  getCell( const CellAddress& rAddress ) const;
+    /** Returns the XCellRange interface for the passed cell range address. */
+    Reference< XCellRange > getCellRange( const CellRangeAddress& rRange ) const;
+
+    /** Returns the XTableColumns interface for a range of columns. */
+    Reference< XTableColumns > getColumns( sal_Int32 nFirstCol, sal_Int32 nLastCol ) const;
+    /** Returns the XTableRows interface for a range of rows. */
+    Reference< XTableRows > getRows( sal_Int32 nFirstRow, sal_Int32 nLastRow ) const;
+
+    /** Converts imported page style properties and inserts a page style into current sheet. */
+    void                convertPageStyle();
+
+    /** Converts column properties for all columns in the sheet. */
+    void                convertColumns();
+    /** Converts column properties. */
+    void                convertColumns( OutlineLevelVec& orColLevels, sal_Int32 nFirstCol, sal_Int32 nLastCol, const OoxColumnData& rData );
+
+    /** Converts row properties for all rows in the sheet. */
+    void                convertRows();
+    /** Converts row properties. */
+    void                convertRows( OutlineLevelVec& orRowLevels, sal_Int32 nFirstRow, sal_Int32 nLastRow, const OoxRowData& rData );
+
+    /** Converts outline grouping for the passed column or row. */
+    void                convertOutlines( OutlineLevelVec& orLevels, sal_Int32 nColRow, sal_Int32 nLevel, bool bCollapsed, bool bRows );
+    /** Groups columns or rows for the given range. */
+    void                groupColumnsOrRows( sal_Int32 nFirstColRow, sal_Int32 nLastColRow, bool bCollapsed, bool bRows );
+};
+
+// ----------------------------------------------------------------------------
+
+WorksheetHelperImpl::WorksheetHelperImpl( const GlobalDataHelper& rGlobalData,
+        WorksheetType eSheetType, const Reference< XSpreadsheet >& rxSheet, sal_Int16 nSheet ) :
+    mrGlobalData( rGlobalData ),
+    maTrueFormula( CREATE_OUSTRING( "=TRUE()" ) ),
+    maFalseFormula( CREATE_OUSTRING( "=FALSE()" ) ),
+    maWidthProp( CREATE_OUSTRING( "Width" ) ),
+    maHeightProp( CREATE_OUSTRING( "Height" ) ),
+    maVisibleProp( CREATE_OUSTRING( "IsVisible" ) ),
+    maPageBreakProp( CREATE_OUSTRING( "IsStartOfNewPage" ) ),
+    mrMaxApiPos( rGlobalData.getAddressConverter().getMaxApiAddress() ),
+    maPageStyle( rGlobalData ),
+    meSheetType( eSheetType ),
+    mxSheet( rxSheet ),
+    mnSheet( nSheet ),
+    mbHasDefWidth( false ),
+    mbSummaryRight( true ),
+    mbSummaryBelow( true )
+{
+    maErrorCodes[ CREATE_OUSTRING( "#NULL!" ) ]  = BIFF_ERR_NULL;
+    maErrorCodes[ CREATE_OUSTRING( "#DIV/0!" ) ] = BIFF_ERR_DIV0;
+    maErrorCodes[ CREATE_OUSTRING( "#VALUE!" ) ] = BIFF_ERR_VALUE;
+    maErrorCodes[ CREATE_OUSTRING( "#REF!" ) ]   = BIFF_ERR_REF;
+    maErrorCodes[ CREATE_OUSTRING( "#NAME?" ) ]  = BIFF_ERR_NAME;
+    maErrorCodes[ CREATE_OUSTRING( "#NUM!" ) ]   = BIFF_ERR_NUM;
+    maErrorCodes[ CREATE_OUSTRING( "#NA" ) ]     = BIFF_ERR_NA;
+
+    // default column settings (width and hidden state may be updated later)
+    maDefColData.mfWidth = 8.5;
+    maDefColData.mnXfId = -1;
+    maDefColData.mnLevel = 0;
+    maDefColData.mbHidden = false;
+    maDefColData.mbCollapsed = false;
+
+    // default row settings (height and hidden state may be updated later)
+    maDefRowData.mfHeight = 0.0;
+    maDefRowData.mnXfId = -1;
+    maDefRowData.mnLevel = 0;
+    maDefRowData.mbFormatted = false;
+    maDefRowData.mbHidden = false;
+    maDefRowData.mbCollapsed = false;
+}
+
+Reference< XCell > WorksheetHelperImpl::getCell( const CellAddress& rAddress ) const
+{
+    Reference< XCell > xCell;
+    try
+    {
+        xCell = mxSheet->getCellByPosition( rAddress.Column, rAddress.Row );
+    }
+    catch( Exception& )
+    {
+    }
+    return xCell;
+}
+
+Reference< XCellRange > WorksheetHelperImpl::getCellRange( const CellRangeAddress& rRange ) const
+{
+    Reference< XCellRange > xRange;
+    try
+    {
+        xRange = mxSheet->getCellRangeByPosition( rRange.StartColumn, rRange.StartRow, rRange.EndColumn, rRange.EndRow );
+    }
+    catch( Exception& )
+    {
+    }
+    return xRange;
+}
+
+Reference< XTableColumns > WorksheetHelperImpl::getColumns( sal_Int32 nFirstCol, sal_Int32 nLastCol ) const
+{
+    Reference< XTableColumns > xColumns;
+    nLastCol = ::std::min( nLastCol, mrMaxApiPos.Column );
+    if( (0 <= nFirstCol) && (nFirstCol <= nLastCol) )
+    {
+        Reference< XColumnRowRange > xRange( getCellRange( CellRangeAddress( mnSheet, nFirstCol, 0, nLastCol, 0 ) ), UNO_QUERY );
+        if( xRange.is() )
+            xColumns = xRange->getColumns();
+    }
+    return xColumns;
+}
+
+Reference< XTableRows > WorksheetHelperImpl::getRows( sal_Int32 nFirstRow, sal_Int32 nLastRow ) const
+{
+    Reference< XTableRows > xRows;
+    nLastRow = ::std::min( nLastRow, mrMaxApiPos.Row );
+    if( (0 <= nFirstRow) && (nFirstRow <= nLastRow) )
+    {
+        Reference< XColumnRowRange > xRange( getCellRange( CellRangeAddress( mnSheet, 0, nFirstRow, 0, nLastRow ) ), UNO_QUERY );
+        if( xRange.is() )
+            xRows = xRange->getRows();
+    }
+    return xRows;
+}
+
+void WorksheetHelperImpl::convertPageStyle()
+{
+    try
+    {
+        Reference< XStyleFamiliesSupplier > xFamiliesSup( mrGlobalData.getDocument(), UNO_QUERY_THROW );
+        Reference< XNameAccess > xFamiliesNA( xFamiliesSup->getStyleFamilies(), UNO_QUERY_THROW );
+        Reference< XNameContainer > xStylesNC( xFamiliesNA->getByName( CREATE_OUSTRING( "PageStyles" ) ), UNO_QUERY_THROW );
+
+        Reference< XMultiServiceFactory > xFactory( mrGlobalData.getDocument(), UNO_QUERY_THROW );
+        Reference< XStyle > xStyle( xFactory->createInstance( CREATE_OUSTRING( "com.sun.star.style.PageStyle" ) ), UNO_QUERY_THROW );
+
+        Reference< XNamed > xSheetName( mxSheet, UNO_QUERY_THROW );
+        OUString aStyleName = CREATE_OUSTRING( "PageStyle_" ) + xSheetName->getName();
+        aStyleName = ContainerHelper::insertByUnusedName( xStylesNC, Any( xStyle ), aStyleName, false );
+
+        // Populate the new page style.
+        WrappedPropertySet aStyleProps( xStyle );
+        maPageStyle.writeToPropertySet( aStyleProps, meSheetType );
+
+        // Link this page style with the current sheet.
+        WrappedPropertySet aSheetProps( mxSheet );
+        aSheetProps.setProperty( CREATE_OUSTRING( "PageStyle" ), aStyleName );
+    }
+    catch( Exception& )
+    {
+        OSL_ENSURE( false, "WorksheetHelperImpl::convertPageStyle - cannot create style sheet" );
+    }
+}
+
+void WorksheetHelperImpl::convertColumns()
+{
+    sal_Int32 nNextCol = 0;
+    sal_Int32 nMaxCol = mrMaxApiPos.Column;
+    // stores first grouped column index for each level
+    OutlineLevelVec aColLevels;
+
+    for( OoxColumnDataMap::const_iterator aIt = maColDatas.begin(), aEnd = maColDatas.end(); aIt != aEnd; ++aIt )
+    {
+        // convert 1-based OOX column indexes to 0-based API column indexes
+        sal_Int32 nFirstCol = ::std::max( aIt->second.mnFirstCol - 1, nNextCol );
+        sal_Int32 nLastCol = ::std::min( aIt->second.mnLastCol - 1, nMaxCol );
+
+        // process gap between two column datas, use default column data
+        if( nNextCol < nFirstCol )
+            convertColumns( aColLevels, nNextCol, nFirstCol - 1, maDefColData );
+        // process the column data
+        convertColumns( aColLevels, nFirstCol, nLastCol, aIt->second );
+
+        // cache next column to be processed
+        nNextCol = nLastCol + 1;
+    }
+
+    // remaining default columns to end of sheet
+    convertColumns( aColLevels, nNextCol, nMaxCol, maDefColData );
+    // close remaining column outlines spanning to end of sheet
+    convertOutlines( aColLevels, nMaxCol + 1, 0, false, false );
+}
+
+void WorksheetHelperImpl::convertColumns( OutlineLevelVec& orColLevels,
+        sal_Int32 nFirstCol, sal_Int32 nLastCol, const OoxColumnData& rData )
+{
+    Reference< XTableColumns > xColumns = getColumns( nFirstCol, nLastCol );
+    if( xColumns.is() )
+    {
+        // set column properties
+        WrappedPropertySet aPropSet( xColumns );
+        // convert 'number of characters' to column width in 1/100 mm
+        sal_Int32 nWidth = mrGlobalData.getUnitConverter().calcMm100FromDigits( rData.mfWidth );
+        if( nWidth > 0 )
+            aPropSet.setProperty( maWidthProp, nWidth );
+        if( rData.mbHidden )
+            aPropSet.setProperty( maVisibleProp, false );
+    }
+    // outline settings for this column range
+    convertOutlines( orColLevels, nFirstCol, rData.mnLevel, rData.mbCollapsed, false );
+}
+
+void WorksheetHelperImpl::convertRows()
+{
+    sal_Int32 nNextRow = 0;
+    sal_Int32 nMaxRow = mrMaxApiPos.Row;
+    // stores first grouped row index for each level
+    OutlineLevelVec aRowLevels;
+
+    for( OoxRowDataMap::const_iterator aIt = maRowDatas.begin(), aEnd = maRowDatas.end(); aIt != aEnd; ++aIt )
+    {
+        // row index is valid, has been checked while inserting row data into the map
+        sal_Int32 nRow = aIt->first;
+
+        // process gap between two row datas, use default row data
+        if( nNextRow < nRow )
+            convertRows( aRowLevels, nNextRow, nRow - 1, maDefRowData );
+        // process the row data
+        convertRows( aRowLevels, nRow, nRow, aIt->second );
+
+        // cache next row to be processed
+        nNextRow = nRow + 1;
+    }
+
+    // remaining default rows to end of sheet
+    convertRows( aRowLevels, nNextRow, nMaxRow, maDefRowData );
+    // close remaining row outlines spanning to end of sheet
+    convertOutlines( aRowLevels, nMaxRow + 1, 0, false, true );
+}
+
+void WorksheetHelperImpl::convertRows( OutlineLevelVec& orRowLevels,
+        sal_Int32 nFirstRow, sal_Int32 nLastRow, const OoxRowData& rData )
+{
+    Reference< XTableRows > xRows = getRows( nFirstRow, nLastRow );
+    if( xRows.is() )
+    {
+        // set row properties
+        WrappedPropertySet aPropSet( xRows );
+        // convert points to row height in 1/100 mm
+        sal_Int32 nHeight = mrGlobalData.getUnitConverter().calcMm100FromPoints( rData.mfHeight );
+        if( nHeight > 0 )
+            aPropSet.setProperty( maHeightProp, nHeight );
+        if( rData.mbHidden )
+            aPropSet.setProperty( maVisibleProp, false );
+    }
+    // outline settings for this column range
+    convertOutlines( orRowLevels, nFirstRow, rData.mnLevel, rData.mbCollapsed, true );
+}
+
+void WorksheetHelperImpl::convertOutlines( OutlineLevelVec& orLevels,
+        sal_Int32 nColRow, sal_Int32 nLevel, bool bCollapsed, bool bRows )
+{
+    /*  It is ensured from caller functions, that this function is called
+        without any gaps between the processed column or row ranges. */
+
+    OSL_ENSURE( nLevel >= 0, "WorksheetHelperImpl::convertOutlines - negative outline level" );
+    nLevel = ::std::max< sal_Int32 >( nLevel, 0 );
+
+    sal_Int32 nSize = orLevels.size();
+    if( nSize < nLevel )
+    {
+        // Outline level increased. Push the begin column position.
+        for( sal_Int32 nIndex = nSize; nIndex < nLevel; ++nIndex )
+            orLevels.push_back( nColRow );
+    }
+    else if( nLevel < nSize )
+    {
+        // Outline level decreased. Pop them all out.
+        for( sal_Int32 nIndex = nLevel; nIndex < nSize; ++nIndex )
+        {
+            sal_Int32 nFirstInLevel = orLevels.back();
+            orLevels.pop_back();
+            groupColumnsOrRows( nFirstInLevel, nColRow - 1, bCollapsed, bRows );
+            bCollapsed = false; // collapse only once
+        }
+    }
+}
+
+void WorksheetHelperImpl::groupColumnsOrRows( sal_Int32 nFirstColRow, sal_Int32 nLastColRow, bool bCollapse, bool bRows )
+{
+    Reference< XSheetOutline > xOutline( mxSheet, UNO_QUERY );
+    if( xOutline.is() )
+    {
+        if( bRows )
+        {
+            CellRangeAddress aRange( mnSheet, 0, nFirstColRow, 0, nLastColRow );
+            xOutline->group( aRange, ::com::sun::star::table::TableOrientation_ROWS );
+            if( bCollapse )
+                xOutline->hideDetail( aRange );
+        }
+        else
+        {
+            CellRangeAddress aRange( mnSheet, nFirstColRow, 0, nLastColRow, 0 );
+            xOutline->group( aRange, ::com::sun::star::table::TableOrientation_COLUMNS );
+            if( bCollapse )
+                xOutline->hideDetail( aRange );
+        }
+    }
+}
+
+// ============================================================================
+// ============================================================================
+
+WorksheetHelper::WorksheetHelper( const GlobalDataHelper& rGlobalData,
+        WorksheetType eSheetType, const Reference< XSpreadsheet >& rxSheet, sal_Int16 nSheet ) :
+    mxImpl( new WorksheetHelperImpl( rGlobalData, eSheetType, rxSheet, nSheet ) ),
+    mrGlobalData( rGlobalData )
+{
+}
+
+WorksheetHelper::~WorksheetHelper()
+{
+}
+
+WorksheetType WorksheetHelper::getSheetType() const
+{
+    return mxImpl->meSheetType;
+}
+
+Reference< XSpreadsheet > WorksheetHelper::getXSpreadsheet() const
+{
+    return mxImpl->mxSheet;
+}
+
+sal_Int16 WorksheetHelper::getSheetIndex() const
+{
+    return mxImpl->mnSheet;
+}
+
+Reference< XCell > WorksheetHelper::getCell( const CellAddress& rAddress ) const
+{
+    return mxImpl->getCell( rAddress );
+}
+
+Reference< XCell > WorksheetHelper::getCell( const OUString& rAddressStr ) const
+{
+    CellAddress aAddress;
+    if( mrGlobalData.getAddressConverter().convertToCellAddress( aAddress, rAddressStr, mxImpl->mnSheet, true ) )
+        return mxImpl->getCell( aAddress );
+    return Reference< XCell >();
+}
+
+Reference< XCell > WorksheetHelper::getCell( const BiffAddress& rBiffAddress ) const
+{
+    CellAddress aAddress;
+    if( mrGlobalData.getAddressConverter().convertToCellAddress( aAddress, rBiffAddress, mxImpl->mnSheet, true ) )
+        return mxImpl->getCell( aAddress );
+    return Reference< XCell >();
+}
+
+Reference< XCellRange > WorksheetHelper::getCellRange( const CellRangeAddress& rRange ) const
+{
+    return mxImpl->getCellRange( rRange );
+}
+
+Reference< XCellRange > WorksheetHelper::getCellRange( const OUString& rRangeStr ) const
+{
+    CellRangeAddress aRange;
+    if( mrGlobalData.getAddressConverter().convertToCellRange( aRange, rRangeStr, mxImpl->mnSheet, true ) )
+        return mxImpl->getCellRange( aRange );
+    return Reference< XCellRange >();
+}
+
+Reference< XCellRange > WorksheetHelper::getCellRange( const BiffRange& rBiffRange ) const
+{
+    CellRangeAddress aRange;
+    if( mrGlobalData.getAddressConverter().convertToCellRange( aRange, rBiffRange, mxImpl->mnSheet, true ) )
+        return mxImpl->getCellRange( aRange );
+    return Reference< XCellRange >();
+}
+
+CellAddress WorksheetHelper::getCellAddress( const Reference< XCell >& rxCell )
+{
+    CellAddress aAddress;
+    Reference< XCellAddressable > xAddressable( rxCell, UNO_QUERY );
+    if( xAddressable.is() )
+        aAddress = xAddressable->getCellAddress();
+    else
+        OSL_ENSURE( false, "WorksheetHelper::getCellAddress: Cell reference not addressable." );
+
+    return aAddress;
+}
+
+CellRangeAddress WorksheetHelper::getRangeAddress( const XCellRangeRef& rxRange )
+{
+    CellRangeAddress aRange;
+    Reference< XCellRangeAddressable > xAddressable( rxRange, UNO_QUERY );
+    if( xAddressable.is() )
+        aRange = xAddressable->getRangeAddress();
+    else
+        OSL_ENSURE( false, "WorksheetHelper::getRangeAddress: Cell range reference not addressable." );
+
+    return aRange;
+}
+
+Reference< XCellRange > WorksheetHelper::getColumn( sal_Int32 nCol ) const
+{
+    Reference< XCellRange > xColumn;
+    try
+    {
+        Reference< XColumnRowRange > xColRowRange( mxImpl->mxSheet, UNO_QUERY_THROW );
+        Reference< XTableColumns > xColumns = xColRowRange->getColumns();
+        if( xColumns.is() )
+            xColumn.set( xColumns->getByIndex( nCol ), UNO_QUERY );
+    }
+    catch( Exception& )
+    {
+    }
+    return xColumn;
+}
+
+Reference< XCellRange > WorksheetHelper::getRow( sal_Int32 nRow ) const
+{
+    Reference< XCellRange > xRow;
+    try
+    {
+        Reference< XColumnRowRange > xColRowRange( mxImpl->mxSheet, UNO_QUERY_THROW );
+        Reference< XTableRows > xRows = xColRowRange->getRows();
+            xRow.set( xRows->getByIndex( nRow ), UNO_QUERY );
+    }
+    catch( Exception& )
+    {
+    }
+    return xRow;
+}
+
+Reference< XCellRange > WorksheetHelper::getColumnOrRow( sal_Int32 nColRow, bool bRow ) const
+{
+    return bRow ? getRow( nColRow ) : getColumn( nColRow );
+}
+
+Reference< XTableColumns > WorksheetHelper::getColumns( sal_Int32 nFirstCol, sal_Int32 nLastCol ) const
+{
+    return mxImpl->getColumns( nFirstCol, nLastCol );
+}
+
+Reference< XTableRows > WorksheetHelper::getRows( sal_Int32 nFirstRow, sal_Int32 nLastRow ) const
+{
+    return mxImpl->getRows( nFirstRow, nLastRow );
+}
+
+void WorksheetHelper::setMergedRange( const Reference< XCellRange >& rxRange ) const
+{
+    try
+    {
+        Reference< XMergeable > xMerge( rxRange, UNO_QUERY_THROW );
+        xMerge->merge( sal_True );
+    }
+    catch( Exception& )
+    {
+    }
+}
+
+void WorksheetHelper::setBooleanCell( const Reference< XCell >& rxCell, bool bValue ) const
+{
+    OSL_ENSURE( rxCell.is(), "WorksheetHelper::setBooleanCell - missing cell interface" );
+    rxCell->setFormula( bValue ? mxImpl->maTrueFormula : mxImpl->maFalseFormula );
+    // #108770# set 'Standard' number format for all Boolean cells
+    WrappedPropertySet aPropSet( rxCell );
+    mrGlobalData.getStyles().writeNumFmtToPropertySet( aPropSet, 0 );
+}
+
+void WorksheetHelper::setErrorCell( const XCellRef& rxCell, const ::rtl::OUString& rErrorCode ) const
+{
+    WorksheetHelperImpl::ErrorCodeMap::const_iterator aIt = mxImpl->maErrorCodes.find( rErrorCode );
+    sal_uInt8 nErrorCode = (aIt == mxImpl->maErrorCodes.end()) ? BIFF_ERR_NA : aIt->second;
+    setErrorCell( rxCell, nErrorCode );
+}
+
+void WorksheetHelper::setErrorCell( const XCellRef& rxCell, sal_uInt8 nErrorCode ) const
+{
+    Reference< XFormulaTokens > xTokens( rxCell, UNO_QUERY );
+    OSL_ENSURE( xTokens.is(), "WorksheetHelper::setErrorCell - missing cell interface" );
+    if( xTokens.is() )
+    {
+        CellFormulaContext aContext( xTokens, getCellAddress( rxCell ) );
+        mrGlobalData.getFormulaParser().convertErrorToFormula( aContext, nErrorCode );
+    }
+}
+
+void WorksheetHelper::setBaseColumnWidth( sal_Int32 nWidth )
+{
+    // do not modify width, if setDefaultColumnWidth() has been used
+    if( !mxImpl->mbHasDefWidth && (nWidth > 0) )
+    {
+        /*  #i3006# add 5 pixels padding to the width, assuming 1 pixel =
+            1/96 inch. => 5/96 inch == 1.32 mm. */
+        const UnitConverter& rUnitConv = mrGlobalData.getUnitConverter();
+        mxImpl->maDefColData.mfWidth = rUnitConv.calcDigitsFromMm100( rUnitConv.calcMm100FromDigits( nWidth ) + 132 );
+    }
+}
+
+void WorksheetHelper::setDefaultColumnWidth( double fWidth )
+{
+    // overrides a width set with setBaseColumnWidth()
+    if( fWidth > 0.0 )
+    {
+        mxImpl->maDefColData.mfWidth = fWidth;
+        mxImpl->mbHasDefWidth = true;
+    }
+}
+
+void WorksheetHelper::setColumnData( const OoxColumnData& rData )
+{
+    // convert 1-based OOX column indexes to 0-based API column indexes
+    sal_Int32 nFirstCol = rData.mnFirstCol - 1;
+    sal_Int32 nLastCol = rData.mnLastCol - 1;
+    if( nFirstCol <= mxImpl->mrMaxApiPos.Column )
+    {
+        mxImpl->maColDatas[ nFirstCol ] = rData;
+        // set column formatting directly, nLastCol is checked inside the function
+        convertColumnFormat( nFirstCol, nLastCol, rData.mnXfId );
+    }
+}
+
+void WorksheetHelper::setDefaultRowSettings( double fHeight, bool bHidden )
+{
+    mxImpl->maDefRowData.mfHeight = fHeight;
+    mxImpl->maDefRowData.mbHidden = bHidden;
+}
+
+void WorksheetHelper::setRowData( const OoxRowData& rData )
+{
+    // convert 1-based OOX row index to 0-based API row index
+    sal_Int32 nRow = rData.mnRow - 1;
+    if( nRow <= mxImpl->mrMaxApiPos.Row )
+    {
+        mxImpl->maRowDatas[ nRow ] = rData;
+        // set row formatting directly
+        if( rData.mbFormatted )
+            convertRowFormat( nRow, rData.mnXfId );
+    }
+}
+
+void WorksheetHelper::setOutlineSummarySymbols( bool bSummaryRight, bool bSummaryBelow )
+{
+    mxImpl->mbSummaryRight = bSummaryRight;
+    mxImpl->mbSummaryBelow = bSummaryBelow;
+}
+
+PageStyle& WorksheetHelper::getPageStyle()
+{
+    return mxImpl->maPageStyle;
+}
+
+OoxSheetViewData& WorksheetHelper::createSheetViewData()
+{
+    return mrGlobalData.getViewSettings().createSheetViewData( mxImpl->mnSheet );
+}
+
+void WorksheetHelper::convertColumnFormat( sal_Int32 nFirstCol, sal_Int32 nLastCol, sal_Int32 nXfId )
+{
+    CellRangeAddress aRange( mxImpl->mnSheet, nFirstCol, 0, nLastCol, mxImpl->mrMaxApiPos.Row );
+    if( mrGlobalData.getAddressConverter().validateCellRange( aRange, false ) )
+    {
+        WrappedPropertySet aPropSet( getCellRange( aRange ) );
+        mrGlobalData.getStyles().writeCellXfToPropertySet( aPropSet, nXfId );
+    }
+}
+
+void WorksheetHelper::convertRowFormat( sal_Int32 nRow, sal_Int32 nXfId )
+{
+    CellRangeAddress aRange( mxImpl->mnSheet, 0, nRow, mxImpl->mrMaxApiPos.Column, nRow );
+    if( mrGlobalData.getAddressConverter().validateCellRange( aRange, false ) )
+    {
+        WrappedPropertySet aPropSet( getCellRange( aRange ) );
+        mrGlobalData.getStyles().writeCellXfToPropertySet( aPropSet, nXfId );
+    }
+}
+
+void WorksheetHelper::convertPageBreak( const OoxPageBreakData& rData, bool bRowBreak )
+{
+    if( rData.mbManual && (rData.mnColRow > 0) )
+    {
+        WrappedPropertySet aPropSet( getColumnOrRow( rData.mnColRow, bRowBreak ) );
+        aPropSet.setProperty( mxImpl->maPageBreakProp, true );
+    }
+}
+
+void WorksheetHelper::finalizeWorksheetImport()
+{
+    mxImpl->convertPageStyle();
+    mxImpl->convertColumns();
+    mxImpl->convertRows();
+}
+
+// ============================================================================
+
+} // namespace xls
+} // namespace oox
+
