--- /dev/null	
+++ oox/source/xls/sheetdatacontext.cxx	
@@ -0,0 +1,590 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sheetdatacontext.cxx,v $
+ *
+ *  $Revision: 1.1.2.43 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/07/11 07:02:16 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "oox/xls/sheetdatacontext.hxx"
+#include <com/sun/star/table/XCell.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/sheet/XFormulaTokens.hpp>
+#include <com/sun/star/sheet/XArrayFormulaTokens.hpp>
+#include <com/sun/star/text/XText.hpp>
+#include "oox/core/wrappedpropertyset.hxx"
+#include "oox/xls/biffinputstream.hxx"
+#include "oox/xls/unitconverter.hxx"
+#include "oox/xls/addressconverter.hxx"
+#include "oox/xls/formulaparser.hxx"
+#include "oox/xls/extrefbuffer.hxx"
+#include "oox/xls/pivottablebuffer.hxx"
+
+using rtl::OUString;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::table::CellAddress;
+using ::com::sun::star::table::XCell;
+using ::com::sun::star::table::XCellRange;
+using ::com::sun::star::sheet::XFormulaTokens;
+using ::com::sun::star::sheet::XArrayFormulaTokens;
+using ::com::sun::star::text::XText;
+using ::oox::core::AttributeList;
+using ::oox::core::WrappedPropertySet;
+
+namespace oox {
+namespace xls {
+
+// ============================================================================
+
+OoxSheetDataContext::OoxSheetDataContext( FragmentBase& rFragment, const WorksheetHelper& rHelper ) :
+    ContextBase( rFragment ),
+    WorksheetHelper( rHelper ),
+    mnCellType( XML_TOKEN_INVALID ),
+    mnFormulaType( XML_TOKEN_INVALID ),
+    mnXfId( -1 )
+{
+}
+
+// oox.xls.ContextHelper interface --------------------------------------------
+
+bool OoxSheetDataContext::onCanCreateContext( sal_Int32 nElement )
+{
+    switch( getCurrentContext() )
+    {
+        case XLS_TOKEN( sheetData ):    return (nElement == XLS_TOKEN( row ));
+        case XLS_TOKEN( row ):          return (nElement == XLS_TOKEN( c ));
+        case XLS_TOKEN( c ):            return mxCurrCell.is() && (nElement == XLS_TOKEN( v )) || (nElement == XLS_TOKEN( is )) || (nElement == XLS_TOKEN( f ));
+        case XLS_TOKEN( is ):           return (nElement == XLS_TOKEN( t )) || (nElement == XLS_TOKEN( r ));
+        case XLS_TOKEN( r ):            return (nElement == XLS_TOKEN( rPr )) || (nElement == XLS_TOKEN( t ));
+        case XLS_TOKEN( rPr ):          return Font::isSupportedContext( nElement, getCurrentContext() );
+    }
+    return false;
+}
+
+void OoxSheetDataContext::onStartElement( const AttributeList& rAttribs )
+{
+    switch( getCurrentContext() )
+    {
+        case XLS_TOKEN( row ):
+            importRow( rAttribs );
+        break;
+        case XLS_TOKEN( c ):
+        {
+            maCellData = OUString();
+            maCellFormula = OUString();
+            mxCurrCell = getCell( rAttribs.getString( XML_r ) );
+            if ( getPivotTables().isOverlapping( getCellAddress(mxCurrCell) ) )
+            {
+                // This cell overlaps a pivot table.  Skip it.
+                mxCurrCell.clear();
+                return;
+            }
+
+            mnCellType = rAttribs.getToken( XML_t, XML_n );
+            mnFormulaType = XML_TOKEN_INVALID;
+            mnXfId = rAttribs.getInteger( XML_s, -1 );
+            // write all cell formatting
+            WrappedPropertySet aPropSet( mxCurrCell );
+            getStyles().writeCellXfToPropertySet( aPropSet, mnXfId );
+        }
+        break;
+        case XLS_TOKEN( is ):
+            mxInlineStr.reset( new RichString( getGlobalData() ) );
+        break;
+        case XLS_TOKEN( t ):
+            if( mxInlineStr.get() && isPreviousContext( XLS_TOKEN( is ) ) )
+                mxPortion = mxInlineStr->importText( rAttribs );
+        break;
+        case XLS_TOKEN( r ):
+            if( mxInlineStr.get() ) mxPortion = mxInlineStr->importPortion( rAttribs );
+        break;
+        case XLS_TOKEN( rPr ):
+            if( mxPortion.get() ) mxFont = mxPortion->importFont( rAttribs );
+        break;
+        case XLS_TOKEN( f ):
+            maFormulaRef = rAttribs.getString( XML_ref );
+            mnFormulaType = rAttribs.getToken( XML_t, XML_normal );
+        break;
+        default:
+            if( isPreviousContext( XLS_TOKEN( rPr ) ) && mxFont.get() )
+                mxFont->importAttribs( getCurrentContext(), rAttribs );
+    }
+}
+
+void OoxSheetDataContext::onCharacters( const OUString& rChars )
+{
+    switch( getCurrentContext() )
+    {
+        case XLS_TOKEN( v ):
+            maCellData = rChars;
+        break;
+        case XLS_TOKEN( f ):
+            maCellFormula = rChars;
+        break;
+        case XLS_TOKEN( t ):
+            if( mxPortion.get() ) mxPortion->appendString( rChars );
+        break;
+    }
+}
+
+void OoxSheetDataContext::onEndElement()
+{
+    switch( getCurrentContext() )
+    {
+        case XLS_TOKEN( c ):
+        {
+            if ( !mxCurrCell.is() )
+                return;
+
+            if( maCellFormula.getLength() > 0 ) switch( mnFormulaType )
+            {
+                case XML_normal:
+                {
+                    // Check if this cell points to an external reference.
+                    if ( getExtRefs().isExtRef( maCellFormula ) )
+                    {
+                        CellAddress aAddr;
+                        aAddr = getCellAddress( mxCurrCell );
+                        getExtRefs().addToDestCellList( aAddr, maCellFormula );
+                        return;
+                    }
+
+                    Reference< XFormulaTokens > xTokens( mxCurrCell, UNO_QUERY );
+                    if( xTokens.is() )
+                    {
+                        CellFormulaContext aContext( xTokens, getCellAddress( mxCurrCell ) );
+                        getFormulaParser().importFormula( aContext, maCellFormula );
+                    }
+                }
+                break;
+
+                case XML_array:
+                {
+                    Reference< XCellRange > xRange = getCellRange( maFormulaRef );
+                    Reference< XArrayFormulaTokens > xTokens( xRange, UNO_QUERY );
+                    if( xRange.is() && xTokens.is() )
+                    {
+                        ArrayFormulaContext aContext( xTokens, getRangeAddress( xRange ) );
+                        getFormulaParser().importFormula( aContext, maCellFormula );
+                    }
+                }
+                break;
+            }
+            else if( maCellData.getLength() > 0 )
+            {
+                switch( mnCellType )
+                {
+                    case XML_b:
+                        setBooleanCell( mxCurrCell, maCellData.toDouble() != 0.0 );
+                    break;
+    
+                    case XML_n:
+                        mxCurrCell->setValue( maCellData.toDouble() );
+                    break;
+    
+                    case XML_e:
+                        setErrorCell( mxCurrCell, maCellData );
+                    break;
+    
+                    case XML_str:
+                    {
+                        Reference< XText > xText( mxCurrCell, UNO_QUERY );
+                        if( xText.is() )
+                            xText->setString( maCellData );
+                    }
+                    break;
+    
+                    case XML_s:
+                    {
+                        Reference< XText > xText( mxCurrCell, UNO_QUERY );
+                        if( xText.is() )
+                            getSharedStrings().convertString( xText, maCellData.toInt32(), mnXfId );
+                    }
+                    break;
+                }
+            }
+        }
+        break;
+
+        case XLS_TOKEN( is ):
+        {
+            Reference< XText > xText( mxCurrCell, UNO_QUERY );
+            if( mxInlineStr.get() && xText.is() )
+            {
+                // convert font settings
+                mxInlineStr->finalizeImport();
+                // write string to cell
+                mxInlineStr->convert( xText, mnXfId );
+            }
+        }
+        break;
+    }
+}
+
+// private --------------------------------------------------------------------
+
+void OoxSheetDataContext::importRow( const AttributeList& rAttribs )
+{
+    OoxRowData aData;
+    aData.mnRow = rAttribs.getInteger( XML_r, -1 );
+    aData.mfHeight = rAttribs.getDouble( XML_ht, 0.0 );
+    aData.mnXfId = rAttribs.getInteger( XML_s, -1 );
+    aData.mnLevel = rAttribs.getInteger( XML_outlineLevel, 0 );
+    aData.mbFormatted = rAttribs.getBool( XML_customFormat, false );
+    aData.mbHidden = rAttribs.getBool( XML_hidden, false );
+    aData.mbCollapsed = rAttribs.getBool( XML_collapsed, false );
+    // set row properties in the current sheet
+    setRowData( aData );
+}
+
+// ============================================================================
+
+BiffSheetDataContext::BiffSheetDataContext(
+        const GlobalDataHelper& rGlobalData, const WorksheetHelper& rHelper ) :
+    GlobalDataHelper( rGlobalData ),
+    WorksheetHelper( rHelper ),
+    mnBiff2XfId( 0 )
+{
+}
+
+void BiffSheetDataContext::importRecord( BiffInputStream& rStrm )
+{
+    sal_uInt16 nRecId = rStrm.getRecId();
+    switch( nRecId )
+    {
+        // records in all BIFF versions
+        case BIFF2_ID_ARRAY:        // #i72713#
+        case BIFF3_ID_ARRAY:        importArray( rStrm );       break;
+        case BIFF2_ID_BLANK:
+        case BIFF3_ID_BLANK:        importBlank( rStrm );       break;
+        case BIFF2_ID_BOOLERR:
+        case BIFF3_ID_BOOLERR:      importBoolErr( rStrm );     break;
+        case BIFF2_ID_INTEGER:      importInteger( rStrm );     break;
+        case BIFF_ID_IXFE:          rStrm >> mnBiff2XfId;       break;
+        case BIFF2_ID_LABEL:
+        case BIFF3_ID_LABEL:        importLabel( rStrm );       break;
+        case BIFF2_ID_NUMBER:
+        case BIFF3_ID_NUMBER:       importNumber( rStrm );      break;
+        case BIFF_ID_RK:            importRk( rStrm );          break;
+
+        // BIFF specific records
+        default: switch( getBiff() )
+        {
+            case BIFF2: switch( nRecId )
+            {
+                case BIFF2_ID_FORMULA:      importFormula( rStrm );     break;
+                case BIFF2_ID_ROW:          importRow( rStrm );         break;
+            }
+            break;
+
+            case BIFF3: switch( nRecId )
+            {
+                case BIFF3_ID_FORMULA:      importFormula( rStrm );     break;
+                case BIFF3_ID_ROW:          importRow( rStrm );         break;
+            }
+            break;
+
+            case BIFF4: switch( nRecId )
+            {
+                case BIFF4_ID_FORMULA:      importFormula( rStrm );     break;
+                case BIFF3_ID_ROW:          importRow( rStrm );         break;
+            }
+            break;
+
+            case BIFF5: switch( nRecId )
+            {
+                case BIFF3_ID_FORMULA:
+                case BIFF4_ID_FORMULA:
+                case BIFF5_ID_FORMULA:      importFormula( rStrm );     break;
+                case BIFF_ID_MULTBLANK:     importMultBlank( rStrm );   break;
+                case BIFF_ID_MULTRK:        importMultRk( rStrm );      break;
+                case BIFF3_ID_ROW:          importRow( rStrm );         break;
+                case BIFF_ID_RSTRING:       importLabel( rStrm );       break;
+            }
+            break;
+
+            case BIFF8: switch( nRecId )
+            {
+                case BIFF3_ID_FORMULA:
+                case BIFF4_ID_FORMULA:
+                case BIFF5_ID_FORMULA:      importFormula( rStrm );     break;
+                case BIFF_ID_LABELSST:      importLabelSst( rStrm );    break;
+                case BIFF_ID_MULTBLANK:     importMultBlank( rStrm );   break;
+                case BIFF_ID_MULTRK:        importMultRk( rStrm );      break;
+                case BIFF3_ID_ROW:          importRow( rStrm );         break;
+                case BIFF_ID_RSTRING:       importLabel( rStrm );       break;
+            }
+            break;
+
+            case BIFF_UNKNOWN: break;
+        }
+    }
+}
+
+// private --------------------------------------------------------------------
+
+void BiffSheetDataContext::importArray( BiffInputStream& rStrm )
+{
+    BiffRange aBiffRange;
+    aBiffRange.read( rStrm, false );
+    Reference< XCellRange > xRange = getCellRange( aBiffRange );
+    Reference< XArrayFormulaTokens > xTokens( xRange, UNO_QUERY );
+    if( xRange.is() && xTokens.is() )
+    {
+        rStrm.ignore( (getBiff() == BIFF2) ? 1 : ((getBiff() <= BIFF4) ? 2 : 6) );
+        ArrayFormulaContext aContext( xTokens, getRangeAddress( xRange ) );
+        getFormulaParser().importFormula( aContext, rStrm );
+    }
+}
+
+void BiffSheetDataContext::importRow( BiffInputStream& rStrm )
+{
+    sal_uInt16 nRow, nHeight, nFlags = 0, nXfId = 0;
+    bool bFormatted = false;
+
+    rStrm >> nRow;
+    rStrm.ignore( 4 );
+    rStrm >> nHeight;
+    if( getBiff() == BIFF2 )
+    {
+        rStrm.ignore( 2 );
+        bFormatted = rStrm.readuInt8() == BIFF2_ROW_FORMATTED;
+        if( bFormatted )
+        {
+            rStrm.ignore( 3 );
+            rStrm >> nXfId;
+        }
+    }
+    else
+    {
+        rStrm.ignore( 4 );
+        rStrm >> nFlags >> nXfId;
+    }
+
+    OoxRowData aData;
+    // row index is 0-based in BIFF, but OoxRowData expects 1-based
+    aData.mnRow = nRow + 1;
+    // row height is in twips in BIFF, convert to points
+    aData.mfHeight = (nHeight & BIFF_ROW_HEIGHTMASK) / 20.0;
+    aData.mnXfId = nXfId & BIFF_ROW_XFMASK;
+    aData.mnLevel = extractValue< sal_Int32 >( nFlags, 0, 3 );
+    aData.mbFormatted = bFormatted;
+    aData.mbHidden = getFlag( nFlags, BIFF_ROW_HIDDEN );
+    aData.mbCollapsed = getFlag( nFlags, BIFF_ROW_COLLAPSED );
+    // set row properties in the current sheet
+    setRowData( aData );
+}
+
+Reference< XCell > BiffSheetDataContext::importCellAddress( BiffInputStream& rStrm )
+{
+    BiffAddress aAddress;
+    rStrm >> aAddress;
+    return getCell( aAddress );
+}
+
+sal_Int32 BiffSheetDataContext::importXfId( BiffInputStream& rStrm, const Reference< XCell >& rxCell, bool bBiff2 )
+{
+    sal_uInt16 nXfId = 0;
+    if( bBiff2 )
+    {
+        sal_uInt8 nBiff2XfId;
+        rStrm >> nBiff2XfId;
+        rStrm.ignore( 2 );
+        nXfId = nBiff2XfId & BIFF2_XF_MASK;
+        if( nXfId == BIFF_IXFE_USE_CACHED )
+            nXfId = mnBiff2XfId;
+    }
+    else
+    {
+        rStrm >> nXfId;
+    }
+    WrappedPropertySet aPropSet( rxCell );
+    getStyles().writeCellXfToPropertySet( aPropSet, nXfId );
+    return nXfId;
+}
+
+void BiffSheetDataContext::importBlank( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    if( xCell.is() )
+        importXfId( rStrm, xCell, rStrm.getRecId() == BIFF2_ID_BLANK );
+}
+
+void BiffSheetDataContext::importBoolErr( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    if( xCell.is() )
+    {
+        importXfId( rStrm, xCell, rStrm.getRecId() == BIFF2_ID_BOOLERR );
+        sal_uInt8 nValue, nType;
+        rStrm >> nValue >> nType;
+        switch( nType )
+        {
+            case BIFF_BOOLERR_BOOL:     setBooleanCell( xCell, nValue != 0 );   break;
+            case BIFF_BOOLERR_ERROR:    setErrorCell( xCell, nValue );          break;
+            default: OSL_ENSURE( false, "BiffSheetDataContext::importBoolErr - unknown cell type" );
+        }
+    }
+}
+
+void BiffSheetDataContext::importFormula( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    Reference< XFormulaTokens > xTokens( xCell, UNO_QUERY );
+    if( xCell.is() && xTokens.is() )
+    {
+        bool bBiff2 = getBiff() == BIFF2;
+        importXfId( rStrm, xCell, bBiff2 );
+        rStrm.ignore( 8 );  // formula result
+        /*sal_uInt16 nFlags =*/ bBiff2 ? rStrm.readuInt8() : rStrm.readuInt16();
+        if( getBiff() >= BIFF5 )
+            rStrm.ignore( 4 );
+        CellFormulaContext aContext( xTokens, getCellAddress( xCell ) );
+        getFormulaParser().importFormula( aContext, rStrm );
+    }
+}
+
+void BiffSheetDataContext::importInteger( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    if( xCell.is() )
+    {
+        importXfId( rStrm, xCell, true );
+        sal_uInt16 nValue;
+        rStrm >> nValue;
+        xCell->setValue( nValue );
+    }
+}
+
+void BiffSheetDataContext::importLabel( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    Reference< XText > xText( xCell, UNO_QUERY );
+    if( xCell.is() && xText.is() )
+    {
+        /*  the deep secrets of BIFF type and record identifier...
+            record id   BIFF    XF type     String type
+            0x0004      2-7     3 byte      8-bit length, byte string
+            0x0004      8       3 byte      16-bit length, unicode string
+            0x0204      2-7     2 byte      16-bit length, byte string
+            0x0204      8       2 byte      16-bit length, unicode string */
+        bool bBiff2Xf = rStrm.getRecId() == BIFF2_ID_LABEL;
+        sal_Int32 nXfId = importXfId( rStrm, xCell, bBiff2Xf );
+
+        RichString aString( getGlobalData() );
+        if( getBiff() == BIFF8 )
+        {
+            aString.importUniString( rStrm );
+        }
+        else
+        {
+            // #i63105# use text encoding from FONT record
+            rtl_TextEncoding eTextEnc = getTextEncoding();
+            if( const Font* pFont = getStyles().getFontFromCellXf( nXfId ).get() )
+                eTextEnc = pFont->getFontEncoding();
+            BiffStringFlags nFlags = bBiff2Xf ? BIFF_STR_8BITLENGTH : BIFF_STR_DEFAULT;
+            setFlag( nFlags, BIFF_STR_EXTRAFONTS, rStrm.getRecId() == BIFF_ID_RSTRING );
+            aString.importByteString( rStrm, eTextEnc, nFlags );
+        }
+        aString.finalizeImport();
+        aString.convert( xText, nXfId );
+    }
+}
+
+void BiffSheetDataContext::importLabelSst( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    Reference< XText > xText( xCell, UNO_QUERY );
+    if( xCell.is() && xText.is() )
+    {
+        sal_Int32 nXfId = importXfId( rStrm, xCell, false );
+        sal_Int32 nSstId;
+        rStrm >> nSstId;
+        getSharedStrings().convertString( xText, nSstId, nXfId );
+    }
+}
+
+void BiffSheetDataContext::importMultBlank( BiffInputStream& rStrm )
+{
+    BiffAddress aAddress;
+    for( rStrm >> aAddress; rStrm.getRecLeft() > 2; ++aAddress.mnCol )
+    {
+        Reference< XCell > xCell = getCell( aAddress );
+        if( xCell.is() )
+            importXfId( rStrm, xCell, false );
+    }
+}
+
+void BiffSheetDataContext::importMultRk( BiffInputStream& rStrm )
+{
+    BiffAddress aAddress;
+    for( rStrm >> aAddress; rStrm.getRecLeft() > 2; ++aAddress.mnCol )
+    {
+        Reference< XCell > xCell = getCell( aAddress );
+        if( xCell.is() )
+        {
+            importXfId( rStrm, xCell, false );
+            sal_Int32 nRkValue;
+            rStrm >> nRkValue;
+            xCell->setValue( BiffHelper::calcDoubleFromRk( nRkValue ) );
+        }
+    }
+}
+
+void BiffSheetDataContext::importNumber( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    if( xCell.is() )
+    {
+        importXfId( rStrm, xCell, rStrm.getRecId() == BIFF2_ID_NUMBER );
+        double fValue;
+        rStrm >> fValue;
+        xCell->setValue( fValue );
+    }
+}
+
+void BiffSheetDataContext::importRk( BiffInputStream& rStrm )
+{
+    Reference< XCell > xCell = importCellAddress( rStrm );
+    if( xCell.is() )
+    {
+        importXfId( rStrm, xCell, false );
+        sal_Int32 nRkValue;
+        rStrm >> nRkValue;
+        xCell->setValue( BiffHelper::calcDoubleFromRk( nRkValue ) );
+    }
+}
+
+// ============================================================================
+
+} // namespace xls
+} // namespace oox
+
