--- /opt/OpenOffice/ooo-build/build/src680-m79/psprint/source/printer/cupsmgr.cxx	2005-03-01 19:59:14.000000000 +0000
+++ psprint/source/printer/cupsmgr.cxx	2005-03-17 16:00:38.367432344 +0000
@@ -123,7 +123,7 @@
                    cups_option_t* pOptions )
     { return m_pcupsPrintFile( pPrinter, pFileName, pTitle, nOptions, pOptions ); }
 
-    const char* cupsGetPPD( const char* pPrinter );
+    rtl::OString cupsGetPPD( const char* pPrinter );
 
     int cupsMarkOptions(ppd_file_t* pPPD, int nOptions, cups_option_t* pOptions )
     { return m_pcupsMarkOptions(pPPD, nOptions, pOptions); }
@@ -256,68 +256,111 @@
     return m_pLib != NULL;
 }
 
-static struct GetPPDAttribs
+typedef const char* (*PPDFunction)(const char*);
+
+static Mutex aPPDMutex;
+static bool  bPPDThreadRunning = false;
+
+struct GetPPDAttribs
 {
-    const char* (*pFunction)(const char*);
-    osl::Condition		m_aCondition;
-    const char*			m_pParameter;
-    const char*			m_pResult;
-    oslThread			m_aThread;
-} *pAttribs = NULL;
+	int              m_nRefs;
+	Condition        m_aCondition;
+	PPDFunction      m_pFunction;
+	OString          m_aParameter;
+	OString          m_aResult;
+
+	GetPPDAttribs( PPDFunction pFn, const char * m_pParameter )
+			: m_pFunction( pFn ),
+			  m_aParameter( m_pParameter )
+	{
+		m_nRefs = 2;
+		m_aCondition.reset();
+	}
+
+	~GetPPDAttribs()
+	{
+		if( m_aResult.getLength() )
+			unlink( m_aResult );
+	}
+
+	void unref()
+	{
+		if( --m_nRefs == 0 )
+		{
+			bPPDThreadRunning = false;
+			delete this;
+		}
+	}
+
+	void executeCall()
+	{
+		// This CUPS method is not at all thread-safe we need
+		// to dup the pointer to a static buffer it returns ASAP
+		OString aResult = m_pFunction( m_aParameter );
+
+		{
+			MutexGuard aGuard( aPPDMutex );
+			m_aResult = aResult;
+			m_aCondition.set();
+			unref();
+		}
+	}
+
+	OString waitResult( TimeValue *pDelay )
+	{
+		aPPDMutex.release();
+
+		if (m_aCondition.wait( pDelay ) != Condition::result_ok )
+		{
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "cupsGetPPD %s timed out\n",
+					 (const sal_Char *) m_aParameter );
+#endif
+		}
+
+		aPPDMutex.acquire();
+
+		OString aRetval = m_aResult;
+		m_aResult = OString();
+		unref();
+
+		return aRetval;
+	}
+};
 
 extern "C" {
-    static void getPPDWorker(void*)
+    static void getPPDWorker(void *pData)
     {
-        pAttribs->m_pResult = pAttribs->pFunction( pAttribs->m_pParameter );
-        if( pAttribs->m_aCondition.check() )
-        {
-            // timed out, unlink file
-            if( pAttribs->m_pResult )
-                unlink( pAttribs->m_pResult );
-            delete pAttribs;
-            pAttribs = NULL;
-        }
-        else
-            pAttribs->m_aCondition.set();
+		GetPPDAttribs *pAttribs = (GetPPDAttribs *) pData;
+		pAttribs->executeCall();
     }
 }
 
-const char* CUPSWrapper::cupsGetPPD( const char* pPrinter )
+OString CUPSWrapper::cupsGetPPD( const char* pPrinter )
 {
-    const char* pResult = NULL;
+	OString aResult;
+
+	aPPDMutex.acquire();
 
     // if one thread hangs in cupsGetPPD already, don't start another
-    if( ! pAttribs )
+	if( !bPPDThreadRunning )
     {
-        pAttribs = new GetPPDAttribs();
-        pAttribs->pFunction			= m_pcupsGetPPD;
-        pAttribs->m_aCondition.reset();
-        pAttribs->m_pParameter		= pPrinter;
-        pAttribs->m_pResult			= NULL;
-        pAttribs->m_aThread			= osl_createThread( getPPDWorker, NULL );
+		bPPDThreadRunning = true;
+        GetPPDAttribs *pAttribs = new GetPPDAttribs( m_pcupsGetPPD, pPrinter );
+        oslThread aThread = osl_createThread( getPPDWorker, pAttribs );
 
         TimeValue aValue;
         aValue.Seconds = 5;
         aValue.Nanosec = 0;
-        if( pAttribs->m_aCondition.wait( &aValue ) == Condition::result_ok )
-        {
-            osl_destroyThread( pAttribs->m_aThread );
-            pResult = pAttribs->m_pResult;
-            delete pAttribs;
-            pAttribs = NULL;
-        }
-        else
-        {
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "cupsGetPPD %s timed out\n", pPrinter );
-#endif
-            // should the thread awake again notify it to clean up itself
-            pAttribs->m_aCondition.set();
-            osl_destroyThread( pAttribs->m_aThread );
-        }
+
+		aResult = pAttribs->waitResult( &aValue );
+
+		osl_destroyThread( aThread );
     }
 
-    return pResult;
+	aPPDMutex.release();
+
+    return aResult;
 }
 
 static const char* setPasswordCallback( const char* pIn )
@@ -575,20 +618,21 @@
             if( dest_it != m_aCUPSDestMap.end() )
             {
                 cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + dest_it->second;
-                const char* pPPDFile = m_pCUPSWrapper->cupsGetPPD( pDest->name );
+				OString aPPDFile = m_pCUPSWrapper->cupsGetPPD( pDest->name );
                 #if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr, "PPD for %s is %s\n", OUStringToOString( aPrinter, osl_getThreadTextEncoding() ).getStr(), pPPDFile );
+                fprintf( stderr, "PPD for %s is %s\n", OUStringToOString( aPrinter, osl_getThreadTextEncoding() ).getStr(),
+						 (const sal_Char *) aPPDFile );
                 #endif
-                if( pPPDFile )
+                if( aPPDFile.getLength() )
                 {
                     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
-                    OUString aFileName( OStringToOUString( pPPDFile, aEncoding ) );
+                    OUString aFileName( OStringToOUString( aPPDFile, aEncoding ) );
                     // update the printer info with context information
-                    ppd_file_t* pPPD = m_pCUPSWrapper->ppdOpenFile( pPPDFile );
+                    ppd_file_t* pPPD = m_pCUPSWrapper->ppdOpenFile( aPPDFile );
                     if( pPPD )
                     {
                         // create the new parser
-                        PPDParser* pCUPSParser =  new PPDParser( aFileName );
+                        PPDParser* pCUPSParser = new PPDParser( aFileName );
                         pCUPSParser->m_aFile = rPrinter;
                         pNewParser = pCUPSParser;
                         
@@ -621,7 +665,7 @@
                     #endif
                     
                     // remove temporary PPD file
-                    unlink( pPPDFile );
+                    unlink( aPPDFile );
                 }
                 #if OSL_DEBUG_LEVEL > 1
                 else
