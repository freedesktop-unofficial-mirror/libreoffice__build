Index: gcach_ftyp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.cxx,v
retrieving revision 1.124
diff -u -u -r1.124 gcach_ftyp.cxx
--- vcl/source/glyphs/gcach_ftyp.cxx	5 May 2006 09:00:45 -0000	1.124
+++ vcl/source/glyphs/gcach_ftyp.cxx	6 Jul 2006 18:52:41 -0000
@@ -60,6 +60,9 @@
 #include FT_TRUETYPE_TABLES_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_TRUETYPE_IDS_H
+#ifdef USE_FT_EMBOLDEN
+#include FT_SYNTHESIS_H
+#endif
 
 #ifndef INCLUDED_RTL_INSTANCE_HXX
 #include <rtl/instance.hxx>
@@ -108,6 +111,7 @@
 
 // -----------------------------------------------------------------------
 
+#ifndef USE_FT_EMBOLDEN
 // the gamma table makes artificial bold look better for CJK glyphs
 static unsigned char aGammaTable[257];
 
@@ -130,6 +134,7 @@
     }
 }
 // -----------------------------------------------------------------------
+#endif
 
 static FT_Library aLibFT = 0;
 
@@ -491,7 +496,9 @@
     if( pEnv )
         nDefaultPrioAutoHint  = pEnv[0] - '0';
 
+#ifndef USE_FT_EMBOLDEN
     InitGammaTable();
+#endif
 }
 
 // -----------------------------------------------------------------------
@@ -817,6 +824,7 @@
     static const int TT_CODEPAGE_RANGE_1361 = (1L << 21); // Korean Johab
     static const int TT_CODEPAGE_RANGES1_CJKT = 0x3F0000; // all of the above
     const TT_OS2* pOs2 = (const TT_OS2*)FT_Get_Sfnt_Table( maFaceFT, ft_sfnt_os2 );
+#ifndef USE_FT_EMBOLDEN
     if ((pOs2) && (pOs2->ulCodePageRange1 & TT_CODEPAGE_RANGES1_CJKT )
 	      && rFSD.mnHeight < 20)
 	mbUseGamma = true;
@@ -825,6 +833,10 @@
 
     if (mbUseGamma)
 	mnLoadFlags |= FT_LOAD_FORCE_AUTOHINT;
+#else
+    if ((pOs2) && (pOs2->ulCodePageRange1 & TT_CODEPAGE_RANGES1_CJKT ))
+         mnLoadFlags |= FT_LOAD_FORCE_AUTOHINT;
+#endif
 
     if( (mnSin != 0) && (mnCos != 0) ) // hinting for 0/90/180/270 degrees only
         mnLoadFlags |= FT_LOAD_NO_HINTING;
@@ -1255,7 +1267,16 @@
     rGD.SetCharWidth( (nCharWidth + 32) >> 6 );
 
     FT_Glyph pGlyphFT;
-    rc = FT_Get_Glyph( maFaceFT->glyph, &pGlyphFT );
+#ifdef USE_FT_EMBOLDEN
+    if( mbArtBold )
+    {
+         FT_GlyphSlot slot = maFaceFT->glyph;
+	 FT_GlyphSlot_Embolden( slot );
+	 rc = FT_Get_Glyph( slot, &pGlyphFT );
+    }
+    else
+#endif
+         rc = FT_Get_Glyph( maFaceFT->glyph, &pGlyphFT );
 
     int nAngle = ApplyGlyphTransform( nGlyphFlags, pGlyphFT, false );
     rGD.SetDelta( (pGlyphFT->advance.x + 0x8000) >> 16, -((pGlyphFT->advance.y + 0x8000) >> 16) );
@@ -1367,6 +1388,7 @@
     const FT_Bitmap& rBitmapFT  = rBmpGlyphFT->bitmap;
     rRawBitmap.mnHeight         = rBitmapFT.rows;
     rRawBitmap.mnBitCount       = 1;
+#ifndef USE_FT_EMBOLDEN
     if( mbArtBold )
     {
 	rRawBitmap.mnWidth = rBitmapFT.width + 1;
@@ -1375,9 +1397,12 @@
     }
     else
     {
+#endif
 	rRawBitmap.mnWidth          = rBitmapFT.width;
 	rRawBitmap.mnScanlineSize   = rBitmapFT.pitch;
+#ifndef USE_FT_EMBOLDEN
     }
+#endif
 
     const ULONG nNeededSize = rRawBitmap.mnScanlineSize * rRawBitmap.mnHeight;
 
@@ -1388,9 +1413,12 @@
         rRawBitmap.mpBits = new unsigned char[ rRawBitmap.mnAllocated ];
     }
 
+#ifndef USE_FT_EMBOLDEN
     if( !mbArtBold )
     {
+#endif
 	memcpy( rRawBitmap.mpBits, rBitmapFT.buffer, nNeededSize );
+#ifndef USE_FT_EMBOLDEN
     }
     else
     {
@@ -1417,6 +1445,7 @@
 	    p += rRawBitmap.mnScanlineSize;
 	}
     }
+#endif
 
     FT_Done_Glyph( pGlyphFT );
 
@@ -1480,6 +1509,17 @@
         return false;
 
     FT_Glyph pGlyphFT;
+#ifdef USE_FT_EMBOLDEN
+    //if mbArtBold true, using freetype API FT_GlyphSlot_Embolden embolden font to generate fake bold font.
+    //but, this method still have to be improve for big cjk font. but I think this should be improve by freetype
+    if( mbArtBold )
+    {
+        FT_GlyphSlot slot = maFaceFT->glyph;
+	FT_GlyphSlot_Embolden( slot );
+	rc = FT_Get_Glyph( slot, &pGlyphFT );
+    }
+    else
+#endif
     rc = FT_Get_Glyph( maFaceFT->glyph, &pGlyphFT );
     if( rc != FT_Err_Ok )
         return false;
@@ -1517,11 +1557,13 @@
     rRawBitmap.mnWidth          = rBitmapFT.width;
     rRawBitmap.mnBitCount       = 8;
     rRawBitmap.mnScanlineSize   = bEmbedded ? rBitmapFT.width : rBitmapFT.pitch;
+#ifndef USE_FT_EMBOLDEN
     if( mbArtBold )
     {
 	++rRawBitmap.mnWidth;
         ++rRawBitmap.mnScanlineSize;
     }
+#endif
     rRawBitmap.mnScanlineSize = (rRawBitmap.mnScanlineSize + 3) & -4;
 
     const ULONG nNeededSize = rRawBitmap.mnScanlineSize * rRawBitmap.mnHeight;
@@ -1560,6 +1602,7 @@
         }
     }
 
+#ifndef USE_FT_EMBOLDEN
     if( mbArtBold )
     {
 	// overlay with glyph image shifted by one left pixel
@@ -1589,6 +1632,7 @@
 	    p += rRawBitmap.mnScanlineSize;
 	}
     }
+#endif
 
     FT_Done_Glyph( pGlyphFT );
 
Index: gcach_ftyp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.hxx,v
retrieving revision 1.35
diff -u -u -r1.35 gcach_ftyp.hxx
--- vcl/source/glyphs/gcach_ftyp.hxx	19 Apr 2006 13:56:08 -0000	1.35
+++ vcl/source/glyphs/gcach_ftyp.hxx	6 Jul 2006 18:52:41 -0000
@@ -220,7 +220,9 @@
 
     bool			mbArtItalic;
     bool			mbArtBold;
+#ifndef USE_FT_EMBOLDEN
     bool			mbUseGamma;
+#endif
 
     typedef ::std::hash_map<int,int> GlyphSubstitution;
     GlyphSubstitution           maGlyphSubstitution;
Index: makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/makefile.mk,v
retrieving revision 1.10
diff -u -u -r1.10 makefile.mk
--- vcl/source/glyphs/makefile.mk	9 Sep 2005 12:15:13 -0000	1.10
+++ vcl/source/glyphs/makefile.mk	6 Jul 2006 18:52:41 -0000
@@ -46,6 +46,9 @@
 
 .IF "$(SYSTEM_FREETYPE)" == "YES"
 CFLAGS+=-DSYSTEM_FREETYPE $(FREETYPE_CFLAGS)
+.IF "$(USE_FT_EMBOLDEN)" == "YES"
+CFLAGS+=-DUSE_FT_EMBOLDEN
+.ENDIF
 .ENDIF
 
 # --- Files --------------------------------------------------------
