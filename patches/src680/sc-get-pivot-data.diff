Index: sc/inc/compiler.hrc
===================================================================
RCS file: /cvs/sc/sc/inc/compiler.hrc,v
retrieving revision 1.13
retrieving revision 1.13.110.1
diff -u -w -p -r1.13 -r1.13.110.1
--- sc/inc/compiler.hrc	18 Oct 2006 12:16:24 -0000	1.13
+++ sc/inc/compiler.hrc	19 Apr 2007 17:54:53 -0000	1.13.110.1
@@ -364,9 +364,10 @@
 #define	SC_OPCODE_HYPERLINK			387
 #define	SC_OPCODE_INDIRECT_XL		388		/* See also INDIRECT for OOO variant */
 #define	SC_OPCODE_ADDRESS_XL	    389		/* See also ADRESS for OOO variant */
-#define SC_OPCODE_END_2_PAR         390
+#define SC_OPCODE_GET_PIVOT_DATA    390
+#define SC_OPCODE_END_2_PAR         391
 
-#define SC_OPCODE_LAST_OPCODE_ID    389      /* last OpCode */
+#define SC_OPCODE_LAST_OPCODE_ID    390      /* last OpCode */
 
 /*** Interna ***/
 #define	SC_OPCODE_INTERNAL_BEGIN   9995
Index: sc/inc/document.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/document.hxx,v
retrieving revision 1.99
retrieving revision 1.97.12.3
diff -u -w -p -r1.99 -r1.97.12.3
--- sc/inc/document.hxx	25 Apr 2007 15:56:41 -0000	1.99
+++ sc/inc/document.hxx	8 May 2007 17:06:29 -0000	1.97.12.3
@@ -481,6 +481,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 
 	ScDPCollection*		GetDPCollection();
 	ScDPObject*			GetDPAtCursor(SCCOL nCol, SCROW nRow, SCTAB nTab) const;
+    ScDPObject*         GetDPAtBlock( const ScRange& rBlock ) const;
 
 	ScPivotCollection*	GetPivotCollection() const;
 	void				SetPivotCollection(ScPivotCollection* pNewPivotCollection);
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.11
retrieving revision 1.11.372.2
diff -u -w -p -r1.11 -r1.11.372.2
--- sc/inc/dpobject.hxx	28 Sep 2005 11:26:37 -0000	1.11
+++ sc/inc/dpobject.hxx	27 Apr 2007 16:31:40 -0000	1.11.372.2
@@ -52,11 +52,14 @@
 #include "collect.hxx"
 #endif
 
+#ifndef SC_DPOUTPUT_HXX
+#include "dpoutput.hxx"
+#endif
+
 #ifndef _COM_SUN_STAR_SHEET_XDIMENSIONSSUPPLIER_HPP_
 #include <com/sun/star/sheet/XDimensionsSupplier.hpp>
 #endif
 
-
 //------------------------------------------------------------------
 
 
@@ -179,6 +182,12 @@ public:
 										Rectangle& rPosRect, USHORT& rOrient, long& rDimPos );
 	BOOL				IsFilterButton( const ScAddress& rPos );
 
+    BOOL                GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
+                                      const std::vector< ScDPGetPivotDataField >& rFilters );
+    BOOL                ParseFilters( ScDPGetPivotDataField& rTarget,
+                                      std::vector< ScDPGetPivotDataField >& rFilters,
+                                      const String& rFilterList );
+
     void                GetMemberResultNames( StrCollection& rNames, long nDimension );
 
 	void				FillPageList( TypedStrCollection& rStrings, long nField );
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.7
retrieving revision 1.7.382.3
diff -u -w -p -r1.7 -r1.7.382.3
--- sc/inc/dpoutput.hxx	8 Sep 2005 17:35:15 -0000	1.7
+++ sc/inc/dpoutput.hxx	3 May 2007 17:51:35 -0000	1.7.382.3
@@ -48,6 +48,10 @@
 #include <com/sun/star/sheet/MemberResult.hpp>
 #endif
 
+#ifndef _COM_SUN_STAR_SHEET_GENERALFUNCTION_HPP_
+#include <com/sun/star/sheet/GeneralFunction.hpp>
+#endif
+
 #ifndef SC_SCGLOB_HXX
 #include "global.hxx"
 #endif
@@ -56,6 +60,8 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
+
 class Rectangle;
 class SvStream;
 class ScDocument;
@@ -77,6 +83,23 @@ struct ScDPPositionData
 	ScDPPositionData() { nDimension = nHierarchy = nLevel = -1; nFlags = 0; }	// invalid
 };
 
+struct ScDPGetPivotDataField
+{
+    String maFieldName;
+    com::sun::star::sheet::GeneralFunction meFunction;
+
+    bool   mbValIsStr;
+    String maValStr;
+    double mnValNum;
+
+        ScDPGetPivotDataField() :
+            meFunction( com::sun::star::sheet::GeneralFunction_NONE ),
+            mbValIsStr( false ),
+            mnValNum( 0.0 )
+        {
+        }
+};
+
 
 
 class ScDPOutput			//! name???
@@ -143,6 +166,8 @@ public:
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+    BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
+                                  const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
 	BOOL			GetHeaderDrag( const ScAddress& rPos, BOOL bMouseLeft, BOOL bMouseTop,
 									long nDragDim,
@@ -150,6 +175,10 @@ public:
 	BOOL			IsFilterButton( const ScAddress& rPos );
 
     void            GetMemberResultNames( StrCollection& rNames, long nDimension );
+
+    static void     GetDataDimensionNames( String& rSourceName, String& rGivenName,
+                                           const com::sun::star::uno::Reference<
+                                               com::sun::star::uno::XInterface>& xDim );
 
 	void 			SetHeaderLayout (BOOL bUseGrid);
 	BOOL			GetHeaderLayout () const 	{ return bHeaderLayout; }
Index: sc/inc/opcode.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/opcode.hxx,v
retrieving revision 1.15
retrieving revision 1.15.110.1
diff -u -w -p -r1.15 -r1.15.110.1
--- sc/inc/opcode.hxx	18 Oct 2006 12:17:24 -0000	1.15
+++ sc/inc/opcode.hxx	19 Apr 2007 17:54:54 -0000	1.15.110.1
@@ -380,6 +380,7 @@ enum OpCodeEnum
 		ocConvert			= SC_OPCODE_CONVERT,
 		ocRoman				= SC_OPCODE_ROMAN,
         ocHyperLink         = SC_OPCODE_HYPERLINK,
+        ocGetPivotData      = SC_OPCODE_GET_PIVOT_DATA,
 		ocEnd2Par			= SC_OPCODE_END_2_PAR,
 	// internes Allerlei
 		ocInternalBegin		= SC_OPCODE_INTERNAL_BEGIN,
Index: sc/inc/scfuncs.hrc
===================================================================
RCS file: /cvs/sc/sc/inc/scfuncs.hrc,v
retrieving revision 1.10
retrieving revision 1.10.182.1
diff -u -w -p -r1.10 -r1.10.182.1
--- sc/inc/scfuncs.hrc	10 Jul 2006 12:31:00 -0000	1.10
+++ sc/inc/scfuncs.hrc	19 Apr 2007 17:54:54 -0000	1.10.182.1
@@ -299,6 +299,7 @@
 #define HID_FUNC_TABELLE			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+18)
 #define HID_FUNC_TABELLEN			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+19)
 #define HID_FUNC_HYPERLINK			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+20)
+#define HID_FUNC_GETPIVOTDATA       (HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+21)
 
 #define HID_FUNC_CODE				(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TEXT*ID_FUNCTION_OFFSET)+1)
 #define HID_FUNC_DM					(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TEXT*ID_FUNCTION_OFFSET)+2)
Index: sc/source/core/data/documen3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/documen3.cxx,v
retrieving revision 1.34
retrieving revision 1.33.50.2
diff -u -w -p -r1.34 -r1.33.50.2
--- sc/source/core/data/documen3.cxx	27 Feb 2007 12:01:36 -0000	1.34
+++ sc/source/core/data/documen3.cxx	23 Apr 2007 08:55:35 -0000	1.33.50.2
@@ -270,6 +270,21 @@ ScDPObject* ScDocument::GetDPAtCursor(SC
 	return NULL;
 }
 
+ScDPObject* ScDocument::GetDPAtBlock( const ScRange & rBlock ) const
+{
+    if (!pDPCollection)
+        return NULL;
+
+    /* Walk the collection in reverse order to get something of an
+     * approximation of MS Excels 'most recent' effect. */
+    USHORT i = pDPCollection->GetCount();
+    while ( i-- > 0 )
+        if ( (*pDPCollection)[i]->GetOutRange().In( rBlock ) )
+            return (*pDPCollection)[i];
+
+    return NULL;
+}
+
 ScPivotCollection* ScDocument::GetPivotCollection() const
 {
 	return pPivotCollection;
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.20
retrieving revision 1.19.174.4
diff -u -w -p -r1.20 -r1.19.174.4
--- sc/source/core/data/dpobject.cxx	27 Feb 2007 12:03:42 -0000	1.20
+++ sc/source/core/data/dpobject.cxx	3 May 2007 17:50:44 -0000	1.19.174.4
@@ -803,6 +803,15 @@ void ScDPObject::GetPositionData( ScDPPo
 	pOutput->GetPositionData( rData, rPos );
 }
 
+// Returns TRUE on success and stores the result in rTarget
+BOOL ScDPObject::GetPivotData( ScDPGetPivotDataField& rTarget,
+                               const std::vector< ScDPGetPivotDataField >& rFilters )
+{
+    CreateOutput();             // create xSource and pOutput if not already done
+
+    return pOutput->GetPivotData( rTarget, rFilters );
+}
+
 BOOL ScDPObject::IsFilterButton( const ScAddress& rPos )
 {
 	CreateOutput();				// create xSource and pOutput if not already done
@@ -832,6 +841,443 @@ void ScDPObject::GetMemberResultNames( S
     pOutput->GetMemberResultNames( rNames, nDimension );    // used only with table data -> level not needed
 }
 
+bool lcl_Dequote( const String& rSource, xub_StrLen nStartPos, xub_StrLen& rEndPos, String& rResult )
+{
+    // nStartPos has to point to opening quote
+
+    bool bRet = false;
+    const sal_Unicode cQuote = '\'';
+
+    if ( rSource.GetChar(nStartPos) == cQuote )
+    {
+        rtl::OUStringBuffer aBuffer;
+        xub_StrLen nPos = nStartPos + 1;
+        const xub_StrLen nLen = rSource.Len();
+
+        while ( nPos < nLen )
+        {
+            const sal_Unicode cNext = rSource.GetChar(nPos);
+            if ( cNext == cQuote )
+            {
+                if ( nPos+1 < nLen && rSource.GetChar(nPos+1) == cQuote )
+                {
+                    // double quote is used for an embedded quote
+                    aBuffer.append( cNext );    // append one quote
+                    ++nPos;                     // skip the next one
+                }
+                else
+                {
+                    // end of quoted string
+                    rResult = aBuffer.makeStringAndClear();
+                    rEndPos = nPos + 1;         // behind closing quote
+                    return true;
+                }
+            }
+            else
+                aBuffer.append( cNext );
+            
+            ++nPos;
+        }
+        // no closing quote before the end of the string -> error (bRet still false)
+    }
+
+    return bRet;
+}
+
+struct ScGetPivotDataFunctionEntry
+{
+    const sal_Char*         pName;
+    sheet::GeneralFunction  eFunc;
+};
+
+bool lcl_ParseFunction( const String& rList, xub_StrLen nStartPos, xub_StrLen& rEndPos, sheet::GeneralFunction& rFunc )
+{
+    static const ScGetPivotDataFunctionEntry aFunctions[] =
+    {
+        // our names
+        { "Sum",        sheet::GeneralFunction_SUM       },
+        { "Count",      sheet::GeneralFunction_COUNT     },
+        { "Average",    sheet::GeneralFunction_AVERAGE   },
+        { "Max",        sheet::GeneralFunction_MAX       },
+        { "Min",        sheet::GeneralFunction_MIN       },
+        { "Product",    sheet::GeneralFunction_PRODUCT   },
+        { "CountNums",  sheet::GeneralFunction_COUNTNUMS },
+        { "StDev",      sheet::GeneralFunction_STDEV     },
+        { "StDevp",     sheet::GeneralFunction_STDEVP    },
+        { "Var",        sheet::GeneralFunction_VAR       },
+        { "VarP",       sheet::GeneralFunction_VARP      },
+        // compatibility names
+        { "Count Nums", sheet::GeneralFunction_COUNTNUMS },
+        { "StdDev",     sheet::GeneralFunction_STDEV     },
+        { "StdDevp",    sheet::GeneralFunction_STDEVP    }
+	};
+
+    const xub_StrLen nListLen = rList.Len();
+    while ( nStartPos < nListLen && rList.GetChar(nStartPos) == ' ' )
+        ++nStartPos;
+
+    bool bParsed = false;
+    bool bFound = false;
+    String aFuncStr;
+    xub_StrLen nFuncEnd = 0;
+    if ( nStartPos < nListLen && rList.GetChar(nStartPos) == '\'' )
+        bParsed = lcl_Dequote( rList, nStartPos, nFuncEnd, aFuncStr );
+    else
+    {
+        nFuncEnd = rList.Search( static_cast<sal_Unicode>(']'), nStartPos );
+        if ( nFuncEnd != STRING_NOTFOUND )
+        {
+            aFuncStr = rList.Copy( nStartPos, nFuncEnd - nStartPos );
+            bParsed = true;
+        }
+    }
+
+    if ( bParsed )
+    {
+        aFuncStr.EraseLeadingAndTrailingChars( ' ' );
+
+        const sal_Int32 nFuncCount = sizeof(aFunctions) / sizeof(aFunctions[0]);
+        for ( sal_Int32 nFunc=0; nFunc<nFuncCount && !bFound; nFunc++ )
+        {
+            if ( aFuncStr.EqualsIgnoreCaseAscii( aFunctions[nFunc].pName ) )
+            {
+                rFunc = aFunctions[nFunc].eFunc;
+                bFound = true;
+
+                while ( nFuncEnd < nListLen && rList.GetChar(nFuncEnd) == ' ' )
+                    ++nFuncEnd;
+                rEndPos = nFuncEnd;
+            }
+        }
+    }
+
+    return bFound;
+}
+
+bool lcl_IsAtStart( const String& rList, const String& rSearch, sal_Int32& rMatched,
+                    bool bAllowBracket, sheet::GeneralFunction* pFunc )
+{
+    sal_Int32 nMatchList = 0;
+    sal_Int32 nMatchSearch = 0;
+    sal_Unicode cFirst = rList.GetChar(0);
+    if ( cFirst == '\'' || cFirst == '[' )
+    {
+        // quoted string or string in brackets must match completely
+
+        String aDequoted;
+        xub_StrLen nQuoteEnd = 0;
+        bool bParsed = false;
+
+        if ( cFirst == '\'' )
+            bParsed = lcl_Dequote( rList, 0, nQuoteEnd, aDequoted );
+        else if ( cFirst == '[' )
+        {
+            // skip spaces after the opening bracket
+
+            xub_StrLen nStartPos = 1;
+            const xub_StrLen nListLen = rList.Len();
+            while ( nStartPos < nListLen && rList.GetChar(nStartPos) == ' ' )
+                ++nStartPos;
+
+            if ( rList.GetChar(nStartPos) == '\'' )         // quoted within the brackets?
+            {
+                if ( lcl_Dequote( rList, nStartPos, nQuoteEnd, aDequoted ) )
+                {
+                    // after the quoted string, there must be the closing bracket, optionally preceded by spaces,
+                    // and/or a function name
+                    while ( nQuoteEnd < nListLen && rList.GetChar(nQuoteEnd) == ' ' )
+                        ++nQuoteEnd;
+
+                    // semicolon separates function name
+                    if ( nQuoteEnd < nListLen && rList.GetChar(nQuoteEnd) == ';' && pFunc )
+                    {
+                        xub_StrLen nFuncEnd = 0;
+                        if ( lcl_ParseFunction( rList, nQuoteEnd + 1, nFuncEnd, *pFunc ) )
+                            nQuoteEnd = nFuncEnd;
+                    }
+                    if ( nQuoteEnd < nListLen && rList.GetChar(nQuoteEnd) == ']' )
+                    {
+                        ++nQuoteEnd;        // include the closing bracket for the matched length
+                        bParsed = true;
+                    }
+                }
+            }
+            else
+            {
+                // implicit quoting to the closing bracket
+
+                xub_StrLen nClosePos = rList.Search( static_cast<sal_Unicode>(']'), nStartPos );
+                if ( nClosePos != STRING_NOTFOUND )
+                {
+                    xub_StrLen nNameEnd = nClosePos;
+                    xub_StrLen nSemiPos = rList.Search( static_cast<sal_Unicode>(';'), nStartPos );
+                    if ( nSemiPos != STRING_NOTFOUND && nSemiPos < nClosePos && pFunc )
+                    {
+                        xub_StrLen nFuncEnd = 0;
+                        if ( lcl_ParseFunction( rList, nSemiPos + 1, nFuncEnd, *pFunc ) )
+                            nNameEnd = nSemiPos;
+                    }
+
+                    aDequoted = rList.Copy( nStartPos, nNameEnd - nStartPos );
+                    aDequoted.EraseTrailingChars( ' ' );        // spaces before the closing bracket or semicolon
+                    nQuoteEnd = nClosePos + 1;
+                    bParsed = true;
+                }
+            }
+        }
+
+        if ( bParsed && ScGlobal::pTransliteration->isEqual( aDequoted, rSearch ) )
+        {
+            nMatchList = nQuoteEnd;             // match count in the list string, including quotes
+            nMatchSearch = rSearch.Len();
+        }
+    }
+    else
+    {
+        // otherwise look for search string at the start of rList
+        ScGlobal::pTransliteration->equals( rList, 0, rList.Len(), nMatchList,
+                                            rSearch, 0, rSearch.Len(), nMatchSearch );
+    }
+
+    if ( nMatchSearch == rSearch.Len() )
+    {
+        // search string is at start of rList - look for following space or end of string
+
+        bool bValid = false;
+        if ( sal::static_int_cast<xub_StrLen>(nMatchList) >= rList.Len() )
+            bValid = true;
+        else
+        {
+            sal_Unicode cNext = rList.GetChar(sal::static_int_cast<xub_StrLen>(nMatchList));
+            if ( cNext == ' ' || ( bAllowBracket && cNext == '[' ) )
+                bValid = true;
+        }
+              
+        if ( bValid )
+        {
+            rMatched = nMatchList;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+BOOL ScDPObject::ParseFilters( ScDPGetPivotDataField& rTarget,
+                               std::vector< ScDPGetPivotDataField >& rFilters,
+                               const String& rFilterList )
+{
+    // parse the string rFilterList into parameters for GetPivotData
+
+    CreateObjects();            // create xSource if not already done
+
+    std::vector<String> aDataNames;     // data fields (source name)
+    std::vector<String> aGivenNames;    // data fields (compound name)
+    std::vector<String> aFieldNames;    // column/row/data fields
+    std::vector< uno::Sequence<rtl::OUString> > aFieldValues;
+
+    //
+    // get all the field and item names
+    //
+
+    uno::Reference<container::XNameAccess> xDimsName = xSource->getDimensions();
+    uno::Reference<container::XIndexAccess> xIntDims = new ScNameToIndexAccess( xDimsName );
+    sal_Int32 nDimCount = xIntDims->getCount();
+    for ( sal_Int32 nDim = 0; nDim<nDimCount; nDim++ )
+    {
+        uno::Reference<uno::XInterface> xIntDim = ScUnoHelpFunctions::AnyToInterface( xIntDims->getByIndex(nDim) );
+        uno::Reference<container::XNamed> xDim( xIntDim, uno::UNO_QUERY );
+        uno::Reference<beans::XPropertySet> xDimProp( xDim, uno::UNO_QUERY );
+        uno::Reference<sheet::XHierarchiesSupplier> xDimSupp( xDim, uno::UNO_QUERY );
+        BOOL bDataLayout = ScUnoHelpFunctions::GetBoolProperty( xDimProp,
+                            rtl::OUString::createFromAscii(DP_PROP_ISDATALAYOUT) );
+        sal_Int32 nOrient = ScUnoHelpFunctions::GetEnumProperty(
+                            xDimProp, rtl::OUString::createFromAscii(DP_PROP_ORIENTATION),
+                            sheet::DataPilotFieldOrientation_HIDDEN );
+        if ( !bDataLayout )
+        {
+            if ( nOrient == sheet::DataPilotFieldOrientation_DATA )
+            {
+                String aSourceName;
+                String aGivenName;
+                ScDPOutput::GetDataDimensionNames( aSourceName, aGivenName, xIntDim );
+                aDataNames.push_back( aSourceName );
+                aGivenNames.push_back( aGivenName );
+            }
+            else if ( nOrient != sheet::DataPilotFieldOrientation_HIDDEN )
+            {
+                // get level names, as in ScDPOutput
+
+                uno::Reference<container::XIndexAccess> xHiers = new ScNameToIndexAccess( xDimSupp->getHierarchies() );
+                sal_Int32 nHierarchy = ScUnoHelpFunctions::GetLongProperty( xDimProp,
+                                                    rtl::OUString::createFromAscii(DP_PROP_USEDHIERARCHY) );
+                if ( nHierarchy >= xHiers->getCount() )
+                    nHierarchy = 0;
+
+                uno::Reference<uno::XInterface> xHier = ScUnoHelpFunctions::AnyToInterface(
+                                                    xHiers->getByIndex(nHierarchy) );
+                uno::Reference<sheet::XLevelsSupplier> xHierSupp( xHier, uno::UNO_QUERY );
+                if ( xHierSupp.is() )
+                {
+                    uno::Reference<container::XIndexAccess> xLevels = new ScNameToIndexAccess( xHierSupp->getLevels() );
+                    sal_Int32 nLevCount = xLevels->getCount();
+                    for (sal_Int32 nLev=0; nLev<nLevCount; nLev++)
+                    {
+                        uno::Reference<uno::XInterface> xLevel = ScUnoHelpFunctions::AnyToInterface(
+                                                            xLevels->getByIndex(nLev) );
+                        uno::Reference<container::XNamed> xLevNam( xLevel, uno::UNO_QUERY );
+                        uno::Reference<sheet::XMembersSupplier> xLevSupp( xLevel, uno::UNO_QUERY );
+                        if ( xLevNam.is() && xLevSupp.is() )
+                        {
+                            uno::Reference<container::XNameAccess> xMembers = xLevSupp->getMembers();
+
+                            String aFieldName( xLevNam->getName() );
+                            uno::Sequence<rtl::OUString> aMemberNames( xMembers->getElementNames() );
+
+                            aFieldNames.push_back( aFieldName );
+                            aFieldValues.push_back( aMemberNames );
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    //
+    // compare and build filters
+    //
+
+    SCSIZE nDataFields = aDataNames.size();
+    SCSIZE nFieldCount = aFieldNames.size();
+    DBG_ASSERT( aGivenNames.size() == nDataFields && aFieldValues.size() == nFieldCount, "wrong count" );
+
+    bool bError = false;
+    bool bHasData = false;
+    String aRemaining( rFilterList );
+    aRemaining.EraseLeadingAndTrailingChars( ' ' );
+    while ( aRemaining.Len() && !bError )
+    {
+        bool bUsed = false;
+
+        // look for data field name
+
+        for ( SCSIZE nDataPos=0; nDataPos<nDataFields && !bUsed; nDataPos++ )
+        {
+            String aFound;
+            sal_Int32 nMatched = 0;
+            if ( lcl_IsAtStart( aRemaining, aDataNames[nDataPos], nMatched, false, NULL ) )
+                aFound = aDataNames[nDataPos];
+            else if ( lcl_IsAtStart( aRemaining, aGivenNames[nDataPos], nMatched, false, NULL ) )
+                aFound = aGivenNames[nDataPos];
+
+            if ( aFound.Len() )
+            {
+                rTarget.maFieldName = aFound;
+                aRemaining.Erase( 0, sal::static_int_cast<xub_StrLen>(nMatched) );
+                bHasData = true;
+                bUsed = true;
+            }
+        }
+
+        // look for field name
+
+        String aSpecField;
+        bool bHasFieldName = false;
+        if ( !bUsed )
+        {
+            sal_Int32 nMatched = 0;
+            for ( SCSIZE nField=0; nField<nFieldCount && !bHasFieldName; nField++ )
+            {
+                if ( lcl_IsAtStart( aRemaining, aFieldNames[nField], nMatched, true, NULL ) )
+                {
+                    aSpecField = aFieldNames[nField];
+                    aRemaining.Erase( 0, sal::static_int_cast<xub_StrLen>(nMatched) );
+                    aRemaining.EraseLeadingChars( ' ' );
+
+                    // field name has to be followed by item name in brackets
+                    if ( aRemaining.GetChar(0) == '[' )
+                    {
+                        bHasFieldName = true;
+                        // bUsed remains false - still need the item
+                    }
+                    else
+                    {
+                        bUsed = true;
+                        bError = true;
+                    }
+                }
+            }
+        }
+
+        // look for field item
+
+        if ( !bUsed )
+        {
+            bool bItemFound = false;
+            sal_Int32 nMatched = 0;
+            String aFoundName;
+            String aFoundValue;
+            sheet::GeneralFunction eFunc = sheet::GeneralFunction_NONE;
+            sheet::GeneralFunction eFoundFunc = sheet::GeneralFunction_NONE;
+
+            for ( SCSIZE nField=0; nField<nFieldCount; nField++ )
+            {
+                // If a field name is given, look in that field only, otherwise in all fields.
+                // aSpecField is initialized from aFieldNames array, so exact comparison can be used.
+                if ( !bHasFieldName || aFieldNames[nField] == aSpecField )
+                {
+                    const uno::Sequence<rtl::OUString>& rItems = aFieldValues[nField];
+                    sal_Int32 nItemCount = rItems.getLength();
+                    const rtl::OUString* pItemArr = rItems.getConstArray();
+                    for ( sal_Int32 nItem=0; nItem<nItemCount; nItem++ )
+                    {
+                        if ( lcl_IsAtStart( aRemaining, pItemArr[nItem], nMatched, false, &eFunc ) )
+                        {
+                            if ( bItemFound )
+                                bError = true;      // duplicate (also across fields)
+                            else
+                            {
+                                aFoundName = aFieldNames[nField];
+                                aFoundValue = pItemArr[nItem];
+                                eFoundFunc = eFunc;
+                                bItemFound = true;
+                                bUsed = true;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if ( bItemFound && !bError )
+            {
+                ScDPGetPivotDataField aField;
+                aField.maFieldName = aFoundName;
+                aField.meFunction = eFoundFunc;
+                aField.mbValIsStr = true;
+                aField.maValStr = aFoundValue;
+                aField.mnValNum = 0.0;
+                rFilters.push_back( aField );
+
+                aRemaining.Erase( 0, sal::static_int_cast<xub_StrLen>(nMatched) );
+            }
+        }
+
+        if ( !bUsed )
+            bError = true;
+
+        aRemaining.EraseLeadingChars( ' ' );        // remove any number of spaces between entries
+    }
+
+    if ( !bError && !bHasData && aDataNames.size() == 1 )
+    {
+        // if there's only one data field, its name need not be specified
+        rTarget.maFieldName = aDataNames[0];
+        bHasData = true;
+    }
+
+    return bHasData && !bError;
+}
+
 void ScDPObject::ToggleDetails( ScDPPositionData& rElemDesc, ScDPObject* pDestObj )
 {
 	CreateObjects();			// create xSource if not already done
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.13
retrieving revision 1.12.174.5
diff -u -w -p -r1.13 -r1.12.174.5
--- sc/source/core/data/dpoutput.cxx	27 Feb 2007 12:04:13 -0000	1.13
+++ sc/source/core/data/dpoutput.cxx	9 May 2007 09:40:49 -0000	1.12.174.5
@@ -45,6 +45,7 @@
 #include <svx/boxitem.hxx>
 #include <svx/brshitem.hxx>
 #include <svx/wghtitem.hxx>
+#include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
 #include "document.hxx"
@@ -69,6 +70,7 @@
 #include <com/sun/star/sheet/MemberResultFlags.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/TableFilterField.hpp>
+#include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
 using namespace com::sun::star;
@@ -77,6 +79,7 @@ using namespace com::sun::star;
 
 //!	move to a header file
 //! use names from unonames.hxx?
+#define DP_PROP_FUNCTION            "Function"
 #define DP_PROP_ORIENTATION			"Orientation"
 #define DP_PROP_POSITION			"Position"
 #define DP_PROP_USEDHIERARCHY		"UsedHierarchy"
@@ -84,6 +87,9 @@ using namespace com::sun::star;
 #define DP_PROP_ISDATALAYOUT		"IsDataLayoutDimension"
 #define DP_PROP_NUMBERFORMAT		"NumberFormat"
 #define DP_PROP_FILTER				"Filter"
+#define DP_PROP_COLUMNGRAND         "ColumnGrand"
+#define DP_PROP_ROWGRAND            "RowGrand"
+#define DP_PROP_SUBTOTALS           "SubTotals"
 
 // -----------------------------------------------------------------------
 
@@ -989,6 +995,536 @@ void ScDPOutput::GetPositionData( ScDPPo
 	}
 }
 
+//
+//  helper functions for ScDPOutput::GetPivotData
+//
+
+bool lcl_IsNamedDataField( const ScDPGetPivotDataField& rTarget, const String& rSourceName, const String& rGivenName )
+{
+    // match one of the names, ignoring case
+    return ScGlobal::pTransliteration->isEqual( rTarget.maFieldName, rSourceName ) ||
+           ScGlobal::pTransliteration->isEqual( rTarget.maFieldName, rGivenName );
+}
+
+bool lcl_IsNamedCategoryField( const ScDPGetPivotDataField& rFilter, const ScDPOutLevelData& rField )
+{
+    //! name from source instead of caption?
+    return ScGlobal::pTransliteration->isEqual( rFilter.maFieldName, rField.aCaption );
+}
+
+bool lcl_IsCondition( const sheet::MemberResult& rResultEntry, const ScDPGetPivotDataField& rFilter )
+{
+    //! handle numeric conditions?
+    return ScGlobal::pTransliteration->isEqual( rResultEntry.Name, rFilter.maValStr );
+}
+
+bool lcl_CheckPageField( const ScDPOutLevelData& rField,
+                        const std::vector< ScDPGetPivotDataField >& rFilters,
+                        std::vector< BOOL >& rFilterUsed )
+{
+    for (SCSIZE nFilterPos = 0; nFilterPos < rFilters.size(); ++nFilterPos)
+    {
+        if ( lcl_IsNamedCategoryField( rFilters[nFilterPos], rField ) )
+        {
+            rFilterUsed[nFilterPos] = TRUE;
+
+            // page field result is empty or the selection as single entry (see lcl_GetSelectedPageAsResult)
+            if ( rField.aResult.getLength() == 1 &&
+                 lcl_IsCondition( rField.aResult[0], rFilters[nFilterPos] ) )
+            {
+                return true;        // condition matches page selection
+            }
+            else
+            {
+                return false;       // no page selection or different entry
+            }
+        }
+    }
+
+    return true;    // valid if the page field doesn't have a filter
+}
+
+uno::Sequence<sheet::GeneralFunction> lcl_GetSubTotals(
+        const uno::Reference<sheet::XDimensionsSupplier>& xSource, const ScDPOutLevelData& rField )
+{
+    uno::Sequence<sheet::GeneralFunction> aSubTotals;
+
+    uno::Reference<sheet::XHierarchiesSupplier> xHierSupp;
+    uno::Reference<container::XNameAccess> xDimsName = xSource->getDimensions();
+    uno::Reference<container::XIndexAccess> xIntDims = new ScNameToIndexAccess( xDimsName );
+    sal_Int32 nIntCount = xIntDims->getCount();
+    if ( rField.nDim < nIntCount )
+    {
+        uno::Reference<uno::XInterface> xIntDim = ScUnoHelpFunctions::AnyToInterface(
+                                    xIntDims->getByIndex( rField.nDim ) );
+        xHierSupp = uno::Reference<sheet::XHierarchiesSupplier>( xIntDim, uno::UNO_QUERY );
+    }
+    DBG_ASSERT( xHierSupp.is(), "dimension not found" );
+
+    sal_Int32 nHierCount = 0;
+    uno::Reference<container::XIndexAccess> xHiers;
+    if ( xHierSupp.is() )
+    {
+        uno::Reference<container::XNameAccess> xHiersName = xHierSupp->getHierarchies();
+        xHiers = new ScNameToIndexAccess( xHiersName );
+        nHierCount = xHiers->getCount();
+    }
+    uno::Reference<uno::XInterface> xHier;
+    if ( rField.nHier < nHierCount )
+        xHier = ScUnoHelpFunctions::AnyToInterface( xHiers->getByIndex( rField.nHier ) );
+    DBG_ASSERT( xHier.is(), "hierarchy not found" );
+
+    sal_Int32 nLevCount = 0;
+    uno::Reference<container::XIndexAccess> xLevels;
+    uno::Reference<sheet::XLevelsSupplier> xLevSupp( xHier, uno::UNO_QUERY );
+    if ( xLevSupp.is() )
+    {
+        uno::Reference<container::XNameAccess> xLevsName = xLevSupp->getLevels();
+        xLevels = new ScNameToIndexAccess( xLevsName );
+        nLevCount = xLevels->getCount();
+    }
+    uno::Reference<uno::XInterface> xLevel;
+    if ( rField.nLevel < nLevCount )
+        xLevel = ScUnoHelpFunctions::AnyToInterface( xLevels->getByIndex( rField.nLevel ) );
+    DBG_ASSERT( xLevel.is(), "level not found" );
+
+    uno::Reference<beans::XPropertySet> xLevelProp( xLevel, uno::UNO_QUERY );
+    if ( xLevelProp.is() )
+    {
+        try
+        {
+            uno::Any aValue = xLevelProp->getPropertyValue( rtl::OUString::createFromAscii(DP_PROP_SUBTOTALS) );
+            aValue >>= aSubTotals;
+        }
+        catch(uno::Exception&)
+        {
+        }
+    }
+
+    return aSubTotals;
+}
+
+void lcl_FilterInclude( std::vector< BOOL >& rResult, std::vector< sal_Int32 >& rSubtotal,
+                        const ScDPOutLevelData& rField,
+                        const std::vector< ScDPGetPivotDataField >& rFilters,
+                        std::vector< BOOL >& rFilterUsed,
+                        bool& rBeforeDataLayout,
+                        sal_Int32 nGrandTotals, sal_Int32 nDataLayoutIndex,
+                        const std::vector<String>& rDataNames, const std::vector<String>& rGivenNames,
+                        const ScDPGetPivotDataField& rTarget, const uno::Reference<sheet::XDimensionsSupplier>& xSource )
+{
+    // returns true if a filter was given for the field
+
+    DBG_ASSERT( rFilters.size() == rFilterUsed.size(), "wrong size" );
+
+    const bool bIsDataLayout = ( rField.nDim == nDataLayoutIndex );
+    if (bIsDataLayout)
+        rBeforeDataLayout = false;
+
+    bool bHasFilter = false;
+    ScDPGetPivotDataField aFilter;
+    if ( !bIsDataLayout )          // selection of data field is handled separately
+    {
+        for (SCSIZE nFilterPos = 0; nFilterPos < rFilters.size() && !bHasFilter; ++nFilterPos)
+        {
+            if ( lcl_IsNamedCategoryField( rFilters[nFilterPos], rField ) )
+            {
+                aFilter = rFilters[nFilterPos];
+                rFilterUsed[nFilterPos] = TRUE;
+                bHasFilter = true;
+            }
+        }
+    }
+
+    bool bHasFunc = bHasFilter && aFilter.meFunction != sheet::GeneralFunction_NONE;
+
+    uno::Sequence<sheet::GeneralFunction> aSubTotals;
+    if ( !bIsDataLayout )
+        aSubTotals = lcl_GetSubTotals( xSource, rField );
+    bool bManualSub = ( aSubTotals.getLength() > 0 && aSubTotals[0] != sheet::GeneralFunction_AUTO );
+
+    const uno::Sequence<sheet::MemberResult>& rSequence = rField.aResult;
+    const sheet::MemberResult* pArray = rSequence.getConstArray();
+    sal_Int32 nSize = rSequence.getLength();
+
+    DBG_ASSERT( (sal_Int32)rResult.size() == nSize, "Number of fields do not match result count" );
+
+    sal_Int32 nContCount = 0;
+    sal_Int32 nSubTotalCount = 0;
+    sheet::MemberResult aPrevious;
+    for( sal_Int32 j=0; j < nSize; j++ )
+    {
+        sheet::MemberResult aResultEntry = pArray[j];
+        if ( aResultEntry.Flags & sheet::MemberResultFlags::CONTINUE )
+        {
+            aResultEntry = aPrevious;
+            ++nContCount;
+        }
+        else if ( ( aResultEntry.Flags & sheet::MemberResultFlags::SUBTOTAL ) == 0 )
+        {
+            // count the CONTINUE entries before a SUBTOTAL
+            nContCount = 0;
+        }
+
+        if ( j >= nSize - nGrandTotals )
+        {
+            // mark as subtotal for the preceding data
+            if ( ( aResultEntry.Flags & sheet::MemberResultFlags::SUBTOTAL ) != 0 )
+            {
+                rSubtotal[j] = nSize - nGrandTotals;
+
+                if ( rResult[j] && nGrandTotals > 1 )
+                {
+                    // grand total is always automatic
+                    sal_Int32 nDataPos = j - ( nSize - nGrandTotals );
+                    DBG_ASSERT( nDataPos < (sal_Int32)rDataNames.size(), "wrong data count" );
+                    String aSourceName( rDataNames[nDataPos] );     // vector contains source names
+                    String aGivenName( rGivenNames[nDataPos] );
+
+                    rResult[j] = lcl_IsNamedDataField( rTarget, aSourceName, aGivenName );
+                }
+            }
+
+            // treat "grand total" columns/rows as empty description, as if they were marked
+            // in a previous field
+
+            DBG_ASSERT( ( aResultEntry.Flags &
+                            ( sheet::MemberResultFlags::HASMEMBER | sheet::MemberResultFlags::SUBTOTAL ) ) == 0 ||
+                        ( aResultEntry.Flags &
+                            ( sheet::MemberResultFlags::HASMEMBER | sheet::MemberResultFlags::SUBTOTAL ) ) ==
+                                ( sheet::MemberResultFlags::HASMEMBER | sheet::MemberResultFlags::SUBTOTAL ),
+                        "non-subtotal member found in grand total result" );
+            aResultEntry.Flags = 0;
+        }
+
+        // mark subtotals (not grand total) for preceding data (assume CONTINUE is set)
+        if ( ( aResultEntry.Flags & sheet::MemberResultFlags::SUBTOTAL ) != 0 )
+        {
+            rSubtotal[j] = nContCount + 1 + nSubTotalCount;
+
+            if ( rResult[j] )
+            {
+                if ( bManualSub )
+                {
+                    if ( rBeforeDataLayout )
+                    {
+                        // manual subtotals and several data fields
+
+                        sal_Int32 nDataCount = rDataNames.size();
+                        sal_Int32 nFuncPos = nSubTotalCount / nDataCount;       // outer order: subtotal functions
+                        sal_Int32 nDataPos = nSubTotalCount % nDataCount;       // inner order: data fields
+
+                        String aSourceName( rDataNames[nDataPos] );             // vector contains source names
+                        String aGivenName( rGivenNames[nDataPos] );
+
+                        DBG_ASSERT( nFuncPos < aSubTotals.getLength(), "wrong subtotal count" );
+                        rResult[j] = lcl_IsNamedDataField( rTarget, aSourceName, aGivenName ) &&
+                                     aSubTotals[nFuncPos] == aFilter.meFunction;
+                    }
+                    else
+                    {
+                        // manual subtotals for a single data field
+
+                        DBG_ASSERT( nSubTotalCount < aSubTotals.getLength(), "wrong subtotal count" );
+                        rResult[j] = ( aSubTotals[nSubTotalCount] == aFilter.meFunction );
+                    }
+                }
+                else    // automatic subtotals
+                {
+                    if ( rBeforeDataLayout )
+                    {
+                        DBG_ASSERT( nSubTotalCount < (sal_Int32)rDataNames.size(), "wrong data count" );
+                        String aSourceName( rDataNames[nSubTotalCount] );       // vector contains source names
+                        String aGivenName( rGivenNames[nSubTotalCount] );
+
+                        rResult[j] = lcl_IsNamedDataField( rTarget, aSourceName, aGivenName );
+                    }
+
+                    // if a function was specified, automatic subtotals never match
+                    if ( bHasFunc )
+                        rResult[j] = FALSE;
+                }
+            }
+
+            ++nSubTotalCount;
+        }
+        else
+            nSubTotalCount = 0;
+
+        if( rResult[j] )
+        {
+            if ( bIsDataLayout )
+            {
+                if ( ( aResultEntry.Flags & sheet::MemberResultFlags::HASMEMBER ) != 0 )
+                {
+                    // Asterisks are added in ScDPSaveData::WriteToSource to create unique names.
+                    //! preserve original name there?
+                    String aSourceName( aResultEntry.Name );
+                    aSourceName.EraseTrailingChars( '*' );
+
+                    String aGivenName( aResultEntry.Caption );  //! Should use a stored name when available
+                    aGivenName.EraseLeadingChars( '\'' );
+
+                    rResult[j] = lcl_IsNamedDataField( rTarget, aSourceName, aGivenName );
+                }
+            }
+            else if ( bHasFilter )
+            {
+                // name must match (simple value or subtotal)
+                rResult[j] = ( ( aResultEntry.Flags & sheet::MemberResultFlags::HASMEMBER ) != 0 ) &&
+                             lcl_IsCondition( aResultEntry, aFilter );
+
+                // if a function was specified, simple (non-subtotal) values never match
+                if ( bHasFunc && nSubTotalCount == 0 )
+                    rResult[j] = FALSE;
+            }
+            // if no condition is given, keep the columns/rows included
+        }
+        aPrevious = aResultEntry;
+    }
+}
+
+void lcl_StripSubTotals( std::vector< BOOL >& rResult, const std::vector< sal_Int32 >& rSubtotal )
+{
+    sal_Int32 nSize = rResult.size();
+    DBG_ASSERT( (sal_Int32)rSubtotal.size() == nSize, "sizes don't match" );
+
+    for (sal_Int32 nPos=0; nPos<nSize; nPos++)
+        if ( rResult[nPos] && rSubtotal[nPos] )
+        {
+            // if a subtotal is included, clear the result flag for the columns/rows that the subtotal includes
+            sal_Int32 nStart = nPos - rSubtotal[nPos];
+            DBG_ASSERT( nStart >= 0, "invalid subtotal count" );
+
+            for (sal_Int32 nPrev = nStart; nPrev < nPos; nPrev++)
+                rResult[nPrev] = FALSE;
+        }
+}
+
+String lcl_GetDataFieldName( const String& rSourceName, sheet::GeneralFunction eFunc )
+{
+    USHORT nStrId = 0;
+    switch ( eFunc )
+    {
+        case sheet::GeneralFunction_SUM:        nStrId = STR_FUN_TEXT_SUM;      break;
+        case sheet::GeneralFunction_COUNT:
+        case sheet::GeneralFunction_COUNTNUMS:  nStrId = STR_FUN_TEXT_COUNT;    break;
+        case sheet::GeneralFunction_AVERAGE:    nStrId = STR_FUN_TEXT_AVG;      break;
+        case sheet::GeneralFunction_MAX:        nStrId = STR_FUN_TEXT_MAX;      break;
+        case sheet::GeneralFunction_MIN:        nStrId = STR_FUN_TEXT_MIN;      break;
+        case sheet::GeneralFunction_PRODUCT:    nStrId = STR_FUN_TEXT_PRODUCT;  break;
+        case sheet::GeneralFunction_STDEV:
+        case sheet::GeneralFunction_STDEVP:     nStrId = STR_FUN_TEXT_STDDEV;   break;
+        case sheet::GeneralFunction_VAR:
+        case sheet::GeneralFunction_VARP:       nStrId = STR_FUN_TEXT_VAR;      break;
+        case sheet::GeneralFunction_NONE:
+        case sheet::GeneralFunction_AUTO:
+        default:
+        {
+            DBG_ERRORFILE("wrong function");
+        }
+    }
+    if ( !nStrId )
+        return String();
+
+    String aRet( ScGlobal::GetRscString( nStrId ) );
+    aRet.AppendAscii(RTL_CONSTASCII_STRINGPARAM( " - " ));
+    aRet.Append( rSourceName );
+    return aRet;
+}
+
+// static
+void ScDPOutput::GetDataDimensionNames( String& rSourceName, String& rGivenName,
+                                        const uno::Reference<uno::XInterface>& xDim )
+{
+    uno::Reference<beans::XPropertySet> xDimProp( xDim, uno::UNO_QUERY );
+    uno::Reference<container::XNamed> xDimName( xDim, uno::UNO_QUERY );
+    if ( xDimProp.is() && xDimName.is() )
+    {
+        // Asterisks are added in ScDPSaveData::WriteToSource to create unique names.
+        //! preserve original name there?
+        rSourceName = xDimName->getName();
+        rSourceName.EraseTrailingChars( '*' );
+
+        // Generate "given name" the same way as in dptabres.
+        //! Should use a stored name when available
+
+        sheet::GeneralFunction eFunc = (sheet::GeneralFunction)ScUnoHelpFunctions::GetEnumProperty(
+                                xDimProp, rtl::OUString::createFromAscii(DP_PROP_FUNCTION),
+                                sheet::GeneralFunction_NONE );
+        rGivenName = lcl_GetDataFieldName( rSourceName, eFunc );
+    }
+}
+
+void lcl_GetTableVars( sal_Int32& rGrandTotalCols, sal_Int32& rGrandTotalRows, sal_Int32& rDataLayoutIndex,
+                             std::vector<String>& rDataNames, std::vector<String>& rGivenNames,
+                             sheet::DataPilotFieldOrientation& rDataOrient,
+                             const uno::Reference<sheet::XDimensionsSupplier>& xSource )
+{
+    rDataLayoutIndex = -1;  // invalid
+    rGrandTotalCols = 0;
+    rGrandTotalRows = 0;
+    rDataOrient = sheet::DataPilotFieldOrientation_HIDDEN;
+
+    uno::Reference<beans::XPropertySet> xSrcProp( xSource, uno::UNO_QUERY );
+    BOOL bColGrand = ScUnoHelpFunctions::GetBoolProperty( xSrcProp,
+                                         rtl::OUString::createFromAscii(DP_PROP_COLUMNGRAND) );
+    if ( bColGrand )
+        rGrandTotalCols = 1;    // default if data layout not in columns
+
+    BOOL bRowGrand = ScUnoHelpFunctions::GetBoolProperty( xSrcProp,
+                                         rtl::OUString::createFromAscii(DP_PROP_ROWGRAND) );
+    if ( bRowGrand )
+        rGrandTotalRows = 1;    // default if data layout not in rows
+
+    if ( xSource.is() )
+    {
+        // find index and orientation of "data layout" dimension, count data dimensions
+
+        sal_Int32 nDataCount = 0;
+
+        uno::Reference<container::XIndexAccess> xDims = new ScNameToIndexAccess( xSource->getDimensions() );
+        long nDimCount = xDims->getCount();
+        for (long nDim=0; nDim<nDimCount; nDim++)
+        {
+            uno::Reference<uno::XInterface> xDim =
+                    ScUnoHelpFunctions::AnyToInterface( xDims->getByIndex(nDim) );
+            uno::Reference<beans::XPropertySet> xDimProp( xDim, uno::UNO_QUERY );
+            if ( xDimProp.is() )
+            {
+                sheet::DataPilotFieldOrientation eDimOrient =
+                    (sheet::DataPilotFieldOrientation) ScUnoHelpFunctions::GetEnumProperty(
+                        xDimProp, rtl::OUString::createFromAscii(DP_PROP_ORIENTATION),
+                        sheet::DataPilotFieldOrientation_HIDDEN );
+                if ( ScUnoHelpFunctions::GetBoolProperty( xDimProp,
+                                         rtl::OUString::createFromAscii(DP_PROP_ISDATALAYOUT) ) )
+                {
+                    rDataLayoutIndex = nDim;
+                    rDataOrient = eDimOrient;
+                }
+                if ( eDimOrient == sheet::DataPilotFieldOrientation_DATA )
+                {
+                    String aSourceName;
+                    String aGivenName;
+                    ScDPOutput::GetDataDimensionNames( aSourceName, aGivenName, xDim );
+                    rDataNames.push_back( aSourceName );
+                    rGivenNames.push_back( aGivenName );
+
+                    ++nDataCount;
+                }
+            }
+        }
+
+        if ( ( rDataOrient == sheet::DataPilotFieldOrientation_COLUMN ) && bColGrand )
+            rGrandTotalCols = nDataCount;
+        else if ( ( rDataOrient == sheet::DataPilotFieldOrientation_ROW ) && bRowGrand )
+            rGrandTotalRows = nDataCount;
+    }
+}
+
+// Returns TRUE on success and stores the result in rTarget
+// Returns FALSE if rFilters or rTarget describes something that is not visible
+BOOL ScDPOutput::GetPivotData( ScDPGetPivotDataField& rTarget,
+                               const std::vector< ScDPGetPivotDataField >& rFilters )
+{
+    CalcSizes();
+
+    // need to know about grand total columns/rows:
+    sal_Int32 nGrandTotalCols;
+    sal_Int32 nGrandTotalRows;
+    sal_Int32 nDataLayoutIndex;
+    std::vector<String> aDataNames;
+    std::vector<String> aGivenNames;
+    sheet::DataPilotFieldOrientation eDataOrient;
+    lcl_GetTableVars( nGrandTotalCols, nGrandTotalRows, nDataLayoutIndex, aDataNames, aGivenNames, eDataOrient, xSource );
+
+    if ( aDataNames.empty() )
+        return FALSE;               // incomplete table without data fields -> no result
+
+    if ( eDataOrient == sheet::DataPilotFieldOrientation_HIDDEN )
+    {
+        // no data layout field -> single data field -> must match the selected field in rTarget
+
+        DBG_ASSERT( aDataNames.size() == 1, "several data fields but no data layout field" );
+        if ( !lcl_IsNamedDataField( rTarget, aDataNames[0], aGivenNames[0] ) )
+            return FALSE;
+    }
+
+    std::vector< BOOL > aIncludeCol( nColCount, TRUE );
+    std::vector< sal_Int32 > aSubtotalCol( nColCount, 0 );
+    std::vector< BOOL > aIncludeRow( nRowCount, TRUE );
+    std::vector< sal_Int32 > aSubtotalRow( nRowCount, 0 );
+
+    std::vector< BOOL > aFilterUsed( rFilters.size(), FALSE );
+
+    long nField;
+    long nCol;
+    long nRow;
+    bool bBeforeDataLayout;
+
+    // look in column fields
+
+    bBeforeDataLayout = ( eDataOrient == sheet::DataPilotFieldOrientation_COLUMN );
+    for (nField=0; nField<nColFieldCount; nField++)
+        lcl_FilterInclude( aIncludeCol, aSubtotalCol, pColFields[nField], rFilters, aFilterUsed, bBeforeDataLayout,
+                           nGrandTotalCols, nDataLayoutIndex, aDataNames, aGivenNames, rTarget, xSource );
+
+    // look in row fields
+
+    bBeforeDataLayout = ( eDataOrient == sheet::DataPilotFieldOrientation_ROW );
+    for (nField=0; nField<nRowFieldCount; nField++)
+        lcl_FilterInclude( aIncludeRow, aSubtotalRow, pRowFields[nField], rFilters, aFilterUsed, bBeforeDataLayout,
+                           nGrandTotalRows, nDataLayoutIndex, aDataNames, aGivenNames, rTarget, xSource );
+
+    // page fields
+
+    for (nField=0; nField<nPageFieldCount; nField++)
+        if ( !lcl_CheckPageField( pPageFields[nField], rFilters, aFilterUsed ) )
+            return FALSE;
+
+    // all filter fields must be used
+    for (SCSIZE nFilter=0; nFilter<aFilterUsed.size(); nFilter++)
+        if (!aFilterUsed[nFilter])
+            return FALSE;
+
+    lcl_StripSubTotals( aIncludeCol, aSubtotalCol );
+    lcl_StripSubTotals( aIncludeRow, aSubtotalRow );
+
+    long nColPos = 0;
+    long nColIncluded = 0;
+    for (nCol=0; nCol<nColCount; nCol++)
+        if (aIncludeCol[nCol])
+        {
+            nColPos = nCol;
+            ++nColIncluded;
+        }
+
+    long nRowPos = 0;
+    long nRowIncluded = 0;
+    for (nRow=0; nRow<nRowCount; nRow++)
+        if (aIncludeRow[nRow])
+        {
+            nRowPos = nRow;
+            ++nRowIncluded;
+        }
+
+    if ( nColIncluded != 1 || nRowIncluded != 1 )
+        return FALSE;
+
+    const uno::Sequence<sheet::DataResult>& rDataRow = aData[nRowPos];
+    if ( nColPos >= rDataRow.getLength() )
+        return FALSE;
+
+    const sheet::DataResult& rResult = rDataRow[nColPos];
+    if ( rResult.Flags & sheet::DataResultFlags::ERROR )
+        return FALSE;                                       //! different error?
+
+    rTarget.mbValIsStr = FALSE;
+    rTarget.mnValNum = rResult.Value;
+
+    return TRUE;
+}
+
 BOOL ScDPOutput::IsFilterButton( const ScAddress& rPos )
 {
 	SCCOL nCol = rPos.Col();
Index: sc/source/core/inc/interpre.hxx
===================================================================
RCS file: /cvs/sc/sc/source/core/inc/interpre.hxx,v
retrieving revision 1.27
retrieving revision 1.27.54.1
diff -u -w -p -r1.27 -r1.27.54.1
--- sc/source/core/inc/interpre.hxx	19 Dec 2006 13:16:55 -0000	1.27
+++ sc/source/core/inc/interpre.hxx	19 Apr 2007 17:54:55 -0000	1.27.54.1
@@ -452,6 +452,7 @@ BOOL SetSbxVariable( SbxVariable* pVar, 
 void ScErrorType();
 void ScDBArea();
 void ScColRowNameAuto();
+void ScGetPivotData();
 void ScHyperLink();
 void ScBahtText();
 void ScCalcTeam();
Index: sc/source/core/src/compiler.src
===================================================================
RCS file: /cvs/sc/sc/source/core/src/compiler.src,v
retrieving revision 1.51
retrieving revision 1.50.110.2
diff -u -w -p -r1.51 -r1.50.110.2
--- sc/source/core/src/compiler.src	19 Apr 2007 16:23:51 -0000	1.51
+++ sc/source/core/src/compiler.src	23 Apr 2007 09:04:14 -0000	1.50.110.2
@@ -1152,6 +1152,10 @@ Resource RID_SC_FUNCTION_NAMES
     {
         Text [ en-US ] = "BAHTTEXT";
     };
+    String SC_OPCODE_GET_PIVOT_DATA
+    {
+        Text [ en-US ] = "GETPIVOTDATA";
+    };
 };
 Resource RID_SC_FUNCTION_NAMES_ENGLISH
 {
@@ -1449,5 +1453,6 @@ Resource RID_SC_FUNCTION_NAMES_ENGLISH
 	String SC_OPCODE_HYPERLINK { Text = "HYPERLINK" ; };
     String SC_OPCODE_INFO { Text = "INFO" ; };
     String SC_OPCODE_BAHTTEXT { Text = "BAHTTEXT" ; };
+    String SC_OPCODE_GET_PIVOT_DATA { Text = "GETPIVOTDATA" ; };
 };
 
Index: sc/source/core/tool/interpr2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr2.cxx,v
retrieving revision 1.31
retrieving revision 1.29.54.4
diff -u -w -p -r1.31 -r1.29.54.4
--- sc/source/core/tool/interpr2.cxx	26 Apr 2007 07:38:41 -0000	1.31
+++ sc/source/core/tool/interpr2.cxx	8 May 2007 17:07:50 -0000	1.29.54.4
@@ -61,6 +61,7 @@
 #include "unitconv.hxx"
 #include "globstr.hrc"
 #include "hints.hxx"
+#include "dpobject.hxx"
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -2492,3 +2493,95 @@ void ScInterpreter::ScBahtText()
 
 // ============================================================================
 
+void ScInterpreter::ScGetPivotData()
+{
+    BYTE nParamCount = GetByte();
+
+    if ( MustHaveParamCount( nParamCount, 2, 30 ) )
+    {
+        // there must be an even number of args
+        //      target, ref, then field/item pairs
+        if( (nParamCount % 2) == 1)
+            goto failed;
+
+        bool bOldSyntax = false;
+        if ( nParamCount == 2 )
+        {
+            // if the first parameter is a ref, assume old syntax
+            StackVar eFirstType = GetStackType( 2 );
+            if ( eFirstType == svSingleRef || eFirstType == svDoubleRef )
+                bOldSyntax = true;
+        }
+
+        ScDPGetPivotDataField aTarget;                  // target field, and returns result
+        std::vector< ScDPGetPivotDataField > aFilters;
+        String aFilterList;
+        if ( bOldSyntax )
+            aFilterList = GetString();      // old syntax: second parameter is list of constraints
+        else
+        {
+            // new syntax: separate name/value pairs
+
+            USHORT nFilterCount = nParamCount / 2 - 1;
+            aFilters.resize( nFilterCount );
+
+            USHORT i = nFilterCount;
+            while( i-- > 0 )
+            {
+                //! should allow numeric constraint values
+                aFilters[i].mbValIsStr = TRUE;
+                aFilters[i].maValStr = GetString();
+                
+                aFilters[i].maFieldName = GetString();
+            }
+        }
+
+        // common to both syntaxes: a reference to the data pilot table
+
+        ScRange aBlock;
+        switch ( GetStackType() )
+        {
+            case svDoubleRef :
+                PopDoubleRef( aBlock );
+                break;
+
+            case svSingleRef :
+                {
+                    ScAddress aAddr;
+                    PopSingleRef( aAddr );
+                    aBlock = aAddr;
+                    break;
+                }
+            default:
+                goto failed;
+        }
+        // NOTE : MS Excel docs claim to use the 'most recent' which is not
+        // exactly the same as what we do in ScDocument::GetDPAtBlock
+        // However we do need to use GetDPABlock
+        ScDPObject* pDPObj = pDok->GetDPAtBlock ( aBlock );
+        if( NULL == pDPObj)
+            goto failed;
+
+        if ( bOldSyntax )
+        {
+            // fill aFilters / aTarget from aFilterList string
+            if ( !pDPObj->ParseFilters( aTarget, aFilters, aFilterList ) )
+                goto failed;
+        }
+        else
+            aTarget.maFieldName = GetString();      // new syntax: first parameter is data field name
+
+        if( pDPObj->GetPivotData( aTarget, aFilters ) )
+        {
+            if( aTarget.mbValIsStr )
+                PushString( aTarget.maValStr );
+            else
+                PushDouble( aTarget.mnValNum );
+            return;
+        }
+    }
+
+failed :
+    SetError( errNoRef );
+}
+
Index: sc/source/core/tool/interpr4.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr4.cxx,v
retrieving revision 1.45
retrieving revision 1.44.54.2
diff -u -w -p -r1.45 -r1.44.54.2
--- sc/source/core/tool/interpr4.cxx	27 Feb 2007 12:16:42 -0000	1.45
+++ sc/source/core/tool/interpr4.cxx	23 Apr 2007 09:09:56 -0000	1.44.54.2
@@ -3544,6 +3544,7 @@ StackVar ScInterpreter::Interpret()
                 case ocInfo             : ScInfo();                     break;
                 case ocHyperLink        : ScHyperLink();                break;
                 case ocBahtText         : ScBahtText();                 break;
+                case ocGetPivotData     : ScGetPivotData();             break;
                 case ocAnswer           : ScAnswer();                   break;
                 case ocTeam             : ScCalcTeam();                 break;
                 case ocTTT              : ScTTT();                      break;
Index: sc/source/core/tool/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/makefile.mk,v
retrieving revision 1.18
retrieving revision 1.18.48.1
diff -u -w -p -r1.18 -r1.18.48.1
--- sc/source/core/tool/makefile.mk	27 Feb 2007 12:17:15 -0000	1.18
+++ sc/source/core/tool/makefile.mk	24 Apr 2007 18:02:59 -0000	1.18.48.1
@@ -118,6 +118,7 @@ EXCEPTIONSFILES= \
         $(SLO)$/chartarr.obj \
         $(SLO)$/compiler.obj \
         $(SLO)$/interpr1.obj \
+        $(SLO)$/interpr2.obj \
         $(SLO)$/interpr3.obj \
         $(SLO)$/interpr4.obj \
         $(SLO)$/interpr5.obj \
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excimp8.cxx,v
retrieving revision 1.116
retrieving revision 1.116.74.1
diff -u -w -p -r1.116 -r1.116.74.1
--- sc/source/filter/excel/excimp8.cxx	22 Nov 2006 12:20:36 -0000	1.116
+++ sc/source/filter/excel/excimp8.cxx	25 Apr 2007 15:15:45 -0000	1.116.74.1
@@ -350,8 +350,8 @@ void ImportExcel8::PostDocLoad( void )
         }
     }
 
-	// building pivot tables
-    GetPivotTableManager().ConvertPivotTables();
+    // #i45843# Pivot tables are now handled outside of PostDocLoad, so they are available
+    // when formula cells are calculated, for the GETPIVOTDATA function.
 }
 
 
Index: sc/source/filter/excel/read.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/read.cxx,v
retrieving revision 1.66
retrieving revision 1.66.48.1
diff -u -w -p -r1.66 -r1.66.48.1
--- sc/source/filter/excel/read.cxx	27 Feb 2007 12:23:54 -0000	1.66
+++ sc/source/filter/excel/read.cxx	25 Apr 2007 15:15:45 -0000	1.66.48.1
@@ -1208,6 +1208,11 @@ FltError ImportExcel8::Read( void )
 
     if( eLastErr == eERR_OK )
     {
+        // #i45843# Convert pivot tables before calculation, so they are available
+        // for the GETPIVOTDATA function.
+        if( GetBiff() == EXC_BIFF8 )
+            GetPivotTableManager().ConvertPivotTables();
+
         pD->CalcAfterLoad();
 
         pProgress.reset();
Index: sc/source/filter/excel/xlformula.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlformula.cxx,v
retrieving revision 1.19
retrieving revision 1.18.14.2
diff -u -w -p -r1.19 -r1.18.14.2
--- sc/source/filter/excel/xlformula.cxx	27 Feb 2007 12:28:54 -0000	1.19
+++ sc/source/filter/excel/xlformula.cxx	23 Apr 2007 09:22:32 -0000	1.18.14.2
@@ -347,6 +347,7 @@ const sal_Char* const EXC_FUNCNAME_BAHTT
 /** Functions new in BIFF8. Unsupported functions: PHONETIC. */
 static const XclFunctionInfo saFuncTable_8[] =
 {
+    { ocGetPivotData,       358,    2,  30, V, { V, R, V }, 0, 0 },
     { ocHyperLink,          359,    1,  2,  V, { V }, 0, 0 },
     { ocNoName,             360,    1,  1,  V, { R }, EXC_FUNCFLAG_IMPORTONLY, 0 },    // PHONETIC
     { ocAverageA,           361,    1,  30, V, { R }, 0, 0 },
Index: sc/source/ui/src/scfuncs.src
===================================================================
RCS file: /cvs/sc/sc/source/ui/src/scfuncs.src,v
retrieving revision 1.90
retrieving revision 1.89.54.3
diff -u -w -p -r1.90 -r1.89.54.3
--- sc/source/ui/src/scfuncs.src	19 Apr 2007 16:46:47 -0000	1.90
+++ sc/source/ui/src/scfuncs.src	8 May 2007 16:56:32 -0000	1.89.54.3
@@ -7494,6 +7494,44 @@ Resource RID_SC_FUNCTION_DESCRIPTIONS2
 			Text [ en-US ] = "Cell Text";
 		};
 	};
+     // -=*# Resource for function GETPIVOTDATA #*=-
+    Resource SC_OPCODE_GET_PIVOT_DATA
+    {
+        String 1 // Description
+        {
+            Text [ en-US ] = "Extracts value(s) from a DataPilot table.";
+        };
+        ExtraData =
+        {
+            ID_FUNCTION_GRP_TABLE;
+            U2S( HID_FUNC_GETPIVOTDATA );
+            VAR_ARGS+2;      0; 0;  1;
+        };
+        String 2 // Name of Parameter 1
+        {
+            Text [ en-US ] = "Data Field";
+        };
+        String 3 // Description of Parameter 1
+        {
+            Text [ en-US ] = "The name of the data pilot field to extract.";
+        };
+        String 4 // Name of Parameter 2
+        {
+            Text [ en-US ] = "DataPilot";
+        };
+        String 5 // Description of Parameter 2
+        {
+            Text [ en-US ] = "A reference to a cell or range in the DataPilot table.";
+        };
+        String 6 // Name of Parameter 3
+        {
+            Text [ en-US ] = "Field Name / Item";
+        };
+        String 7 // Description of Parameter 3
+        {
+            Text [ en-US ] = "Field name/value pair to filter the target data.";
+        };
+    };
      // -=*# Resource for function BAHTTEXT #*=-
     Resource SC_OPCODE_BAHTTEXT
     {
Index: sc/util/hidother.src
===================================================================
RCS file: /cvs/sc/sc/util/hidother.src,v
retrieving revision 1.24
retrieving revision 1.24.182.1
diff -u -w -p -r1.24 -r1.24.182.1
--- sc/util/hidother.src	10 Jul 2006 12:46:32 -0000	1.24
+++ sc/util/hidother.src	19 Apr 2007 17:54:59 -0000	1.24.182.1
@@ -356,6 +356,7 @@ hidspecial HID_FUNC_DDE		 { HelpID = HID
 hidspecial HID_FUNC_TABELLE		 { HelpID = HID_FUNC_TABELLE; };
 hidspecial HID_FUNC_TABELLEN		 { HelpID = HID_FUNC_TABELLEN; };
 hidspecial HID_FUNC_HYPERLINK		 { HelpID = HID_FUNC_HYPERLINK; };
+hidspecial HID_FUNC_GETPIVOTDATA { HelpID = HID_FUNC_GETPIVOTDATA; };
 hidspecial HID_FUNC_CODE		 { HelpID = HID_FUNC_CODE; };
 hidspecial HID_FUNC_DM		 { HelpID = HID_FUNC_DM; };
 hidspecial HID_FUNC_ZEICHEN		 { HelpID = HID_FUNC_ZEICHEN; };
